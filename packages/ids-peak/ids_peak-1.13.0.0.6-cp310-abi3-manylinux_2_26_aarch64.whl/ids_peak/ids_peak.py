# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""
The IDS peak genericAPI is a library that unites GenTL and GenApi. In some places, it also introduces some extra functionality.
The purpose of this extra functionality is to increase the usability and comfort of the standard GenAPI.
"""


from __future__ import annotations

from typing import Any, Sequence, Union, TYPE_CHECKING
import ids_peak_common.exceptions
from .exceptions import *

if TYPE_CHECKING:
    from .image_view import ImageView



from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ids_peak_python_interface
else:
    import _ids_peak_python_interface

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _ids_peak_python_interface.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_SwigPyIterator

    def value(self) -> "Any":
        return _ids_peak_python_interface.SwigPyIterator_value(self)

    def incr(self, n: "int"=1) -> "SwigPyIterator":
        return _ids_peak_python_interface.SwigPyIterator_incr(self, n)

    def decr(self, n: "int"=1) -> "SwigPyIterator":
        return _ids_peak_python_interface.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "int":
        return _ids_peak_python_interface.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _ids_peak_python_interface.SwigPyIterator_equal(self, x)

    def copy(self) -> "SwigPyIterator":
        return _ids_peak_python_interface.SwigPyIterator_copy(self)

    def next(self) -> "Any":
        return _ids_peak_python_interface.SwigPyIterator_next(self)

    def __next__(self) -> "Any":
        return _ids_peak_python_interface.SwigPyIterator___next__(self)

    def previous(self) -> "Any":
        return _ids_peak_python_interface.SwigPyIterator_previous(self)

    def advance(self, n: "int") -> "SwigPyIterator":
        return _ids_peak_python_interface.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _ids_peak_python_interface.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _ids_peak_python_interface.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "int") -> "SwigPyIterator":
        return _ids_peak_python_interface.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "int") -> "SwigPyIterator":
        return _ids_peak_python_interface.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "int") -> "SwigPyIterator":
        return _ids_peak_python_interface.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "int":
        return _ids_peak_python_interface.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _ids_peak_python_interface:
_ids_peak_python_interface.SwigPyIterator_swigregister(SwigPyIterator)
class NodeChangedCallbackBase(object):
    r"""Base class for Changed"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_NodeChangedCallbackBase

    def call(self, arg0: "Node") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.NodeChangedCallbackBase_call(self, arg0)
    unregister: "Any" = property(_ids_peak_python_interface.NodeChangedCallbackBase_unregister_get, _ids_peak_python_interface.NodeChangedCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == NodeChangedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.NodeChangedCallbackBase_swiginit(self, _ids_peak_python_interface.new_NodeChangedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_NodeChangedCallbackBase(self)
        return weakref.proxy(self)

# Register NodeChangedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.NodeChangedCallbackBase_swigregister(NodeChangedCallbackBase)
class SystemInterfaceFoundCallbackBase(object):
    r"""Base class for InterfaceFound"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_SystemInterfaceFoundCallbackBase

    def call(self, arg0: "InterfaceDescriptor") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.SystemInterfaceFoundCallbackBase_call(self, arg0)
    unregister: "Any" = property(_ids_peak_python_interface.SystemInterfaceFoundCallbackBase_unregister_get, _ids_peak_python_interface.SystemInterfaceFoundCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == SystemInterfaceFoundCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.SystemInterfaceFoundCallbackBase_swiginit(self, _ids_peak_python_interface.new_SystemInterfaceFoundCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_SystemInterfaceFoundCallbackBase(self)
        return weakref.proxy(self)

# Register SystemInterfaceFoundCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.SystemInterfaceFoundCallbackBase_swigregister(SystemInterfaceFoundCallbackBase)
class InterfaceDeviceFoundCallbackBase(object):
    r"""Base class for DeviceFound"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_InterfaceDeviceFoundCallbackBase

    def call(self, arg0: "DeviceDescriptor") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.InterfaceDeviceFoundCallbackBase_call(self, arg0)
    unregister: "Any" = property(_ids_peak_python_interface.InterfaceDeviceFoundCallbackBase_unregister_get, _ids_peak_python_interface.InterfaceDeviceFoundCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == InterfaceDeviceFoundCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.InterfaceDeviceFoundCallbackBase_swiginit(self, _ids_peak_python_interface.new_InterfaceDeviceFoundCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_InterfaceDeviceFoundCallbackBase(self)
        return weakref.proxy(self)

# Register InterfaceDeviceFoundCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.InterfaceDeviceFoundCallbackBase_swigregister(InterfaceDeviceFoundCallbackBase)
class InterfaceDeviceReconnectedCallbackBase(object):
    r"""Base class for DeviceReconnected"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_InterfaceDeviceReconnectedCallbackBase

    def call(self, arg0: "DeviceDescriptor", arg1: "DeviceReconnectInformation") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.InterfaceDeviceReconnectedCallbackBase_call(self, arg0, arg1)
    unregister: "Any" = property(_ids_peak_python_interface.InterfaceDeviceReconnectedCallbackBase_unregister_get, _ids_peak_python_interface.InterfaceDeviceReconnectedCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == InterfaceDeviceReconnectedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.InterfaceDeviceReconnectedCallbackBase_swiginit(self, _ids_peak_python_interface.new_InterfaceDeviceReconnectedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_InterfaceDeviceReconnectedCallbackBase(self)
        return weakref.proxy(self)

# Register InterfaceDeviceReconnectedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.InterfaceDeviceReconnectedCallbackBase_swigregister(InterfaceDeviceReconnectedCallbackBase)
class InterfaceDeviceDisconnectedCallbackBase(object):
    r"""Base class for DeviceDisconnected"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_InterfaceDeviceDisconnectedCallbackBase

    def call(self, arg0: "DeviceDescriptor") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.InterfaceDeviceDisconnectedCallbackBase_call(self, arg0)
    unregister: "Any" = property(_ids_peak_python_interface.InterfaceDeviceDisconnectedCallbackBase_unregister_get, _ids_peak_python_interface.InterfaceDeviceDisconnectedCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == InterfaceDeviceDisconnectedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.InterfaceDeviceDisconnectedCallbackBase_swiginit(self, _ids_peak_python_interface.new_InterfaceDeviceDisconnectedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_InterfaceDeviceDisconnectedCallbackBase(self)
        return weakref.proxy(self)

# Register InterfaceDeviceDisconnectedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.InterfaceDeviceDisconnectedCallbackBase_swigregister(InterfaceDeviceDisconnectedCallbackBase)
class InterfaceDeviceLostCallbackBase(object):
    r"""Base class for DeviceLost"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_InterfaceDeviceLostCallbackBase

    def call(self, arg0: "str") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.InterfaceDeviceLostCallbackBase_call(self, arg0)
    unregister: "Any" = property(_ids_peak_python_interface.InterfaceDeviceLostCallbackBase_unregister_get, _ids_peak_python_interface.InterfaceDeviceLostCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == InterfaceDeviceLostCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.InterfaceDeviceLostCallbackBase_swiginit(self, _ids_peak_python_interface.new_InterfaceDeviceLostCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_InterfaceDeviceLostCallbackBase(self)
        return weakref.proxy(self)

# Register InterfaceDeviceLostCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.InterfaceDeviceLostCallbackBase_swigregister(InterfaceDeviceLostCallbackBase)
class DeviceDescriptorDeviceOpenedCallbackBase(object):
    r"""Base class for DeviceOpened"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceDescriptorDeviceOpenedCallbackBase

    def call(self, arg0: "Device") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.DeviceDescriptorDeviceOpenedCallbackBase_call(self, arg0)
    unregister: "Any" = property(_ids_peak_python_interface.DeviceDescriptorDeviceOpenedCallbackBase_unregister_get, _ids_peak_python_interface.DeviceDescriptorDeviceOpenedCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == DeviceDescriptorDeviceOpenedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceDescriptorDeviceOpenedCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceDescriptorDeviceOpenedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceDescriptorDeviceOpenedCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceDescriptorDeviceOpenedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceDescriptorDeviceOpenedCallbackBase_swigregister(DeviceDescriptorDeviceOpenedCallbackBase)
class InterfaceDeviceListChangedCallbackBase(object):
    r"""Base class for DeviceListChanged"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_InterfaceDeviceListChangedCallbackBase

    def call(self) -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.InterfaceDeviceListChangedCallbackBase_call(self)
    unregister: "Any" = property(_ids_peak_python_interface.InterfaceDeviceListChangedCallbackBase_unregister_get, _ids_peak_python_interface.InterfaceDeviceListChangedCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == InterfaceDeviceListChangedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.InterfaceDeviceListChangedCallbackBase_swiginit(self, _ids_peak_python_interface.new_InterfaceDeviceListChangedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_InterfaceDeviceListChangedCallbackBase(self)
        return weakref.proxy(self)

# Register InterfaceDeviceListChangedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.InterfaceDeviceListChangedCallbackBase_swigregister(InterfaceDeviceListChangedCallbackBase)
class FirmwareUpdateProgressObserverUpdateStartedCallbackBase(object):
    r"""Base class for UpdateStarted"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdateProgressObserverUpdateStartedCallbackBase

    def call(self, arg0: "FirmwareUpdateInformation", arg1: "int") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStartedCallbackBase_call(self, arg0, arg1)
    unregister: "Any" = property(_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStartedCallbackBase_unregister_get, _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStartedCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == FirmwareUpdateProgressObserverUpdateStartedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStartedCallbackBase_swiginit(self, _ids_peak_python_interface.new_FirmwareUpdateProgressObserverUpdateStartedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_FirmwareUpdateProgressObserverUpdateStartedCallbackBase(self)
        return weakref.proxy(self)

# Register FirmwareUpdateProgressObserverUpdateStartedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStartedCallbackBase_swigregister(FirmwareUpdateProgressObserverUpdateStartedCallbackBase)
class FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase(object):
    r"""Base class for UpdateStepStarted"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase

    def call(self, arg0: "int", arg1: "int", arg2: "str") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase_call(self, arg0, arg1, arg2)
    unregister: "Any" = property(_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase_unregister_get, _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase_swiginit(self, _ids_peak_python_interface.new_FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase(self)
        return weakref.proxy(self)

# Register FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase_swigregister(FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase)
class FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase(object):
    r"""Base class for UpdateStepProgressChanged"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase

    def call(self, arg0: "int", arg1: "float") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase_call(self, arg0, arg1)
    unregister: "Any" = property(_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase_unregister_get, _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase_swiginit(self, _ids_peak_python_interface.new_FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase(self)
        return weakref.proxy(self)

# Register FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase_swigregister(FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase)
class FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase(object):
    r"""Base class for UpdateStepFinished"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase

    def call(self, arg0: "int") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase_call(self, arg0)
    unregister: "Any" = property(_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase_unregister_get, _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase_swiginit(self, _ids_peak_python_interface.new_FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase(self)
        return weakref.proxy(self)

# Register FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase_swigregister(FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase)
class FirmwareUpdateProgressObserverUpdateFinishedCallbackBase(object):
    r"""Base class for UpdateFinished"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdateProgressObserverUpdateFinishedCallbackBase

    def call(self) -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateFinishedCallbackBase_call(self)
    unregister: "Any" = property(_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateFinishedCallbackBase_unregister_get, _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateFinishedCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == FirmwareUpdateProgressObserverUpdateFinishedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateFinishedCallbackBase_swiginit(self, _ids_peak_python_interface.new_FirmwareUpdateProgressObserverUpdateFinishedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_FirmwareUpdateProgressObserverUpdateFinishedCallbackBase(self)
        return weakref.proxy(self)

# Register FirmwareUpdateProgressObserverUpdateFinishedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateFinishedCallbackBase_swigregister(FirmwareUpdateProgressObserverUpdateFinishedCallbackBase)
class FirmwareUpdateProgressObserverUpdateFailedCallbackBase(object):
    r"""Base class for UpdateFailed"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdateProgressObserverUpdateFailedCallbackBase

    def call(self, arg0: "str") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateFailedCallbackBase_call(self, arg0)
    unregister: "Any" = property(_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateFailedCallbackBase_unregister_get, _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateFailedCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == FirmwareUpdateProgressObserverUpdateFailedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateFailedCallbackBase_swiginit(self, _ids_peak_python_interface.new_FirmwareUpdateProgressObserverUpdateFailedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_FirmwareUpdateProgressObserverUpdateFailedCallbackBase(self)
        return weakref.proxy(self)

# Register FirmwareUpdateProgressObserverUpdateFailedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdateProgressObserverUpdateFailedCallbackBase_swigregister(FirmwareUpdateProgressObserverUpdateFailedCallbackBase)

def AcquisitionStartModeEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an AcquisitionStartMode to a str
    :type entry: int
    :param entry: AcquisitionStartMode to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.AcquisitionStartModeEnumEntryToString(entry)

def AcquisitionStopModeEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an AcquisitionStopMode to a str
    :type entry: int
    :param entry: AcquisitionStopMode to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.AcquisitionStopModeEnumEntryToString(entry)

def BufferPayloadTypeEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an BufferPayloadType to a str
    :type entry: int
    :param entry: BufferPayloadType to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.BufferPayloadTypeEnumEntryToString(entry)

def CharacterEncodingEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an CharacterEncoding to a str
    :type entry: int
    :param entry: CharacterEncoding to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.CharacterEncodingEnumEntryToString(entry)

def DataStreamFlushModeEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an DataStreamFlushMode to a str
    :type entry: int
    :param entry: DataStreamFlushMode to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.DataStreamFlushModeEnumEntryToString(entry)

def DeviceAccessStatusEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an DeviceAccessStatus to a str
    :type entry: int
    :param entry: DeviceAccessStatus to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.DeviceAccessStatusEnumEntryToString(entry)

def DeviceAccessTypeEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an DeviceAccessType to a str
    :type entry: int
    :param entry: DeviceAccessType to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.DeviceAccessTypeEnumEntryToString(entry)

def EventTypeEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an EventType to a str
    :type entry: int
    :param entry: EventType to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.EventTypeEnumEntryToString(entry)

def EndiannessEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an Endianness to a str
    :type entry: int
    :param entry: Endianness to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.EndiannessEnumEntryToString(entry)

def FirmwareUpdatePersistenceEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an FirmwareUpdatePersistence to a str
    :type entry: int
    :param entry: FirmwareUpdatePersistence to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.FirmwareUpdatePersistenceEnumEntryToString(entry)

def FirmwareUpdateStepEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an FirmwareUpdateStep to a str
    :type entry: int
    :param entry: FirmwareUpdateStep to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.FirmwareUpdateStepEnumEntryToString(entry)

def FirmwareUpdateVersionStyleEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an FirmwareUpdateVersionStyle to a str
    :type entry: int
    :param entry: FirmwareUpdateVersionStyle to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.FirmwareUpdateVersionStyleEnumEntryToString(entry)

def PixelFormatNamespaceEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an PixelFormatNamespace to a str
    :type entry: int
    :param entry: PixelFormatNamespace to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.PixelFormatNamespaceEnumEntryToString(entry)

def PortURLSchemeEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an PortURLScheme to a str
    :type entry: int
    :param entry: PortURLScheme to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.PortURLSchemeEnumEntryToString(entry)

def NodeAccessStatusEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an NodeAccessStatus to a str
    :type entry: int
    :param entry: NodeAccessStatus to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.NodeAccessStatusEnumEntryToString(entry)

def NodeCachingModeEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an NodeCachingMode to a str
    :type entry: int
    :param entry: NodeCachingMode to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.NodeCachingModeEnumEntryToString(entry)

def NodeDisplayNotationEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an NodeDisplayNotation to a str
    :type entry: int
    :param entry: NodeDisplayNotation to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.NodeDisplayNotationEnumEntryToString(entry)

def NodeIncrementTypeEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an NodeIncrementType to a str
    :type entry: int
    :param entry: NodeIncrementType to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.NodeIncrementTypeEnumEntryToString(entry)

def NodeNamespaceEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an NodeNamespace to a str
    :type entry: int
    :param entry: NodeNamespace to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.NodeNamespaceEnumEntryToString(entry)

def NodeRepresentationEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an NodeRepresentation to a str
    :type entry: int
    :param entry: NodeRepresentation to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.NodeRepresentationEnumEntryToString(entry)

def NodeTypeEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an NodeType to a str
    :type entry: int
    :param entry: NodeType to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.NodeTypeEnumEntryToString(entry)

def NodeVisibilityEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an NodeVisibility to a str
    :type entry: int
    :param entry: NodeVisibility to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_python_interface.NodeVisibilityEnumEntryToString(entry)
class DeviceManagerSystemFoundCallbackBase(object):
    r"""Base class for SystemFound"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceManagerSystemFoundCallbackBase

    def call(self, arg0: "System") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.DeviceManagerSystemFoundCallbackBase_call(self, arg0)
    unregister: "Any" = property(_ids_peak_python_interface.DeviceManagerSystemFoundCallbackBase_unregister_get, _ids_peak_python_interface.DeviceManagerSystemFoundCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == DeviceManagerSystemFoundCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceManagerSystemFoundCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceManagerSystemFoundCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceManagerSystemFoundCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceManagerSystemFoundCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManagerSystemFoundCallbackBase_swigregister(DeviceManagerSystemFoundCallbackBase)
class DeviceManagerInterfaceFoundCallbackBase(object):
    r"""Base class for InterfaceFound"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceManagerInterfaceFoundCallbackBase

    def call(self, arg0: "Interface") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.DeviceManagerInterfaceFoundCallbackBase_call(self, arg0)
    unregister: "Any" = property(_ids_peak_python_interface.DeviceManagerInterfaceFoundCallbackBase_unregister_get, _ids_peak_python_interface.DeviceManagerInterfaceFoundCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == DeviceManagerInterfaceFoundCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceManagerInterfaceFoundCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceManagerInterfaceFoundCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceManagerInterfaceFoundCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceManagerInterfaceFoundCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManagerInterfaceFoundCallbackBase_swigregister(DeviceManagerInterfaceFoundCallbackBase)
class DeviceManagerInterfaceLostCallbackBase(object):
    r"""Base class for InterfaceLost"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceManagerInterfaceLostCallbackBase

    def call(self, arg0: "str") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.DeviceManagerInterfaceLostCallbackBase_call(self, arg0)
    unregister: "Any" = property(_ids_peak_python_interface.DeviceManagerInterfaceLostCallbackBase_unregister_get, _ids_peak_python_interface.DeviceManagerInterfaceLostCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == DeviceManagerInterfaceLostCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceManagerInterfaceLostCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceManagerInterfaceLostCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceManagerInterfaceLostCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceManagerInterfaceLostCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManagerInterfaceLostCallbackBase_swigregister(DeviceManagerInterfaceLostCallbackBase)
class DeviceManagerDeviceFoundCallbackBase(object):
    r"""Base class for DeviceFound"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceManagerDeviceFoundCallbackBase

    def call(self, arg0: "DeviceDescriptor") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.DeviceManagerDeviceFoundCallbackBase_call(self, arg0)
    unregister: "Any" = property(_ids_peak_python_interface.DeviceManagerDeviceFoundCallbackBase_unregister_get, _ids_peak_python_interface.DeviceManagerDeviceFoundCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == DeviceManagerDeviceFoundCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceManagerDeviceFoundCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceManagerDeviceFoundCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceManagerDeviceFoundCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceManagerDeviceFoundCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManagerDeviceFoundCallbackBase_swigregister(DeviceManagerDeviceFoundCallbackBase)
class DeviceManagerDeviceReconnectedCallbackBase(object):
    r"""Base class for DeviceReconnected"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceManagerDeviceReconnectedCallbackBase

    def call(self, arg0: "DeviceDescriptor", arg1: "DeviceReconnectInformation") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.DeviceManagerDeviceReconnectedCallbackBase_call(self, arg0, arg1)
    unregister: "Any" = property(_ids_peak_python_interface.DeviceManagerDeviceReconnectedCallbackBase_unregister_get, _ids_peak_python_interface.DeviceManagerDeviceReconnectedCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == DeviceManagerDeviceReconnectedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceManagerDeviceReconnectedCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceManagerDeviceReconnectedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceManagerDeviceReconnectedCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceManagerDeviceReconnectedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManagerDeviceReconnectedCallbackBase_swigregister(DeviceManagerDeviceReconnectedCallbackBase)
class DeviceManagerDeviceDisconnectedCallbackBase(object):
    r"""Base class for DeviceDisconnected"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceManagerDeviceDisconnectedCallbackBase

    def call(self, arg0: "DeviceDescriptor") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.DeviceManagerDeviceDisconnectedCallbackBase_call(self, arg0)
    unregister: "Any" = property(_ids_peak_python_interface.DeviceManagerDeviceDisconnectedCallbackBase_unregister_get, _ids_peak_python_interface.DeviceManagerDeviceDisconnectedCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == DeviceManagerDeviceDisconnectedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceManagerDeviceDisconnectedCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceManagerDeviceDisconnectedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceManagerDeviceDisconnectedCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceManagerDeviceDisconnectedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManagerDeviceDisconnectedCallbackBase_swigregister(DeviceManagerDeviceDisconnectedCallbackBase)
class DeviceManagerDeviceLostCallbackBase(object):
    r"""Base class for DeviceLost"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceManagerDeviceLostCallbackBase

    def call(self, arg0: "str") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.DeviceManagerDeviceLostCallbackBase_call(self, arg0)
    unregister: "Any" = property(_ids_peak_python_interface.DeviceManagerDeviceLostCallbackBase_unregister_get, _ids_peak_python_interface.DeviceManagerDeviceLostCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == DeviceManagerDeviceLostCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceManagerDeviceLostCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceManagerDeviceLostCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceManagerDeviceLostCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceManagerDeviceLostCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManagerDeviceLostCallbackBase_swigregister(DeviceManagerDeviceLostCallbackBase)
class DeviceManagerDeviceListChangedCallbackBase(object):
    r"""Base class for DeviceListChanged"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceManagerDeviceListChangedCallbackBase

    def call(self) -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.DeviceManagerDeviceListChangedCallbackBase_call(self)
    unregister: "Any" = property(_ids_peak_python_interface.DeviceManagerDeviceListChangedCallbackBase_unregister_get, _ids_peak_python_interface.DeviceManagerDeviceListChangedCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == DeviceManagerDeviceListChangedCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceManagerDeviceListChangedCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceManagerDeviceListChangedCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceManagerDeviceListChangedCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceManagerDeviceListChangedCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManagerDeviceListChangedCallbackBase_swigregister(DeviceManagerDeviceListChangedCallbackBase)
class DeviceManagerUpdateErrorCallbackBase(object):
    r"""Base class for UpdateError"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceManagerUpdateErrorCallbackBase

    def call(self, arg0: "str") -> "None":
        r"""Call the callback"""
        return _ids_peak_python_interface.DeviceManagerUpdateErrorCallbackBase_call(self, arg0)
    unregister: "Any" = property(_ids_peak_python_interface.DeviceManagerUpdateErrorCallbackBase_unregister_get, _ids_peak_python_interface.DeviceManagerUpdateErrorCallbackBase_unregister_set, doc=r"""The function to unregister the callback""")

    def __init__(self):
        if self.__class__ == DeviceManagerUpdateErrorCallbackBase:
            _self = None
        else:
            _self = self
        _ids_peak_python_interface.DeviceManagerUpdateErrorCallbackBase_swiginit(self, _ids_peak_python_interface.new_DeviceManagerUpdateErrorCallbackBase(_self, ))
    def __disown__(self):
        self.this.disown()
        _ids_peak_python_interface.disown_DeviceManagerUpdateErrorCallbackBase(self)
        return weakref.proxy(self)

# Register DeviceManagerUpdateErrorCallbackBase in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManagerUpdateErrorCallbackBase_swigregister(DeviceManagerUpdateErrorCallbackBase)
class Version(object):
    r"""
    Implements versioning functionality.

    This class allows to create and compare different versions.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_Version

    def __init__(self, *args):
        _ids_peak_python_interface.Version_swiginit(self, _ids_peak_python_interface.new_Version(*args))

    def ToString(self) -> "str":
        r"""
        Returns the version as str.

        Since: 1.0
        """
        return _ids_peak_python_interface.Version_ToString(self)

    def Major(self) -> "int":
        r"""
        Returns the major part of the version which is the first part of the version scheme separated by dots.

        :rtype: int
        :return: **x**.y.z

        Since: 1.0
        """
        return _ids_peak_python_interface.Version_Major(self)

    def Minor(self) -> "int":
        r"""
        Returns the minor part of the version which is the second part of the version scheme separated by dots.

        :rtype: int
        :return: x.**y**.z

        Since: 1.0
        """
        return _ids_peak_python_interface.Version_Minor(self)

    def Subminor(self) -> "int":
        r"""
        Returns the subminor part of the version which is the third part of the version scheme separated by dots.

        :rtype: int
        :return: x.y.**z**

        Since: 1.0
        """
        return _ids_peak_python_interface.Version_Subminor(self)

# Register Version in _ids_peak_python_interface:
_ids_peak_python_interface.Version_swigregister(Version)

def __lt__(lhs: "Version", rhs: "Version") -> "bool":
    return _ids_peak_python_interface.__lt__(lhs, rhs)

def __gt__(lhs: "Version", rhs: "Version") -> "bool":
    return _ids_peak_python_interface.__gt__(lhs, rhs)

def __eq__(lhs: "Version", rhs: "Version") -> "bool":
    return _ids_peak_python_interface.__eq__(lhs, rhs)

def __ne__(lhs: "Version", rhs: "Version") -> "bool":
    return _ids_peak_python_interface.__ne__(lhs, rhs)
class Library(object):
    r"""
    A collection of global library functions.

    Currently, this includes Initialize() / Close(), which must be called before/after usage of the
    library, and Version(), to retrieve version information about the the library.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def Initialize() -> "None":
        r"""
        Initializes the IDS peak genericAPI library.

        This function **must** be called prior to any other function call to allow global initialization of library
        internals. This function is necessary since automated initialization functionality like within DllMain on MS
        Windows platforms is very limited.

        Calling this function multiple times is ok, but note that these calls are reference counted, so you have to call
        Close() as many times as Initialize().

        Since: 1.0
        2.0 Added reference counting

        Notes: Calling any other function before this will result in a NotInitializedException.

        :raises: runtime_error when dynamic loading is active and and error occured during loading the dynamic library.
        """
        return _ids_peak_python_interface.Library_Initialize()

    @staticmethod
    def Close() -> "None":
        r"""
        Closes the IDS peak genericAPI library and cleans up any resources that are still in use.

        This function should be called after no function of the library is needed anymore, before unloading the library.
        It cleans up any resources still in use. If an Update is in progress, the update will finish
        before the library is closed.

        Notes: Calling any other function (except Initialize()) after this will result in a NotInitializedException.

        Calls to Initialize() and Close() are reference counted, so you have to call Close() as many times as you
              called Initialize().

        Warning: It is of particular importance on _MS Windows_ platforms, when using "Run-Time Dynamic Linking",
                 especially when unloading the DLL with FreeLibrary(). Otherwise it is very likely to run into the
                 "Loader-Lock Deadlock Problem" during DLL unloading.

        Since: 1.0
        2.0 Added reference counting

        :raises: runtime_error when dynamic loading is active and and error occured during loading the dynamic library.
        """
        return _ids_peak_python_interface.Library_Close()

    @staticmethod
    def Version() -> "Version":
        r"""
        Returns the library version.

        :rtype: :py:class:`Version`
        :return: Library version

        Since: 1.0

        :raises: runtime_error when dynamic loading is active and and error occured during loading the dynamic library.
        """
        return _ids_peak_python_interface.Library_Version()

# Register Library in _ids_peak_python_interface:
_ids_peak_python_interface.Library_swigregister(Library)
Endianness_Unknown = _ids_peak_python_interface.Endianness_Unknown
r"""Endianness of the data is unknown to the GenTL Producer."""
Endianness_Little = _ids_peak_python_interface.Endianness_Little
r"""The data is stored in little endian format."""
Endianness_Big = _ids_peak_python_interface.Endianness_Big
r"""The data is stored in big endian format."""
class RawInformation(object):
    r"""The struct returned by all raw information functions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    DataType: "int" = property(_ids_peak_python_interface.RawInformation_DataType_get, _ids_peak_python_interface.RawInformation_DataType_set)
    Data: "Sequence[int]" = property(_ids_peak_python_interface.RawInformation_Data_get, _ids_peak_python_interface.RawInformation_Data_set)

    def __init__(self):
        _ids_peak_python_interface.RawInformation_swiginit(self, _ids_peak_python_interface.new_RawInformation())
    __swig_destroy__ = _ids_peak_python_interface.delete_RawInformation

# Register RawInformation in _ids_peak_python_interface:
_ids_peak_python_interface.RawInformation_swigregister(RawInformation)
class Timeout(object):
    r"""
    Represents a timeout value in milliseconds.

    Use INFINITE_TIMEOUT for an infinite timeout.

    Since: 1.1
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    INFINITE_TIMEOUT = _ids_peak_python_interface.Timeout_INFINITE_TIMEOUT
    r"""
    The constant defining an infinite timeout.

    The corresponding function will only return after the operation is completed.
    """

    def __init__(self, *args):
        _ids_peak_python_interface.Timeout_swiginit(self, _ids_peak_python_interface.new_Timeout(*args))
    __swig_destroy__ = _ids_peak_python_interface.delete_Timeout

# Register Timeout in _ids_peak_python_interface:
_ids_peak_python_interface.Timeout_swigregister(Timeout)
EventType_Error = _ids_peak_python_interface.EventType_Error
EventType_FeatureInvalidate = _ids_peak_python_interface.EventType_FeatureInvalidate
EventType_FeatureChange = _ids_peak_python_interface.EventType_FeatureChange
EventType_RemoteDevice = _ids_peak_python_interface.EventType_RemoteDevice
EventType_Module = _ids_peak_python_interface.EventType_Module
EventType_Custom = _ids_peak_python_interface.EventType_Custom
class Event(object):
    r"""Encapsulates the GenTL event data functions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_Event

    def Info(self, infoCommand: "int") -> "RawInformation":

        return _ids_peak_python_interface.Event_Info(self, infoCommand)

    def ID(self) -> "int":
        r"""
        Returns the ID.

        :rtype: int
        :return: ID

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Event_ID(self)

    def Data(self) -> "Sequence[int]":
        r"""
        Returns the event payload data.

        The delivered data depend on the event type.

        :rtype: Sequence[int]
        :return: Payload data

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Event_Data(self)

    def Type(self) -> "int":
        r"""
        Returns the type.

        :rtype: int
        :return: Type

        Since: 1.0
        """
        return _ids_peak_python_interface.Event_Type(self)

    def RawData(self) -> "Sequence[int]":
        r"""
        Returns the event raw data.

        The delivered data depend on the underlying transport layer
        (GEV, USB3, ...) and the event type.
        (e.g. If the underlying CTI implements GEV and the event is a remote device event,
        the delivered data will be the event raw data of a GEV event)

        :rtype: Sequence[int]
        :return: Raw data

        Since: 1.2
        """
        return _ids_peak_python_interface.Event_RawData(self)

# Register Event in _ids_peak_python_interface:
_ids_peak_python_interface.Event_swigregister(Event)
class EventController(object):
    r"""
    Encapsulates the GenTL event functionality associated with one GenTL #EVENT_HANDLE.

    This class is returned by EnableEvents() and acts as a controller for events of the type given
    to EnableEvents().

    Notes: When the EventController is destroyed, the #EventType corresponding to
          the GenTL #EVENT_HANDLE will be unregistered. This causes all waiting #WaitForEvent calls to be aborted and
          pending events, including KillWaits, to be discarded.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_EventController

    def Info(self, infoCommand: "int") -> "RawInformation":

        return _ids_peak_python_interface.EventController_Info(self, infoCommand)

    def NumEventsInQueue(self) -> "int":
        r"""
        Returns the number of events in queue.

        :rtype: int
        :return: Number of events in queue

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EventController_NumEventsInQueue(self)

    def NumEventsFired(self) -> "int":
        r"""
        Returns the number of fired events.

        :rtype: int
        :return: Number of fired events

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EventController_NumEventsFired(self)

    def EventMaxSize(self) -> "int":
        r"""
        Returns the maximum size of an event in bytes.

        :rtype: int
        :return: Maximum size of an event in bytes.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EventController_EventMaxSize(self)

    def EventDataMaxSize(self) -> "int":
        r"""
        Returns the maximum size of the data of an event in bytes.

        :rtype: int
        :return: Maximum size of the data of an event in bytes.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EventController_EventDataMaxSize(self)

    def WaitForEvent(self, timeout_ms: "Timeout") -> "Any":
        r"""
        Blocking wait for an event.

        A call to #WaitForEvent can be aborted immediately and at any time by calling
        #KillWait from another thread, resulting in an #AbortedException being thrown.
        This is especially useful when using [INFINITE_TIMEOUT](#INFINITE_TIMEOUT).

        :type timeout_ms: :py:class:`Timeout`, in
        :param timeout_ms: The maximum waiting time in milliseconds.
                                  When called with INFINITE_TIMEOUT, the function will only return
                                  if the event is triggered or KillWait() is called.

        :rtype: unique_ptr< Event >
        :return: Event

        Since: 1.0

        :raises: AbortedException The wait was aborted, e.g. by a call to 'KillWait'
        :raises: TimeoutException The function call timed out
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EventController_WaitForEvent(self, timeout_ms)

    def KillWait(self) -> "None":
        r"""
        Cancels a pending #WaitForEvent call.

        Calling #KillWait will interrupt an ongoing #WaitForEvent call, triggering an #AbortedException.

        If no #WaitForEvent call is currently active, the cancellation request will be __queued__.
        The __next call__ to #WaitForEvent will then be aborted. Multiple invocations of #KillWait will add
        multiple cancellation requests to the queue.

        A pending #KillWait takes precedence over regular events. This means
        that if both a regular event and a pending #KillWait exist, a call
        to #WaitForEvent will fail with an #AbortedException.

        Notes: To clear the queued cancellations, you can re-register the event by reconstructing
        the #EventController or calling #FlushPendingKillWaits. This, however, will clear all pending events,
        including regular events, which cannot be retrieved after reconstructing the EventController.

        Since: 1.0

        :raises: InternalErrorException If an internal error occurs.
        """
        return _ids_peak_python_interface.EventController_KillWait(self)

    def FlushPendingKillWaits(self) -> "None":
        r"""
        Flushes the KillWait queue.

        This function clears all queued KillWaits, preventing subsequent calls to #WaitForEvent
        from throwing a #AbortedException.

        Calls to #WaitForEvent that are currently waiting will be aborted and throw a
        #AbortedException.


        Any pending events will be discarded.

        Since: 1.11

        :raises: BadAccessException The acquisition is currently running and needs to be stopped first.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EventController_FlushPendingKillWaits(self)

    def FlushEvents(self) -> "None":
        r"""
        Discards all events in queue.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EventController_FlushEvents(self)

    def ControlledEventType(self) -> "int":
        r"""
        Returns the controlled event type.

        :rtype: int
        :return: Controlled event type

        Since: 1.0
        """
        return _ids_peak_python_interface.EventController_ControlledEventType(self)

# Register EventController in _ids_peak_python_interface:
_ids_peak_python_interface.EventController_swigregister(EventController)
NodeAccessStatus_NotImplemented = _ids_peak_python_interface.NodeAccessStatus_NotImplemented
NodeAccessStatus_NotAvailable = _ids_peak_python_interface.NodeAccessStatus_NotAvailable
NodeAccessStatus_WriteOnly = _ids_peak_python_interface.NodeAccessStatus_WriteOnly
NodeAccessStatus_ReadOnly = _ids_peak_python_interface.NodeAccessStatus_ReadOnly
NodeAccessStatus_ReadWrite = _ids_peak_python_interface.NodeAccessStatus_ReadWrite
NodeCachingMode_NoCache = _ids_peak_python_interface.NodeCachingMode_NoCache
r"""NoCache means all values are read directly from the device."""
NodeCachingMode_WriteThrough = _ids_peak_python_interface.NodeCachingMode_WriteThrough
r"""WriteThrough means that a value written to the camera is written to the cache as well."""
NodeCachingMode_WriteAround = _ids_peak_python_interface.NodeCachingMode_WriteAround
r"""WriteAround means that only read values are written to the cache."""
NodeNamespace_Custom = _ids_peak_python_interface.NodeNamespace_Custom
NodeNamespace_Standard = _ids_peak_python_interface.NodeNamespace_Standard
NodeType_Integer = _ids_peak_python_interface.NodeType_Integer
NodeType_Boolean = _ids_peak_python_interface.NodeType_Boolean
NodeType_Command = _ids_peak_python_interface.NodeType_Command
NodeType_Float = _ids_peak_python_interface.NodeType_Float
NodeType_String = _ids_peak_python_interface.NodeType_String
NodeType_Register = _ids_peak_python_interface.NodeType_Register
NodeType_Category = _ids_peak_python_interface.NodeType_Category
NodeType_Enumeration = _ids_peak_python_interface.NodeType_Enumeration
NodeType_EnumerationEntry = _ids_peak_python_interface.NodeType_EnumerationEntry
NodeVisibility_Beginner = _ids_peak_python_interface.NodeVisibility_Beginner
NodeVisibility_Expert = _ids_peak_python_interface.NodeVisibility_Expert
NodeVisibility_Guru = _ids_peak_python_interface.NodeVisibility_Guru
NodeVisibility_Invisible = _ids_peak_python_interface.NodeVisibility_Invisible
class Node(object):
    r"""
     End of conditional comment.

    Represents a GenAPI node.

    This class allows to interact with a single node of a module. It is the base class for all nodes a module can
    have.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_Node

    def Name(self) -> "str":
        r"""
        Returns the name.

        :rtype: str
        :return: Name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_Name(self)

    def DisplayName(self) -> "str":
        r"""
        Returns the display name.

        :rtype: str
        :return: Display name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_DisplayName(self)

    def Namespace(self) -> "int":
        r"""
        Returns the namespace the node beints to.

        :rtype: int
        :return: Namespace the node beints to

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_Namespace(self)

    def Visibility(self) -> "int":
        r"""
        Returns the visibility.

        :rtype: int
        :return: Visibility

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_Visibility(self)

    def AccessStatus(self) -> "int":
        r"""
        Returns the access status.

        :rtype: int
        :return: Access status

        Since: 1.0

        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_AccessStatus(self)

    def IsReadable(self) -> "bool":
        r"""
        Returns whether the node is currently readable.

        :raises: IOException A communication error has occurred, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.

        Since: 1.8.1
        """
        return _ids_peak_python_interface.Node_IsReadable(self)

    def IsWriteable(self) -> "bool":
        r"""
        Returns whether the node is currently writeable.

        :raises: IOException A communication error has occurred, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.

        Since: 1.8.1
        """
        return _ids_peak_python_interface.Node_IsWriteable(self)

    def IsAvailable(self) -> "bool":
        r"""
        Returns whether the node is currently either readable or writeable.

        :raises: IOException A communication error has occurred, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.

        Since: 1.10
        """
        return _ids_peak_python_interface.Node_IsAvailable(self)

    def IsImplemented(self) -> "bool":
        r"""
        Returns whether the node is implemented.

        :raises: IOException A communication error has occurred, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.

        Since: 1.10
        """
        return _ids_peak_python_interface.Node_IsImplemented(self)

    def IsCacheable(self) -> "bool":
        r"""
        Checks whether the node is cacheable.

        :rtype: boolean
        :return: True, if the node is cacheable.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_IsCacheable(self)

    def IsAccessStatusCacheable(self) -> "bool":
        r"""
        Checks whether the node's access status is cacheable.

        :rtype: boolean
        :return: True, if the node's access status is cacheable.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_IsAccessStatusCacheable(self)

    def IsStreamable(self) -> "bool":
        r"""
        Checks whether the node is streamable.

        :rtype: boolean
        :return: True, if the node is streamable.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_IsStreamable(self)

    def IsDeprecated(self) -> "bool":
        r"""
        Checks whether the node is deprecated.

        :rtype: boolean
        :return: True, if the node is deprecated.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_IsDeprecated(self)

    def IsFeature(self) -> "bool":
        r"""
        Checks whether the node is a feature, i.e. it can be reached via
        category nodes from a category node named "Root".

        :rtype: boolean
        :return: True, if the node is a feature.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.2

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_IsFeature(self)

    def CachingMode(self) -> "int":
        r"""
        Returns the caching mode.

        :rtype: int
        :return: Caching mode

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_CachingMode(self)

    def PollingTime(self) -> "int":
        r"""
        Returns the polling time.

        :rtype: int
        :return: Polling time in milliseconds

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_PollingTime(self)

    def ToolTip(self) -> "str":
        r"""
        Returns the tool tip.

        :rtype: str
        :return: Tool tip

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_ToolTip(self)

    def Description(self) -> "str":
        r"""
        Returns the description.

        :rtype: str
        :return: Description

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_Description(self)

    def Type(self) -> "int":
        r"""
        Returns the type.

        The returned type is necessary to know the type the node has to be casted to if you want to access the full
        functionality of the node.

        :rtype: int
        :return: Type

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_Type(self)

    def ParentNodeMap(self) -> "NodeMap":
        r"""
        Returns the parent node map.

        :rtype: :py:class:`NodeMap`
        :return: Parent node map

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_ParentNodeMap(self)

    def FindInvalidatedNode(self, name: "str") -> "Node":
        r"""
        Tries to find an invalidated node with the given name.

        :type name: str, in
        :param name: The name of the invalidated node to find.

        :rtype: :py:class:`Node`
        :return: Found node.
        :rtype: :py:class:`Node`
        :return: If no invalidated node with the given name exists, a NotFoundException is thrown.

        Since: 1.0

        :raises: NotFoundException There is no invalidated node with the given name
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_FindInvalidatedNode(self, name)

    def InvalidatedNodes(self) -> "Sequence[Node]":
        r"""
        Returns the invalidated nodes.

        :rtype: Sequence[Node]
        :return: Invalidated nodes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_InvalidatedNodes(self)

    def FindInvalidatingNode(self, name: "str") -> "Node":
        r"""
        Tries to find an invalidating node with the given name.

        :type name: str, in
        :param name: The name of the invalidating node to find.

        :rtype: :py:class:`Node`
        :return: Found node.
        :rtype: :py:class:`Node`
        :return: If no invalidating node with the given name exists, a NotFoundException is thrown.

        Since: 1.0

        :raises: NotFoundException There is no invalidating node with the given name
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_FindInvalidatingNode(self, name)

    def InvalidatingNodes(self) -> "Sequence[Node]":
        r"""
        Returns the invalidating nodes.

        :rtype: Sequence[Node]
        :return: Invalidating nodes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_InvalidatingNodes(self)

    def FindSelectedNode(self, name: "str") -> "Node":
        r"""
        Tries to find a selected node with the given name.

        :type name: str, in
        :param name: The name of the selected node to find.

        :rtype: :py:class:`Node`
        :return: Found node.
        :rtype: :py:class:`Node`
        :return: If no selected node with the given name exists, a NotFoundException is thrown.

        Since: 1.0

        :raises: NotFoundException There is no selected node with the given name
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_FindSelectedNode(self, name)

    def SelectedNodes(self) -> "Sequence[Node]":
        r"""
        Returns the selected nodes.

        :rtype: Sequence[Node]
        :return: Selected nodes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_SelectedNodes(self)

    def FindSelectingNode(self, name: "str") -> "Node":
        r"""
        Tries to find a selecting node with the given name.

        :type name: str, in
        :param name: The name of the selecting node to find.

        :rtype: :py:class:`Node`
        :return: Found node.
        :rtype: :py:class:`Node`
        :return: If no selecting node with the given name exists, a NotFoundException is thrown.

        Since: 1.0

        :raises: NotFoundException There is no selecting node with the given name
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_FindSelectingNode(self, name)

    def SelectingNodes(self) -> "Sequence[Node]":
        r"""
        Returns the selecting nodes.

        :rtype: Sequence[Node]
        :return: Selecting nodes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Node_SelectingNodes(self)

    def RegisterChangedCallback(self, callbackToRegister: "NodeChangedCallbackBase") -> "::NodeChangedCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.Node_RegisterChangedCallback(self, callbackToRegister)

    def UnregisterChangedCallback(self, callbackToUnregister: "NodeChangedCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.Node_UnregisterChangedCallback(self, callbackToUnregister)

    class ChangedCallback(NodeChangedCallbackBase):
        def __init__(self, callback):
            NodeChangedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "Node"):
            self._callback(arg0)
        _callback = None


# Register Node in _ids_peak_python_interface:
_ids_peak_python_interface.Node_swigregister(Node)
NodeCacheUsePolicy_UseCache = _ids_peak_python_interface.NodeCacheUsePolicy_UseCache
NodeCacheUsePolicy_IgnoreCache = _ids_peak_python_interface.NodeCacheUsePolicy_IgnoreCache
NodeIncrementType_NoIncrement = _ids_peak_python_interface.NodeIncrementType_NoIncrement
NodeIncrementType_FixedIncrement = _ids_peak_python_interface.NodeIncrementType_FixedIncrement
NodeIncrementType_ListIncrement = _ids_peak_python_interface.NodeIncrementType_ListIncrement
NodeRepresentation_Linear = _ids_peak_python_interface.NodeRepresentation_Linear
NodeRepresentation_Logarithmic = _ids_peak_python_interface.NodeRepresentation_Logarithmic
NodeRepresentation_Boolean = _ids_peak_python_interface.NodeRepresentation_Boolean
NodeRepresentation_PureNumber = _ids_peak_python_interface.NodeRepresentation_PureNumber
NodeRepresentation_HexNumber = _ids_peak_python_interface.NodeRepresentation_HexNumber
NodeRepresentation_IP4Address = _ids_peak_python_interface.NodeRepresentation_IP4Address
NodeRepresentation_MACAddress = _ids_peak_python_interface.NodeRepresentation_MACAddress
class BooleanNode(Node):
    r"""Represents a GenAPI boolean node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    NodeType = _ids_peak_python_interface.BooleanNode_NodeType
    __swig_destroy__ = _ids_peak_python_interface.delete_BooleanNode

    def Value(self, *args) -> "bool":
        r"""
        Returns the value.

        :type cacheUsePolicy: int, in, optional
        :param cacheUsePolicy: A flag telling whether the value should be read using the internal cache.

        :rtype: boolean
        :return: Value

        Since: 1.0

        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BooleanNode_Value(self, *args)

    def SetValue(self, value: "bool") -> "None":
        r"""
        Sets the given value.

        :type value: boolean, in
        :param value: The value to be set.

        Since: 1.0

        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BooleanNode_SetValue(self, value)

# Register BooleanNode in _ids_peak_python_interface:
_ids_peak_python_interface.BooleanNode_swigregister(BooleanNode)
class CategoryNode(Node):
    r"""Represents a GenAPI category node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    NodeType = _ids_peak_python_interface.CategoryNode_NodeType
    __swig_destroy__ = _ids_peak_python_interface.delete_CategoryNode

    def SubNodes(self) -> "Sequence[Node]":
        r"""
        Returns the sub nodes.

        :rtype: Sequence[Node]
        :return: Sub nodes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.CategoryNode_SubNodes(self)

# Register CategoryNode in _ids_peak_python_interface:
_ids_peak_python_interface.CategoryNode_swigregister(CategoryNode)
class CommandNode(Node):
    r"""Represents a GenAPI command node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    NodeType = _ids_peak_python_interface.CommandNode_NodeType
    __swig_destroy__ = _ids_peak_python_interface.delete_CommandNode

    def IsDone(self) -> "bool":
        r"""
        Checks whether the command is done.

        :rtype: boolean
        :return: True, if the command is done
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.CommandNode_IsDone(self)

    def Execute(self) -> "None":
        r"""
        Executes the command associated with this node

        Since: 1.0

        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.CommandNode_Execute(self)

    def WaitUntilDone(self, waitTimeout_ms: "Timeout"=500) -> "None":
        r"""
        (Blocking) Wait for the executed command to be finished, i.e. until IsDone() is true.

        :type waitTimeout_ms: :py:class:`Timeout`, in, optional
        :param waitTimeout_ms: The maximum waiting time in milliseconds.

        Since: 1.0

        :raises: TimeoutException       The specified timeout expired without the executed command being finished.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.CommandNode_WaitUntilDone(self, waitTimeout_ms)

# Register CommandNode in _ids_peak_python_interface:
_ids_peak_python_interface.CommandNode_swigregister(CommandNode)
class EnumerationEntryNode(Node):
    r"""Represents a GenAPI enumeration entry node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    NodeType = _ids_peak_python_interface.EnumerationEntryNode_NodeType
    __swig_destroy__ = _ids_peak_python_interface.delete_EnumerationEntryNode

    def IsSelfClearing(self) -> "bool":
        r"""
        Checks whether the node is self clearing.

        :rtype: boolean
        :return: True, if the node is self clearing.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EnumerationEntryNode_IsSelfClearing(self)

    def SymbolicValue(self) -> "str":
        r"""
        Returns the symbolic value (i.e. name/str value) of the enum entry.

        :rtype: str
        :return: Symbolic value.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EnumerationEntryNode_SymbolicValue(self)

    def StringValue(self) -> "str":

        return _ids_peak_python_interface.EnumerationEntryNode_StringValue(self)

    def Value(self) -> "int":
        r"""
        Returns the numeric value of the enum entry.

        :rtype: int
        :return: Value.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EnumerationEntryNode_Value(self)

    def NumericValue(self) -> "int":

        return _ids_peak_python_interface.EnumerationEntryNode_NumericValue(self)

# Register EnumerationEntryNode in _ids_peak_python_interface:
_ids_peak_python_interface.EnumerationEntryNode_swigregister(EnumerationEntryNode)
class EnumerationNode(Node):
    r"""Represents a GenAPI enumeration node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    NodeType = _ids_peak_python_interface.EnumerationNode_NodeType
    __swig_destroy__ = _ids_peak_python_interface.delete_EnumerationNode

    def CurrentEntry(self, *args) -> "EnumerationEntryNode":
        r"""
        Returns the current entry.

        :type cacheUsePolicy: int, in, optional
        :param cacheUsePolicy: A flag telling whether the value should be read using the internal cache.

        :rtype: :py:class:`EnumerationEntryNode`
        :return: Current entry

        Since: 1.0

        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EnumerationNode_CurrentEntry(self, *args)

    def SetCurrentEntry(self, *args) -> "None":
        r"""
        *Overload 1:*

        Sets the current entry.

        :type entry: :py:class:`EnumerationEntryNode`, in
        :param entry: The entry to set as current entry.

        Since: 1.0

        :raises: InvalidArgumentException There is no matching entry in this enumeration node.
        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.

        |

        *Overload 2:*

        Sets the current entry to an entry with the given symbolic value.

        :type symbolicValue: str, in
        :param symbolicValue: The symbolic value of the entry to set.

        Since: 1.0

        :raises: InvalidArgumentException There is no entry with this symbolicValue in this enumeration node.
        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.

        |

        *Overload 3:*

        Sets the current entry to an entry with the given value.

        :type value: int, in
        :param value: The value of the entry to set.

        Since: 1.0

        :raises: InvalidArgumentException There is no entry with this value in this enumeration node.
        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EnumerationNode_SetCurrentEntry(self, *args)

    def HasEntry(self, *args) -> "bool":
        r"""
        *Overload 1:*

        Checks whether the enumeration node contains an entry with the given symbolic value.

        Notes: This function only checks whether there is an entry with the given name.
              It does **not** check the access status whether the entry is available or implemented.
              To do so consider utilizing the function 'IsAvailable'.

        :type symbolicValue: str, in
        :param symbolicValue: The symbolic value of the entry to find.

        Since: 1.10.0

        :raises: InternalErrorException An internal error has occurred.

        |

        *Overload 2:*

        Checks whether the enumeration node contains an entry with the given value.

        Notes: This function only checks whether there is an entry with the given value.
              It does **not** check the access status whether the entry is available or implemented.

        :type value: int, in
        :param value: The value of the entry to find.

        Since: 1.10.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EnumerationNode_HasEntry(self, *args)

    def FindEntry(self, *args) -> "EnumerationEntryNode":
        r"""
        *Overload 1:*

        Finds an entry with the given symbolic value.

        :type symbolicValue: str, in
        :param symbolicValue: The symbolic value of the entry to find.

        :rtype: :py:class:`EnumerationEntryNode`
        :return: Found entry.
        :rtype: :py:class:`EnumerationEntryNode`
        :return: If no entry with the given name exists, a NotFoundException is thrown.

        Since: 1.0

        :raises: NotFoundException There is no entry with the given name.
        :raises: InternalErrorException An internal error has occurred.

        |

        *Overload 2:*

        Finds an entry with the given numeric value.

        :type value: int, in
        :param value: The value of the entry to find.

        :rtype: :py:class:`EnumerationEntryNode`
        :return: Found entry.
        :rtype: :py:class:`EnumerationEntryNode`
        :return: If no entry with the given numeric value, a NotFoundException is thrown.

        Since: 1.0

        :raises: NotFoundException There is no entry with the given numeric value.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EnumerationNode_FindEntry(self, *args)

    def TryFindEntry(self, *args) -> "EnumerationEntryNode":
        r"""
        *Overload 1:*

        Tries to find an entry with the given symbolic value.

        :type symbolicValue: str, in
        :param symbolicValue: The symbolic value of the entry to find.

        :rtype: :py:class:`EnumerationEntryNode`
        :return: Found entry or nullptr if no entry with the given name exists.

        Since: 1.10.0

        :raises: InternalErrorException An internal error has occurred.

        |

        *Overload 2:*

        Tries to find a entry with the given numeric value.

        :type value: int, in
        :param value: The value of the entry to find.

        :rtype: :py:class:`EnumerationEntryNode`
        :return: Found entry or nullptr if no entry with the given name exists.

        Since: 1.10.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EnumerationNode_TryFindEntry(self, *args)

    def Entries(self) -> "Sequence[EnumerationEntryNode]":
        r"""
        Returns the entries.

        :rtype: Sequence[EnumerationEntryNode]
        :return: Entries

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EnumerationNode_Entries(self)

    def AvailableEntries(self) -> "Sequence[EnumerationEntryNode]":
        r"""
        Returns the currently selectable entries.

        :rtype: Sequence[EnumerationEntryNode]
        :return: Selectable entries

        Since: 1.10.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EnumerationNode_AvailableEntries(self)

# Register EnumerationNode in _ids_peak_python_interface:
_ids_peak_python_interface.EnumerationNode_swigregister(EnumerationNode)
NodeDisplayNotation_Automatic = _ids_peak_python_interface.NodeDisplayNotation_Automatic
NodeDisplayNotation_Fixed = _ids_peak_python_interface.NodeDisplayNotation_Fixed
NodeDisplayNotation_Scientific = _ids_peak_python_interface.NodeDisplayNotation_Scientific
class FloatNode(Node):
    r"""Represents a GenAPI float node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    NodeType = _ids_peak_python_interface.FloatNode_NodeType
    __swig_destroy__ = _ids_peak_python_interface.delete_FloatNode

    def Minimum(self) -> "float":
        r"""
        Returns the minimum.

        :rtype: float
        :return: Minimum

        Since: 1.0

        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_Minimum(self)

    def Maximum(self) -> "float":
        r"""
        Returns the maximum.

        :rtype: float
        :return: Maximum

        Since: 1.0

        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_Maximum(self)

    def Increment(self) -> "float":
        r"""
        Returns the increment.

        :rtype: float
        :return: Increment

        Since: 1.0

        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_Increment(self)

    def IncrementType(self) -> "int":
        r"""
        Returns the increment type.

        :rtype: int
        :return: Increment type

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_IncrementType(self)

    def ValidValues(self) -> "Sequence[double]":
        r"""
        Returns the valid values.

        This function returns a list of valid values. A numeric node can have a list of valid values if it does not have
        a constant increment.

        :rtype: Sequence[double]
        :return: Valid values

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_ValidValues(self)

    def Representation(self) -> "int":
        r"""
        Returns the representation.

        :rtype: int
        :return: Representation

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_Representation(self)

    def Unit(self) -> "str":
        r"""
        Returns the unit.

        :rtype: str
        :return: Unit

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_Unit(self)

    def DisplayNotation(self) -> "int":
        r"""
        Returns the display notation.

        :rtype: int
        :return: Display notation

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_DisplayNotation(self)

    def DisplayPrecision(self) -> "int":
        r"""
        Returns the display precision.

        :rtype: int
        :return: Display precision

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_DisplayPrecision(self)

    def HasConstantIncrement(self) -> "bool":
        r"""
        Checks whether the node has a constant increment.

        :rtype: boolean
        :return: True, if the node has a constant increment.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_HasConstantIncrement(self)

    def Value(self, *args) -> "float":
        r"""
        Returns the value.

        :type cacheUsePolicy: int, in, optional
        :param cacheUsePolicy: A flag telling whether the value should be read using the internal cache.

        :rtype: float
        :return: Value

        Since: 1.0

        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_Value(self, *args)

    def SetValue(self, value: "float") -> "None":
        r"""
        Sets the given value.

        :type value: float, in
        :param value: The value to set.

        Since: 1.0

        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FloatNode_SetValue(self, value)

# Register FloatNode in _ids_peak_python_interface:
_ids_peak_python_interface.FloatNode_swigregister(FloatNode)
class IntegerNode(Node):
    r"""Represents a GenAPI integer node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    NodeType = _ids_peak_python_interface.IntegerNode_NodeType
    __swig_destroy__ = _ids_peak_python_interface.delete_IntegerNode

    def Minimum(self) -> "int":

        return _ids_peak_python_interface.IntegerNode_Minimum(self)

    def Maximum(self) -> "int":

        return _ids_peak_python_interface.IntegerNode_Maximum(self)

    def Increment(self) -> "int":

        return _ids_peak_python_interface.IntegerNode_Increment(self)

    def IncrementType(self) -> "int":

        return _ids_peak_python_interface.IntegerNode_IncrementType(self)

    def ValidValues(self) -> "Sequence[int]":

        return _ids_peak_python_interface.IntegerNode_ValidValues(self)

    def Representation(self) -> "int":

        return _ids_peak_python_interface.IntegerNode_Representation(self)

    def Unit(self) -> "str":

        return _ids_peak_python_interface.IntegerNode_Unit(self)

    def Value(self, *args) -> "int":

        return _ids_peak_python_interface.IntegerNode_Value(self, *args)

    def SetValue(self, value: "int") -> "None":

        return _ids_peak_python_interface.IntegerNode_SetValue(self, value)

# Register IntegerNode in _ids_peak_python_interface:
_ids_peak_python_interface.IntegerNode_swigregister(IntegerNode)
class RegisterNode(Node):
    r"""Represents a GenAPI register node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    NodeType = _ids_peak_python_interface.RegisterNode_NodeType
    __swig_destroy__ = _ids_peak_python_interface.delete_RegisterNode

    def Address(self) -> "int":
        r"""
        Returns the address.

        :rtype: int
        :return: Address

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.RegisterNode_Address(self)

    def Length(self) -> "int":
        r"""
        Returns the length.

        :rtype: int
        :return: Length

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.RegisterNode_Length(self)

    def Read(self, *args) -> "Sequence[int]":
        r"""
        Reads a given amount of bytes.

        :type numBytes: int, in
        :param numBytes: The amount of bytes to read.
        :type cacheUsePolicy: int, in, optional
        :param cacheUsePolicy: A flag telling whether the value should be read using the internal cache.

        :rtype: Sequence[int]
        :return: Read bytes

        Since: 1.0

        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.RegisterNode_Read(self, *args)

    def Write(self, *args) -> "None":
        r"""
        *Overload 1:*

        Writes a given amount of bytes.

        :type bytes: Sequence[int]
        :param bytes: The bytes to write.

        Since: 1.0

        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.

        |

        *Overload 2:*

        Writes a given amount of bytes.

        :type bytes: int, in
        :param bytes: The bytes to write.
        :type size: int, in
        :param size: The size of bytes to write.

        Since: 1.10

        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.RegisterNode_Write(self, *args)

# Register RegisterNode in _ids_peak_python_interface:
_ids_peak_python_interface.RegisterNode_swigregister(RegisterNode)
class StringNode(Node):
    r"""Represents a GenAPI str node."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    NodeType = _ids_peak_python_interface.StringNode_NodeType
    __swig_destroy__ = _ids_peak_python_interface.delete_StringNode

    def MaximumLength(self) -> "int":
        r"""
        Returns the maximum length.

        :rtype: int
        :return: Maximum length

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.StringNode_MaximumLength(self)

    def Value(self, *args) -> "str":

        return _ids_peak_python_interface.StringNode_Value(self, *args)

    def SetValue(self, value: "str") -> "None":

        return _ids_peak_python_interface.StringNode_SetValue(self, value)

# Register StringNode in _ids_peak_python_interface:
_ids_peak_python_interface.StringNode_swigregister(StringNode)
class NodeMap(object):
    r"""
    Represents a GenAPI node map.

    This class allows to interact with the nodes of a module.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_NodeMap

    def HasNode(self, name: "str") -> "bool":
        r"""
        Checks whether the node map contains a node with the given name.

        Notes: This function does **not** consider the access status and whether
              a node is implemented or available.

        :type name: str, in
        :param name: The name of the node to find.

        Since: 1.2

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_HasNode(self, name)

    def FindNode(self, name: "str") -> "Union[Node|FloatNode|IntegerNode|StringNode|CategoryNode|BooleanNode|CommandNode|EnumerationNode|RegisterNode]":
        r"""
        Find a node with the given name.

        :type name: str, in
        :param name: The name of the node to find.

        :rtype: :py:class:`Node`
        :return: Found node.
        :rtype: :py:class:`Node`
        :return: If no node with the given name exists, a NotFoundException is thrown.

        Since: 1.0

        :raises: NotFoundException There is no node with the given name
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_FindNode(self, name)

    def TryFindNode(self, name: "str") -> "Union[Node|FloatNode|IntegerNode|StringNode|CategoryNode|BooleanNode|CommandNode|EnumerationNode|RegisterNode]":
        r"""
        Tries to find a node with the given name.

        :type name: str, in
        :param name: The name of the node to find.

        :rtype: :py:class:`Node`
        :return: Found node or nullptr if no node with the given name exists.

        Since: 1.10.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_TryFindNode(self, name)

    def InvalidateNodes(self) -> "None":
        r"""
        Invalidates all nodes.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_InvalidateNodes(self)

    def PollNodes(self, elapsedTime_ms: "int") -> "None":
        r"""
        Polls all nodes having a polling time.

        :type elapsedTime_ms: int, in
        :param elapsedTime_ms: The elapsed time since the last poll in milliseconds.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_PollNodes(self, elapsedTime_ms)

    def Nodes(self) -> "Sequence[Node]":
        r"""
        Returns the nodes.

        :rtype: Sequence[Node]
        :return: Nodes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_Nodes(self)

    def HasBufferSupportedChunks(self, buffer: "Buffer") -> "bool":
        r"""
        Checks if the Buffer contains chunks corresponding to the NodeMap.

        :type buffer: :py:class:`Buffer`, in
        :param buffer: The Buffer to check.

        Since: 1.1

        :raises: InvalidArgumentException The given buffer is invalid.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_HasBufferSupportedChunks(self, buffer)

    def UpdateChunkNodes(self, buffer: "Buffer") -> "None":
        r"""
        Updates chunk information in the NodeMap.

        :type buffer: :py:class:`Buffer`, in
        :param buffer: The Buffer to update from.

        When chunks are active, pass each new buffer to this method to parse the chunks and update the corresponding
        chunk nodes in the NodeMap.

        Since: 1.1

        :raises: InvalidArgumentException The given buffer is invalid.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_UpdateChunkNodes(self, buffer)

    def HasEventSupportedData(self, event: "Any") -> "bool":
        r"""
        Checks if the Event contains data corresponding to the NodeMap.

        :type event: unique_ptr< Event >, in
        :param event: The Event to check.

        Since: 1.2

        :raises: InvalidArgumentException The given event is invalid.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_HasEventSupportedData(self, event)

    def UpdateEventNodes(self, event: "Any") -> "None":
        r"""
        Updates event information in the NodeMap.

        :type event: unique_ptr< Event >, in
        :param event: The Event to update from.

        When events are active, pass each new event to this method to parse the event data and update the corresponding
        nodes in the NodeMap.

        Since: 1.2

        :raises: InvalidArgumentException The given Event does not have supported data
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_UpdateEventNodes(self, event)

    def StoreToFile(self, filePath: "str") -> "None":
        r"""
        Stores the values of streamable nodes to the file at the given file path.

        :type filePath: str, in
        :param filePath: The path of the file to store to.

        The stored file uses the GenApi persistence file format. It is not recommended to edit files using this format
        manually unless you are familiar with the GenApi persistence functionality.

        Notes: The ``filePath`` is UTF-8 encoded.

        Since: 1.1

        :raises: InvalidArgumentException The given file path is invalid
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_StoreToFile(self, filePath)

    def LoadFromFile(self, filePath: "str") -> "None":
        r"""
        Loads the values of streamable nodes from the file at the given file path.

        :type filePath: str, in
        :param filePath: The path of the file to load from.

        The file to load has to use the GenApi persistence file format. It is not recommended to edit files using this
        format manually unless you are familiar with the GenApi persistence functionality.

        Notes: The ``filePath`` is UTF-8 encoded.

        Since: 1.1

        :raises: InvalidArgumentException The given file path is invalid
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_LoadFromFile(self, filePath)

    def Lock(self) -> "Any":
        r"""
        Locks a recursive mutex on the NodeMap.

        Use this to synchronize NodeMap access from multiple threads.

        Notes: Each individual access is already protected by this mutex, so the nodemap doesn't need to
              be locked for those. But often, nodemap access consists of multiple calls, e.g.: First,
              (1.) change a selector value (e.g. set "GainSelector" node to "DigitalRed"), then (2.)
              access a selected node (e.g. set value in "Gain" node). If a different thread changes the
              selector value between (1.) and (2.), (2.) will access the wrong selected
              node. These kinds of calls should be protected by this lock.

        :rtype: unique_ptr< ScopedNodeMapLock >
        :return: A ScopedNodeMapLock, which holds the lock and releases it on destruction.

        Since: 1.2

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_Lock(self)

    def TryLock(self) -> "Any":
        r"""
        Locks a recursive mutex on the NodeMap.

        Use this to synchronize NodeMap access from multiple threads.
        Tries to lock the node map. This call is non-blocking.

        Notes: Each individual access is already protected by this mutex, so the nodemap doesn't need to
              be locked for those. But often, nodemap access consists of multiple calls, e.g.: First,
              (1.) change a selector value (e.g. set "GainSelector" node to "DigitalRed"), then (2.)
              access a selected node (e.g. set value in "Gain" node). If a different thread changes the
              selector value between (1.) and (2.), (2.) will access the wrong selected
              node. These kinds of calls should be protected by this lock.

        :rtype: unique_ptr< ScopedNodeMapLock >
        :return: A unique pointer containing the ScopedNodeMapLock, which holds the lock and releases it on destruction
                    if the lock could be acquired or a null unique pointer when it could not.

        Since: 1.11

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.NodeMap_TryLock(self)

    def Handle(self) -> "int":
        r"""
        Get the backend handle

        Use this to use the c interface directly (not recommended)

        :rtype: PEAK_NODE_MAP_HANDLE
        :return: The PEAK_NODE_MAP_HANDLE

        Since: 1.5
        """
        return _ids_peak_python_interface.NodeMap_Handle(self)

# Register NodeMap in _ids_peak_python_interface:
_ids_peak_python_interface.NodeMap_swigregister(NodeMap)
PortURLScheme_Local = _ids_peak_python_interface.PortURLScheme_Local
PortURLScheme_HTTP = _ids_peak_python_interface.PortURLScheme_HTTP
PortURLScheme_File = _ids_peak_python_interface.PortURLScheme_File
PortURLScheme_Custom = _ids_peak_python_interface.PortURLScheme_Custom
class PortURL(object):
    r"""
    Represents a GenTL port URL.

    This class allows to query information about a GenTL port URL.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_PortURL

    def Info(self, infoCommand: "int") -> "RawInformation":

        return _ids_peak_python_interface.PortURL_Info(self, infoCommand)

    def URL(self) -> "str":
        r"""
        Returns the URL.

        :rtype: str
        :return: URL

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_URL(self)

    def Scheme(self) -> "int":
        r"""
        Returns the scheme.

        :rtype: int
        :return: Scheme

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_Scheme(self)

    def FileName(self) -> "str":
        r"""
        Returns the file name.

        :rtype: str
        :return: File name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileName(self)

    def FileRegisterAddress(self) -> "int":
        r"""
        Returns the file register address.

        :rtype: int
        :return: File register address

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileRegisterAddress(self)

    def FileSize(self) -> "int":
        r"""
        Returns the file size.

        :rtype: int
        :return: File size

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileSize(self)

    def FileSHA1Hash(self) -> "Sequence[int]":
        r"""
        Returns the file SHA1 hash.

        :rtype: Sequence[int]
        :return: File SHA1 hash

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileSHA1Hash(self)

    def FileVersionMajor(self) -> "int":
        r"""
        Returns the file major version.

        :rtype: int
        :return: File major version

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileVersionMajor(self)

    def FileVersionMinor(self) -> "int":
        r"""
        Returns the file major version.

        :rtype: int
        :return: File major version

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileVersionMinor(self)

    def FileVersionSubminor(self) -> "int":
        r"""
        Returns the file subminor version.

        :rtype: int
        :return: File subminor version

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileVersionSubminor(self)

    def FileSchemaVersionMajor(self) -> "int":
        r"""
        Returns the file schema major version.

        :rtype: int
        :return: File schema major version

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileSchemaVersionMajor(self)

    def FileSchemaVersionMinor(self) -> "int":
        r"""
        Returns the file schema minor version.

        :rtype: int
        :return: File schema minor version

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_FileSchemaVersionMinor(self)

    def ParentPort(self) -> "Port":
        r"""
        Returns the parent port.

        :rtype: :py:class:`Port`
        :return: Parent port

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.PortURL_ParentPort(self)

# Register PortURL in _ids_peak_python_interface:
_ids_peak_python_interface.PortURL_swigregister(PortURL)
class Port(object):
    r"""
    Represents a GenTL port.

    This class allows to query information about a GenTL port and to enumerate its URLs.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_Port

    def Info(self, infoCommand: "int") -> "RawInformation":

        return _ids_peak_python_interface.Port_Info(self, infoCommand)

    def ID(self) -> "str":
        r"""
        Returns the ID.

        :rtype: str
        :return: ID

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_ID(self)

    def Name(self) -> "str":
        r"""
        Returns the name.

        :rtype: str
        :return: Name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_Name(self)

    def VendorName(self) -> "str":
        r"""
        Returns the vendor name.

        :rtype: str
        :return: Vendor name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_VendorName(self)

    def ModelName(self) -> "str":
        r"""
        Returns the model name.

        :rtype: str
        :return: Model name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_ModelName(self)

    def Version(self) -> "str":
        r"""
        Returns the version.

        :rtype: str
        :return: Version

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_Version(self)

    def TLType(self) -> "str":

        return _ids_peak_python_interface.Port_TLType(self)

    def ModuleName(self) -> "str":
        r"""
        Returns the module name.

        :rtype: str
        :return: Module name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_ModuleName(self)

    def DataEndianness(self) -> "int":
        r"""
        Returns the data endianness.

        :rtype: int
        :return: Data endianness

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_DataEndianness(self)

    def IsReadable(self) -> "bool":
        r"""
        Checks whether the port is readable.

        :rtype: boolean
        :return: True, if the port is readable
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_IsReadable(self)

    def IsWritable(self) -> "bool":
        r"""
        Checks whether the port is writable.

        :rtype: boolean
        :return: True, if the port is writable.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_IsWritable(self)

    def IsAvailable(self) -> "bool":
        r"""
        Checks whether the port is available.

        :rtype: boolean
        :return: True, if the port is available.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_IsAvailable(self)

    def IsImplemented(self) -> "bool":
        r"""
        Checks whether the port is implemented.

        :rtype: boolean
        :return: True, if the port is implemented.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_IsImplemented(self)

    def Read(self, address: "int", numBytes: "int") -> "Sequence[int]":
        r"""
        Reads a given amount of bytes at a given address.

        :type address: int, in
        :param address: The address to read at.
        :type numBytes: int, in
        :param numBytes: The amount of bytes to read.

        :rtype: Sequence[int]
        :return: Read bytes

        Since: 1.0

        :raises: InvalidAddressException Address is invalid
        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_Read(self, address, numBytes)

    def Write(self, address: "int", bytes: "VectorUInt8") -> "None":
        r"""
        Writes a given amount of bytes at a given address.

        :type address: int, in
        :param address: The address to write at.
        :type bytes: Sequence[int]
        :param bytes: The bytes to write.

        Since: 1.0

        :raises: InvalidAddressException Address is invalid
        :raises: OutOfRangeException The given value is out of range
        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_Write(self, address, bytes)

    def URLs(self) -> "Sequence[PortURL]":
        r"""
        Returns the URLs.

        :rtype: Sequence[PortURL]
        :return: URLs

        Since: 1.0

        :raises: IOException A communication error has occured, e.g. when the device is disconnected.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Port_URLs(self)

# Register Port in _ids_peak_python_interface:
_ids_peak_python_interface.Port_swigregister(Port)
class Module(object):
    r"""
    Represents an extended GenTL port.

    This class extends the functionality of a GenTL port with the functionality of the GenAPI. Instead of separating the
    node map from the port, this class brings them together making it much easier to get things done.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_Module

    def NodeMaps(self) -> "Sequence[NodeMap]":
        r"""
        Returns the module's node maps.

        :rtype: Sequence[NodeMap]
        :return: Node maps

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Module_NodeMaps(self)

    def Port(self) -> "Port":
        r"""
        Returns the module's port.

        :rtype: :py:class:`Port`
        :return: Port

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Module_Port(self)

# Register Module in _ids_peak_python_interface:
_ids_peak_python_interface.Module_swigregister(Module)
class EventSupportingModule(Module):
    r"""
    The base class for all modules being able to raise events.

    This class generalizes all modules supporting events (System, Interface, Device, DataStream, Buffer).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_EventSupportingModule

    def EnableEvents(self, type: "int") -> "Any":
        r"""
        Enables events of the given event type.

        :type type: int, in
        :param type: The event type to enable.

        :rtype: unique_ptr< EventController >
        :return: Event controller for the given event type

        Since: 1.0

        :raises: BadAccessException Event is already enabled.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.EventSupportingModule_EnableEvents(self, type)

# Register EventSupportingModule in _ids_peak_python_interface:
_ids_peak_python_interface.EventSupportingModule_swigregister(EventSupportingModule)
class ModuleDescriptor(object):
    r"""The base class for all openable modules."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_ModuleDescriptor

    def ID(self) -> "str":
        r"""
        Returns the ID of the described module.

        :rtype: str
        :return: ID

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.ModuleDescriptor_ID(self)

# Register ModuleDescriptor in _ids_peak_python_interface:
_ids_peak_python_interface.ModuleDescriptor_swigregister(ModuleDescriptor)
class _ExtractedPayload(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    size: "Size" = property(_ids_peak_python_interface._ExtractedPayload_size_get, _ids_peak_python_interface._ExtractedPayload_size_set)
    pixel_format: "PixelFormat" = property(_ids_peak_python_interface._ExtractedPayload_pixel_format_get, _ids_peak_python_interface._ExtractedPayload_pixel_format_set)
    data_ptr: "Any" = property(_ids_peak_python_interface._ExtractedPayload_data_ptr_get, _ids_peak_python_interface._ExtractedPayload_data_ptr_set)
    data_size: "int" = property(_ids_peak_python_interface._ExtractedPayload_data_size_get, _ids_peak_python_interface._ExtractedPayload_data_size_set)

    def __init__(self):
        _ids_peak_python_interface._ExtractedPayload_swiginit(self, _ids_peak_python_interface.new__ExtractedPayload())
    __swig_destroy__ = _ids_peak_python_interface.delete__ExtractedPayload

# Register _ExtractedPayload in _ids_peak_python_interface:
_ids_peak_python_interface._ExtractedPayload_swigregister(_ExtractedPayload)

def _ExtractPayloadFromBufferPart(part: "BufferPart") -> "ExtractedPayload":
    return _ids_peak_python_interface._ExtractPayloadFromBufferPart(part)

def _ExtractPayloadFromBuffer(buffer: "Buffer") -> "ExtractedPayload":
    return _ids_peak_python_interface._ExtractPayloadFromBuffer(buffer)

def _ExtractMetadataFromBuffer(buffer: "Buffer") -> "Metadata":
    return _ids_peak_python_interface._ExtractMetadataFromBuffer(buffer)
class BufferChunk(object):
    r"""
    Represents a buffer chunk.

    This class allows to query information about a buffer chunk.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_BufferChunk

    def ID(self) -> "int":
        r"""
        Returns the ID.

        :rtype: int
        :return: ID

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferChunk_ID(self)

    def BasePtr(self) -> "Any":
        r"""
        Returns the base pointer.

        :rtype: void
        :return: Base pointer

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferChunk_BasePtr(self)

    def Size(self) -> "int":
        r"""
        Returns the size.

        :rtype: int
        :return: Size

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferChunk_Size(self)

    def ParentBuffer(self) -> "Buffer":
        r"""
        Returns the parent buffer.

        :rtype: :py:class:`Buffer`
        :return: Parent buffer

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferChunk_ParentBuffer(self)

# Register BufferChunk in _ids_peak_python_interface:
_ids_peak_python_interface.BufferChunk_swigregister(BufferChunk)
BufferPartType_Unknown = _ids_peak_python_interface.BufferPartType_Unknown
BufferPartType_Image2D = _ids_peak_python_interface.BufferPartType_Image2D
BufferPartType_PlaneBiPlanar2D = _ids_peak_python_interface.BufferPartType_PlaneBiPlanar2D
BufferPartType_PlaneTriPlanar2D = _ids_peak_python_interface.BufferPartType_PlaneTriPlanar2D
BufferPartType_PlaneQuadPlanar2D = _ids_peak_python_interface.BufferPartType_PlaneQuadPlanar2D
BufferPartType_Image3D = _ids_peak_python_interface.BufferPartType_Image3D
BufferPartType_PlaneBiPlanar3D = _ids_peak_python_interface.BufferPartType_PlaneBiPlanar3D
BufferPartType_PlaneTriPlanar3D = _ids_peak_python_interface.BufferPartType_PlaneTriPlanar3D
BufferPartType_PlaneQuadPlanar3D = _ids_peak_python_interface.BufferPartType_PlaneQuadPlanar3D
BufferPartType_ConfidenceMap = _ids_peak_python_interface.BufferPartType_ConfidenceMap
BufferPartType_Custom = _ids_peak_python_interface.BufferPartType_Custom
class BufferPart(object):
    r"""
    Represents a buffer part.

    This class allows to query information about a buffer part.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_BufferPart

    def Info(self, infoCommand: "int") -> "RawInformation":

        return _ids_peak_python_interface.BufferPart_Info(self, infoCommand)

    def SourceID(self) -> "int":
        r"""
        Returns the source ID.

        :rtype: int
        :return: Source ID

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_SourceID(self)

    def BasePtr(self) -> "Any":
        r"""
        Returns the base pointer.

        :rtype: void
        :return: Base pointer

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_BasePtr(self)

    def Size(self) -> "int":
        r"""
        Returns the size in bytes.

        :rtype: int
        :return: Size in bytes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_Size(self)

    def Type(self) -> "int":
        r"""
        Returns the type.

        :rtype: int
        :return: Type

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_Type(self)

    def Format(self) -> "int":
        r"""
        Returns the format.

        :rtype: int
        :return: Format

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_Format(self)

    def FormatNamespace(self) -> "int":
        r"""
        Returns the format namespace.

        :rtype: int
        :return: Format namespace

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_FormatNamespace(self)

    def Width(self) -> "int":
        r"""
        Returns the width.

        :rtype: int
        :return: Width

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_Width(self)

    def Height(self) -> "int":
        r"""
        Returns the height.

        :rtype: int
        :return: Height

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_Height(self)

    def XOffset(self) -> "int":
        r"""
        Returns the x offset.

        :rtype: int
        :return: X offset

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_XOffset(self)

    def YOffset(self) -> "int":
        r"""
        Returns the y offset.

        :rtype: int
        :return: Y offset

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_YOffset(self)

    def XPadding(self) -> "int":
        r"""
        Returns the x padding.

        :rtype: int
        :return: X padding

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_XPadding(self)

    def DeliveredImageHeight(self) -> "int":
        r"""
        Returns the delivered image height.

        :rtype: int
        :return: Delivered image height

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_DeliveredImageHeight(self)

    def ParentBuffer(self) -> "Buffer":
        r"""
        Returns the parent buffer.

        :rtype: :py:class:`Buffer`
        :return: Parent buffer

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.BufferPart_ParentBuffer(self)

    def ToImageView(self) -> ImageView:
        """
        Create an ImageView object from this buffer part

        :return: ImageView object, implementing ids_peak_common.IImageView

        Since 1.12
        """
        from .image_view import ImageView
        return ImageView(self)


# Register BufferPart in _ids_peak_python_interface:
_ids_peak_python_interface.BufferPart_swigregister(BufferPart)
BufferPayloadType_Unknown = _ids_peak_python_interface.BufferPayloadType_Unknown
BufferPayloadType_Image = _ids_peak_python_interface.BufferPayloadType_Image
BufferPayloadType_RawData = _ids_peak_python_interface.BufferPayloadType_RawData
BufferPayloadType_File = _ids_peak_python_interface.BufferPayloadType_File
BufferPayloadType_Chunk = _ids_peak_python_interface.BufferPayloadType_Chunk
BufferPayloadType_JPEG = _ids_peak_python_interface.BufferPayloadType_JPEG
BufferPayloadType_JPEG2000 = _ids_peak_python_interface.BufferPayloadType_JPEG2000
BufferPayloadType_H264 = _ids_peak_python_interface.BufferPayloadType_H264
BufferPayloadType_ChunkOnly = _ids_peak_python_interface.BufferPayloadType_ChunkOnly
BufferPayloadType_DeviceSpecific = _ids_peak_python_interface.BufferPayloadType_DeviceSpecific
BufferPayloadType_MultiPart = _ids_peak_python_interface.BufferPayloadType_MultiPart
BufferPayloadType_Custom = _ids_peak_python_interface.BufferPayloadType_Custom
PixelFormatNamespace_GEV = _ids_peak_python_interface.PixelFormatNamespace_GEV
PixelFormatNamespace_IIDC = _ids_peak_python_interface.PixelFormatNamespace_IIDC
PixelFormatNamespace_PFNC16Bit = _ids_peak_python_interface.PixelFormatNamespace_PFNC16Bit
PixelFormatNamespace_PFNC32Bit = _ids_peak_python_interface.PixelFormatNamespace_PFNC32Bit
PixelFormatNamespace_Custom = _ids_peak_python_interface.PixelFormatNamespace_Custom
class Buffer(EventSupportingModule):
    r"""
    Represents a GenTL buffer module.

    This class allows to query information about a GenTL buffer module and to enumerate its chunks or parts.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_Buffer

    def Info(self, infoCommand: "int") -> "RawInformation":
        r"""Information based on GenTL BUFFER_INFO_CMD."""
        return _ids_peak_python_interface.Buffer_Info(self, infoCommand)

    def TLType(self) -> "str":

        return _ids_peak_python_interface.Buffer_TLType(self)

    def BasePtr(self) -> "Any":
        r"""
        Returns the base pointer.

        :rtype: void
        :return: Base pointer

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_BasePtr(self)

    def Size(self) -> "int":
        r"""
        Returns the size of the buffer in bytes.

        :rtype: int
        :return: Buffer size in bytes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_Size(self)

    def PayloadType(self) -> "int":
        r"""
        Returns the payload type.

        :rtype: int
        :return: Payload type

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_PayloadType(self)

    def PixelFormat(self) -> "int":
        r"""
        Returns the pixel format of the data.

        The interpretation of the pixel format depends on the namespace the pixel format beints to. This can be
        inquired using PixelFormatNamespace().

        :rtype: int
        :return: Pixel format

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_PixelFormat(self)

    def PixelFormatNamespace(self) -> "int":
        r"""
        Returns the pixel format namespace, to allow interpretation of the PixelFormat().

        :rtype: int
        :return: Pixel format namespace

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_PixelFormatNamespace(self)

    def PixelEndianness(self) -> "int":
        r"""
        Returns the pixel endianness.

        :rtype: int
        :return: Pixel endianness

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_PixelEndianness(self)

    def ExpectedDataSize(self) -> "int":
        r"""
        Returns the expected data size.

        :rtype: int
        :return: Expected data size

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_ExpectedDataSize(self)

    def DeliveredDataSize(self) -> "int":
        r"""
        Returns the delivered data size.

        :rtype: int
        :return: Delivered data size

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_DeliveredDataSize(self)

    def FrameID(self) -> "int":
        r"""
        Returns the identifier of the current frame.

        The frame ID is a sequentially incremented value that increases by one
        from one frame to the next. It serves as a means to detect missing or
        out-of-order frames in a stream. Once the maximum value supported by
        the device and transport layer is reached, the frame ID wraps back to zero.
        The exact wrap-around point is not fixed and depends on both the device
        and the transport layer in use.

        :rtype: int
        :return: A 64-bit unsigned integer representing the frame ID.

        Since: 1.0

        :raises: InternalErrorException If an internal error occurs.
        """
        return _ids_peak_python_interface.Buffer_FrameID(self)

    def ImageOffset(self) -> "int":
        r"""
        Returns the offset of the image data from the beginning of the delivered buffer in bytes.

        :rtype: int
        :return: Image offset in bytes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_ImageOffset(self)

    def DeliveredImageHeight(self) -> "int":
        r"""
        Returns the delivered image height.

        :rtype: int
        :return: Delivered image height

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_DeliveredImageHeight(self)

    def DeliveredChunkPayloadSize(self) -> "int":
        r"""
        Returns the delivered chunk payload size.

        :rtype: int
        :return: Delivered chunk payload size

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_DeliveredChunkPayloadSize(self)

    def ChunkLayoutID(self) -> "int":
        r"""
        Returns the chunk layout ID.

        :rtype: int
        :return: Chunk layout ID

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_ChunkLayoutID(self)

    def FileName(self) -> "str":
        r"""
        Retrieves the file name.

        Returns the file name if the payload contains a file.
        For example, in GigE Vision, this corresponds to information provided
        in the image stream data leader. Implementations for other technologies
        should provide similar functionality as appropriate.

        As this is based on GigE Vision, the file name is UTF-8 encoded,
        consistent with the GigE Vision specification.

        :rtype: str
        :return: A UTF-8 encoded file name as a str.

        Since: 1.0

        :raises: InternalErrorException If an internal error occurs.
        """
        return _ids_peak_python_interface.Buffer_FileName(self)

    def Width(self) -> "int":
        r"""
        Returns the width.

        :rtype: int
        :return: Width

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_Width(self)

    def Height(self) -> "int":
        r"""
        Returns the height.

        :rtype: int
        :return: Height

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_Height(self)

    def XOffset(self) -> "int":
        r"""
        Returns the x offset of the data in the buffer in number of pixels from the image origin to handle
        areas of interest.

        :rtype: int
        :return: X offset in number of pixels

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_XOffset(self)

    def YOffset(self) -> "int":
        r"""
        Returns the y offset of the data in the buffer in number of lines from the image origin to handle
        areas of interest.

        :rtype: int
        :return: Y offset in number of lines

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_YOffset(self)

    def XPadding(self) -> "int":
        r"""
        Returns the x padding of the data in the buffer in number of bytes.

        :rtype: int
        :return: X padding in bytes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_XPadding(self)

    def YPadding(self) -> "int":
        r"""
        Returns the y padding of the data in the buffer in number of bytes.

        :rtype: int
        :return: Y padding in bytes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_YPadding(self)

    def Timestamp_ticks(self) -> "int":
        r"""
        Returns the timestamp.

        :rtype: int
        :return: Timestamp in ticks

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_Timestamp_ticks(self)

    def Timestamp_ns(self) -> "int":
        r"""
        Returns the timestamp associated with when the image was recorded.

        The timestamp is expressed in nanoseconds and is relative to a
        reference point (t = 0) defined by the transport layer and the device.
        This reference point is not known to the caller. The timestamp does not
        represent an absolute wall-clock time, but instead the elapsed time since
        that reference. The difference between timestamps of consecutive images
        indicates the time interval between their recordings.

        Depending on the transport layer, timestamp information might not be
        provided.

        :rtype: int
        :return: Timestamp in nanoseconds, relative to an unknown reference point.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_Timestamp_ns(self)

    def IsQueued(self) -> "bool":
        r"""
        Checks whether the buffer is queued  or not.

        :rtype: boolean
        :return: True, while the buffer is in the input pool, is currently being filled or is in the output buffer queue.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_IsQueued(self)

    def IsAcquiring(self) -> "bool":
        r"""
        Checks whether the buffer is currently being filled.

        :rtype: boolean
        :return: True, while the buffer is being filled.
        :rtype: boolean
        :return: False otherwise.


        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_IsAcquiring(self)

    def IsIncomplete(self) -> "bool":
        r"""
        Checks whether the buffer is incomplete or not.

        Incomplete buffers can happen when an error occurred while the buffer was being filled.

        :rtype: boolean
        :return: True if the buffer couldn't be filled completely.
        :rtype: boolean
        :return: False if the buffer is complete.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_IsIncomplete(self)

    def HasNewData(self) -> "bool":
        r"""
        Checks whether the buffer has new data since the last delivery.

        :rtype: boolean
        :return: True when the buffer has new data since the last delivery.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_HasNewData(self)

    def HasImage(self) -> "bool":
        r"""
        Checks whether the buffer contains image data.

        :rtype: boolean
        :return: True, if the buffer contains an image.
        :rtype: boolean
        :return: False otherwise.

        See GenTL BUFFER_INFO_IMAGEPRESENT.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_HasImage(self)

    def HasChunks(self) -> "bool":
        r"""
        Checks whether the buffer contains chunks.

        If HasChunks() is true, check the BufferChunks using Chunks().

        :rtype: boolean
        :return: True, if the buffer has chunks.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_HasChunks(self)

    def HasParts(self) -> "bool":
        r"""
        Checks whether the buffer contains parts.

        If HasParts() is true, check the BufferParts using Parts().

        :rtype: boolean
        :return: True, if the buffer has parts.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.8

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_HasParts(self)

    def Chunks(self) -> "Sequence[BufferChunk]":
        r"""
        Returns the buffer's chunks if it contains chunks.

        Check if the buffer has chunks with HasChunks().

        :rtype: Sequence[BufferChunk]
        :return: Buffer chunks

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_Chunks(self)

    def Parts(self) -> "Sequence[BufferPart]":
        r"""
        Returns all buffer parts for multipart buffers.

        :rtype: Sequence[BufferPart]
        :return: Buffer parts

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_Parts(self)

    def ParentDataStream(self) -> "DataStream":
        r"""
        Returns the parent data stream.

        :rtype: :py:class:`DataStream`
        :return: Parent data stream

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Buffer_ParentDataStream(self)

    def ToImageView(self) -> ImageView:
        """
        Create an ImageView object from this buffer

        :return: ImageView object, implementing ids_peak_common.IImageView

        Since 1.12
        """
        from .image_view import ImageView
        return ImageView(self)


# Register Buffer in _ids_peak_python_interface:
_ids_peak_python_interface.Buffer_swigregister(Buffer)
DataStreamFlushMode_InputPoolToOutputQueue = _ids_peak_python_interface.DataStreamFlushMode_InputPoolToOutputQueue
r"""
    Flushes the buffers from the input pool to the
    output buffer queue and if necessary adds
    entries in the "New Buffer" event data queue.
    The buffers currently being filled are not
    affected by this operation.
    """
DataStreamFlushMode_DiscardOutputQueue = _ids_peak_python_interface.DataStreamFlushMode_DiscardOutputQueue
r"""
    Discards all buffers in the output buffer queue
    and if necessary remove the entries from the
    event data queue.
    """
DataStreamFlushMode_AllToInputPool = _ids_peak_python_interface.DataStreamFlushMode_AllToInputPool
r"""
    Puts all buffers in the input pool. This is
    including those in the output buffer queue and
    the ones which are currently being filled and
    discard entries in the event data queue.
    """
DataStreamFlushMode_UnqueuedToInputPool = _ids_peak_python_interface.DataStreamFlushMode_UnqueuedToInputPool
r"""
    Puts all buffers that are neither in the input pool
    nor being currently filled nor in the output
    buffer queue in the input pool.
    """
DataStreamFlushMode_DiscardAll = _ids_peak_python_interface.DataStreamFlushMode_DiscardAll
r"""
    Discards all buffers in the input pool and the
    buffers in the output queue including buffers
    currently being filled so that no buffer is bound
    to any internal mechanism and all buffers may
    be revoked or requeued.
    """
DataStreamFlushMode_Custom = _ids_peak_python_interface.DataStreamFlushMode_Custom
r"""Starting value for GenTL Producer custom IDs which are implementation specific."""
AcquisitionStartMode_Default = _ids_peak_python_interface.AcquisitionStartMode_Default
r"""Default behavior."""
AcquisitionStartMode_Custom = _ids_peak_python_interface.AcquisitionStartMode_Custom
r"""Starting value for GenTL Producer custom IDs which are implementation specific."""
AcquisitionStopMode_Default = _ids_peak_python_interface.AcquisitionStopMode_Default
r"""
    Stops the acquisition engine when the currently
    running tasks like filling a buffer are completed
    (default behavior).
    """
AcquisitionStopMode_Kill = _ids_peak_python_interface.AcquisitionStopMode_Kill
r"""
    Stop the acquisition engine immediately. In
    case this results in a partially filled buffer the
    Producer will return the buffer through the
    regular mechanism to the user, indicating
    through the info function of that buffer that this
    buffer is not complete.
    """
AcquisitionStopMode_Custom = _ids_peak_python_interface.AcquisitionStopMode_Custom
r"""Starting value for GenTL Producer custom IDs which are implementation specific."""
class DataStream(EventSupportingModule):
    r"""
    Represents a GenTL DataStream module.

    This class allows to query information about a GenTL DataStream module and to manage and receive
    Buffer Buffers from the physical device.

    The workflow for the buffers follows the GenTL model: First, memory needs to be allocated and announced to
    the API, so they are in the GenTL "Announced Buffer Pool". Then, the buffers are queued, so they are available in
    the GenTL "Input Buffer Pool". From this pool, buffers are chosen and filled by the device. Once a buffer is filled,
    i.e. a new frame is available, it is added to the GenTL "Output Buffer Queue" and a "NewBufferEvent" is sent. At
    this point, the newly filled buffer is available to the API.

    ### Buffer management

    There are two options for managing memory for the buffers:
    * Allocate the memory for the buffer yourself and announce it to the API yourself, using AnnounceBuffer().
      Then you'll also need to free the memory for the buffer yourself, once you are done. To help with that,
      AnnounceBuffer() allows to add a callback, which is called when the buffer is revoked. At that point the memory
      won't be used anymore, and therefore can be deleted. If you don't add this callback, you'll have to manage the
      time of deletion yourself.
    * Let the API allocate and free the memory for the buffer, using AllocAndAnnounceBuffer(). Then, the memory
      will be freed automatically when the buffer is revoked.

    After announcing the buffer, use QueueBuffer() to move it to the "Input Buffer Pool".

    Once a Buffer is not needed anymore, revoke it using RevokeBuffer().

    Use Flush() to move buffers between the Input Buffer Pool, the Output Buffer Queue and the Announced Buffer Pool.

    ### Receiving new buffers

    Once enough buffers are announced and queued, use StartAcquisition() to start generating new frames.

    Notes: Typically, the RemoteDevice also needs to be started using its NodeMap, e.g.:

    .. code- c++

        stream->StartAcquisition(Default);
        remoteDevice->NodeMaps()[0]->FindNode<CommandNode>("AcquisitionStart")->Execute();
        remoteDevice->NodeMaps()[0]->FindNode<CommandNode>("AcquisitionStart")->WaitUntilDone();

    Once the acquisition is started, wait for the NewBufferEvent using WaitForFinishedBuffer(), which blocks until a
    newly filled buffer is available.

    See GenTL Data Stream Module.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    INFINITE_NUMBER = _ids_peak_python_interface.DataStream_INFINITE_NUMBER
    r"""The constant defining an infinite number, used in StartAcquisition()."""
    __swig_destroy__ = _ids_peak_python_interface.delete_DataStream

    def Key(self) -> "str":

        return _ids_peak_python_interface.DataStream_Key(self)

    def Info(self, infoCommand: "int") -> "RawInformation":

        return _ids_peak_python_interface.DataStream_Info(self, infoCommand)

    def ID(self) -> "str":

        return _ids_peak_python_interface.DataStream_ID(self)

    def TLType(self) -> "str":

        return _ids_peak_python_interface.DataStream_TLType(self)

    def NumBuffersAnnouncedMinRequired(self) -> "int":
        r"""
        Returns the minimum number of buffers that must be announced before starting the acquisition
        with #StartAcquisition.

        This value is influenced by the "StreamBufferHandlingMode" node in the datastream nodemap.

        :rtype: int
        :return: The minimum number of announced buffers required.

        Since: 1.0

        :raises: InternalErrorException If an internal error occurs.
        """
        return _ids_peak_python_interface.DataStream_NumBuffersAnnouncedMinRequired(self)

    def NumBuffersAnnounced(self) -> "int":
        r"""
        Retrieves the count of buffers announced via #AnnounceBuffer or #AllocAndAnnounceBuffer.

        The state or pool of the buffers does not affect the count, as int as they have been announced.

        :rtype: int
        :return: The number of buffers that have been announced.

        Since: 1.0

        :raises: InternalErrorException If an internal error occurs.
        """
        return _ids_peak_python_interface.DataStream_NumBuffersAnnounced(self)

    def NumBuffersQueued(self) -> "int":
        r"""
        Retrieves the count of buffers that are currently queued,
        i.e., the number of buffers present in the input pool.

        For additional details, refer to #QueueBuffer and #WaitForFinishedBuffer.

        :rtype: int
        :return: The number of buffers currently queued.

        Since: 1.0

        :raises: InternalErrorException If an internal error occurs.
        """
        return _ids_peak_python_interface.DataStream_NumBuffersQueued(self)

    def NumBuffersAwaitDelivery(self) -> "int":
        r"""
        Retrieves the count of buffers that are currently waiting to be delivered,
        i.e., the number of buffers present in the output pool.

        :rtype: int
        :return: The number of buffers awaiting delivery.

        Since: 1.0

        :raises: InternalErrorException If an internal error occurs.
        """
        return _ids_peak_python_interface.DataStream_NumBuffersAwaitDelivery(self)

    def NumBuffersDelivered(self) -> "int":
        r"""
        Retrieves the count of buffers delivered since the last acquisition start.

        A buffer is considered delivered once it has been retrieved through #WaitForFinishedBuffer.

        This counter is reset to 0 when a new acquisition is initiated, as described in #StartAcquisition.

        :rtype: int
        :return: The number of buffers delivered since the last acquisition start.

        Since: 1.0

        :raises: InternalErrorException If an internal error occurs.
        """
        return _ids_peak_python_interface.DataStream_NumBuffersDelivered(self)

    def NumBuffersStarted(self) -> "int":
        r"""
        Returns the count of buffers that have been initiated.

        This counter increases with each new buffer that the acquisition engine begins to fill,
        regardless of whether the buffer is ultimately discarded or delivered.

        The counter starts at 0 when the #DataStream is opened and is not reset until the #DataStream is closed.

        :rtype: int
        :return: The total number of buffers that have been initiated.

        Since: 1.0

        :raises: InternalErrorException If an internal error occurs.
        """
        return _ids_peak_python_interface.DataStream_NumBuffersStarted(self)

    def NumUnderruns(self) -> "int":
        r"""
        Retrieves the count of underruns.

        This counter increments when the acquisition engine has no buffers queued (see #QueueBuffer)
        and a new frame is received from the remote device. As a result, the acquisition engine discards the
        incoming data because there is no available buffer to store it.

        If you encounter this situation, verify that you are calling #QueueBuffer and ensure the time between receiving
        the buffer through #WaitForFinishedBuffer and calling #QueueBuffer is less than the time required to capture
        a frame (1 / frame rate).

        This counter is reset to zero at the time the #DataStream is opened
        using #OpenDataStream.

        :rtype: int
        :return: The number of underruns.

        Since: 1.0

        :raises: InternalErrorException If an internal error occurs.
        """
        return _ids_peak_python_interface.DataStream_NumUnderruns(self)

    def NumChunksPerBufferMax(self) -> "int":
        r"""
        Returns the maximum number of chunks per buffer.

        :rtype: int
        :return: Maximum number of chunks per buffer

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_NumChunksPerBufferMax(self)

    def BufferAlignment(self) -> "int":
        r"""
        Returns the buffer alignment.

        :rtype: int
        :return: Buffer alignment in bytes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_BufferAlignment(self)

    def PayloadSize(self) -> "int":
        r"""
        Returns the payload size in bytes, i.e. the size of the buffers.

        :rtype: int
        :return: Payload size in bytes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_PayloadSize(self)

    def DefinesPayloadSize(self) -> "bool":
        r"""
        Checks whether the data stream defines the payload size.

        :rtype: boolean
        :return: True, if the DataStream defines the payload size.
        :rtype: boolean
        :return: False otherwise. In this case, ask the RemoteDevice for the payload size instead of the DataStream, e.g.:

                    .. code- c++

                    payload_size =
            device->RemoteDevice()->NodeMaps()[0]->FindNode<IntegerNode>("PayloadSize")->Value();

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_DefinesPayloadSize(self)

    def IsGrabbing(self) -> "bool":
        r"""
        Checks whether the data stream is grabbing.

        :rtype: boolean
        :return: True, while the acquisition is running.
        :rtype: boolean
        :return: False, if the acquisition isn't started yet or was stopped.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_IsGrabbing(self)

    def QueueBuffer(self, buffer: "Buffer") -> "None":
        r"""
        Queues a given buffer.

        Queueing a given buffer makes it available to be used by the acquisition
        engine for receiving new data.

        :type buffer: :py:class:`Buffer`, in
        :param buffer: The buffer to queue.

        Since: 1.0

        :raises: InvalidArgumentException One of the submitted arguments is outside the valid range or is not supported.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_QueueBuffer(self, buffer)

    def RevokeBuffer(self, buffer: "Buffer") -> "None":
        r"""
        Revokes a specified buffer.

        This function revokes the given buffer. If the buffer was allocated by the client, the callback provided
        during the buffer announcement (#AnnounceBuffer) will be triggered.

        Notes: A buffer can only be revoked if it is not queued, meaning it is neither in the input nor the output pool.

        You can use the #Flush function with #DiscardAll as the flush mode to ensure that all
        buffers are safe to be revoked.

        :type buffer: :py:class:`Buffer`, in
        :param buffer: The buffer to revoke.

        Since: 1.0

        :raises: InvalidArgumentException If one of the provided arguments is outside the valid range or unsupported.
        :raises: InternalErrorException If an internal error occurs.
        """
        return _ids_peak_python_interface.DataStream_RevokeBuffer(self, buffer)

    def Flush(self, mode: "int") -> "None":
        r"""
        Move buffers between the Input %Buffer Pool, the Output %Buffer Pool and the Announced %Buffer Pool,
        depending on the mode parameter.

        :type mode: int, in
        :param mode: Operation modes being used to flush the buffers of the data stream.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_Flush(self, mode)

    def AnnouncedBuffers(self) -> "Sequence[Buffer]":
        r"""
        Retrieves the list of the currently announced buffers. The buffers' states are irrelevant, as int as
        they have been announced.

        :rtype: Sequence[Buffer]
        :return: A list of currently announced buffers.

        Since: 1.0

        :raises: InternalErrorException If an internal error occurs.
        """
        return _ids_peak_python_interface.DataStream_AnnouncedBuffers(self)

    def StartAcquisition(self, *args) -> "None":
        r"""
        Starts the acquisition.

        Starts the acquisition engine on the host side. The acquisition on the
        remote device needs to be started separately using the "AcquisitionStart"
        command node.

        The acquisition engine depends on the payload size value not changing
        between announcing the buffers to the data stream and while the
        acquisition is running. For information on how to ensure this can't
        happen, see 'AnnounceBuffer'.

        :type mode: int, in, optional
        :param mode: The mode being used to start the acquisition.
        :type numToAcquire: int, in, optional
        :param numToAcquire: The number of buffers to acquire.

        Since: 1.0

        :raises: BadAccessException The acquisition is already running
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_StartAcquisition(self, *args)

    def StopAcquisition(self, *args) -> "None":
        r"""
        Stops the acquisition.

        :type mode: int, in, optional
        :param mode: The mode being used to stop the acquisition.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_StopAcquisition(self, *args)

    def WaitForFinishedBuffer(self, timeout_ms: "Timeout") -> "Buffer":
        r"""
        Blocking wait for a finished Buffer.

        Block and wait for the next buffer to be received or until the supplied
        timeout is exceeded. In order to wait indefinitely use
        [INFINITE_TIMEOUT](#INFINITE_TIMEOUT).

        A call to #WaitForFinishedBuffer can be aborted immediately and at any time by calling
        #KillWait from another thread, resulting in an #AbortedException being thrown.
        This is especially useful when using [INFINITE_TIMEOUT](#INFINITE_TIMEOUT).

        A buffer returned by #WaitForFinishedBuffer is guaranteed to remain untouched by the acquisition engine,
        until it has been re-queued using #QueueBuffer. Depending on the time it takes the application to process the
        image, it may be beneficial to copy the buffer data, re-queue the buffer and to process the copy.

        If buffers are not re-queued using #QueueBuffer in time and no more buffers are available
                   to the acquisition engine, no buffers will be received and image data will be discarded!
                   For more information see #NumUnderruns.


        :type timeout_ms: :py:class:`Timeout`, in
        :param timeout_ms: The time to wait for a finished buffer in milliseconds.
                                  Use #INFINITE_NUMBER to wait indefinitely.

        :rtype: :py:class:`Buffer`
        :return: Newly filled Buffer.

        Since: 1.0

        :raises: AbortedException The wait was aborted by #KillWait or #FlushPendingKillWaits
        :raises: TimeoutException The function call timed out
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_WaitForFinishedBuffer(self, timeout_ms)

    def KillWait(self) -> "None":
        r"""
        Tells the data stream to kill one call to #WaitForFinishedBuffer.

        Kills one call to #WaitForFinishedBuffer or queues the kill request
        to be applied to the next call. Each kill results in one call to #WaitForFinishedBuffer to be aborted.
        Calling #KillWait multiple times will queue multiple kills.
        A pending #KillWait takes precedence over regular events. This means
        that if both a new buffer event and a pending #KillWait exist, a call
        to #WaitForFinishedBuffer will fail with an #AbortedException.

        Pending kills stay queued even if the acquisition is stopped and restarted.
                   They can only be cleared by closing the datastream or calling #FlushPendingKillWaits.

        To prevent queueing kills, call #KillWait only once and only when your acquisition is running.
        Then, allow the acquisition thread to continue until #WaitForFinishedBuffer triggers an #AbortedException.
        You can verify if the acquisition is running by using #IsGrabbing.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_KillWait(self)

    def FlushPendingKillWaits(self) -> "None":
        r"""
        Flushes the KillWait queue.

        This function clears all queued KillWaits, preventing subsequent calls to #WaitForFinishedBuffer
        from throwing a #AbortedException.

        Calls to #WaitForFinishedBuffer that are currently waiting will be aborted and throw a
        #AbortedException.

        Notes: This function is only available when the acquisition is stopped.

        Any pending new-buffer events will be discarded.
                   Buffers still in the output queue will be moved to a
                   non-queued state, where they will only count as announced and
                   must be requeued. Otherwise, the buffer can not be used by the acquisition engine.
                   To retrieve data from discarded buffers,
                   use IsQueued and HasNewData to identify them.
                   A buffer discarded by FlushPendingKillWaits is expected to contain new
                   data and return `false` for IsQueued.
        Since: 1.11

        :raises: BadAccessException The acquisition is currently running and needs to be stopped first.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStream_FlushPendingKillWaits(self)

    def ParentDevice(self) -> "Device":

        return _ids_peak_python_interface.DataStream_ParentDevice(self)

    def AllocAndAnnounceBuffer(self, size: "int") -> "Buffer":
        r"""
        Allocate and announce a new buffer to the datastream
        :type size: int, in
        :param size: The buffer size to allocate
        :rtype: :py:class:`Buffer`
        :return: the announced buffer
        """
        return _ids_peak_python_interface.DataStream_AllocAndAnnounceBuffer(self, size)

# Register DataStream in _ids_peak_python_interface:
_ids_peak_python_interface.DataStream_swigregister(DataStream)
class DataStreamDescriptor(ModuleDescriptor):
    r"""
    Encapsulates the GenTL functions associated with a GenTL DataStream module's ID.

    This class allows to query information about a GenTL DataStream module without opening it.
    Furthermore, it allows to open this GenTL DataStream module.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DataStreamDescriptor

    def Key(self) -> "str":

        return _ids_peak_python_interface.DataStreamDescriptor_Key(self)

    def ParentDevice(self) -> "Device":
        r"""
        Returns the parent device.

        :rtype: :py:class:`Device`
        :return: Parent device

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStreamDescriptor_ParentDevice(self)

    def OpenDataStream(self) -> "DataStream":
        r"""
        Opens the data stream.

        :rtype: :py:class:`DataStream`
        :return: Opened data stream

        Since: 1.0

        :raises: BadAccessException Access denied
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DataStreamDescriptor_OpenDataStream(self)

    def OpenedDataStream(self) -> "DataStream":
        r"""
        Returns the DataStream that was opened with this DataStreamDescriptor.

        :rtype: :py:class:`DataStream`
        :return: Opened DataStream

        Since: 1.0

        :raises: BadAccessException DataStream is not open
        """
        return _ids_peak_python_interface.DataStreamDescriptor_OpenedDataStream(self)

# Register DataStreamDescriptor in _ids_peak_python_interface:
_ids_peak_python_interface.DataStreamDescriptor_swigregister(DataStreamDescriptor)
DeviceAccessStatus_ReadWrite = _ids_peak_python_interface.DeviceAccessStatus_ReadWrite
DeviceAccessStatus_ReadOnly = _ids_peak_python_interface.DeviceAccessStatus_ReadOnly
DeviceAccessStatus_NoAccess = _ids_peak_python_interface.DeviceAccessStatus_NoAccess
DeviceAccessStatus_Busy = _ids_peak_python_interface.DeviceAccessStatus_Busy
DeviceAccessStatus_OpenReadWrite = _ids_peak_python_interface.DeviceAccessStatus_OpenReadWrite
DeviceAccessStatus_OpenReadOnly = _ids_peak_python_interface.DeviceAccessStatus_OpenReadOnly
DeviceAccessStatus_Custom = _ids_peak_python_interface.DeviceAccessStatus_Custom
class RemoteDevice(Module):
    r"""
    Allows to access the physical Device.

    Access the NodeMap and Port of the physical device. This class doesn't have any additional functionality,
    but helps separate the local virtual device proxy from that actual physical hardware device. I.e. the NodeMap of
    this RemoteDevice is created from the XML file retrieved from the physical device, while the NodeMap of the proxy
    Device is created by the ProducerLibrary (CTI).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_RemoteDevice

    def LocalDevice(self) -> "Device":
        r"""
        Returns the local device (device proxy) of the remote device.

        :rtype: :py:class:`Device`
        :return: Local device of the remote device

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.RemoteDevice_LocalDevice(self)

# Register RemoteDevice in _ids_peak_python_interface:
_ids_peak_python_interface.RemoteDevice_swigregister(RemoteDevice)
class Device(EventSupportingModule):
    r"""
    Represents a GenTL Device module, i.e. a local virtual Device proxy for the actual hardware RemoteDevice.

    This class allows to query information about a GenTL Device module and to enumerate its
    DataStreamDescriptor DataStreamDescriptors, which allows to open the corresponding DataStream.

    Additionally, it allows access to its RemoteDevice, i.e. the actual hardware device. To change hardware settings,
    you typically need to work with the NodeMap of the RemoteDevice. E.g. to change the exposure time:

    .. code- c++

        // get the (first) node map of the remote device
        auto remoteNodeMap = device->RemoteDevice()->NodeMaps().at(0);
        // change exposure time
        remoteNodeMap->FindNode<FloatNode>("ExposureTime")->SetValue(1.5);
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_Device

    def Key(self) -> "str":

        return _ids_peak_python_interface.Device_Key(self)

    def Info(self, infoCommand: "int") -> "RawInformation":

        return _ids_peak_python_interface.Device_Info(self, infoCommand)

    def ID(self) -> "str":

        return _ids_peak_python_interface.Device_ID(self)

    def DisplayName(self) -> "str":

        return _ids_peak_python_interface.Device_DisplayName(self)

    def VendorName(self) -> "str":

        return _ids_peak_python_interface.Device_VendorName(self)

    def ModelName(self) -> "str":

        return _ids_peak_python_interface.Device_ModelName(self)

    def Version(self) -> "str":

        return _ids_peak_python_interface.Device_Version(self)

    def TLType(self) -> "str":

        return _ids_peak_python_interface.Device_TLType(self)

    def UserDefinedName(self) -> "str":

        return _ids_peak_python_interface.Device_UserDefinedName(self)

    def SerialNumber(self) -> "str":

        return _ids_peak_python_interface.Device_SerialNumber(self)

    def AccessStatus(self) -> "int":

        return _ids_peak_python_interface.Device_AccessStatus(self)

    def TimestampTickFrequency(self) -> "int":

        return _ids_peak_python_interface.Device_TimestampTickFrequency(self)

    def RemoteDevice(self) -> "RemoteDevice":
        r"""
        Returns the remote device of the device.

        This function returns the remote device which provides the access to the physical device. In contrast, this class
        acts only as a proxy for the physical device.

        :rtype: :py:class:`RemoteDevice`
        :return: Remote device

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Device_RemoteDevice(self)

    def DataStreams(self) -> "Sequence[DataStreamDescriptor]":
        r"""
        Returns the data stream list of the device.

        :rtype: Sequence[DataStreamDescriptor]
        :return: Data stream list

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Device_DataStreams(self)

    def ParentInterface(self) -> "Interface":

        return _ids_peak_python_interface.Device_ParentInterface(self)

    def Handle(self) -> "int":
        r"""
        Get the backend handle

        Use this to use the c interface directly (not recommended)

        :rtype: PEAK_DEVICE_HANDLE
        :return: The PEAK_DEVICE_HANDLE

        Since: 1.5
        """
        return _ids_peak_python_interface.Device_Handle(self)

# Register Device in _ids_peak_python_interface:
_ids_peak_python_interface.Device_swigregister(Device)
DeviceAccessType_ReadOnly = _ids_peak_python_interface.DeviceAccessType_ReadOnly
DeviceAccessType_Control = _ids_peak_python_interface.DeviceAccessType_Control
DeviceAccessType_Exclusive = _ids_peak_python_interface.DeviceAccessType_Exclusive
DeviceAccessType_Custom = _ids_peak_python_interface.DeviceAccessType_Custom
class DeviceDescriptor(ModuleDescriptor):
    r"""
    Encapsulates the GenTL functions associated with a GenTL Device module's ID.

    This class allows to query information about a GenTL Device module without opening it. Furthermore, it enables
    you to open this GenTL Device module.

    ### Opening a Device

    When you try to open a device with an access mode that is not allowed, a BadAccessException is thrown. To avoid
    that, ask the device if the desired access mode is available with IsOpenable(). By default, IsOpenable
    asks for the highest access mode, Exclusive:

    .. code- c++

        if (deviceDescriptor->IsOpenable())
        {
            device = deviceDescriptor->OpenDevice(Control);
        }

    ### %Device Information Monitoring

    With [this group of methods]('DeviceInformationMonitoring)', you can conveniently monitor for changes of
    information about the device.

    Register a callback using RegisterInformationChangedCallback() and configure which information you want to
    monitor with AddInformationRoleToMonitoring() and RemoveInformationRoleFromMonitoring().

    By default, the following DeviceInformationRoles are monitored:
    * AccessStatus
    * UserDefinedName
    * TimestampTickFrequency
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceDescriptor

    def Key(self) -> "str":

        return _ids_peak_python_interface.DeviceDescriptor_Key(self)

    def Info(self, infoCommand: "int") -> "RawInformation":

        return _ids_peak_python_interface.DeviceDescriptor_Info(self, infoCommand)

    def DisplayName(self) -> "str":
        r"""
        Returns the display name.

        :rtype: str
        :return: Display name

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_DisplayName(self)

    def VendorName(self) -> "str":
        r"""
        Returns the vendor name.

        :rtype: str
        :return: Vendor name

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_VendorName(self)

    def ModelName(self) -> "str":
        r"""
        Returns the model name.

        :rtype: str
        :return: Model name

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_ModelName(self)

    def Version(self) -> "str":
        r"""
        Returns the version.

        :rtype: str
        :return: Version

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_Version(self)

    def TLType(self) -> "str":

        return _ids_peak_python_interface.DeviceDescriptor_TLType(self)

    def UserDefinedName(self) -> "str":
        r"""
        Returns the user defined name.

        :rtype: str
        :return: User defined name

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_UserDefinedName(self)

    def SerialNumber(self) -> "str":
        r"""
        Returns the serial number.

        :rtype: str
        :return: Serial number

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_SerialNumber(self)

    def AccessStatus(self) -> "int":
        r"""
        Returns the access status.

        :rtype: int
        :return: Access status

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_AccessStatus(self)

    def TimestampTickFrequency(self) -> "int":
        r"""
        Returns the timestamp tick frequency.

        :rtype: int
        :return: Timestamp tick frequency in Hz

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_TimestampTickFrequency(self)

    def ParentInterface(self) -> "Interface":
        r"""
        Returns the parent interface.

        :rtype: :py:class:`Interface`
        :return: Parent interface

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_ParentInterface(self)

    def IsOpenable(self, *args) -> "bool":
        r"""
        Checks whether the device can be opened with a specific access type.

        If the device can be opened with a higher access type, it can also be opened with a lower access type.

        .. code- c++

            if (deviceDescriptor->IsOpenable())
            {
                device = deviceDescriptor->OpenDevice(Control);
            }

        :type accessType: int, in, optional
        :param accessType: The access type to check.

        :rtype: boolean
        :return: True, if the device can be opened with the given access type.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_IsOpenable(self, *args)

    def OpenDevice(self, accessType: "int") -> "Device":
        r"""
        Opens the Device.

        :type accessType: int, in
        :param accessType: The access type the device should be opened for.

        :rtype: :py:class:`Device`
        :return: Opened Device

        Since: 1.0

        :raises: NotFoundException Device could not be found.
        :raises: BadAccessException Access denied
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceDescriptor_OpenDevice(self, accessType)

    def OpenedDevice(self) -> "Device":
        r"""
        Returns the Device that was opened with this DeviceDescriptor.

        :rtype: :py:class:`Device`
        :return: Opened Device

        Since: 1.0

        :raises: BadAccessException Device is not open
        """
        return _ids_peak_python_interface.DeviceDescriptor_OpenedDevice(self)

    def RegisterDeviceOpenedCallback(self, callbackToRegister: "DeviceDescriptorDeviceOpenedCallbackBase") -> "::DeviceDescriptorDeviceOpenedCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.DeviceDescriptor_RegisterDeviceOpenedCallback(self, callbackToRegister)

    def UnregisterDeviceOpenedCallback(self, callbackToUnregister: "DeviceDescriptorDeviceOpenedCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.DeviceDescriptor_UnregisterDeviceOpenedCallback(self, callbackToUnregister)

    class DeviceOpenedCallback(DeviceDescriptorDeviceOpenedCallbackBase):
        def __init__(self, callback):
            DeviceDescriptorDeviceOpenedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "Device"):
            self._callback(arg0)
        _callback = None


# Register DeviceDescriptor in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceDescriptor_swigregister(DeviceDescriptor)
FirmwareUpdatePersistence_NoPersistence = _ids_peak_python_interface.FirmwareUpdatePersistence_NoPersistence
r"""All sets are reset to default values during the update."""
FirmwareUpdatePersistence_FullPersistence = _ids_peak_python_interface.FirmwareUpdatePersistence_FullPersistence
r"""The device guarantees, that all sets are persisted during the update."""
FirmwareUpdateVersionStyle_Dotted = _ids_peak_python_interface.FirmwareUpdateVersionStyle_Dotted
r"""
    The version consists of any number of parts separated by dots. If a part consists of decimal characters only,
    it is compared numerically, otherwise it is compared using strcmp(). This leads to the following ordering:
    1.1.a < 1.10.a < 1.10.b <1.10.b.a
    """
FirmwareUpdateVersionStyle_Semantic = _ids_peak_python_interface.FirmwareUpdateVersionStyle_Semantic
r"""The style as specified in 'Semantic Versioning 2.0.0' ( http://semver.org/ )."""
class FirmwareUpdateInformation(object):
    r"""
    Represents a single firmware update information.

    This class allows to query information from the *.guf file about a single firmware update information.

    See GenICam FWUpdate Standard.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdateInformation

    def IsValid(self) -> "bool":
        r"""
        Checks whether the information held are valid.

        :rtype: boolean
        :return: True, if the information held are valid.
        :rtype: boolean
        :return: False otherwise.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_IsValid(self)

    def FileName(self) -> "str":
        r"""
        Returns the file name of the package this firmware update information beints to.

        :rtype: str
        :return: File name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_FileName(self)

    def Description(self) -> "str":
        r"""
        Returns the description of the firmware update.

        :rtype: str
        :return: Description

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_Description(self)

    def Version(self) -> "str":
        r"""
        Returns the version of the firmware update.

        :rtype: str
        :return: Version

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_Version(self)

    def VersionExtractionPattern(self) -> "str":
        r"""
        Regular expression to extract the device version from the DeviceFirmwareVersion node.

        The first matched group is used as result. This is needed for devices which encode more information than just
        the firmware version inside the DeviceFirmwareVersion node. The default value is: ^(.*)$

        :rtype: str
        :return: Version extraction pattern

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_VersionExtractionPattern(self)

    def VersionStyle(self) -> "int":
        r"""
        The style of the Version() value.

        This is needed to actually interpret and sort the versions. Using this information an update software is
        able to inform the user if an update would actually be a downgrade or if it was already applied to the device.

        :rtype: int
        :return: Version style

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_VersionStyle(self)

    def ReleaseNotes(self) -> "str":
        r"""
        Release notes of the firmware update.

        :rtype: str
        :return: Release notes

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_ReleaseNotes(self)

    def ReleaseNotesURL(self) -> "str":
        r"""
        A link to a webpage with more release notes.

        This webpage can contain addition details not contained in ReleaseNotes().

        :rtype: str
        :return: URL where the release notes of the firmware update can be found

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_ReleaseNotesURL(self)

    def UserSetPersistence(self) -> "int":
        r"""
        Specifies if the device persists user sets during the update.

        :rtype: int
        :return: User set persistence

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_UserSetPersistence(self)

    def SequencerSetPersistence(self) -> "int":
        r"""
        Specifies if the device persists sequencer sets during the update.

        :rtype: int
        :return: Sequencer set persistence

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdateInformation_SequencerSetPersistence(self)

# Register FirmwareUpdateInformation in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdateInformation_swigregister(FirmwareUpdateInformation)
FirmwareUpdateStep_CheckPreconditions = _ids_peak_python_interface.FirmwareUpdateStep_CheckPreconditions
FirmwareUpdateStep_AcquireUpdateData = _ids_peak_python_interface.FirmwareUpdateStep_AcquireUpdateData
FirmwareUpdateStep_WriteFeature = _ids_peak_python_interface.FirmwareUpdateStep_WriteFeature
FirmwareUpdateStep_ExecuteFeature = _ids_peak_python_interface.FirmwareUpdateStep_ExecuteFeature
FirmwareUpdateStep_AssertFeature = _ids_peak_python_interface.FirmwareUpdateStep_AssertFeature
FirmwareUpdateStep_UploadFile = _ids_peak_python_interface.FirmwareUpdateStep_UploadFile
FirmwareUpdateStep_ResetDevice = _ids_peak_python_interface.FirmwareUpdateStep_ResetDevice
class FirmwareUpdateProgressObserver(object):
    r"""
    Allows to observe a firmware update process.

    Observe a firmware update process by registering several callbacks.
    These callbacks get called when the observer is passed to the UpdateDevice() function. The
    callbacks inform about changes of the status of the firmware update process.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _ids_peak_python_interface.FirmwareUpdateProgressObserver_swiginit(self, _ids_peak_python_interface.new_FirmwareUpdateProgressObserver())
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdateProgressObserver

    def RegisterUpdateStartedCallback(self, callbackToRegister: "FirmwareUpdateProgressObserverUpdateStartedCallbackBase") -> "::FirmwareUpdateProgressObserverUpdateStartedCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_RegisterUpdateStartedCallback(self, callbackToRegister)

    def UnregisterUpdateStartedCallback(self, callbackToUnregister: "FirmwareUpdateProgressObserverUpdateStartedCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_UnregisterUpdateStartedCallback(self, callbackToUnregister)

    class UpdateStartedCallback(FirmwareUpdateProgressObserverUpdateStartedCallbackBase):
        def __init__(self, callback):
            FirmwareUpdateProgressObserverUpdateStartedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "FirmwareUpdateInformation", arg1 : "int"):
            self._callback(arg0, arg1)
        _callback = None


    def RegisterUpdateStepStartedCallback(self, callbackToRegister: "FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase") -> "::FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_RegisterUpdateStepStartedCallback(self, callbackToRegister)

    def UnregisterUpdateStepStartedCallback(self, callbackToUnregister: "FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_UnregisterUpdateStepStartedCallback(self, callbackToUnregister)

    class UpdateStepStartedCallback(FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase):
        def __init__(self, callback):
            FirmwareUpdateProgressObserverUpdateStepStartedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "int", arg1 : "int", arg2 : "str"):
            self._callback(arg0, arg1, arg2)
        _callback = None


    def RegisterUpdateStepProgressChangedCallback(self, callbackToRegister: "FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase") -> "::FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_RegisterUpdateStepProgressChangedCallback(self, callbackToRegister)

    def UnregisterUpdateStepProgressChangedCallback(self, callbackToUnregister: "FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_UnregisterUpdateStepProgressChangedCallback(self, callbackToUnregister)

    class UpdateStepProgressChangedCallback(FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase):
        def __init__(self, callback):
            FirmwareUpdateProgressObserverUpdateStepProgressChangedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "int", arg1 : "float"):
            self._callback(arg0, arg1)
        _callback = None


    def RegisterUpdateStepFinishedCallback(self, callbackToRegister: "FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase") -> "::FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_RegisterUpdateStepFinishedCallback(self, callbackToRegister)

    def UnregisterUpdateStepFinishedCallback(self, callbackToUnregister: "FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_UnregisterUpdateStepFinishedCallback(self, callbackToUnregister)

    class UpdateStepFinishedCallback(FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase):
        def __init__(self, callback):
            FirmwareUpdateProgressObserverUpdateStepFinishedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "int"):
            self._callback(arg0)
        _callback = None


    def RegisterUpdateFinishedCallback(self, callback: "FirmwareUpdateProgressObserverUpdateFinishedCallbackBase") -> "Any":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_RegisterUpdateFinishedCallback(self, callback)

    def UnregisterUpdateFinishedCallback(self, callbackHandle: "Any") -> "None":
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_UnregisterUpdateFinishedCallback(self, callbackHandle)

    class UpdateFinishedCallback(FirmwareUpdateProgressObserverUpdateFinishedCallbackBase):
        def __init__(self, callback):
            FirmwareUpdateProgressObserverUpdateFinishedCallbackBase.__init__(self)
            self._callback = callback
        def call(self):
            self._callback()
        _callback = None


    def RegisterUpdateFailedCallback(self, callbackToRegister: "FirmwareUpdateProgressObserverUpdateFailedCallbackBase") -> "::FirmwareUpdateProgressObserverUpdateFailedCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_RegisterUpdateFailedCallback(self, callbackToRegister)

    def UnregisterUpdateFailedCallback(self, callbackToUnregister: "FirmwareUpdateProgressObserverUpdateFailedCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.FirmwareUpdateProgressObserver_UnregisterUpdateFailedCallback(self, callbackToUnregister)

    class UpdateFailedCallback(FirmwareUpdateProgressObserverUpdateFailedCallbackBase):
        def __init__(self, callback):
            FirmwareUpdateProgressObserverUpdateFailedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "str"):
            self._callback(arg0)
        _callback = None


# Register FirmwareUpdateProgressObserver in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdateProgressObserver_swigregister(FirmwareUpdateProgressObserver)
class FirmwareUpdater(object):
    r"""
    Allows to update the firmware of a device.

    To update the device firmware, call CollectFirmwareUpdateInformation() with a *.guf file and the device to update,
    select one of the firmware updates in the list, then pass it to UpdateDevice() to execute the update.

    To observe the update progress, pass a FirmwareUpdateProgressObserver to the UpdateDevice(). This is optional, but
    very helpful, since firmware updates can take several minutes.

    Notes: The DeviceDescriptor passed to CollectFirmwareUpdateInformation() and UpdateDevice() will be opened in
          Control mode. Therefore, if the Device is opened in any other application, both methods can fail with an
          InternalErrorException.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _ids_peak_python_interface.FirmwareUpdater_swiginit(self, _ids_peak_python_interface.new_FirmwareUpdater())
    __swig_destroy__ = _ids_peak_python_interface.delete_FirmwareUpdater

    def CollectFirmwareUpdateInformation(self, *args) -> "Sequence[FirmwareUpdateInformation]":
        r"""
        *Overload 1:*

        Collects all firmware update information of a given *.guf file.

        :type gufPath: str, in
        :param gufPath: The path of the *.guf file containing the firmware update.

        :rtype: Sequence[FirmwareUpdateInformation]
        :return: A list of firmware update information.

        Since: 1.2

        :raises: InvalidArgumentException One of the submitted arguments is outside the valid range or is not supported.
        :raises: NotFoundException The supplied ``gufPath`` was not found.
        :raises: IOException Failed to read the file from ``gufPath``.
        :raises: NoDataException The supplied ``gufPath`` does not seem to be a valid GUF file.
        :raises: BadAllocException Bad memory allocation.
        :raises: InternalErrorException An internal error has occurred.

        |

        *Overload 2:*

        Collects the firmware update information of a given *.guf file fitting to a given device.

        :type gufPath: str, in
        :param gufPath: The path of the *.guf file containing the firmware update.
        :type device: :py:class:`DeviceDescriptor`, in
        :param device: The device to update.

        :rtype: Sequence[FirmwareUpdateInformation]
        :return: A list of firmware update information fitting to the given device

        Notes: This function requires the given ``device`` to be openable.

        Since: 1.0

        :raises: InvalidArgumentException One of the submitted arguments is outside the valid range or is not supported.
        :raises: NotFoundException The supplied ``gufPath`` was not found.
        :raises: IOException A communication error has occurred, e.g. when the device is disconnected or reading the file failed.
        :raises: NoDataException The supplied ``gufPath`` does not seem to be a valid GUF file.
        :raises: BadAllocException Bad memory allocation.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdater_CollectFirmwareUpdateInformation(self, *args)

    def UpdateDevice(self, *args) -> "None":
        r"""
        Updates a given device by using a given firmware update information.

        This is a blocking call, i.e. it only returns once the update is done. Depending on the device, the update may
        take several minutes. To watch the progress during the update, pass a FirmwareUpdateProgressObserver.

        :type device: :py:class:`DeviceDescriptor`, in
        :param device: The device to update.
        :type updateInformation: :py:class:`FirmwareUpdateInformation`, in
        :param updateInformation: The firmware update information to update the device.
        :type progressObserver: :py:class:`FirmwareUpdateProgressObserver`, in, optional
        :param progressObserver: The progress observer to observe the update process. It is optional.
        :type deviceResetDiscoveryTimeout: :py:class:`Timeout`, in, optional
        :param deviceResetDiscoveryTimeout: Time to wait for a device to reboot during the update.

        Notes: The DeviceDescriptor passed to this function will be invalid after the update. Update the
              DeviceManager/Interface and retrieve a new DeviceDescriptor.

        Since: 1.0
        1.2 Added deviceResetDiscoveryTimeout parameter.

        :raises: InvalidArgumentException One of the submitted arguments is outside the valid range or is not supported.
        :raises: TimeoutException The deviceResetDiscoveryTimeout was exceeded.
        :raises: IOException A communication error has occurred, e.g. when the device gets unexpectedly disconnected
                                during the update process or reading the file failed.
        :raises: NotFoundException The previously supplied GUF file was removed.

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FirmwareUpdater_UpdateDevice(self, *args)

# Register FirmwareUpdater in _ids_peak_python_interface:
_ids_peak_python_interface.FirmwareUpdater_swigregister(FirmwareUpdater)
class FileAdapter(object):
    r"""
    The FileAdapter is a utility class designed for accessing files stored in a
           RemoteDevice's persistent memory.

    It provides convenient functions to 'Read', 'Write', and 'Delete' files.
    doc_file_adapter_test.cpp file_adapter_class

    Notes:
    The FileAdapter relies on certain nodes within the RemoteDevice.
    If these nodes are not present, the functions may not work properly.
    Check your device's manual to confirm the availability of these nodes.
    - FileSelector
    - FileOperationSelector
    - FileOperationExecute
    - FileSize
    - FileAccessBuffer
    - FileAccessLength
    - FileAccessOffset
    - ...

    The FileAdapter class encapsulates the functions of the FileProtocolAdapter.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nodeMap: "NodeMap", fileName: "str"):
        r"""
        Constructs a FileAdapter for a specific file name in the RemoteDevice's NodeMap.

        doc_file_adapter_test.cpp file_adapter_constructor

        File names may vary depending on the device.
        To obtain a list of valid file names, you can either iterate through the
        AvailableEntries AvailableEntries of the
        'FileSelector' EnumerationNode EnumerationNode
        or use the static AvailableFileNames function.
        Some files may be read-only.

        Common file names include:
        * UserData1
        * UserData2
        * CriticalEventLog

        :type nodeMap: :py:class:`NodeMap`
        :param nodeMap: The NodeMap of the RemoteDevice
        :type fileName: str
        :param fileName: A valid file name

        Since: 1.10

        :raises: InvalidArgumentException The nodeMap pointer is invalid.
        :raises: NotAvailableException The 'FileSelector' node or it's entry with the given file name is not available.
        :raises: InternalErrorException An internal error has occurred.
        """
        _ids_peak_python_interface.FileAdapter_swiginit(self, _ids_peak_python_interface.new_FileAdapter(nodeMap, fileName))
    __swig_destroy__ = _ids_peak_python_interface.delete_FileAdapter

    def Delete(self) -> "None":
        r"""
        Deletes the file the adapter references.

        Since: 1.10

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FileAdapter_Delete(self)

    def Size(self) -> "int":
        r"""
        Returns the content size of the file the adapter references.
        This is the maximum size that can be read.

        :rtype: int
        :return: The content size

        Since: 1.10

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FileAdapter_Size(self)

    def MaxSize(self) -> "int":
        r"""
        Returns the maximum size of the file the adapter references.
        This is the maximum size that can be written.

        :rtype: int
        :return: The maximum size

        Since: 1.10

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FileAdapter_MaxSize(self)

    @staticmethod
    def AvailableFileNames(nodeMap: "NodeMap") -> "Sequence[str]":
        r"""
        Returns a vector of available file names from the given NodeMap.
        File names may vary depending on the device.
        doc_file_adapter_test.cpp file_adapter_list

        :type nodeMap: :py:class:`NodeMap`
        :param nodeMap: The NodeMap of the RemoteDevice

        :rtype: Sequence[str]
        :return: Vector of available file names

        Since: 1.10

        :raises: InvalidArgumentException The NodeMap pointer is invalid.
        :raises: NotAvailableException The 'FileSelector' node is not available.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.FileAdapter_AvailableFileNames(nodeMap)

    def Read(self, numBytes: "int", offset: "int" = 0) -> "bytes":
        r"""
        Reads the contents of the file into the supplied buffer

        To read the entire file, use Size() as the size argument.
        Alternatively, you can specify an offset and a smaller size to read only a part of the file content.

        :type numBytes: int
        :param numBytes: The count of bytes to read.
        :type offset: int
        :param offset: Offset in the file to start reading the content. Defaults to 0.

        :rtype: bytes
        :return: The read bytes

        :raises OutOfRangeException: Data size + offset exceeds the file's MaxSize or offset cannot be set.
        :raises InternalErrorException: An internal error has occurred.
        """
        return _ids_peak_python_interface.FileAdapter_ReadBytes(self, numBytes, offset)



    def Write(self, writeBuffer: "bytes", offset: "int" = 0) -> "None":
        r"""
        Writes the data supplied in the buffer to the file the adapter references.

        Ensure that the data size does not exceed MaxSize().

        Note: If you don't want to write from the start of the file, add an offset in the function call.
              This might fail if the RemoteDevice's FileAccessOffset node cannot set the specified offset.

        :type writeBuffer: bytes
        :param writeBuffer: The bytes object to write to the file
        :type offset: int
        :param offset: Offset in the file to write the content to. Defaults to 0.

        :raises OutOfRangeException: Data size + offset exceeds the file's MaxSize or offset cannot be set.
        :raises InternalErrorException: An internal error has occurred.
        """

    # Try to convert the type to bytes if it is not already
        if not isinstance(writeBuffer, bytes):
            writeBuffer = bytes(writeBuffer)

        _ids_peak_python_interface.FileAdapter_WriteBytes(self, writeBuffer, offset)



# Register FileAdapter in _ids_peak_python_interface:
_ids_peak_python_interface.FileAdapter_swigregister(FileAdapter)
class Interface(EventSupportingModule):
    r"""
    Represents a GenTL Interface module.

    This class allows to query information about a GenTL Interface module and to enumerate its
    DeviceDescriptor DeviceDescriptors, which allow you to open the corresponding Device.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_Interface

    def Key(self) -> "str":

        return _ids_peak_python_interface.Interface_Key(self)

    def Info(self, infoCommand: "int") -> "RawInformation":

        return _ids_peak_python_interface.Interface_Info(self, infoCommand)

    def ID(self) -> "str":

        return _ids_peak_python_interface.Interface_ID(self)

    def DisplayName(self) -> "str":

        return _ids_peak_python_interface.Interface_DisplayName(self)

    def TLType(self) -> "str":

        return _ids_peak_python_interface.Interface_TLType(self)

    def UpdateDevices(self, timeout_ms: "Timeout") -> "None":
        r"""
        Searches for devices.

        This function triggers an update of the internal device list. The callbacks registered on the interface
        will be triggered if an device is found or lost.

        :type timeout_ms: :py:class:`Timeout`, in
        :param timeout_ms: The time to wait for new devices in milliseconds. In any case the
                                  GenTL Producer must make sure that this operation is completed in a
                                  reasonable amount of time depending on the underlying technology.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Interface_UpdateDevices(self, timeout_ms)

    def Devices(self) -> "Sequence[DeviceDescriptor]":
        r"""
        Returns the device list.

        :rtype: Sequence[DeviceDescriptor]
        :return: Device list

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.Interface_Devices(self)

    def ParentSystem(self) -> "System":

        return _ids_peak_python_interface.Interface_ParentSystem(self)

    def RegisterDeviceFoundCallback(self, callbackToRegister: "InterfaceDeviceFoundCallbackBase") -> "::InterfaceDeviceFoundCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.Interface_RegisterDeviceFoundCallback(self, callbackToRegister)

    def UnregisterDeviceFoundCallback(self, callbackToUnregister: "InterfaceDeviceFoundCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.Interface_UnregisterDeviceFoundCallback(self, callbackToUnregister)

    class DeviceFoundCallback(InterfaceDeviceFoundCallbackBase):
        def __init__(self, callback):
            InterfaceDeviceFoundCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "DeviceDescriptor"):
            self._callback(arg0)
        _callback = None


    def RegisterDeviceReconnectedCallback(self, callbackToRegister: "InterfaceDeviceReconnectedCallbackBase") -> "::InterfaceDeviceReconnectedCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.Interface_RegisterDeviceReconnectedCallback(self, callbackToRegister)

    def UnregisterDeviceReconnectedCallback(self, callbackToUnregister: "InterfaceDeviceReconnectedCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.Interface_UnregisterDeviceReconnectedCallback(self, callbackToUnregister)

    class DeviceReconnectedCallback(InterfaceDeviceReconnectedCallbackBase):
        def __init__(self, callback):
            InterfaceDeviceReconnectedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "DeviceDescriptor", arg1 : "DeviceReconnectInformation"):
            self._callback(arg0, arg1)
        _callback = None


    def RegisterDeviceDisconnectedCallback(self, callbackToRegister: "InterfaceDeviceDisconnectedCallbackBase") -> "::InterfaceDeviceDisconnectedCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.Interface_RegisterDeviceDisconnectedCallback(self, callbackToRegister)

    def UnregisterDeviceDisconnectedCallback(self, callbackToUnregister: "InterfaceDeviceDisconnectedCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.Interface_UnregisterDeviceDisconnectedCallback(self, callbackToUnregister)

    class DeviceDisconnectedCallback(InterfaceDeviceDisconnectedCallbackBase):
        def __init__(self, callback):
            InterfaceDeviceDisconnectedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "DeviceDescriptor"):
            self._callback(arg0)
        _callback = None


    def RegisterDeviceLostCallback(self, callbackToRegister: "InterfaceDeviceLostCallbackBase") -> "::InterfaceDeviceLostCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.Interface_RegisterDeviceLostCallback(self, callbackToRegister)

    def UnregisterDeviceLostCallback(self, callbackToUnregister: "InterfaceDeviceLostCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.Interface_UnregisterDeviceLostCallback(self, callbackToUnregister)

    class DeviceLostCallback(InterfaceDeviceLostCallbackBase):
        def __init__(self, callback):
            InterfaceDeviceLostCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "str"):
            self._callback(arg0)
        _callback = None


    def RegisterDeviceListChangedCallback(self, callback: "InterfaceDeviceListChangedCallbackBase") -> "Any":
        return _ids_peak_python_interface.Interface_RegisterDeviceListChangedCallback(self, callback)

    def UnregisterDeviceListChangedCallback(self, callbackHandle: "Any") -> "None":
        return _ids_peak_python_interface.Interface_UnregisterDeviceListChangedCallback(self, callbackHandle)

    class DeviceListChangedCallback(InterfaceDeviceListChangedCallbackBase):
        def __init__(self, callback):
            InterfaceDeviceListChangedCallbackBase.__init__(self)
            self._callback = callback
        def call(self):
            self._callback()
        _callback = None


# Register Interface in _ids_peak_python_interface:
_ids_peak_python_interface.Interface_swigregister(Interface)
class InterfaceDescriptor(ModuleDescriptor):
    r"""
    Encapsulates the GenTL functions associated with a GenTL Interface module's ID.

    This class allows to query information about a GenTL Interface module without opening it. Furthermore, it allows
    to open the corresponding Interface module.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_InterfaceDescriptor

    def Key(self) -> "str":

        return _ids_peak_python_interface.InterfaceDescriptor_Key(self)

    def Info(self, infoCommand: "int") -> "RawInformation":

        return _ids_peak_python_interface.InterfaceDescriptor_Info(self, infoCommand)

    def DisplayName(self) -> "str":
        r"""
        Returns the display name.

        :rtype: str
        :return: Display name

        Since: 1.0

        :raises: NotFoundException Interface could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.InterfaceDescriptor_DisplayName(self)

    def TLType(self) -> "str":

        return _ids_peak_python_interface.InterfaceDescriptor_TLType(self)

    def ParentSystem(self) -> "System":
        r"""
        Returns the parent system.

        :rtype: :py:class:`System`
        :return: Parent system

        Since: 1.0

        :raises: NotFoundException Interface could not be found.
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.InterfaceDescriptor_ParentSystem(self)

    def OpenInterface(self) -> "Interface":
        r"""
        Opens the interface.

        :rtype: :py:class:`Interface`
        :return: Opened interface

        Since: 1.0

        :raises: BadAccessException Access denied
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.InterfaceDescriptor_OpenInterface(self)

    def OpenedInterface(self) -> "Interface":
        r"""
        Returns the Interface that was opened with this InterfaceDescriptor.

        :rtype: :py:class:`Interface`
        :return: Opened Interface

        Since: 1.0

        :raises: BadAccessException Interface is not open
        """
        return _ids_peak_python_interface.InterfaceDescriptor_OpenedInterface(self)

# Register InterfaceDescriptor in _ids_peak_python_interface:
_ids_peak_python_interface.InterfaceDescriptor_swigregister(InterfaceDescriptor)
CharacterEncoding_ASCII = _ids_peak_python_interface.CharacterEncoding_ASCII
CharacterEncoding_UTF8 = _ids_peak_python_interface.CharacterEncoding_UTF8
class System(EventSupportingModule):
    r"""
    Represents a GenTL System module.

    This class allows to query information about the GenTL System module and to enumerate its
    InterfaceDescriptor InterfaceDescriptors, which allow to open the corresponding Interface.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_System

    def Key(self) -> "str":

        return _ids_peak_python_interface.System_Key(self)

    def Info(self, infoCommand: "int") -> "RawInformation":

        return _ids_peak_python_interface.System_Info(self, infoCommand)

    def ID(self) -> "str":
        r"""
        Returns the ID.

        :rtype: str
        :return: ID

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.System_ID(self)

    def DisplayName(self) -> "str":

        return _ids_peak_python_interface.System_DisplayName(self)

    def VendorName(self) -> "str":

        return _ids_peak_python_interface.System_VendorName(self)

    def ModelName(self) -> "str":

        return _ids_peak_python_interface.System_ModelName(self)

    def Version(self) -> "str":

        return _ids_peak_python_interface.System_Version(self)

    def TLType(self) -> "str":

        return _ids_peak_python_interface.System_TLType(self)

    def CTIFileName(self) -> "str":

        return _ids_peak_python_interface.System_CTIFileName(self)

    def CTIFullPath(self) -> "str":

        return _ids_peak_python_interface.System_CTIFullPath(self)

    def GenTLVersionMajor(self) -> "int":

        return _ids_peak_python_interface.System_GenTLVersionMajor(self)

    def GenTLVersionMinor(self) -> "int":

        return _ids_peak_python_interface.System_GenTLVersionMinor(self)

    def CharacterEncoding(self) -> "int":

        return _ids_peak_python_interface.System_CharacterEncoding(self)

    def UpdateInterfaces(self, timeout_ms: "Timeout") -> "None":
        r"""
        Searches for interfaces.

        This function triggers an update of the internal interface list. The callbacks registered on the system
        will be triggered if an interface is found or lost.

        :type timeout_ms: :py:class:`Timeout`, in
        :param timeout_ms: The time to wait for new interfaces in milliseconds. In any case the
                                  GenTL Producer must make sure that this operation is completed in a
                                  reasonable amount of time depending on the underlying technology.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.System_UpdateInterfaces(self, timeout_ms)

    def Interfaces(self) -> "Sequence[InterfaceDescriptor]":
        r"""
        Returns the interface list.

        :rtype: Sequence[InterfaceDescriptor]
        :return: Interface list

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.System_Interfaces(self)

    def ParentLibrary(self) -> "ProducerLibrary":

        return _ids_peak_python_interface.System_ParentLibrary(self)

    def RegisterInterfaceLostCallback(self, callback: "Any") -> "Any":
        r"""
        Registers a callback for signaling a lost interface.

        This function registers a callback which gets called every time a interface is lost. Pass the callback
        handle returned by this function to UnregisterInterfaceLostCallback() to unregister the callback.

        :type callback: InterfaceLostCallback, in
        :param callback: The callback to call if a interface is lost.

        :rtype: function< void (str) >
        :return: Callback handle

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.System_RegisterInterfaceLostCallback(self, callback)

    def UnregisterInterfaceLostCallback(self, callbackHandle: "Any") -> "None":
        r"""
        Unregisters a interface lost callback.

        This function unregisters a interface lost callback by taking its handle.

        :type callbackHandle: function< void (str) >, in
        :param callbackHandle: The handle of the callback to unregister.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.System_UnregisterInterfaceLostCallback(self, callbackHandle)

    def RegisterInterfaceFoundCallback(self, callbackToRegister: "SystemInterfaceFoundCallbackBase") -> "::SystemInterfaceFoundCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.System_RegisterInterfaceFoundCallback(self, callbackToRegister)

    def UnregisterInterfaceFoundCallback(self, callbackToUnregister: "SystemInterfaceFoundCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.System_UnregisterInterfaceFoundCallback(self, callbackToUnregister)

    class InterfaceFoundCallback(SystemInterfaceFoundCallbackBase):
        def __init__(self, callback):
            SystemInterfaceFoundCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "InterfaceDescriptor"):
            self._callback(arg0)
        _callback = None


# Register System in _ids_peak_python_interface:
_ids_peak_python_interface.System_swigregister(System)
class SystemDescriptor(ModuleDescriptor):
    r"""
    Encapsulates the GenTL functions associated with the GenTL System module's ID.

    This class allows to query information about the GenTL System module without opening it. Furthermore, it enables
    you to open the GenTL System module.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_SystemDescriptor

    def Key(self) -> "str":

        return _ids_peak_python_interface.SystemDescriptor_Key(self)

    def Info(self, infoCommand: "int") -> "RawInformation":
        r"""
        Delivers information based on the given GenTL info command.

        :type infoCommand: int, in
        :param infoCommand: The GenTL info command.

        This function can be used to query information going beyond the predefined info functions, based on the GenTL
        info commands of the corresponding module.

        Example (error handling is omitted):

        .. code- c++

            #include <peak/thirdparty/GenTL.h>
            auto info = object->Info(XX_INFO_XX);

            // Cast depending on the delivered data type
            if (info.dataType == INFO_DATATYPE_UINT64)
            {
                int uint64Var = *reinterpret_cast<int*>(info.data.data());
                // Do something with the information
            }
            else if (infoDataTypeVar == INFO_DATATYPE_INT64)
            {
                ...
            }
            ...

        :rtype: :py:class:`RawInformation`
        :return: Raw information according to the passed info command

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_Info(self, infoCommand)

    def DisplayName(self) -> "str":
        r"""
        Returns the display name.

        :rtype: str
        :return: Display name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_DisplayName(self)

    def VendorName(self) -> "str":
        r"""
        Returns the vendor name.

        :rtype: str
        :return: Vendor name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_VendorName(self)

    def ModelName(self) -> "str":
        r"""
        Returns the model name.

        :rtype: str
        :return: Model name

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_ModelName(self)

    def Version(self) -> "str":
        r"""
        Returns the version.

        :rtype: str
        :return: Version

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_Version(self)

    def TLType(self) -> "str":
        r"""
        Returns the TL (transport layer) type.

        :rtype: str
        :return: TL type

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_TLType(self)

    def CTIFileName(self) -> "str":
        r"""
        Returns the file name of the GenTL producer library this system beints to.

        :rtype: str
        :return: File name of the GenTL producer library

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_CTIFileName(self)

    def CTIFullPath(self) -> "str":
        r"""
        Returns the full path of the GenTL producer library this system beints to.

        :rtype: str
        :return: Full path of the GenTL producer library

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_CTIFullPath(self)

    def GenTLVersionMajor(self) -> "int":
        r"""
        Returns the GenTL major version of the GenTL producer library this system beints to.

        :rtype: int
        :return: GenTL major version of the GenTL producer library

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_GenTLVersionMajor(self)

    def GenTLVersionMinor(self) -> "int":
        r"""
        Returns the GenTL minor version of the GenTL producer library this system beints to.

        :rtype: int
        :return: GenTL minor version of the GenTL producer library

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_GenTLVersionMinor(self)

    def CharacterEncoding(self) -> "int":
        r"""
        Returns the character encoding of the GenTL producer library this system beints to.

        :rtype: int
        :return: Character encoding of the GenTL producer library

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_CharacterEncoding(self)

    def ParentLibrary(self) -> "ProducerLibrary":
        r"""
        Returns the parent library.

        :rtype: :py:class:`ProducerLibrary`
        :return: Parent library

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_ParentLibrary(self)

    def OpenSystem(self) -> "System":
        r"""
        Opens the system.

        :rtype: :py:class:`System`
        :return: Opened system

        Since: 1.0

        :raises: BadAccessException Access denied
        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.SystemDescriptor_OpenSystem(self)

    def OpenedSystem(self) -> "System":
        r"""
        Returns the System that was opened with this SystemDescriptor.

        :rtype: :py:class:`System`
        :return: Opened System

        Since: 1.0

        :raises: BadAccessException System is not open
        """
        return _ids_peak_python_interface.SystemDescriptor_OpenedSystem(self)

    def IsOpened(self) -> "bool":
        r"""
        Returns if the system is currently opened or not

        :rtype: boolean
        :return: true if open, false if not

        Since: 1.7
        """
        return _ids_peak_python_interface.SystemDescriptor_IsOpened(self)

# Register SystemDescriptor in _ids_peak_python_interface:
_ids_peak_python_interface.SystemDescriptor_swigregister(SystemDescriptor)
class ProducerLibrary(object):
    r"""
    Represents a GenTL producer library (CTI).

    This class allows to load and initialize a GenTL producer library (CTI) and access its functionality. Each
    ProducerLibrary contains exactly one SystemDescriptor, which allows you to open the corresponding System.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_ProducerLibrary

    @staticmethod
    def Open(ctiPath: "str") -> "ProducerLibrary":
        r"""
        Opens the given producer library (CTI).

        :type ctiPath: str, in
        :param ctiPath: The path of the producer library (CTI) to open.

        :rtype: :py:class:`ProducerLibrary`
        :return: Producer library

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        :raises: CTILoadingException Loading the cti failed.
        """
        return _ids_peak_python_interface.ProducerLibrary_Open(ctiPath)

    def Key(self) -> "str":
        r"""
        Returns the unique key.

        The returned key is unique even across different producer libraries.

        :rtype: str
        :return: Unique key

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.ProducerLibrary_Key(self)

    def System(self) -> "SystemDescriptor":
        r"""
        Returns the system descriptor.

        The returned system descriptor can be used to query information about the GenTL system module
        without opening it and to open the GenTL system module.

        :rtype: :py:class:`SystemDescriptor`
        :return: System descriptor

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.ProducerLibrary_System(self)

# Register ProducerLibrary in _ids_peak_python_interface:
_ids_peak_python_interface.ProducerLibrary_swigregister(ProducerLibrary)
class DeviceReconnectInformation(object):
    r"""Reconnect information signaling the state of the Device after it has been reconnected."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_python_interface.delete_DeviceReconnectInformation

    def __init__(self, *args):
        _ids_peak_python_interface.DeviceReconnectInformation_swiginit(self, _ids_peak_python_interface.new_DeviceReconnectInformation(*args))

    def IsSuccessful(self) -> "bool":
        r"""Returns true if no error occured during the reconnect"""
        return _ids_peak_python_interface.DeviceReconnectInformation_IsSuccessful(self)

    def IsRemoteDeviceAcquisitionRunning(self) -> "bool":
        r"""
        Returns true if the remote device acquisition is running
        when the device got reconnected.
        """
        return _ids_peak_python_interface.DeviceReconnectInformation_IsRemoteDeviceAcquisitionRunning(self)

    def IsRemoteDeviceConfigurationRestored(self) -> "bool":
        r"""
        Returns true if the configuration of the remote device has been
        restored.
        """
        return _ids_peak_python_interface.DeviceReconnectInformation_IsRemoteDeviceConfigurationRestored(self)

    def GetErrorFlags(self) -> "int":
        r"""
         Returns error flags indicating the failed reconnect operation and the corresponding error.

        If an error occurs during a reconnect this flag field indicates the failed reconnect operation as well as a more
        detailed error flag. Based on the error the users application can complete the missing reconnect operations,
        e.g. reallocating the buffers if the
        'PEAK_DEVICE_RECONNECT_OPERATION_REMOTE_DEVICE_ACQUISITION_RESTART_PAYLOAD_SIZE_LARGER_THAN_BUFFERS' flag is set.
        """
        return _ids_peak_python_interface.DeviceReconnectInformation_GetErrorFlags(self)

# Register DeviceReconnectInformation in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceReconnectInformation_swigregister(DeviceReconnectInformation)
class EnvironmentInspector(object):
    r"""Allows to inspect the environment the application is running in."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def CollectCTIPaths() -> "Sequence[str]":
        r"""
        Collects producer library paths found in the current environment.

        Select a *.cti file from this list of paths and use it with Open().

        Notes: This function depends on the architecture your application is compiled for. This means you are getting
              the paths for the 32-bit producer libraries if your application is compiled for a 32-bit system and the
              paths for the 64-bit producer libraries if your application is compiled for a 64-bit system.

        :rtype: Sequence[str]
        :return: Producer library paths found in the current environment

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        :raises: NotFoundException The environment variable GENICAM_GENTL32_PATH / GENICAM_GENTL64_PATH was not
                                      found or was empty when scanning for environment ProducerLibraries.
        """
        return _ids_peak_python_interface.EnvironmentInspector_CollectCTIPaths()

# Register EnvironmentInspector in _ids_peak_python_interface:
_ids_peak_python_interface.EnvironmentInspector_swigregister(EnvironmentInspector)
class DeviceManager(object):
    r"""
    The global DeviceManager (singleton) searches all installed producer libraries (*.cti) and enumerates the
    modules contained in them.

    Retrieve the global DeviceManager with Instance().

    When Update() is called, it searches for all producer libraries contained in the directories found in the official
    GenICam GenTL environment variable GENICAM_GENTL{32/64}_PATH. It then openes all found
    ProducerLibrary ProducerLibraries, their System Systems, their
    Interface Interfaces, and lists all available DeviceDescriptor DeviceDescriptors.

    .. code- c++

        auto& deviceManager = Instance();
        deviceManager.Update();
        deviceDescriptors = deviceManager.Devices();

    Notes: The found producer libraries depend on the architecture your application is compiled for. This means you are
          getting 32-bit producer libraries if your application is compiled for a 32-bit system and 64-bit producer
          libraries if your application is compiled for a 64-bit system.

    The DeviceManager is a singleton. Therefore, after it was used, it stays active until program termination. That
    means the opened ProducerLibrary ProducerLibraries, System Systems, and
    Interface Interfaces  stay open. To close them before and start from scratch during runtime, call
    Reset().
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    UpdatePolicy_ScanEnvironmentForProducerLibraries = _ids_peak_python_interface.DeviceManager_UpdatePolicy_ScanEnvironmentForProducerLibraries
    r"""Scan env variable and add newly found producer libraries on #Update() call"""
    UpdatePolicy_DontScanEnvironmentForProducerLibraries = _ids_peak_python_interface.DeviceManager_UpdatePolicy_DontScanEnvironmentForProducerLibraries
    r"""Don't scan env variable and add newly found producer libraries on #Update() call"""
    ResetPolicy_ErrorOnOpenDevices = _ids_peak_python_interface.DeviceManager_ResetPolicy_ErrorOnOpenDevices
    r"""Check and throw an exception if an opened device is found"""
    ResetPolicy_IgnoreOpenDevices = _ids_peak_python_interface.DeviceManager_ResetPolicy_IgnoreOpenDevices
    r"""Ignore opened device and close them"""

    @staticmethod
    def Instance() -> "DeviceManager":
        r"""
        Returns the global DeviceManager.

        Since: 1.0
        """
        return _ids_peak_python_interface.DeviceManager_Instance()

    def AddProducerLibrary(self, *args) -> "None":
        r"""
        *Overload 1:*

        Adds the given producer library (CTI).

        This function can be used to add producer libraries manually. This is useful when the desired producer
        library is not registered at the GenTL environment variable.

        :type ctiPath: str, in
        :param ctiPath: The path to the producer library (CTI) to add

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.

        Notes: Changes only take effect when they are applied before calling Update().
              Changes applied during a running update only take effect with the next call to Update().

        |

        *Overload 2:*

        Adds the given producer library (CTI).

        This function can be used to add already opened producer libraries manually. This is useful when the desired
        producer library is not registered at the GenTL environment variable. If the producer library is already present,
        this call does nothing.

        :type library: :py:class:`ProducerLibrary`, in
        :param library: The library instance

        Since: 1.7

        :raises: BadAccessException Access denied
        :raises: InternalErrorException An internal error has occurred.

        Notes: Changes only take effect when they are applied before calling Update().
              Calling the function while an update is running will block the call.
        If the system of the producer library is not open, it will be opened immediately.
        Will trigger the SystemFound callback if the system is added to the internal list.
        """
        return _ids_peak_python_interface.DeviceManager_AddProducerLibrary(self, *args)

    def Reset(self, *args) -> "None":
        r"""
        Resets the DeviceManager.

        All Interface Interfaces  and System Systems  are closed, additional
        ProducerLibraries (added via AddProducerLibrary()) are cleared. Any registered callbacks stay active and the
        DeviceLostCallback and InterfaceLostCallback are called for all devices / interfaces.

        Notes: Can't reset the DeviceManager while there are open Device Devices. Close all devices before
              calling this method. Otherwise, a InternalErrorException is thrown.

        :type resetPolicy: int, in, optional
        :param resetPolicy: With the default ErrorOnOpenDevices, an exception is thrown if there are
                       any open devices managed by the DeviceManager. With IgnoreOpenDevices, no such exception
                       is thrown.

        Since: 1.0

        :raises: InternalErrorException If there are open devices (with ErrorOnOpenDevices).
        """
        return _ids_peak_python_interface.DeviceManager_Reset(self, *args)

    def InterfaceUpdateTimeout(self) -> "Timeout":
        r"""
        Returns the interface update timeout.

        :rtype: :py:class:`Timeout`
        :return: Interface update timeout in milliseconds

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceManager_InterfaceUpdateTimeout(self)

    def SetInterfaceUpdateTimeout(self, timeout_ms: "Timeout") -> "None":
        r"""
        Sets the interface update timeout.

        :type timeout_ms: :py:class:`Timeout`, in
        :param timeout_ms: The time to wait for new interfaces in milliseconds.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.

        Notes: Changes only take effect when they are
              applied before calling Update(). Changes applied during a running update only take effect with the next
              call to Update().
        """
        return _ids_peak_python_interface.DeviceManager_SetInterfaceUpdateTimeout(self, timeout_ms)

    def DeviceUpdateTimeout(self) -> "Timeout":
        r"""
        Returns the device update timeout.

        :rtype: :py:class:`Timeout`
        :return: Device update timeout in milliseconds

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceManager_DeviceUpdateTimeout(self)

    def SetDeviceUpdateTimeout(self, timeout_ms: "Timeout") -> "None":
        r"""
        Sets the device update timeout.

        :type timeout_ms: :py:class:`Timeout`, in
        :param timeout_ms: The time to wait for new devices in milliseconds.

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.

        Notes: Changes only take effect when they are
              applied before calling Update(). Changes applied during a running update only take effect with the next
              call to Update().
        """
        return _ids_peak_python_interface.DeviceManager_SetDeviceUpdateTimeout(self, timeout_ms)

    def Systems(self) -> "Sequence[System]":
        r"""
        Returns the found and opened systems.

        :rtype: Sequence[System]
        :return: Found and opened systems

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceManager_Systems(self)

    def Interfaces(self) -> "Sequence[Interface]":
        r"""
        Returns the found and opened interfaces.

        :rtype: Sequence[Interface]
        :return: Found and opened interfaces

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceManager_Interfaces(self)

    def Devices(self) -> "Sequence[DeviceDescriptor]":
        r"""
        Returns the found devices.

        :rtype: Sequence[DeviceDescriptor]
        :return: Found devices

        Since: 1.0

        :raises: InternalErrorException An internal error has occurred.
        """
        return _ids_peak_python_interface.DeviceManager_Devices(self)

    def RegisterSystemFoundCallback(self, callbackToRegister: "DeviceManagerSystemFoundCallbackBase") -> "::DeviceManagerSystemFoundCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.DeviceManager_RegisterSystemFoundCallback(self, callbackToRegister)

    def UnregisterSystemFoundCallback(self, callbackToUnregister: "DeviceManagerSystemFoundCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.DeviceManager_UnregisterSystemFoundCallback(self, callbackToUnregister)

    class SystemFoundCallback(DeviceManagerSystemFoundCallbackBase):
        def __init__(self, callback):
            DeviceManagerSystemFoundCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "System"):
            self._callback(arg0)
        _callback = None


    def RegisterInterfaceFoundCallback(self, callbackToRegister: "DeviceManagerInterfaceFoundCallbackBase") -> "::DeviceManagerInterfaceFoundCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.DeviceManager_RegisterInterfaceFoundCallback(self, callbackToRegister)

    def UnregisterInterfaceFoundCallback(self, callbackToUnregister: "DeviceManagerInterfaceFoundCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.DeviceManager_UnregisterInterfaceFoundCallback(self, callbackToUnregister)

    class InterfaceFoundCallback(DeviceManagerInterfaceFoundCallbackBase):
        def __init__(self, callback):
            DeviceManagerInterfaceFoundCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "Interface"):
            self._callback(arg0)
        _callback = None


    def RegisterInterfaceLostCallback(self, callbackToRegister: "DeviceManagerInterfaceLostCallbackBase") -> "::DeviceManagerInterfaceLostCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.DeviceManager_RegisterInterfaceLostCallback(self, callbackToRegister)

    def UnregisterInterfaceLostCallback(self, callbackToUnregister: "DeviceManagerInterfaceLostCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.DeviceManager_UnregisterInterfaceLostCallback(self, callbackToUnregister)

    class InterfaceLostCallback(DeviceManagerInterfaceLostCallbackBase):
        def __init__(self, callback):
            DeviceManagerInterfaceLostCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "str"):
            self._callback(arg0)
        _callback = None


    def RegisterDeviceFoundCallback(self, callbackToRegister: "DeviceManagerDeviceFoundCallbackBase") -> "::DeviceManagerDeviceFoundCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.DeviceManager_RegisterDeviceFoundCallback(self, callbackToRegister)

    def UnregisterDeviceFoundCallback(self, callbackToUnregister: "DeviceManagerDeviceFoundCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.DeviceManager_UnregisterDeviceFoundCallback(self, callbackToUnregister)

    class DeviceFoundCallback(DeviceManagerDeviceFoundCallbackBase):
        def __init__(self, callback):
            DeviceManagerDeviceFoundCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "DeviceDescriptor"):
            self._callback(arg0)
        _callback = None


    def RegisterDeviceReconnectedCallback(self, callbackToRegister: "DeviceManagerDeviceReconnectedCallbackBase") -> "::DeviceManagerDeviceReconnectedCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.DeviceManager_RegisterDeviceReconnectedCallback(self, callbackToRegister)

    def UnregisterDeviceReconnectedCallback(self, callbackToUnregister: "DeviceManagerDeviceReconnectedCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.DeviceManager_UnregisterDeviceReconnectedCallback(self, callbackToUnregister)

    class DeviceReconnectedCallback(DeviceManagerDeviceReconnectedCallbackBase):
        def __init__(self, callback):
            DeviceManagerDeviceReconnectedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "DeviceDescriptor", arg1 : "DeviceReconnectInformation"):
            self._callback(arg0, arg1)
        _callback = None


    def RegisterDeviceDisconnectedCallback(self, callbackToRegister: "DeviceManagerDeviceDisconnectedCallbackBase") -> "::DeviceManagerDeviceDisconnectedCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.DeviceManager_RegisterDeviceDisconnectedCallback(self, callbackToRegister)

    def UnregisterDeviceDisconnectedCallback(self, callbackToUnregister: "DeviceManagerDeviceDisconnectedCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.DeviceManager_UnregisterDeviceDisconnectedCallback(self, callbackToUnregister)

    class DeviceDisconnectedCallback(DeviceManagerDeviceDisconnectedCallbackBase):
        def __init__(self, callback):
            DeviceManagerDeviceDisconnectedCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "DeviceDescriptor"):
            self._callback(arg0)
        _callback = None


    def RegisterDeviceLostCallback(self, callbackToRegister: "DeviceManagerDeviceLostCallbackBase") -> "::DeviceManagerDeviceLostCallbackBase *":
        r"""Register the callback in the backend"""
        return _ids_peak_python_interface.DeviceManager_RegisterDeviceLostCallback(self, callbackToRegister)

    def UnregisterDeviceLostCallback(self, callbackToUnregister: "DeviceManagerDeviceLostCallbackBase") -> "None":
        r"""Unregister the callback in the backend"""
        return _ids_peak_python_interface.DeviceManager_UnregisterDeviceLostCallback(self, callbackToUnregister)

    class DeviceLostCallback(DeviceManagerDeviceLostCallbackBase):
        def __init__(self, callback):
            DeviceManagerDeviceLostCallbackBase.__init__(self)
            self._callback = callback
        def call(self, arg0 : "str"):
            self._callback(arg0)
        _callback = None


    def RegisterDeviceListChangedCallback(self, callback: "DeviceManagerDeviceListChangedCallbackBase") -> "Any":
        return _ids_peak_python_interface.DeviceManager_RegisterDeviceListChangedCallback(self, callback)

    def UnregisterDeviceListChangedCallback(self, callbackHandle: "Any") -> "None":
        return _ids_peak_python_interface.DeviceManager_UnregisterDeviceListChangedCallback(self, callbackHandle)

    class DeviceListChangedCallback(DeviceManagerDeviceListChangedCallbackBase):
        def __init__(self, callback):
            DeviceManagerDeviceListChangedCallbackBase.__init__(self)
            self._callback = callback
        def call(self):
            self._callback()
        _callback = None


    class UpdateErrorCallback(DeviceManagerUpdateErrorCallbackBase):
        def __init__(self, callback):
            DeviceManagerUpdateErrorCallbackBase.__init__(self)
            self._callback = callback

        def call(self, arg0 : "str"):
            self._callback(arg0)

        _callback = None


    def Update(self, *args) -> "None":
        r"""
        Starts an update.

        If there is already an update in progress, it waits for the previous update to finish before starting the new
        update.

        :type updatePolicy: int, in, optional
        :param updatePolicy: The update policy to use.
        :type errorCallback: :py:class:`DeviceManagerUpdateErrorCallbackBase`, in, optional
        :param errorCallback: A thread-safe callback getting called for each error occurring during the update.

        Since: 1.0

        :raises: NotInitializedException The library was not initialized before use.
        :raises: InternalErrorException An internal error has occurred.
        :raises: NotFoundException The environment variable GENICAM_GENTL32_PATH / GENICAM_GENTL64_PATH was not
                                            found or was empty when scanning for environment ProducerLibraries.
        :raises: CTILoadingException A error has occurred when loading a CTI from the environment variable
                                              GENICAM_GENTL32_PATH / GENICAM_GENTL64_PATH.
        """
        return _ids_peak_python_interface.DeviceManager_Update(self, *args)

# Register DeviceManager in _ids_peak_python_interface:
_ids_peak_python_interface.DeviceManager_swigregister(DeviceManager)
class VectorString(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_python_interface.VectorString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorString___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorString___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_python_interface.VectorString___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[str]":
        return _ids_peak_python_interface.VectorString___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorString___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_python_interface.VectorString___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorString___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorString___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorString___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_python_interface.VectorString_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorString_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorString_empty(self)

    def size(self) -> "Any":
        return _ids_peak_python_interface.VectorString_size(self)

    def swap(self, v: "VectorString") -> "None":
        return _ids_peak_python_interface.VectorString_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_python_interface.VectorString_begin(self)

    def end(self) -> "Any":
        return _ids_peak_python_interface.VectorString_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_python_interface.VectorString_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_python_interface.VectorString_rend(self)

    def clear(self) -> "None":
        return _ids_peak_python_interface.VectorString_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_python_interface.VectorString_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_python_interface.VectorString_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorString_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorString_swiginit(self, _ids_peak_python_interface.new_VectorString(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorString_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_python_interface.VectorString_front(self)

    def back(self) -> "Any":
        return _ids_peak_python_interface.VectorString_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_python_interface.VectorString_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_python_interface.VectorString_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_python_interface.VectorString_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_python_interface.VectorString_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_python_interface.VectorString_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorString

# Register VectorString in _ids_peak_python_interface:
_ids_peak_python_interface.VectorString_swigregister(VectorString)
class VectorDouble(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_python_interface.VectorDouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorDouble___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorDouble___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_python_interface.VectorDouble___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[double]":
        return _ids_peak_python_interface.VectorDouble___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorDouble___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_python_interface.VectorDouble___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorDouble___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorDouble___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorDouble___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_python_interface.VectorDouble_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorDouble_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorDouble_empty(self)

    def size(self) -> "Any":
        return _ids_peak_python_interface.VectorDouble_size(self)

    def swap(self, v: "VectorDouble") -> "None":
        return _ids_peak_python_interface.VectorDouble_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_python_interface.VectorDouble_begin(self)

    def end(self) -> "Any":
        return _ids_peak_python_interface.VectorDouble_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_python_interface.VectorDouble_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_python_interface.VectorDouble_rend(self)

    def clear(self) -> "None":
        return _ids_peak_python_interface.VectorDouble_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_python_interface.VectorDouble_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_python_interface.VectorDouble_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorDouble_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorDouble_swiginit(self, _ids_peak_python_interface.new_VectorDouble(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorDouble_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_python_interface.VectorDouble_front(self)

    def back(self) -> "Any":
        return _ids_peak_python_interface.VectorDouble_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_python_interface.VectorDouble_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_python_interface.VectorDouble_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_python_interface.VectorDouble_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_python_interface.VectorDouble_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_python_interface.VectorDouble_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorDouble

# Register VectorDouble in _ids_peak_python_interface:
_ids_peak_python_interface.VectorDouble_swigregister(VectorDouble)
class VectorInt64(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_python_interface.VectorInt64_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorInt64___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorInt64___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_python_interface.VectorInt64___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[int]":
        return _ids_peak_python_interface.VectorInt64___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorInt64___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_python_interface.VectorInt64___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorInt64___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorInt64___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorInt64___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_python_interface.VectorInt64_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorInt64_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorInt64_empty(self)

    def size(self) -> "Any":
        return _ids_peak_python_interface.VectorInt64_size(self)

    def swap(self, v: "VectorInt64") -> "None":
        return _ids_peak_python_interface.VectorInt64_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_python_interface.VectorInt64_begin(self)

    def end(self) -> "Any":
        return _ids_peak_python_interface.VectorInt64_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_python_interface.VectorInt64_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_python_interface.VectorInt64_rend(self)

    def clear(self) -> "None":
        return _ids_peak_python_interface.VectorInt64_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_python_interface.VectorInt64_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_python_interface.VectorInt64_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorInt64_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorInt64_swiginit(self, _ids_peak_python_interface.new_VectorInt64(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorInt64_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_python_interface.VectorInt64_front(self)

    def back(self) -> "Any":
        return _ids_peak_python_interface.VectorInt64_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_python_interface.VectorInt64_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_python_interface.VectorInt64_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_python_interface.VectorInt64_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_python_interface.VectorInt64_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_python_interface.VectorInt64_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorInt64

# Register VectorInt64 in _ids_peak_python_interface:
_ids_peak_python_interface.VectorInt64_swigregister(VectorInt64)
class VectorUInt8(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_python_interface.VectorUInt8_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorUInt8___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorUInt8___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_python_interface.VectorUInt8___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Any":
        return _ids_peak_python_interface.VectorUInt8___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorUInt8___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_python_interface.VectorUInt8___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorUInt8___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorUInt8___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorUInt8___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_python_interface.VectorUInt8_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorUInt8_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorUInt8_empty(self)

    def size(self) -> "Any":
        return _ids_peak_python_interface.VectorUInt8_size(self)

    def swap(self, v: "VectorUInt8") -> "None":
        return _ids_peak_python_interface.VectorUInt8_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_python_interface.VectorUInt8_begin(self)

    def end(self) -> "Any":
        return _ids_peak_python_interface.VectorUInt8_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_python_interface.VectorUInt8_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_python_interface.VectorUInt8_rend(self)

    def clear(self) -> "None":
        return _ids_peak_python_interface.VectorUInt8_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_python_interface.VectorUInt8_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_python_interface.VectorUInt8_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorUInt8_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorUInt8_swiginit(self, _ids_peak_python_interface.new_VectorUInt8(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorUInt8_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_python_interface.VectorUInt8_front(self)

    def back(self) -> "Any":
        return _ids_peak_python_interface.VectorUInt8_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_python_interface.VectorUInt8_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_python_interface.VectorUInt8_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_python_interface.VectorUInt8_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_python_interface.VectorUInt8_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_python_interface.VectorUInt8_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorUInt8

# Register VectorUInt8 in _ids_peak_python_interface:
_ids_peak_python_interface.VectorUInt8_swigregister(VectorUInt8)
class VectorNodeMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_python_interface.VectorNodeMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorNodeMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorNodeMap___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_python_interface.VectorNodeMap___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[NodeMap]":
        return _ids_peak_python_interface.VectorNodeMap___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorNodeMap___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_python_interface.VectorNodeMap___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorNodeMap___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorNodeMap___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorNodeMap___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_python_interface.VectorNodeMap_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorNodeMap_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorNodeMap_empty(self)

    def size(self) -> "Any":
        return _ids_peak_python_interface.VectorNodeMap_size(self)

    def swap(self, v: "VectorNodeMap") -> "None":
        return _ids_peak_python_interface.VectorNodeMap_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_python_interface.VectorNodeMap_begin(self)

    def end(self) -> "Any":
        return _ids_peak_python_interface.VectorNodeMap_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_python_interface.VectorNodeMap_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_python_interface.VectorNodeMap_rend(self)

    def clear(self) -> "None":
        return _ids_peak_python_interface.VectorNodeMap_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_python_interface.VectorNodeMap_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_python_interface.VectorNodeMap_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorNodeMap_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorNodeMap_swiginit(self, _ids_peak_python_interface.new_VectorNodeMap(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorNodeMap_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_python_interface.VectorNodeMap_front(self)

    def back(self) -> "Any":
        return _ids_peak_python_interface.VectorNodeMap_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_python_interface.VectorNodeMap_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_python_interface.VectorNodeMap_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_python_interface.VectorNodeMap_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_python_interface.VectorNodeMap_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_python_interface.VectorNodeMap_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorNodeMap

# Register VectorNodeMap in _ids_peak_python_interface:
_ids_peak_python_interface.VectorNodeMap_swigregister(VectorNodeMap)
class VectorEnumerationEntryNode(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[EnumerationEntryNode]":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorEnumerationEntryNode___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_empty(self)

    def size(self) -> "Any":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_size(self)

    def swap(self, v: "VectorEnumerationEntryNode") -> "None":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_begin(self)

    def end(self) -> "Any":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_rend(self)

    def clear(self) -> "None":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorEnumerationEntryNode_swiginit(self, _ids_peak_python_interface.new_VectorEnumerationEntryNode(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_front(self)

    def back(self) -> "Any":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_python_interface.VectorEnumerationEntryNode_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorEnumerationEntryNode

# Register VectorEnumerationEntryNode in _ids_peak_python_interface:
_ids_peak_python_interface.VectorEnumerationEntryNode_swigregister(VectorEnumerationEntryNode)
class VectorPortURL(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_python_interface.VectorPortURL_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorPortURL___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorPortURL___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_python_interface.VectorPortURL___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[PortURL]":
        return _ids_peak_python_interface.VectorPortURL___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorPortURL___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_python_interface.VectorPortURL___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorPortURL___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorPortURL___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorPortURL___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_python_interface.VectorPortURL_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorPortURL_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorPortURL_empty(self)

    def size(self) -> "Any":
        return _ids_peak_python_interface.VectorPortURL_size(self)

    def swap(self, v: "VectorPortURL") -> "None":
        return _ids_peak_python_interface.VectorPortURL_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_python_interface.VectorPortURL_begin(self)

    def end(self) -> "Any":
        return _ids_peak_python_interface.VectorPortURL_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_python_interface.VectorPortURL_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_python_interface.VectorPortURL_rend(self)

    def clear(self) -> "None":
        return _ids_peak_python_interface.VectorPortURL_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_python_interface.VectorPortURL_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_python_interface.VectorPortURL_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorPortURL_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorPortURL_swiginit(self, _ids_peak_python_interface.new_VectorPortURL(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorPortURL_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_python_interface.VectorPortURL_front(self)

    def back(self) -> "Any":
        return _ids_peak_python_interface.VectorPortURL_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_python_interface.VectorPortURL_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_python_interface.VectorPortURL_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_python_interface.VectorPortURL_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_python_interface.VectorPortURL_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_python_interface.VectorPortURL_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorPortURL

# Register VectorPortURL in _ids_peak_python_interface:
_ids_peak_python_interface.VectorPortURL_swigregister(VectorPortURL)
class VectorInterfaceDescriptor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[InterfaceDescriptor]":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorInterfaceDescriptor___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_empty(self)

    def size(self) -> "Any":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_size(self)

    def swap(self, v: "VectorInterfaceDescriptor") -> "None":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_begin(self)

    def end(self) -> "Any":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_rend(self)

    def clear(self) -> "None":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorInterfaceDescriptor_swiginit(self, _ids_peak_python_interface.new_VectorInterfaceDescriptor(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_front(self)

    def back(self) -> "Any":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_python_interface.VectorInterfaceDescriptor_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorInterfaceDescriptor

# Register VectorInterfaceDescriptor in _ids_peak_python_interface:
_ids_peak_python_interface.VectorInterfaceDescriptor_swigregister(VectorInterfaceDescriptor)
class VectorDeviceDescriptor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_python_interface.VectorDeviceDescriptor_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorDeviceDescriptor___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorDeviceDescriptor___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_python_interface.VectorDeviceDescriptor___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[DeviceDescriptor]":
        return _ids_peak_python_interface.VectorDeviceDescriptor___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorDeviceDescriptor___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_python_interface.VectorDeviceDescriptor___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorDeviceDescriptor___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorDeviceDescriptor___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorDeviceDescriptor___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_python_interface.VectorDeviceDescriptor_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorDeviceDescriptor_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorDeviceDescriptor_empty(self)

    def size(self) -> "Any":
        return _ids_peak_python_interface.VectorDeviceDescriptor_size(self)

    def swap(self, v: "VectorDeviceDescriptor") -> "None":
        return _ids_peak_python_interface.VectorDeviceDescriptor_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_python_interface.VectorDeviceDescriptor_begin(self)

    def end(self) -> "Any":
        return _ids_peak_python_interface.VectorDeviceDescriptor_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_python_interface.VectorDeviceDescriptor_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_python_interface.VectorDeviceDescriptor_rend(self)

    def clear(self) -> "None":
        return _ids_peak_python_interface.VectorDeviceDescriptor_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_python_interface.VectorDeviceDescriptor_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_python_interface.VectorDeviceDescriptor_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorDeviceDescriptor_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorDeviceDescriptor_swiginit(self, _ids_peak_python_interface.new_VectorDeviceDescriptor(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorDeviceDescriptor_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_python_interface.VectorDeviceDescriptor_front(self)

    def back(self) -> "Any":
        return _ids_peak_python_interface.VectorDeviceDescriptor_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_python_interface.VectorDeviceDescriptor_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_python_interface.VectorDeviceDescriptor_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_python_interface.VectorDeviceDescriptor_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_python_interface.VectorDeviceDescriptor_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_python_interface.VectorDeviceDescriptor_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorDeviceDescriptor

# Register VectorDeviceDescriptor in _ids_peak_python_interface:
_ids_peak_python_interface.VectorDeviceDescriptor_swigregister(VectorDeviceDescriptor)
class VectorFirmwareUpdateInformation(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[FirmwareUpdateInformation]":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_empty(self)

    def size(self) -> "Any":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_size(self)

    def swap(self, v: "VectorFirmwareUpdateInformation") -> "None":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_begin(self)

    def end(self) -> "Any":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_rend(self)

    def clear(self) -> "None":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorFirmwareUpdateInformation_swiginit(self, _ids_peak_python_interface.new_VectorFirmwareUpdateInformation(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_front(self)

    def back(self) -> "Any":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_python_interface.VectorFirmwareUpdateInformation_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorFirmwareUpdateInformation

# Register VectorFirmwareUpdateInformation in _ids_peak_python_interface:
_ids_peak_python_interface.VectorFirmwareUpdateInformation_swigregister(VectorFirmwareUpdateInformation)
class VectorDataStreamDescriptor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[DataStreamDescriptor]":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorDataStreamDescriptor___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_empty(self)

    def size(self) -> "Any":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_size(self)

    def swap(self, v: "VectorDataStreamDescriptor") -> "None":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_begin(self)

    def end(self) -> "Any":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_rend(self)

    def clear(self) -> "None":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorDataStreamDescriptor_swiginit(self, _ids_peak_python_interface.new_VectorDataStreamDescriptor(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_front(self)

    def back(self) -> "Any":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_python_interface.VectorDataStreamDescriptor_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorDataStreamDescriptor

# Register VectorDataStreamDescriptor in _ids_peak_python_interface:
_ids_peak_python_interface.VectorDataStreamDescriptor_swigregister(VectorDataStreamDescriptor)
class VectorBuffer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_python_interface.VectorBuffer_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorBuffer___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorBuffer___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_python_interface.VectorBuffer___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[Buffer]":
        return _ids_peak_python_interface.VectorBuffer___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorBuffer___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_python_interface.VectorBuffer___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorBuffer___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorBuffer___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorBuffer___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_python_interface.VectorBuffer_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorBuffer_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorBuffer_empty(self)

    def size(self) -> "Any":
        return _ids_peak_python_interface.VectorBuffer_size(self)

    def swap(self, v: "VectorBuffer") -> "None":
        return _ids_peak_python_interface.VectorBuffer_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_python_interface.VectorBuffer_begin(self)

    def end(self) -> "Any":
        return _ids_peak_python_interface.VectorBuffer_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_python_interface.VectorBuffer_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_python_interface.VectorBuffer_rend(self)

    def clear(self) -> "None":
        return _ids_peak_python_interface.VectorBuffer_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_python_interface.VectorBuffer_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_python_interface.VectorBuffer_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorBuffer_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorBuffer_swiginit(self, _ids_peak_python_interface.new_VectorBuffer(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorBuffer_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_python_interface.VectorBuffer_front(self)

    def back(self) -> "Any":
        return _ids_peak_python_interface.VectorBuffer_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_python_interface.VectorBuffer_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_python_interface.VectorBuffer_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_python_interface.VectorBuffer_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_python_interface.VectorBuffer_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_python_interface.VectorBuffer_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorBuffer

# Register VectorBuffer in _ids_peak_python_interface:
_ids_peak_python_interface.VectorBuffer_swigregister(VectorBuffer)
class VectorBufferChunk(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_python_interface.VectorBufferChunk_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorBufferChunk___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorBufferChunk___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferChunk___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[BufferChunk]":
        return _ids_peak_python_interface.VectorBufferChunk___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorBufferChunk___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_python_interface.VectorBufferChunk___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorBufferChunk___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorBufferChunk___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorBufferChunk___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferChunk_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorBufferChunk_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorBufferChunk_empty(self)

    def size(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferChunk_size(self)

    def swap(self, v: "VectorBufferChunk") -> "None":
        return _ids_peak_python_interface.VectorBufferChunk_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferChunk_begin(self)

    def end(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferChunk_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferChunk_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferChunk_rend(self)

    def clear(self) -> "None":
        return _ids_peak_python_interface.VectorBufferChunk_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferChunk_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_python_interface.VectorBufferChunk_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorBufferChunk_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorBufferChunk_swiginit(self, _ids_peak_python_interface.new_VectorBufferChunk(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorBufferChunk_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferChunk_front(self)

    def back(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferChunk_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_python_interface.VectorBufferChunk_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_python_interface.VectorBufferChunk_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_python_interface.VectorBufferChunk_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_python_interface.VectorBufferChunk_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferChunk_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorBufferChunk

# Register VectorBufferChunk in _ids_peak_python_interface:
_ids_peak_python_interface.VectorBufferChunk_swigregister(VectorBufferChunk)
class VectorBufferPart(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_python_interface.VectorBufferPart_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_python_interface.VectorBufferPart___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_python_interface.VectorBufferPart___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferPart___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[BufferPart]":
        return _ids_peak_python_interface.VectorBufferPart___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorBufferPart___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_python_interface.VectorBufferPart___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorBufferPart___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorBufferPart___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_python_interface.VectorBufferPart___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferPart_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorBufferPart_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_python_interface.VectorBufferPart_empty(self)

    def size(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferPart_size(self)

    def swap(self, v: "VectorBufferPart") -> "None":
        return _ids_peak_python_interface.VectorBufferPart_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferPart_begin(self)

    def end(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferPart_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferPart_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferPart_rend(self)

    def clear(self) -> "None":
        return _ids_peak_python_interface.VectorBufferPart_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferPart_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_python_interface.VectorBufferPart_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_python_interface.VectorBufferPart_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_python_interface.VectorBufferPart_swiginit(self, _ids_peak_python_interface.new_VectorBufferPart(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_python_interface.VectorBufferPart_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferPart_front(self)

    def back(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferPart_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_python_interface.VectorBufferPart_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_python_interface.VectorBufferPart_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_python_interface.VectorBufferPart_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_python_interface.VectorBufferPart_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_python_interface.VectorBufferPart_capacity(self)
    __swig_destroy__ = _ids_peak_python_interface.delete_VectorBufferPart

# Register VectorBufferPart in _ids_peak_python_interface:
_ids_peak_python_interface.VectorBufferPart_swigregister(VectorBufferPart)

