# coding: utf-8

"""
    File Service API v3

    File Service API v3 - All v3 endpoints

    The version of the OpenAPI document: 0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from istari_digital_client.v3.models.cursor_page_resource_dto import CursorPageResourceDto
from istari_digital_client.v3.models.cursor_page_resource_revision_dto import CursorPageResourceRevisionDto
from istari_digital_client.v3.models.resource_create_dto import ResourceCreateDto
from istari_digital_client.v3.models.resource_dto import ResourceDto
from istari_digital_client.v3.models.resource_revision_create_dto import ResourceRevisionCreateDto
from istari_digital_client.v3.models.resource_revision_dto import ResourceRevisionDto
from istari_digital_client.v3.models.revision_relationship_create_dto import RevisionRelationshipCreateDto
from istari_digital_client.v3.models.revision_relationship_dto import RevisionRelationshipDto

from istari_digital_client.api_client import ApiClient, RequestSerialized
from istari_digital_client.api_response import ApiResponse
from istari_digital_client.rest import RESTResponseType

from istari_digital_client.storage.api.storage_api import StorageApi
from istari_digital_client.log_utils import log_method
from istari_digital_client.configuration import Configuration

class V3Api:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, config: Configuration, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client
        self.config = config


    @validate_call
    @log_method
    def create_resource(
        self,
        resource_create_dto: ResourceCreateDto,
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> ResourceDto:

        """
        This method creates a new resource.

        :param resource_create_dto: (required)
        :type resource_create_dto: ResourceCreateDto
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._create_resource_serialize(
            resource_create_dto=resource_create_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceDto",
            '422': "HTTPValidationError",
        }


        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_resource_with_http_info(
        self,
        resource_create_dto: ResourceCreateDto,
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> ApiResponse[ResourceDto]:

        """
        This method creates a new resource.

        :param resource_create_dto: (required)
        :type resource_create_dto: ResourceCreateDto
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._create_resource_serialize(
            resource_create_dto=resource_create_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceDto",
            '422': "HTTPValidationError",
        }


        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_resource_without_preload_content(
        self,
        resource_create_dto: ResourceCreateDto,
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> RESTResponseType:

        """
        This method creates a new resource.

        :param resource_create_dto: (required)
        :type resource_create_dto: ResourceCreateDto
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._create_resource_serialize(
            resource_create_dto=resource_create_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceDto",
            '422': "HTTPValidationError",
        }

        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        return response_data.response


    def _create_resource_serialize(
        self,
        resource_create_dto,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if resource_create_dto is not None:
            _body_params = resource_create_dto


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'RequestAuthenticator'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/resources',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    @log_method
    def create_resource_revision(
        self,
        resource_id: Annotated[StrictStr, Field(description="The ID of the resource to create a new revision for.")],
        resource_revision_create_dto: ResourceRevisionCreateDto,
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> ResourceRevisionDto:

        """
        This method creates a new revision for a resource.

        :param resource_id: The ID of the resource to create a new revision for. (required)
        :type resource_id: str
        :param resource_revision_create_dto: (required)
        :type resource_revision_create_dto: ResourceRevisionCreateDto
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._create_resource_revision_serialize(
            resource_id=resource_id,
            resource_revision_create_dto=resource_revision_create_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceRevisionDto",
            '422': "HTTPValidationError",
        }


        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_resource_revision_with_http_info(
        self,
        resource_id: Annotated[StrictStr, Field(description="The ID of the resource to create a new revision for.")],
        resource_revision_create_dto: ResourceRevisionCreateDto,
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> ApiResponse[ResourceRevisionDto]:

        """
        This method creates a new revision for a resource.

        :param resource_id: The ID of the resource to create a new revision for. (required)
        :type resource_id: str
        :param resource_revision_create_dto: (required)
        :type resource_revision_create_dto: ResourceRevisionCreateDto
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._create_resource_revision_serialize(
            resource_id=resource_id,
            resource_revision_create_dto=resource_revision_create_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceRevisionDto",
            '422': "HTTPValidationError",
        }


        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_resource_revision_without_preload_content(
        self,
        resource_id: Annotated[StrictStr, Field(description="The ID of the resource to create a new revision for.")],
        resource_revision_create_dto: ResourceRevisionCreateDto,
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> RESTResponseType:

        """
        This method creates a new revision for a resource.

        :param resource_id: The ID of the resource to create a new revision for. (required)
        :type resource_id: str
        :param resource_revision_create_dto: (required)
        :type resource_revision_create_dto: ResourceRevisionCreateDto
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._create_resource_revision_serialize(
            resource_id=resource_id,
            resource_revision_create_dto=resource_revision_create_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceRevisionDto",
            '422': "HTTPValidationError",
        }

        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        return response_data.response


    def _create_resource_revision_serialize(
        self,
        resource_id,
        resource_revision_create_dto,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if resource_id is not None:
            _path_params['resource_id'] = resource_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if resource_revision_create_dto is not None:
            _body_params = resource_revision_create_dto


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'RequestAuthenticator'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/resources/{resource_id}/revisions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    @log_method
    def create_revision_relationship(
        self,
        resource_id: Annotated[StrictStr, Field(description="The ID of the resource to create a new relationship for.")],
        revision_id: Annotated[StrictStr, Field(description="The ID of the revision to create a new relationship for.")],
        revision_relationship_create_dto: RevisionRelationshipCreateDto,
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> RevisionRelationshipDto:

        """
        This method creates a new relationship for a revision.

        :param resource_id: The ID of the resource to create a new relationship for. (required)
        :type resource_id: str
        :param revision_id: The ID of the revision to create a new relationship for. (required)
        :type revision_id: str
        :param revision_relationship_create_dto: (required)
        :type revision_relationship_create_dto: RevisionRelationshipCreateDto
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._create_revision_relationship_serialize(
            resource_id=resource_id,
            revision_id=revision_id,
            revision_relationship_create_dto=revision_relationship_create_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RevisionRelationshipDto",
            '422': "HTTPValidationError",
        }


        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_revision_relationship_with_http_info(
        self,
        resource_id: Annotated[StrictStr, Field(description="The ID of the resource to create a new relationship for.")],
        revision_id: Annotated[StrictStr, Field(description="The ID of the revision to create a new relationship for.")],
        revision_relationship_create_dto: RevisionRelationshipCreateDto,
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> ApiResponse[RevisionRelationshipDto]:

        """
        This method creates a new relationship for a revision.

        :param resource_id: The ID of the resource to create a new relationship for. (required)
        :type resource_id: str
        :param revision_id: The ID of the revision to create a new relationship for. (required)
        :type revision_id: str
        :param revision_relationship_create_dto: (required)
        :type revision_relationship_create_dto: RevisionRelationshipCreateDto
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._create_revision_relationship_serialize(
            resource_id=resource_id,
            revision_id=revision_id,
            revision_relationship_create_dto=revision_relationship_create_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RevisionRelationshipDto",
            '422': "HTTPValidationError",
        }


        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_revision_relationship_without_preload_content(
        self,
        resource_id: Annotated[StrictStr, Field(description="The ID of the resource to create a new relationship for.")],
        revision_id: Annotated[StrictStr, Field(description="The ID of the revision to create a new relationship for.")],
        revision_relationship_create_dto: RevisionRelationshipCreateDto,
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> RESTResponseType:

        """
        This method creates a new relationship for a revision.

        :param resource_id: The ID of the resource to create a new relationship for. (required)
        :type resource_id: str
        :param revision_id: The ID of the revision to create a new relationship for. (required)
        :type revision_id: str
        :param revision_relationship_create_dto: (required)
        :type revision_relationship_create_dto: RevisionRelationshipCreateDto
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._create_revision_relationship_serialize(
            resource_id=resource_id,
            revision_id=revision_id,
            revision_relationship_create_dto=revision_relationship_create_dto,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RevisionRelationshipDto",
            '422': "HTTPValidationError",
        }

        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        return response_data.response


    def _create_revision_relationship_serialize(
        self,
        resource_id,
        revision_id,
        revision_relationship_create_dto,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if resource_id is not None:
            _path_params['resource_id'] = resource_id
        if revision_id is not None:
            _path_params['revision_id'] = revision_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if revision_relationship_create_dto is not None:
            _body_params = revision_relationship_create_dto


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'RequestAuthenticator'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v3/resources/{resource_id}/revisions/{revision_id}/relationships',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    @log_method
    def get_resource(
        self,
        resource_id: Annotated[StrictStr, Field(description="The ID of the resource to get.")],
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> ResourceDto:

        """
        This method gets a resource by its resource ID.

        :param resource_id: The ID of the resource to get. (required)
        :type resource_id: str
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._get_resource_serialize(
            resource_id=resource_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceDto",
            '422': "HTTPValidationError",
        }


        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_resource_with_http_info(
        self,
        resource_id: Annotated[StrictStr, Field(description="The ID of the resource to get.")],
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> ApiResponse[ResourceDto]:

        """
        This method gets a resource by its resource ID.

        :param resource_id: The ID of the resource to get. (required)
        :type resource_id: str
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._get_resource_serialize(
            resource_id=resource_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceDto",
            '422': "HTTPValidationError",
        }


        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_resource_without_preload_content(
        self,
        resource_id: Annotated[StrictStr, Field(description="The ID of the resource to get.")],
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> RESTResponseType:

        """
        This method gets a resource by its resource ID.

        :param resource_id: The ID of the resource to get. (required)
        :type resource_id: str
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._get_resource_serialize(
            resource_id=resource_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceDto",
            '422': "HTTPValidationError",
        }

        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        return response_data.response


    def _get_resource_serialize(
        self,
        resource_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if resource_id is not None:
            _path_params['resource_id'] = resource_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'RequestAuthenticator'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/resources/{resource_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    @log_method
    def get_resource_revision(
        self,
        resource_id: Annotated[StrictStr, Field(description="The ID of the resource.")],
        revision_id: Annotated[StrictStr, Field(description="The ID of the revision to get.")],
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> ResourceRevisionDto:

        """
        This method gets a revision for a resource by its revision ID.

        :param resource_id: The ID of the resource. (required)
        :type resource_id: str
        :param revision_id: The ID of the revision to get. (required)
        :type revision_id: str
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._get_resource_revision_serialize(
            resource_id=resource_id,
            revision_id=revision_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceRevisionDto",
            '422': "HTTPValidationError",
        }


        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_resource_revision_with_http_info(
        self,
        resource_id: Annotated[StrictStr, Field(description="The ID of the resource.")],
        revision_id: Annotated[StrictStr, Field(description="The ID of the revision to get.")],
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> ApiResponse[ResourceRevisionDto]:

        """
        This method gets a revision for a resource by its revision ID.

        :param resource_id: The ID of the resource. (required)
        :type resource_id: str
        :param revision_id: The ID of the revision to get. (required)
        :type revision_id: str
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._get_resource_revision_serialize(
            resource_id=resource_id,
            revision_id=revision_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceRevisionDto",
            '422': "HTTPValidationError",
        }


        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_resource_revision_without_preload_content(
        self,
        resource_id: Annotated[StrictStr, Field(description="The ID of the resource.")],
        revision_id: Annotated[StrictStr, Field(description="The ID of the revision to get.")],
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> RESTResponseType:

        """
        This method gets a revision for a resource by its revision ID.

        :param resource_id: The ID of the resource. (required)
        :type resource_id: str
        :param revision_id: The ID of the revision to get. (required)
        :type revision_id: str
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._get_resource_revision_serialize(
            resource_id=resource_id,
            revision_id=revision_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResourceRevisionDto",
            '422': "HTTPValidationError",
        }

        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        return response_data.response


    def _get_resource_revision_serialize(
        self,
        resource_id,
        revision_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if resource_id is not None:
            _path_params['resource_id'] = resource_id
        if revision_id is not None:
            _path_params['revision_id'] = revision_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'RequestAuthenticator'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/resources/{resource_id}/revisions/{revision_id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    @log_method
    def list_resource_revisions(
        self,
        resource_id: Annotated[StrictStr, Field(description="The ID of the resource to list revisions for.")],
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor for the next page")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=0)]], Field(description="Page size")] = None,
        include_total: Optional[StrictBool] = None,
        file_revision_id: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision IDs.")] = None,
        created_by_id: Annotated[Optional[List[StrictStr]], Field(description="Filter by created by IDs.")] = None,
        name: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision names.")] = None,
        description: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision descriptions.")] = None,
        version_name: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision version names.")] = None,
        external_identifier: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision external identifier.")] = None,
        display_name: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision display names.")] = None,
        mime_type: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision mime types.")] = None,
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> CursorPageResourceRevisionDto:

        """
        This method lists all revisions for a resource a user has access to.

        :param resource_id: The ID of the resource to list revisions for. (required)
        :type resource_id: str
        :param cursor: Cursor for the next page
        :type cursor: str
        :param size: Page size
        :type size: int
        :param include_total:
        :type include_total: bool
        :param file_revision_id: Filter by revision IDs.
        :type file_revision_id: List[str]
        :param created_by_id: Filter by created by IDs.
        :type created_by_id: List[str]
        :param name: Filter by revision names.
        :type name: List[str]
        :param description: Filter by revision descriptions.
        :type description: List[str]
        :param version_name: Filter by revision version names.
        :type version_name: List[str]
        :param external_identifier: Filter by revision external identifier.
        :type external_identifier: List[str]
        :param display_name: Filter by revision display names.
        :type display_name: List[str]
        :param mime_type: Filter by revision mime types.
        :type mime_type: List[str]
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._list_resource_revisions_serialize(
            resource_id=resource_id,
            cursor=cursor,
            size=size,
            include_total=include_total,
            file_revision_id=file_revision_id,
            created_by_id=created_by_id,
            name=name,
            description=description,
            version_name=version_name,
            external_identifier=external_identifier,
            display_name=display_name,
            mime_type=mime_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CursorPageResourceRevisionDto",
            '422': "HTTPValidationError",
        }


        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_resource_revisions_with_http_info(
        self,
        resource_id: Annotated[StrictStr, Field(description="The ID of the resource to list revisions for.")],
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor for the next page")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=0)]], Field(description="Page size")] = None,
        include_total: Optional[StrictBool] = None,
        file_revision_id: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision IDs.")] = None,
        created_by_id: Annotated[Optional[List[StrictStr]], Field(description="Filter by created by IDs.")] = None,
        name: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision names.")] = None,
        description: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision descriptions.")] = None,
        version_name: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision version names.")] = None,
        external_identifier: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision external identifier.")] = None,
        display_name: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision display names.")] = None,
        mime_type: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision mime types.")] = None,
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> ApiResponse[CursorPageResourceRevisionDto]:

        """
        This method lists all revisions for a resource a user has access to.

        :param resource_id: The ID of the resource to list revisions for. (required)
        :type resource_id: str
        :param cursor: Cursor for the next page
        :type cursor: str
        :param size: Page size
        :type size: int
        :param include_total:
        :type include_total: bool
        :param file_revision_id: Filter by revision IDs.
        :type file_revision_id: List[str]
        :param created_by_id: Filter by created by IDs.
        :type created_by_id: List[str]
        :param name: Filter by revision names.
        :type name: List[str]
        :param description: Filter by revision descriptions.
        :type description: List[str]
        :param version_name: Filter by revision version names.
        :type version_name: List[str]
        :param external_identifier: Filter by revision external identifier.
        :type external_identifier: List[str]
        :param display_name: Filter by revision display names.
        :type display_name: List[str]
        :param mime_type: Filter by revision mime types.
        :type mime_type: List[str]
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._list_resource_revisions_serialize(
            resource_id=resource_id,
            cursor=cursor,
            size=size,
            include_total=include_total,
            file_revision_id=file_revision_id,
            created_by_id=created_by_id,
            name=name,
            description=description,
            version_name=version_name,
            external_identifier=external_identifier,
            display_name=display_name,
            mime_type=mime_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CursorPageResourceRevisionDto",
            '422': "HTTPValidationError",
        }


        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_resource_revisions_without_preload_content(
        self,
        resource_id: Annotated[StrictStr, Field(description="The ID of the resource to list revisions for.")],
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor for the next page")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=0)]], Field(description="Page size")] = None,
        include_total: Optional[StrictBool] = None,
        file_revision_id: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision IDs.")] = None,
        created_by_id: Annotated[Optional[List[StrictStr]], Field(description="Filter by created by IDs.")] = None,
        name: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision names.")] = None,
        description: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision descriptions.")] = None,
        version_name: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision version names.")] = None,
        external_identifier: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision external identifier.")] = None,
        display_name: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision display names.")] = None,
        mime_type: Annotated[Optional[List[StrictStr]], Field(description="Filter by revision mime types.")] = None,
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> RESTResponseType:

        """
        This method lists all revisions for a resource a user has access to.

        :param resource_id: The ID of the resource to list revisions for. (required)
        :type resource_id: str
        :param cursor: Cursor for the next page
        :type cursor: str
        :param size: Page size
        :type size: int
        :param include_total:
        :type include_total: bool
        :param file_revision_id: Filter by revision IDs.
        :type file_revision_id: List[str]
        :param created_by_id: Filter by created by IDs.
        :type created_by_id: List[str]
        :param name: Filter by revision names.
        :type name: List[str]
        :param description: Filter by revision descriptions.
        :type description: List[str]
        :param version_name: Filter by revision version names.
        :type version_name: List[str]
        :param external_identifier: Filter by revision external identifier.
        :type external_identifier: List[str]
        :param display_name: Filter by revision display names.
        :type display_name: List[str]
        :param mime_type: Filter by revision mime types.
        :type mime_type: List[str]
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._list_resource_revisions_serialize(
            resource_id=resource_id,
            cursor=cursor,
            size=size,
            include_total=include_total,
            file_revision_id=file_revision_id,
            created_by_id=created_by_id,
            name=name,
            description=description,
            version_name=version_name,
            external_identifier=external_identifier,
            display_name=display_name,
            mime_type=mime_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CursorPageResourceRevisionDto",
            '422': "HTTPValidationError",
        }

        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        return response_data.response


    def _list_resource_revisions_serialize(
        self,
        resource_id,
        cursor,
        size,
        include_total,
        file_revision_id,
        created_by_id,
        name,
        description,
        version_name,
        external_identifier,
        display_name,
        mime_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'file_revision_id': 'multi',
            'created_by_id': 'multi',
            'name': 'multi',
            'description': 'multi',
            'version_name': 'multi',
            'external_identifier': 'multi',
            'display_name': 'multi',
            'mime_type': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if resource_id is not None:
            _path_params['resource_id'] = resource_id
        # process the query parameters
        if cursor is not None:

            _query_params.append(('cursor', cursor))

        if size is not None:

            _query_params.append(('size', size))

        if include_total is not None:

            _query_params.append(('include_total', include_total))

        if file_revision_id is not None:

            _query_params.append(('file_revision_id', file_revision_id))

        if created_by_id is not None:

            _query_params.append(('created_by_id', created_by_id))

        if name is not None:

            _query_params.append(('name', name))

        if description is not None:

            _query_params.append(('description', description))

        if version_name is not None:

            _query_params.append(('version_name', version_name))

        if external_identifier is not None:

            _query_params.append(('external_identifier', external_identifier))

        if display_name is not None:

            _query_params.append(('display_name', display_name))

        if mime_type is not None:

            _query_params.append(('mime_type', mime_type))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'RequestAuthenticator'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/resources/{resource_id}/revisions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    @log_method
    def list_resources(
        self,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor for the next page")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=0)]], Field(description="Page size")] = None,
        include_total: Optional[StrictBool] = None,
        resource_id: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource IDs.")] = None,
        created_by_id: Annotated[Optional[List[StrictStr]], Field(description="Filter by created by IDs.")] = None,
        name: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource names.")] = None,
        type_name: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource type names.")] = None,
        description: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource descriptions.")] = None,
        version_name: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource version names.")] = None,
        external_identifier: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource external identifier.")] = None,
        display_name: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource display names.")] = None,
        mime_type: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource mime types.")] = None,
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> CursorPageResourceDto:

        """
        This method lists all resources a user has access to.

        :param cursor: Cursor for the next page
        :type cursor: str
        :param size: Page size
        :type size: int
        :param include_total:
        :type include_total: bool
        :param resource_id: Filter by resource IDs.
        :type resource_id: List[str]
        :param created_by_id: Filter by created by IDs.
        :type created_by_id: List[str]
        :param name: Filter by resource names.
        :type name: List[str]
        :param type_name: Filter by resource type names.
        :type type_name: List[str]
        :param description: Filter by resource descriptions.
        :type description: List[str]
        :param version_name: Filter by resource version names.
        :type version_name: List[str]
        :param external_identifier: Filter by resource external identifier.
        :type external_identifier: List[str]
        :param display_name: Filter by resource display names.
        :type display_name: List[str]
        :param mime_type: Filter by resource mime types.
        :type mime_type: List[str]
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._list_resources_serialize(
            cursor=cursor,
            size=size,
            include_total=include_total,
            resource_id=resource_id,
            created_by_id=created_by_id,
            name=name,
            type_name=type_name,
            description=description,
            version_name=version_name,
            external_identifier=external_identifier,
            display_name=display_name,
            mime_type=mime_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CursorPageResourceDto",
            '422': "HTTPValidationError",
        }


        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_resources_with_http_info(
        self,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor for the next page")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=0)]], Field(description="Page size")] = None,
        include_total: Optional[StrictBool] = None,
        resource_id: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource IDs.")] = None,
        created_by_id: Annotated[Optional[List[StrictStr]], Field(description="Filter by created by IDs.")] = None,
        name: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource names.")] = None,
        type_name: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource type names.")] = None,
        description: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource descriptions.")] = None,
        version_name: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource version names.")] = None,
        external_identifier: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource external identifier.")] = None,
        display_name: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource display names.")] = None,
        mime_type: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource mime types.")] = None,
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> ApiResponse[CursorPageResourceDto]:

        """
        This method lists all resources a user has access to.

        :param cursor: Cursor for the next page
        :type cursor: str
        :param size: Page size
        :type size: int
        :param include_total:
        :type include_total: bool
        :param resource_id: Filter by resource IDs.
        :type resource_id: List[str]
        :param created_by_id: Filter by created by IDs.
        :type created_by_id: List[str]
        :param name: Filter by resource names.
        :type name: List[str]
        :param type_name: Filter by resource type names.
        :type type_name: List[str]
        :param description: Filter by resource descriptions.
        :type description: List[str]
        :param version_name: Filter by resource version names.
        :type version_name: List[str]
        :param external_identifier: Filter by resource external identifier.
        :type external_identifier: List[str]
        :param display_name: Filter by resource display names.
        :type display_name: List[str]
        :param mime_type: Filter by resource mime types.
        :type mime_type: List[str]
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._list_resources_serialize(
            cursor=cursor,
            size=size,
            include_total=include_total,
            resource_id=resource_id,
            created_by_id=created_by_id,
            name=name,
            type_name=type_name,
            description=description,
            version_name=version_name,
            external_identifier=external_identifier,
            display_name=display_name,
            mime_type=mime_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CursorPageResourceDto",
            '422': "HTTPValidationError",
        }


        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_resources_without_preload_content(
        self,
        cursor: Annotated[Optional[StrictStr], Field(description="Cursor for the next page")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=0)]], Field(description="Page size")] = None,
        include_total: Optional[StrictBool] = None,
        resource_id: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource IDs.")] = None,
        created_by_id: Annotated[Optional[List[StrictStr]], Field(description="Filter by created by IDs.")] = None,
        name: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource names.")] = None,
        type_name: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource type names.")] = None,
        description: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource descriptions.")] = None,
        version_name: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource version names.")] = None,
        external_identifier: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource external identifier.")] = None,
        display_name: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource display names.")] = None,
        mime_type: Annotated[Optional[List[StrictStr]], Field(description="Filter by resource mime types.")] = None,
        http_request_timeout_secs: Annotated[StrictInt | None, Field(ge=0)] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0
    ) -> RESTResponseType:

        """
        This method lists all resources a user has access to.

        :param cursor: Cursor for the next page
        :type cursor: str
        :param size: Page size
        :type size: int
        :param include_total:
        :type include_total: bool
        :param resource_id: Filter by resource IDs.
        :type resource_id: List[str]
        :param created_by_id: Filter by created by IDs.
        :type created_by_id: List[str]
        :param name: Filter by resource names.
        :type name: List[str]
        :param type_name: Filter by resource type names.
        :type type_name: List[str]
        :param description: Filter by resource descriptions.
        :type description: List[str]
        :param version_name: Filter by resource version names.
        :type version_name: List[str]
        :param external_identifier: Filter by resource external identifier.
        :type external_identifier: List[str]
        :param display_name: Filter by resource display names.
        :type display_name: List[str]
        :param mime_type: Filter by resource mime types.
        :type mime_type: List[str]
        :param http_request_timeout_secs: timeout setting for this request
        :type http_request_timeout_secs: int, optional

        """ # noqa: E501

        _param = self._list_resources_serialize(
            cursor=cursor,
            size=size,
            include_total=include_total,
            resource_id=resource_id,
            created_by_id=created_by_id,
            name=name,
            type_name=type_name,
            description=description,
            version_name=version_name,
            external_identifier=external_identifier,
            display_name=display_name,
            mime_type=mime_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CursorPageResourceDto",
            '422': "HTTPValidationError",
        }

        request_timeout = http_request_timeout_secs or self.config.http_request_timeout_secs

        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=request_timeout
        )
        return response_data.response


    def _list_resources_serialize(
        self,
        cursor,
        size,
        include_total,
        resource_id,
        created_by_id,
        name,
        type_name,
        description,
        version_name,
        external_identifier,
        display_name,
        mime_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'resource_id': 'multi',
            'created_by_id': 'multi',
            'name': 'multi',
            'type_name': 'multi',
            'description': 'multi',
            'version_name': 'multi',
            'external_identifier': 'multi',
            'display_name': 'multi',
            'mime_type': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if cursor is not None:

            _query_params.append(('cursor', cursor))

        if size is not None:

            _query_params.append(('size', size))

        if include_total is not None:

            _query_params.append(('include_total', include_total))

        if resource_id is not None:

            _query_params.append(('resource_id', resource_id))

        if created_by_id is not None:

            _query_params.append(('created_by_id', created_by_id))

        if name is not None:

            _query_params.append(('name', name))

        if type_name is not None:

            _query_params.append(('type_name', type_name))

        if description is not None:

            _query_params.append(('description', description))

        if version_name is not None:

            _query_params.append(('version_name', version_name))

        if external_identifier is not None:

            _query_params.append(('external_identifier', external_identifier))

        if display_name is not None:

            _query_params.append(('display_name', display_name))

        if mime_type is not None:

            _query_params.append(('mime_type', mime_type))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'RequestAuthenticator'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v3/resources',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )
