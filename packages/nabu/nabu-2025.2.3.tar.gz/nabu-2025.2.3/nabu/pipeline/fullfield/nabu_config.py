# ruff: noqa: F405
from ..config_validators import *  # noqa: F403

nabu_config = {
    "dataset": {
        "location": {
            "default": "",
            "help": "Dataset location, either a directory or a HDF5-Nexus file.",
            "validator": dataset_location_validator,
            "type": "required",
        },
        "hdf5_entry": {
            "default": "",
            "help": "Which entry to process in the data HDF5 file. Default is the first entry. It can be a comma-separated list of entries, and/or a wildcard (* for all entries, or things like entry???1).",
            "validator": optional_string_validator,
            "type": "advanced",
        },
        "nexus_version": {
            "default": "",
            "help": "Specify a Nexus version to use when browsing the HDF5 dataset.",
            "validator": optional_float_validator,
            "type": "advanced",
        },
        "darks_flats_dir": {
            "default": "",
            "help": "Path to a directory where XXX_flats.h5 and XXX_darks.h5 are to be found, where 'XXX' denotes the dataset basename. If these files are found, then reduced flats/darks will be loaded from them. Otherwise, reduced flats/darks will be saved there once computed, either in the .nx directory, or in the output directory. Mind that the HDF5 entry corresponds to the one of the dataset.",
            "validator": optional_directory_location_validator,
            "type": "optional",
        },
        "binning": {
            "default": "1",
            "help": "Binning factor in the horizontal dimension when reading the data.\nThe final slices dimensions will be divided by this factor.",
            "validator": binning_validator,
            "type": "advanced",
        },
        "binning_z": {
            "default": "1",
            "help": "Binning factor in the vertical dimension when reading the data.\nThis results in a lesser number of reconstructed slices.",
            "validator": binning_validator,
            "type": "advanced",
        },
        "projections_subsampling": {
            "default": "1",
            "help": "Projections subsampling factor: take one projection out of 'projections_subsampling'. The format can be an integer (take 1 projection out of N), or N:M (take 1 projection out of N, start with the projection number M)\nFor example: 2 (or 2:0) to reconstruct from even projections, 2:1 to reconstruct from odd projections.",
            "validator": projections_subsampling_validator,
            "type": "advanced",
        },
        "exclude_projections": {
            "default": "",
            "help": "Projection to exclude from the reconstruction. It can be:\n-indices = exclude_projections_indices.txt : Path to a text file with one integer per line. Each corresponding projection INDEX will be ignored.\n-angles = exclude_projections_angles.txt : Path to a text file with angle in DEGREES, one per line. The corresponding angles will be ignored\n-angular_range = [a, b] : ignore angles belonging to angular range [a, b] in degrees, with b included.",
            "validator": exclude_projections_validator,
            "type": "advanced",
        },
        "overwrite_metadata": {
            "default": "",
            "help": "Which metadata to overwrite, separated by a semicolon, and with units. Example: 'energy = 19 kev; pixel_size = 1.6 um'. Supported entities are: pixel_size, energy, distance.",
            "validator": no_validator,
            "type": "advanced",
        },
        "flip_lr": {
            "default": "auto",
            "help": "Whether to flip frames left<->right when reconstructing. This parameter takes precedence over any metadata found in the dataset.",
            "validator": boolean_or_auto_validator,
            "type": "advanced",
        },
        "flip_ud": {
            "default": "auto",
            "help": "Whether to flip frames up<->down when reconstructing. This parameter takes precedence over any metadata found in the dataset.",
            "validator": boolean_or_auto_validator,
            "type": "advanced",
        },
    },
    "preproc": {
        "flatfield": {
            "default": "1",
            "help": "How to perform flat-field normalization. The parameter value can be:\n - 1 or True: enabled.\n - 0 or False: disabled\n - pca: perform a normalization via Principal Component Analysis decomposition PCA-flat-field normalization",
            "validator": flatfield_validator,
            "type": "required",
        },
        "flatfield_loading_mode": {
            "default": "load_if_present",
            "help": "How to load/compute flat-field. This parameter can be:\n - load_if_present (default) or empty string: Use the existing flatfield files, if existing.\n - force-load: perform flatfield regardless of the dataset by attempting to load darks/flats\n - force-compute: perform flatfield, ignore all .h5 files containing already computed darks/flats.",
            "validator": flatfield_loading_mode_validator,
            "type": "optional",
        },
        "flat_distortion_correction_enabled": {
            "default": "0",
            "help": "Whether to correct for flat distortion. If activated, each radiograph is correlated with its corresponding flat, in order to determine and correct the flat distortion.",
            "validator": boolean_validator,
            "type": "advanced",
        },
        "flat_distortion_params": {
            "default": "tile_size=100; interpolation_kind='linear'; padding_mode='edge'; correction_spike_threshold=None",
            "help": "Advanced parameters for flat distortion correction",
            "validator": optional_string_validator,
            "type": "advanced",
        },
        "normalize_srcurrent": {
            "default": "1",
            "help": "Whether to normalize frames with Synchrotron Current. This can correct the effect of a beam refill not taken into account by flats.",
            "validator": boolean_validator,
            "type": "advanced",
        },
        "ccd_filter_enabled": {
            "default": "0",
            "help": "Whether to enable the CCD hotspots correction.",
            "validator": boolean_validator,
            "type": "optional",
        },
        "ccd_filter_threshold": {
            "default": "0.04",
            "help": "If ccd_filter_enabled = 1, a median filter is applied on the 3X3 neighborhood\nof every pixel. If a pixel value exceeds the median value more than this parameter,\nthen the pixel value is replaced with the median value.",
            "validator": float_validator,
            "type": "optional",
        },
        "detector_distortion_correction": {
            "default": "",
            "help": "Apply coordinate transformation on the raw data, at the reading stage. Default (empty) is None.\n Available are: None, identity(for testing the pipeline), map_xz.\n This latter method requires two URLs being passed by detector_distortion_correction_options: map_x and map_z pointing to two 2D arrays containing the position where each pixel can be interpolated at in the raw data",
            "validator": detector_distortion_correction_validator,
            "type": "advanced",
        },
        "detector_distortion_correction_options": {
            "default": "",
            "help": """Options for detector_distortion_correction. Example, for mapx_xz: 
            detector_distortion_correction_options=map_x="silx:./dm.h5?path=/coords_source_x" ; map_z="silx:./dm.h5?path=/coords_source_z"
            Mind the semicolon separator (;).
            """,
            "validator": generic_options_validator,
            "type": "advanced",
        },
        "double_flatfield": {
            "default": "0",
            "help": "Whether to perform 'double flat-field' filtering (this can help to remove rings artefacts). Possible values:\n - 1 or True: enabled.\n - 0 or False: disabled\n - force-load: use an existing DFF file regardless of the dataset\n - force-compute: re-compute the DFF, ignore all existing .h5 files containing already computed DFF",
            "validator": flatfield_validator,
            "type": "optional",
        },
        "dff_sigma": {
            "default": "",
            "help": "Enable high-pass filtering on double flatfield with this value of 'sigma'",
            "validator": optional_float_validator,
            "type": "advanced",
        },
        "take_logarithm": {
            "default": "1",
            "help": "Whether to take logarithm after flat-field and phase retrieval.",
            "validator": boolean_validator,
            "type": "required",
        },
        "log_min_clip": {
            "default": "1e-6",
            "help": "After division by the FF, and before the logarithm, the is clipped to this minimum. Enabled only if take_logarithm=1",
            "validator": float_validator,
            "type": "advanced",
        },
        "log_max_clip": {
            "default": "10.0",
            "help": "After division by the FF, and before the logarithm, the is clipped to this maximum. Enabled only if take_logarithm=1",
            "validator": float_validator,
            "type": "advanced",
        },
        "sino_normalization": {
            "default": "",
            "help": "Sinogram normalization method. Available methods are: chebyshev, subtraction, division, none. Default is none (no normalization)",
            "validator": sino_normalization_validator,
            "type": "advanced",
        },
        "sino_normalization_file": {
            "default": "",
            "help": "Path to the file when sino_normalization is either 'subtraction' or 'division'. To specify the path within a HDF5 file, the syntax is /path/to/file?path=/entry/data",
            "validator": no_validator,
            "type": "advanced",
        },
        "processes_file": {
            "default": "",
            "help": "Path to the file where some operations should be stored for later use. By default it is 'xxx_nabu_processes.h5'",
            "validator": optional_output_file_path_validator,
            "type": "advanced",
        },
        "sino_rings_correction": {
            "default": "",
            "help": "Sinogram rings removal method. Default (empty) is None. Available are: None, munch, vo, mean-subtraction, mean-division. See also: sino_rings_options",
            "validator": sino_deringer_methods,
            "type": "optional",
        },
        "sino_rings_options": {
            "default": "",
            "help": "Options for sinogram rings correction methods. The parameters are separated by commas and passed as 'name=value'. Mind the semicolon separator (;). The default options are the following:\n-For munch: sigma=1.0 ; levels=10 ; padding=False\n-For vo: snr=3.0; la_size=51; sm_size=21; dim=1\n-For mean-subtraction and mean-division: filter_cutoff=(0, 30)",
            "validator": generic_options_validator,
            "type": "advanced",
        },
        "rotate_projections_center": {
            "default": "",
            "help": "Center of rotation when 'tilt_correction' is non-empty. By default the center of rotation is the middle of each radiograph, i.e ((Nx-1)/2.0, (Ny-1)/2.0).",
            "validator": optional_tuple_of_floats_validator,
            "type": "advanced",
        },
        "tilt_correction": {
            "default": "",
            "help": "Detector tilt correction. Default (empty) means no tilt correction.\nThe following values can be provided for automatic tilt estimation, in this case, the projection images are rotated by the found tilt value:\n - A scalar value: tilt correction angle in degrees\n - 1d-correlation: auto-detect tilt with the 1D correlation method (fastest, but works best for small tilts)\n - fft-polar: auto-detect tilt with polar FFT method (slower, but works well on all ranges of tilts)",
            "validator": tilt_validator,
            "type": "advanced",
        },
        "autotilt_options": {
            "default": "",
            "help": "Options for methods computing automatically the detector tilt. The parameters are separated by commas and passed as 'name=value', for example: low_pass=1; high_pass=20. Mind the semicolon separator (;). Use 'value' ('') for values that are strings",
            "validator": generic_options_validator,
            "type": "advanced",
        },
    },
    "phase": {
        "method": {
            "default": "none",
            "help": "Phase retrieval method. Available are: Paganin, CTF, None",
            "validator": phase_method_validator,
            "type": "required",
        },
        "delta_beta": {
            "default": "100.0",
            "help": "Single-distance phase retrieval related parameters\n----------------------------\ndelta/beta ratio for the Paganin/CTF method",
            "validator": float_validator,
            "type": "required",
        },
        "unsharp_coeff": {
            "default": "0",
            "help": "Unsharp mask strength. The unsharped image is equal to\n  UnsharpedImage =  (1 + coeff)*originalPaganinImage - coeff * ConvolvedImage. Setting this coefficient to zero means that no unsharp mask will be applied.",
            "validator": float_validator,
            "type": "optional",
        },
        "unsharp_sigma": {
            "default": "0",
            "help": "Standard deviation of the Gaussian filter when applying an unsharp mask\nafter the phase filtering. Disabled if set to 0.",
            "validator": float_validator,
            "type": "optional",
        },
        "unsharp_method": {
            "default": "gaussian",
            "help": "Which type of unsharp mask filter to use. Available values are gaussian, laplacian and imagej. Default is gaussian.",
            "validator": unsharp_method_validator,
            "type": "optional",
        },
        "padding_type": {
            "default": "edge",
            "help": "Padding type for the filtering step in Paganin/CTF. Available are: mirror, edge, zeros",
            "validator": padding_mode_validator,
            "type": "advanced",
        },
        "ctf_geometry": {
            "default": "z1_v=None; z1_h=None; detec_pixel_size=None; magnification=True",
            "help": "Geometric parameters for CTF phase retrieval. Length units are in meters.",
            "validator": optional_string_validator,
            "type": "optional",
        },
        "ctf_advanced_params": {
            "default": "length_scale=1e-5; lim1=1e-5; lim2=0.2; normalize_by_mean=True",
            "help": "Advanced parameters for CTF phase retrieval.",
            "validator": optional_string_validator,
            "type": "advanced",
        },
    },
    "reconstruction": {
        "method": {
            "default": "FBP",
            "help": "Reconstruction method. Possible values: FBP, HBP, cone, MLEM, none. If value is 'none', no reconstruction will be done.",
            "validator": reconstruction_method_validator,
            "type": "required",
        },
        "implementation": {
            "default": "",
            "help": "Reconstruction method implementation. The same method can have several implementations. Can be 'nabu', 'corrct', 'astra'",
            "validator": reconstruction_implementation_validator,
            "type": "advanced",
        },
        "angles_file": {
            "default": "",
            "help": "In the case you want to override the angles found in the files metadata. The angles are in degree.",
            "validator": optional_file_location_validator,
            "type": "optional",
        },
        "rotation_axis_position": {
            "default": "sliding-window",
            "help": "Rotation axis position. It can be a number or the name of an estimation method (empty value means the middle of the detector).\nThe following methods are available to find automatically the Center of Rotation (CoR):\n - centered : a fast and simple auto-CoR method. It only works when the CoR is not far from the middle of the detector. It does not work for half-tomography.\n - global : a slow but robust auto-CoR.\n - sliding-window : semi-automatically find the CoR with a sliding window. You have to specify on which side the CoR is (left, center, right). Please see the 'cor_options' parameter.\n - growing-window : automatically find the CoR with a sliding-and-growing window. You can tune the option with the parameter 'cor_options'.\n - sino-coarse-to-fine: Estimate CoR from sinogram. Only works for 360 degrees scans.\n - composite-coarse-to-fine: Estimate CoR from composite multi-angle images. Only works for 360 degrees scans.\n - fourier-angles: Estimate CoR from sino based on an angular correlation analysis. You can tune the option with the parameter 'cor_options'.\n - octave-accurate: Legacy from octave accurate COR estimation algorithm. It first estimates the COR with global fourier-based correlation, then refines this estimation with local correlation based on the variance of the difference patches. You can tune the option with the parameter 'cor_options'.\n - vo: Method from Nghia Vo, based on double-wedge in sinogram Fourier transform (needs algotom python package)",
            "validator": cor_validator,
            "type": "required",
        },
        "cor_options": {
            "default": "side='from_file'",
            "help": "Options for methods finding automatically the rotation axis position. The parameters are separated by commas and passed as 'name=value'.\nFor example: low_pass=1; high_pass=20. Mind the semicolon separator (;) and the '' for string values that are strings.\nIf 'side' is set, it is expected to be either:\n - 'from_file' (to pick the value in the NX file.)\n - or an relative CoR position in pixels (if so, it overrides the value in the NX file), \n or any of 'left', 'center', 'right', 'all', 'near'.\n The default value for 'side' is 'from_file'.",
            "validator": generic_options_validator,
            "type": "advanced",
        },
        "cor_slice": {
            "default": "",
            "help": "Which slice to use for estimating the Center of Rotation (CoR). This parameter can be an integer or 'top', 'middle', 'bottom'.\nIf provided, the CoR will be estimated from the corresponding sinogram, and 'cor_options' can contain the parameter 'subsampling'.",
            "validator": cor_slice_validator,
            "type": "advanced",
        },
        "axis_correction_file": {
            "default": "",
            "help": "In the case where the axis position is specified for each angle",
            "validator": optional_values_file_validator,
            "type": "advanced",
        },
        "translation_movements_file": {
            "default": "",
            "help": "A file where each line describes the horizontal and vertical translations of the sample (or detector). The order is 'horizontal, vertical'.\nIt can be created from a numpy array saved with 'numpy.savetxt'",
            "validator": optional_values_file_validator,
            "type": "advanced",
        },
        "angle_offset": {
            "default": "0",
            "help": "Use this if you want to obtain a rotated reconstructed slice. The angle is in degrees.",
            "validator": float_validator,
            "type": "advanced",
        },
        "fbp_filter_type": {
            "default": "ramlak",
            "help": "Filter type for FBP method. Available are: none, ramlak, shepp-logan, cosine, hamming, hann, tukey, lanczos, hilbert",
            "validator": fbp_filter_name_validator,
            "type": "advanced",
        },
        "fbp_filter_cutoff": {
            "default": "1.",
            "help": "Cut-off frequency for Fourier filter used in FBP, in normalized units. Default is the Nyquist frequency 1.0",
            "validator": float_validator,
            "type": "advanced",
        },
        "source_sample_dist": {
            "default": "",
            "help": "In cone-beam geometry, distance (in meters) between the X-ray source and the center of the sample. Default is infinity.",
            "validator": optional_float_validator,
            "type": "advanced",
        },
        "sample_detector_dist": {
            "default": "",
            "help": "In cone-beam geometry, distance (in meters) between the center of the sample and the detector. Default is read from the input dataset.",
            "validator": optional_float_validator,
            "type": "advanced",
        },
        "padding_type": {
            "default": "edges",
            "help": "Padding type for FBP. Available are: zeros, edges",
            "validator": padding_mode_validator,
            "type": "optional",  # put "advanced" with default value "edges" ?
        },
        "enable_halftomo": {
            "default": "auto",
            "help": "Whether to enable half-acquisition. Default is auto. You can enable/disable it manually by setting 1 or 0.",
            "validator": boolean_or_auto_validator,
            "type": "optional",
        },
        "clip_outer_circle": {
            "default": "0",
            "help": "Whether to mask voxels falling outside of the reconstruction region",
            "validator": boolean_validator,
            "type": "optional",
        },
        "outer_circle_value": {
            "default": "0",
            "help": "If 'clip_outer_circle' is enabled, value of the voxels falling outside of the reconstruction region.",
            "validator": float_validator,
            "type": "optional",
        },
        "centered_axis": {
            "default": "1",
            "help": "If set to true, the reconstructed region is centered on the rotation axis, i.e the center of the image will be the rotation axis position.",
            "validator": boolean_validator,
            "type": "optional",
        },
        "hbp_reduction_steps": {
            "default": "2",
            "help": "How many  reduction steps will be taken. At least 2. A Higher number may increase speed but may also increase the interpolation errors",
            "validator": nonnegative_integer_validator,
            "type": "advanced",
        },
        "hbp_legs": {
            "default": "4",
            "help": "Increasing this parameter help matching the GPU memory size for big slices. Reconstruction by fragments of the whole images. For very large slices it can be useful to increase this number to fit the memory",
            "validator": nonnegative_integer_validator,
            "type": "advanced",
        },
        "start_x": {
            "default": "0",
            "help": "\nParameters for sub-volume reconstruction. Indices start at 0, and upper bounds are INCLUDED!\n----------------------------------------------------------------\n(x, y) are the dimension of a slice, and (z) is the 'vertical' axis\nBy default, all the volume is reconstructed slice by slice, along the axis 'z'.",
            "validator": nonnegative_integer_validator,
            "type": "optional",
        },
        "end_x": {
            "default": "-1",
            "help": "",
            "validator": integer_validator,
            "type": "optional",
        },
        "start_y": {
            "default": "0",
            "help": "",
            "validator": nonnegative_integer_validator,
            "type": "optional",
        },
        "end_y": {
            "default": "-1",
            "help": "",
            "validator": integer_validator,
            "type": "optional",
        },
        "start_z": {
            "default": "0",
            "help": "",
            "validator": slice_num_validator,
            "type": "optional",
        },
        "end_z": {
            "default": "-1",
            "help": "",
            "validator": slice_num_validator,
            "type": "optional",
        },
        "iterations": {
            "default": "200",
            "help": "\nParameters for iterative algorithms\n------------------------------------\nNumber of iterations",
            "validator": nonnegative_integer_validator,
            "type": "advanced",
        },
        "crop_filtered_data": {
            "default": "1",
            "help": "Whether to crop the data after the filtering step in FBP/FDK. This parameter should be always 1 unless you know what you are doing.",
            "validator": boolean_validator,
            "type": "advanced",
        },
        "optim_algorithm": {
            "default": "chambolle-pock",
            "help": "Optimization algorithm for iterative methods",
            "validator": optimization_algorithm_name_validator,
            "type": "unsupported",
        },
        "weight_tv": {
            "default": "1.0e-2",
            "help": "Total Variation regularization parameter for iterative methods",
            "validator": float_validator,
            "type": "unsupported",
        },
        "preconditioning_filter": {
            "default": "1",
            "help": "Whether to enable 'filter preconditioning' for iterative methods",
            "validator": boolean_validator,
            "type": "unsupported",
        },
        "positivity_constraint": {
            "default": "1",
            "help": "Whether to enforce a positivity constraint in the reconstruction.",
            "validator": boolean_validator,
            "type": "unsupported",
        },
    },
    "output": {
        "location": {
            "default": "",
            "help": "Directory where the output reconstruction is stored.",
            "validator": optional_directory_location_validator,
            "type": "required",
        },
        "file_prefix": {
            "default": "",
            "help": "File prefix. Optional, by default it is inferred from the scanned dataset.",
            "validator": optional_file_name_validator,
            "type": "optional",
        },
        "file_format": {
            "default": "hdf5",
            "help": "Output file format. Available are: hdf5, tiff, jp2, edf, vol",
            "validator": output_file_format_validator,
            "type": "optional",
        },
        "overwrite_results": {
            "default": "1",
            "help": "What to do in the case where the output file exists.\nBy default, the output data is never overwritten and the process is interrupted if the file already exists.\nSet this option to 1 if you want to overwrite the output files.",
            "validator": boolean_validator,
            "type": "required",
        },
        "tiff_single_file": {
            "default": "0",
            "help": "Whether to create a single large tiff file for the reconstructed volume.",
            "validator": boolean_validator,
            "type": "advanced",
        },
        "jpeg2000_compression_ratio": {
            "default": "",
            "help": "Compression ratio for Jpeg2000 output.",
            "validator": optional_positive_integer_validator,
            "type": "advanced",
        },
        "float_clip_values": {
            "default": "",
            "help": "Lower and upper bounds to use when converting from float32 to int. Floating point values are clipped to these (min, max) values before being cast to integer.",
            "validator": optional_tuple_of_floats_validator,
            "type": "advanced",
        },
    },
    "postproc": {
        "output_histogram": {
            "default": "1",
            "help": "Whether to compute a histogram of the volume.",
            "validator": boolean_validator,
            "type": "optional",
        },
        "histogram_bins": {
            "default": "1000000",
            "help": "Number of bins for the output histogram. Default is one million. ",
            "validator": nonnegative_integer_validator,
            "type": "advanced",
        },
    },
    "resources": {
        "method": {
            "default": "local",
            "help": "Computations distribution method. It can be:\n  - local:  run the computations on the local machine\n  - slurm: run the computations through SLURM\n  - preview: reconstruct the slices/volume as quickly as possible, possibly doing some binning.",
            "validator": distribution_method_validator,
            "type": "required",
        },
        "workers": {
            "default": "1",
            "help": "Number of workers to use.",
            "validator": positive_integer_validator,
            "type": "advanced",
        },
        "gpus": {
            "default": "1",
            "help": "Number of GPUs to use. Each worker can use up to 1 GPU.",
            "validator": nonnegative_integer_validator,
            "type": "advanced",
        },
        "gpu_id": {
            "default": "",
            "help": "For method = local only. List of GPU IDs to use. This parameter overwrites 'gpus'.\nIf left blank, exactly one GPU will be used, and the best one will be picked.",
            "validator": list_of_int_validator,
            "type": "advanced",
        },
        "memory_fraction": {
            "default": "90%",
            "help": "RAM memory per computing node, either in GB or in percent of the AVAILABLE (!= total) node memory.\nIf several workers share the same node, their combined memory usage will not exceed this number.",
            "validator": resources_validator,
            "type": "advanced",
        },
        "num_threads": {
            "default": "100%",
            "help": "Number of threads to use by each worker when doing multi-threads computations. Not really relevant if GPU is used. This parameter can be given in two forms:\n  - As an integer: eg. 'num_threads = 4' means 'use up to 4 CPU threads\n  - As a fraction of integers, eg. 'num_threads = 1/2' means 'use up to half the total number of threads'",
            "validator": num_threads_validator,
            "type": "unsupported",
        },
    },
    "pipeline": {
        "save_steps": {
            "default": "",
            "help": "Save intermediate results. This is a list of comma-separated processing steps, for ex: flatfield, phase, sinogram.\nEach step generates a HDF5 file in the form name_file_prefix.hdf5 (e.g. 'sinogram_file_prefix.hdf5')",
            "validator": optional_string_validator,
            "type": "optional",
        },
        "resume_from_step": {
            "default": "",
            "help": "Resume the processing from a previously saved processing step. The corresponding file must exist in the output directory.",
            "validator": optional_string_validator,
            "type": "optional",
        },
        "steps_file": {
            "default": "",
            "help": "File where the intermediate processing steps are written. By default it is empty, and intermediate processing steps are written in the same directory as the reconstructions, with a file prefix, e.g. sinogram_mydataset.hdf5.",
            "validator": optional_output_file_path_validator,
            "type": "advanced",
        },
        "processing_margin": {
            "default": "",
            "help": "When data is processed by chunks, the pipeline reads 'n' lines of each radio. Sometimes more lines must be read, eg. for cone-beam reconstruction or phase retrieval. Normally this parameter is calculated automatically, but you can set it to a custom value.",
            "validator": optional_positive_integer_validator,
            "type": "advanced",
        },
        "verbosity": {
            "default": "2",
            "help": "Level of verbosity of the processing. 0 = terse, 3 = much information.",
            "validator": logging_validator,
            "type": "optional",
        },
    },
    # This section will be removed in the future (for now it is deprecated)
    "about": {},
}

renamed_keys = {
    "marge": {
        "section": "phase",
        "new_name": "margin",
        "since": "2020.2.0",
        "message": "Option 'marge' has been renamed 'margin' in [phase]",
    },
    "overwrite_results": {
        "section": "about",
        "new_name": "overwrite_results",
        "new_section": "output",
        "since": "2020.3.0",
        "message": "Option 'overwrite_results' was moved from section [about] to section [output]",
    },
    "nabu_config_version": {
        "section": "about",
        "new_name": "",
        "new_section": "about",
        "since": "2020.3.1",
        "message": "Option 'nabu_config_version' was removed.",
    },
    "nabu_version": {
        "section": "about",
        "new_name": "",
        "new_section": "about",
        "since": "2021.1.0",
        "message": "Option 'nabu_config' was removed.",
    },
    "verbosity": {
        "section": "about",
        "new_name": "verbosity",
        "new_section": "pipeline",
        "since": "2021.1.0",
        "message": "Option 'verbosity' was moved from section [about] to section [pipeline]",
    },
    "flatfield_enabled": {
        "section": "preproc",
        "new_name": "flatfield",
        "since": "2021.2.0",
        "message": "Option 'flatfield_enabled' has been renamed 'flatfield' in [preproc]",
    },
    "double_flatfield_enabled": {
        "section": "preproc",
        "new_name": "double_flatfield",
        "since": "2025.1.0",
        "message": "Option 'double_flatfield_enabled' has been renamed 'double_flatfield' in [preproc]",
    },
    "rotate_projections": {
        "section": "preproc",
        "new_name": "",
        "since": "2024.2.0",
        "message": "Option 'rotate_projections' removed as it was duplicate of 'tilt_correction'. Please use the latter with a scalar value.",
    },
}
