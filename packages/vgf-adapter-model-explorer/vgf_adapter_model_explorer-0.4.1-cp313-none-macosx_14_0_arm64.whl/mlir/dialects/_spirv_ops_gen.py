
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "spirv"

@_ods_cext.register_operation(_Dialect)
class AccessChainOp(_ods_ir.OpView):
  r"""
  Result Type must be an OpTypePointer. Its Type operand must be the type
  reached by walking the Base’s type hierarchy down to the last provided
  index in Indexes, and its Storage Class operand must be the same as the
  Storage Class of Base.
  
  Base must be a pointer, pointing to the base of a composite object.
  
  Indexes walk the type hierarchy to the desired depth, potentially down
  to scalar granularity. The first index in Indexes will select the top-
  level member/element/component/element of the base composite. All
  composite constituents use zero-based numbering, as described by their
  OpType… instruction. The second index will apply similarly to that
  result, and so on. Once any non-composite type is reached, there must be
  no remaining (unused) indexes.
  
   Each index in Indexes
  
  - must be a scalar integer type,
  
  - is treated as a signed count, and
  
  - must be an OpConstant when indexing into a structure.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = "spirv.Constant"() { value = 1: i32} : () -> i32
  %1 = spirv.Variable : !spirv.ptr<!spirv.struct<f32, !spirv.array<4xf32>>, Function>
  %2 = spirv.AccessChain %1[%0] : !spirv.ptr<!spirv.struct<f32, !spirv.array<4xf32>>, Function> -> !spirv.ptr<!spirv.array<4xf32>, Function>
  %3 = spirv.Load "Function" %2 ["Volatile"] : !spirv.array<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.AccessChain"

  _ODS_REGIONS = (0, True)

  def __init__(self, component_ptr, base_ptr, indices, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(base_ptr)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(component_ptr)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def base_ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def indices(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def component_ptr(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def AccessChain(component_ptr, base_ptr, indices, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AccessChainOp(component_ptr=component_ptr, base_ptr=base_ptr, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AddressOfOp(_ods_ir.OpView):
  r"""
  Variables in module scope are defined using symbol names. This op generates
  an SSA value that can be used to refer to the symbol within function scope
  for use in ops that expect an SSA value. This operation has no corresponding
  SPIR-V instruction; it's merely used for modelling purpose in the SPIR-V
  dialect. Since variables in module scope in SPIR-V dialect are of pointer
  type, this op returns a pointer type as well, and the type is the same as
  the variable referenced.
  
  #### Example:
  
  ```mlir
  %0 = spirv.mlir.addressof @global_var : !spirv.ptr<f32, Input>
  ```
  """

  OPERATION_NAME = "spirv.mlir.addressof"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, variable, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["variable"] = (variable if (
    isinstance(variable, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(variable, context=_ods_context))
    results = []
    results.append(pointer)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def variable(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["variable"]

  @variable.setter
  def variable(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["variable"] = value

  @builtins.property
  def pointer(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mlir_addressof(pointer, variable, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return AddressOfOp(pointer=pointer, variable=variable, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicAndOp(_ods_ir.OpView):
  r"""
  1) load through Pointer to get an Original Value,
  
  2) get a New Value by the bitwise AND of Original Value and Value, and
  
  3) store the New Value back through Pointer.
  
  The instruction’s result is the Original Value.
  
  Result Type must be an integer type scalar.
  
   The type of Value must be the same as Result Type.  The type of the
  value pointed to by Pointer must be the same as Result Type.
  
  Memory must be a valid memory Scope.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.AtomicAnd <Device> <None> %pointer, %value :
                     !spirv.ptr<i32, StorageBuffer>
  ```
  """

  OPERATION_NAME = "spirv.AtomicAnd"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def AtomicAnd(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtomicAndOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicCompareExchangeOp(_ods_ir.OpView):
  r"""
  1) load through Pointer to get an Original Value,
  
  2) get a New Value from Value only if Original Value equals Comparator,
  and
  
  3) store the New Value back through Pointer'only if 'Original Value
  equaled Comparator.
  
  The instruction's result is the Original Value.
  
  Result Type must be an integer type scalar.
  
  Use Equal for the memory semantics of this instruction when Value and
  Original Value compare equal.
  
  Use Unequal for the memory semantics of this instruction when Value and
  Original Value compare unequal. Unequal must not be set to Release or
  Acquire and Release. In addition, Unequal cannot be set to a stronger
  memory-order then Equal.
  
   The type of Value must be the same as Result Type.  The type of the
  value pointed to by Pointer must be the same as Result Type.  This type
  must also match the type of Comparator.
  
  Memory is a memory Scope.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```
  %0 = spirv.AtomicCompareExchange <Workgroup> <Acquire> <None>
                                  %pointer, %value, %comparator
                                  : !spirv.ptr<i32, WorkGroup>
  ```
  """

  OPERATION_NAME = "spirv.AtomicCompareExchange"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, equal_semantics, unequal_semantics, value, comparator, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    operands.append(comparator)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["equal_semantics"] = (equal_semantics if (
    isinstance(equal_semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(equal_semantics, context=_ods_context))
    attributes["unequal_semantics"] = (unequal_semantics if (
    isinstance(unequal_semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(unequal_semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def comparator(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def equal_semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["equal_semantics"]

  @equal_semantics.setter
  def equal_semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["equal_semantics"] = value

  @builtins.property
  def unequal_semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["unequal_semantics"]

  @unequal_semantics.setter
  def unequal_semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["unequal_semantics"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def AtomicCompareExchange(pointer, memory_scope, equal_semantics, unequal_semantics, value, comparator, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtomicCompareExchangeOp(pointer=pointer, memory_scope=memory_scope, equal_semantics=equal_semantics, unequal_semantics=unequal_semantics, value=value, comparator=comparator, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicCompareExchangeWeakOp(_ods_ir.OpView):
  r"""
  Has the same semantics as OpAtomicCompareExchange.
  
  Memory must be a valid memory Scope.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.AtomicCompareExchangeWeak <Workgroup> <Acquire> <None>
                                     %pointer, %value, %comparator
                                     : !spirv.ptr<i32, WorkGroup>
  ```
  """

  OPERATION_NAME = "spirv.AtomicCompareExchangeWeak"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, equal_semantics, unequal_semantics, value, comparator, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    operands.append(comparator)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["equal_semantics"] = (equal_semantics if (
    isinstance(equal_semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(equal_semantics, context=_ods_context))
    attributes["unequal_semantics"] = (unequal_semantics if (
    isinstance(unequal_semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(unequal_semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def comparator(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def equal_semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["equal_semantics"]

  @equal_semantics.setter
  def equal_semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["equal_semantics"] = value

  @builtins.property
  def unequal_semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["unequal_semantics"]

  @unequal_semantics.setter
  def unequal_semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["unequal_semantics"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def AtomicCompareExchangeWeak(pointer, memory_scope, equal_semantics, unequal_semantics, value, comparator, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtomicCompareExchangeWeakOp(pointer=pointer, memory_scope=memory_scope, equal_semantics=equal_semantics, unequal_semantics=unequal_semantics, value=value, comparator=comparator, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicExchangeOp(_ods_ir.OpView):
  r"""
  1) load through Pointer to get an Original Value,
  
  2) get a New Value from copying Value, and
  
  3) store the New Value back through Pointer.
  
  The instruction's result is the Original Value.
  
  Result Type must be a scalar of integer type or floating-point type.
  
   The type of Value must be the same as Result Type.  The type of the
  value pointed to by Pointer must be the same as Result Type.
  
  Memory is a memory Scope.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.AtomicExchange <Workgroup> <Acquire> %pointer, %value,
                          : !spirv.ptr<i32, WorkGroup>
  ```
  """

  OPERATION_NAME = "spirv.AtomicExchange"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def AtomicExchange(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtomicExchangeOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicIAddOp(_ods_ir.OpView):
  r"""
  1) load through Pointer to get an Original Value,
  
  2) get a New Value by integer addition of Original Value and Value, and
  
  3) store the New Value back through Pointer.
  
  The instruction’s result is the Original Value.
  
  Result Type must be an integer type scalar.
  
   The type of Value must be the same as Result Type.  The type of the
  value pointed to by Pointer must be the same as Result Type.
  
  Memory must be a valid memory Scope.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.AtomicIAdd <Device> <None> %pointer, %value :
                      !spirv.ptr<i32, StorageBuffer>
  ```
  """

  OPERATION_NAME = "spirv.AtomicIAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def AtomicIAdd(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtomicIAddOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicIDecrementOp(_ods_ir.OpView):
  r"""
  1) load through Pointer to get an Original Value,
  
  2) get a New Value through integer subtraction of 1 from Original Value,
  and
  
  3) store the New Value back through Pointer.
  
  The instruction’s result is the Original Value.
  
  Result Type must be an integer type scalar.  The type of the value
  pointed to by Pointer must be the same as Result Type.
  
  Memory must be a valid memory Scope.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.AtomicIDecrement <Device> <None> %pointer :
                            !spirv.ptr<i32, StorageBuffer>
  ```
  """

  OPERATION_NAME = "spirv.AtomicIDecrement"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def AtomicIDecrement(pointer, memory_scope, semantics, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtomicIDecrementOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicIIncrementOp(_ods_ir.OpView):
  r"""
  1) load through Pointer to get an Original Value,
  
  2) get a New Value through integer addition of 1 to Original Value, and
  
  3) store the New Value back through Pointer.
  
  The instruction’s result is the Original Value.
  
  Result Type must be an integer type scalar.  The type of the value
  pointed to by Pointer must be the same as Result Type.
  
  Memory must be a valid memory Scope.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.AtomicIncrement <Device> <None> %pointer :
                           !spirv.ptr<i32, StorageBuffer>
  ```
  """

  OPERATION_NAME = "spirv.AtomicIIncrement"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def AtomicIIncrement(pointer, memory_scope, semantics, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtomicIIncrementOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicISubOp(_ods_ir.OpView):
  r"""
  1) load through Pointer to get an Original Value,
  
  2) get a New Value by integer subtraction of Value from Original Value,
  and
  
  3) store the New Value back through Pointer.
  
  The instruction’s result is the Original Value.
  
  Result Type must be an integer type scalar.
  
   The type of Value must be the same as Result Type.  The type of the
  value pointed to by Pointer must be the same as Result Type.
  
  Memory must be a valid memory Scope.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.AtomicISub <Device> <None> %pointer, %value :
                      !spirv.ptr<i32, StorageBuffer>
  ```
  """

  OPERATION_NAME = "spirv.AtomicISub"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def AtomicISub(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtomicISubOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicOrOp(_ods_ir.OpView):
  r"""
  1) load through Pointer to get an Original Value,
  
  2) get a New Value by the bitwise OR of Original Value and Value, and
  
  3) store the New Value back through Pointer.
  
  The instruction’s result is the Original Value.
  
  Result Type must be an integer type scalar.
  
   The type of Value must be the same as Result Type.  The type of the
  value pointed to by Pointer must be the same as Result Type.
  
  Memory must be a valid memory Scope.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.AtomicOr <Device> <None> %pointer, %value :
                    !spirv.ptr<i32, StorageBuffer>
  ```
  """

  OPERATION_NAME = "spirv.AtomicOr"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def AtomicOr(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtomicOrOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicSMaxOp(_ods_ir.OpView):
  r"""
  1) load through Pointer to get an Original Value,
  
  2) get a New Value by finding the largest signed integer of Original
  Value and Value, and
  
  3) store the New Value back through Pointer.
  
  The instruction’s result is the Original Value.
  
  Result Type must be an integer type scalar.
  
   The type of Value must be the same as Result Type.  The type of the
  value pointed to by Pointer must be the same as Result Type.
  
  Memory must be a valid memory Scope.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.AtomicSMax <Device> <None> %pointer, %value :
                      !spirv.ptr<i32, StorageBuffer>
  ```
  """

  OPERATION_NAME = "spirv.AtomicSMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def AtomicSMax(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtomicSMaxOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicSMinOp(_ods_ir.OpView):
  r"""
  1) load through Pointer to get an Original Value,
  
  2) get a New Value by finding the smallest signed integer of Original
  Value and Value, and
  
  3) store the New Value back through Pointer.
  
  The instruction’s result is the Original Value.
  
  Result Type must be an integer type scalar.
  
   The type of Value must be the same as Result Type.  The type of the
  value pointed to by Pointer must be the same as Result Type.
  
  Memory must be a valid memory Scope.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.AtomicSMin <Device> <None> %pointer, %value :
                      !spirv.ptr<i32, StorageBuffer>
  ```
  """

  OPERATION_NAME = "spirv.AtomicSMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def AtomicSMin(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtomicSMinOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicUMaxOp(_ods_ir.OpView):
  r"""
  1) load through Pointer to get an Original Value,
  
  2) get a New Value by finding the largest unsigned integer of Original
  Value and Value, and
  
  3) store the New Value back through Pointer.
  
  The instruction’s result is the Original Value.
  
  Result Type must be an integer type scalar.
  
   The type of Value must be the same as Result Type.  The type of the
  value pointed to by Pointer must be the same as Result Type.
  
  Memory must be a valid memory Scope.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.AtomicUMax <Device> <None> %pointer, %value :
                      !spirv.ptr<i32, StorageBuffer>
  ```
  """

  OPERATION_NAME = "spirv.AtomicUMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def AtomicUMax(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtomicUMaxOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicUMinOp(_ods_ir.OpView):
  r"""
  1) load through Pointer to get an Original Value,
  
  2) get a New Value by finding the smallest unsigned integer of Original
  Value and Value, and
  
  3) store the New Value back through Pointer.
  
  The instruction’s result is the Original Value.
  
  Result Type must be an integer type scalar.
  
   The type of Value must be the same as Result Type.  The type of the
  value pointed to by Pointer must be the same as Result Type.
  
  Memory must be a valid memory Scope.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.AtomicUMin <Device> <None> %pointer, %value :
                      !spirv.ptr<i32, StorageBuffer>
  ```
  """

  OPERATION_NAME = "spirv.AtomicUMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def AtomicUMin(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtomicUMinOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AtomicXorOp(_ods_ir.OpView):
  r"""
  1) load through Pointer to get an Original Value,
  
  2) get a New Value by the bitwise exclusive OR of Original Value and
  Value, and
  
  3) store the New Value back through Pointer.
  
  The instruction’s result is the Original Value.
  
  Result Type must be an integer type scalar.
  
   The type of Value must be the same as Result Type.  The type of the
  value pointed to by Pointer must be the same as Result Type.
  
  Memory must be a valid memory Scope.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.AtomicXor <Device> <None> %pointer, %value :
                     !spirv.ptr<i32, StorageBuffer>
  ```
  """

  OPERATION_NAME = "spirv.AtomicXor"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def AtomicXor(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AtomicXorOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitCountOp(_ods_ir.OpView):
  r"""
  Results are computed per component.
  
  Result Type must be a scalar or vector of integer type.  The components
  must be wide enough to hold the unsigned Width of Base as an unsigned
  value. That is, no sign bit is needed or counted when checking for a
  wide enough result width.
  
  Base must be a scalar or vector of integer type.  It must have the same
  number of components as Result Type.
  
  The result is the unsigned value that is the number of bits in Base that
  are 1.
  
  #### Example:
  
  ```mlir
  %2 = spirv.BitCount %0: i32
  %3 = spirv.BitCount %1: vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.BitCount"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def BitCount(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitCountOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitFieldInsertOp(_ods_ir.OpView):
  r"""
  Results are computed per component.
  
  Result Type must be a scalar or vector of integer type.
  
  The type of Base and Insert must be the same as Result Type.
  
  Any result bits numbered outside [Offset, Offset + Count -  1]
  (inclusive) will come from the corresponding bits in Base.
  
  Any result bits numbered in [Offset, Offset + Count -  1] come, in
  order, from the bits numbered [0, Count - 1] of Insert.
  
  Count  must be an integer type scalar. Count is the number of bits taken
  from Insert. It will be consumed as an unsigned value. Count can be 0,
  in which case the result will be Base.
  
  Offset  must be an integer type scalar. Offset is the lowest-order bit
  of the bit field.  It will be consumed as an unsigned value.
  
  The resulting value is undefined if Count or Offset or their sum is
  greater than the number of bits in the result.
  
  #### Example:
  
  ```mlir
  %0 = spirv.BitFieldInsert %base, %insert, %offset, %count : vector<3xi32>, i8, i8
  ```
  """

  OPERATION_NAME = "spirv.BitFieldInsert"

  _ODS_REGIONS = (0, True)

  def __init__(self, base, insert, offset, count, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(base)
    operands.append(insert)
    operands.append(offset)
    operands.append(count)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def base(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def insert(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def count(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def BitFieldInsert(base, insert, offset, count, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitFieldInsertOp(base=base, insert=insert, offset=offset, count=count, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitFieldSExtractOp(_ods_ir.OpView):
  r"""
  Results are computed per component.
  
  Result Type must be a scalar or vector of integer type.
  
  The type of Base must be the same as Result Type.
  
  If Count is greater than 0: The bits of Base numbered in [Offset, Offset
  + Count -  1] (inclusive) become the bits numbered [0, Count - 1] of the
  result. The remaining bits of the result will all be the same as bit
  Offset + Count -  1 of Base.
  
  Count  must be an integer type scalar. Count is the number of bits
  extracted from Base. It will be consumed as an unsigned value. Count can
  be 0, in which case the result will be 0.
  
  Offset  must be an integer type scalar. Offset is the lowest-order bit
  of the bit field to extract from Base.  It will be consumed as an
  unsigned value.
  
  The resulting value is undefined if Count or Offset or their sum is
  greater than the number of bits in the result.
  
  #### Example:
  
  ```mlir
  %0 = spirv.BitFieldSExtract %base, %offset, %count : vector<3xi32>, i8, i8
  ```
  """

  OPERATION_NAME = "spirv.BitFieldSExtract"

  _ODS_REGIONS = (0, True)

  def __init__(self, base, offset, count, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(base)
    operands.append(offset)
    operands.append(count)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def base(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def count(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def BitFieldSExtract(base, offset, count, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitFieldSExtractOp(base=base, offset=offset, count=count, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitFieldUExtractOp(_ods_ir.OpView):
  r"""
  The semantics are the same as with OpBitFieldSExtract with the exception
  that there is no sign extension. The remaining bits of the result will
  all be 0.
  
  #### Example:
  
  ```mlir
  %0 = spirv.BitFieldUExtract %base, %offset, %count : vector<3xi32>, i8, i8
  ```
  """

  OPERATION_NAME = "spirv.BitFieldUExtract"

  _ODS_REGIONS = (0, True)

  def __init__(self, base, offset, count, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(base)
    operands.append(offset)
    operands.append(count)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def base(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def count(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def BitFieldUExtract(base, offset, count, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitFieldUExtractOp(base=base, offset=offset, count=count, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitReverseOp(_ods_ir.OpView):
  r"""
  Results are computed per component.
  
  Result Type must be a scalar or vector of integer type.
  
  The type of Base must be the same as Result Type.
  
  The bit-number n of the result will be taken from bit-number Width - 1 -
  n of Base, where Width is the OpTypeInt operand of the Result Type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.BitReverse %0 : i32
  %3 = spirv.BitReverse %1 : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.BitReverse"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def BitReverse(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitReverseOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitcastOp(_ods_ir.OpView):
  r"""
  Result Type must be an OpTypePointer, or a scalar or vector of
  numerical-type.
  
  Operand must have a type of OpTypePointer, or a scalar or vector of
  numerical-type. It must be a different type than Result Type.
  
  If either Result Type or Operand is a pointer, the other must be a
  pointer (diverges from the SPIR-V spec).
  
  If Result Type has a different number of components than Operand, the
  total number of bits in Result Type must equal the total number of bits
  in Operand. Let L be the type, either Result Type or Operand's type,
  that has the larger number of components. Let S be the other type, with
  the smaller number of components. The number of components in L must be
  an integer multiple of the number of components in S. The first
  component (that is, the only or lowest-numbered component) of S maps to
  the first components of L, and so on,  up to the last component of S
  mapping to the last components of L. Within this mapping, any single
  component of S (mapping to multiple components of L) maps its lower-
  ordered bits to the lower-numbered components of L.
  
  #### Example:
  
  ```mlir
  %1 = spirv.Bitcast %0 : f32 to i32
  %1 = spirv.Bitcast %0 : vector<2xf32> to i64
  %1 = spirv.Bitcast %0 : !spirv.ptr<f32, Function> to !spirv.ptr<i32, Function>
  ```
  """

  OPERATION_NAME = "spirv.Bitcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Bitcast(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitcastOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitwiseAndOp(_ods_ir.OpView):
  r"""
  Results are computed per component, and within each component, per bit.
  
  Result Type must be a scalar or vector of integer type.  The type of
  Operand 1 and Operand 2  must be a scalar or vector of integer type.
  They must have the same number of components as Result Type. They must
  have the same component width as Result Type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.BitwiseAnd %0, %1 : i32
  %2 = spirv.BitwiseAnd %0, %1 : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.BitwiseAnd"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def BitwiseAnd(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitwiseAndOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitwiseOrOp(_ods_ir.OpView):
  r"""
   Results are computed per component, and within each component, per bit.
  
  Result Type must be a scalar or vector of integer type.  The type of
  Operand 1 and Operand 2  must be a scalar or vector of integer type.
  They must have the same number of components as Result Type. They must
  have the same component width as Result Type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.BitwiseOr %0, %1 : i32
  %2 = spirv.BitwiseOr %0, %1 : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.BitwiseOr"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def BitwiseOr(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitwiseOrOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BitwiseXorOp(_ods_ir.OpView):
  r"""
  Results are computed per component, and within each component, per bit.
  
  Result Type must be a scalar or vector of integer type.  The type of
  Operand 1 and Operand 2  must be a scalar or vector of integer type.
  They must have the same number of components as Result Type. They must
  have the same component width as Result Type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.BitwiseXor %0, %1 : i32
  %2 = spirv.BitwiseXor %0, %1 : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.BitwiseXor"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def BitwiseXor(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BitwiseXorOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class BranchConditionalOp(_ods_ir.OpView):
  r"""
  Condition must be a Boolean type scalar.
  
  Branch weights are unsigned 32-bit integer literals. There must be
  either no Branch Weights or exactly two branch weights. If present, the
  first is the weight for branching to True Label, and the second is the
  weight for branching to False Label. The implied probability that a
  branch is taken is its weight divided by the sum of the two Branch
  weights. At least one weight must be non-zero. A weight of zero does not
  imply a branch is dead or permit its removal; branch weights are only
  hints. The two weights must not overflow a 32-bit unsigned integer when
  added together.
  
  This instruction must be the last instruction in a block.
  
  <!-- End of AutoGen section -->
  
  ```
  branch-conditional-op ::= `spirv.BranchConditional` ssa-use
                            (`[` integer-literal, integer-literal `]`)?
                            `,` successor `,` successor
  successor ::= bb-id branch-use-list?
  branch-use-list ::= `(` ssa-use-list `:` type-list-no-parens `)`
  ```
  
  #### Example:
  
  ```mlir
  spirv.BranchConditional %condition, ^true_branch, ^false_branch
  spirv.BranchConditional %condition, ^true_branch(%0: i32), ^false_branch(%1: i32)
  ```
  """

  OPERATION_NAME = "spirv.BranchConditional"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, condition, trueTargetOperands, falseTargetOperands, trueTarget, falseTarget, *, branch_weights=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.append(_get_op_results_or_values(trueTargetOperands))
    operands.append(_get_op_results_or_values(falseTargetOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    if branch_weights is not None: attributes["branch_weights"] = (branch_weights if (
        isinstance(branch_weights, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I32ArrayAttr')(branch_weights, context=_ods_context))
    results = []
    _ods_successors = []
    _ods_successors.append(trueTarget)
    _ods_successors.append(falseTarget)
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def trueTargetOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def falseTargetOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def branch_weights(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "branch_weights" not in self.operation.attributes:
      return None
    return self.operation.attributes["branch_weights"]

  @branch_weights.setter
  def branch_weights(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["branch_weights"] = value
    elif "branch_weights" in self.operation.attributes:
      del self.operation.attributes["branch_weights"]

  @branch_weights.deleter
  def branch_weights(self):
    del self.operation.attributes["branch_weights"]

def BranchConditional(condition, true_target_operands, false_target_operands, true_target, false_target, *, branch_weights=None, loc=None, ip=None) -> BranchConditionalOp:
  return BranchConditionalOp(condition=condition, trueTargetOperands=true_target_operands, falseTargetOperands=false_target_operands, trueTarget=true_target, falseTarget=false_target, branch_weights=branch_weights, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BranchOp(_ods_ir.OpView):
  r"""
  This instruction must be the last instruction in a block.
  
  #### Example:
  
  ```mlir
  spirv.Branch ^target
  spirv.Branch ^target(%0, %1: i32, f32)
  ```
  """

  OPERATION_NAME = "spirv.Branch"

  _ODS_REGIONS = (0, True)

  def __init__(self, targetOperands, target, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(targetOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = []
    _ods_successors.append(target)
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def targetOperands(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def Branch(target_operands, target, *, loc=None, ip=None) -> BranchOp:
  return BranchOp(targetOperands=target_operands, target=target, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CLAcosOp(_ods_ir.OpView):
  r"""
  Result is an angle in radians.
  
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.acos %0 : f32
  %3 = spirv.CL.acos %1 : vector<4xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.acos"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_acos(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLAcosOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLAcoshOp(_ods_ir.OpView):
  r"""
  Result is an angle in radians.
  
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.acosh %0 : f32
  %3 = spirv.CL.acosh %1 : vector<4xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.acosh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_acosh(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLAcoshOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLAsinOp(_ods_ir.OpView):
  r"""
  Result is an angle in radians.
  
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.asin %0 : f32
  %3 = spirv.CL.asin %1 : vector<4xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.asin"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_asin(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLAsinOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLAsinhOp(_ods_ir.OpView):
  r"""
  Result is an angle in radians.
  
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.asinh %0 : f32
  %3 = spirv.CL.asinh %1 : vector<4xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.asinh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_asinh(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLAsinhOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLAtan2Op(_ods_ir.OpView):
  r"""
  Result is an angle in radians.
  
  Result Type, y and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.atan2 %0, %1 : f32
  %3 = spirv.CL.atan2 %0, %1 : vector<4xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.atan2"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_atan2(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLAtan2Op(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLAtanOp(_ods_ir.OpView):
  r"""
  Result is an angle in radians.
  
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.atan %0 : f32
  %3 = spirv.CL.atan %1 : vector<4xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.atan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_atan(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLAtanOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLAtanhOp(_ods_ir.OpView):
  r"""
  Result is an angle in radians.
  
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.atanh %0 : f32
  %3 = spirv.CL.atanh %1 : vector<4xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.atanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_atanh(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLAtanhOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLCeilOp(_ods_ir.OpView):
  r"""
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.ceil %0 : f32
  %3 = spirv.CL.ceil %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.ceil"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_ceil(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLCeilOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLCosOp(_ods_ir.OpView):
  r"""
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.cos %0 : f32
  %3 = spirv.CL.cos %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_cos(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLCosOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLCoshOp(_ods_ir.OpView):
  r"""
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.cosh %0 : f32
  %3 = spirv.CL.cosh %1 : vector<4xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.cosh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_cosh(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLCoshOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLErfOp(_ods_ir.OpView):
  r"""
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.erf %0 : f32
  %3 = spirv.CL.erf %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.erf"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_erf(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLErfOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLExpOp(_ods_ir.OpView):
  r"""
  Compute the base-e exponential of x. (i.e. ex)
  
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand,
  must be of the same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.exp %0 : f32
  %3 = spirv.CL.exp %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_exp(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLExpOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLFAbsOp(_ods_ir.OpView):
  r"""
  Compute the absolute value of x.
  
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand,
  must be of the same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.fabs %0 : f32
  %3 = spirv.CL.fabs %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.fabs"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_fabs(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLFAbsOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLFMaxOp(_ods_ir.OpView):
  r"""
  Returns y if x < y, otherwise it returns x. If one argument is a NaN,
  Fmax returns the other argument. If both arguments are NaNs, Fmax returns a NaN.
  
  Result Type, x and y must be floating-point or vector(2,3,4,8,16)
  of floating-point values.
  
  All of the operands, including the Result Type operand,
  must be of the same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.fmax %0, %1 : f32
  %3 = spirv.CL.fmax %0, %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.fmax"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_fmax(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLFMaxOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLFMinOp(_ods_ir.OpView):
  r"""
  Returns y if y < x, otherwise it returns x. If one argument is a NaN, Fmin returns the other argument.
  If both arguments are NaNs, Fmin returns a NaN.
  
  Result Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values.
  
  All of the operands, including the Result Type operand, must be of the same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.fmin %0, %1 : f32
  %3 = spirv.CL.fmin %0, %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.fmin"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_fmin(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLFMinOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLFloorOp(_ods_ir.OpView):
  r"""
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.floor %0 : f32
  %3 = spirv.CL.floor %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_floor(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLFloorOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLFmaOp(_ods_ir.OpView):
  r"""
  Result Type, a, b and c must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %0 = spirv.CL.fma %a, %b, %c : f32
  %1 = spirv.CL.fma %a, %b, %c : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.fma"

  _ODS_REGIONS = (0, True)

  def __init__(self, x, y, z, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(y)
    operands.append(z)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def z(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_fma(x, y, z, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLFmaOp(x=x, y=y, z=z, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLLogOp(_ods_ir.OpView):
  r"""
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.log %0 : f32
  %3 = spirv.CL.log %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.log"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_log(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLLogOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLMixOp(_ods_ir.OpView):
  r"""
  Result Type, x, y and a must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  Note: This instruction can be implemented using contractions such as mad
  or fma.
  
  #### Example:
  
  ```mlir
  %0 = spirv.CL.mix %a, %b, %c : f32
  %1 = spirv.CL.mix %a, %b, %c : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.mix"

  _ODS_REGIONS = (0, True)

  def __init__(self, x, y, z, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(y)
    operands.append(z)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def z(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_mix(x, y, z, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLMixOp(x=x, y=y, z=z, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLPowOp(_ods_ir.OpView):
  r"""
  Result Type, x and y must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.pow %0, %1 : f32
  %3 = spirv.CL.pow %0, %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_pow(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLPowOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLPrintfOp(_ods_ir.OpView):
  r"""
  printf returns 0 if it was executed successfully and -1 otherwise.
  
  Result Type must be i32.
  
  Format must be a pointer(constant) to i8. If there are insufficient 
  arguments for the format, the behavior is undefined. If the format 
  is exhausted while arguments remain, the excess arguments are evaluated
  (as always) but are otherwise ignored. The printf instruction returns 
  when the end of the format string is encountered.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.CL.printf %fmt %1, %2  : !spirv.ptr<i8, UniformConstant>, i32, i32 -> i32
  ```
  """

  OPERATION_NAME = "spirv.CL.printf"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, format, arguments, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(format)
    operands.extend(_get_op_results_or_values(arguments))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def format(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def arguments(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_printf(result, format, arguments, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLPrintfOp(result=result, format=format, arguments=arguments, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLRintOp(_ods_ir.OpView):
  r"""
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %0 = spirv.CL.rint %0 : f32
  %1 = spirv.CL.rint %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.rint"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_rint(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLRintOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLRoundOp(_ods_ir.OpView):
  r"""
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.round %0 : f32
  %3 = spirv.CL.round %0 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.round"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_round(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLRoundOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLRsqrtOp(_ods_ir.OpView):
  r"""
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.rsqrt %0 : f32
  %3 = spirv.CL.rsqrt %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.rsqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_rsqrt(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLRsqrtOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLSAbsOp(_ods_ir.OpView):
  r"""
  Returns |x|, where x is treated as signed integer.
  
  Result Type and x must be integer or vector(2,3,4,8,16) of
  integer values.
  
  All of the operands, including the Result Type operand,
  must be of the same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.s_abs %0 : i32
  %3 = spirv.CL.s_abs %1 : vector<3xi16>
  ```
  """

  OPERATION_NAME = "spirv.CL.s_abs"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_s_abs(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLSAbsOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLSMaxOp(_ods_ir.OpView):
  r"""
  Returns y if x < y, otherwise it returns x, where x and y are treated as signed integers.
  
  Result Type,x and y must be integer or vector(2,3,4,8,16) of integer values.
  
  All of the operands, including the Result Type operand, must be of the same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.s_max %0, %1 : i32
  %3 = spirv.CL.s_max %0, %1 : vector<3xi16>
  ```
  """

  OPERATION_NAME = "spirv.CL.s_max"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_s_max(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLSMaxOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLSMinOp(_ods_ir.OpView):
  r"""
  Returns y if x < y, otherwise it returns x, where x and y are treated as signed integers.
  
  Result Type,x and y must be integer or vector(2,3,4,8,16) of integer values.
  
  All of the operands, including the Result Type operand, must be of the same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.s_min %0, %1 : i32
  %3 = spirv.CL.s_min %0, %1 : vector<3xi16>
  ```
  """

  OPERATION_NAME = "spirv.CL.s_min"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_s_min(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLSMinOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLSinOp(_ods_ir.OpView):
  r"""
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.sin %0 : f32
  %3 = spirv.CL.sin %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_sin(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLSinOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLSinhOp(_ods_ir.OpView):
  r"""
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.sinh %0 : f32
  %3 = spirv.CL.sinh %1 : vector<4xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.sinh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_sinh(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLSinhOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLSqrtOp(_ods_ir.OpView):
  r"""
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.sqrt %0 : f32
  %3 = spirv.CL.sqrt %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_sqrt(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLSqrtOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLTanOp(_ods_ir.OpView):
  r"""
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.tan %0 : f32
  %3 = spirv.CL.tan %1 : vector<4xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.tan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_tan(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLTanOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLTanhOp(_ods_ir.OpView):
  r"""
  Result Type and x must be floating-point or vector(2,3,4,8,16) of
  floating-point values.
  
  All of the operands, including the Result Type operand, must be of the
  same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.tanh %0 : f32
  %3 = spirv.CL.tanh %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.CL.tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_tanh(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLTanhOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLUMaxOp(_ods_ir.OpView):
  r"""
  Returns y if x < y, otherwise it returns x, where x and y are treated as unsigned integers.
  
  Result Type,x and y must be integer or vector(2,3,4,8,16) of integer values.
  
  All of the operands, including the Result Type operand, must be of the same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.u_max %0, %1 : i32
  %3 = spirv.CL.u_max %0, %1 : vector<3xi16>
  ```
  """

  OPERATION_NAME = "spirv.CL.u_max"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_u_max(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLUMaxOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CLUMinOp(_ods_ir.OpView):
  r"""
  Returns y if x < y, otherwise it returns x, where x and y are treated as unsigned integers.
  
  Result Type,x and y must be integer or vector(2,3,4,8,16) of integer values.
  
  All of the operands, including the Result Type operand, must be of the same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.CL.u_min %0, %1 : i32
  %3 = spirv.CL.u_min %0, %1 : vector<3xi16>
  ```
  """

  OPERATION_NAME = "spirv.CL.u_min"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CL_u_min(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CLUMinOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CompositeConstructOp(_ods_ir.OpView):
  r"""
  Result Type must be a composite type, whose top-level
  members/elements/components/columns have the same type as the types of
  the operands, with one exception. The exception is that for constructing
  a vector, the operands may also be vectors with the same component type
  as the Result Type component type. When constructing a vector, the total
  number of components in all the operands must equal the number of
  components in Result Type.
  
  Constituents will become members of a structure, or elements of an
  array, or components of a vector, or columns of a matrix. There must be
  exactly one Constituent for each top-level
  member/element/component/column of the result, with one exception. The
  exception is that for constructing a vector, a contiguous subset of the
  scalars consumed can be represented by a vector operand instead. The
  Constituents must appear in the order needed by the definition of the
  type of the result. When constructing a vector, there must be at least
  two Constituent operands.
  
  #### Example:
  
  ```mlir
  %a = spirv.CompositeConstruct %1, %2, %3 : vector<3xf32>
  %b = spirv.CompositeConstruct %a, %1 : (vector<3xf32>, f32) -> vector<4xf32>
  
  %c = spirv.CompositeConstruct %1 :
    (f32) -> !spirv.coopmatrix<4x4xf32, Subgroup, MatrixA>
  
  %d = spirv.CompositeConstruct %a, %4, %5 :
    (vector<3xf32>, !spirv.array<4xf32>, !spirv.struct<(f32)>) ->
      !spirv.struct<(vector<3xf32>, !spirv.array<4xf32>, !spirv.struct<(f32)>)>
  ```
  """

  OPERATION_NAME = "spirv.CompositeConstruct"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, constituents, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(constituents))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def constituents(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CompositeConstruct(result, constituents, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CompositeConstructOp(result=result, constituents=constituents, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CompositeExtractOp(_ods_ir.OpView):
  r"""
  Result Type must be the type of object selected by the last provided
  index.  The instruction result is the extracted object.
  
  Composite is the composite to extract from.
  
  Indexes walk the type hierarchy, potentially down to component
  granularity, to select the part to extract. All indexes must be in
  bounds.  All composite constituents use zero-based numbering, as
  described by their OpType… instruction.
  
  <!-- End of AutoGen section -->
  
  ```
  composite-extract-op ::= ssa-id `=` `spirv.CompositeExtract` ssa-use
                           `[` integer-literal (',' integer-literal)* `]`
                           `:` composite-type
  ```
  
  #### Example:
  
  ```mlir
  %0 = spirv.Variable : !spirv.ptr<!spirv.array<4x!spirv.array<4xf32>>, Function>
  %1 = spirv.Load "Function" %0 ["Volatile"] : !spirv.array<4x!spirv.array<4xf32>>
  %2 = spirv.CompositeExtract %1[1 : i32] : !spirv.array<4x!spirv.array<4xf32>>
  ```
  
  """

  OPERATION_NAME = "spirv.CompositeExtract"

  _ODS_REGIONS = (0, True)

  def __init__(self, component, composite, indices, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(composite)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["indices"] = (indices if (
    isinstance(indices, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I32ArrayAttr')(indices, context=_ods_context))
    results = []
    results.append(component)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def composite(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def indices(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["indices"]

  @indices.setter
  def indices(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["indices"] = value

  @builtins.property
  def component(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CompositeExtract(component, composite, indices, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CompositeExtractOp(component=component, composite=composite, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CompositeInsertOp(_ods_ir.OpView):
  r"""
  Result Type must be the same type as Composite.
  
  Object is the object to use as the modified part.
  
  Composite is the composite to copy all but the modified part from.
  
  Indexes walk the type hierarchy of Composite to the desired depth,
  potentially down to component granularity, to select the part to modify.
  All indexes must be in bounds. All composite constituents use zero-based
  numbering, as described by their OpType… instruction. The type of the
  part selected to modify must match the type of Object.
  
  <!-- End of AutoGen section -->
  
  ```
  composite-insert-op ::= ssa-id `=` `spirv.CompositeInsert` ssa-use, ssa-use
                          `[` integer-literal (',' integer-literal)* `]`
                          `:` object-type `into` composite-type
  ```
  
  #### Example:
  
  ```mlir
  %0 = spirv.CompositeInsert %object, %composite[1 : i32] : f32 into !spirv.array<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.CompositeInsert"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, object, composite, indices, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(object)
    operands.append(composite)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["indices"] = (indices if (
    isinstance(indices, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I32ArrayAttr')(indices, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def object(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def composite(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["indices"]

  @indices.setter
  def indices(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["indices"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def CompositeInsert(result, object, composite, indices, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return CompositeInsertOp(result=result, object=object, composite=composite, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConstantOp(_ods_ir.OpView):
  r"""
  This op declares a SPIR-V normal constant. SPIR-V has multiple constant
  instructions covering different constant types:
  
  * `OpConstantTrue` and `OpConstantFalse` for boolean constants
  * `OpConstant` for scalar constants
  * `OpConstantComposite` for composite constants
  * `OpConstantNull` for null constants
  * ...
  
  Having such a plethora of constant instructions renders IR transformations
  more tedious. Therefore, we use a single `spirv.Constant` op to represent
  them all. Note that conversion between those SPIR-V constant instructions
  and this op is purely mechanical; so it can be scoped to the binary
  (de)serialization process.
  
  <!-- End of AutoGen section -->
  
  ```
  spirv.Constant-op ::= ssa-id `=` `spirv.Constant` attribute-value
                      (`:` spirv-type)?
  ```
  
  #### Example:
  
  ```mlir
  %0 = spirv.Constant true
  %1 = spirv.Constant dense<[2.0, 3.0]> : vector<2xf32>
  %2 = spirv.Constant [dense<3.0> : vector<2xf32>] : !spirv.array<1xvector<2xf32>>
  ```
  
  TODO: support constant structs
  """

  OPERATION_NAME = "spirv.Constant"

  _ODS_REGIONS = (0, True)

  def __init__(self, constant, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(value, context=_ods_context))
    results = []
    results.append(constant)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def constant(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Constant(constant, value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConstantOp(constant=constant, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ControlBarrierOp(_ods_ir.OpView):
  r"""
  All invocations of this module within Execution scope must reach this
  point of execution before any invocation will proceed beyond it.
  
  When Execution is Workgroup or larger, behavior is undefined if this
  instruction is used in control flow that is non-uniform within
  Execution. When Execution is Subgroup or Invocation, the behavior of
  this instruction in non-uniform control flow is defined by the client
  API.
  
  If Semantics is not None, this instruction also serves as an
  OpMemoryBarrier instruction, and must also perform and adhere to the
  description and semantics of an OpMemoryBarrier instruction with the
  same Memory and Semantics operands.  This allows atomically specifying
  both a control barrier and a memory barrier (that is, without needing
  two instructions). If Semantics is None, Memory is ignored.
  
  Before version 1.3, it is only valid to use this instruction with
  TessellationControl, GLCompute, or Kernel execution models. There is no
  such restriction starting with version 1.3.
  
  When used with the TessellationControl execution model, it also
  implicitly synchronizes the Output Storage Class:  Writes to Output
  variables performed by any invocation executed prior to a
  OpControlBarrier will be visible to any other invocation after return
  from that OpControlBarrier.
  
  #### Example:
  
  ```mlir
  spirv.ControlBarrier <Workgroup>, <Device>, <Acquire|UniformMemory>
  ```
  """

  OPERATION_NAME = "spirv.ControlBarrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["memory_semantics"] = (memory_semantics if (
    isinstance(memory_semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(memory_semantics, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def memory_semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_semantics"]

  @memory_semantics.setter
  def memory_semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_semantics"] = value

def ControlBarrier(execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None) -> ControlBarrierOp:
  return ControlBarrierOp(execution_scope=execution_scope, memory_scope=memory_scope, memory_semantics=memory_semantics, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ConvertFToSOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type.
  
  Float Value must be a scalar or vector of floating-point type.  It must
  have the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %1 = spirv.ConvertFToS %0 : f32 to i32
  %3 = spirv.ConvertFToS %2 : vector<3xf32> to vector<3xi32>
  ```
  """

  OPERATION_NAME = "spirv.ConvertFToS"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ConvertFToS(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConvertFToSOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvertFToUOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type, whose Signedness
  operand is 0.
  
  Float Value must be a scalar or vector of floating-point type.  It must
  have the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %1 = spirv.ConvertFToU %0 : f32 to i32
  %3 = spirv.ConvertFToU %2 : vector<3xf32> to vector<3xi32>
  ```
  """

  OPERATION_NAME = "spirv.ConvertFToU"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ConvertFToU(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConvertFToUOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvertPtrToUOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar of integer type, whose Signedness operand is 0.
  
  Pointer must be a physical pointer type. If the bit width of Pointer is
  smaller than that of Result Type, the conversion zero extends Pointer.
  If the bit width of Pointer is larger than that of Result Type,
  the conversion truncates Pointer.
  
  For same bit width Pointer and Result Type, this is the same as OpBitcast.
  
  #### Example:
  
  ```mlir
  %1 = spirv.ConvertPtrToU %0 : !spirv.ptr<i32, Generic> to i32
  ```
  """

  OPERATION_NAME = "spirv.ConvertPtrToU"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, pointer, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ConvertPtrToU(result, pointer, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConvertPtrToUOp(result=result, pointer=pointer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvertSToFOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of floating-point type.
  
  Signed Value must be a scalar or vector of integer type.  It must have
  the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %1 = spirv.ConvertSToF %0 : i32 to f32
  %3 = spirv.ConvertSToF %2 : vector<3xi32> to vector<3xf32>
  ```
  """

  OPERATION_NAME = "spirv.ConvertSToF"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ConvertSToF(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConvertSToFOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvertUToFOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of floating-point type.
  
  Unsigned Value must be a scalar or vector of integer type.  It must have
  the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %1 = spirv.ConvertUToF %0 : i32 to f32
  %3 = spirv.ConvertUToF %2 : vector<3xi32> to vector<3xf32>
  ```
  """

  OPERATION_NAME = "spirv.ConvertUToF"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ConvertUToF(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConvertUToFOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ConvertUToPtrOp(_ods_ir.OpView):
  r"""
  Result Type must be a physical pointer type.
  
  Integer Value must be a scalar of integer type, whose Signedness
  operand is 0. If the bit width of Integer Value is smaller
  than that of Result Type, the conversion zero extends Integer Value.
  If the bit width of Integer Value is larger than that of Result Type,
  the conversion truncates Integer Value.
  
  For same-width Integer Value and Result Type, this is the same as OpBitcast.
  
  #### Example:
  
  ```mlir
  %1 = spirv.ConvertUToPtr %0 :  i32 to !spirv.ptr<i32, Generic>
  ```
  """

  OPERATION_NAME = "spirv.ConvertUToPtr"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ConvertUToPtr(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ConvertUToPtrOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CopyMemoryOp(_ods_ir.OpView):
  r"""
  If present, any Memory Operands must begin with a memory operand
  literal. If not present, it is the same as specifying the memory operand
  None. Before version 1.4, at most one memory operands mask can be
  provided. Starting with version 1.4 two masks can be provided, as
  described in Memory Operands. If no masks or only one mask is present,
  it applies to both Source and Target. If two masks are present, the
  first applies to Target and cannot include MakePointerVisible, and the
  second applies to Source and cannot include MakePointerAvailable.
  
  <!-- End of AutoGen section -->
  
  ```
  copy-memory-op ::= `spirv.CopyMemory ` storage-class ssa-use
                     storage-class ssa-use
                     (`[` memory-access `]` (`, [` memory-access `]`)?)?
                     ` : ` spirv-element-type
  ```
  
  #### Example:
  
  ```mlir
  %0 = spirv.Variable : !spirv.ptr<f32, Function>
  %1 = spirv.Variable : !spirv.ptr<f32, Function>
  spirv.CopyMemory "Function" %0, "Function" %1 : f32
  ```
  """

  OPERATION_NAME = "spirv.CopyMemory"

  _ODS_REGIONS = (0, True)

  def __init__(self, target, source, *, memory_access=None, alignment=None, source_memory_access=None, source_alignment=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(target)
    operands.append(source)
    _ods_context = _ods_get_default_loc_context(loc)
    if memory_access is not None: attributes["memory_access"] = (memory_access if (
        isinstance(memory_access, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_MemoryAccessAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_MemoryAccessAttr')(memory_access, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(alignment, context=_ods_context))
    if source_memory_access is not None: attributes["source_memory_access"] = (source_memory_access if (
        isinstance(source_memory_access, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_MemoryAccessAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_MemoryAccessAttr')(source_memory_access, context=_ods_context))
    if source_alignment is not None: attributes["source_alignment"] = (source_alignment if (
        isinstance(source_alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(source_alignment, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def target(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def source(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def memory_access(self) -> _Optional[_ods_ir.Attribute]:
    if "memory_access" not in self.operation.attributes:
      return None
    return self.operation.attributes["memory_access"]

  @memory_access.setter
  def memory_access(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["memory_access"] = value
    elif "memory_access" in self.operation.attributes:
      del self.operation.attributes["memory_access"]

  @memory_access.deleter
  def memory_access(self):
    del self.operation.attributes["memory_access"]

  @builtins.property
  def alignment(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def source_memory_access(self) -> _Optional[_ods_ir.Attribute]:
    if "source_memory_access" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_memory_access"]

  @source_memory_access.setter
  def source_memory_access(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["source_memory_access"] = value
    elif "source_memory_access" in self.operation.attributes:
      del self.operation.attributes["source_memory_access"]

  @source_memory_access.deleter
  def source_memory_access(self):
    del self.operation.attributes["source_memory_access"]

  @builtins.property
  def source_alignment(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "source_alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["source_alignment"]

  @source_alignment.setter
  def source_alignment(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["source_alignment"] = value
    elif "source_alignment" in self.operation.attributes:
      del self.operation.attributes["source_alignment"]

  @source_alignment.deleter
  def source_alignment(self):
    del self.operation.attributes["source_alignment"]

def CopyMemory(target, source, *, memory_access=None, alignment=None, source_memory_access=None, source_alignment=None, loc=None, ip=None) -> CopyMemoryOp:
  return CopyMemoryOp(target=target, source=source, memory_access=memory_access, alignment=alignment, source_memory_access=source_memory_access, source_alignment=source_alignment, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DotOp(_ods_ir.OpView):
  r"""
  Result Type must be a floating point scalar.
  
  Vector 1 and Vector 2 must be vectors of the same type, and their component
  type must be Result Type.
  
  #### Example:
  
  ```mlir
  %0 = spirv.Dot %v1, %v2 : vector<4xf32> -> f32
  ```
  """

  OPERATION_NAME = "spirv.Dot"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, vector1, vector2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vector1)
    operands.append(vector2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def vector2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Dot(result, vector1, vector2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DotOp(result=result, vector1=vector1, vector2=vector2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EXTAtomicFAddOp(_ods_ir.OpView):
  r"""
  <!-- End of AutoGen section -->
  
  Perform the following steps atomically with respect to any other atomic
  accesses within Scope to the same location:
  
  1) load through Pointer to get an Original Value,
  
  2) get a New Value by float addition of Original Value and Value, and
  
  3) store the New Value back through Pointer.
  
  The instruction's result is the Original Value.
  
  Result Type must be a floating-point type scalar.
  
  The type of Value must be the same as Result Type. The type of the value
  pointed to by Pointer must be the same as Result Type.
  
  Memory must be a valid memory Scope.
  
  #### Example:
  
  ```mlir
  %0 = spirv.EXT.AtomicFAdd <Device> <None> %pointer, %value :
                         !spirv.ptr<f32, StorageBuffer>
  ```
  """

  OPERATION_NAME = "spirv.EXT.AtomicFAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["semantics"] = (semantics if (
    isinstance(semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(semantics, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["semantics"]

  @semantics.setter
  def semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["semantics"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def EXT_AtomicFAdd(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return EXTAtomicFAddOp(pointer=pointer, memory_scope=memory_scope, semantics=semantics, value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EXTConstantCompositeReplicateOp(_ods_ir.OpView):
  r"""
  Represents a splat composite constant i.e., all elements of composite constant
  have the same value.
  
  #### Example:
  
  ```mlir
  %0 = spirv.EXT.ConstantCompositeReplicate [1 : i32] : vector<2xi32>
  %1 = spirv.EXT.ConstantCompositeReplicate [1 : i32] : !spirv.array<2 x vector<2xi32>>
  %2 = spirv.EXT.ConstantCompositeReplicate [dense<[1, 2]> : vector<2xi32>] : !spirv.array<2 x vector<2xi32>>
  ```
  """

  OPERATION_NAME = "spirv.EXT.ConstantCompositeReplicate"

  _ODS_REGIONS = (0, True)

  def __init__(self, replicated_constant, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["value"] = (value if (
    isinstance(value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(value, context=_ods_context))
    results = []
    results.append(replicated_constant)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["value"] = value

  @builtins.property
  def replicated_constant(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def EXT_ConstantCompositeReplicate(replicated_constant, value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return EXTConstantCompositeReplicateOp(replicated_constant=replicated_constant, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EXTEmitMeshTasksOp(_ods_ir.OpView):
  r"""
  Defines the grid size of subsequent mesh shader workgroups to generate upon
  completion of the task shader workgroup.
  
  Group Count X Y Z must each be a 32-bit unsigned integer value. They
  configure the number of local workgroups in each respective dimensions for the
  launch of child mesh tasks. See Vulkan API specification for more detail.
  
  Payload is an optional pointer to the payload structure to pass to the
  generated mesh shader invocations. Payload must be the result of an OpVariable
  with a storage class of TaskPayloadWorkgroupEXT.
  
  The arguments are taken from the first invocation in each workgroup.
  Behaviour is undefined if any invocation terminates without executing this
  instruction, or if any invocation executes this instruction in non-uniform
  control flow.
  
  This instruction also serves as an OpControlBarrier instruction, and also
  performs and adheres to the description and semantics of an OpControlBarrier
  instruction with the Execution and Memory operands set to Workgroup and the
  Semantics operand set to a combination of WorkgroupMemory and AcquireRelease.
  
  Ceases all further processing: Only instructions executed before
  OpEmitMeshTasksEXT have observable side effects.
  
  This instruction must be the last instruction in a block.
  
  This instruction is only valid in the TaskEXT Execution Model.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  spirv.EmitMeshTasksEXT %x, %y, %z : i32, i32, i32
  spirv.EmitMeshTasksEXT %x, %x, %z, %payload : i32, i32, i32, !spirv.ptr<i32, TaskPayloadWorkgroupEXT>
  ```
  """

  OPERATION_NAME = "spirv.EXT.EmitMeshTasks"

  _ODS_REGIONS = (0, True)

  def __init__(self, group_count_x, group_count_y, group_count_z, *, payload=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(group_count_x)
    operands.append(group_count_y)
    operands.append(group_count_z)
    if payload is not None: operands.append(payload)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def group_count_x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def group_count_y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def group_count_z(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def payload(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 4 else self.operation.operands[3]

def EXT_EmitMeshTasks(group_count_x, group_count_y, group_count_z, *, payload=None, loc=None, ip=None) -> EXTEmitMeshTasksOp:
  return EXTEmitMeshTasksOp(group_count_x=group_count_x, group_count_y=group_count_y, group_count_z=group_count_z, payload=payload, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class EXTSetMeshOutputsOp(_ods_ir.OpView):
  r"""
  Vertex Count must be a 32-bit unsigned integer value. It defines the array size
  of per-vertex outputs.
  
  Primitive Count must a 32-bit unsigned integer value. It defines the array size
  of per-primitive outputs.
  
  The arguments are taken from the first invocation in each workgroup. Behavior
  is undefined if any invocation executes this instruction more than once or
  under non-uniform control flow. Behavior is undefined if there is any control
  flow path to an output write that is not preceded by this instruction.
  
  This instruction is only valid in the MeshEXT Execution Model.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  spirv.SetMeshOutputsEXT %vcount, %pcount : i32, i32
  ```
  """

  OPERATION_NAME = "spirv.EXT.SetMeshOutputs"

  _ODS_REGIONS = (0, True)

  def __init__(self, vertex_count, primitive_count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vertex_count)
    operands.append(primitive_count)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vertex_count(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def primitive_count(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def EXT_SetMeshOutputs(vertex_count, primitive_count, *, loc=None, ip=None) -> EXTSetMeshOutputsOp:
  return EXTSetMeshOutputsOp(vertex_count=vertex_count, primitive_count=primitive_count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class EXTSpecConstantCompositeReplicateOp(_ods_ir.OpView):
  r"""
  Represents a splat spec composite constant i.e., all elements of spec composite
  constant have the same value. The splat value must come from a symbol reference
  of spec constant instruction.
  
  #### Example:
  
  ```mlir
  spirv.SpecConstant @sc_i32_1 = 1 : i32
  spirv.EXT.SpecConstantCompositeReplicate @scc_splat_array_of_i32 (@sc_i32_1) : !spirv.array<3 x i32>
  spirv.EXT.SpecConstantCompositeReplicate @scc_splat_struct_of_i32 (@sc_i32_1) : !spirv.struct<(i32, i32, i32)>
  ```
  """

  OPERATION_NAME = "spirv.EXT.SpecConstantCompositeReplicate"

  _ODS_REGIONS = (0, True)

  def __init__(self, type_, sym_name, constituent, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(sym_name, context=_ods_context))
    attributes["constituent"] = (constituent if (
    isinstance(constituent, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(constituent, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def constituent(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["constituent"]

  @constituent.setter
  def constituent(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["constituent"] = value

def EXT_SpecConstantCompositeReplicate(type_, sym_name, constituent, *, loc=None, ip=None) -> EXTSpecConstantCompositeReplicateOp:
  return EXTSpecConstantCompositeReplicateOp(type_=type_, sym_name=sym_name, constituent=constituent, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class EmitVertexOp(_ods_ir.OpView):
  r"""
  This instruction must only be used when only one stream is present.
  
  #### Example:
  
  ```mlir
  spirv.EmitVertex
  ```
  """

  OPERATION_NAME = "spirv.EmitVertex"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def EmitVertex(*, loc=None, ip=None) -> EmitVertexOp:
  return EmitVertexOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class EndPrimitiveOp(_ods_ir.OpView):
  r"""
  This instruction must only be used when only one stream is present.
  
  #### Example:
  
  ```mlir
  spirv.EndPrimitive
  ```
  """

  OPERATION_NAME = "spirv.EndPrimitive"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def EndPrimitive(*, loc=None, ip=None) -> EndPrimitiveOp:
  return EndPrimitiveOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class EntryPointOp(_ods_ir.OpView):
  r"""
  Execution Model is the execution model for the entry point and its
  static call tree. See Execution Model.
  
  Entry Point must be the Result <id> of an OpFunction instruction.
  
  Name is a name string for the entry point. A module cannot have two
  OpEntryPoint instructions with the same Execution Model and the same
  Name string.
  
  Interface is a list of symbol references to `spirv.GlobalVariable`
  operations. These declare the set of global variables from a
  module that form the interface of this entry point. The set of
  Interface symbols must be equal to or a superset of the
  `spirv.GlobalVariable`s referenced by the entry point’s static call
  tree, within the interface’s storage classes.  Before version 1.4,
  the interface’s storage classes are limited to the Input and
  Output storage classes. Starting with version 1.4, the interface’s
  storage classes are all storage classes used in declaring all
  global variables referenced by the entry point’s call tree.
  
  <!-- End of AutoGen section -->
  
  ```
  execution-model ::= "Vertex" | "TesellationControl" |
                      <and other SPIR-V execution models...>
  
  entry-point-op ::= ssa-id `=` `spirv.EntryPoint` execution-model
                     symbol-reference (`, ` symbol-reference)*
  ```
  
  #### Example:
  
  ```mlir
  spirv.EntryPoint "GLCompute" @foo
  spirv.EntryPoint "Kernel" @foo, @var1, @var2
  
  ```
  """

  OPERATION_NAME = "spirv.EntryPoint"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_model, fn, interface, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_model"] = (execution_model if (
    isinstance(execution_model, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ExecutionModelAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ExecutionModelAttr')(execution_model, context=_ods_context))
    attributes["fn"] = (fn if (
    isinstance(fn, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(fn, context=_ods_context))
    attributes["interface"] = (interface if (
    isinstance(interface, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(interface, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def execution_model(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_model"]

  @execution_model.setter
  def execution_model(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_model"] = value

  @builtins.property
  def fn(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["fn"]

  @fn.setter
  def fn(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fn"] = value

  @builtins.property
  def interface(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["interface"]

  @interface.setter
  def interface(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["interface"] = value

def EntryPoint(execution_model, fn, interface, *, loc=None, ip=None) -> EntryPointOp:
  return EntryPointOp(execution_model=execution_model, fn=fn, interface=interface, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExecutionModeOp(_ods_ir.OpView):
  r"""
  Entry Point must be the Entry Point <id> operand of an OpEntryPoint
  instruction.
  
  Mode is the execution mode. See Execution Mode.
  
  This instruction is only valid when the Mode operand is an execution
  mode that takes no Extra Operands, or takes Extra Operands that are not
  <id> operands.
  
  <!-- End of AutoGen section -->
  
  ```
  execution-mode ::= "Invocations" | "SpacingEqual" |
                     <and other SPIR-V execution modes...>
  
  execution-mode-op ::= `spirv.ExecutionMode ` ssa-use execution-mode
                        (integer-literal (`, ` integer-literal)* )?
  ```
  
  #### Example:
  
  ```mlir
  spirv.ExecutionMode @foo "ContractionOff"
  spirv.ExecutionMode @bar "LocalSizeHint", 3, 4, 5
  ```
  """

  OPERATION_NAME = "spirv.ExecutionMode"

  _ODS_REGIONS = (0, True)

  def __init__(self, fn, execution_mode, values, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fn"] = (fn if (
    isinstance(fn, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(fn, context=_ods_context))
    attributes["execution_mode"] = (execution_mode if (
    isinstance(execution_mode, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ExecutionModeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ExecutionModeAttr')(execution_mode, context=_ods_context))
    attributes["values"] = (values if (
    isinstance(values, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I32ArrayAttr')(values, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fn(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["fn"]

  @fn.setter
  def fn(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fn"] = value

  @builtins.property
  def execution_mode(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_mode"]

  @execution_mode.setter
  def execution_mode(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_mode"] = value

  @builtins.property
  def values(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["values"]

  @values.setter
  def values(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["values"] = value

def ExecutionMode(fn, execution_mode, values, *, loc=None, ip=None) -> ExecutionModeOp:
  return ExecutionModeOp(fn=fn, execution_mode=execution_mode, values=values, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FAddOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of floating-point type.
  
  The types of Operand 1 and Operand 2 both must be the same as Result
  Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FAdd %0, %1 : f32
  %5 = spirv.FAdd %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FAdd(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FAddOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FConvertOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of floating-point type.
  
  Float Value must be a scalar or vector of floating-point type.  It must
  have the same number of components as Result Type.  The component width
  cannot equal the component width in Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %1 = spirv.FConvertOp %0 : f32 to f64
  %3 = spirv.FConvertOp %2 : vector<3xf32> to vector<3xf64>
  ```
  """

  OPERATION_NAME = "spirv.FConvert"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FConvert(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return FConvertOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FDivOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of floating-point type.
  
  The types of Operand 1 and Operand 2 both must be the same as Result
  Type.
  
  Results are computed per component.  The resulting value is undefined
  if Operand 2 is 0.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FDiv %0, %1 : f32
  %5 = spirv.FDiv %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FDiv"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FDiv(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FDivOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FModOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of floating-point type.
  
  The types of Operand 1 and Operand 2 both must be the same as Result
  Type.
  
  Results are computed per component.  The resulting value is undefined
  if Operand 2 is 0.  Otherwise, the result is the remainder r of Operand
  1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the
  sign of Operand 2.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FMod %0, %1 : f32
  %5 = spirv.FMod %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FMod"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FMod(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FModOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FMulOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of floating-point type.
  
  The types of Operand 1 and Operand 2 both must be the same as Result
  Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FMul %0, %1 : f32
  %5 = spirv.FMul %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FMul(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FMulOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FNegateOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of floating-point type.
  
  The type of Operand must be the same as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %1 = spirv.FNegate %0 : f32
  %3 = spirv.FNegate %2 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FNegate"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FNegate(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FNegateOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FOrdEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  floating-point type.  They must have the same type, and they must have
  the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FOrdEqual %0, %1 : f32
  %5 = spirv.FOrdEqual %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FOrdEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FOrdEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FOrdEqualOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FOrdGreaterThanEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  floating-point type.  They must have the same type, and they must have
  the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FOrdGreaterThanEqual %0, %1 : f32
  %5 = spirv.FOrdGreaterThanEqual %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FOrdGreaterThanEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FOrdGreaterThanEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FOrdGreaterThanEqualOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FOrdGreaterThanOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  floating-point type.  They must have the same type, and they must have
  the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FOrdGreaterThan %0, %1 : f32
  %5 = spirv.FOrdGreaterThan %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FOrdGreaterThan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FOrdGreaterThan(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FOrdGreaterThanOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FOrdLessThanEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  floating-point type.  They must have the same type, and they must have
  the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FOrdLessThanEqual %0, %1 : f32
  %5 = spirv.FOrdLessThanEqual %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FOrdLessThanEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FOrdLessThanEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FOrdLessThanEqualOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FOrdLessThanOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  floating-point type.  They must have the same type, and they must have
  the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FOrdLessThan %0, %1 : f32
  %5 = spirv.FOrdLessThan %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FOrdLessThan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FOrdLessThan(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FOrdLessThanOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FOrdNotEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  floating-point type.  They must have the same type, and they must have
  the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FOrdNotEqual %0, %1 : f32
  %5 = spirv.FOrdNotEqual %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FOrdNotEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FOrdNotEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FOrdNotEqualOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FRemOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of floating-point type.
  
  The types of Operand 1 and Operand 2 both must be the same as Result
  Type.
  
  Results are computed per component.  The resulting value is undefined
  if Operand 2 is 0.  Otherwise, the result is the remainder r of Operand
  1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the
  sign of Operand 1.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FRemOp %0, %1 : f32
  %5 = spirv.FRemOp %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FRem"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FRem(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FRemOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FSubOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of floating-point type.
  
  The types of Operand 1 and Operand 2 both must be the same as Result
  Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FRemOp %0, %1 : f32
  %5 = spirv.FRemOp %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FSub"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FSub(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FSubOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FUnordEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  floating-point type.  They must have the same type, and they must have
  the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FUnordEqual %0, %1 : f32
  %5 = spirv.FUnordEqual %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FUnordEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FUnordEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FUnordEqualOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FUnordGreaterThanEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  floating-point type.  They must have the same type, and they must have
  the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FUnordGreaterThanEqual %0, %1 : f32
  %5 = spirv.FUnordGreaterThanEqual %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FUnordGreaterThanEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FUnordGreaterThanEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FUnordGreaterThanEqualOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FUnordGreaterThanOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  floating-point type.  They must have the same type, and they must have
  the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FUnordGreaterThan %0, %1 : f32
  %5 = spirv.FUnordGreaterThan %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FUnordGreaterThan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FUnordGreaterThan(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FUnordGreaterThanOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FUnordLessThanEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  floating-point type.  They must have the same type, and they must have
  the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FUnordLessThanEqual %0, %1 : f32
  %5 = spirv.FUnordLessThanEqual %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FUnordLessThanEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FUnordLessThanEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FUnordLessThanEqualOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FUnordLessThanOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  floating-point type.  They must have the same type, and they must have
  the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FUnordLessThan %0, %1 : f32
  %5 = spirv.FUnordLessThan %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FUnordLessThan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FUnordLessThan(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FUnordLessThanOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FUnordNotEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  floating-point type.  They must have the same type, and they must have
  the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.FUnordNotEqual %0, %1 : f32
  %5 = spirv.FUnordNotEqual %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.FUnordNotEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def FUnordNotEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FUnordNotEqualOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FuncOp(_ods_ir.OpView):
  r"""
  This op declares or defines a SPIR-V function using one region, which
  contains one or more blocks.
  
  Different from the SPIR-V binary format, this op is not allowed to
  implicitly capture global values, and all external references must use
  function arguments or symbol references. This op itself defines a symbol
  that is unique in the enclosing module op.
  
  This op itself takes no operands and generates no results. Its region
  can take zero or more arguments and return zero or one values.
  
  From `SPV_KHR_physical_storage_buffer`:
  If a parameter of function is
  - a pointer (or contains a pointer) in the PhysicalStorageBuffer storage
    class, the function parameter must be decorated with exactly one of
    `Aliased` or `Restrict`.
  - a pointer (or contains a pointer) and the type it points to is a pointer
    in the PhysicalStorageBuffer storage class, the function parameter must
    be decorated with exactly one of `AliasedPointer` or `RestrictPointer`.
  
  <!-- End of AutoGen section -->
  
  ```
  spv-function-control ::= "None" | "Inline" | "DontInline" | ...
  spv-function-op ::= `spirv.func` function-signature
                       spv-function-control region
  ```
  
  #### Example:
  
  ```mlir
  spirv.func @foo() -> () "None" { ... }
  spirv.func @bar() -> () "Inline|Pure" { ... }
  
  spirv.func @aliased_pointer(%arg0: !spirv.ptr<i32, PhysicalStorageBuffer>,
      { spirv.decoration = #spirv.decoration<Aliased> }) -> () "None" { ... }
  
  spirv.func @restrict_pointer(%arg0: !spirv.ptr<i32, PhysicalStorageBuffer>,
      { spirv.decoration = #spirv.decoration<Restrict> }) -> () "None" { ... }
  
  spirv.func @aliased_pointee(%arg0: !spirv.ptr<!spirv.ptr<i32,
      PhysicalStorageBuffer>, Generic> { spirv.decoration =
      #spirv.decoration<AliasedPointer> }) -> () "None" { ... }
  
  spirv.func @restrict_pointee(%arg0: !spirv.ptr<!spirv.ptr<i32,
      PhysicalStorageBuffer>, Generic> { spirv.decoration =
      #spirv.decoration<RestrictPointer> }) -> () "None" { ... }
  ```
  """

  OPERATION_NAME = "spirv.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, function_type, sym_name, function_control, *, arg_attrs=None, res_attrs=None, linkage_attributes=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_2073')) else
      _ods_ir.AttrBuilder.get('anonymous_2073')(function_type, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(sym_name, context=_ods_context))
    attributes["function_control"] = (function_control if (
    isinstance(function_control, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_FunctionControlAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_FunctionControlAttr')(function_control, context=_ods_context))
    if linkage_attributes is not None: attributes["linkage_attributes"] = (linkage_attributes if (
        isinstance(linkage_attributes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_LinkageAttributesAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_LinkageAttributesAttr')(linkage_attributes, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_control(self) -> _ods_ir.Attribute:
    return self.operation.attributes["function_control"]

  @function_control.setter
  def function_control(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_control"] = value

  @builtins.property
  def linkage_attributes(self) -> _Optional[_ods_ir.Attribute]:
    if "linkage_attributes" not in self.operation.attributes:
      return None
    return self.operation.attributes["linkage_attributes"]

  @linkage_attributes.setter
  def linkage_attributes(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["linkage_attributes"] = value
    elif "linkage_attributes" in self.operation.attributes:
      del self.operation.attributes["linkage_attributes"]

  @linkage_attributes.deleter
  def linkage_attributes(self):
    del self.operation.attributes["linkage_attributes"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def func(function_type, sym_name, function_control, *, arg_attrs=None, res_attrs=None, linkage_attributes=None, loc=None, ip=None) -> FuncOp:
  return FuncOp(function_type=function_type, sym_name=sym_name, function_control=function_control, arg_attrs=arg_attrs, res_attrs=res_attrs, linkage_attributes=linkage_attributes, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FunctionCallOp(_ods_ir.OpView):
  r"""
  Result Type is the type of the return value of the function. It must be
  the same as the Return Type operand of the Function Type operand of the
  Function operand.
  
  Function is an OpFunction instruction.  This could be a forward
  reference.
  
  Argument N is the object to copy to parameter N of Function.
  
  Note: A forward call is possible because there is no missing type
  information: Result Type must match the Return Type of the function, and
  the calling argument types must match the formal parameter types.
  
  #### Example:
  
  ```mlir
  spirv.FunctionCall @f_void(%arg0) : (i32) ->  ()
  %0 = spirv.FunctionCall @f_iadd(%arg0, %arg1) : (i32, i32) -> i32
  ```
  """

  OPERATION_NAME = "spirv.FunctionCall"

  _ODS_REGIONS = (0, True)

  def __init__(self, return_value, callee, arguments, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(arguments))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    if return_value is not None: results.append(return_value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def arguments(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def callee(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def return_value(self) -> _Optional[_ods_ir.OpResult]:
    return None if len(self.operation.results) < 1 else self.operation.results[0]

def FunctionCall(return_value, callee, arguments, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, FunctionCallOp]:
  op = FunctionCallOp(return_value=return_value, callee=callee, arguments=arguments, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class GLAcosOp(_ods_ir.OpView):
  r"""
  The standard trigonometric arc cosine of x radians.
  
  Result is an angle, in radians, whose cosine is x. The range of result
  values is [0, π]. Result is undefined if abs x > 1.
  
  The operand x must be a scalar or vector whose component type is 16-bit or
  32-bit floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Acos %0 : f32
  %3 = spirv.GL.Acos %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Acos"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Acos(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLAcosOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLAcoshOp(_ods_ir.OpView):
  r"""
  Arc hyperbolic cosine; result is the non-negative inverse of cosh. The resulting
  value is NaN if x < 1.
  
  The operand x must be a scalar or vector whose component type is 16-bit or
  32-bit floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Acosh %0 : f32
  %3 = spirv.GL.Acosh %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Acosh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Acosh(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLAcoshOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLAsinOp(_ods_ir.OpView):
  r"""
  The standard trigonometric arc sine of x radians.
  
  Result is an angle, in radians, whose sine is x. The range of result values
  is [-π / 2, π / 2]. Result is undefined if abs x > 1.
  
  The operand x must be a scalar or vector whose component type is 16-bit or
  32-bit floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Asin %0 : f32
  %3 = spirv.GL.Asin %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Asin"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Asin(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLAsinOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLAsinhOp(_ods_ir.OpView):
  r"""
  Arc hyperbolic sine; result is the inverse of sinh.
  
  The operand x must be a scalar or vector whose component type is 16-bit or
  32-bit floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Asinh %0 : f32
  %3 = spirv.GL.Asinh %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Asinh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Asinh(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLAsinhOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLAtanOp(_ods_ir.OpView):
  r"""
  The standard trigonometric arc tangent of x radians.
  
  Result is an angle, in radians, whose tangent is y_over_x. The range of
  result values is [-π / 2, π / 2].
  
  The operand x must be a scalar or vector whose component type is 16-bit or
  32-bit floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Atan %0 : f32
  %3 = spirv.GL.Atan %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Atan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Atan(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLAtanOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLAtanhOp(_ods_ir.OpView):
  r"""
  Arc hyperbolic tangent; result is the inverse of tanh. The resulting value
  is NaN if abs x ≥ 1.
  
  The operand x must be a scalar or vector whose component type is 16-bit or
  32-bit floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Atanh %0 : f32
  %3 = spirv.GL.Atanh %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Atanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Atanh(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLAtanhOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLCeilOp(_ods_ir.OpView):
  r"""
  Result is the value equal to the nearest whole number that is greater than
  or equal to x.
  
  The operand x must be a scalar or vector whose component type is
  floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Ceil %0 : f32
  %3 = spirv.GL.Ceil %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Ceil"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Ceil(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLCeilOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLCosOp(_ods_ir.OpView):
  r"""
  The standard trigonometric cosine of x radians.
  
  The operand x must be a scalar or vector whose component type is 16-bit or
  32-bit floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Cos %0 : f32
  %3 = spirv.GL.Cos %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Cos(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLCosOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLCoshOp(_ods_ir.OpView):
  r"""
  Hyperbolic cosine of x radians.
  
  The operand x must be a scalar or vector whose component type is 16-bit or
  32-bit floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Cosh %0 : f32
  %3 = spirv.GL.Cosh %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Cosh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Cosh(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLCoshOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLCrossOp(_ods_ir.OpView):
  r"""
  Result is the cross product of x and y, i.e., the resulting components are, in order:
  
  x[1] * y[2] - y[1] * x[2]
  
  x[2] * y[0] - y[2] * x[0]
  
  x[0] * y[1] - y[0] * x[1]
  
  All the operands must be vectors of 3 components of a floating-point type.
  
  Result Type and the type of all operands must be the same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Cross %0, %1 : vector<3xf32>
  %3 = spirv.GL.Cross %0, %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Cross"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Cross(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLCrossOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLDistanceOp(_ods_ir.OpView):
  r"""
  Result is the distance between p0 and p1, i.e., length(p0 - p1).
  
  The operands must all be a scalar or vector whose component type is floating-point.
  
  Result Type must be a scalar of the same type as the component type of the operands.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Distance %0, %1 : vector<3xf32>, vector<3xf32> -> f32
  ```
  """

  OPERATION_NAME = "spirv.GL.Distance"

  _ODS_REGIONS = (0, True)

  def __init__(self, p0, p1, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(p0)
    operands.append(p1)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def p0(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def p1(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Distance(p0, p1, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLDistanceOp(p0=p0, p1=p1, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLExp2Op(_ods_ir.OpView):
  r"""
  Result is 2 raised to the x power; 2**x.
  
  ```
  exp2(Inf) = Inf.
  exp2(-Inf) = +0.
  ```
  
  The operand x must be a scalar or vector whose component type is 16-bit or
  32-bit floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Exp2 %0 : f32
  %3 = spirv.GL.Exp2 %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Exp2"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Exp2(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLExp2Op(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLExpOp(_ods_ir.OpView):
  r"""
  Result is the natural exponentiation of x; e^x.
  
  The operand x must be a scalar or vector whose component type is
  16-bit or 32-bit floating-point.
  
  Result Type and the type of x must be the same type. Results are
  computed per component.";
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Exp %0 : f32
  %3 = spirv.GL.Exp %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Exp(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLExpOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFAbsOp(_ods_ir.OpView):
  r"""
  Result is x if x >= 0; otherwise result is -x.
  
  The operand x must be a scalar or vector whose component type is
  floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.FAbs %0 : f32
  %3 = spirv.GL.FAbs %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.FAbs"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_FAbs(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLFAbsOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFClampOp(_ods_ir.OpView):
  r"""
  Result is min(max(x, minVal), maxVal). The resulting value is undefined if
  minVal > maxVal. The semantics used by min() and max() are those of FMin and
  FMax.
  
  The operands must all be a scalar or vector whose component type is
  floating-point.
  
  Result Type and the type of all operands must be the same type. Results are
  computed per component.
  
  <!-- End of AutoGen section -->
  ```
  fclamp-op ::= ssa-id `=` `spirv.GL.FClamp` ssa-use, ssa-use, ssa-use `:`
             float-scalar-vector-type
  ```
  #### Example:
  
  ```mlir
  %2 = spirv.GL.FClamp %x, %min, %max : f32
  %3 = spirv.GL.FClamp %x, %min, %max : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.FClamp"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, x, y, z, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(y)
    operands.append(z)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def z(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_FClamp(result, x, y, z, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLFClampOp(result=result, x=x, y=y, z=z, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFMaxOp(_ods_ir.OpView):
  r"""
  Result is y if x < y; otherwise result is x. Which operand is the
  result is undefined if one of the operands is a NaN.
  
  The operands must all be a scalar or vector whose component type
  is floating-point.
  
  Result Type and the type of all operands must be the same
  type. Results are computed per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.FMax %0, %1 : f32
  %3 = spirv.GL.FMax %0, %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.FMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_FMax(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLFMaxOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFMinOp(_ods_ir.OpView):
  r"""
  Result is y if y < x; otherwise result is x. Which operand is the result is
  undefined if one of the operands is a NaN.
  
  The operands must all be a scalar or vector whose component type is
  floating-point.
  
  Result Type and the type of all operands must be the same type. Results are
  computed per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.FMin %0, %1 : f32
  %3 = spirv.GL.FMin %0, %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.FMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_FMin(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLFMinOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFMixOp(_ods_ir.OpView):
  r"""
  Result is the linear blend of x and y, i.e., x * (1 - a) + y * a.
  
  The operands must all be a scalar or vector whose component type is floating-point.
  
  Result Type and the type of all operands must be the same type. Results are computed per component.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.GL.FMix %x : f32, %y : f32, %a : f32 -> f32
  %0 = spirv.GL.FMix %x : vector<4xf32>, %y : vector<4xf32>, %a : vector<4xf32> -> vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.GL.FMix"

  _ODS_REGIONS = (0, True)

  def __init__(self, x, y, a, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(y)
    operands.append(a)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_FMix(x, y, a, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLFMixOp(x=x, y=y, a=a, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFSignOp(_ods_ir.OpView):
  r"""
  Result is 1.0 if x > 0, 0.0 if x = 0, or -1.0 if x < 0.
  
  The operand x must be a scalar or vector whose component type is
  floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.FSign %0 : f32
  %3 = spirv.GL.FSign %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.FSign"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_FSign(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLFSignOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFindILsbOp(_ods_ir.OpView):
  r"""
  Results in the bit number of the least-significant 1-bit in the binary
  representation of Value. If Value is 0, the result is -1.
  
  Result Type and the type of Value must both be integer scalar or
  integer vector types. Result Type and operand types must have the
  same number of components with the same component width. Results are
  computed per component.
  """

  OPERATION_NAME = "spirv.GL.FindILsb"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_FindILsb(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLFindILsbOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFindSMsbOp(_ods_ir.OpView):
  r"""
  For positive numbers, the result will be the bit number of the most significant
  1-bit. For negative numbers, the result will be the bit number of the most
  significant 0-bit. For a Value of 0 or -1, the result is -1.
  
  Result Type and the type of Value must both be integer scalar or
  integer vector types. Result Type and operand types must have the
  same number of components with the same component width. Results are
  computed per component.
  
  This instruction is currently limited to 32-bit width components.
  """

  OPERATION_NAME = "spirv.GL.FindSMsb"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_FindSMsb(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLFindSMsbOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFindUMsbOp(_ods_ir.OpView):
  r"""
  Results in the bit number of the most-significant 1-bit in the binary
  representation of Value. If Value is 0, the result is -1.
  
  Result Type and the type of Value must both be integer scalar or
  integer vector types. Result Type and operand types must have the
  same number of components with the same component width. Results are
  computed per component.
  
  This instruction is currently limited to 32-bit width components.
  """

  OPERATION_NAME = "spirv.GL.FindUMsb"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_FindUMsb(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLFindUMsbOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFloorOp(_ods_ir.OpView):
  r"""
  Result is the value equal to the nearest whole number that is less than or
  equal to x.
  
  The operand x must be a scalar or vector whose component type is
  floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Floor %0 : f32
  %3 = spirv.GL.Floor %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Floor(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLFloorOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFmaOp(_ods_ir.OpView):
  r"""
  In uses where this operation is decorated with NoContraction:
  
  - fma is considered a single operation, whereas the expression a * b + c
    is considered two operations.
  - The precision of fma can differ from the precision of the expression
    a * b + c.
  - fma will be computed with the same precision as any other fma decorated
    with NoContraction, giving invariant results for the same input values
    of a, b, and c.
  
  Otherwise, in the absence of a NoContraction decoration, there are no
  special constraints on the number of operations or difference in precision
  between fma and the expression a * b +c.
  
  The operands must all be a scalar or vector whose component type is
  floating-point.
  
  Result Type and the type of all operands must be the same type. Results
  are computed per component.
  
  <!-- End of AutoGen section -->
  ```
  fma-op ::= ssa-id `=` `spirv.GL.Fma` ssa-use, ssa-use, ssa-use `:`
             float-scalar-vector-type
  ```
  #### Example:
  
  ```mlir
  %0 = spirv.GL.Fma %a, %b, %c : f32
  %1 = spirv.GL.Fma %a, %b, %c : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Fma"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, x, y, z, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(y)
    operands.append(z)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def z(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Fma(result, x, y, z, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLFmaOp(result=result, x=x, y=y, z=z, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFractOp(_ods_ir.OpView):
  r"""
  Result is:
  
  ```
  fract(x) = x - floor(x)
  fract(±0) = +0
  fract(±Inf) = NaN
  ```
  
  The operand x must be a scalar or vector whose component type is floating-point.
  
  Result Type and the type of x must be the same type. Results are computed per component.
  
  #### Example:
  
  ```mlir
  %result = spirv.GL.Sqrt %x : f32
  %result = spirv.GL.Sqrt %x : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Fract"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Fract(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLFractOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLFrexpStructOp(_ods_ir.OpView):
  r"""
  Result is a structure containing x split into a floating-point significand
  in the range (-1.0, 0.5] or [0.5, 1.0) and an integral exponent of 2, such that:
  
  x = significand * 2^exponent
  
  If x is a zero, the exponent is 0.0. If x is an infinity or a NaN, the
  exponent is undefined. If x is 0.0, the significand is 0.0. If x is -0.0,
  the significand is -0.0
  
  Result Type must be an OpTypeStruct with two members. Member 0 must have
  the same type as the type of x. Member 0 holds the significand. Member 1
  must be a scalar or vector with integer component type, with 32-bit
  component width. Member 1 holds the exponent. These two members and x must
  have the same number of components.
  
  The operand x must be a scalar or vector whose component type is
  floating-point.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.FrexpStruct %0 : f32 -> !spirv.struct<f32, i32>
  %3 = spirv.GL.FrexpStruct %0 : vector<3xf32> -> !spirv.struct<vector<3xf32>, vector<3xi32>>
  ```
  """

  OPERATION_NAME = "spirv.GL.FrexpStruct"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_FrexpStruct(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLFrexpStructOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLInverseSqrtOp(_ods_ir.OpView):
  r"""
  Result is the reciprocal of sqrt x. Result is undefined if x <= 0.
  
  The operand x must be a scalar or vector whose component type is
  floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.InverseSqrt %0 : f32
  %3 = spirv.GL.InverseSqrt %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.InverseSqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_InverseSqrt(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLInverseSqrtOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLLdexpOp(_ods_ir.OpView):
  r"""
  Builds a floating-point number from x and the corresponding
  integral exponent of two in exp:
  
  significand * 2^exponent
  
  If this product is too large to be represented in the floating-point
  type, the resulting value is undefined. If exp is greater than +128
  (single precision) or +1024 (double precision), the resulting value is
  undefined. If exp is less than -126 (single precision) or -1022 (double precision),
  the result may be flushed to zero. Additionally, splitting the value
  into a significand and exponent using frexp and then reconstructing a
  floating-point value using ldexp should yield the original input for
  zero and all finite non-denormalized values.
  
  The operand x must be a scalar or vector whose component type is floating-point.
  
  The exp operand must be a scalar or vector with integer component type.
  The number of components in x and exp must be the same.
  
  Result Type must be the same type as the type of x. Results are computed per
  component.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %y = spirv.GL.Ldexp %x : f32, %exp : i32 -> f32
  %y = spirv.GL.Ldexp %x : vector<3xf32>, %exp : vector<3xi32> -> vector<3xf32>
  ```
  """

  OPERATION_NAME = "spirv.GL.Ldexp"

  _ODS_REGIONS = (0, True)

  def __init__(self, x, exp, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(exp)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def exp(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def y(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Ldexp(x, exp, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLLdexpOp(x=x, exp=exp, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLLengthOp(_ods_ir.OpView):
  r"""
  Result is the length of vector x, i.e., sqrt(x[0]**2 + x[1]**2 + ...).
  
  The operand x must be a scalar or vector whose component type is floating-point.
  
  Result Type must be a scalar of the same type as the component type of x.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Length %0 : vector<3xf32> -> f32
  %3 = spirv.GL.Length %1 : f32 -> f32
  ```
  """

  OPERATION_NAME = "spirv.GL.Length"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Length(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLLengthOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLLog2Op(_ods_ir.OpView):
  r"""
  Result is the base-2 logarithm of x, i.e., the value y which satisfies the
  equation x = 2**y. The resulting value is NaN if x < 0. Moreover:
  
  ```
  log(Inf) = Inf
  log(1.0) = +0
  log(±0) = -Inf
  ```
  
  The operand x must be a scalar or vector whose component type is 16-bit or
  32-bit floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Log2 %0 : f32
  %3 = spirv.GL.Log2 %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Log2"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Log2(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLLog2Op(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLLogOp(_ods_ir.OpView):
  r"""
  Result is the natural logarithm of x, i.e., the value y which satisfies the
  equation x = ey. Result is undefined if x <= 0.
  
  The operand x must be a scalar or vector whose component type is 16-bit or
  32-bit floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Log %0 : f32
  %3 = spirv.GL.Log %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Log"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Log(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLLogOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLNormalizeOp(_ods_ir.OpView):
  r"""
  Result is the vector in the same direction as x but with a length of 1.
  
  The operand x must be a scalar or vector whose component type is floating-point.
  
  Result Type and the type of x must be the same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Normalize %0 : vector<3xf32>
  %3 = spirv.GL.Normalize %1 : vector<4xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Normalize"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Normalize(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLNormalizeOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLPackHalf2x16Op(_ods_ir.OpView):
  r"""
  Result is the unsigned integer obtained by converting the components of a
  two-component floating-point vector to the 16-bit OpTypeFloat, and then packing
  these two 16-bit integers into a 32-bit unsigned integer. The first vector
  component specifies the 16 least-significant bits of the result; the second
  component specifies the 16 most-significant bits.
  
  The RelaxedPrecision Decoration only affects the conversion step of the instruction.
  
  The v operand must be a vector of 2 components whose type is a 32-bit floating-point.
  
  Result Type must be a 32-bit integer type.
  
  #### Example:
  
  ```mlir
  %1 = spirv.GL.PackHalf2x16 %0 : vector<2xf32> -> i32
  ```
  """

  OPERATION_NAME = "spirv.GL.PackHalf2x16"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_PackHalf2x16(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLPackHalf2x16Op(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLPowOp(_ods_ir.OpView):
  r"""
  Result is x raised to the y power; x^y.
  
  Result is undefined if x = 0 and y ≤ 0.
  
  The operand x and y must be a scalar or vector whose component type is
  16-bit or 32-bit floating-point.
  
  Result Type and the type of all operands must be the same type. Results are
  computed per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Pow %0, %1 : f32
  %3 = spirv.GL.Pow %0, %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Pow(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLPowOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLReflectOp(_ods_ir.OpView):
  r"""
  For the incident vector I and surface orientation N, the result is the reflection direction:
  
  I - 2 * dot(N, I) * N
  
  N must already be normalized in order to achieve the desired result.
  
  The operands must all be a scalar or vector whose component type is floating-point.
  
  Result Type and the type of all operands must be the same type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Reflect %0, %1 : f32
  %3 = spirv.GL.Reflect %0, %1 : vector<3xf32>
  ```
  """

  OPERATION_NAME = "spirv.GL.Reflect"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Reflect(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLReflectOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLRoundEvenOp(_ods_ir.OpView):
  r"""
  Result is the value equal to the nearest whole number to x. A fractional
  part of 0.5 will round toward the nearest even whole number. (Both 3.5 and
  4.5 for x will be 4.0.)
  
  The operand x must be a scalar or vector whose component type is
  floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.RoundEven %0 : f32
  %3 = spirv.GL.RoundEven %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.RoundEven"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_RoundEven(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLRoundEvenOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLRoundOp(_ods_ir.OpView):
  r"""
  Result is the value equal to the nearest whole number to x. The fraction
  0.5 will round in a direction chosen by the implementation, presumably
  the direction that is fastest. This includes the possibility that
  Round x is the same value as RoundEven x for all values of x.
  
  The operand x must be a scalar or vector whose component type is
  floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Round %0 : f32
  %3 = spirv.GL.Round %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Round"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Round(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLRoundOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLSAbsOp(_ods_ir.OpView):
  r"""
  Result is x if x ≥ 0; otherwise result is -x, where x is interpreted as a
  signed integer.
  
  Result Type and the type of x must both be integer scalar or integer vector
  types. Result Type and operand types must have the same number of components
  with the same component width. Results are computed per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.SAbs %0 : i32
  %3 = spirv.GL.SAbs %1 : vector<3xi16>
  ```
  """

  OPERATION_NAME = "spirv.GL.SAbs"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_SAbs(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLSAbsOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLSClampOp(_ods_ir.OpView):
  r"""
  Result is min(max(x, minVal), maxVal), where x, minVal and maxVal are
  interpreted as signed integers. The resulting value is undefined if
  minVal > maxVal.
  
  Result Type and the type of the operands must both be integer scalar or
  integer vector types. Result Type and operand types must have the same number
  of components with the same component width. Results are computed per
  component.
  
  <!-- End of AutoGen section -->
  ```
  uclamp-op ::= ssa-id `=` `spirv.GL.UClamp` ssa-use, ssa-use, ssa-use `:`
             sgined-scalar-vector-type
  ```
  #### Example:
  
  ```mlir
  %2 = spirv.GL.SClamp %x, %min, %max : si32
  %3 = spirv.GL.SClamp %x, %min, %max : vector<3xsi16>
  ```
  """

  OPERATION_NAME = "spirv.GL.SClamp"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, x, y, z, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(y)
    operands.append(z)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def z(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_SClamp(result, x, y, z, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLSClampOp(result=result, x=x, y=y, z=z, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLSMaxOp(_ods_ir.OpView):
  r"""
  Result is y if x < y; otherwise result is x, where x and y are interpreted
  as signed integers.
  
  Result Type and the type of x and y must both be integer scalar or integer
  vector types. Result Type and operand types must have the same number of
  components with the same component width. Results are computed per
  component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.SMax %0, %1 : i32
  %3 = spirv.GL.SMax %0, %1 : vector<3xi16>
  ```
  """

  OPERATION_NAME = "spirv.GL.SMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_SMax(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLSMaxOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLSMinOp(_ods_ir.OpView):
  r"""
  Result is y if y < x; otherwise result is x, where x and y are interpreted
  as signed integers.
  
  Result Type and the type of x and y must both be integer scalar or integer
  vector types. Result Type and operand types must have the same number of
  components with the same component width. Results are computed per
  component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.SMin %0, %1 : i32
  %3 = spirv.GL.SMin %0, %1 : vector<3xi16>
  ```
  """

  OPERATION_NAME = "spirv.GL.SMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_SMin(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLSMinOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLSSignOp(_ods_ir.OpView):
  r"""
  Result is 1 if x > 0, 0 if x = 0, or -1 if x < 0, where x is interpreted as
  a signed integer.
  
  Result Type and the type of x must both be integer scalar or integer vector
  types. Result Type and operand types must have the same number of components
  with the same component width. Results are computed per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.SSign %0 : i32
  %3 = spirv.GL.SSign %1 : vector<3xi16>
  ```
  """

  OPERATION_NAME = "spirv.GL.SSign"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_SSign(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLSSignOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLSinOp(_ods_ir.OpView):
  r"""
  The standard trigonometric sine of x radians.
  
  The operand x must be a scalar or vector whose component type is 16-bit or
  32-bit floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Sin %0 : f32
  %3 = spirv.GL.Sin %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Sin(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLSinOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLSinhOp(_ods_ir.OpView):
  r"""
  Hyperbolic sine of x radians.
  
  The operand x must be a scalar or vector whose component type is 16-bit or
  32-bit floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Sinh %0 : f32
  %3 = spirv.GL.Sinh %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Sinh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Sinh(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLSinhOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLSqrtOp(_ods_ir.OpView):
  r"""
  Result is the square root of x. Result is undefined if x < 0.
  
  The operand x must be a scalar or vector whose component type is
  floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Sqrt %0 : f32
  %3 = spirv.GL.Sqrt %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Sqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Sqrt(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLSqrtOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLTanOp(_ods_ir.OpView):
  r"""
  The standard trigonometric tangent of x radians.
  
  The operand x must be a scalar or vector whose component type is 16-bit or
  32-bit floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Tan %0 : f32
  %3 = spirv.GL.Tan %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Tan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Tan(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLTanOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLTanhOp(_ods_ir.OpView):
  r"""
  Hyperbolic tangent of x radians.
  
  The operand x must be a scalar or vector whose component type is 16-bit or
  32-bit floating-point.
  
  Result Type and the type of x must be the same type. Results are computed
  per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.Tanh %0 : f32
  %3 = spirv.GL.Tanh %1 : vector<3xf16>
  ```
  """

  OPERATION_NAME = "spirv.GL.Tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_Tanh(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLTanhOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLUClampOp(_ods_ir.OpView):
  r"""
  Result is min(max(x, minVal), maxVal), where x, minVal and maxVal are
  interpreted as unsigned integers. The resulting value is undefined if
  minVal > maxVal.
  
  Result Type and the type of the operands must both be integer scalar or
  integer vector types. Result Type and operand types must have the same number
  of components with the same component width. Results are computed per
  component.
  
  <!-- End of AutoGen section -->
  ```
  uclamp-op ::= ssa-id `=` `spirv.GL.UClamp` ssa-use, ssa-use, ssa-use `:`
             unsigned-signless-scalar-vector-type
  ```
  #### Example:
  
  ```mlir
  %2 = spirv.GL.UClamp %x, %min, %max : i32
  %3 = spirv.GL.UClamp %x, %min, %max : vector<3xui16>
  ```
  """

  OPERATION_NAME = "spirv.GL.UClamp"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, x, y, z, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(y)
    operands.append(z)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def y(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def z(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_UClamp(result, x, y, z, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLUClampOp(result=result, x=x, y=y, z=z, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLUMaxOp(_ods_ir.OpView):
  r"""
  Result is y if x < y; otherwise result is x, where x and y are interpreted
  as unsigned integers.
  
  Result Type and the type of x and y must both be integer scalar or integer
  vector types. Result Type and operand types must have the same number of
  components with the same component width. Results are computed per
  component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.UMax %0, %1 : i32
  %3 = spirv.GL.UMax %0, %1 : vector<3xi16>
  ```
  """

  OPERATION_NAME = "spirv.GL.UMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_UMax(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLUMaxOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLUMinOp(_ods_ir.OpView):
  r"""
  Result is y if y < x; otherwise result is x, where x and y are interpreted
  as unsigned integers.
  
  Result Type and the type of x and y must both be integer scalar or integer
  vector types. Result Type and operand types must have the same number of
  components with the same component width. Results are computed per
  component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.GL.UMin %0, %1 : i32
  %3 = spirv.GL.UMin %0, %1 : vector<3xi16>
  ```
  """

  OPERATION_NAME = "spirv.GL.UMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, lhs, rhs, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rhs(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_UMin(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLUMinOp(lhs=lhs, rhs=rhs, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GLUnpackHalf2x16Op(_ods_ir.OpView):
  r"""
  Result is the two-component floating-point vector with components obtained by
  unpacking a 32-bit unsigned integer into a pair of 16-bit values, interpreting
  those values as 16-bit floating-point numbers according to the OpenGL
  Specification, and converting them to 32-bit floating-point values. Subnormal
  numbers are either preserved or flushed to zero, consistently within an
  implementation.
  
  The first component of the vector is obtained from the 16 least-significant bits
  of v; the second component is obtained from the 16 most-significant bits of v.
  
  The RelaxedPrecision Decoration only affects the conversion step of the instruction.
  
  The v operand must be a scalar with 32-bit integer type.
  
  Result Type must be a vector of 2 components whose type is 32-bit floating point.
  
  #### Example:
  
  ```mlir
  %1 = spirv.GL.UnpackHalf2x16 %0 : i32 -> vector<2xf32>
  ```
  """

  OPERATION_NAME = "spirv.GL.UnpackHalf2x16"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GL_UnpackHalf2x16(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GLUnpackHalf2x16Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GenericCastToPtrExplicitOp(_ods_ir.OpView):
  r"""
  Result Type must be an OpTypePointer. Its Storage Class must be Storage.
  
  Pointer must have a type of OpTypePointer whose Type is the same as the
  Type of Result Type.Pointer must point to the Generic Storage Class. If
  the cast fails, the instruction result is an OpConstantNull pointer in
  the Storage Storage Class.
  
  Storage must be one of the following literal values from Storage Class:
  Workgroup, CrossWorkgroup, or Function.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
     %1 = spirv.GenericCastToPtrExplicitOp %0 : !spirv.ptr<f32, Generic> to
     !spirv.ptr<f32, CrossWorkGroup>
  ```
  """

  OPERATION_NAME = "spirv.GenericCastToPtrExplicit"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, pointer, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GenericCastToPtrExplicit(result, pointer, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GenericCastToPtrExplicitOp(result=result, pointer=pointer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GenericCastToPtrOp(_ods_ir.OpView):
  r"""
  Result Type must be an OpTypePointer. Its Storage Class must be
  Workgroup, CrossWorkgroup, or Function.
  
  Pointer must point to the Generic Storage Class.
  
  Result Type and Pointer must point to the same type.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
     %1 = spirv.GenericCastToPtrOp %0 : !spirv.ptr<f32, Generic> to
     !spirv.ptr<f32, CrossWorkGroup>
  ```
  """

  OPERATION_NAME = "spirv.GenericCastToPtr"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, pointer, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GenericCastToPtr(result, pointer, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GenericCastToPtrOp(result=result, pointer=pointer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalVariableOp(_ods_ir.OpView):
  r"""
  The variable type must be an OpTypePointer. Its type operand is the type of
  object in memory.
  
  Storage Class is the Storage Class of the memory holding the object. It
  cannot be Generic. It must be the same as the Storage Class operand of
  the variable types. Only those storage classes that are valid at module
  scope (like Input, Output, StorageBuffer, etc.) are valid.
  
  Initializer is optional.  If Initializer is present, it will be
  the initial value of the variable’s memory content. Initializer
  must be an symbol defined from a constant instruction or other
  `spirv.GlobalVariable` operation in module scope. Initializer must
  have the same type as the type of the defined symbol.
  
  <!-- End of AutoGen section -->
  
  ```
  variable-op ::= `spirv.GlobalVariable` spirv-type symbol-ref-id
                  (`initializer(` symbol-ref-id `)`)?
                  (`bind(` integer-literal, integer-literal `)`)?
                  (`built_in(` string-literal `)`)?
                  attribute-dict?
  ```
  
  where `initializer` specifies initializer and `bind` specifies the
  descriptor set and binding number. `built_in` specifies SPIR-V
  BuiltIn decoration associated with the op.
  
  #### Example:
  
  ```mlir
  spirv.GlobalVariable @var0 : !spirv.ptr<f32, Input> @var0
  spirv.GlobalVariable @var1 initializer(@var0) : !spirv.ptr<f32, Output>
  spirv.GlobalVariable @var2 bind(1, 2) : !spirv.ptr<f32, Uniform>
  spirv.GlobalVariable @var3 built_in("GlobalInvocationId") : !spirv.ptr<vector<3xi32>, Input>
  ```
  """

  OPERATION_NAME = "spirv.GlobalVariable"

  _ODS_REGIONS = (0, True)

  def __init__(self, type_, sym_name, *, initializer=None, location=None, binding=None, descriptor_set=None, built_in=None, linkage_attributes=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(sym_name, context=_ods_context))
    if initializer is not None: attributes["initializer"] = (initializer if (
        isinstance(initializer, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(initializer, context=_ods_context))
    if location is not None: attributes["location"] = (location if (
        isinstance(location, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(location, context=_ods_context))
    if binding is not None: attributes["binding"] = (binding if (
        isinstance(binding, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(binding, context=_ods_context))
    if descriptor_set is not None: attributes["descriptor_set"] = (descriptor_set if (
        isinstance(descriptor_set, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(descriptor_set, context=_ods_context))
    if built_in is not None: attributes["built_in"] = (built_in if (
        isinstance(built_in, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(built_in, context=_ods_context))
    if linkage_attributes is not None: attributes["linkage_attributes"] = (linkage_attributes if (
        isinstance(linkage_attributes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_LinkageAttributesAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_LinkageAttributesAttr')(linkage_attributes, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def initializer(self) -> _Optional[_ods_ir.FlatSymbolRefAttr]:
    if "initializer" not in self.operation.attributes:
      return None
    return self.operation.attributes["initializer"]

  @initializer.setter
  def initializer(self, value: _Optional[_ods_ir.FlatSymbolRefAttr]):
    if value is not None:
      self.operation.attributes["initializer"] = value
    elif "initializer" in self.operation.attributes:
      del self.operation.attributes["initializer"]

  @initializer.deleter
  def initializer(self):
    del self.operation.attributes["initializer"]

  @builtins.property
  def location(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "location" not in self.operation.attributes:
      return None
    return self.operation.attributes["location"]

  @location.setter
  def location(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["location"] = value
    elif "location" in self.operation.attributes:
      del self.operation.attributes["location"]

  @location.deleter
  def location(self):
    del self.operation.attributes["location"]

  @builtins.property
  def binding(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "binding" not in self.operation.attributes:
      return None
    return self.operation.attributes["binding"]

  @binding.setter
  def binding(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["binding"] = value
    elif "binding" in self.operation.attributes:
      del self.operation.attributes["binding"]

  @binding.deleter
  def binding(self):
    del self.operation.attributes["binding"]

  @builtins.property
  def descriptor_set(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "descriptor_set" not in self.operation.attributes:
      return None
    return self.operation.attributes["descriptor_set"]

  @descriptor_set.setter
  def descriptor_set(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["descriptor_set"] = value
    elif "descriptor_set" in self.operation.attributes:
      del self.operation.attributes["descriptor_set"]

  @descriptor_set.deleter
  def descriptor_set(self):
    del self.operation.attributes["descriptor_set"]

  @builtins.property
  def built_in(self) -> _Optional[_ods_ir.StringAttr]:
    if "built_in" not in self.operation.attributes:
      return None
    return self.operation.attributes["built_in"]

  @built_in.setter
  def built_in(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["built_in"] = value
    elif "built_in" in self.operation.attributes:
      del self.operation.attributes["built_in"]

  @built_in.deleter
  def built_in(self):
    del self.operation.attributes["built_in"]

  @builtins.property
  def linkage_attributes(self) -> _Optional[_ods_ir.Attribute]:
    if "linkage_attributes" not in self.operation.attributes:
      return None
    return self.operation.attributes["linkage_attributes"]

  @linkage_attributes.setter
  def linkage_attributes(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["linkage_attributes"] = value
    elif "linkage_attributes" in self.operation.attributes:
      del self.operation.attributes["linkage_attributes"]

  @linkage_attributes.deleter
  def linkage_attributes(self):
    del self.operation.attributes["linkage_attributes"]

def GlobalVariable(type_, sym_name, *, initializer=None, location=None, binding=None, descriptor_set=None, built_in=None, linkage_attributes=None, loc=None, ip=None) -> GlobalVariableOp:
  return GlobalVariableOp(type_=type_, sym_name=sym_name, initializer=initializer, location=location, binding=binding, descriptor_set=descriptor_set, built_in=built_in, linkage_attributes=linkage_attributes, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GraphARMOp(_ods_ir.OpView):
  r"""
  This op declares or defines a SPIR-V graph using one region, which
  contains one or more blocks.
  
  This op is not allowed to implicitly capture global values, and all external
  references must use function arguments or symbol references. This op itself
  defines a symbol that is unique in the enclosing module op.
  
  Note that this op does not have a 1:1 mapping to the SPIR-V ops representing
  a graph. Indeed during serialization a single GraphARMOp is serialized into
  several different SPIR-V ops: OpGraphARM, OpGraphInputARM and OpGraphEndARM.
  There are as many occurences of OpGraphInputARM ops as many inputs in the
  graph. Deserialization maps that set of operations into a single GraphARMOp.
  
  This op itself takes no operands and generates no results. Its region
  can take zero or more arguments and return one or more values.
  
  ```
  spv-graph-arm-op ::= `spirv.ARM.Graph` function-signature
                      region
  ```
  
  #### Example:
  
  ```mlir
  spirv.ARM.Graph @graph(%arg0: !spirv.arm.tensor<14x19xi16>) -> !spirv.arm.tensor<14x19xi16> {
      spirv.ARM.GraphOutputs %arg0 : !spirv.arm.tensor<14x19xi16>
  }
  ```
  """

  OPERATION_NAME = "spirv.ARM.Graph"

  _ODS_REGIONS = (1, True)

  def __init__(self, function_type, sym_name, *, arg_attrs=None, res_attrs=None, entry_point=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1894')) else
      _ods_ir.AttrBuilder.get('anonymous_1894')(function_type, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    if entry_point is not None: attributes["entry_point"] = (entry_point if (
        isinstance(entry_point, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(entry_point, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def entry_point(self) -> _Optional[_ods_ir.BoolAttr]:
    if "entry_point" not in self.operation.attributes:
      return None
    return self.operation.attributes["entry_point"]

  @entry_point.setter
  def entry_point(self, value: _Optional[_ods_ir.BoolAttr]):
    if value is not None:
      self.operation.attributes["entry_point"] = value
    elif "entry_point" in self.operation.attributes:
      del self.operation.attributes["entry_point"]

  @entry_point.deleter
  def entry_point(self):
    del self.operation.attributes["entry_point"]

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def ARM_Graph(function_type, sym_name, *, arg_attrs=None, res_attrs=None, entry_point=None, loc=None, ip=None) -> GraphARMOp:
  return GraphARMOp(function_type=function_type, sym_name=sym_name, arg_attrs=arg_attrs, res_attrs=res_attrs, entry_point=entry_point, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GraphConstantARMOp(_ods_ir.OpView):
  r"""
  Declare a graph constant.
  Result Type must be an OpTypeTensorARM.
  GraphConstantID must be a 32-bit integer literal.
  
  #### Example:
  
  ```mlir
  %0 = spirv.ARM.GraphConstant { graph_constant_id = 42 : i32 } : !spirv.arm.tensor<2x3xi16>
  ```
  
  GraphConstantID is a unique identifier which is use to map the contants
  defined by GraphConstantARM in the SPIRV module with the one provided at
  shader creation time via the VkDataGraphPipelineShaderModuleCreateInfoARM.
  That Vulkan structure provides a list of VkDataGraphPipelineConstantARM
  which contains the bindings from id to data. (For more details see
  https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#graphs)
  """

  OPERATION_NAME = "spirv.ARM.GraphConstant"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, graph_constant_id, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["graph_constant_id"] = (graph_constant_id if (
    isinstance(graph_constant_id, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32Attr')) else
      _ods_ir.AttrBuilder.get('I32Attr')(graph_constant_id, context=_ods_context))
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def graph_constant_id(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["graph_constant_id"]

  @graph_constant_id.setter
  def graph_constant_id(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["graph_constant_id"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ARM_GraphConstant(output, graph_constant_id, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GraphConstantARMOp(output=output, graph_constant_id=graph_constant_id, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GraphEntryPointARMOp(_ods_ir.OpView):
  r"""
  Graph Entry Point must be the Result <id> of an OpGraphARM instruction.
  
  Name is a name string for the graphentry point. A module cannot have two
  OpGraphEntryPointARM instructions with the same Name string.
  
  Interface is a list of symbol references to `spirv.GlobalVariable`
  operations. These declare the set of global variables from a
  module that form the interface of this entry point. The set of
  Interface symbols must be equal to or a superset of the
  `spirv.GlobalVariable`s referenced by the entry point’s static call
  tree, within the interface’s storage classes.
  
  #### Example:
  
  ```mlir
  spirv.GlobalVariable @arg_0 bind(0, 0) : !spirv.ptr<!spirv.arm.tensor<14x19xi16>, UniformConstant>
  spirv.GlobalVariable @res_0 bind(0, 1) : !spirv.ptr<!spirv.arm.tensor<14x19xi16>, UniformConstant>
  spirv.ARM.GraphEntryPoint @graph, @arg_0, @res_0
  spirv.ARM.Graph @graph(%arg0 : !spirv.arm.tensor<14x19xi16>) -> !spirv.arm.tensor<14x19xi16> {
      ...
  }
  ```
  """

  OPERATION_NAME = "spirv.ARM.GraphEntryPoint"

  _ODS_REGIONS = (0, True)

  def __init__(self, fn, interface, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["fn"] = (fn if (
    isinstance(fn, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(fn, context=_ods_context))
    attributes["interface"] = (interface if (
    isinstance(interface, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(interface, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def fn(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["fn"]

  @fn.setter
  def fn(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["fn"] = value

  @builtins.property
  def interface(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["interface"]

  @interface.setter
  def interface(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["interface"] = value

def ARM_GraphEntryPoint(fn, interface, *, loc=None, ip=None) -> GraphEntryPointARMOp:
  return GraphEntryPointARMOp(fn=fn, interface=interface, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GraphOutputsARMOp(_ods_ir.OpView):
  r"""
  Values are the graph outputs values and must match the GraphOutputs Type
  operand of the OpTypeGraphARM type of the OpGraphARM body this
  instruction is in.
  
  This instruction must be the last instruction in a block.
  
  #### Example:
  
  ```mlir
  spirv.ARM.Graph @graph(%arg0 : !spirv.arm.tensor<14x19xi16>) -> !spirv.arm.tensor<14x19xi16> {
      spirv.ARM.GraphOutputs %arg0 : !spirv.arm.tensor<14x19xi16>
  }
  ```
  """

  OPERATION_NAME = "spirv.ARM.GraphOutputs"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(value))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def ARM_GraphOutputs(value, *, loc=None, ip=None) -> GraphOutputsARMOp:
  return GraphOutputsARMOp(value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GroupBroadcastOp(_ods_ir.OpView):
  r"""
  All invocations of this module within Execution must reach this point of
  execution.
  
  Behavior is undefined if this instruction is used in control flow that
  is non-uniform within Execution.
  
  Result Type  must be a scalar or vector of floating-point type, integer
  type, or Boolean type.
  
  Execution must be Workgroup or Subgroup Scope.
  
  The type of Value must be the same as Result Type.
  
  LocalId must be an integer datatype. It can be a scalar, or a vector
  with 2 components or a vector with 3 components. LocalId must be the
  same for all invocations in the group.
  
  #### Example:
  
  ```mlir
  %scalar_value = ... : f32
  %vector_value = ... : vector<4xf32>
  %scalar_localid = ... : i32
  %vector_localid = ... : vector<3xi32>
  %0 = spirv.GroupBroadcast "Subgroup" %scalar_value, %scalar_localid : f32, i32
  %1 = spirv.GroupBroadcast "Workgroup" %vector_value, %vector_localid :
    vector<4xf32>, vector<3xi32>
  ```
  """

  OPERATION_NAME = "spirv.GroupBroadcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, value, localid, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(localid)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def localid(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupBroadcast(execution_scope, value, localid, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupBroadcastOp(execution_scope=execution_scope, value=value, localid=localid, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupFAddOp(_ods_ir.OpView):
  r"""
  Behavior is undefined if not all invocations of this module within
  Execution reach this point of execution.
  
  Behavior is undefined unless all invocations within Execution execute
  the same dynamic instance of this instruction.
  
  Result Type  must be a scalar or vector of floating-point type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
  The identity I for Operation is 0.
  
  The type of X must be the same as Result Type.
  
  #### Example:
  
  ```mlir
  %0 = spirv.GroupFAdd <Workgroup> <Reduce> %value : f32
  ```
  """

  OPERATION_NAME = "spirv.GroupFAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupFAdd(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupFAddOp(execution_scope=execution_scope, group_operation=group_operation, x=x, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupFMaxOp(_ods_ir.OpView):
  r"""
  Behavior is undefined if not all invocations of this module within
  Execution reach this point of execution.
  
  Behavior is undefined unless all invocations within Execution execute
  the same dynamic instance of this instruction.
  
  Result Type  must be a scalar or vector of floating-point type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
  The identity I for Operation is -INF.
  
  The type of X must be the same as Result Type.
  
  #### Example:
  
  ```mlir
  %0 = spirv.GroupFMax <Workgroup> <Reduce> %value : f32
  ```
  """

  OPERATION_NAME = "spirv.GroupFMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupFMax(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupFMaxOp(execution_scope=execution_scope, group_operation=group_operation, x=x, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupFMinOp(_ods_ir.OpView):
  r"""
  Behavior is undefined if not all invocations of this module within
  Execution reach this point of execution.
  
  Behavior is undefined unless all invocations within Execution execute
  the same dynamic instance of this instruction.
  
  Result Type  must be a scalar or vector of floating-point type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
  The identity I for Operation is +INF.
  
  The type of X must be the same as Result Type.
  
  #### Example:
  
  ```mlir
  %0 = spirv.GroupFMin <Workgroup> <Reduce> %value : f32
  ```
  """

  OPERATION_NAME = "spirv.GroupFMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupFMin(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupFMinOp(execution_scope=execution_scope, group_operation=group_operation, x=x, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupFMulKHROp(_ods_ir.OpView):
  r"""
  Behavior is undefined if not all invocations of this module within
  'Execution' reach this point of execution.
  
  Behavior is undefined unless all invocations within 'Execution' execute the
  same dynamic instance of this instruction.
  
  'Result Type' must be a scalar or vector of floating-point type.
  
  'Execution' is a Scope. It must be either Workgroup or Subgroup.
  
  The identity I for 'Operation' is 1.
  
  The type of 'X' must be the same as 'Result Type'.
  
  
  #### Example:
  
  ```mlir
  %0 = spirv.KHR.GroupFMul <Workgroup> <Reduce> %value : f32
  ```
  """

  OPERATION_NAME = "spirv.KHR.GroupFMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def KHR_GroupFMul(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupFMulKHROp(execution_scope=execution_scope, group_operation=group_operation, x=x, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupIAddOp(_ods_ir.OpView):
  r"""
  Behavior is undefined if not all invocations of this module within
  Execution reach this point of execution.
  
  Behavior is undefined unless all invocations within Execution execute
  the same dynamic instance of this instruction.
  
  Result Type  must be a scalar or vector of integer type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
  The identity I for Operation is 0.
  
  The type of X must be the same as Result Type.
  
  #### Example:
  
  ```mlir
  %0 = spirv.GroupIAdd <Workgroup> <Reduce> %value : i32
  ```
  """

  OPERATION_NAME = "spirv.GroupIAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupIAdd(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupIAddOp(execution_scope=execution_scope, group_operation=group_operation, x=x, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupIMulKHROp(_ods_ir.OpView):
  r"""
  Behavior is undefined if not all invocations of this module within
  'Execution' reach this point of execution.
  
  Behavior is undefined unless all invocations within 'Execution' execute the
  same dynamic instance of this instruction.
  
  'Result Type' must be a scalar or vector of integer type.
  
  'Execution' is a Scope. It must be either Workgroup or Subgroup.
  
  The identity I for 'Operation' is 1.
  
  The type of 'X' must be the same as 'Result Type'.
  
  #### Example:
  
  ```mlir
  %0 = spirv.KHR.GroupIMul <Workgroup> <Reduce> %value : i32
  ```
  """

  OPERATION_NAME = "spirv.KHR.GroupIMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def KHR_GroupIMul(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupIMulKHROp(execution_scope=execution_scope, group_operation=group_operation, x=x, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformAllEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a Boolean type.
  
  Execution is the scope defining the scope restricted tangle affected by
  this command. It must be Subgroup.
  
  Value must be a scalar or vector of floating-point type, integer type,
  or Boolean type. The compare operation is based on this type, and if it
  is a floating-point type, an ordered-and-equal compare is used.
  
  An invocation will not execute a dynamic instance of this instruction
  (X') until all invocations in its scope restricted tangle have executed
  all dynamic instances that are program-ordered before X'.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %scalar_value = ... : f32
  %vector_value = ... : vector<4xf32>
  %0 = spirv.GroupNonUniformAllEqual <Subgroup> %scalar_value : f32, i1
  %1 = spirv.GroupNonUniformAllEqual <Subgroup> %vector_value : vector<4xf32>, i1
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformAllEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformAllEqual(execution_scope, value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformAllEqualOp(execution_scope=execution_scope, value=value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformAllOp(_ods_ir.OpView):
  r"""
  Result Type must be a Boolean type.
  
  Execution is the scope defining the scope restricted tangle affected by
  this command. It must be Subgroup.
  
  Predicate must be a Boolean type.
  
  An invocation will not execute a dynamic instance of this instruction
  (X') until all invocations in its scope restricted tangle have executed
  all dynamic instances that are program-ordered before X'.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %predicate = ... : i1
  %0 = spirv.GroupNonUniformAll "Subgroup" %predicate : i1
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformAll"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, predicate, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(predicate)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def predicate(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformAll(execution_scope, predicate, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformAllOp(execution_scope=execution_scope, predicate=predicate, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformAnyOp(_ods_ir.OpView):
  r"""
  Result Type must be a Boolean type.
  
  Execution is the scope defining the scope restricted tangle affected by
  this command. It must be Subgroup.
  
  Predicate must be a Boolean type.
  
  An invocation will not execute a dynamic instance of this instruction
  (X') until all invocations in its scope restricted tangle have executed
  all dynamic instances that are program-ordered before X'.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %predicate = ... : i1
  %0 = spirv.GroupNonUniformAny "Subgroup" %predicate : i1
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformAny"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, predicate, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(predicate)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def predicate(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformAny(execution_scope, predicate, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformAnyOp(execution_scope=execution_scope, predicate=predicate, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformBallotBitCountOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar of integer type, whose Signedness operand
  is 0.
  
  Execution is the scope defining the scope restricted tangle affected by
  this command. It must be Subgroup.
  
  The identity I for Operation is 0.
  
  Value must be a vector of four components of integer type scalar, whose
  Width operand is 32 and whose Signedness operand is 0.
  
  Value is a set of bitfields where the first invocation is represented in
  the lowest bit of the first vector component and the last (up to the
  size of the scope) is the higher bit number of the last bitmask needed
  to represent all bits of the invocations in the scope restricted tangle.
  
  An invocation will not execute a dynamic instance of this instruction
  (X') until all invocations in its scope restricted tangle have executed
  all dynamic instances that are program-ordered before X'.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %count = spirv.GroupNonUniformBallotBitCount <Subgroup> <Reduce> %val : vector<4xi32> -> i32
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformBallotBitCount"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformBallotBitCount(result, execution_scope, group_operation, value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformBallotBitCountOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformBallotFindLSBOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar of integer type, whose Signedness operand
  is 0.
  
  Execution is a Scope that identifies the group of invocations affected
  by this command. It must be Subgroup.
  
  Value must be a vector of four components of integer type scalar, whose
  Width operand is 32 and whose Signedness operand is 0.
  
  Value is a set of bitfields where the first invocation is represented in
  the lowest bit of the first vector component and the last (up to the
  size of the group) is the higher bit number of the last bitmask needed
  to represent all bits of the group invocations.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %vector = ... : vector<4xi32>
  %0 = spirv.GroupNonUniformBallotFindLSB <Subgroup> %vector : vector<4xi32>, i32
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformBallotFindLSB"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformBallotFindLSB(result, execution_scope, value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformBallotFindLSBOp(result=result, execution_scope=execution_scope, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformBallotFindMSBOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar of integer type, whose Signedness operand
  is 0.
  
  Execution is a Scope that identifies the group of invocations affected
  by this command. It must be Subgroup.
  
  Value must be a vector of four components of integer type scalar, whose
  Width operand is 32 and whose Signedness operand is 0.
  
  Value is a set of bitfields where the first invocation is represented in
  the lowest bit of the first vector component and the last (up to the
  size of the group) is the higher bit number of the last bitmask needed
  to represent all bits of the group invocations.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %vector = ... : vector<4xi32>
  %0 = spirv.GroupNonUniformBallotFindMSB <Subgroup> %vector : vector<4xi32>, i32
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformBallotFindMSB"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformBallotFindMSB(result, execution_scope, value, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformBallotFindMSBOp(result=result, execution_scope=execution_scope, value=value, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformBallotOp(_ods_ir.OpView):
  r"""
  Result Type  must be a vector of four components of integer type scalar,
  whose Signedness operand is 0.
  
  Result is a set of bitfields where the first invocation is represented
  in the lowest bit of the first vector component and the last (up to the
  size of the group) is the higher bit number of the last bitmask needed
  to represent all bits of the group invocations.
  
  Execution must be Workgroup or Subgroup Scope.
  
  Predicate must be a Boolean type.
  
  #### Example:
  
  ```mlir
  %0 = spirv.GroupNonUniformBallot <Subgroup> %predicate : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformBallot"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, predicate, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(predicate)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def predicate(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformBallot(result, execution_scope, predicate, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformBallotOp(result=result, execution_scope=execution_scope, predicate=predicate, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformBitwiseAndOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
  The identity I for Operation is ~0. If Operation is ClusteredReduce,
  ClusterSize must be present.
  
  The type of Value must be the same as Result Type.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar
  of integer type, whose Signedness operand is 0. ClusterSize must come
  from a constant instruction. ClusterSize must be at least 1, and must be
  a power of 2. If ClusterSize is greater than the declared SubGroupSize,
  executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %scalar = ... : i32
  %vector = ... : vector<4xi32>
  %0 = spirv.GroupNonUniformBitwiseAnd <Workgroup> <Reduce> %scalar : i32 -> i32
  %1 = spirv.GroupNonUniformBitwiseAnd <Subgroup> <ClusteredReduce>
         %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformBitwiseAnd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformBitwiseAnd(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformBitwiseAndOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformBitwiseOrOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
  The identity I for Operation is 0. If Operation is ClusteredReduce,
  ClusterSize must be present.
  
  The type of Value must be the same as Result Type.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar
  of integer type, whose Signedness operand is 0. ClusterSize must come
  from a constant instruction. ClusterSize must be at least 1, and must be
  a power of 2. If ClusterSize is greater than the declared SubGroupSize,
  executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %scalar = ... : i32
  %vector = ... : vector<4xi32>
  %0 = spirv.GroupNonUniformBitwiseOr <Workgroup> <Reduce> %scalar : i32 -> i32
  %1 = spirv.GroupNonUniformBitwiseOr <Subgroup> <ClusteredReduce>
         %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformBitwiseOr"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformBitwiseOr(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformBitwiseOrOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformBitwiseXorOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
  The identity I for Operation is 0. If Operation is ClusteredReduce,
  ClusterSize must be present.
  
  The type of Value must be the same as Result Type.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar
  of integer type, whose Signedness operand is 0. ClusterSize must come
  from a constant instruction. ClusterSize must be at least 1, and must be
  a power of 2. If ClusterSize is greater than the declared SubGroupSize,
  executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %scalar = ... : i32
  %vector = ... : vector<4xi32>
  %0 = spirv.GroupNonUniformBitwiseXor <Workgroup> <Reduce> %scalar : i32 -> i32
  %1 = spirv.GroupNonUniformBitwiseXor <Subgroup> <ClusteredReduce>
         %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformBitwiseXor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformBitwiseXor(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformBitwiseXorOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformBroadcastOp(_ods_ir.OpView):
  r"""
  Result Type  must be a scalar or vector of floating-point type, integer
  type, or Boolean type.
  
  Execution must be Workgroup or Subgroup Scope.
  
  The type of Value must be the same as Result Type.
  
  Id  must be a scalar of integer type, whose Signedness operand is 0.
  
  Before version 1.5, Id must come from a constant instruction. Starting
  with version 1.5, Id must be dynamically uniform.
  
  The resulting value is undefined if Id is an inactive invocation, or is
  greater than or equal to the size of the group.
  
  #### Example:
  
  ```mlir
  %scalar_value = ... : f32
  %vector_value = ... : vector<4xf32>
  %id = ... : i32
  %0 = spirv.GroupNonUniformBroadcast "Subgroup" %scalar_value, %id : f32, i32
  %1 = spirv.GroupNonUniformBroadcast "Workgroup" %vector_value, %id :
    vector<4xf32>, i32
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformBroadcast"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, value, id, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(id)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def id(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformBroadcast(execution_scope, value, id, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformBroadcastOp(execution_scope=execution_scope, value=value, id=id, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformElectOp(_ods_ir.OpView):
  r"""
  Result Type must be a Boolean type.
  
  Execution must be Workgroup or Subgroup Scope.
  
  #### Example:
  
  ```mlir
  %0 = spirv.GroupNonUniformElect : i1
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformElect"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformElect(execution_scope, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformElectOp(execution_scope=execution_scope, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformFAddOp(_ods_ir.OpView):
  r"""
  Result Type  must be a scalar or vector of floating-point type.
  
  Execution must be Workgroup or Subgroup Scope.
  
  The identity I for Operation is 0. If Operation is ClusteredReduce,
  ClusterSize must be specified.
  
   The type of Value must be the same as Result Type.  The method used to
  perform the group operation on the contributed Value(s) from active
  invocations is implementation defined.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar
  of integer type, whose Signedness operand is 0. ClusterSize must come
  from a constant instruction. ClusterSize must be at least 1, and must be
  a power of 2. If ClusterSize is greater than the declared SubGroupSize,
  executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %scalar = ... : f32
  %vector = ... : vector<4xf32>
  %0 = spirv.GroupNonUniformFAdd <Workgroup> <Reduce> %scalar : f32 -> f32
  %1 = spirv.GroupNonUniformFAdd <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xf32>, i32 -> vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformFAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformFAdd(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformFAddOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformFMaxOp(_ods_ir.OpView):
  r"""
  Result Type  must be a scalar or vector of floating-point type.
  
  Execution must be Workgroup or Subgroup Scope.
  
  The identity I for Operation is -INF. If Operation is ClusteredReduce,
  ClusterSize must be specified.
  
   The type of Value must be the same as Result Type.  The method used to
  perform the group operation on the contributed Value(s) from active
  invocations is implementation defined. From the set of Value(s) provided
  by active invocations within a subgroup, if for any two Values one of
  them is a NaN, the other is chosen. If all Value(s) that are used by the
  current invocation are NaN, then the result is an undefined value.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar
  of integer type, whose Signedness operand is 0. ClusterSize must come
  from a constant instruction. ClusterSize must be at least 1, and must be
  a power of 2. If ClusterSize is greater than the declared SubGroupSize,
  executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %scalar = ... : f32
  %vector = ... : vector<4xf32>
  %0 = spirv.GroupNonUniformFMax <Workgroup> <Reduce> %scalar : f32 -> f32
  %1 = spirv.GroupNonUniformFMax <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xf32>, i32 -> vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformFMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformFMax(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformFMaxOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformFMinOp(_ods_ir.OpView):
  r"""
  Result Type  must be a scalar or vector of floating-point type.
  
  Execution must be Workgroup or Subgroup Scope.
  
  The identity I for Operation is +INF. If Operation is ClusteredReduce,
  ClusterSize must be specified.
  
   The type of Value must be the same as Result Type.  The method used to
  perform the group operation on the contributed Value(s) from active
  invocations is implementation defined. From the set of Value(s) provided
  by active invocations within a subgroup, if for any two Values one of
  them is a NaN, the other is chosen. If all Value(s) that are used by the
  current invocation are NaN, then the result is an undefined value.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar
  of integer type, whose Signedness operand is 0. ClusterSize must come
  from a constant instruction. ClusterSize must be at least 1, and must be
  a power of 2. If ClusterSize is greater than the declared SubGroupSize,
  executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %scalar = ... : f32
  %vector = ... : vector<4xf32>
  %0 = spirv.GroupNonUniformFMin <Workgroup> <Reduce> %scalar : f32 -> i32
  %1 = spirv.GroupNonUniformFMin <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xf32>, i32 -> vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformFMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformFMin(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformFMinOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformFMulOp(_ods_ir.OpView):
  r"""
  Result Type  must be a scalar or vector of floating-point type.
  
  Execution must be Workgroup or Subgroup Scope.
  
  The identity I for Operation is 1. If Operation is ClusteredReduce,
  ClusterSize must be specified.
  
   The type of Value must be the same as Result Type.  The method used to
  perform the group operation on the contributed Value(s) from active
  invocations is implementation defined.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar
  of integer type, whose Signedness operand is 0. ClusterSize must come
  from a constant instruction. ClusterSize must be at least 1, and must be
  a power of 2. If ClusterSize is greater than the declared SubGroupSize,
  executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %scalar = ... : f32
  %vector = ... : vector<4xf32>
  %0 = spirv.GroupNonUniformFMul <Workgroup> <Reduce> %scalar : f32 -> f32
  %1 = spirv.GroupNonUniformFMul <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xf32>, i32 -> vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformFMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformFMul(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformFMulOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformIAddOp(_ods_ir.OpView):
  r"""
  Result Type  must be a scalar or vector of integer type.
  
  Execution must be Workgroup or Subgroup Scope.
  
  The identity I for Operation is 0. If Operation is ClusteredReduce,
  ClusterSize must be specified.
  
   The type of Value must be the same as Result Type.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar
  of integer type, whose Signedness operand is 0. ClusterSize must come
  from a constant instruction. ClusterSize must be at least 1, and must be
  a power of 2. If ClusterSize is greater than the declared SubGroupSize,
  executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %scalar = ... : i32
  %vector = ... : vector<4xi32>
  %0 = spirv.GroupNonUniformIAdd <Workgroup> <Reduce> %scalar : i32 -> i32
  %1 = spirv.GroupNonUniformIAdd <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformIAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformIAdd(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformIAddOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformIMulOp(_ods_ir.OpView):
  r"""
  Result Type  must be a scalar or vector of integer type.
  
  Execution must be Workgroup or Subgroup Scope.
  
  The identity I for Operation is 1. If Operation is ClusteredReduce,
  ClusterSize must be specified.
  
   The type of Value must be the same as Result Type.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar
  of integer type, whose Signedness operand is 0. ClusterSize must come
  from a constant instruction. ClusterSize must be at least 1, and must be
  a power of 2. If ClusterSize is greater than the declared SubGroupSize,
  executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %scalar = ... : i32
  %vector = ... : vector<4xi32>
  %0 = spirv.GroupNonUniformIMul <Workgroup> <Reduce> %scalar : i32 -> i32
  %1 = spirv.GroupNonUniformIMul <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformIMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformIMul(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformIMulOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformLogicalAndOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
  The identity I for Operation is ~0. If Operation is ClusteredReduce,
  ClusterSize must be present.
  
  The type of Value must be the same as Result Type.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar
  of integer type, whose Signedness operand is 0. ClusterSize must come
  from a constant instruction. ClusterSize must be at least 1, and must be
  a power of 2. If ClusterSize is greater than the declared SubGroupSize,
  executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %scalar = ... : i1
  %vector = ... : vector<4xi1>
  %0 = spirv.GroupNonUniformLogicalAnd <Workgroup> <Reduce> %scalar : i1 -> i1
  %1 = spirv.GroupNonUniformLogicalAnd <Subgroup> <ClusteredReduce>
         %vector cluster_size(%four) : vector<4xi1>, i32 -> vector<4xi1>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformLogicalAnd"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformLogicalAnd(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformLogicalAndOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformLogicalOrOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
  The identity I for Operation is 0. If Operation is ClusteredReduce,
  ClusterSize must be present.
  
  The type of Value must be the same as Result Type.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar
  of integer type, whose Signedness operand is 0. ClusterSize must come
  from a constant instruction. ClusterSize must be at least 1, and must be
  a power of 2. If ClusterSize is greater than the declared SubGroupSize,
  executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %scalar = ... : i1
  %vector = ... : vector<4xi1>
  %0 = spirv.GroupNonUniformLogicalOr <Workgroup> <Reduce> %scalar : i1 -> i1
  %1 = spirv.GroupNonUniformLogicalOr <Subgroup> <ClusteredReduce>
         %vector cluster_size(%four) : vector<4xi1>, i32 -> vector<4xi1>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformLogicalOr"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformLogicalOr(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformLogicalOrOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformLogicalXorOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
  The identity I for Operation is 0. If Operation is ClusteredReduce,
  ClusterSize must be present.
  
  The type of Value must be the same as Result Type.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar
  of integer type, whose Signedness operand is 0. ClusterSize must come
  from a constant instruction. ClusterSize must be at least 1, and must be
  a power of 2. If ClusterSize is greater than the declared SubGroupSize,
  executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %scalar = ... : i1
  %vector = ... : vector<4xi1>
  %0 = spirv.GroupNonUniformLogicalXor <Workgroup> <Reduce> %scalar : i1 -> i1
  %1 = spirv.GroupNonUniformLogicalXor <Subgroup> <ClusteredReduce>
         %vector cluster_size(%four) : vector<4xi1>, i32 -> vector<4xi1>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformLogicalXor"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformLogicalXor(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformLogicalXorOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformRotateKHROp(_ods_ir.OpView):
  r"""
  Return the Value of the invocation whose id within the group is calculated
  as follows:
  
  LocalId = SubgroupLocalInvocationId if Execution is Subgroup or
            LocalInvocationId if Execution is Workgroup
  RotationGroupSize = ClusterSize when ClusterSize is present, otherwise
  RotationGroupSize = SubgroupMaxSize if the Kernel capability is declared
                      and SubgroupSize if not.
  Invocation ID = ( (LocalId + Delta) & (RotationGroupSize - 1) ) +
                  (LocalId & ~(RotationGroupSize - 1))
  
  Result Type must be a scalar or vector of floating-point type, integer
  type, or Boolean type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
  The type of Value must be the same as Result Type.
  
  Delta must be a scalar of integer type, whose Signedness operand is 0.
  Delta must be dynamically uniform within Execution.
  
  Delta is treated as unsigned and the resulting value is undefined if the
  selected lane is inactive.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar of
  integer type, whose Signedness operand is 0. ClusterSize must come from a
  constant instruction. Behavior is undefined unless ClusterSize is at least
  1 and a power of 2. If ClusterSize is greater than the declared
  SubGroupSize, executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %0 = spirv.GroupNonUniformRotateKHR <Subgroup> %value, %delta : f32, i32 -> f32
  %1 = spirv.GroupNonUniformRotateKHR <Workgroup> %value, %delta,
       clustersize(%four) : f32, i32, i32 -> f32
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformRotateKHR"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, value, delta, *, cluster_size=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(delta)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def delta(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformRotateKHR(execution_scope, value, delta, *, cluster_size=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformRotateKHROp(execution_scope=execution_scope, value=value, delta=delta, cluster_size=cluster_size, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformSMaxOp(_ods_ir.OpView):
  r"""
  Result Type  must be a scalar or vector of integer type.
  
  Execution must be Workgroup or Subgroup Scope.
  
  The identity I for Operation is INT_MIN. If Operation is
  ClusteredReduce, ClusterSize must be specified.
  
   The type of Value must be the same as Result Type.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar
  of integer type, whose Signedness operand is 0. ClusterSize must come
  from a constant instruction. ClusterSize must be at least 1, and must be
  a power of 2. If ClusterSize is greater than the declared SubGroupSize,
  executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %scalar = ... : i32
  %vector = ... : vector<4xi32>
  %0 = spirv.GroupNonUniformSMax <Workgroup> <Reduce> %scalar : i32
  %1 = spirv.GroupNonUniformSMax <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformSMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformSMax(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformSMaxOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformSMinOp(_ods_ir.OpView):
  r"""
  Result Type  must be a scalar or vector of integer type.
  
  Execution must be Workgroup or Subgroup Scope.
  
  The identity I for Operation is INT_MAX. If Operation is
  ClusteredReduce, ClusterSize must be specified.
  
   The type of Value must be the same as Result Type.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar
  of integer type, whose Signedness operand is 0. ClusterSize must come
  from a constant instruction. ClusterSize must be at least 1, and must be
  a power of 2. If ClusterSize is greater than the declared SubGroupSize,
  executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %scalar = ... : i32
  %vector = ... : vector<4xi32>
  %0 = spirv.GroupNonUniformSMin <Workgroup> <Reduce> %scalar : i32 -> i32
  %1 = spirv.GroupNonUniformSMin <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformSMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformSMin(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformSMinOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformShuffleDownOp(_ods_ir.OpView):
  r"""
  Result Type  must be a scalar or vector of floating-point type, integer
  type, or Boolean type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
   The type of Value must be the same as Result Type.
  
  Delta  must be a scalar of integer type, whose Signedness operand is 0.
  
  Delta is treated as unsigned and the resulting value is undefined if
  Delta is greater than or equal to the size of the group, or if the
  current invocation’s id within the group + Delta is either an inactive
  invocation or greater than or equal to the size of the group.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.GroupNonUniformShuffleDown <Subgroup> %val, %delta : f32, i32
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformShuffleDown"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, value, delta, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(delta)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def delta(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformShuffleDown(execution_scope, value, delta, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformShuffleDownOp(execution_scope=execution_scope, value=value, delta=delta, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformShuffleOp(_ods_ir.OpView):
  r"""
  Result Type  must be a scalar or vector of floating-point type, integer
  type, or Boolean type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
   The type of Value must be the same as Result Type.
  
  Id  must be a scalar of integer type, whose Signedness operand is 0.
  
  The resulting value is undefined if Id is an inactive invocation, or is
  greater than or equal to the size of the group.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.GroupNonUniformShuffle <Subgroup> %val, %id : f32, i32
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformShuffle"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, value, id, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(id)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def id(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformShuffle(execution_scope, value, id, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformShuffleOp(execution_scope=execution_scope, value=value, id=id, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformShuffleUpOp(_ods_ir.OpView):
  r"""
  Result Type  must be a scalar or vector of floating-point type, integer
  type, or Boolean type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
   The type of Value must be the same as Result Type.
  
  Delta  must be a scalar of integer type, whose Signedness operand is 0.
  
  Delta is treated as unsigned and the resulting value is undefined if
  Delta is greater than the current invocation’s id within the group or if
  the selected lane is inactive.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.GroupNonUniformShuffleUp <Subgroup> %val, %delta : f32, i32
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformShuffleUp"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, value, delta, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(delta)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def delta(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformShuffleUp(execution_scope, value, delta, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformShuffleUpOp(execution_scope=execution_scope, value=value, delta=delta, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformShuffleXorOp(_ods_ir.OpView):
  r"""
  Result Type  must be a scalar or vector of floating-point type, integer
  type, or Boolean type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
   The type of Value must be the same as Result Type.
  
  Mask  must be a scalar of integer type, whose Signedness operand is 0.
  
  The resulting value is undefined if current invocation’s id within the
  group xor’ed with Mask is an inactive invocation, or is greater than or
  equal to the size of the group.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.GroupNonUniformShuffleXor <Subgroup> %val, %mask : f32, i32
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformShuffleXor"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, value, mask, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(mask)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def mask(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformShuffleXor(execution_scope, value, mask, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformShuffleXorOp(execution_scope=execution_scope, value=value, mask=mask, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformUMaxOp(_ods_ir.OpView):
  r"""
  Result Type  must be a scalar or vector of integer type, whose
  Signedness operand is 0.
  
  Execution must be Workgroup or Subgroup Scope.
  
  The identity I for Operation is 0. If Operation is ClusteredReduce,
  ClusterSize must be specified.
  
   The type of Value must be the same as Result Type.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar
  of integer type, whose Signedness operand is 0. ClusterSize must come
  from a constant instruction. ClusterSize must be at least 1, and must be
  a power of 2. If ClusterSize is greater than the declared SubGroupSize,
  executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %scalar = ... : i32
  %vector = ... : vector<4xi32>
  %0 = spirv.GroupNonUniformUMax <Workgroup> <Reduce> %scalar : i32 -> i32
  %1 = spirv.GroupNonUniformUMax <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformUMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformUMax(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformUMaxOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupNonUniformUMinOp(_ods_ir.OpView):
  r"""
  Result Type  must be a scalar or vector of integer type, whose
  Signedness operand is 0.
  
  Execution must be Workgroup or Subgroup Scope.
  
  The identity I for Operation is UINT_MAX. If Operation is
  ClusteredReduce, ClusterSize must be specified.
  
   The type of Value must be the same as Result Type.
  
  ClusterSize is the size of cluster to use. ClusterSize must be a scalar
  of integer type, whose Signedness operand is 0. ClusterSize must come
  from a constant instruction. ClusterSize must be at least 1, and must be
  a power of 2. If ClusterSize is greater than the declared SubGroupSize,
  executing this instruction results in undefined behavior.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %four = spirv.Constant 4 : i32
  %scalar = ... : i32
  %vector = ... : vector<4xi32>
  %0 = spirv.GroupNonUniformUMin <Workgroup> <Reduce> %scalar : i32 -> i32
  %1 = spirv.GroupNonUniformUMin <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.GroupNonUniformUMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    if cluster_size is not None: operands.append(cluster_size)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def cluster_size(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupNonUniformUMin(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupNonUniformUMinOp(result=result, execution_scope=execution_scope, group_operation=group_operation, value=value, cluster_size=cluster_size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupSMaxOp(_ods_ir.OpView):
  r"""
  Behavior is undefined if not all invocations of this module within
  Execution reach this point of execution.
  
  Behavior is undefined unless all invocations within Execution execute
  the same dynamic instance of this instruction.
  
  Result Type  must be a scalar or vector of integer type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
  The identity I for Operation is INT_MIN when X is 32 bits wide and
  LONG_MIN when X is 64 bits wide.
  
  The type of X must be the same as Result Type.
  
  #### Example:
  
  ```mlir
  %0 = spirv.GroupSMax <Workgroup> <Reduce> %value : i32
  ```
  """

  OPERATION_NAME = "spirv.GroupSMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupSMax(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupSMaxOp(execution_scope=execution_scope, group_operation=group_operation, x=x, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupSMinOp(_ods_ir.OpView):
  r"""
  Behavior is undefined if not all invocations of this module within
  Execution reach this point of execution.
  
  Behavior is undefined unless all invocations within Execution execute
  the same dynamic instance of this instruction.
  
  Result Type  must be a scalar or vector of integer type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
  The identity I for Operation is INT_MAX when X is 32 bits wide and
  LONG_MAX when X is 64 bits wide.
  
  The type of X must be the same as Result Type.
  
  #### Example:
  
  ```mlir
  %0 = spirv.GroupSMin <Workgroup> <Reduce> %value : i32
  ```
  """

  OPERATION_NAME = "spirv.GroupSMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupSMin(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupSMinOp(execution_scope=execution_scope, group_operation=group_operation, x=x, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupUMaxOp(_ods_ir.OpView):
  r"""
  Behavior is undefined if not all invocations of this module within
  Execution reach this point of execution.
  
  Behavior is undefined unless all invocations within Execution execute
  the same dynamic instance of this instruction.
  
  Result Type  must be a scalar or vector of integer type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
  The identity I for Operation is 0.
  
  The type of X must be the same as Result Type.
  
  #### Example:
  
  ```mlir
  %0 = spirv.GroupUMax <Workgroup> <Reduce> %value : i32
  ```
  """

  OPERATION_NAME = "spirv.GroupUMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupUMax(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupUMaxOp(execution_scope=execution_scope, group_operation=group_operation, x=x, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GroupUMinOp(_ods_ir.OpView):
  r"""
  Behavior is undefined if not all invocations of this module within
  Execution reach this point of execution.
  
  Behavior is undefined unless all invocations within Execution execute
  the same dynamic instance of this instruction.
  
  Result Type  must be a scalar or vector of integer type.
  
  Execution is a Scope. It must be either Workgroup or Subgroup.
  
  The identity I for Operation is UINT_MAX when X is 32 bits wide and
  ULONG_MAX when X is 64 bits wide.
  
  The type of X must be the same as Result Type.
  
  #### Example:
  
  ```mlir
  %0 = spirv.GroupUMin <Workgroup> <Reduce> %value : i32
  ```
  """

  OPERATION_NAME = "spirv.GroupUMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, group_operation, x, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["group_operation"] = (group_operation if (
    isinstance(group_operation, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_GroupOperationAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_GroupOperationAttr')(group_operation, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def group_operation(self) -> _ods_ir.Attribute:
    return self.operation.attributes["group_operation"]

  @group_operation.setter
  def group_operation(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["group_operation"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def GroupUMin(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GroupUMinOp(execution_scope=execution_scope, group_operation=group_operation, x=x, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IAddCarryOp(_ods_ir.OpView):
  r"""
  Result Type must be from OpTypeStruct.  The struct must have two
  members, and the two members must be the same type.  The member type
  must be a scalar or vector of integer type, whose Signedness operand is
  0.
  
  Operand 1 and Operand 2 must have the same type as the members of Result
  Type. These are consumed as unsigned integers.
  
   Results are computed per component.
  
  Member 0 of the result gets the low-order bits (full component width) of
  the addition.
  
  Member 1 of the result gets the high-order (carry) bit of the result of
  the addition. That is, it gets the value 1 if the addition overflowed
  the component width, and 0 otherwise.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %2 = spirv.IAddCarry %0, %1 : !spirv.struct<(i32, i32)>
  %2 = spirv.IAddCarry %0, %1 : !spirv.struct<(vector<2xi32>, vector<2xi32>)>
  ```
  """

  OPERATION_NAME = "spirv.IAddCarry"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand1, operand2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def IAddCarry(result, operand1, operand2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return IAddCarryOp(result=result, operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IAddOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  integer type.  They must have the same number of components as Result
  Type. They must have the same component width as Result Type.
  
  The resulting value will equal the low-order N bits of the correct
  result R, where N is the component width and R is computed with enough
  precision to avoid overflow and underflow.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.IAdd %0, %1 : i32
  %5 = spirv.IAdd %2, %3 : vector<4xi32>
  
  ```
  """

  OPERATION_NAME = "spirv.IAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def IAdd(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IAddOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  integer type.  They must have the same component width, and they must
  have the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.IEqual %0, %1 : i32
  %5 = spirv.IEqual %2, %3 : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.IEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def IEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IEqualOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IMulOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  integer type.  They must have the same number of components as Result
  Type. They must have the same component width as Result Type.
  
  The resulting value will equal the low-order N bits of the correct
  result R, where N is the component width and R is computed with enough
  precision to avoid overflow and underflow.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.IMul %0, %1 : i32
  %5 = spirv.IMul %2, %3 : vector<4xi32>
  
  ```
  """

  OPERATION_NAME = "spirv.IMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def IMul(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IMulOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class INTELControlBarrierArriveOp(_ods_ir.OpView):
  r"""
  Indicates that an invocation has arrived at a split control barrier. This
  may allow other invocations waiting on the split control barrier to continue
  executing.
  
  When `Execution` is `Workgroup` or larger, behavior is undefined unless all
  invocations within `Execution` execute the same dynamic instance of this
  instruction. When `Execution` is `Subgroup` or `Invocation`, the behavior of
  this instruction in non-uniform control flow is defined by the client API.
  
  If `Semantics` is not `None`, this instruction also serves as the start of a
  memory barrier similar to an `OpMemoryBarrier` instruction with the same
  `Memory` and `Semantics` operands. This allows atomically specifying both a
  control barrier and a memory barrier (that is, without needing two
  instructions). If `Semantics` is `None`, `Memory` is ignored.
  
  #### Example:
  
  ```mlir
  spirv.ControlBarrierArrive <Workgroup> <Device> <Acquire|UniformMemory>
  ```
  """

  OPERATION_NAME = "spirv.INTEL.ControlBarrierArrive"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["memory_semantics"] = (memory_semantics if (
    isinstance(memory_semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(memory_semantics, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def memory_semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_semantics"]

  @memory_semantics.setter
  def memory_semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_semantics"] = value

def INTEL_ControlBarrierArrive(execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None) -> INTELControlBarrierArriveOp:
  return INTELControlBarrierArriveOp(execution_scope=execution_scope, memory_scope=memory_scope, memory_semantics=memory_semantics, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class INTELControlBarrierWaitOp(_ods_ir.OpView):
  r"""
  Waits for other invocations of this module to arrive at a split control
  barrier.
  
  When `Execution` is `Workgroup` or larger, behavior is undefined unless all
  invocations within `Execution` execute the same dynamic instance of this
  instruction. When `Execution` is `Subgroup` or `Invocation`, the behavior of
  this instruction in non-uniform control flow is defined by the client API.
  
  If `Semantics` is not `None`, this instruction also serves as the end of a
  memory barrier similar to an `OpMemoryBarrier` instruction with the same
  `Memory` and `Semantics` operands. This ensures that memory accesses issued
  before arriving at the split barrier are observed before memory accesses
  issued after this instruction. This control is ensured only for memory
  accesses issued by this invocation and observed by another invocation
  executing within `Memory` scope. This allows atomically specifying both a
  control barrier and a memory barrier (that is, without needing two
  instructions). If `Semantics` is `None`, `Memory` is ignored.
  
  #### Example:
  
  ```mlir
  spirv.ControlBarrierWait <Workgroup> <Device> <Acquire|UniformMemory>
  ```
  """

  OPERATION_NAME = "spirv.INTEL.ControlBarrierWait"

  _ODS_REGIONS = (0, True)

  def __init__(self, execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["execution_scope"] = (execution_scope if (
    isinstance(execution_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(execution_scope, context=_ods_context))
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["memory_semantics"] = (memory_semantics if (
    isinstance(memory_semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(memory_semantics, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def execution_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["execution_scope"]

  @execution_scope.setter
  def execution_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["execution_scope"] = value

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def memory_semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_semantics"]

  @memory_semantics.setter
  def memory_semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_semantics"] = value

def INTEL_ControlBarrierWait(execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None) -> INTELControlBarrierWaitOp:
  return INTELControlBarrierWaitOp(execution_scope=execution_scope, memory_scope=memory_scope, memory_semantics=memory_semantics, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class INTELConvertBF16ToFOp(_ods_ir.OpView):
  r"""
  Interpret a 16-bit integer as bfloat16 and convert the value numerically to 32-bit floating point type.
  
  Result Type must be a scalar or vector of floating-point. The component width must be 32 bits.
  
  Bfloat16 Value must be a scalar or vector of integer type, which is interpreted as a bfloat16 type.
  The type must have the same number of components as the Result Type. The component width must be 16 bits.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %1 = spirv.ConvertBF16ToF %0 : i16 to f32
  %3 = spirv.ConvertBF16ToF %2 : vector<3xi16> to vector<3xf32>
  ```
  
  """

  OPERATION_NAME = "spirv.INTEL.ConvertBF16ToF"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def INTEL_ConvertBF16ToF(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return INTELConvertBF16ToFOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class INTELConvertFToBF16Op(_ods_ir.OpView):
  r"""
  Convert value numerically from 32-bit floating point to bfloat16,
  which is represented as a 16-bit unsigned integer.
  
  Result Type must be a scalar or vector of integer type.
  The component width must be 16 bits. Bit pattern in the Result represents a bfloat16 value.
  
  Float Value must be a scalar or vector of floating-point type.
  It must have the same number of components as Result Type. The component width must be 32 bits.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %1 = spirv.ConvertFToBF16 %0 : f32 to i16
  %3 = spirv.ConvertFToBF16 %2 : vector<3xf32> to vector<3xi16>
  ```
  
  """

  OPERATION_NAME = "spirv.INTEL.ConvertFToBF16"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def INTEL_ConvertFToBF16(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return INTELConvertFToBF16Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class INTELRoundFToTF32Op(_ods_ir.OpView):
  r"""
  Convert value numerically from a 32-bit floating point type to tensor float32,
  with rounding to the nearest even.
  
  Result Type must be a scalar or vector of 32-bit floating-point type.
  The component width must be 32 bits. Bit pattern in the Result represents a tensor float32 value.
  
  Float Value must be a scalar or vector of floating-point type.
  It must have the same number of components as Result Type. The component width must be 32 bits.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %1 = spirv.RoundFToTF32 %0 : f32 to f32
  %3 = spirv.RoundFToTF32 %2 : vector<3xf32> to vector<3xf32>
  ```
  
  """

  OPERATION_NAME = "spirv.INTEL.RoundFToTF32"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def INTEL_RoundFToTF32(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return INTELRoundFToTF32Op(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class INTELSubgroupBlockReadOp(_ods_ir.OpView):
  r"""
  Reads one or more components of Result data for each invocation in the
  subgroup from the specified Ptr as a block operation.
  
  The data is read strided, so the first value read is:
  Ptr[ SubgroupLocalInvocationId ]
  
  and the second value read is:
  Ptr[ SubgroupLocalInvocationId + SubgroupMaxSize ]
  etc.
  
  Result Type may be a scalar or vector type, and its component type must be
  equal to the type pointed to by Ptr.
  
  The type of Ptr must be a pointer type, and must point to a scalar type.
  
  <!-- End of AutoGen section -->
  
  ```
  subgroup-block-read-INTEL-op ::= ssa-id `=` `spirv.INTEL.SubgroupBlockRead`
                              storage-class ssa_use `:` spirv-element-type
  ```
  
  #### Example:
  
  ```mlir
  %0 = spirv.INTEL.SubgroupBlockRead "StorageBuffer" %ptr : i32
  ```
  """

  OPERATION_NAME = "spirv.INTEL.SubgroupBlockRead"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, ptr, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def INTEL_SubgroupBlockRead(value, ptr, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return INTELSubgroupBlockReadOp(value=value, ptr=ptr, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class INTELSubgroupBlockWriteOp(_ods_ir.OpView):
  r"""
  Writes one or more components of Data for each invocation in the subgroup
  from the specified Ptr as a block operation.
  
  The data is written strided, so the first value is written to:
  Ptr[ SubgroupLocalInvocationId ]
  
  and the second value written is:
  Ptr[ SubgroupLocalInvocationId + SubgroupMaxSize ]
  etc.
  
  The type of Ptr must be a pointer type, and must point to a scalar type.
  
  The component type of Data must be equal to the type pointed to by Ptr.
  
  <!-- End of AutoGen section -->
  
  ```
  subgroup-block-write-INTEL-op ::= ssa-id `=` `spirv.INTEL.SubgroupBlockWrite`
                    storage-class ssa_use `,` ssa-use `:` spirv-element-type
  ```
  
  #### Example:
  
  ```mlir
  spirv.INTEL.SubgroupBlockWrite "StorageBuffer" %ptr, %value : i32
  ```
  """

  OPERATION_NAME = "spirv.INTEL.SubgroupBlockWrite"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def INTEL_SubgroupBlockWrite(ptr, value, *, loc=None, ip=None) -> INTELSubgroupBlockWriteOp:
  return INTELSubgroupBlockWriteOp(ptr=ptr, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class INotEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  integer type.  They must have the same component width, and they must
  have the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.INotEqual %0, %1 : i32
  %5 = spirv.INotEqual %2, %3 : vector<4xi32>
  
  ```
  """

  OPERATION_NAME = "spirv.INotEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def INotEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return INotEqualOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ISubBorrowOp(_ods_ir.OpView):
  r"""
  Result Type must be from OpTypeStruct.  The struct must have two
  members, and the two members must be the same type.  The member type
  must be a scalar or vector of integer type, whose Signedness operand is
  0.
  
  Operand 1 and Operand 2 must have the same type as the members of Result
  Type. These are consumed as unsigned integers.
  
   Results are computed per component.
  
  Member 0 of the result gets the low-order bits (full component width) of
  the subtraction. That is, if Operand 1 is larger than Operand 2, member
  0 gets the full value of the subtraction;  if Operand 2 is larger than
  Operand 1, member 0 gets 2w + Operand 1 - Operand 2, where w is the
  component width.
  
  Member 1 of the result gets 0 if Operand 1 ≥ Operand 2, and gets 1
  otherwise.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %2 = spirv.ISubBorrow %0, %1 : !spirv.struct<(i32, i32)>
  %2 = spirv.ISubBorrow %0, %1 : !spirv.struct<(vector<2xi32>, vector<2xi32>)>
  ```
  """

  OPERATION_NAME = "spirv.ISubBorrow"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand1, operand2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ISubBorrow(result, operand1, operand2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ISubBorrowOp(result=result, operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ISubOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  integer type.  They must have the same number of components as Result
  Type. They must have the same component width as Result Type.
  
  The resulting value will equal the low-order N bits of the correct
  result R, where N is the component width and R is computed with enough
  precision to avoid overflow and underflow.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.ISub %0, %1 : i32
  %5 = spirv.ISub %2, %3 : vector<4xi32>
  
  ```
  """

  OPERATION_NAME = "spirv.ISub"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ISub(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ISubOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImageDrefGatherOp(_ods_ir.OpView):
  r"""
  Result Type must be a vector of four components of floating-point type
  or integer type. Its components must be the same as Sampled Type of the
  underlying OpTypeImage (unless that underlying Sampled Type is
  OpTypeVoid). It has one component per gathered texel.
  
  Sampled Image must be an object whose type is OpTypeSampledImage. Its
  OpTypeImage must have a Dim of 2D, Cube, or Rect. The MS operand of the
  underlying OpTypeImage must be 0.
  
  Coordinate must be a scalar or vector of floating-point type. It
  contains (u[, v] ... [, array layer]) as needed by the definition of
  Sampled Image.
  
  Dref is the depth-comparison reference value. It must be a 32-bit
  floating-point type scalar.
  
  Image Operands encodes what operands follow, as per Image Operands.
  
  #### Example:
  
  ```mlir
  %0 = spirv.ImageDrefGather %1, %2, %3 : !spirv.sampled_image<!spirv.image<i32, Dim2D, NoDepth, NonArrayed, SingleSampled, NoSampler, Unknown>>, vector<4xf32>, f32 -> vector<4xi32>
  %0 = spirv.ImageDrefGather %1, %2, %3 ["NonPrivateTexel"] : !spirv.sampled_image<!spirv.image<i32, Dim2D, NoDepth, NonArrayed, SingleSampled, NoSampler, Unknown>>, vector<4xf32>, f32 -> vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.ImageDrefGather"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, sampled_image, coordinate, dref, operand_arguments, *, image_operands=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(sampled_image)
    operands.append(coordinate)
    operands.append(dref)
    operands.extend(_get_op_results_or_values(operand_arguments))
    _ods_context = _ods_get_default_loc_context(loc)
    if image_operands is not None: attributes["image_operands"] = (image_operands if (
        isinstance(image_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_ImageOperandsAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_ImageOperandsAttr')(image_operands, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sampled_image(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def coordinate(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def dref(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def operand_arguments(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3:3 + _ods_variadic_group_length]

  @builtins.property
  def image_operands(self) -> _Optional[_ods_ir.Attribute]:
    if "image_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["image_operands"]

  @image_operands.setter
  def image_operands(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["image_operands"] = value
    elif "image_operands" in self.operation.attributes:
      del self.operation.attributes["image_operands"]

  @image_operands.deleter
  def image_operands(self):
    del self.operation.attributes["image_operands"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ImageDrefGather(result, sampled_image, coordinate, dref, operand_arguments, *, image_operands=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ImageDrefGatherOp(result=result, sampled_image=sampled_image, coordinate=coordinate, dref=dref, operand_arguments=operand_arguments, image_operands=image_operands, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImageFetchOp(_ods_ir.OpView):
  r"""
  Result Type must be a vector of four components of floating-point type or
  integer type. Its components must be the same as Sampled Type of the underlying
  OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).
  
  Image must be an object whose type is OpTypeImage. Its Dim operand must not be
  Cube, and its Sampled operand must be 1.
  
  Coordinate must be a scalar or vector of integer type. It contains (u[, v] … [,
  array layer]) as needed by the definition of Sampled Image.
  
  Image Operands encodes what operands follow, as per Image Operands.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.ImageFetch %1, %2 : !spirv.image<f32, Dim2D, NoDepth, NonArrayed, SingleSampled, NeedSampler, R32f>, vector<2xsi32> -> vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.ImageFetch"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, image, coordinate, operand_arguments, *, image_operands=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(image)
    operands.append(coordinate)
    operands.extend(_get_op_results_or_values(operand_arguments))
    _ods_context = _ods_get_default_loc_context(loc)
    if image_operands is not None: attributes["image_operands"] = (image_operands if (
        isinstance(image_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_ImageOperandsAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_ImageOperandsAttr')(image_operands, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def image(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def coordinate(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def operand_arguments(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def image_operands(self) -> _Optional[_ods_ir.Attribute]:
    if "image_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["image_operands"]

  @image_operands.setter
  def image_operands(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["image_operands"] = value
    elif "image_operands" in self.operation.attributes:
      del self.operation.attributes["image_operands"]

  @image_operands.deleter
  def image_operands(self):
    del self.operation.attributes["image_operands"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ImageFetch(result, image, coordinate, operand_arguments, *, image_operands=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ImageFetchOp(result=result, image=image, coordinate=coordinate, operand_arguments=operand_arguments, image_operands=image_operands, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImageOp(_ods_ir.OpView):
  r"""
  Result Type must be OpTypeImage.
  
  Sampled Image must have type OpTypeSampledImage whose Image Type is the
  same as Result Type.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.Image %1 : !spirv.sampled_image<!spirv.image<f32, Cube, NoDepth, NonArrayed, SingleSampled, NoSampler, Unknown>>
  ```
  """

  OPERATION_NAME = "spirv.Image"

  _ODS_REGIONS = (0, True)

  def __init__(self, sampled_image, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(sampled_image)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sampled_image(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Image(sampled_image, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ImageOp(sampled_image=sampled_image, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImageQuerySizeOp(_ods_ir.OpView):
  r"""
  Result Type must be an integer type scalar or vector. The number of
  components must be:
  
  1 for the 1D and Buffer dimensionalities,
  
  2 for the 2D, Cube, and Rect dimensionalities,
  
  3 for the 3D dimensionality,
  
  plus 1 more if the image type is arrayed. This vector is filled in with
  (width [, height] [, elements]) where elements is the number of layers
  in an image array or the number of cubes in a cube-map array.
  
  Image must be an object whose type is OpTypeImage. Its Dim operand must
  be one of those listed under Result Type, above. Additionally, if its
  Dim is 1D, 2D, 3D, or Cube, it must also have either an MS of 1 or a
  Sampled of 0 or 2. There is no implicit level-of-detail consumed by this
  instruction. See OpImageQuerySizeLod for querying images having level of
  detail. This operation is allowed on an image decorated as NonReadable.
  See the client API specification for additional image type restrictions.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %3 = spirv.ImageQuerySize %0 : !spirv.image<i32, Dim1D, NoDepth, NonArrayed, SingleSampled, NoSampler, Unknown> -> i32
  %4 = spirv.ImageQuerySize %1 : !spirv.image<i32, Dim2D, NoDepth, NonArrayed, SingleSampled, NoSampler, Unknown> -> vector<2xi32>
  %5 = spirv.ImageQuerySize %2 : !spirv.image<i32, Dim2D, NoDepth, Arrayed, SingleSampled, NoSampler, Unknown> -> vector<3xi32>
  ```
  
  """

  OPERATION_NAME = "spirv.ImageQuerySize"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, image, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(image)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def image(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ImageQuerySize(result, image, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ImageQuerySizeOp(result=result, image=image, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImageReadOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of floating-point type or integer
  type. It must be a scalar or vector with component type the same as Sampled
  Type of the OpTypeImage (unless that Sampled Type is OpTypeVoid).
  
  Image must be an object whose type is OpTypeImage with a Sampled operand of
  0 or 2. If the Arrayed operand is 1, then additional capabilities may be
  required; e.g., ImageCubeArray, or ImageMSArray.
  
  Coordinate must be a scalar or vector of floating-point type or integer
  type. It contains non-normalized texel coordinates (u[, v] ... [, array
  layer]) as needed by the definition of Image. See the client API
  specification for handling of coordinates outside the image.
  
  If the Image Dim operand is SubpassData, Coordinate is relative to the
  current fragment location. See the client API specification for more detail
  on how these coordinates are applied.
  
  If the Image Dim operand is not SubpassData, the Image Format must not be
  Unknown, unless the StorageImageReadWithoutFormat Capability was declared.
  
  Image Operands encodes what operands follow, as per Image Operands.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.ImageRead %1, %2 : !spirv.image<f32, Dim2D, NoDepth, NonArrayed, SingleSampled, NoSampler, R32f>, vector<2xsi32> -> vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.ImageRead"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, image, coordinate, operand_arguments, *, image_operands=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(image)
    operands.append(coordinate)
    operands.extend(_get_op_results_or_values(operand_arguments))
    _ods_context = _ods_get_default_loc_context(loc)
    if image_operands is not None: attributes["image_operands"] = (image_operands if (
        isinstance(image_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_ImageOperandsAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_ImageOperandsAttr')(image_operands, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def image(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def coordinate(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def operand_arguments(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def image_operands(self) -> _Optional[_ods_ir.Attribute]:
    if "image_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["image_operands"]

  @image_operands.setter
  def image_operands(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["image_operands"] = value
    elif "image_operands" in self.operation.attributes:
      del self.operation.attributes["image_operands"]

  @image_operands.deleter
  def image_operands(self):
    del self.operation.attributes["image_operands"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ImageRead(result, image, coordinate, operand_arguments, *, image_operands=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ImageReadOp(result=result, image=image, coordinate=coordinate, operand_arguments=operand_arguments, image_operands=image_operands, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImageSampleExplicitLodOp(_ods_ir.OpView):
  r"""
  Result Type must be a vector of four components of floating-point type
  or integer type. Its components must be the same as Sampled Type of the
  underlying OpTypeImage (unless that underlying Sampled Type is
  OpTypeVoid).
  
  Sampled Image must be an object whose type is OpTypeSampledImage. Its
  OpTypeImage must not have a Dim of Buffer. The MS operand of the
  underlying OpTypeImage must be 0.
  
  Coordinate must be a scalar or vector of floating-point type or integer
  type. It contains (u[, v] ... [, array layer]) as needed by the
  definition of Sampled Image. Unless the Kernel capability is declared,
  it must be floating point. It may be a vector larger than needed, but
  all unused components appear after all used components.
  
  Image Operands encodes what operands follow, as per Image Operands.
  Either Lod or Grad image operands must be present.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %result = spirv.ImageSampleExplicitLod %image, %coord ["Lod"](%lod) :
    !spirv.sampled_image<!spirv.image<f32, Dim2D, NoDepth, NonArrayed, SingleSampled, NeedSampler, Unknown>>,
    vector<2xf32> (f32) -> vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.ImageSampleExplicitLod"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, sampled_image, coordinate, image_operands, operand_arguments, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(sampled_image)
    operands.append(coordinate)
    operands.extend(_get_op_results_or_values(operand_arguments))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["image_operands"] = (image_operands if (
    isinstance(image_operands, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ImageOperandsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ImageOperandsAttr')(image_operands, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sampled_image(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def coordinate(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def operand_arguments(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def image_operands(self) -> _ods_ir.Attribute:
    return self.operation.attributes["image_operands"]

  @image_operands.setter
  def image_operands(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["image_operands"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ImageSampleExplicitLod(result, sampled_image, coordinate, image_operands, operand_arguments, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ImageSampleExplicitLodOp(result=result, sampled_image=sampled_image, coordinate=coordinate, image_operands=image_operands, operand_arguments=operand_arguments, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImageSampleImplicitLodOp(_ods_ir.OpView):
  r"""
  An invocation will not execute a dynamic instance of this instruction
  (X') until all invocations in its derivative group have executed all
  dynamic instances that are program-ordered before X'.
  
  Result Type must be a vector of four components of floating-point type
  or integer type. Its components must be the same as Sampled Type of the
  underlying OpTypeImage (unless that underlying Sampled Type is
  OpTypeVoid).
  
  Sampled Image must be an object whose type is OpTypeSampledImage. Its
  OpTypeImage must not have a Dim of Buffer. The MS operand of the
  underlying OpTypeImage must be 0.
  
  Coordinate must be a scalar or vector of floating-point type. It
  contains (u[, v] ... [, array layer]) as needed by the definition of
  Sampled Image. It may be a vector larger than needed, but all unused
  components appear after all used components.
  
  Image Operands encodes what operands follow, as per Image Operands.
  
  This instruction is only valid in the Fragment Execution Model. In
  addition, it consumes an implicit derivative that can be affected by
  code motion.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %result = spirv.ImageSampleImplicitLod %image, %coord :
    !spirv.sampled_image<!spirv.image<f32, Cube, NoDepth, NonArrayed, SingleSampled, NeedSampler, Unknown>>,
    vector<3xf32> -> vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.ImageSampleImplicitLod"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, sampled_image, coordinate, operand_arguments, *, image_operands=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(sampled_image)
    operands.append(coordinate)
    operands.extend(_get_op_results_or_values(operand_arguments))
    _ods_context = _ods_get_default_loc_context(loc)
    if image_operands is not None: attributes["image_operands"] = (image_operands if (
        isinstance(image_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_ImageOperandsAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_ImageOperandsAttr')(image_operands, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sampled_image(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def coordinate(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def operand_arguments(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def image_operands(self) -> _Optional[_ods_ir.Attribute]:
    if "image_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["image_operands"]

  @image_operands.setter
  def image_operands(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["image_operands"] = value
    elif "image_operands" in self.operation.attributes:
      del self.operation.attributes["image_operands"]

  @image_operands.deleter
  def image_operands(self):
    del self.operation.attributes["image_operands"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ImageSampleImplicitLod(result, sampled_image, coordinate, operand_arguments, *, image_operands=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ImageSampleImplicitLodOp(result=result, sampled_image=sampled_image, coordinate=coordinate, operand_arguments=operand_arguments, image_operands=image_operands, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImageSampleProjDrefImplicitLodOp(_ods_ir.OpView):
  r"""
  An invocation will not execute a dynamic instance of this instruction
  (X') until all invocations in its derivative group have executed all
  dynamic instances that are program-ordered before X'.
  
  Result Type must be a scalar of integer type or floating-point type. It
  must be the same as Sampled Type of the underlying OpTypeImage.
  
  Sampled Image must be an object whose type is OpTypeSampledImage. The
  Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,
  and the Arrayed and MS operands must be 0.
  
  Coordinate must be a vector of floating-point type. It contains (u[,
  v] [, w], q), as needed by the definition of Sampled Image, with the q
  component consumed for the projective division. That is, the actual
  sample coordinate is (u/q [, v/q] [, w/q]), as needed by the definition
  of Sampled Image. It may be a vector larger than needed, but all unused
  components appear after all used components.
  
  Dref/q is the depth-comparison reference value. Dref must be a 32-bit
  floating-point type scalar.
  
  Image Operands encodes what operands follow, as per Image Operands.
  
  This instruction is only valid in the Fragment Execution Model. In
  addition, it consumes an implicit derivative that can be affected by
  code motion.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %result = spirv.ImageSampleProjDrefImplicitLod %image, %coord, %dref :
    !spirv.sampled_image<!spirv.image<f32, Dim2D, IsDepth, NonArrayed, SingleSampled, NeedSampler, Unknown>>,
    vector<4xf16>, f32 -> f32
  ```
  """

  OPERATION_NAME = "spirv.ImageSampleProjDrefImplicitLod"

  _ODS_REGIONS = (0, True)

  def __init__(self, sampled_image, coordinate, dref, operand_arguments, *, image_operands=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(sampled_image)
    operands.append(coordinate)
    operands.append(dref)
    operands.extend(_get_op_results_or_values(operand_arguments))
    _ods_context = _ods_get_default_loc_context(loc)
    if image_operands is not None: attributes["image_operands"] = (image_operands if (
        isinstance(image_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_ImageOperandsAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_ImageOperandsAttr')(image_operands, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sampled_image(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def coordinate(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def dref(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def operand_arguments(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3:3 + _ods_variadic_group_length]

  @builtins.property
  def image_operands(self) -> _Optional[_ods_ir.Attribute]:
    if "image_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["image_operands"]

  @image_operands.setter
  def image_operands(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["image_operands"] = value
    elif "image_operands" in self.operation.attributes:
      del self.operation.attributes["image_operands"]

  @image_operands.deleter
  def image_operands(self):
    del self.operation.attributes["image_operands"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ImageSampleProjDrefImplicitLod(sampled_image, coordinate, dref, operand_arguments, *, image_operands=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ImageSampleProjDrefImplicitLodOp(sampled_image=sampled_image, coordinate=coordinate, dref=dref, operand_arguments=operand_arguments, image_operands=image_operands, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ImageWriteOp(_ods_ir.OpView):
  r"""
  Image must be an object whose type is OpTypeImage with a Sampled operand
  of 0 or 2. If the Arrayed operand is 1, then additional capabilities may
  be required; e.g., ImageCubeArray, or ImageMSArray. Its Dim operand
  must not be SubpassData.
  
  Coordinate must be a scalar or vector of floating-point type or integer
  type. It contains non-normalized texel coordinates (u[, v] ... [, array
  layer]) as needed by the definition of Image. See the client API
  specification for handling of coordinates outside the image.
  
  Texel is the data to write. It must be a scalar or vector with component
  type the same as Sampled Type of the OpTypeImage (unless that Sampled
  Type is OpTypeVoid).
  
  The Image Format must not be Unknown, unless the
  StorageImageWriteWithoutFormat Capability was declared.
  
  Image Operands encodes what operands follow, as per Image Operands.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  spirv.ImageWrite %0, %1, %2 : !spirv.image<f32, Dim2D, NoDepth, NonArrayed, SingleSampled, NoSampler, Rgba16>, vector<2xsi32>, vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.ImageWrite"

  _ODS_REGIONS = (0, True)

  def __init__(self, image, coordinate, texel, operand_arguments, *, image_operands=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(image)
    operands.append(coordinate)
    operands.append(texel)
    operands.extend(_get_op_results_or_values(operand_arguments))
    _ods_context = _ods_get_default_loc_context(loc)
    if image_operands is not None: attributes["image_operands"] = (image_operands if (
        isinstance(image_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_ImageOperandsAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_ImageOperandsAttr')(image_operands, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def image(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def coordinate(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def texel(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def operand_arguments(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 4 + 1
    return self.operation.operands[3:3 + _ods_variadic_group_length]

  @builtins.property
  def image_operands(self) -> _Optional[_ods_ir.Attribute]:
    if "image_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["image_operands"]

  @image_operands.setter
  def image_operands(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["image_operands"] = value
    elif "image_operands" in self.operation.attributes:
      del self.operation.attributes["image_operands"]

  @image_operands.deleter
  def image_operands(self):
    del self.operation.attributes["image_operands"]

def ImageWrite(image, coordinate, texel, operand_arguments, *, image_operands=None, loc=None, ip=None) -> ImageWriteOp:
  return ImageWriteOp(image=image, coordinate=coordinate, texel=texel, operand_arguments=operand_arguments, image_operands=image_operands, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InBoundsPtrAccessChainOp(_ods_ir.OpView):
  r"""
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  func @inbounds_ptr_access_chain(%arg0: !spirv.ptr<f32, CrossWorkgroup>, %arg1 : i64) -> () {
    %0 = spirv.InBoundsPtrAccessChain %arg0[%arg1] : !spirv.ptr<f32, CrossWorkgroup>, i64 -> !spirv.ptr<f32, CrossWorkgroup>
    ...
  }
  ```
  """

  OPERATION_NAME = "spirv.InBoundsPtrAccessChain"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, base_ptr, element, indices, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(base_ptr)
    operands.append(element)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def base_ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def element(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def InBoundsPtrAccessChain(result, base_ptr, element, indices, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return InBoundsPtrAccessChainOp(result=result, base_ptr=base_ptr, element=element, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IsFiniteOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  x must be a scalar or vector of floating-point type.  It must have the
  same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.IsFinite %0: f32
  %3 = spirv.IsFinite %1: vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.IsFinite"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def IsFinite(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IsFiniteOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IsInfOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  x must be a scalar or vector of floating-point type.  It must have the
  same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.IsInf %0: f32
  %3 = spirv.IsInf %1: vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.IsInf"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def IsInf(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IsInfOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class IsNanOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  x must be a scalar or vector of floating-point type.  It must have the
  same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.IsNan %0: f32
  %3 = spirv.IsNan %1: vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.IsNan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def IsNan(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IsNanOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class KHRAssumeTrueOp(_ods_ir.OpView):
  r"""
  <!-- End of AutoGen section -->
  
  ```
  assumetruekhr-op ::= `spirv.KHR.AssumeTrue` ssa-use
  ```
  
  #### Example:
  
  ```mlir
  spirv.KHR.AssumeTrue %arg
  ```
  """

  OPERATION_NAME = "spirv.KHR.AssumeTrue"

  _ODS_REGIONS = (0, True)

  def __init__(self, condition, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(condition)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def KHR_AssumeTrue(condition, *, loc=None, ip=None) -> KHRAssumeTrueOp:
  return KHRAssumeTrueOp(condition=condition, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class KHRCooperativeMatrixLengthOp(_ods_ir.OpView):
  r"""
  Number of components of a cooperative matrix type accessible to each
  invocation when treated as a composite.
  
  The type attribute must be a cooperative matrix type.
  
  #### Example:
  
  ```
  %0 = spirv.KHR.CooperativeMatrixLength :
         !spirv.coopmatrix<8x16xi32, Subgroup, MatrixA>
  ```
  """

  OPERATION_NAME = "spirv.KHR.CooperativeMatrixLength"

  _ODS_REGIONS = (0, True)

  def __init__(self, cooperative_matrix_type, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["cooperative_matrix_type"] = (cooperative_matrix_type if (
    isinstance(cooperative_matrix_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_1715')) else
      _ods_ir.AttrBuilder.get('anonymous_1715')(cooperative_matrix_type, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def cooperative_matrix_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["cooperative_matrix_type"]

  @cooperative_matrix_type.setter
  def cooperative_matrix_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["cooperative_matrix_type"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def KHR_CooperativeMatrixLength(cooperative_matrix_type, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return KHRCooperativeMatrixLengthOp(cooperative_matrix_type=cooperative_matrix_type, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class KHRCooperativeMatrixLoadOp(_ods_ir.OpView):
  r"""
  Load a cooperative matrix through a pointer.
  
  Result Type is the type of the loaded object. It must be a cooperative
  matrix type.
  
  Pointer is a pointer. Its type must be an OpTypePointer whose Type operand is
  a scalar or vector type. If the Shader capability was declared, Pointer must
  point into an array and any ArrayStride decoration on Pointer is ignored.
  
  MemoryLayout specifies how matrix elements are laid out in memory. It must
  come from a 32-bit integer constant instruction whose value corresponds to a
  Cooperative Matrix Layout. See the Cooperative Matrix Layout table for a
  description of the layouts and detailed layout-specific rules.
  
  Stride further qualifies how matrix elements are laid out in memory. It must
  be a scalar integer type and its exact semantics depend on MemoryLayout.
  
  Memory Operand must be a Memory Operand literal. If not present, it is the
  same as specifying None.
  
  NOTE: In earlier versions of the SPIR-V spec, 'Memory Operand' was known
  as 'Memory Access'.
  
  For a given dynamic instance of this instruction, all operands of this
  instruction must be the same for all invocations in a given scope instance
  (where the scope is the scope the cooperative matrix type was created with).
  All invocations in a given scope instance must be active or all must be
  inactive.
  
  TODO: In the SPIR-V spec, `stride` is an optional argument. We should also
  support this optionality in the SPIR-V dialect.
  
  #### Example:
  
  ```
  %0 = spirv.KHR.CooperativeMatrixLoad %ptr, %stride, <RowMajor>
       : !spirv.ptr<i32, StorageBuffer>, i32
           -> !spirv.KHR.coopmatrix<16x8xi32, Workgroup, MatrixA>
  
  %1 = spirv.KHR.CooperativeMatrixLoad %ptr, %stride, <ColumnMajor>, <Volatile>
       : !spirv.ptr<f32, StorageBuffer>, i64
           -> !spirv.KHR.coopmatrix<8x8xf32, Subgroup, MatrixAcc>
  ```
  """

  OPERATION_NAME = "spirv.KHR.CooperativeMatrixLoad"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, pointer, matrix_layout, stride, *, memory_operand=None, alignment=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(stride)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["matrix_layout"] = (matrix_layout if (
    isinstance(matrix_layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_KHR_CooperativeMatrixLayoutAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_KHR_CooperativeMatrixLayoutAttr')(matrix_layout, context=_ods_context))
    if memory_operand is not None: attributes["memory_operand"] = (memory_operand if (
        isinstance(memory_operand, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_MemoryAccessAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_MemoryAccessAttr')(memory_operand, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(alignment, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def stride(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def matrix_layout(self) -> _ods_ir.Attribute:
    return self.operation.attributes["matrix_layout"]

  @matrix_layout.setter
  def matrix_layout(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["matrix_layout"] = value

  @builtins.property
  def memory_operand(self) -> _Optional[_ods_ir.Attribute]:
    if "memory_operand" not in self.operation.attributes:
      return None
    return self.operation.attributes["memory_operand"]

  @memory_operand.setter
  def memory_operand(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["memory_operand"] = value
    elif "memory_operand" in self.operation.attributes:
      del self.operation.attributes["memory_operand"]

  @memory_operand.deleter
  def memory_operand(self):
    del self.operation.attributes["memory_operand"]

  @builtins.property
  def alignment(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def KHR_CooperativeMatrixLoad(result, pointer, matrix_layout, stride, *, memory_operand=None, alignment=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return KHRCooperativeMatrixLoadOp(result=result, pointer=pointer, matrix_layout=matrix_layout, stride=stride, memory_operand=memory_operand, alignment=alignment, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class KHRCooperativeMatrixMulAddOp(_ods_ir.OpView):
  r"""
  Linear-algebraic matrix multiply of A by B and then component-wise add C.
  The order of the operations is implementation-dependent. The internal
  precision of floating-point operations is defined by the client API. Integer
  operations used in the multiplication of A by B are performed at the
  precision of the Result Type and the resulting value will equal the
  low-order N bits of the correct result R, where N is the result width and R
  is computed with enough precision to avoid overflow and underflow if the
  SaturatingAccumulation Cooperative Matrix Operand is not present. If the
  SaturatingAccumulation Cooperative Matrix Operand is present and overflow or
  underflow occurs as part of calculating that intermediate result, the result
  of the instruction is undefined. Integer additions of the elements of that
  intermediate result with those of C are performed at the precision of Result
  Type, are exact, and are saturating if the SaturatingAccumulation
  Cooperative Matrix Operand is present, with the signedness of the saturation
  being that of the components of Result Type. If the SaturatingAccumulation
  Cooperative Matrix Operand is not present then the resulting value will
  equal the low-order N bits of the correct result R, where N is the result
  width and R is computed with enough precision to avoid overflow and
  underflow.
  
  Result Type must be a cooperative matrix type with M rows and N columns
  whose Use must be MatrixAccumulatorKHR.
  
  A is a cooperative matrix with M rows and K columns whose Use must be
  MatrixAKHR.
  
  B is a cooperative matrix with K rows and N columns whose Use must be
  MatrixBKHR.
  
  C is a cooperative matrix with M rows and N columns whose Use must be
  MatrixAccumulatorKHR.
  
  The values of M, N, and K must be consistent across the result and operands.
  This is referred to as an MxNxK matrix multiply.
  
  A, B, C, and Result Type must have the same scope, and this defines the
  scope of the operation. A, B, C, and Result Type need not necessarily have
  the same component type, this is defined by the client API.
  
  If the Component Type of any matrix operand is an integer type, then its
  components are treated as signed if the Matrix{A,B,C,Result}SignedComponents
  Cooperative Matrix Operand is present and are treated as unsigned otherwise.
  
  Cooperative Matrix Operands is an optional Cooperative Matrix Operand
  literal. If not present, it is the same as specifying the Cooperative Matrix
  Operand None.
  
  For a given dynamic instance of this instruction, all invocations in a given
  scope instance must be active or all must be inactive (where the scope is
  the scope of the operation).
  
  ``` {.ebnf}
  cooperative-matrixmuladd-op ::= ssa-id `=` `spirv.KHR.CooperativeMatrixMulAdd`
                            ssa-use `,` ssa-use `,` ssa-use
                            (`<` matrix-operands `>`)? `:`
                            a-cooperative-matrix-type `,`
                            b-cooperative-matrix-type `->`
                              result-cooperative-matrix-type
  ```
  
  #### Example:
  
  ```
  %0 = spirv.KHR.CooperativeMatrixMulAdd %matA, %matB, %matC :
    !spirv.coopmatrix<4x4xf32, Subgroup, MatrixA>,
    !spirv.coopmatrix<4x4xf32, Subgroup, MatrixB> ->
      !spirv.coopmatrix<4x4xf32, Subgroup, MatrixAcc>
  
  %1 = spirv.KHR.CooperativeMatrixMulAdd %matA, %matB, %matC, <ASigned | AccSat> :
    !spirv.coopmatrix<8x16xi32, Subgroup, MatrixA>,
    !spirv.coopmatrix<16x4xi32, Subgroup, MatrixB> ->
      !spirv.coopmatrix<8x4xi32, Subgroup, MatrixAcc>
  ```
  """

  OPERATION_NAME = "spirv.KHR.CooperativeMatrixMulAdd"

  _ODS_REGIONS = (0, True)

  def __init__(self, a, b, c, *, matrix_operands=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(a)
    operands.append(b)
    operands.append(c)
    _ods_context = _ods_get_default_loc_context(loc)
    if matrix_operands is not None: attributes["matrix_operands"] = (matrix_operands if (
        isinstance(matrix_operands, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_KHR_CooperativeMatrixOperandsAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_KHR_CooperativeMatrixOperandsAttr')(matrix_operands, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def a(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def b(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def c(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def matrix_operands(self) -> _Optional[_ods_ir.Attribute]:
    if "matrix_operands" not in self.operation.attributes:
      return None
    return self.operation.attributes["matrix_operands"]

  @matrix_operands.setter
  def matrix_operands(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["matrix_operands"] = value
    elif "matrix_operands" in self.operation.attributes:
      del self.operation.attributes["matrix_operands"]

  @matrix_operands.deleter
  def matrix_operands(self):
    del self.operation.attributes["matrix_operands"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def KHR_CooperativeMatrixMulAdd(a, b, c, *, matrix_operands=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return KHRCooperativeMatrixMulAddOp(a=a, b=b, c=c, matrix_operands=matrix_operands, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class KHRCooperativeMatrixStoreOp(_ods_ir.OpView):
  r"""
  Store a cooperative matrix through a pointer.
  Pointer is a pointer. Its type must be an OpTypePointer whose Type operand
  is a scalar or vector type. If the Shader capability was declared, Pointer
  must point into an array and any ArrayStride decoration on Pointer is
  ignored.
  
  Object is the object to store. Its type must be an
  OpTypeCooperativeMatrixKHR.
  
  MemoryLayout specifies how matrix elements are laid out in memory. It must
  come from a 32-bit integer constant instruction whose value corresponds to a
  Cooperative Matrix Layout. See the Cooperative Matrix Layout table for a
  description of the layouts and detailed layout-specific rules.
  
  Stride further qualifies how matrix elements are laid out in memory. It must
  be a scalar integer type and its exact semantics depend on MemoryLayout.
  
  Memory Operand must be a Memory Operand literal. If not present, it is the
  same as specifying None.
  
  NOTE: In earlier versions of the SPIR-V spec, 'Memory Operand' was known
  as 'Memory Access'.
  
  For a given dynamic instance of this instruction, all operands of this
  instruction must be the same for all invocations in a given scope instance
  (where the scope is the scope the cooperative matrix type was created with).
  All invocations in a given scope instance must be active or all must be
  inactive.
  
  TODO: In the SPIR-V spec, `stride` is an optional argument. We should also
  support this optionality in the SPIR-V dialect.
  
  #### Example:
  
  ```
    spirv.KHR.CooperativeMatrixStore %ptr, %obj, %stride, <RowMajor> :
      !spirv.ptr<i32, StorageBuffer>, !spirv.coopmatrix<16x8xi32, Workgroup, MatrixA>, i32
  
    spirv.KHR.CooperativeMatrixStore %ptr, %obj, %stride, <ColumnMajor>, <Volatile> :
      !spirv.ptr<f32, StorageBuffer>, !spirv.coopmatrix<8x8xf32, Subgroup, MatrixAcc>, i64
  ```
  """

  OPERATION_NAME = "spirv.KHR.CooperativeMatrixStore"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, object, matrix_layout, stride, *, memory_operand=None, alignment=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    operands.append(object)
    operands.append(stride)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["matrix_layout"] = (matrix_layout if (
    isinstance(matrix_layout, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_KHR_CooperativeMatrixLayoutAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_KHR_CooperativeMatrixLayoutAttr')(matrix_layout, context=_ods_context))
    if memory_operand is not None: attributes["memory_operand"] = (memory_operand if (
        isinstance(memory_operand, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_MemoryAccessAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_MemoryAccessAttr')(memory_operand, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(alignment, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def object(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def stride(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def matrix_layout(self) -> _ods_ir.Attribute:
    return self.operation.attributes["matrix_layout"]

  @matrix_layout.setter
  def matrix_layout(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["matrix_layout"] = value

  @builtins.property
  def memory_operand(self) -> _Optional[_ods_ir.Attribute]:
    if "memory_operand" not in self.operation.attributes:
      return None
    return self.operation.attributes["memory_operand"]

  @memory_operand.setter
  def memory_operand(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["memory_operand"] = value
    elif "memory_operand" in self.operation.attributes:
      del self.operation.attributes["memory_operand"]

  @memory_operand.deleter
  def memory_operand(self):
    del self.operation.attributes["memory_operand"]

  @builtins.property
  def alignment(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

def KHR_CooperativeMatrixStore(pointer, object, matrix_layout, stride, *, memory_operand=None, alignment=None, loc=None, ip=None) -> KHRCooperativeMatrixStoreOp:
  return KHRCooperativeMatrixStoreOp(pointer=pointer, object=object, matrix_layout=matrix_layout, stride=stride, memory_operand=memory_operand, alignment=alignment, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class KHRSubgroupBallotOp(_ods_ir.OpView):
  r"""
  Computes a bitfield value combining the Predicate value from all invocations
  in the current Subgroup that execute the same dynamic instance of this
  instruction. The bit is set to one if the corresponding invocation is active
  and the predicate is evaluated to true; otherwise, it is set to zero.
  
  Predicate must be a Boolean type.
  
  Result Type must be a 4 component vector of 32 bit integer types.
  
  Result is a set of bitfields where the first invocation is represented in bit
  0 of the first vector component and the last (up to SubgroupSize) is the
  higher bit number of the last bitmask needed to represent all bits of the
  subgroup invocations.
  
  <!-- End of AutoGen section -->
  
  ```
  subgroup-ballot-op ::= ssa-id `=` `spirv.KHR.SubgroupBallot`
                              ssa-use `:` `vector` `<` 4 `x` `i32` `>`
  ```
  
  #### Example:
  
  ```mlir
  %0 = spirv.KHR.SubgroupBallot %predicate : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.KHR.SubgroupBallot"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, predicate, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(predicate)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def predicate(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def KHR_SubgroupBallot(result, predicate, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return KHRSubgroupBallotOp(result=result, predicate=predicate, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class KillOp(_ods_ir.OpView):
  r"""
  Fragment-shader discard.
  
  Ceases all further processing in any invocation that executes it: Only
  instructions these invocations executed before OpKill have observable
  side effects. If this instruction is executed in non-uniform control
  flow, all subsequent control flow is non-uniform (for invocations that
  continue to execute).
  
  This instruction must be the last instruction in a block.
  
  This instruction is only valid in the Fragment Execution Model.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  spirv.Kill
  ```
  """

  OPERATION_NAME = "spirv.Kill"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def Kill(*, loc=None, ip=None) -> KillOp:
  return KillOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LoadOp(_ods_ir.OpView):
  r"""
  Result Type is the type of the loaded object. It must be a type with
  fixed size; i.e., it cannot be, nor include, any OpTypeRuntimeArray
  types.
  
  Pointer is the pointer to load through.  Its type must be an
  OpTypePointer whose Type operand is the same as Result Type.
  
  If present, any Memory Operands must begin with a memory operand
  literal. If not present, it is the same as specifying the memory operand
  None.
  
  <!-- End of AutoGen section -->
  
  ```
  memory-access ::= `"None"` | `"Volatile"` | `"Aligned", ` integer-literal
                  | `"NonTemporal"`
  
  load-op ::= ssa-id ` = spirv.Load ` storage-class ssa-use
              (`[` memory-access `]`)? ` : ` spirv-element-type
  ```
  
  #### Example:
  
  ```mlir
  %0 = spirv.Variable : !spirv.ptr<f32, Function>
  %1 = spirv.Load "Function" %0 : f32
  %2 = spirv.Load "Function" %0 ["Volatile"] : f32
  %3 = spirv.Load "Function" %0 ["Aligned", 4] : f32
  ```
  """

  OPERATION_NAME = "spirv.Load"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, ptr, *, memory_access=None, alignment=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    _ods_context = _ods_get_default_loc_context(loc)
    if memory_access is not None: attributes["memory_access"] = (memory_access if (
        isinstance(memory_access, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_MemoryAccessAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_MemoryAccessAttr')(memory_access, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(alignment, context=_ods_context))
    results = []
    results.append(value)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def memory_access(self) -> _Optional[_ods_ir.Attribute]:
    if "memory_access" not in self.operation.attributes:
      return None
    return self.operation.attributes["memory_access"]

  @memory_access.setter
  def memory_access(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["memory_access"] = value
    elif "memory_access" in self.operation.attributes:
      del self.operation.attributes["memory_access"]

  @memory_access.deleter
  def memory_access(self):
    del self.operation.attributes["memory_access"]

  @builtins.property
  def alignment(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

  @builtins.property
  def value(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Load(value, ptr, *, memory_access=None, alignment=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return LoadOp(value=value, ptr=ptr, memory_access=memory_access, alignment=alignment, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalAndOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 must be the same as Result Type.
  
  The type of Operand 2 must be the same as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.LogicalAnd %0, %1 : i1
  %2 = spirv.LogicalAnd %0, %1 : vector<4xi1>
  ```
  """

  OPERATION_NAME = "spirv.LogicalAnd"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def LogicalAnd(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogicalAndOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 must be the same as Result Type.
  
  The type of Operand 2 must be the same as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.LogicalEqual %0, %1 : i1
  %2 = spirv.LogicalEqual %0, %1 : vector<4xi1>
  ```
  """

  OPERATION_NAME = "spirv.LogicalEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def LogicalEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogicalEqualOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalNotEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 must be the same as Result Type.
  
  The type of Operand 2 must be the same as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.LogicalNotEqual %0, %1 : i1
  %2 = spirv.LogicalNotEqual %0, %1 : vector<4xi1>
  ```
  """

  OPERATION_NAME = "spirv.LogicalNotEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def LogicalNotEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogicalNotEqualOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalNotOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand must be the same as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.LogicalNot %0 : i1
  %2 = spirv.LogicalNot %0 : vector<4xi1>
  ```
  """

  OPERATION_NAME = "spirv.LogicalNot"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def LogicalNot(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogicalNotOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LogicalOrOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 must be the same as Result Type.
  
  The type of Operand 2 must be the same as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.LogicalOr %0, %1 : i1
  %2 = spirv.LogicalOr %0, %1 : vector<4xi1>
  ```
  """

  OPERATION_NAME = "spirv.LogicalOr"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def LogicalOr(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return LogicalOrOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class LoopOp(_ods_ir.OpView):
  r"""
  SPIR-V can explicitly declare structured control-flow constructs using merge
  instructions. These explicitly declare a header block before the control
  flow diverges and a merge block where control flow subsequently converges.
  These blocks delimit constructs that must nest, and can only be entered
  and exited in structured ways. See "2.11. Structured Control Flow" of the
  SPIR-V spec for more details.
  
  Instead of having a `spirv.LoopMerge` op to directly model loop merge
  instruction for indicating the merge and continue target, we use regions
  to delimit the boundary of the loop: the merge target is the next op
  following the `spirv.mlir.loop` op and the continue target is the block that
  has a back-edge pointing to the entry block inside the `spirv.mlir.loop`'s region.
  This way it's easier to discover all blocks belonging to a construct and
  it plays nicer with the MLIR system.
  
  The `spirv.mlir.loop` region should contain at least four blocks: one entry block,
  one loop header block, one loop continue block, one loop merge block.
  The entry block should be the first block and it should jump to the loop
  header block, which is the second block. The loop merge block should be the
  last block. The merge block should only contain a `spirv.mlir.merge` op.
  The continue block should be the second to last block and it should have a
  branch to the loop header block. The loop continue block should be the only
  block, except the entry block, branching to the header block.
  
  Values defined inside the loop regions cannot be directly used
  outside of them; however, the loop region can yield values. These values are
  yielded using a `spirv.mlir.merge` op and returned as a result of the loop op.
  """

  OPERATION_NAME = "spirv.mlir.loop"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, loop_control, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["loop_control"] = (loop_control if (
    isinstance(loop_control, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_LoopControlAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_LoopControlAttr')(loop_control, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def loop_control(self) -> _ods_ir.Attribute:
    return self.operation.attributes["loop_control"]

  @loop_control.setter
  def loop_control(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["loop_control"] = value

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def mlir_loop(results_, loop_control, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, LoopOp]:
  op = LoopOp(results_=results_, loop_control=loop_control, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class MatrixTimesMatrixOp(_ods_ir.OpView):
  r"""
  Result Type must be an OpTypeMatrix whose Column Type is a vector of
  floating-point type.
  
  LeftMatrix must be a matrix whose Column Type is the same as the Column
  Type in Result Type.
  
  RightMatrix must be a matrix with the same Component Type as the
  Component Type in Result Type. Its number of columns must equal the
  number of columns in Result Type. Its columns must have the same number
  of components as the number of columns in LeftMatrix.
  
  #### Example:
  
  ```mlir
  %0 = spirv.MatrixTimesMatrix %matrix_1, %matrix_2 :
      !spirv.matrix<4 x vector<3xf32>>, !spirv.matrix<3 x vector<4xf32>> ->
      !spirv.matrix<4 x vector<4xf32>>
  ```
  """

  OPERATION_NAME = "spirv.MatrixTimesMatrix"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, leftmatrix, rightmatrix, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(leftmatrix)
    operands.append(rightmatrix)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def leftmatrix(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rightmatrix(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def MatrixTimesMatrix(result, leftmatrix, rightmatrix, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MatrixTimesMatrixOp(result=result, leftmatrix=leftmatrix, rightmatrix=rightmatrix, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MatrixTimesScalarOp(_ods_ir.OpView):
  r"""
  Result Type must be a matrix type with a float component type.
  
  The type of Matrix must be the same as Result Type. Each component in
  each column in Matrix is multiplied by Scalar.
  
  Scalar must have the same type as the Component Type in Result Type.
  
  #### Example:
  
  ```mlir
  %0 = spirv.MatrixTimesScalar %matrix, %scalar :
  !spirv.matrix<3 x vector<3xf32>>, f32 -> !spirv.matrix<3 x vector<3xf32>>
  
  ```
  """

  OPERATION_NAME = "spirv.MatrixTimesScalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, matrix, scalar, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(matrix)
    operands.append(scalar)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def matrix(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scalar(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def MatrixTimesScalar(matrix, scalar, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return MatrixTimesScalarOp(matrix=matrix, scalar=scalar, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MatrixTimesVectorOp(_ods_ir.OpView):
  r"""
  Result Type must be a vector of floating-point type.
  
  Matrix must be an OpTypeMatrix whose Column Type is Result Type.
  
  Vector must be a vector with the same Component Type as the Component Type in Result Type. Its number of components must equal the number of columns in Matrix.
  
  #### Example:
  
  ```mlir
  %0 = spirv.MatrixTimesVector %matrix, %vector : 
      !spirv.matrix<3 x vector<2xf32>>, vector<3xf32> -> vector<2xf32>
  ```
  """

  OPERATION_NAME = "spirv.MatrixTimesVector"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, matrix, vector, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(matrix)
    operands.append(vector)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def matrix(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def vector(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def MatrixTimesVector(result, matrix, vector, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return MatrixTimesVectorOp(result=result, matrix=matrix, vector=vector, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class MemoryBarrierOp(_ods_ir.OpView):
  r"""
  Ensures that memory accesses issued before this instruction will be
  observed before memory accesses issued after this instruction. This
  control is ensured only for memory accesses issued by this invocation
  and observed by another invocation executing within Memory scope. If the
  Vulkan memory model is declared, this ordering only applies to memory
  accesses that use the NonPrivatePointer memory operand or
  NonPrivateTexel image operand.
  
  Semantics declares what kind of memory is being controlled and what kind
  of control to apply.
  
  To execute both a memory barrier and a control barrier, see
  OpControlBarrier.
  
  #### Example:
  
  ```mlir
  spirv.MemoryBarrier "Device", "Acquire|UniformMemory"
  ```
  """

  OPERATION_NAME = "spirv.MemoryBarrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, memory_scope, memory_semantics, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["memory_scope"] = (memory_scope if (
    isinstance(memory_scope, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_ScopeAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_ScopeAttr')(memory_scope, context=_ods_context))
    attributes["memory_semantics"] = (memory_semantics if (
    isinstance(memory_semantics, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemorySemanticsAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemorySemanticsAttr')(memory_semantics, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def memory_scope(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_scope"]

  @memory_scope.setter
  def memory_scope(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_scope"] = value

  @builtins.property
  def memory_semantics(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_semantics"]

  @memory_semantics.setter
  def memory_semantics(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_semantics"] = value

def MemoryBarrier(memory_scope, memory_semantics, *, loc=None, ip=None) -> MemoryBarrierOp:
  return MemoryBarrierOp(memory_scope=memory_scope, memory_semantics=memory_semantics, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MergeOp(_ods_ir.OpView):
  r"""
  We use `spirv.mlir.selection`/`spirv.mlir.loop` for modelling structured selection/loop.
  This op is a terminator used inside their regions to mean jumping to the
  merge point, which is the next op following the `spirv.mlir.selection` or
  `spirv.mlir.loop` op. This op does not have a corresponding instruction in the
  SPIR-V binary format; it's solely for structural purpose.
  
  The instruction is also used to yield values from inside the selection/loop region
  to the outside, as values that were sunk into the region cannot otherwise escape it.
  """

  OPERATION_NAME = "spirv.mlir.merge"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def mlir_merge(operands_, *, loc=None, ip=None) -> MergeOp:
  return MergeOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ModuleOp(_ods_ir.OpView):
  r"""
  This op defines a SPIR-V module using a MLIR region. The region contains
  one block. Module-level operations, including functions definitions,
  are all placed in this block.
  
  Using an op with a region to define a SPIR-V module enables "embedding"
  SPIR-V modules in other dialects in a clean manner: this op guarantees
  the validity and serializability of a SPIR-V module and thus serves as
  a clear-cut boundary.
  
  This op takes no operands and generates no results. This op should not
  implicitly capture values from the enclosing environment.
  
  This op has only one region, which only contains one block. The block
  has no terminator.
  
  <!-- End of AutoGen section -->
  
  ```
  addressing-model ::= `Logical` | `Physical32` | `Physical64` | ...
  memory-model ::= `Simple` | `GLSL450` | `OpenCL` | `Vulkan` | ...
  spv-module-op ::= `spirv.module` addressing-model memory-model
                    (requires  spirv-vce-attribute)?
                    (`attributes` attribute-dict)?
                    region
  ```
  
  #### Example:
  
  ```mlir
  spirv.module Logical GLSL450  {}
  
  spirv.module Logical Vulkan
      requires #spirv.vce<v1.0, [Shader], [SPV_KHR_vulkan_memory_model]>
      attributes { some_additional_attr = ... } {
    spirv.func @do_nothing() -> () {
      spirv.Return
    }
  }
  ```
  """

  OPERATION_NAME = "spirv.module"

  _ODS_REGIONS = (1, True)

  def __init__(self, addressing_model, memory_model, *, vce_triple=None, sym_name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["addressing_model"] = (addressing_model if (
    isinstance(addressing_model, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_AddressingModelAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_AddressingModelAttr')(addressing_model, context=_ods_context))
    attributes["memory_model"] = (memory_model if (
    isinstance(memory_model, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_MemoryModelAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_MemoryModelAttr')(memory_model, context=_ods_context))
    if vce_triple is not None: attributes["vce_triple"] = (vce_triple if (
        isinstance(vce_triple, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_VerCapExtAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_VerCapExtAttr')(vce_triple, context=_ods_context))
    if sym_name is not None: attributes["sym_name"] = (sym_name if (
        isinstance(sym_name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def addressing_model(self) -> _ods_ir.Attribute:
    return self.operation.attributes["addressing_model"]

  @addressing_model.setter
  def addressing_model(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["addressing_model"] = value

  @builtins.property
  def memory_model(self) -> _ods_ir.Attribute:
    return self.operation.attributes["memory_model"]

  @memory_model.setter
  def memory_model(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["memory_model"] = value

  @builtins.property
  def vce_triple(self) -> _Optional[_ods_ir.Attribute]:
    if "vce_triple" not in self.operation.attributes:
      return None
    return self.operation.attributes["vce_triple"]

  @vce_triple.setter
  def vce_triple(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["vce_triple"] = value
    elif "vce_triple" in self.operation.attributes:
      del self.operation.attributes["vce_triple"]

  @vce_triple.deleter
  def vce_triple(self):
    del self.operation.attributes["vce_triple"]

  @builtins.property
  def sym_name(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_name" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_name"] = value
    elif "sym_name" in self.operation.attributes:
      del self.operation.attributes["sym_name"]

  @sym_name.deleter
  def sym_name(self):
    del self.operation.attributes["sym_name"]

def module(addressing_model, memory_model, *, vce_triple=None, sym_name=None, loc=None, ip=None) -> ModuleOp:
  return ModuleOp(addressing_model=addressing_model, memory_model=memory_model, vce_triple=vce_triple, sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class NotOp(_ods_ir.OpView):
  r"""
  Results are computed per component, and within each component, per bit.
  
  Result Type must be a scalar or vector of integer type.
  
  Operand's type  must be a scalar or vector of integer type.  It must
  have the same number of components as Result Type.  The component width
  must equal the component width in Result Type.
  
  #### Example:
  
  ```mlir
  %2 = spirv.Not %0 : i32
  %3 = spirv.Not %1 : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.Not"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Not(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return NotOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OrderedOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  x must be a scalar or vector of floating-point type.  It must have the
  same number of components as Result Type.
  
  y must have the same type as x.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.Ordered %0, %1 : f32
  %5 = spirv.Ordered %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.Ordered"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Ordered(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return OrderedOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PtrAccessChainOp(_ods_ir.OpView):
  r"""
  Element is used to do an initial dereference of Base: Base is treated as
  the address of an element in an array, and a new element address is
  computed from Base and Element to become the OpAccessChain Base to
  dereference as per OpAccessChain. This computed Base has the same type
  as the originating Base.
  
  To compute the new element address, Element is treated as a signed count
  of elements E, relative to the original Base element B, and the address
  of element B + E is computed using enough precision to avoid overflow
  and underflow. For objects in the Uniform, StorageBuffer, or
  PushConstant storage classes, the element's address or location is
  calculated using a stride, which will be the Base-type's Array Stride if
  the Base type is decorated with ArrayStride. For all other objects, the
  implementation calculates the element's address or location.
  
  With one exception, undefined behavior results when B + E is not an
  element in the same array (same innermost array, if array types are
  nested) as B. The exception being when B + E = L, where L is the length
  of the array: the address computation for element L is done with the
  same stride as any other B + E computation that stays within the array.
  
  Note: If Base is typed to be a pointer to an array and the desired
  operation is to select an element of that array, OpAccessChain should be
  directly used, as its first Index selects the array element.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  func @ptr_access_chain(%arg0: !spirv.ptr<f32, CrossWorkgroup>, %arg1 : i64) -> () {
    %0 = spirv.PtrAccessChain %arg0[%arg1] : !spirv.ptr<f32, CrossWorkgroup>, i64 -> !spirv.ptr<f32, CrossWorkgroup>
    ...
  }
  ```
  """

  OPERATION_NAME = "spirv.PtrAccessChain"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, base_ptr, element, indices, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(base_ptr)
    operands.append(element)
    operands.extend(_get_op_results_or_values(indices))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def base_ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def element(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def indices(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 3 + 1
    return self.operation.operands[2:2 + _ods_variadic_group_length]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def PtrAccessChain(result, base_ptr, element, indices, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return PtrAccessChainOp(result=result, base_ptr=base_ptr, element=element, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PtrCastToGenericOp(_ods_ir.OpView):
  r"""
  Result Type must be an OpTypePointer. Its Storage Class must be Generic.
  
  Pointer must point to the Workgroup, CrossWorkgroup, or Function Storage
  Class.
  
  Result Type and Pointer must point to the same type.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %1 = spirv.PtrCastToGenericOp %0 : !spirv.ptr<f32, CrossWorkGroup> to
       !spirv.ptr<f32, Generic>
  ```
  """

  OPERATION_NAME = "spirv.PtrCastToGeneric"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, pointer, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pointer)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pointer(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def PtrCastToGeneric(result, pointer, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return PtrCastToGenericOp(result=result, pointer=pointer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReferenceOfOp(_ods_ir.OpView):
  r"""
  Specialization constants in module scope are defined using symbol names.
  This op generates an SSA value that can be used to refer to the symbol
  within function scope for use in ops that expect an SSA value.
  This operation has no corresponding SPIR-V instruction; it's merely used
  for modelling purpose in the SPIR-V dialect. This op's return type is
  the same as the specialization constant.
  
  #### Example:
  
  ```mlir
  %0 = spirv.mlir.referenceof @spec_const : f32
  ```
  
  TODO Add support for composite specialization constants.
  """

  OPERATION_NAME = "spirv.mlir.referenceof"

  _ODS_REGIONS = (0, True)

  def __init__(self, reference, spec_const, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["spec_const"] = (spec_const if (
    isinstance(spec_const, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(spec_const, context=_ods_context))
    results = []
    results.append(reference)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def spec_const(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["spec_const"]

  @spec_const.setter
  def spec_const(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["spec_const"] = value

  @builtins.property
  def reference(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def mlir_referenceof(reference, spec_const, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReferenceOfOp(reference=reference, spec_const=spec_const, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  r"""
  This instruction must be the last instruction in a block.
  
  #### Example:
  
  ```mlir
  spirv.Return
  ```
  """

  OPERATION_NAME = "spirv.Return"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def Return(*, loc=None, ip=None) -> ReturnOp:
  return ReturnOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReturnValueOp(_ods_ir.OpView):
  r"""
  Value is the value returned, by copy, and must match the Return Type
  operand of the OpTypeFunction type of the OpFunction body this return
  instruction is in.
  
  This instruction must be the last instruction in a block.
  
  #### Example:
  
  ```mlir
  spirv.ReturnValue %0 : f32
  ```
  """

  OPERATION_NAME = "spirv.ReturnValue"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def ReturnValue(value, *, loc=None, ip=None) -> ReturnValueOp:
  return ReturnValueOp(value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SConvertOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type.
  
  Signed Value must be a scalar or vector of integer type.  It must have
  the same number of components as Result Type.  The component width
  cannot equal the component width in Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %1 = spirv.SConvertOp %0 : i32 to i64
  %3 = spirv.SConvertOp %2 : vector<3xi32> to vector<3xi64>
  ```
  """

  OPERATION_NAME = "spirv.SConvert"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def SConvert(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SConvertOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SDivOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  integer type.  They must have the same number of components as Result
  Type. They must have the same component width as Result Type.
  
  Results are computed per component.  The resulting value is undefined
  if Operand 2 is 0.
  
  #### Example:
  
  ```mlir
  %4 = spirv.SDiv %0, %1 : i32
  %5 = spirv.SDiv %2, %3 : vector<4xi32>
  
  ```
  """

  OPERATION_NAME = "spirv.SDiv"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def SDiv(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SDivOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SDotAccSatOp(_ods_ir.OpView):
  r"""
  Result Type must be an integer type whose Width must be greater than or
  equal to that of the components of Vector 1 and Vector 2.
  
  Vector 1 and Vector 2 must have the same type.
  
  Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
  DotProductInput4x8BitPacked capability) or vectors of integer type
  (enabled by the DotProductInput4x8Bit or DotProductInputAll capability).
  
  The type of Accumulator must be the same as Result Type.
  
  When Vector 1 and Vector 2 are scalar integer types, Packed Vector
  Format must be specified to select how the integers are to be
  interpreted as vectors.
  
  All components of the input vectors are sign-extended to the bit width
  of the result's type. The sign-extended input vectors are then
  multiplied component-wise and all components of the vector resulting
  from the component-wise multiplication are added together. Finally, the
  resulting sum is added to the input accumulator. This final addition is
  saturating.
  
  If any of the multiplications or additions, with the exception of the
  final accumulation, overflow or underflow, the result of the instruction
  is undefined.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %r = spirv.SDotAccSat %a, %b, %acc, <PackedVectorFormat4x8Bit> : i32 -> i32
  %r = spirv.SDotAccSat %a, %b, %acc, <PackedVectorFormat4x8Bit> : i32 -> i64
  %r = spirv.SDotAccSat %a, %b, %acc : vector<4xi8> -> i32
  ```
  """

  OPERATION_NAME = "spirv.SDotAccSat"

  _ODS_REGIONS = (0, True)

  def __init__(self, vector1, vector2, accumulator, *, format=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vector1)
    operands.append(vector2)
    operands.append(accumulator)
    _ods_context = _ods_get_default_loc_context(loc)
    if format is not None: attributes["format"] = (format if (
        isinstance(format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_PackedVectorFormatAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_PackedVectorFormatAttr')(format, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def vector2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def accumulator(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def format(self) -> _Optional[_ods_ir.Attribute]:
    if "format" not in self.operation.attributes:
      return None
    return self.operation.attributes["format"]

  @format.setter
  def format(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["format"] = value
    elif "format" in self.operation.attributes:
      del self.operation.attributes["format"]

  @format.deleter
  def format(self):
    del self.operation.attributes["format"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def SDotAccSat(vector1, vector2, accumulator, *, format=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SDotAccSatOp(vector1=vector1, vector2=vector2, accumulator=accumulator, format=format, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SDotOp(_ods_ir.OpView):
  r"""
  Result Type must be an integer type whose Width must be greater than or
  equal to that of the components of Vector 1 and Vector 2.
  
  Vector 1 and Vector 2 must have the same type.
  
  Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
  DotProductInput4x8BitPacked capability) or vectors of integer type
  (enabled by the DotProductInput4x8Bit or DotProductInputAll capability).
  
  When Vector 1 and Vector 2 are scalar integer types, Packed Vector
  Format must be specified to select how the integers are to be
  interpreted as vectors.
  
  All components of the input vectors are sign-extended to the bit width
  of the result's type. The sign-extended input vectors are then
  multiplied component-wise and all components of the vector resulting
  from the component-wise multiplication are added together. The resulting
  value will equal the low-order N bits of the correct result R, where N
  is the result width and R is computed with enough precision to avoid
  overflow and underflow.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %r = spirv.SDot %a, %b, <PackedVectorFormat4x8Bit> : i32 -> i32
  %r = spirv.SDot %a, %b, <PackedVectorFormat4x8Bit> : i32 -> i64
  %r = spirv.SDot %a, %b : vector<4xi8> -> i32
  ```
  """

  OPERATION_NAME = "spirv.SDot"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, vector1, vector2, *, format=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vector1)
    operands.append(vector2)
    _ods_context = _ods_get_default_loc_context(loc)
    if format is not None: attributes["format"] = (format if (
        isinstance(format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_PackedVectorFormatAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_PackedVectorFormatAttr')(format, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def vector2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def format(self) -> _Optional[_ods_ir.Attribute]:
    if "format" not in self.operation.attributes:
      return None
    return self.operation.attributes["format"]

  @format.setter
  def format(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["format"] = value
    elif "format" in self.operation.attributes:
      del self.operation.attributes["format"]

  @format.deleter
  def format(self):
    del self.operation.attributes["format"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def SDot(result, vector1, vector2, *, format=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SDotOp(result=result, vector1=vector1, vector2=vector2, format=format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SGreaterThanEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  integer type.  They must have the same component width, and they must
  have the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.SGreaterThanEqual %0, %1 : i32
  %5 = spirv.SGreaterThanEqual %2, %3 : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.SGreaterThanEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def SGreaterThanEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SGreaterThanEqualOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SGreaterThanOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  integer type.  They must have the same component width, and they must
  have the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.SGreaterThan %0, %1 : i32
  %5 = spirv.SGreaterThan %2, %3 : vector<4xi32>
  
  ```
  """

  OPERATION_NAME = "spirv.SGreaterThan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def SGreaterThan(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SGreaterThanOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SLessThanEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  integer type.  They must have the same component width, and they must
  have the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.SLessThanEqual %0, %1 : i32
  %5 = spirv.SLessThanEqual %2, %3 : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.SLessThanEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def SLessThanEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SLessThanEqualOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SLessThanOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  integer type.  They must have the same component width, and they must
  have the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.SLessThan %0, %1 : i32
  %5 = spirv.SLessThan %2, %3 : vector<4xi32>
  
  ```
  """

  OPERATION_NAME = "spirv.SLessThan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def SLessThan(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SLessThanOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SModOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  integer type.  They must have the same number of components as Result
  Type. They must have the same component width as Result Type.
  
  Results are computed per component.  The resulting value is undefined
  if Operand 2 is 0.  Otherwise, the result is the remainder r of Operand
  1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the
  sign of Operand 2.
  
  #### Example:
  
  ```mlir
  %4 = spirv.SMod %0, %1 : i32
  %5 = spirv.SMod %2, %3 : vector<4xi32>
  
  ```
  """

  OPERATION_NAME = "spirv.SMod"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def SMod(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SModOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SMulExtendedOp(_ods_ir.OpView):
  r"""
  Result Type must be from OpTypeStruct.  The struct must have two
  members, and the two members must be the same type.  The member type
  must be a scalar or vector of integer type.
  
  Operand 1 and Operand 2 must have the same type as the members of Result
  Type. These are consumed as signed integers.
  
  Results are computed per component.
  
  Member 0 of the result gets the low-order bits of the multiplication.
  
  Member 1 of the result gets the high-order bits of the multiplication.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %2 = spirv.SMulExtended %0, %1 : !spirv.struct<(i32, i32)>
  %2 = spirv.SMulExtended %0, %1 : !spirv.struct<(vector<2xi32>, vector<2xi32>)>
  ```
  """

  OPERATION_NAME = "spirv.SMulExtended"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand1, operand2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def SMulExtended(result, operand1, operand2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SMulExtendedOp(result=result, operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SNegateOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type.
  
  Operand's type  must be a scalar or vector of integer type.  It must
  have the same number of components as Result Type.  The component width
  must equal the component width in Result Type.
  
   Results are computed per component.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %1 = spirv.SNegate %0 : i32
  %3 = spirv.SNegate %2 : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.SNegate"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def SNegate(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SNegateOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SRemOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  integer type.  They must have the same number of components as Result
  Type. They must have the same component width as Result Type.
  
  Results are computed per component.  The resulting value is undefined
  if Operand 2 is 0.  Otherwise, the result is the remainder r of Operand
  1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the
  sign of Operand 1.
  
  #### Example:
  
  ```mlir
  %4 = spirv.SRem %0, %1 : i32
  %5 = spirv.SRem %2, %3 : vector<4xi32>
  
  ```
  """

  OPERATION_NAME = "spirv.SRem"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def SRem(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SRemOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SUDotAccSatOp(_ods_ir.OpView):
  r"""
  Result Type must be an integer type whose Width must be greater than or
  equal to that of the components of Vector 1 and Vector 2.
  
  Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
  DotProductInput4x8BitPacked capability) or vectors of integer type with
  the same number of components and same component Width (enabled by the
  DotProductInput4x8Bit or DotProductInputAll capability). When Vector 1
  and Vector 2 are vectors, the components of Vector 2 must have a
  Signedness of 0.
  
  The type of Accumulator must be the same as Result Type.
  
  When Vector 1 and Vector 2 are scalar integer types, Packed Vector
  Format must be specified to select how the integers are to be
  interpreted as vectors.
  
  All components of Vector 1 are sign-extended to the bit width of the
  result's type. All components of Vector 2 are zero-extended to the bit
  width of the result's type. The sign- or zero-extended input vectors are
  then multiplied component-wise and all components of the vector
  resulting from the component-wise multiplication are added together.
  Finally, the resulting sum is added to the input accumulator. This final
  addition is saturating.
  
  If any of the multiplications or additions, with the exception of the
  final accumulation, overflow or underflow, the result of the instruction
  is undefined.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %r = spirv.SUDotAccSat %a, %b, %acc, <PackedVectorFormat4x8Bit> : i32 -> i32
  %r = spirv.SUDotAccSat %a, %b, %acc, <PackedVectorFormat4x8Bit> : i32 -> i64
  %r = spirv.SUDotAccSat %a, %b, %acc : vector<4xi8> -> i32
  ```
  """

  OPERATION_NAME = "spirv.SUDotAccSat"

  _ODS_REGIONS = (0, True)

  def __init__(self, vector1, vector2, accumulator, *, format=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vector1)
    operands.append(vector2)
    operands.append(accumulator)
    _ods_context = _ods_get_default_loc_context(loc)
    if format is not None: attributes["format"] = (format if (
        isinstance(format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_PackedVectorFormatAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_PackedVectorFormatAttr')(format, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def vector2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def accumulator(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def format(self) -> _Optional[_ods_ir.Attribute]:
    if "format" not in self.operation.attributes:
      return None
    return self.operation.attributes["format"]

  @format.setter
  def format(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["format"] = value
    elif "format" in self.operation.attributes:
      del self.operation.attributes["format"]

  @format.deleter
  def format(self):
    del self.operation.attributes["format"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def SUDotAccSat(vector1, vector2, accumulator, *, format=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SUDotAccSatOp(vector1=vector1, vector2=vector2, accumulator=accumulator, format=format, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SUDotOp(_ods_ir.OpView):
  r"""
  Result Type must be an integer type whose Width must be greater than or
  equal to that of the components of Vector 1 and Vector 2.
  
  Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
  DotProductInput4x8BitPacked capability) or vectors of integer type with
  the same number of components and same component Width (enabled by the
  DotProductInput4x8Bit or DotProductInputAll capability). When Vector 1
  and Vector 2 are vectors, the components of Vector 2 must have a
  Signedness of 0.
  
  When Vector 1 and Vector 2 are scalar integer types, Packed Vector
  Format must be specified to select how the integers are to be
  interpreted as vectors.
  
  All components of Vector 1 are sign-extended to the bit width of the
  result's type. All components of Vector 2 are zero-extended to the bit
  width of the result's type. The sign- or zero-extended input vectors are
  then multiplied component-wise and all components of the vector
  resulting from the component-wise multiplication are added together. The
  resulting value will equal the low-order N bits of the correct result R,
  where N is the result width and R is computed with enough precision to
  avoid overflow and underflow.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %r = spirv.SUDot %a, %b, <PackedVectorFormat4x8Bit> : i32 -> i32
  %r = spirv.SUDot %a, %b, <PackedVectorFormat4x8Bit> : i32 -> i64
  %r = spirv.SUDot %a, %b : vector<4xi8> -> i32
  ```
  """

  OPERATION_NAME = "spirv.SUDot"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, vector1, vector2, *, format=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vector1)
    operands.append(vector2)
    _ods_context = _ods_get_default_loc_context(loc)
    if format is not None: attributes["format"] = (format if (
        isinstance(format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_PackedVectorFormatAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_PackedVectorFormatAttr')(format, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def vector2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def format(self) -> _Optional[_ods_ir.Attribute]:
    if "format" not in self.operation.attributes:
      return None
    return self.operation.attributes["format"]

  @format.setter
  def format(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["format"] = value
    elif "format" in self.operation.attributes:
      del self.operation.attributes["format"]

  @format.deleter
  def format(self):
    del self.operation.attributes["format"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def SUDot(result, vector1, vector2, *, format=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SUDotOp(result=result, vector1=vector1, vector2=vector2, format=format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectOp(_ods_ir.OpView):
  r"""
  Before version 1.4, Result Type must be a pointer, scalar, or vector.
  
  The types of Object 1 and Object 2 must be the same as Result Type.
  
  Condition must be a scalar or vector of Boolean type.
  
  If Condition is a scalar and true, the result is Object 1. If Condition
  is a scalar and false, the result is Object 2.
  
  If Condition is a vector, Result Type must be a vector with the same
  number of components as Condition and the result is a mix of Object 1
  and Object 2: When a component of Condition is true, the corresponding
  component in the result is taken from Object 1, otherwise it is taken
  from Object 2.
  
  #### Example:
  
  ```mlir
  %3 = spirv.Select %0, %1, %2 : i1, f32
  %3 = spirv.Select %0, %1, %2 : i1, vector<3xi32>
  %3 = spirv.Select %0, %1, %2 : vector<3xi1>, vector<3xf32>
  ```
  """

  OPERATION_NAME = "spirv.Select"

  _ODS_REGIONS = (0, True)

  def __init__(self, condition, true_value, false_value, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(condition)
    operands.append(true_value)
    operands.append(false_value)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def condition(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def true_value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def false_value(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Select(condition, true_value, false_value, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return SelectOp(condition=condition, true_value=true_value, false_value=false_value, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SelectionOp(_ods_ir.OpView):
  r"""
  SPIR-V can explicitly declare structured control-flow constructs using merge
  instructions. These explicitly declare a header block before the control
  flow diverges and a merge block where control flow subsequently converges.
  These blocks delimit constructs that must nest, and can only be entered
  and exited in structured ways. See "2.11. Structured Control Flow" of the
  SPIR-V spec for more details.
  
  Instead of having a `spirv.SelectionMerge` op to directly model selection
  merge instruction for indicating the merge target, we use regions to delimit
  the boundary of the selection: the merge target is the next op following the
  `spirv.mlir.selection` op. This way it's easier to discover all blocks belonging to
  the selection and it plays nicer with the MLIR system.
  
  The `spirv.mlir.selection` region should contain at least two blocks: one selection
  header block, and one selection merge. The selection header block should be
  the first block. The selection merge block should be the last block.
  The merge block should only contain a `spirv.mlir.merge` op.
  
  Values defined inside the selection regions cannot be directly used
  outside of them; however, the selection region can yield values. These values are
  yielded using a `spirv.mlir.merge` op and returned as a result of the selection op.
  """

  OPERATION_NAME = "spirv.mlir.selection"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, selection_control, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["selection_control"] = (selection_control if (
    isinstance(selection_control, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_SelectionControlAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_SelectionControlAttr')(selection_control, context=_ods_context))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def selection_control(self) -> _ods_ir.Attribute:
    return self.operation.attributes["selection_control"]

  @selection_control.setter
  def selection_control(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["selection_control"] = value

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def mlir_selection(results_, selection_control, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, SelectionOp]:
  op = SelectionOp(results_=results_, selection_control=selection_control, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class ShiftLeftLogicalOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type.
  
  The type of each Base and Shift must be a scalar or vector of integer
  type. Base and Shift must have the same number of components.  The
  number of components and bit width of the type of Base must be the same
  as in Result Type.
  
  Shift is treated as unsigned. The result is undefined if Shift is
  greater than or equal to the bit width of the components of Base.
  
  The number of components and bit width of Result Type must match those
  Base type. All types must be integer types.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.ShiftLeftLogical %0, %1 : i32, i16
  %5 = spirv.ShiftLeftLogical %3, %4 : vector<3xi32>, vector<3xi16>
  ```
  """

  OPERATION_NAME = "spirv.ShiftLeftLogical"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ShiftLeftLogical(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShiftLeftLogicalOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShiftRightArithmeticOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type.
  
  The type of each Base and Shift must be a scalar or vector of integer
  type. Base and Shift must have the same number of components.  The
  number of components and bit width of the type of Base must be the same
  as in Result Type.
  
  Shift is treated as unsigned. The result is undefined if Shift is
  greater than or equal to the bit width of the components of Base.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.ShiftRightArithmetic %0, %1 : i32, i16
  %5 = spirv.ShiftRightArithmetic %3, %4 : vector<3xi32>, vector<3xi16>
  ```
  """

  OPERATION_NAME = "spirv.ShiftRightArithmetic"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ShiftRightArithmetic(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShiftRightArithmeticOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ShiftRightLogicalOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type.
  
  The type of each Base and Shift must be a scalar or vector of integer
  type. Base and Shift must have the same number of components.  The
  number of components and bit width of the type of Base must be the same
  as in Result Type.
  
  Shift is consumed as an unsigned integer. The result is undefined if
  Shift is greater than or equal to the bit width of the components of
  Base.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %2 = spirv.ShiftRightLogical %0, %1 : i32, i16
  %5 = spirv.ShiftRightLogical %3, %4 : vector<3xi32>, vector<3xi16>
  ```
  """

  OPERATION_NAME = "spirv.ShiftRightLogical"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ShiftRightLogical(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ShiftRightLogicalOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class SpecConstantCompositeOp(_ods_ir.OpView):
  r"""
  This op declares a SPIR-V composite specialization constant. This covers
  the `OpSpecConstantComposite` SPIR-V instruction. Scalar constants are
  covered by `spirv.SpecConstant`.
  
  A constituent of a spec constant composite can be:
  - A symbol referring of another spec constant.
  - The SSA ID of a non-specialization constant (i.e. defined through
    `spirv.SpecConstant`).
  - The SSA ID of a `spirv.Undef`.
  
  ```
  spv-spec-constant-composite-op ::= `spirv.SpecConstantComposite` symbol-ref-id ` (`
                                     symbol-ref-id (`, ` symbol-ref-id)*
                                     `) :` composite-type
  ```
  
   where `composite-type` is some non-scalar type that can be represented in the `spv`
   dialect: `spirv.struct`, `spirv.array`, or `vector`.
  
   #### Example:
  
   ```mlir
   spirv.SpecConstant @sc1 = 1   : i32
   spirv.SpecConstant @sc2 = 2.5 : f32
   spirv.SpecConstant @sc3 = 3.5 : f32
   spirv.SpecConstantComposite @scc (@sc1, @sc2, @sc3) : !spirv.struct<i32, f32, f32>
   ```
  
  TODO Add support for constituents that are:
  - regular constants.
  - undef.
  - spec constant composite.
  """

  OPERATION_NAME = "spirv.SpecConstantComposite"

  _ODS_REGIONS = (0, True)

  def __init__(self, type_, sym_name, constituents, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(sym_name, context=_ods_context))
    attributes["constituents"] = (constituents if (
    isinstance(constituents, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(constituents, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def constituents(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["constituents"]

  @constituents.setter
  def constituents(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["constituents"] = value

def SpecConstantComposite(type_, sym_name, constituents, *, loc=None, ip=None) -> SpecConstantCompositeOp:
  return SpecConstantCompositeOp(type_=type_, sym_name=sym_name, constituents=constituents, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SpecConstantOp(_ods_ir.OpView):
  r"""
  This op declares a SPIR-V scalar specialization constant. SPIR-V has
  multiple constant instructions covering different scalar types:
  
  * `OpSpecConstantTrue` and `OpSpecConstantFalse` for boolean constants
  * `OpSpecConstant` for scalar constants
  
  Similar as `spirv.Constant`, this op represents all of the above cases.
  `OpSpecConstantComposite` and `OpSpecConstantOp` are modelled with
  separate ops.
  
  <!-- End of AutoGen section -->
  
  ```
  spv-spec-constant-op ::= `spirv.SpecConstant` symbol-ref-id
                           `spec_id(` integer `)`
                           `=` attribute-value (`:` spirv-type)?
  ```
  
  where `spec_id` specifies the SPIR-V SpecId decoration associated with
  the op.
  
  #### Example:
  
  ```mlir
  spirv.SpecConstant @spec_const1 = true
  spirv.SpecConstant @spec_const2 spec_id(5) = 42 : i32
  ```
  """

  OPERATION_NAME = "spirv.SpecConstant"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, default_value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(sym_name, context=_ods_context))
    attributes["default_value"] = (default_value if (
    isinstance(default_value, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypedAttrInterface')) else
      _ods_ir.AttrBuilder.get('TypedAttrInterface')(default_value, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def default_value(self) -> _ods_ir.Attribute:
    return self.operation.attributes["default_value"]

  @default_value.setter
  def default_value(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["default_value"] = value

def SpecConstant(sym_name, default_value, *, loc=None, ip=None) -> SpecConstantOp:
  return SpecConstantOp(sym_name=sym_name, default_value=default_value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SpecConstantOperationOp(_ods_ir.OpView):
  r"""
  This op declares a SPIR-V specialization constant that results from
  doing an operation on other constants (specialization or otherwise).
  
  In the `spv` dialect, this op is modelled as follows:
  
  ```
  spv-spec-constant-operation-op ::= `spirv.SpecConstantOperation` `wraps`
                                       generic-spirv-op `:` function-type
  ```
  
  In particular, an `spirv.SpecConstantOperation` contains exactly one
  region. In turn, that region, contains exactly 2 instructions:
  - One of SPIR-V's instructions that are allowed within an
  OpSpecConstantOp.
  - An `spirv.mlir.yield` instruction as the terminator.
  
  The following SPIR-V instructions are valid:
  - OpSConvert,
  - OpUConvert,
  - OpFConvert,
  - OpSNegate,
  - OpNot,
  - OpIAdd,
  - OpISub,
  - OpIMul,
  - OpUDiv,
  - OpSDiv,
  - OpUMod,
  - OpSRem,
  - OpSMod
  - OpShiftRightLogical,
  - OpShiftRightArithmetic,
  - OpShiftLeftLogical
  - OpBitwiseOr,
  - OpBitwiseXor,
  - OpBitwiseAnd
  - OpVectorShuffle,
  - OpCompositeExtract,
  - OpCompositeInsert
  - OpLogicalOr,
  - OpLogicalAnd,
  - OpLogicalNot,
  - OpLogicalEqual,
  - OpLogicalNotEqual
  - OpSelect
  - OpIEqual,
  - OpINotEqual
  - OpULessThan,
  - OpSLessThan
  - OpUGreaterThan,
  - OpSGreaterThan
  - OpULessThanEqual,
  - OpSLessThanEqual
  - OpUGreaterThanEqual,
  - OpSGreaterThanEqual
  
  TODO Add capability-specific ops when supported.
  
  #### Example:
  ```mlir
  %0 = spirv.Constant 1: i32
  %1 = spirv.Constant 1: i32
  
  %2 = spirv.SpecConstantOperation wraps "spirv.IAdd"(%0, %1) : (i32, i32) -> i32
  ```
  """

  OPERATION_NAME = "spirv.SpecConstantOperation"

  _ODS_REGIONS = (1, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def SpecConstantOperation(result, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return SpecConstantOperationOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class StoreOp(_ods_ir.OpView):
  r"""
  Pointer is the pointer to store through.  Its type must be an
  OpTypePointer whose Type operand is the same as the type of Object.
  
  Object is the object to store.
  
  If present, any Memory Operands must begin with a memory operand
  literal. If not present, it is the same as specifying the memory operand
  None.
  
  <!-- End of AutoGen section -->
  
  ```
  store-op ::= `spirv.Store ` storage-class ssa-use `, ` ssa-use `, `
                (`[` memory-access `]`)? `:` spirv-element-type
  ```
  
  #### Example:
  
  ```mlir
  %0 = spirv.Variable : !spirv.ptr<f32, Function>
  %1 = spirv.FMul ... : f32
  spirv.Store "Function" %0, %1 : f32
  spirv.Store "Function" %0, %1 ["Volatile"] : f32
  spirv.Store "Function" %0, %1 ["Aligned", 4] : f32
  ```
  """

  OPERATION_NAME = "spirv.Store"

  _ODS_REGIONS = (0, True)

  def __init__(self, ptr, value, *, memory_access=None, alignment=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ptr)
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    if memory_access is not None: attributes["memory_access"] = (memory_access if (
        isinstance(memory_access, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_MemoryAccessAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_MemoryAccessAttr')(memory_access, context=_ods_context))
    if alignment is not None: attributes["alignment"] = (alignment if (
        isinstance(alignment, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(alignment, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ptr(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def memory_access(self) -> _Optional[_ods_ir.Attribute]:
    if "memory_access" not in self.operation.attributes:
      return None
    return self.operation.attributes["memory_access"]

  @memory_access.setter
  def memory_access(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["memory_access"] = value
    elif "memory_access" in self.operation.attributes:
      del self.operation.attributes["memory_access"]

  @memory_access.deleter
  def memory_access(self):
    del self.operation.attributes["memory_access"]

  @builtins.property
  def alignment(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "alignment" not in self.operation.attributes:
      return None
    return self.operation.attributes["alignment"]

  @alignment.setter
  def alignment(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["alignment"] = value
    elif "alignment" in self.operation.attributes:
      del self.operation.attributes["alignment"]

  @alignment.deleter
  def alignment(self):
    del self.operation.attributes["alignment"]

def Store(ptr, value, *, memory_access=None, alignment=None, loc=None, ip=None) -> StoreOp:
  return StoreOp(ptr=ptr, value=value, memory_access=memory_access, alignment=alignment, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TosaAbsOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_abs
  """

  OPERATION_NAME = "spirv.Tosa.Abs"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Abs(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaAbsOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaAddOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_add
  """

  OPERATION_NAME = "spirv.Tosa.Add"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Add(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaAddOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaArgMaxOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_argmax
  """

  OPERATION_NAME = "spirv.Tosa.ArgMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, axis, nan_mode, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(axis)
    operands.append(nan_mode)
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def nan_mode(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_ArgMax(output, axis, nan_mode, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaArgMaxOp(output=output, axis=axis, nan_mode=nan_mode, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaArithmeticRightShiftOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_arithmetic_right_shift
  """

  OPERATION_NAME = "spirv.Tosa.ArithmeticRightShift"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, round, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(round)
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def round(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_ArithmeticRightShift(output, round, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaArithmeticRightShiftOp(output=output, round=round, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaAvgPool2DOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_avg_pool2d
  """

  OPERATION_NAME = "spirv.Tosa.AvgPool2D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, kernel, stride, pad, acc_type, input, input_zp, output_zp, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(kernel)
    operands.append(stride)
    operands.append(pad)
    operands.append(acc_type)
    operands.append(input)
    operands.append(input_zp)
    operands.append(output_zp)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def kernel(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def stride(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def pad(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def acc_type(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def input_zp(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def output_zp(self) -> _ods_ir.Value:
    return self.operation.operands[6]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_AvgPool2D(output, kernel, stride, pad, acc_type, input, input_zp, output_zp, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaAvgPool2DOp(output=output, kernel=kernel, stride=stride, pad=pad, acc_type=acc_type, input=input, input_zp=input_zp, output_zp=output_zp, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaBitwiseAndOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_bitwise_and
  """

  OPERATION_NAME = "spirv.Tosa.BitwiseAnd"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_BitwiseAnd(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaBitwiseAndOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaBitwiseNotOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_bitwise_not
  """

  OPERATION_NAME = "spirv.Tosa.BitwiseNot"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_BitwiseNot(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaBitwiseNotOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaBitwiseOrOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_bitwise_or
  """

  OPERATION_NAME = "spirv.Tosa.BitwiseOr"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_BitwiseOr(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaBitwiseOrOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaBitwiseXorOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_bitwise_xor
  """

  OPERATION_NAME = "spirv.Tosa.BitwiseXor"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_BitwiseXor(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaBitwiseXorOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaCastOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_cast
  """

  OPERATION_NAME = "spirv.Tosa.Cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Cast(output, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaCastOp(output=output, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaCeilOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_ceil
  """

  OPERATION_NAME = "spirv.Tosa.Ceil"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Ceil(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaCeilOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaClampOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_clamp
  """

  OPERATION_NAME = "spirv.Tosa.Clamp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, min_val, max_val, nan_mode, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(min_val)
    operands.append(max_val)
    operands.append(nan_mode)
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def min_val(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def max_val(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def nan_mode(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Clamp(output, min_val, max_val, nan_mode, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaClampOp(output=output, min_val=min_val, max_val=max_val, nan_mode=nan_mode, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaClzOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_clz
  """

  OPERATION_NAME = "spirv.Tosa.Clz"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Clz(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaClzOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaConcatOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_concat
  """

  OPERATION_NAME = "spirv.Tosa.Concat"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, axis, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(axis)
    operands.extend(_get_op_results_or_values(input1))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input1(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Concat(output, axis, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaConcatOp(output=output, axis=axis, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaConv2DOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_conv2d
  """

  OPERATION_NAME = "spirv.Tosa.Conv2D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, pad, stride, dilation, acc_type, local_bound, input, weight, bias, input_zp, weight_zp, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pad)
    operands.append(stride)
    operands.append(dilation)
    operands.append(acc_type)
    operands.append(local_bound)
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(input_zp)
    operands.append(weight_zp)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pad(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def stride(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def dilation(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def acc_type(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def local_bound(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def weight(self) -> _ods_ir.Value:
    return self.operation.operands[6]

  @builtins.property
  def bias(self) -> _ods_ir.Value:
    return self.operation.operands[7]

  @builtins.property
  def input_zp(self) -> _ods_ir.Value:
    return self.operation.operands[8]

  @builtins.property
  def weight_zp(self) -> _ods_ir.Value:
    return self.operation.operands[9]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Conv2D(output, pad, stride, dilation, acc_type, local_bound, input, weight, bias, input_zp, weight_zp, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaConv2DOp(output=output, pad=pad, stride=stride, dilation=dilation, acc_type=acc_type, local_bound=local_bound, input=input, weight=weight, bias=bias, input_zp=input_zp, weight_zp=weight_zp, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaConv3DOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_conv3d
  """

  OPERATION_NAME = "spirv.Tosa.Conv3D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, pad, stride, dilation, acc_type, local_bound, input, weight, bias, input_zp, weight_zp, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pad)
    operands.append(stride)
    operands.append(dilation)
    operands.append(acc_type)
    operands.append(local_bound)
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(input_zp)
    operands.append(weight_zp)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pad(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def stride(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def dilation(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def acc_type(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def local_bound(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def weight(self) -> _ods_ir.Value:
    return self.operation.operands[6]

  @builtins.property
  def bias(self) -> _ods_ir.Value:
    return self.operation.operands[7]

  @builtins.property
  def input_zp(self) -> _ods_ir.Value:
    return self.operation.operands[8]

  @builtins.property
  def weight_zp(self) -> _ods_ir.Value:
    return self.operation.operands[9]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Conv3D(output, pad, stride, dilation, acc_type, local_bound, input, weight, bias, input_zp, weight_zp, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaConv3DOp(output=output, pad=pad, stride=stride, dilation=dilation, acc_type=acc_type, local_bound=local_bound, input=input, weight=weight, bias=bias, input_zp=input_zp, weight_zp=weight_zp, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaCosOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_cos
  """

  OPERATION_NAME = "spirv.Tosa.Cos"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Cos(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaCosOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaDepthwiseConv2DOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_depthwise_conv2d
  """

  OPERATION_NAME = "spirv.Tosa.DepthwiseConv2D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, pad, stride, dilation, acc_type, local_bound, input, weight, bias, input_zp, weight_zp, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(pad)
    operands.append(stride)
    operands.append(dilation)
    operands.append(acc_type)
    operands.append(local_bound)
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(input_zp)
    operands.append(weight_zp)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pad(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def stride(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def dilation(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def acc_type(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def local_bound(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def weight(self) -> _ods_ir.Value:
    return self.operation.operands[6]

  @builtins.property
  def bias(self) -> _ods_ir.Value:
    return self.operation.operands[7]

  @builtins.property
  def input_zp(self) -> _ods_ir.Value:
    return self.operation.operands[8]

  @builtins.property
  def weight_zp(self) -> _ods_ir.Value:
    return self.operation.operands[9]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_DepthwiseConv2D(output, pad, stride, dilation, acc_type, local_bound, input, weight, bias, input_zp, weight_zp, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaDepthwiseConv2DOp(output=output, pad=pad, stride=stride, dilation=dilation, acc_type=acc_type, local_bound=local_bound, input=input, weight=weight, bias=bias, input_zp=input_zp, weight_zp=weight_zp, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaEqualOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_equal
  """

  OPERATION_NAME = "spirv.Tosa.Equal"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Equal(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaEqualOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaErfOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_erf
  """

  OPERATION_NAME = "spirv.Tosa.Erf"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Erf(output, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaErfOp(output=output, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaExpOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_exp
  """

  OPERATION_NAME = "spirv.Tosa.Exp"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Exp(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaExpOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaFFT2DOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_fft2d
  """

  OPERATION_NAME = "spirv.Tosa.FFT2D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, inverse, local_bound, input_real, input_imag, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(inverse)
    operands.append(local_bound)
    operands.append(input_real)
    operands.append(input_imag)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inverse(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def local_bound(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def input_real(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def input_imag(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_FFT2D(output, inverse, local_bound, input_real, input_imag, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaFFT2DOp(output=output, inverse=inverse, local_bound=local_bound, input_real=input_real, input_imag=input_imag, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaFloorOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_floor
  """

  OPERATION_NAME = "spirv.Tosa.Floor"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Floor(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaFloorOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaGatherOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_gather
  """

  OPERATION_NAME = "spirv.Tosa.Gather"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, values, indices, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(values)
    operands.append(indices)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def values(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Gather(output, values, indices, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaGatherOp(output=output, values=values, indices=indices, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaGreaterEqualOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_greater_equal
  """

  OPERATION_NAME = "spirv.Tosa.GreaterEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_GreaterEqual(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaGreaterEqualOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaGreaterOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_greater
  """

  OPERATION_NAME = "spirv.Tosa.Greater"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Greater(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaGreaterOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaIntDivOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_intdiv
  """

  OPERATION_NAME = "spirv.Tosa.IntDiv"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_IntDiv(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaIntDivOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaLogOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_log
  """

  OPERATION_NAME = "spirv.Tosa.Log"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Log(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaLogOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaLogicalAndOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_logical_and
  """

  OPERATION_NAME = "spirv.Tosa.LogicalAnd"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_LogicalAnd(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaLogicalAndOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaLogicalLeftShiftOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_logical_left_shift
  """

  OPERATION_NAME = "spirv.Tosa.LogicalLeftShift"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_LogicalLeftShift(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaLogicalLeftShiftOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaLogicalNotOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_logical_not
  """

  OPERATION_NAME = "spirv.Tosa.LogicalNot"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_LogicalNot(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaLogicalNotOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaLogicalOrOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_logical_or
  """

  OPERATION_NAME = "spirv.Tosa.LogicalOr"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_LogicalOr(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaLogicalOrOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaLogicalRightShiftOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_logical_right_shift
  """

  OPERATION_NAME = "spirv.Tosa.LogicalRightShift"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_LogicalRightShift(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaLogicalRightShiftOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaLogicalXorOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_logical_xor
  """

  OPERATION_NAME = "spirv.Tosa.LogicalXor"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_LogicalXor(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaLogicalXorOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaMatMulOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_matmul
  """

  OPERATION_NAME = "spirv.Tosa.MatMul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, A, B, A_zp, B_zp, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(A)
    operands.append(B)
    operands.append(A_zp)
    operands.append(B_zp)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def A(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def B(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def A_zp(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def B_zp(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_MatMul(output, a, b, a_zp, b_zp, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaMatMulOp(output=output, A=a, B=b, A_zp=a_zp, B_zp=b_zp, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaMaxPool2DOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_max_pool2d
  """

  OPERATION_NAME = "spirv.Tosa.MaxPool2D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, kernel, stride, pad, nan_mode, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(kernel)
    operands.append(stride)
    operands.append(pad)
    operands.append(nan_mode)
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def kernel(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def stride(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def pad(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def nan_mode(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_MaxPool2D(output, kernel, stride, pad, nan_mode, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaMaxPool2DOp(output=output, kernel=kernel, stride=stride, pad=pad, nan_mode=nan_mode, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaMaximumOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_maximum
  """

  OPERATION_NAME = "spirv.Tosa.Maximum"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, nan_mode, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(nan_mode)
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def nan_mode(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Maximum(output, nan_mode, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaMaximumOp(output=output, nan_mode=nan_mode, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaMinimumOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_minimum
  """

  OPERATION_NAME = "spirv.Tosa.Minimum"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, nan_mode, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(nan_mode)
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def nan_mode(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Minimum(output, nan_mode, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaMinimumOp(output=output, nan_mode=nan_mode, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaMulOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_mul
  """

  OPERATION_NAME = "spirv.Tosa.Mul"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, shift, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    operands.append(shift)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def shift(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Mul(output, input1, input2, shift, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaMulOp(output=output, input1=input1, input2=input2, shift=shift, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaNegateOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_negate
  """

  OPERATION_NAME = "spirv.Tosa.Negate"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input1_zp, output_zp, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input1_zp)
    operands.append(output_zp)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input1_zp(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output_zp(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Negate(output, input1, input1_zp, output_zp, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaNegateOp(output=output, input1=input1, input1_zp=input1_zp, output_zp=output_zp, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaPadOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_pad
  """

  OPERATION_NAME = "spirv.Tosa.Pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, padding, pad_const, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(padding)
    operands.append(pad_const)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def padding(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def pad_const(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Pad(output, input1, padding, pad_const, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaPadOp(output=output, input1=input1, padding=padding, pad_const=pad_const, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaPowOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_pow
  """

  OPERATION_NAME = "spirv.Tosa.Pow"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Pow(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaPowOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaRFFT2DOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_rfft2d
  """

  OPERATION_NAME = "spirv.Tosa.RFFT2D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, local_bound, input_real, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(local_bound)
    operands.append(input_real)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def local_bound(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input_real(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_RFFT2D(output, local_bound, input_real, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaRFFT2DOp(output=output, local_bound=local_bound, input_real=input_real, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaReciprocalOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reciprocal
  """

  OPERATION_NAME = "spirv.Tosa.Reciprocal"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Reciprocal(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaReciprocalOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaReduceAllOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reduce_all
  """

  OPERATION_NAME = "spirv.Tosa.ReduceAll"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, axis, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(axis)
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_ReduceAll(output, axis, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaReduceAllOp(output=output, axis=axis, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaReduceAnyOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reduce_any
  """

  OPERATION_NAME = "spirv.Tosa.ReduceAny"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, axis, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(axis)
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_ReduceAny(output, axis, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaReduceAnyOp(output=output, axis=axis, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaReduceMaxOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reduce_max
  """

  OPERATION_NAME = "spirv.Tosa.ReduceMax"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, axis, nan_mode, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(axis)
    operands.append(nan_mode)
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def nan_mode(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_ReduceMax(output, axis, nan_mode, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaReduceMaxOp(output=output, axis=axis, nan_mode=nan_mode, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaReduceMinOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reduce_min
  """

  OPERATION_NAME = "spirv.Tosa.ReduceMin"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, axis, nan_mode, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(axis)
    operands.append(nan_mode)
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def nan_mode(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_ReduceMin(output, axis, nan_mode, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaReduceMinOp(output=output, axis=axis, nan_mode=nan_mode, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaReduceProductOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reduce_product
  """

  OPERATION_NAME = "spirv.Tosa.ReduceProduct"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, axis, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(axis)
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_ReduceProduct(output, axis, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaReduceProductOp(output=output, axis=axis, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaReduceSumOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reduce_sum
  """

  OPERATION_NAME = "spirv.Tosa.ReduceSum"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, axis, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(axis)
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_ReduceSum(output, axis, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaReduceSumOp(output=output, axis=axis, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaRescaleOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_rescale
  """

  OPERATION_NAME = "spirv.Tosa.Rescale"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, scale32, rounding_mode, per_channel, input_unsigned, output_unsigned, input, multiplier, shift, input_zp, output_zp, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(scale32)
    operands.append(rounding_mode)
    operands.append(per_channel)
    operands.append(input_unsigned)
    operands.append(output_unsigned)
    operands.append(input)
    operands.append(multiplier)
    operands.append(shift)
    operands.append(input_zp)
    operands.append(output_zp)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def scale32(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def rounding_mode(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def per_channel(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def input_unsigned(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def output_unsigned(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def multiplier(self) -> _ods_ir.Value:
    return self.operation.operands[6]

  @builtins.property
  def shift(self) -> _ods_ir.Value:
    return self.operation.operands[7]

  @builtins.property
  def input_zp(self) -> _ods_ir.Value:
    return self.operation.operands[8]

  @builtins.property
  def output_zp(self) -> _ods_ir.Value:
    return self.operation.operands[9]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Rescale(output, scale32, rounding_mode, per_channel, input_unsigned, output_unsigned, input, multiplier, shift, input_zp, output_zp, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaRescaleOp(output=output, scale32=scale32, rounding_mode=rounding_mode, per_channel=per_channel, input_unsigned=input_unsigned, output_unsigned=output_unsigned, input=input, multiplier=multiplier, shift=shift, input_zp=input_zp, output_zp=output_zp, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaReshapeOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reshape
  """

  OPERATION_NAME = "spirv.Tosa.Reshape"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, shape, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(shape)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def shape(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Reshape(output, input1, shape, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaReshapeOp(output=output, input1=input1, shape=shape, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaResizeOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_resize
  """

  OPERATION_NAME = "spirv.Tosa.Resize"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, mode, input, scale, offset, border, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(mode)
    operands.append(input)
    operands.append(scale)
    operands.append(offset)
    operands.append(border)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def mode(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def scale(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def offset(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def border(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Resize(output, mode, input, scale, offset, border, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaResizeOp(output=output, mode=mode, input=input, scale=scale, offset=offset, border=border, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaReverseOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_reverse
  """

  OPERATION_NAME = "spirv.Tosa.Reverse"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, axis, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(axis)
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def axis(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Reverse(output, axis, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaReverseOp(output=output, axis=axis, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaRsqrtOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_rsqrt
  """

  OPERATION_NAME = "spirv.Tosa.Rsqrt"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Rsqrt(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaRsqrtOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaScatterOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_scatter
  """

  OPERATION_NAME = "spirv.Tosa.Scatter"

  _ODS_REGIONS = (0, True)

  def __init__(self, values_out, values_in, indices, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(values_in)
    operands.append(indices)
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(values_out)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def values_in(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def indices(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def values_out(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Scatter(values_out, values_in, indices, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaScatterOp(values_out=values_out, values_in=values_in, indices=indices, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaSelectOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_select
  """

  OPERATION_NAME = "spirv.Tosa.Select"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, input3, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    operands.append(input3)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def input3(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Select(output, input1, input2, input3, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaSelectOp(output=output, input1=input1, input2=input2, input3=input3, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaSigmoidOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_sigmoid
  """

  OPERATION_NAME = "spirv.Tosa.Sigmoid"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Sigmoid(output, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaSigmoidOp(output=output, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaSinOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_sin
  """

  OPERATION_NAME = "spirv.Tosa.Sin"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Sin(output, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaSinOp(output=output, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaSliceOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_slice
  """

  OPERATION_NAME = "spirv.Tosa.Slice"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, start, size, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(start)
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def start(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def size(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Slice(output, input1, start, size, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaSliceOp(output=output, input1=input1, start=start, size=size, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaSubOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_sub
  """

  OPERATION_NAME = "spirv.Tosa.Sub"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, input2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(input2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Sub(output, input1, input2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaSubOp(output=output, input1=input1, input2=input2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaTableOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_table
  """

  OPERATION_NAME = "spirv.Tosa.Table"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, table, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(table)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def table(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Table(output, input1, table, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaTableOp(output=output, input1=input1, table=table, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaTanhOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_tanh
  """

  OPERATION_NAME = "spirv.Tosa.Tanh"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Tanh(output, input, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaTanhOp(output=output, input=input, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaTileOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_tile
  """

  OPERATION_NAME = "spirv.Tosa.Tile"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, input1, multiples, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(input1)
    operands.append(multiples)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def multiples(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Tile(output, input1, multiples, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaTileOp(output=output, input1=input1, multiples=multiples, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaTransposeConv2DOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_transpose_conv2d
  """

  OPERATION_NAME = "spirv.Tosa.TransposeConv2D"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, out_pad, stride, acc_type, local_bound, input, weight, bias, input_zp, weight_zp, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(out_pad)
    operands.append(stride)
    operands.append(acc_type)
    operands.append(local_bound)
    operands.append(input)
    operands.append(weight)
    operands.append(bias)
    operands.append(input_zp)
    operands.append(weight_zp)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def out_pad(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def stride(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def acc_type(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def local_bound(self) -> _ods_ir.Value:
    return self.operation.operands[3]

  @builtins.property
  def input(self) -> _ods_ir.Value:
    return self.operation.operands[4]

  @builtins.property
  def weight(self) -> _ods_ir.Value:
    return self.operation.operands[5]

  @builtins.property
  def bias(self) -> _ods_ir.Value:
    return self.operation.operands[6]

  @builtins.property
  def input_zp(self) -> _ods_ir.Value:
    return self.operation.operands[7]

  @builtins.property
  def weight_zp(self) -> _ods_ir.Value:
    return self.operation.operands[8]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_TransposeConv2D(output, out_pad, stride, acc_type, local_bound, input, weight, bias, input_zp, weight_zp, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaTransposeConv2DOp(output=output, out_pad=out_pad, stride=stride, acc_type=acc_type, local_bound=local_bound, input=input, weight=weight, bias=bias, input_zp=input_zp, weight_zp=weight_zp, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TosaTransposeOp(_ods_ir.OpView):
  r"""
  https://github.khronos.org/SPIRV-Registry/extended/TOSA.001000.1.html#_transpose
  """

  OPERATION_NAME = "spirv.Tosa.Transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, output, perms, input1, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(perms)
    operands.append(input1)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(output)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def perms(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def input1(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Tosa_Transpose(output, perms, input1, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TosaTransposeOp(output=output, perms=perms, input1=input1, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class TransposeOp(_ods_ir.OpView):
  r"""
  Result Type must be an OpTypeMatrix.
  
  Matrix must be an object of type OpTypeMatrix. The number of columns and
  the column size of Matrix must be the reverse of those in Result Type.
  The types of the scalar components in Matrix and Result Type must be the
  same.
  
  Matrix must have of type of OpTypeMatrix.
  
  #### Example:
  
  ```mlir
  %0 = spirv.Transpose %matrix: !spirv.matrix<2 x vector<3xf32>> ->
  !spirv.matrix<3 x vector<2xf32>>
  ```
  """

  OPERATION_NAME = "spirv.Transpose"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, matrix, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(matrix)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def matrix(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Transpose(result, matrix, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TransposeOp(result=result, matrix=matrix, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UConvertOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type, whose Signedness
  operand is 0.
  
  Unsigned Value must be a scalar or vector of integer type.  It must have
  the same number of components as Result Type.  The component width
  cannot equal the component width in Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %1 = spirv.UConvertOp %0 : i32 to i64
  %3 = spirv.UConvertOp %2 : vector<3xi32> to vector<3xi64>
  ```
  """

  OPERATION_NAME = "spirv.UConvert"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def UConvert(result, operand, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return UConvertOp(result=result, operand=operand, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UDivOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type, whose Signedness
  operand is 0.
  
  The types of Operand 1 and Operand 2 both must be the same as Result
  Type.
  
  Results are computed per component.  The resulting value is undefined
  if Operand 2 is 0.
  
  #### Example:
  
  ```mlir
  %4 = spirv.UDiv %0, %1 : i32
  %5 = spirv.UDiv %2, %3 : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.UDiv"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def UDiv(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return UDivOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UDotAccSatOp(_ods_ir.OpView):
  r"""
  Result Type must be an integer type with Signedness of 0 whose Width
  must be greater than or equal to that of the components of Vector 1 and
  Vector 2.
  
  Vector 1 and Vector 2 must have the same type.
  
  Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
  DotProductInput4x8BitPacked capability) or vectors of integer type with
  Signedness of 0 (enabled by the DotProductInput4x8Bit or
  DotProductInputAll capability).
  
  The type of Accumulator must be the same as Result Type.
  
  When Vector 1 and Vector 2 are scalar integer types, Packed Vector
  Format must be specified to select how the integers are to be
  interpreted as vectors.
  
  All components of the input vectors are zero-extended to the bit width
  of the result's type. The zero-extended input vectors are then
  multiplied component-wise and all components of the vector resulting
  from the component-wise multiplication are added together. Finally, the
  resulting sum is added to the input accumulator. This final addition is
  saturating.
  
  If any of the multiplications or additions, with the exception of the
  final accumulation, overflow or underflow, the result of the instruction
  is undefined.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %r = spirv.UDotAccSat %a, %b, %acc, <PackedVectorFormat4x8Bit> : i32 -> i32
  %r = spirv.UDotAccSat %a, %b, %acc, <PackedVectorFormat4x8Bit> : i32 -> i64
  %r = spirv.UDotAccSat %a, %b, %acc : vector<4xi8> -> i32
  ```
  """

  OPERATION_NAME = "spirv.UDotAccSat"

  _ODS_REGIONS = (0, True)

  def __init__(self, vector1, vector2, accumulator, *, format=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vector1)
    operands.append(vector2)
    operands.append(accumulator)
    _ods_context = _ods_get_default_loc_context(loc)
    if format is not None: attributes["format"] = (format if (
        isinstance(format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_PackedVectorFormatAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_PackedVectorFormatAttr')(format, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def vector2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def accumulator(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def format(self) -> _Optional[_ods_ir.Attribute]:
    if "format" not in self.operation.attributes:
      return None
    return self.operation.attributes["format"]

  @format.setter
  def format(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["format"] = value
    elif "format" in self.operation.attributes:
      del self.operation.attributes["format"]

  @format.deleter
  def format(self):
    del self.operation.attributes["format"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def UDotAccSat(vector1, vector2, accumulator, *, format=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return UDotAccSatOp(vector1=vector1, vector2=vector2, accumulator=accumulator, format=format, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UDotOp(_ods_ir.OpView):
  r"""
  Result Type must be an integer type with Signedness of 0 whose Width
  must be greater than or equal to that of the components of Vector 1 and
  Vector 2.
  
  Vector 1 and Vector 2 must have the same type.
  
  Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
  DotProductInput4x8BitPacked capability) or vectors of integer type with
  Signedness of 0 (enabled by the DotProductInput4x8Bit or
  DotProductInputAll capability).
  
  When Vector 1 and Vector 2 are scalar integer types, Packed Vector
  Format must be specified to select how the integers are to be
  interpreted as vectors.
  
  All components of the input vectors are zero-extended to the bit width
  of the result's type. The zero-extended input vectors are then
  multiplied component-wise and all components of the vector resulting
  from the component-wise multiplication are added together. The resulting
  value will equal the low-order N bits of the correct result R, where N
  is the result width and R is computed with enough precision to avoid
  overflow and underflow.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %r = spirv.UDot %a, %b, <PackedVectorFormat4x8Bit> : i32 -> i32
  %r = spirv.UDot %a, %b, <PackedVectorFormat4x8Bit> : i32 -> i64
  %r = spirv.UDot %a, %b : vector<4xi8> -> i32
  ```
  """

  OPERATION_NAME = "spirv.UDot"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, vector1, vector2, *, format=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vector1)
    operands.append(vector2)
    _ods_context = _ods_get_default_loc_context(loc)
    if format is not None: attributes["format"] = (format if (
        isinstance(format, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SPIRV_PackedVectorFormatAttr')) else
          _ods_ir.AttrBuilder.get('SPIRV_PackedVectorFormatAttr')(format, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def vector2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def format(self) -> _Optional[_ods_ir.Attribute]:
    if "format" not in self.operation.attributes:
      return None
    return self.operation.attributes["format"]

  @format.setter
  def format(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["format"] = value
    elif "format" in self.operation.attributes:
      del self.operation.attributes["format"]

  @format.deleter
  def format(self):
    del self.operation.attributes["format"]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def UDot(result, vector1, vector2, *, format=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return UDotOp(result=result, vector1=vector1, vector2=vector2, format=format, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UGreaterThanEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  integer type.  They must have the same component width, and they must
  have the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.UGreaterThanEqual %0, %1 : i32
  %5 = spirv.UGreaterThanEqual %2, %3 : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.UGreaterThanEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def UGreaterThanEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return UGreaterThanEqualOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UGreaterThanOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  integer type.  They must have the same component width, and they must
  have the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.UGreaterThan %0, %1 : i32
  %5 = spirv.UGreaterThan %2, %3 : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.UGreaterThan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def UGreaterThan(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return UGreaterThanOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ULessThanEqualOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  integer type.  They must have the same component width, and they must
  have the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.ULessThanEqual %0, %1 : i32
  %5 = spirv.ULessThanEqual %2, %3 : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.ULessThanEqual"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ULessThanEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ULessThanEqualOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ULessThanOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  The type of Operand 1 and Operand 2  must be a scalar or vector of
  integer type.  They must have the same component width, and they must
  have the same number of components as Result Type.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.ULessThan %0, %1 : i32
  %5 = spirv.ULessThan %2, %3 : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.ULessThan"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def ULessThan(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ULessThanOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UModOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of integer type, whose Signedness
  operand is 0.
  
  The types of Operand 1 and Operand 2 both must be the same as Result
  Type.
  
  Results are computed per component.  The resulting value is undefined
  if Operand 2 is 0.
  
  #### Example:
  
  ```mlir
  %4 = spirv.UMod %0, %1 : i32
  %5 = spirv.UMod %2, %3 : vector<4xi32>
  ```
  """

  OPERATION_NAME = "spirv.UMod"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def UMod(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return UModOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UMulExtendedOp(_ods_ir.OpView):
  r"""
  Result Type must be from OpTypeStruct.  The struct must have two
  members, and the two members must be the same type.  The member type
  must be a scalar or vector of integer type, whose Signedness operand is
  0.
  
  Operand 1 and Operand 2 must have the same type as the members of Result
  Type. These are consumed as unsigned integers.
  
  Results are computed per component.
  
  Member 0 of the result gets the low-order bits of the multiplication.
  
  Member 1 of the result gets the high-order bits of the multiplication.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %2 = spirv.UMulExtended %0, %1 : !spirv.struct<(i32, i32)>
  %2 = spirv.UMulExtended %0, %1 : !spirv.struct<(vector<2xi32>, vector<2xi32>)>
  ```
  """

  OPERATION_NAME = "spirv.UMulExtended"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand1, operand2, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def UMulExtended(result, operand1, operand2, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return UMulExtendedOp(result=result, operand1=operand1, operand2=operand2, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UndefOp(_ods_ir.OpView):
  r"""
  Result Type is the type of object to make.
  
  Each consumption of Result <id> yields an arbitrary, possibly different
  bit pattern or abstract value resulting in possibly different concrete,
  abstract, or opaque values.
  
  #### Example:
  
  ```mlir
  %0 = spirv.Undef : f32
  %1 = spirv.Undef : !spirv.struct<!spirv.array<4 x vector<4xi32>>>
  ```
  """

  OPERATION_NAME = "spirv.Undef"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Undef(result, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return UndefOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnorderedOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar or vector of Boolean type.
  
  x must be a scalar or vector of floating-point type.  It must have the
  same number of components as Result Type.
  
  y must have the same type as x.
  
  Results are computed per component.
  
  #### Example:
  
  ```mlir
  %4 = spirv.Unordered %0, %1 : f32
  %5 = spirv.Unordered %2, %3 : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.Unordered"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand1, operand2, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand1)
    operands.append(operand2)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def operand2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Unordered(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return UnorderedOp(operand1=operand1, operand2=operand2, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UnreachableOp(_ods_ir.OpView):
  r"""
  This instruction must be the last instruction in a block.
  """

  OPERATION_NAME = "spirv.Unreachable"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def Unreachable(*, loc=None, ip=None) -> UnreachableOp:
  return UnreachableOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class VariableOp(_ods_ir.OpView):
  r"""
  Result Type must be an OpTypePointer. Its Type operand is the type of
  object in memory.
  
  Storage Class is the Storage Class of the memory holding the object.
  Since the op is used to model function-level variables, the storage class
  must be the `Function` Storage Class.
  
  Initializer is optional. If Initializer is present, it will be the
  initial value of the variable's memory content. Initializer must be an
  <id> from a constant instruction or a global (module scope) OpVariable
  instruction. Initializer must have the same type as the type pointed to
  by Result Type.
  
  From `SPV_KHR_physical_storage_buffer`:
  If an OpVariable's pointee type is a pointer (or array of pointers) in
  PhysicalStorageBuffer storage class, then the variable must be decorated
  with exactly one of AliasedPointer or RestrictPointer.
  
  <!-- End of AutoGen section -->
  
  ```
  variable-op ::= ssa-id `=` `spirv.Variable` (`init(` ssa-use `)`)?
                  attribute-dict? `:` spirv-pointer-type
  ```
  
  where `init` specifies initializer.
  
  #### Example:
  
  ```mlir
  %0 = spirv.Constant ...
  
  %1 = spirv.Variable : !spirv.ptr<f32, Function>
  %2 = spirv.Variable init(%0): !spirv.ptr<f32, Function>
  
  %3 = spirv.Variable {aliased_pointer} :
    !spirv.ptr<!spirv.ptr<f32, PhysicalStorageBuffer>, Function>
  ```
  """

  OPERATION_NAME = "spirv.Variable"

  _ODS_REGIONS = (0, True)

  def __init__(self, pointer, storage_class, *, initializer=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    if initializer is not None: operands.append(initializer)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["storage_class"] = (storage_class if (
    isinstance(storage_class, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SPIRV_StorageClassAttr')) else
      _ods_ir.AttrBuilder.get('SPIRV_StorageClassAttr')(storage_class, context=_ods_context))
    results = []
    results.append(pointer)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def initializer(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def storage_class(self) -> _ods_ir.Attribute:
    return self.operation.attributes["storage_class"]

  @storage_class.setter
  def storage_class(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["storage_class"] = value

  @builtins.property
  def pointer(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def Variable(pointer, storage_class, *, initializer=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return VariableOp(pointer=pointer, storage_class=storage_class, initializer=initializer, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VectorExtractDynamicOp(_ods_ir.OpView):
  r"""
  Result Type must be a scalar type.
  
  Vector must have a type OpTypeVector whose Component Type is Result
  Type.
  
  Index must be a scalar integer. It is interpreted as a 0-based index of
  which component of Vector to extract.
  
  Behavior is undefined if Index's value is less than zero or greater than
  or equal to the number of components in Vector.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```
  %2 = spirv.VectorExtractDynamic %0[%1] : vector<8xf32>, i32
  ```
  """

  OPERATION_NAME = "spirv.VectorExtractDynamic"

  _ODS_REGIONS = (0, True)

  def __init__(self, vector, index, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vector)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def index(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def VectorExtractDynamic(vector, index, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return VectorExtractDynamicOp(vector=vector, index=index, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VectorInsertDynamicOp(_ods_ir.OpView):
  r"""
  Result Type must be an OpTypeVector.
  
  Vector must have the same type as Result Type and is the vector that the
  non-written components are copied from.
  
  Component is the value supplied for the component selected by Index. It
  must have the same type as the type of components in Result Type.
  
  Index must be a scalar integer. It is interpreted as a 0-based index of
  which component to modify.
  
  Behavior is undefined if Index's value is less than zero or greater than
  or equal to the number of components in Vector.
  
  #### Example:
  
  ```mlir
  %scalar = ... : f32
  %2 = spirv.VectorInsertDynamic %scalar %0[%1] : f32, vector<8xf32>, i32
  ```
  """

  OPERATION_NAME = "spirv.VectorInsertDynamic"

  _ODS_REGIONS = (0, True)

  def __init__(self, vector, component, index, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vector)
    operands.append(component)
    operands.append(index)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def component(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def index(self) -> _ods_ir.Value:
    return self.operation.operands[2]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def VectorInsertDynamic(vector, component, index, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return VectorInsertDynamicOp(vector=vector, component=component, index=index, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VectorShuffleOp(_ods_ir.OpView):
  r"""
  Result Type must be an OpTypeVector. The number of components in Result
  Type must be the same as the number of Component operands.
  
  Vector 1 and Vector 2 must both have vector types, with the same
  Component Type as Result Type. They do not have to have the same number
  of components as Result Type or with each other. They are logically
  concatenated, forming a single vector with Vector 1's components
  appearing before Vector 2's. The components of this logical vector are
  logically numbered with a single consecutive set of numbers from 0 to N
  - 1, where N is the total number of components.
  
  Components are these logical numbers (see above), selecting which of the
  logically numbered components form the result. Each component is an
  unsigned 32-bit integer.  They can select the components in any order
  and can repeat components. The first component of the result is selected
  by the first Component operand,  the second component of the result is
  selected by the second Component operand, etc. A Component literal may
  also be FFFFFFFF, which means the corresponding result component has no
  source and is undefined. All Component literals must either be FFFFFFFF
  or in [0, N - 1] (inclusive).
  
  Note: A vector “swizzle” can be done by using the vector for both Vector
  operands, or using an OpUndef for one of the Vector operands.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.VectorShuffle [1: i32, 3: i32, 5: i32] %vector1, %vector2 :
    vector<4xf32>, vector<2xf32> -> vector<3xf32>
  ```
  """

  OPERATION_NAME = "spirv.VectorShuffle"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, vector1, vector2, components, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vector1)
    operands.append(vector2)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["components"] = (components if (
    isinstance(components, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I32ArrayAttr')) else
      _ods_ir.AttrBuilder.get('I32ArrayAttr')(components, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector1(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def vector2(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def components(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["components"]

  @components.setter
  def components(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["components"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def VectorShuffle(result, vector1, vector2, components, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return VectorShuffleOp(result=result, vector1=vector1, vector2=vector2, components=components, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VectorTimesMatrixOp(_ods_ir.OpView):
  r"""
  Result Type must be a vector of floating-point type.
  
  Vector must be a vector with the same Component Type as the Component
  Type in Result Type. Its number of components must equal the number of
  components in each column in Matrix.
  
  Matrix must be a matrix with the same Component Type as the Component
  Type in Result Type. Its number of columns must equal the number of
  components in Result Type.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %result = spirv.VectorTimesMatrix %vector, %matrix : vector<4xf32>, !spirv.matrix<4 x vector<4xf32>> -> vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.VectorTimesMatrix"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, vector, matrix, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vector)
    operands.append(matrix)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def matrix(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def VectorTimesMatrix(result, vector, matrix, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return VectorTimesMatrixOp(result=result, vector=vector, matrix=matrix, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class VectorTimesScalarOp(_ods_ir.OpView):
  r"""
  Result Type must be a vector of floating-point type.
  
   The type of Vector must be the same as Result Type. Each component of
  Vector is multiplied by Scalar.
  
  Scalar must have the same type as the Component Type in Result Type.
  
  <!-- End of AutoGen section -->
  
  #### Example:
  
  ```mlir
  %0 = spirv.VectorTimesScalar %vector, %scalar : vector<4xf32>
  ```
  """

  OPERATION_NAME = "spirv.VectorTimesScalar"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, vector, scalar, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(vector)
    operands.append(scalar)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def vector(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def scalar(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def VectorTimesScalar(result, vector, scalar, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return VectorTimesScalarOp(result=result, vector=vector, scalar=scalar, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  r"""
  This op is a special terminator whose only purpose is to terminate
  an `spirv.SpecConstantOperation`'s enclosed region. It accepts a
  single operand produced by the preceeding (and only other) instruction
  in its parent block (see SPIRV_SpecConstantOperation for further
  details). This op has no corresponding SPIR-V instruction.
  
  #### Example:
  
  ```mlir
  %0 = ... (some op supported by SPIR-V OpSpecConstantOp)
  spirv.mlir.yield %0
  ```
  """

  OPERATION_NAME = "spirv.mlir.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def mlir_yield(operand, *, loc=None, ip=None) -> YieldOp:
  return YieldOp(operand=operand, loc=loc, ip=ip)
