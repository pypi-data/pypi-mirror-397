
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "async"

@_ods_cext.register_operation(_Dialect)
class AddToGroupOp(_ods_ir.OpView):
  r"""
  The `async.add_to_group` adds an async token or value to the async group.
  Returns the rank of the added element in the group. This rank is fixed
  for the group lifetime.
  
  Example:
  
  ```mlir
  %0 = async.create_group %size : !async.group
  %1 = ... : !async.token
  %2 = async.add_to_group %1, %0 : !async.token
  ```
  """

  OPERATION_NAME = "async.add_to_group"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, group, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(group)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def group(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def rank(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def add_to_group(operand, group, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AddToGroupOp(operand=operand, group=group, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AwaitAllOp(_ods_ir.OpView):
  r"""
  The `async.await_all` operation waits until all the tokens or values in the
  group become ready.
  
  Example:
  
  ```mlir
  %0 = async.create_group %size : !async.group
  
  %1 = ... : !async.token
  %2 = async.add_to_group %1, %0 : !async.token
  
  %3 = ... : !async.token
  %4 = async.add_to_group %2, %0 : !async.token
  
  async.await_all %0
  ```
  """

  OPERATION_NAME = "async.await_all"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def await_all(operand, *, loc=None, ip=None) -> AwaitAllOp:
  return AwaitAllOp(operand=operand, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AwaitOp(_ods_ir.OpView):
  r"""
  The `async.await` operation waits until the argument becomes ready, and for
  the `async.value` arguments it unwraps the underlying value
  
  Example:
  
  ```mlir
  %0 = ... : !async.token
  async.await %0 : !async.token
  
  %1 = ... : !async.value<f32>
  %2 = async.await %1 : !async.value<f32>
  ```
  """

  OPERATION_NAME = "async.await"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    if result is not None: results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _Optional[_ods_ir.OpResult]:
    return None if len(self.operation.results) < 1 else self.operation.results[0]

def await_(result, operand, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, AwaitOp]:
  op = AwaitOp(result=result, operand=operand, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class CallOp(_ods_ir.OpView):
  r"""
  The `async.call` operation represents a direct call to an async function
  that is within the same symbol scope as the call. The operands and result
  types of the call must match the specified async function type. The callee
  is encoded as a symbol reference attribute named "callee".
  
  Example:
  
  ```mlir
  %2 = async.call @my_add(%0, %1) : (f32, f32) -> !async.value<f32>
  ```
  """

  OPERATION_NAME = "async.call"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, callee, operands_, *, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["callee"] = (callee if (
    isinstance(callee, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('FlatSymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('FlatSymbolRefAttr')(callee, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    results.extend(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def callee(self) -> _ods_ir.FlatSymbolRefAttr:
    return self.operation.attributes["callee"]

  @callee.setter
  def callee(self, value: _ods_ir.FlatSymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["callee"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

def call(result, callee, operands_, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, CallOp]:
  op = CallOp(result=result, callee=callee, operands_=operands_, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class CoroBeginOp(_ods_ir.OpView):
  r"""
  The `async.coro.begin` allocates a coroutine frame and returns a handle to
  the coroutine.
  """

  OPERATION_NAME = "async.coro.begin"

  _ODS_REGIONS = (0, True)

  def __init__(self, id, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(id)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def id(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def handle(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def coro_begin(id, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CoroBeginOp(id=id, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CoroEndOp(_ods_ir.OpView):
  r"""
  The `async.coro.end` marks the point where a coroutine needs to return
  control back to the caller if it is not an initial invocation of the
  coroutine. It the start part of the coroutine is is no-op.
  """

  OPERATION_NAME = "async.coro.end"

  _ODS_REGIONS = (0, True)

  def __init__(self, handle, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(handle)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def handle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def coro_end(handle, *, loc=None, ip=None) -> CoroEndOp:
  return CoroEndOp(handle=handle, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CoroFreeOp(_ods_ir.OpView):
  r"""
  The `async.coro.free` deallocates the coroutine frame created by the
  async.coro.begin operation.
  """

  OPERATION_NAME = "async.coro.free"

  _ODS_REGIONS = (0, True)

  def __init__(self, id, handle, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(id)
    operands.append(handle)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def id(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def handle(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def coro_free(id, handle, *, loc=None, ip=None) -> CoroFreeOp:
  return CoroFreeOp(id=id, handle=handle, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CoroIdOp(_ods_ir.OpView):
  r"""
  The `async.coro.id` returns a switched-resume coroutine identifier.
  """

  OPERATION_NAME = "async.coro.id"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def id(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def coro_id(*, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CoroIdOp(results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CoroSaveOp(_ods_ir.OpView):
  r"""
  The `async.coro.saves` saves the coroutine state.
  """

  OPERATION_NAME = "async.coro.save"

  _ODS_REGIONS = (0, True)

  def __init__(self, handle, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(handle)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def handle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def state(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def coro_save(handle, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CoroSaveOp(handle=handle, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CoroSuspendOp(_ods_ir.OpView):
  r"""
  The `async.coro.suspend` suspends the coroutine and transfers control to the
  `suspend` successor. If suspended coroutine later resumed it will transfer
  control to the `resume` successor. If it is destroyed it will transfer
  control to the the `cleanup` successor.
  
  In switched-resume lowering coroutine can be already in resumed state when
  suspend operation is called, in this case control will be transferred to the
  `resume` successor skipping the `suspend` successor.
  """

  OPERATION_NAME = "async.coro.suspend"

  _ODS_REGIONS = (0, True)

  def __init__(self, state, suspendDest, resumeDest, cleanupDest, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(state)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = []
    _ods_successors.append(suspendDest)
    _ods_successors.append(resumeDest)
    _ods_successors.append(cleanupDest)
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def state(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def coro_suspend(state, suspend_dest, resume_dest, cleanup_dest, *, loc=None, ip=None) -> CoroSuspendOp:
  return CoroSuspendOp(state=state, suspendDest=suspend_dest, resumeDest=resume_dest, cleanupDest=cleanup_dest, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CreateGroupOp(_ods_ir.OpView):
  r"""
  The `async.create_group` allocates an empty async group. Async tokens or
  values can be added to this group later. The size of the group must be
  specified at construction time, and `await_all` operation will first
  wait until the number of added tokens or values reaches the group size.
  
  Example:
  
  ```mlir
  %size = ... : index
  %group = async.create_group %size : !async.group
  ...
  async.await_all %group
  ```
  """

  OPERATION_NAME = "async.create_group"

  _ODS_REGIONS = (0, True)

  def __init__(self, size, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def size(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def create_group(size, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CreateGroupOp(size=size, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ExecuteOp(_ods_ir.OpView):
  r"""
   The `body` region attached to the `async.execute` operation semantically
   can be executed concurrently with the successor operation. In the followup
   example "compute0" can be executed concurrently with "compute1".
  
   The actual concurrency semantics depends on the dialect lowering to the
   executable format. Fully sequential execution ("compute0" completes before
   "compute1" starts) is a completely legal execution.
  
   Because concurrent execution is not guaranteed, it is illegal to create an
   implicit dependency from "compute1" to "compute0" (e.g. via shared global
   state). All dependencies must be made explicit with async execute arguments
   (`async.token` or `async.value`).
  
  `async.execute` operation takes `async.token` dependencies and `async.value`
   operands separately, and starts execution of the attached body region only
   when all tokens and values become ready.
  
   Example:
  
   ```mlir
   %dependency = ... : !async.token
   %value = ... : !async.value<f32>
  
   %token, %results =
     async.execute [%dependency](%value as %unwrapped: !async.value<f32>)
                -> !async.value<!some.type>
     {
       %0 = "compute0"(%unwrapped): (f32) -> !some.type
       async.yield %0 : !some.type
     }
  
   %1 = "compute1"(...) : !some.type
   ```
  
   In the example above asynchronous execution starts only after dependency
   token and value argument become ready. Unwrapped value passed to the
   attached body region as an %unwrapped value of f32 type.
  """

  OPERATION_NAME = "async.execute"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, token, bodyResults, dependencies, bodyOperands, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(dependencies))
    operands.append(_get_op_results_or_values(bodyOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(token)
    results.extend(bodyResults)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dependencies(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def bodyOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def token(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def bodyResults(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

  @builtins.property
  def bodyRegion(self) -> _ods_ir.Region:
    return self.regions[0]

def execute(token, body_results, dependencies, body_operands, *, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, ExecuteOp]:
  op = ExecuteOp(token=token, bodyResults=body_results, dependencies=dependencies, bodyOperands=body_operands, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class FuncOp(_ods_ir.OpView):
  r"""
  An async function is like a normal function, but supports non-blocking
  await. Internally, async function is lowered to the LLVM coroutinue with
  async runtime intrinsic. It can return an async token and/or async values.
  The token represents the execution state of async function and can be used
  when users want to express dependencies on some side effects, e.g.,
  the token becomes available once every thing in the func body is executed.
  
  Example:
  
  ```mlir
  // Async function can't return void, it always must be some async thing.
  async.func @async.0() -> !async.token {
    return
  }
  
  // Function returns only async value.
  async.func @async.1() -> !async.value<i32> {
    %0 = arith.constant 42 : i32
    return %0 : i32
  }
  
  // Implicit token can be added to return types.
  async.func @async.2() -> !async.token, !async.value<i32> {
    %0 = arith.constant 42 : i32
    return %0 : i32
  }
  ```
  """

  OPERATION_NAME = "async.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_444')) else
      _ods_ir.AttrBuilder.get('anonymous_444')(function_type, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def func(sym_name, function_type, *, sym_visibility=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> FuncOp:
  return FuncOp(sym_name=sym_name, function_type=function_type, sym_visibility=sym_visibility, arg_attrs=arg_attrs, res_attrs=res_attrs, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  r"""
  The `async.return` is a special terminator operation for Async function.
  
  Example:
  
  ```mlir
  async.func @foo() : !async.token {
    return
  }
  ```
  """

  OPERATION_NAME = "async.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(operands_, *, loc=None, ip=None) -> ReturnOp:
  return ReturnOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RuntimeAddRefOp(_ods_ir.OpView):
  r"""
  The `async.runtime.add_ref` operation adds a reference(s) to async value
  (token, value or group).
  """

  OPERATION_NAME = "async.runtime.add_ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def runtime_add_ref(operand, count, *, loc=None, ip=None) -> RuntimeAddRefOp:
  return RuntimeAddRefOp(operand=operand, count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RuntimeAddToGroupOp(_ods_ir.OpView):
  r"""
  The `async.runtime.add_to_group` adds an async token or value to the async
  group. Returns the rank of the added element in the group.
  """

  OPERATION_NAME = "async.runtime.add_to_group"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, group, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(group)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def group(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def rank(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def runtime_add_to_group(operand, group, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RuntimeAddToGroupOp(operand=operand, group=group, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RuntimeAwaitAndResumeOp(_ods_ir.OpView):
  r"""
  The `async.runtime.await_and_resume` operation awaits for the operand to
  become available or error and resumes the coroutine on a thread managed by
  the runtime.
  """

  OPERATION_NAME = "async.runtime.await_and_resume"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, handle, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    operands.append(handle)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def handle(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def runtime_await_and_resume(operand, handle, *, loc=None, ip=None) -> RuntimeAwaitAndResumeOp:
  return RuntimeAwaitAndResumeOp(operand=operand, handle=handle, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RuntimeAwaitOp(_ods_ir.OpView):
  r"""
  The `async.runtime.await` operation blocks the caller thread until the
  operand becomes available or error.
  """

  OPERATION_NAME = "async.runtime.await"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def runtime_await(operand, *, loc=None, ip=None) -> RuntimeAwaitOp:
  return RuntimeAwaitOp(operand=operand, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RuntimeCreateGroupOp(_ods_ir.OpView):
  r"""
  The `async.runtime.create_group` operation creates an async dialect group
  of the given size. Group created in the empty state.
  """

  OPERATION_NAME = "async.runtime.create_group"

  _ODS_REGIONS = (0, True)

  def __init__(self, size, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(size)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def size(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def runtime_create_group(size, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RuntimeCreateGroupOp(size=size, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RuntimeCreateOp(_ods_ir.OpView):
  r"""
  The `async.runtime.create` operation creates an async dialect token or
  value. Tokens and values are created in the non-ready state.
  """

  OPERATION_NAME = "async.runtime.create"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def runtime_create(result, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return RuntimeCreateOp(result=result, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RuntimeDropRefOp(_ods_ir.OpView):
  r"""
  The `async.runtime.drop_ref` operation drops a reference(s) to async value
  (token, value or group).
  """

  OPERATION_NAME = "async.runtime.drop_ref"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, count, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["count"] = (count if (
    isinstance(count, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(count, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def count(self) -> _ods_ir.IntegerAttr:
    return self.operation.attributes["count"]

  @count.setter
  def count(self, value: _ods_ir.IntegerAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["count"] = value

def runtime_drop_ref(operand, count, *, loc=None, ip=None) -> RuntimeDropRefOp:
  return RuntimeDropRefOp(operand=operand, count=count, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RuntimeIsErrorOp(_ods_ir.OpView):
  r"""
  The `async.runtime.is_error` operation returns true if the token, value or
  group (any of the async runtime values) is in the error state. It is the
  caller responsibility to check error state after the call to `await` or
  resuming after `await_and_resume`.
  """

  OPERATION_NAME = "async.runtime.is_error"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def is_error(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def runtime_is_error(operand, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RuntimeIsErrorOp(operand=operand, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RuntimeLoadOp(_ods_ir.OpView):
  r"""
  The `async.runtime.load` operation loads the value from the runtime
  async.value storage.
  """

  OPERATION_NAME = "async.runtime.load"

  _ODS_REGIONS = (0, True)

  def __init__(self, storage, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(storage)
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def storage(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def runtime_load(storage, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RuntimeLoadOp(storage=storage, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RuntimeNumWorkerThreadsOp(_ods_ir.OpView):
  r"""
  The `async.runtime.num_worker_threads` operation gets the number of threads
  in the threadpool from the runtime.
  """

  OPERATION_NAME = "async.runtime.num_worker_threads"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def runtime_num_worker_threads(*, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RuntimeNumWorkerThreadsOp(results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RuntimeResumeOp(_ods_ir.OpView):
  r"""
  The `async.runtime.resume` operation resumes the coroutine on a thread
  managed by the runtime.
  """

  OPERATION_NAME = "async.runtime.resume"

  _ODS_REGIONS = (0, True)

  def __init__(self, handle, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(handle)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def handle(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def runtime_resume(handle, *, loc=None, ip=None) -> RuntimeResumeOp:
  return RuntimeResumeOp(handle=handle, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RuntimeSetAvailableOp(_ods_ir.OpView):
  r"""
  The `async.runtime.set_available` operation switches async token or value
  state to available.
  """

  OPERATION_NAME = "async.runtime.set_available"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def runtime_set_available(operand, *, loc=None, ip=None) -> RuntimeSetAvailableOp:
  return RuntimeSetAvailableOp(operand=operand, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RuntimeSetErrorOp(_ods_ir.OpView):
  r"""
  The `async.runtime.set_error` operation switches async token or value
  state to error.
  """

  OPERATION_NAME = "async.runtime.set_error"

  _ODS_REGIONS = (0, True)

  def __init__(self, operand, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(operand)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operand(self) -> _ods_ir.Value:
    return self.operation.operands[0]

def runtime_set_error(operand, *, loc=None, ip=None) -> RuntimeSetErrorOp:
  return RuntimeSetErrorOp(operand=operand, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RuntimeStoreOp(_ods_ir.OpView):
  r"""
  The `async.runtime.store` operation stores the value into the runtime
  async.value storage.
  """

  OPERATION_NAME = "async.runtime.store"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, storage, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.append(storage)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def storage(self) -> _ods_ir.Value:
    return self.operation.operands[1]

def runtime_store(value, storage, *, loc=None, ip=None) -> RuntimeStoreOp:
  return RuntimeStoreOp(value=value, storage=storage, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  r"""
  The `async.yield` is a special terminator operation for the block inside
  `async.execute` operation.
  """

  OPERATION_NAME = "async.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(operands_, *, loc=None, ip=None) -> YieldOp:
  return YieldOp(operands_=operands_, loc=loc, ip=ip)
