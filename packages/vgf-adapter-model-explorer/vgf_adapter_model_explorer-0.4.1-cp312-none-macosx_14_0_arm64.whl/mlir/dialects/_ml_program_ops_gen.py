
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "ml_program"

@_ods_cext.register_operation(_Dialect)
class FuncOp(_ods_ir.OpView):
  r"""
  This simple function container represents callables in an ML program where
  the body is an `SSACFG` region. It must be terminated by a `return` op which
  yields values with the same arity and types as the `FunctionType` results
  of the containing `func`.
  
  This op is a `Symbol` but does not introduce a new `SymbolTable`. As such,
  it cannot represent nested symbols.
  
  Example:
  
  ```mlir
  ml_program.func private @some_extern(i32) -> i32
  ml_program.func @compute(%arg0 : i32) -> i32 {
    ml_program.return %arg0 : i32
  }
  ```
  """

  OPERATION_NAME = "ml_program.func"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, arg_attrs=None, res_attrs=None, sym_visibility=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_424')) else
      _ods_ir.AttrBuilder.get('anonymous_424')(function_type, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def func(sym_name, function_type, *, arg_attrs=None, res_attrs=None, sym_visibility=None, loc=None, ip=None) -> FuncOp:
  return FuncOp(sym_name=sym_name, function_type=function_type, arg_attrs=arg_attrs, res_attrs=res_attrs, sym_visibility=sym_visibility, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalLoadConstOp(_ods_ir.OpView):
  r"""
  Loads a constant (immutable) value from a global directly by symbol.
  
  This op is only legal for globals that are not mutable and exists because
  such a load can be considered to have no side effects.
  
  Example:
  
  ```mlir
  %0 = ml_program.global_load_const @foobar : tensor<?xi32>
  ```
  """

  OPERATION_NAME = "ml_program.global_load_const"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, global_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(global_, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def global_load_const(result, global_, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadConstOp(result=result, global_=global_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadGraphOp(_ods_ir.OpView):
  r"""
  Performs a non-atomic, non-volatile, non-synchronized load from a global
  that may be mutable.
  
  It is fully expected that these constraints are not suitable for all
  situations, and alternative ops should be defined and used for more advanced
  cases.
  
  This op is side effecting and may not be valid to use in graph regions
  without additional consideration to evaluation order constraints.
  
  Example:
  
  ```mlir
  %0, %cstr = ml_program.global_load_graph @foobar
    ordering (%token -> !ml_program.token) : tensor<?xi32>
  ```
  """

  OPERATION_NAME = "ml_program.global_load_graph"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, produceToken, global_, consumeTokens, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(consumeTokens))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(global_, context=_ods_context))
    results = []
    results.append(result)
    results.append(produceToken)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def consumeTokens(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def global_(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

  @builtins.property
  def produceToken(self) -> _ods_ir.OpResult:
    return self.operation.results[1]

def global_load_graph(result, produce_token, global_, consume_tokens, *, loc=None, ip=None) -> _ods_ir.OpResultList:
  return GlobalLoadGraphOp(result=result, produceToken=produce_token, global_=global_, consumeTokens=consume_tokens, loc=loc, ip=ip).results

@_ods_cext.register_operation(_Dialect)
class GlobalLoadOp(_ods_ir.OpView):
  r"""
  Performs a non-atomic, non-volatile, non-synchronized load from a global
  that may be mutable.
  
  It is fully expected that these constraints are not suitable for
  all situations, and alternative ops should be defined and used for more
  advanced cases.
  
  This op is side effecting and may not be valid to use in graph regions
  without additional consideration to evaluation order constraints. See
  `global_load_graph` for op which allows for explicit ordering constraints.
  
  Example:
  
  ```mlir
  %0 = ml_program.global_load @foobar : tensor<?xi32>
  ```
  """

  OPERATION_NAME = "ml_program.global_load"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, global_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(global_, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def global_(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def global_load(result, global_, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalLoadOp(result=result, global_=global_, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalOp(_ods_ir.OpView):
  r"""
  Declares a named global variable (or constant).
  
  A global contains a value of a specified type which can be accessed at
  runtime via appropriate load/store operations. It can be mutable or
  constant, optionally taking an initial value or declared as
  extern (in which case, the initial value is found in external storage
  by symbol name).
  
  Generally, the type of the global and the type of the initial value
  will be the same. However, for type hierarchies which can have a more
  generalized bounding type that can be assigned from a narrow type, this
  is allowed (but not verified).
  
  Examples:
  
  ```mlir
  // Constant global.
  ml_program.global @foobar(dense<4> : tensor<4xi32>) : tensor<?xi32>
  
  // Constant with external linkage.
  ml_program.global mutable @foobar(#ml_program.extern<tensor<4xi32>>)
    : tensor<?xi32>
  
  // Mutable global with an undefined initial value.
  ml_program.global mutable @foobar : tensor<?xi32>
  ```
  """

  OPERATION_NAME = "ml_program.global"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, type_, *, is_mutable=None, value=None, sym_visibility=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    if bool(is_mutable): attributes["is_mutable"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if value is not None: attributes["value"] = (value if (
        isinstance(value, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('AnyAttr')) else
          _ods_ir.AttrBuilder.get('AnyAttr')(value, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def is_mutable(self) -> bool:
    return "is_mutable" in self.operation.attributes

  @is_mutable.setter
  def is_mutable(self, value):
    if bool(value):
      self.operation.attributes["is_mutable"] = _ods_ir.UnitAttr.get()
    elif "is_mutable" in self.operation.attributes:
      del self.operation.attributes["is_mutable"]

  @is_mutable.deleter
  def is_mutable(self):
    del self.operation.attributes["is_mutable"]

  @builtins.property
  def value(self) -> _Optional[_ods_ir.Attribute]:
    if "value" not in self.operation.attributes:
      return None
    return self.operation.attributes["value"]

  @value.setter
  def value(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["value"] = value
    elif "value" in self.operation.attributes:
      del self.operation.attributes["value"]

  @value.deleter
  def value(self):
    del self.operation.attributes["value"]

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

def global_(sym_name, type_, *, is_mutable=None, value=None, sym_visibility=None, loc=None, ip=None) -> GlobalOp:
  return GlobalOp(sym_name=sym_name, type_=type_, is_mutable=is_mutable, value=value, sym_visibility=sym_visibility, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalStoreGraphOp(_ods_ir.OpView):
  r"""
  Performs a non-atomic, non-volatile, non-synchronized store to a mutable
  global.
  
  It is fully expected that these constraints are not suitable for
  all situations, and alternative ops should be defined and used for more
  advanced cases.
  
  This op is side effecting and may not be valid to use in graph regions
  without additional consideration to evaluation order constraints.
  
  Example:
  
  ```mlir
  %token = ml_program.global_store @foobar = %0 : tensor<?xi32>
    ordering (%in_token -> !ml_program.token) : tensor<?xi32>
  ```
  """

  OPERATION_NAME = "ml_program.global_store_graph"

  _ODS_REGIONS = (0, True)

  def __init__(self, produceToken, global_, value, consumeTokens, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    operands.extend(_get_op_results_or_values(consumeTokens))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(global_, context=_ods_context))
    results = []
    results.append(produceToken)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def consumeTokens(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 2 + 1
    return self.operation.operands[1:1 + _ods_variadic_group_length]

  @builtins.property
  def global_(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

  @builtins.property
  def produceToken(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def global_store_graph(produce_token, global_, value, consume_tokens, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GlobalStoreGraphOp(produceToken=produce_token, global_=global_, value=value, consumeTokens=consume_tokens, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalStoreOp(_ods_ir.OpView):
  r"""
  Performs a non-atomic, non-volatile, non-synchronized store to a mutable
  global.
  
  It is fully expected that these constraints are not suitable for
  all situations, and alternative ops should be defined and used for more
  advanced cases.
  
  This op is side effecting and may not be valid to use in graph regions
  without additional consideration to evaluation order constraints. See
  `global_store_graph` for op which allows for explicit ordering constraints.
  
  Example:
  
  ```mlir
  ml_program.global_store @foobar = %0 : tensor<?xi32>
  ```
  """

  OPERATION_NAME = "ml_program.global_store"

  _ODS_REGIONS = (0, True)

  def __init__(self, global_, value, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(value)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["global"] = (global_ if (
    isinstance(global_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(global_, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def value(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def global_(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["global"]

  @global_.setter
  def global_(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["global"] = value

def global_store(global_, value, *, loc=None, ip=None) -> GlobalStoreOp:
  return GlobalStoreOp(global_=global_, value=value, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class OutputOp(_ods_ir.OpView):
  r"""
  The `output` operation terminates a subgraph by yielding values
  to the caller.
  The operation takes variable number of operands and produces no results.
  The operand number and types must match the signature of the function
  that contains the operation.
  """

  OPERATION_NAME = "ml_program.output"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def output(operands_, *, loc=None, ip=None) -> OutputOp:
  return OutputOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReturnOp(_ods_ir.OpView):
  r"""
  The `return` operation terminates a `func` function by yielding values
  to the caller.
  The operation takes variable number of operands and produces no results.
  The operand number and types must match the signature of the function
  that contains the operation.
  """

  OPERATION_NAME = "ml_program.return"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def return_(operands_, *, loc=None, ip=None) -> ReturnOp:
  return ReturnOp(operands_=operands_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SubgraphOp(_ods_ir.OpView):
  r"""
  This simple function container represents callables in an ML program where
  the body is a `Graph` region containing a single block. It must be
  terminated by an `output` op which yields values with the same arity and
  types as the `FunctionType` results of the containing `subgraph`.
  
  This op is a `Symbol` but does not introduce a new `SymbolTable`. As such,
  it cannot represented nested symbols.
  
  Example:
  
  ```mlir
  ml_program.subgraph private @some_extern(i32) -> i32
  ml_program.subgraph @compute(%arg0 : i32) -> i32 {
    ml_program.output %arg0 : i32
  }
  ```
  """

  OPERATION_NAME = "ml_program.subgraph"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, function_type, *, arg_attrs=None, res_attrs=None, sym_visibility=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["function_type"] = (function_type if (
    isinstance(function_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_424')) else
      _ods_ir.AttrBuilder.get('anonymous_424')(function_type, context=_ods_context))
    if arg_attrs is not None: attributes["arg_attrs"] = (arg_attrs if (
        isinstance(arg_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(arg_attrs, context=_ods_context))
    if res_attrs is not None: attributes["res_attrs"] = (res_attrs if (
        isinstance(res_attrs, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DictArrayAttr')) else
          _ods_ir.AttrBuilder.get('DictArrayAttr')(res_attrs, context=_ods_context))
    if sym_visibility is not None: attributes["sym_visibility"] = (sym_visibility if (
        isinstance(sym_visibility, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(sym_visibility, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def function_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["function_type"]

  @function_type.setter
  def function_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["function_type"] = value

  @builtins.property
  def arg_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "arg_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["arg_attrs"]

  @arg_attrs.setter
  def arg_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["arg_attrs"] = value
    elif "arg_attrs" in self.operation.attributes:
      del self.operation.attributes["arg_attrs"]

  @arg_attrs.deleter
  def arg_attrs(self):
    del self.operation.attributes["arg_attrs"]

  @builtins.property
  def res_attrs(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "res_attrs" not in self.operation.attributes:
      return None
    return self.operation.attributes["res_attrs"]

  @res_attrs.setter
  def res_attrs(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["res_attrs"] = value
    elif "res_attrs" in self.operation.attributes:
      del self.operation.attributes["res_attrs"]

  @res_attrs.deleter
  def res_attrs(self):
    del self.operation.attributes["res_attrs"]

  @builtins.property
  def sym_visibility(self) -> _Optional[_ods_ir.StringAttr]:
    if "sym_visibility" not in self.operation.attributes:
      return None
    return self.operation.attributes["sym_visibility"]

  @sym_visibility.setter
  def sym_visibility(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["sym_visibility"] = value
    elif "sym_visibility" in self.operation.attributes:
      del self.operation.attributes["sym_visibility"]

  @sym_visibility.deleter
  def sym_visibility(self):
    del self.operation.attributes["sym_visibility"]

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def subgraph(sym_name, function_type, *, arg_attrs=None, res_attrs=None, sym_visibility=None, loc=None, ip=None) -> SubgraphOp:
  return SubgraphOp(sym_name=sym_name, function_type=function_type, arg_attrs=arg_attrs, res_attrs=res_attrs, sym_visibility=sym_visibility, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TokenOp(_ods_ir.OpView):
  r"""
  Token values are used to chain side effecting ops in a graph so as to
  establish an execution order. This op produces a token.
  """

  OPERATION_NAME = "ml_program.token"

  _ODS_REGIONS = (0, True)

  def __init__(self, token, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(token)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def token(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def token(token, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return TokenOp(token=token, loc=loc, ip=ip).result
