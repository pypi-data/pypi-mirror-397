
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "acc"

@_ods_cext.register_operation(_Dialect)
class AtomicCaptureOp(_ods_ir.OpView):
  r"""
  This operation performs an atomic capture.
  
  The region has the following allowed forms:
  
  ```
    acc.atomic.capture {
      acc.atomic.update ...
      acc.atomic.read ...
      acc.terminator
    }
  
    acc.atomic.capture {
      acc.atomic.read ...
      acc.atomic.update ...
      acc.terminator
    }
  
    acc.atomic.capture {
      acc.atomic.read ...
      acc.atomic.write ...
      acc.terminator
    }
  ```
  
  """

  OPERATION_NAME = "acc.atomic.capture"

  _ODS_REGIONS = (1, True)

  def __init__(self, *, ifCond=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    if ifCond is not None: operands.append(ifCond)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ifCond(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def atomic_capture(*, if_cond=None, loc=None, ip=None) -> AtomicCaptureOp:
  return AtomicCaptureOp(ifCond=if_cond, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AtomicReadOp(_ods_ir.OpView):
  r"""
  This operation performs an atomic read.
  
  The operand `x` is the address from where the value is atomically read.
  The operand `v` is the address where the value is stored after reading.
  """

  OPERATION_NAME = "acc.atomic.read"

  _ODS_REGIONS = (0, True)

  def __init__(self, x, v, element_type, *, ifCond=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(v)
    if ifCond is not None: operands.append(ifCond)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["element_type"] = (element_type if (
    isinstance(element_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(element_type, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def v(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def ifCond(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

  @builtins.property
  def element_type(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["element_type"]

  @element_type.setter
  def element_type(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["element_type"] = value

def atomic_read(x, v, element_type, *, if_cond=None, loc=None, ip=None) -> AtomicReadOp:
  return AtomicReadOp(x=x, v=v, element_type=element_type, ifCond=if_cond, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AtomicUpdateOp(_ods_ir.OpView):
  r"""
  This operation performs an atomic update.
  
  The operand `x` is exactly the same as the operand `x` in the OpenACC
  Standard (OpenACC 3.3, section 2.12). It is the address of the variable
  that is being updated. `x` is atomically read/written.
  
  The region describes how to update the value of `x`. It takes the value at
  `x` as an input and must yield the updated value. Only the update to `x` is
  atomic. Generally the region must have only one instruction, but can
  potentially have more than one instructions too. The update is sematically
  similar to a compare-exchange loop based atomic update.
  
  The syntax of atomic update operation is different from atomic read and
  atomic write operations. This is because only the host dialect knows how to
  appropriately update a value. For example, while generating LLVM IR, if
  there are no special `atomicrmw` instructions for the operation-type
  combination in atomic update, a compare-exchange loop is generated, where
  the core update operation is directly translated like regular operations by
  the host dialect. The front-end must handle semantic checks for allowed
  operations.
  """

  OPERATION_NAME = "acc.atomic.update"

  _ODS_REGIONS = (1, True)

  def __init__(self, x, *, ifCond=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    if ifCond is not None: operands.append(ifCond)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def ifCond(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def atomic_update(x, *, if_cond=None, loc=None, ip=None) -> AtomicUpdateOp:
  return AtomicUpdateOp(x=x, ifCond=if_cond, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AtomicWriteOp(_ods_ir.OpView):
  r"""
  This operation performs an atomic write.
  
  The operand `x` is the address to where the `expr` is atomically
  written w.r.t. multiple threads. The evaluation of `expr` need not be
  atomic w.r.t. the write to address. In general, the type(x) must
  dereference to type(expr).
  """

  OPERATION_NAME = "acc.atomic.write"

  _ODS_REGIONS = (0, True)

  def __init__(self, x, expr, *, ifCond=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(x)
    operands.append(expr)
    if ifCond is not None: operands.append(ifCond)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def x(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def expr(self) -> _ods_ir.Value:
    return self.operation.operands[1]

  @builtins.property
  def ifCond(self) -> _Optional[_ods_ir.Value]:
    return None if len(self.operation.operands) < 3 else self.operation.operands[2]

def atomic_write(x, expr, *, if_cond=None, loc=None, ip=None) -> AtomicWriteOp:
  return AtomicWriteOp(x=x, expr=expr, ifCond=if_cond, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AttachOp(_ods_ir.OpView):
  r"""
  Description of arguments:
  - `var`: The variable to copy. Must be either `MappableType` or
  `PointerLikeType`.
  - `varType`: The type of the variable that is being copied. When `var` is
  a `MappableType`, this matches the type of `var`. When `var` is a
  `PointerLikeType`, this type holds information about the target of the
  pointer.
  - `varPtrPtr`: Specifies the address of the address of `var` - only used
  when the variable copied is a field in a struct. This is important for
  OpenACC due to implicit attach semantics on data clauses (2.6.4).
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, readonly, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data entry operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.attach"

  _ODS_OPERAND_SEGMENTS = [1,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, varPtrPtr=None, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(var)
    operands.append(varPtrPtr)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(accVar)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def varPtrPtr(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def accVar(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def attach(acc_var, var, var_type, bounds, async_operands, *, var_ptr_ptr=None, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AttachOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, varPtrPtr=var_ptr_ptr, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CacheOp(_ods_ir.OpView):
  r"""
  Description of arguments:
  - `var`: The variable to copy. Must be either `MappableType` or
  `PointerLikeType`.
  - `varType`: The type of the variable that is being copied. When `var` is
  a `MappableType`, this matches the type of `var`. When `var` is a
  `PointerLikeType`, this type holds information about the target of the
  pointer.
  - `varPtrPtr`: Specifies the address of the address of `var` - only used
  when the variable copied is a field in a struct. This is important for
  OpenACC due to implicit attach semantics on data clauses (2.6.4).
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, readonly, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data entry operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.cache"

  _ODS_OPERAND_SEGMENTS = [1,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, varPtrPtr=None, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(var)
    operands.append(varPtrPtr)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(accVar)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def varPtrPtr(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def accVar(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def cache(acc_var, var, var_type, bounds, async_operands, *, var_ptr_ptr=None, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CacheOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, varPtrPtr=var_ptr_ptr, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CopyinOp(_ods_ir.OpView):
  r"""
  Description of arguments:
  - `var`: The variable to copy. Must be either `MappableType` or
  `PointerLikeType`.
  - `varType`: The type of the variable that is being copied. When `var` is
  a `MappableType`, this matches the type of `var`. When `var` is a
  `PointerLikeType`, this type holds information about the target of the
  pointer.
  - `varPtrPtr`: Specifies the address of the address of `var` - only used
  when the variable copied is a field in a struct. This is important for
  OpenACC due to implicit attach semantics on data clauses (2.6.4).
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, readonly, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data entry operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.copyin"

  _ODS_OPERAND_SEGMENTS = [1,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, varPtrPtr=None, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(var)
    operands.append(varPtrPtr)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(accVar)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def varPtrPtr(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def accVar(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def copyin(acc_var, var, var_type, bounds, async_operands, *, var_ptr_ptr=None, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CopyinOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, varPtrPtr=var_ptr_ptr, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CopyoutOp(_ods_ir.OpView):
  r"""
  - `varPtr`: The address of variable to copy back to.
      - `accVar`: The acc variable. This is the link from the data-entry
      operation used.
      - `bounds`: Used when copying just slice of array or array's bounds are not
      encoded in type. They are in rank order where rank 0 is inner-most dimension.
      - `asyncOperands` and `asyncOperandsDeviceType`:
      pair-wise lists of the async clause values associated with device_type's.
      - `asyncOnly`: a list of device_type's for which async clause
      does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
      - `dataClause`: Keeps track of the data clause the user used. This is because
      the acc operations are decomposed. So a 'copy' clause is decomposed to both 
      `acc.copyin` and `acc.copyout` operations, but both have dataClause that
      specifies `acc_copy` in this field.
      - `structured`: Flag to note whether this is associated with structured region
      (parallel, kernels, data) or unstructured (enter data, exit data). This is
      important due to spec specifically calling out structured and dynamic reference
      counters (2.6.7).
      - `implicit`: Whether this is an implicitly generated operation, such as copies
      done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
      - `modifiers`: Keeps track of the data clause modifiers (eg zero, always, etc)
      - `name`: Holds the name of variable as specified in user clause (including bounds).
  
      The async values attached to the data exit operation imply that the data
      action applies to all device types specified by the device_type clauses
      using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.copyout"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(accVar)
    operands.append(var)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def accVar(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

def copyout(acc_var, var, var_type, bounds, async_operands, *, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> CopyoutOp:
  return CopyoutOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class CreateOp(_ods_ir.OpView):
  r"""
  Description of arguments:
  - `var`: The variable to copy. Must be either `MappableType` or
  `PointerLikeType`.
  - `varType`: The type of the variable that is being copied. When `var` is
  a `MappableType`, this matches the type of `var`. When `var` is a
  `PointerLikeType`, this type holds information about the target of the
  pointer.
  - `varPtrPtr`: Specifies the address of the address of `var` - only used
  when the variable copied is a field in a struct. This is important for
  OpenACC due to implicit attach semantics on data clauses (2.6.4).
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, readonly, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data entry operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.create"

  _ODS_OPERAND_SEGMENTS = [1,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, varPtrPtr=None, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(var)
    operands.append(varPtrPtr)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(accVar)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def varPtrPtr(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def accVar(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def create_(acc_var, var, var_type, bounds, async_operands, *, var_ptr_ptr=None, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CreateOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, varPtrPtr=var_ptr_ptr, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DataBoundsOp(_ods_ir.OpView):
  r"""
  This operation is used to record bounds used in acc data clause in a
  normalized fashion (zero-based). This works well with the `PointerLikeType`
  requirement in data clauses - since a `lowerbound` of 0 means looking
  at data at the zero offset from pointer.
  
  The operation must have an `upperbound` or `extent` (or both are allowed -
  but not checked for consistency). When the source language's arrays are
  not zero-based, the `startIdx` must specify the zero-position index.
  
  The `stride` represents the distance between consecutive elements. For
  multi-dimensional arrays, the `stride` for each outer dimension must account
  for the complete size of all inner dimensions.
  
  The `strideInBytes` flag indicates that the `stride` is specified in bytes
  rather than the number of elements.
  
  Examples below show copying a slice of 10-element array except first element.
  Note that the examples use extent in data clause for C++ and upperbound
  for Fortran (as per 2.7.1). To simplify examples, the constants are used
  directly in the acc.bounds operands - this is not the syntax of operation.
  
  C++:
  ```
  int array[10];
  #pragma acc copy(array[1:9])
  ```
  =>
  ```mlir
  acc.bounds lb(1) ub(9) extent(9) startIdx(0) stride(1)
  ```
  
  Fortran:
  ```
  integer :: array(1:10)
  !$acc copy(array(2:10))
  ```
  =>
  ```mlir
  acc.bounds lb(1) ub(9) extent(9) startIdx(1) stride(1)
  ```
  """

  OPERATION_NAME = "acc.bounds"

  _ODS_OPERAND_SEGMENTS = [0,0,0,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, *, lowerbound=None, upperbound=None, extent=None, stride=None, strideInBytes=None, startIdx=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(lowerbound)
    operands.append(upperbound)
    operands.append(extent)
    operands.append(stride)
    operands.append(startIdx)
    _ods_context = _ods_get_default_loc_context(loc)
    if strideInBytes is not None: attributes["strideInBytes"] = (strideInBytes if (
        isinstance(strideInBytes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(strideInBytes, context=_ods_context))
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lowerbound(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def upperbound(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def extent(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def stride(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def startIdx(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def strideInBytes(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["strideInBytes"]

  @strideInBytes.setter
  def strideInBytes(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["strideInBytes"] = value

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def bounds(result, *, lowerbound=None, upperbound=None, extent=None, stride=None, stride_in_bytes=None, start_idx=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DataBoundsOp(result=result, lowerbound=lowerbound, upperbound=upperbound, extent=extent, stride=stride, strideInBytes=stride_in_bytes, startIdx=start_idx, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DataOp(_ods_ir.OpView):
  r"""
  The "acc.data" operation represents a data construct. It defines vars to
  be allocated in the current device memory for the duration of the region,
  whether data should be copied from local memory to the current device
  memory upon region entry , and copied from device memory to local memory
  upon region exit.
  
  Example:
  
  ```mlir
  acc.data present(%a: memref<10x10xf32>, %b: memref<10x10xf32>,
      %c: memref<10xf32>, %d: memref<10xf32>) {
    // data region
  }
  ```
  
  `async` and `wait` operands are supported with `device_type` information.
  They should only be accessed by the extra provided getters. If modified,
  the corresponding `device_type` attributes must be modified as well.
  """

  OPERATION_NAME = "acc.data"

  _ODS_OPERAND_SEGMENTS = [0,-1,-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, asyncOperands, waitOperands, dataClauseOperands, *, ifCond=None, asyncOperandsDeviceType=None, asyncOnly=None, waitOperandsSegments=None, waitOperandsDeviceType=None, hasWaitDevnum=None, waitOnly=None, defaultAttr=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ifCond)
    operands.append(_get_op_results_or_values(asyncOperands))
    operands.append(_get_op_results_or_values(waitOperands))
    operands.append(_get_op_results_or_values(dataClauseOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if waitOperandsSegments is not None: attributes["waitOperandsSegments"] = (waitOperandsSegments if (
        isinstance(waitOperandsSegments, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(waitOperandsSegments, context=_ods_context))
    if waitOperandsDeviceType is not None: attributes["waitOperandsDeviceType"] = (waitOperandsDeviceType if (
        isinstance(waitOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(waitOperandsDeviceType, context=_ods_context))
    if hasWaitDevnum is not None: attributes["hasWaitDevnum"] = (hasWaitDevnum if (
        isinstance(hasWaitDevnum, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolArrayAttr')) else
          _ods_ir.AttrBuilder.get('BoolArrayAttr')(hasWaitDevnum, context=_ods_context))
    if waitOnly is not None: attributes["waitOnly"] = (waitOnly if (
        isinstance(waitOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(waitOnly, context=_ods_context))
    if defaultAttr is not None: attributes["defaultAttr"] = (defaultAttr if (
        isinstance(defaultAttr, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DefaultValueAttr')) else
          _ods_ir.AttrBuilder.get('DefaultValueAttr')(defaultAttr, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ifCond(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def waitOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def dataClauseOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def waitOperandsSegments(self) -> _Optional[_ods_ir.DenseI32ArrayAttr]:
    if "waitOperandsSegments" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOperandsSegments"]

  @waitOperandsSegments.setter
  def waitOperandsSegments(self, value: _Optional[_ods_ir.DenseI32ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOperandsSegments"] = value
    elif "waitOperandsSegments" in self.operation.attributes:
      del self.operation.attributes["waitOperandsSegments"]

  @waitOperandsSegments.deleter
  def waitOperandsSegments(self):
    del self.operation.attributes["waitOperandsSegments"]

  @builtins.property
  def waitOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "waitOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOperandsDeviceType"]

  @waitOperandsDeviceType.setter
  def waitOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOperandsDeviceType"] = value
    elif "waitOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["waitOperandsDeviceType"]

  @waitOperandsDeviceType.deleter
  def waitOperandsDeviceType(self):
    del self.operation.attributes["waitOperandsDeviceType"]

  @builtins.property
  def hasWaitDevnum(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "hasWaitDevnum" not in self.operation.attributes:
      return None
    return self.operation.attributes["hasWaitDevnum"]

  @hasWaitDevnum.setter
  def hasWaitDevnum(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["hasWaitDevnum"] = value
    elif "hasWaitDevnum" in self.operation.attributes:
      del self.operation.attributes["hasWaitDevnum"]

  @hasWaitDevnum.deleter
  def hasWaitDevnum(self):
    del self.operation.attributes["hasWaitDevnum"]

  @builtins.property
  def waitOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "waitOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOnly"]

  @waitOnly.setter
  def waitOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOnly"] = value
    elif "waitOnly" in self.operation.attributes:
      del self.operation.attributes["waitOnly"]

  @waitOnly.deleter
  def waitOnly(self):
    del self.operation.attributes["waitOnly"]

  @builtins.property
  def defaultAttr(self) -> _Optional[_ods_ir.Attribute]:
    if "defaultAttr" not in self.operation.attributes:
      return None
    return self.operation.attributes["defaultAttr"]

  @defaultAttr.setter
  def defaultAttr(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["defaultAttr"] = value
    elif "defaultAttr" in self.operation.attributes:
      del self.operation.attributes["defaultAttr"]

  @defaultAttr.deleter
  def defaultAttr(self):
    del self.operation.attributes["defaultAttr"]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def data(async_operands, wait_operands, data_clause_operands, *, if_cond=None, async_operands_device_type=None, async_only=None, wait_operands_segments=None, wait_operands_device_type=None, has_wait_devnum=None, wait_only=None, default_attr=None, loc=None, ip=None) -> DataOp:
  return DataOp(asyncOperands=async_operands, waitOperands=wait_operands, dataClauseOperands=data_clause_operands, ifCond=if_cond, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, waitOperandsSegments=wait_operands_segments, waitOperandsDeviceType=wait_operands_device_type, hasWaitDevnum=has_wait_devnum, waitOnly=wait_only, defaultAttr=default_attr, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeclareDeviceResidentOp(_ods_ir.OpView):
  r"""
  Description of arguments:
  - `var`: The variable to copy. Must be either `MappableType` or
  `PointerLikeType`.
  - `varType`: The type of the variable that is being copied. When `var` is
  a `MappableType`, this matches the type of `var`. When `var` is a
  `PointerLikeType`, this type holds information about the target of the
  pointer.
  - `varPtrPtr`: Specifies the address of the address of `var` - only used
  when the variable copied is a field in a struct. This is important for
  OpenACC due to implicit attach semantics on data clauses (2.6.4).
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, readonly, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data entry operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.declare_device_resident"

  _ODS_OPERAND_SEGMENTS = [1,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, varPtrPtr=None, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(var)
    operands.append(varPtrPtr)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(accVar)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def varPtrPtr(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def accVar(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def declare_device_resident(acc_var, var, var_type, bounds, async_operands, *, var_ptr_ptr=None, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DeclareDeviceResidentOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, varPtrPtr=var_ptr_ptr, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DeclareEnterOp(_ods_ir.OpView):
  r"""
  The "acc.declare_enter" operation represents the OpenACC declare directive
  and captures the entry semantics to the implicit data region.
  This operation is modeled similarly to "acc.enter_data".
  
  Example showing `acc declare create(a)`:
  
  ```mlir
  %0 = acc.create varPtr(%a : !llvm.ptr) -> !llvm.ptr
  acc.declare_enter dataOperands(%0 : !llvm.ptr)
  ```
  """

  OPERATION_NAME = "acc.declare_enter"

  _ODS_REGIONS = (0, True)

  def __init__(self, token, dataClauseOperands, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(dataClauseOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(token)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dataClauseOperands(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def token(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def declare_enter(token, data_clause_operands, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return DeclareEnterOp(token=token, dataClauseOperands=data_clause_operands, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DeclareExitOp(_ods_ir.OpView):
  r"""
  The "acc.declare_exit" operation represents the OpenACC declare directive
  and captures the exit semantics from the implicit data region.
  This operation is modeled similarly to "acc.exit_data".
  
  Example showing `acc declare device_resident(a)`:
  
  ```mlir
  %0 = acc.getdeviceptr varPtr(%a : !llvm.ptr) -> !llvm.ptr {dataClause = #acc<data_clause declare_device_resident>}
  acc.declare_exit dataOperands(%0 : !llvm.ptr)
  acc.delete accPtr(%0 : !llvm.ptr) {dataClause = #acc<data_clause declare_device_resident>}
  ```
  """

  OPERATION_NAME = "acc.declare_exit"

  _ODS_OPERAND_SEGMENTS = [0,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, dataClauseOperands, *, token=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(token)
    operands.append(_get_op_results_or_values(dataClauseOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def token(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def dataClauseOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

def declare_exit(data_clause_operands, *, token=None, loc=None, ip=None) -> DeclareExitOp:
  return DeclareExitOp(dataClauseOperands=data_clause_operands, token=token, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeclareLinkOp(_ods_ir.OpView):
  r"""
  Description of arguments:
  - `var`: The variable to copy. Must be either `MappableType` or
  `PointerLikeType`.
  - `varType`: The type of the variable that is being copied. When `var` is
  a `MappableType`, this matches the type of `var`. When `var` is a
  `PointerLikeType`, this type holds information about the target of the
  pointer.
  - `varPtrPtr`: Specifies the address of the address of `var` - only used
  when the variable copied is a field in a struct. This is important for
  OpenACC due to implicit attach semantics on data clauses (2.6.4).
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, readonly, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data entry operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.declare_link"

  _ODS_OPERAND_SEGMENTS = [1,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, varPtrPtr=None, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(var)
    operands.append(varPtrPtr)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(accVar)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def varPtrPtr(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def accVar(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def declare_link(acc_var, var, var_type, bounds, async_operands, *, var_ptr_ptr=None, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DeclareLinkOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, varPtrPtr=var_ptr_ptr, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DeclareOp(_ods_ir.OpView):
  r"""
  The "acc.declare" operation represents an implicit declare region in
  function (and subroutine in Fortran).
  
  Example:
  
  ```mlir
  %pa = acc.present varPtr(%a : memref<10x10xf32>) -> memref<10x10xf32>
  acc.declare dataOperands(%pa: memref<10x10xf32>) {
    // implicit region
  }
  ```
  """

  OPERATION_NAME = "acc.declare"

  _ODS_REGIONS = (1, True)

  def __init__(self, dataClauseOperands, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(dataClauseOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dataClauseOperands(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def declare(data_clause_operands, *, loc=None, ip=None) -> DeclareOp:
  return DeclareOp(dataClauseOperands=data_clause_operands, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DeleteOp(_ods_ir.OpView):
  r"""
  - `accVar`: The acc variable. This is the link from the data-entry
  operation used.
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, always, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data exit operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.delete"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, bounds, asyncOperands, *, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(accVar)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def accVar(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

def delete(acc_var, bounds, async_operands, *, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> DeleteOp:
  return DeleteOp(accVar=acc_var, bounds=bounds, asyncOperands=async_operands, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DetachOp(_ods_ir.OpView):
  r"""
  - `accVar`: The acc variable. This is the link from the data-entry
  operation used.
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, always, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data exit operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.detach"

  _ODS_OPERAND_SEGMENTS = [1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, bounds, asyncOperands, *, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(accVar)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def accVar(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

def detach(acc_var, bounds, async_operands, *, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> DetachOp:
  return DetachOp(accVar=acc_var, bounds=bounds, asyncOperands=async_operands, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class DevicePtrOp(_ods_ir.OpView):
  r"""
  Description of arguments:
  - `var`: The variable to copy. Must be either `MappableType` or
  `PointerLikeType`.
  - `varType`: The type of the variable that is being copied. When `var` is
  a `MappableType`, this matches the type of `var`. When `var` is a
  `PointerLikeType`, this type holds information about the target of the
  pointer.
  - `varPtrPtr`: Specifies the address of the address of `var` - only used
  when the variable copied is a field in a struct. This is important for
  OpenACC due to implicit attach semantics on data clauses (2.6.4).
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, readonly, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data entry operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.deviceptr"

  _ODS_OPERAND_SEGMENTS = [1,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, varPtrPtr=None, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(var)
    operands.append(varPtrPtr)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(accVar)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def varPtrPtr(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def accVar(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def deviceptr(acc_var, var, var_type, bounds, async_operands, *, var_ptr_ptr=None, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return DevicePtrOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, varPtrPtr=var_ptr_ptr, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class EnterDataOp(_ods_ir.OpView):
  r"""
  The "acc.enter_data" operation represents the OpenACC enter data directive.
  
  Example:
  
  ```mlir
  acc.enter_data create(%d1 : memref<10xf32>) attributes {async}
  ```
  """

  OPERATION_NAME = "acc.enter_data"

  _ODS_OPERAND_SEGMENTS = [0,0,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, waitOperands, dataClauseOperands, *, ifCond=None, asyncOperand=None, async_=None, waitDevnum=None, wait=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ifCond)
    operands.append(asyncOperand)
    operands.append(waitDevnum)
    operands.append(_get_op_results_or_values(waitOperands))
    operands.append(_get_op_results_or_values(dataClauseOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(async_): attributes["async"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(wait): attributes["wait"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ifCond(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def asyncOperand(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def waitDevnum(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def waitOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def dataClauseOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def async_(self) -> bool:
    return "async" in self.operation.attributes

  @async_.setter
  def async_(self, value):
    if bool(value):
      self.operation.attributes["async"] = _ods_ir.UnitAttr.get()
    elif "async" in self.operation.attributes:
      del self.operation.attributes["async"]

  @async_.deleter
  def async_(self):
    del self.operation.attributes["async"]

  @builtins.property
  def wait(self) -> bool:
    return "wait" in self.operation.attributes

  @wait.setter
  def wait(self, value):
    if bool(value):
      self.operation.attributes["wait"] = _ods_ir.UnitAttr.get()
    elif "wait" in self.operation.attributes:
      del self.operation.attributes["wait"]

  @wait.deleter
  def wait(self):
    del self.operation.attributes["wait"]

def enter_data(wait_operands, data_clause_operands, *, if_cond=None, async_operand=None, async_=None, wait_devnum=None, wait=None, loc=None, ip=None) -> EnterDataOp:
  return EnterDataOp(waitOperands=wait_operands, dataClauseOperands=data_clause_operands, ifCond=if_cond, asyncOperand=async_operand, async_=async_, waitDevnum=wait_devnum, wait=wait, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ExitDataOp(_ods_ir.OpView):
  r"""
  The "acc.exit_data" operation represents the OpenACC exit data directive.
  
  Example:
  
  ```mlir
  acc.exit_data delete(%d1 : memref<10xf32>) attributes {async}
  ```
  """

  OPERATION_NAME = "acc.exit_data"

  _ODS_OPERAND_SEGMENTS = [0,0,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, waitOperands, dataClauseOperands, *, ifCond=None, asyncOperand=None, async_=None, waitDevnum=None, wait=None, finalize=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ifCond)
    operands.append(asyncOperand)
    operands.append(waitDevnum)
    operands.append(_get_op_results_or_values(waitOperands))
    operands.append(_get_op_results_or_values(dataClauseOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(async_): attributes["async"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(wait): attributes["wait"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(finalize): attributes["finalize"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ifCond(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def asyncOperand(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def waitDevnum(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def waitOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def dataClauseOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def async_(self) -> bool:
    return "async" in self.operation.attributes

  @async_.setter
  def async_(self, value):
    if bool(value):
      self.operation.attributes["async"] = _ods_ir.UnitAttr.get()
    elif "async" in self.operation.attributes:
      del self.operation.attributes["async"]

  @async_.deleter
  def async_(self):
    del self.operation.attributes["async"]

  @builtins.property
  def wait(self) -> bool:
    return "wait" in self.operation.attributes

  @wait.setter
  def wait(self, value):
    if bool(value):
      self.operation.attributes["wait"] = _ods_ir.UnitAttr.get()
    elif "wait" in self.operation.attributes:
      del self.operation.attributes["wait"]

  @wait.deleter
  def wait(self):
    del self.operation.attributes["wait"]

  @builtins.property
  def finalize(self) -> bool:
    return "finalize" in self.operation.attributes

  @finalize.setter
  def finalize(self, value):
    if bool(value):
      self.operation.attributes["finalize"] = _ods_ir.UnitAttr.get()
    elif "finalize" in self.operation.attributes:
      del self.operation.attributes["finalize"]

  @finalize.deleter
  def finalize(self):
    del self.operation.attributes["finalize"]

def exit_data(wait_operands, data_clause_operands, *, if_cond=None, async_operand=None, async_=None, wait_devnum=None, wait=None, finalize=None, loc=None, ip=None) -> ExitDataOp:
  return ExitDataOp(waitOperands=wait_operands, dataClauseOperands=data_clause_operands, ifCond=if_cond, asyncOperand=async_operand, async_=async_, waitDevnum=wait_devnum, wait=wait, finalize=finalize, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class FirstprivateMapInitialOp(_ods_ir.OpView):
  r"""
  Description of arguments:
  - `var`: The variable to copy. Must be either `MappableType` or
  `PointerLikeType`.
  - `varType`: The type of the variable that is being copied. When `var` is
  a `MappableType`, this matches the type of `var`. When `var` is a
  `PointerLikeType`, this type holds information about the target of the
  pointer.
  - `varPtrPtr`: Specifies the address of the address of `var` - only used
  when the variable copied is a field in a struct. This is important for
  OpenACC due to implicit attach semantics on data clauses (2.6.4).
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, readonly, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data entry operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.firstprivate_map"

  _ODS_OPERAND_SEGMENTS = [1,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, varPtrPtr=None, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(var)
    operands.append(varPtrPtr)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(accVar)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def varPtrPtr(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def accVar(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def firstprivate_map(acc_var, var, var_type, bounds, async_operands, *, var_ptr_ptr=None, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FirstprivateMapInitialOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, varPtrPtr=var_ptr_ptr, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FirstprivateOp(_ods_ir.OpView):
  r"""
  Description of arguments:
  - `var`: The variable to copy. Must be either `MappableType` or
  `PointerLikeType`.
  - `varType`: The type of the variable that is being copied. When `var` is
  a `MappableType`, this matches the type of `var`. When `var` is a
  `PointerLikeType`, this type holds information about the target of the
  pointer.
  - `varPtrPtr`: Specifies the address of the address of `var` - only used
  when the variable copied is a field in a struct. This is important for
  OpenACC due to implicit attach semantics on data clauses (2.6.4).
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, readonly, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data entry operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.firstprivate"

  _ODS_OPERAND_SEGMENTS = [1,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, varPtrPtr=None, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(var)
    operands.append(varPtrPtr)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(accVar)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def varPtrPtr(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def accVar(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def firstprivate(acc_var, var, var_type, bounds, async_operands, *, var_ptr_ptr=None, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return FirstprivateOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, varPtrPtr=var_ptr_ptr, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class FirstprivateRecipeOp(_ods_ir.OpView):
  r"""
  Declares an OpenACC privatization recipe with copy of the initial value.
  The operation requires two mandatory regions and one optional.
  
    1. The initializer region specifies how to allocate and initialize a new
       private value. For example in Fortran, a derived-type might have a
       default initialization. The region has an argument that contains the
       original value that needs to be privatized, followed by bounds arguments
       (if any) in order from innermost to outermost dimension. The region must
       yield the privatized copy.
    2. The copy region specifies how to copy the initial value to the newly
       created private value. It takes the original value, the privatized
       value, followed by bounds arguments (if any) in the same order.
    3. The destroy region specifies how to destruct the value when it reaches
       its end of life. It takes the original value, the privatized value, and
       bounds arguments (if any) in the same order. It is optional.
  
  A single privatization recipe can be used for multiple operand if they have
  the same type and do not require a specific default initialization.
  
  Example:
  
  ```mlir
  acc.firstprivate.recipe @firstprivate_memref : memref<10x20xf32> init {
  ^bb0(%original: memref<10x20xf32>):
    // init region contains a sequence of operations to create and
    // initialize the copy. It yields the privatized copy.
    %alloca = memref.alloca() : memref<10x20xf32>
    acc.yield %alloca : memref<10x20xf32>
  } copy {
  ^bb0(%original: memref<10x20xf32>, %privatized: memref<10x20xf32>):
    // copy region contains a sequence of operations to copy the initial value
    // of the firstprivate value to the newly created value.
    memref.copy %original, %privatized : memref<10x20xf32> to memref<10x20xf32>
    acc.terminator
  } destroy {
  ^bb0(%original: memref<10x20xf32>, %privatized: memref<10x20xf32>):
    // destroy region is empty since alloca is automatically cleaned up
    acc.terminator
  }
  
  // Example with bounds for array slicing:
  acc.firstprivate.recipe @firstprivate_slice : memref<10x20xf32> init {
  ^bb0(%original: memref<10x20xf32>, %bounds_inner: !acc.data_bounds_ty, %bounds_outer: !acc.data_bounds_ty):
    // Extract bounds and create appropriately sized allocation
    %extent_inner = acc.get_extent %bounds_inner : (!acc.data_bounds_ty) -> index
    %extent_outer = acc.get_extent %bounds_outer : (!acc.data_bounds_ty) -> index
    %slice_alloc = memref.alloca(%extent_outer, %extent_inner) : memref<?x?xf32>
    // ... base pointer adjustment logic ...
    acc.yield %result : memref<10x20xf32>
  } copy {
  ^bb0(%original: memref<10x20xf32>, %privatized: memref<10x20xf32>, %bounds_inner: !acc.data_bounds_ty, %bounds_outer: !acc.data_bounds_ty):
    // Copy the slice portion from original to privatized
    %lb_inner = acc.get_lowerbound %bounds_inner : (!acc.data_bounds_ty) -> index
    %lb_outer = acc.get_lowerbound %bounds_outer : (!acc.data_bounds_ty) -> index
    %extent_inner = acc.get_extent %bounds_inner : (!acc.data_bounds_ty) -> index
    %extent_outer = acc.get_extent %bounds_outer : (!acc.data_bounds_ty) -> index
    %subview = memref.subview %original[%lb_outer, %lb_inner][%extent_outer, %extent_inner][1, 1]
      : memref<10x20xf32> to memref<?x?xf32, strided<[20, 1], offset: ?>>
    // Copy subview to privatized...
    acc.terminator
  }
  
  // The privatization symbol is then used in the corresponding operation.
  acc.parallel firstprivate(@firstprivate_memref -> %a : memref<10x20xf32>) {
  }
  ```
  """

  OPERATION_NAME = "acc.firstprivate.recipe"

  _ODS_REGIONS = (3, True)

  def __init__(self, sym_name, type_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def initRegion(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def copyRegion(self) -> _ods_ir.Region:
    return self.regions[1]

  @builtins.property
  def destroyRegion(self) -> _ods_ir.Region:
    return self.regions[2]

def firstprivate_recipe(sym_name, type_, *, loc=None, ip=None) -> FirstprivateRecipeOp:
  return FirstprivateRecipeOp(sym_name=sym_name, type_=type_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GetDevicePtrOp(_ods_ir.OpView):
  r"""
    This operation is used to get the `accPtr` for a variable. This is often
    used in conjunction with data exit operations when the data entry
    operation is not visible. This operation can have a `dataClause` argument
    that is any of the valid `mlir::acc::DataClause` entries.
    \
  
  Description of arguments:
  - `var`: The variable to copy. Must be either `MappableType` or
  `PointerLikeType`.
  - `varType`: The type of the variable that is being copied. When `var` is
  a `MappableType`, this matches the type of `var`. When `var` is a
  `PointerLikeType`, this type holds information about the target of the
  pointer.
  - `varPtrPtr`: Specifies the address of the address of `var` - only used
  when the variable copied is a field in a struct. This is important for
  OpenACC due to implicit attach semantics on data clauses (2.6.4).
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, readonly, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data entry operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.getdeviceptr"

  _ODS_OPERAND_SEGMENTS = [1,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, varPtrPtr=None, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(var)
    operands.append(varPtrPtr)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(accVar)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def varPtrPtr(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def accVar(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def getdeviceptr(acc_var, var, var_type, bounds, async_operands, *, var_ptr_ptr=None, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetDevicePtrOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, varPtrPtr=var_ptr_ptr, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetExtentOp(_ods_ir.OpView):
  r"""
  This operation extracts the extent value from an `acc.bounds` value.
  If the data bounds does not have an extent specified, it is computed
  from the upperbound.
  
  Example:
  ```mlir
  %extent = acc.get_extent %bounds : (!acc.data_bounds_ty) -> index
  ```
  """

  OPERATION_NAME = "acc.get_extent"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, bounds, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(bounds)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def bounds(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def get_extent(result, bounds, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetExtentOp(result=result, bounds=bounds, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetLowerboundOp(_ods_ir.OpView):
  r"""
  This operation extracts the lowerbound value from an `acc.bounds` value.
  If the data bounds does not have a lowerbound specified, it means it is zero.
  
  Example:
  ```mlir
  %lb = acc.get_lowerbound %bounds : (!acc.data_bounds_ty) -> index
  ```
  """

  OPERATION_NAME = "acc.get_lowerbound"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, bounds, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(bounds)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def bounds(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def get_lowerbound(result, bounds, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetLowerboundOp(result=result, bounds=bounds, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetStrideOp(_ods_ir.OpView):
  r"""
  This operation extracts the stride value from an `acc.bounds` value.
  If the data bounds does not have a stride specified, it defaults to 1.
  
  Example:
  ```mlir
  %stride = acc.get_stride %bounds : (!acc.data_bounds_ty) -> index
  ```
  """

  OPERATION_NAME = "acc.get_stride"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, bounds, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(bounds)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def bounds(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def get_stride(result, bounds, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetStrideOp(result=result, bounds=bounds, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GetUpperboundOp(_ods_ir.OpView):
  r"""
  This operation extracts the upperbound value from an `acc.bounds` value.
  If the data bounds does not have an upperbound specified, this operation
  uses the extent to compute it.
  
  Example:
  ```mlir
  %ub = acc.get_upperbound %bounds : (!acc.data_bounds_ty) -> index
  ```
  """

  OPERATION_NAME = "acc.get_upperbound"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, bounds, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(bounds)
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def bounds(self) -> _ods_ir.Value:
    return self.operation.operands[0]

  @builtins.property
  def result(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def get_upperbound(result, bounds, *, loc=None, ip=None) -> _ods_ir.OpResult:
  return GetUpperboundOp(result=result, bounds=bounds, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalConstructorOp(_ods_ir.OpView):
  r"""
  The "acc.global_ctor" operation is used to capture OpenACC actions to apply
  on globals (such as `acc declare`) at the entry to the implicit data region.
  This operation is isolated and intended to be used in a module.
  
  Example showing `declare create` of global:
  
  ```mlir
  llvm.mlir.global external @globalvar() : i32 {
    %0 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %0 : i32
  }
  acc.global_ctor @acc_constructor {
    %0 = llvm.mlir.addressof @globalvar : !llvm.ptr
    %1 = acc.create varPtr(%0 : !llvm.ptr) -> !llvm.ptr
    acc.declare_enter dataOperands(%1 : !llvm.ptr)
  }
  ```
  """

  OPERATION_NAME = "acc.global_ctor"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def global_ctor(sym_name, *, loc=None, ip=None) -> GlobalConstructorOp:
  return GlobalConstructorOp(sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class GlobalDestructorOp(_ods_ir.OpView):
  r"""
  The "acc.global_dtor" operation is used to capture OpenACC actions to apply
  on globals (such as `acc declare`) at the exit from the implicit data
  region. This operation is isolated and intended to be used in a module.
  
  Example showing delete associated with `declare create` of global:
  
  ```mlir
  llvm.mlir.global external @globalvar() : i32 {
    %0 = llvm.mlir.constant(0 : i32) : i32
    llvm.return %0 : i32
  }
  acc.global_dtor @acc_destructor {
    %0 = llvm.mlir.addressof @globalvar : !llvm.ptr
    %1 = acc.getdeviceptr varPtr(%0 : !llvm.ptr) -> !llvm.ptr {dataClause = #acc<data_clause create>}
    acc.declare_exit dataOperands(%1 : !llvm.ptr)
    acc.delete accPtr(%1 : !llvm.ptr) {dataClause = #acc<data_clause create>}
  }
  ```
  """

  OPERATION_NAME = "acc.global_dtor"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def global_dtor(sym_name, *, loc=None, ip=None) -> GlobalDestructorOp:
  return GlobalDestructorOp(sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class HostDataOp(_ods_ir.OpView):
  r"""
  The "acc.host_data" operation represents the OpenACC host_data construct.
  
  Example:
  
  ```mlir
  %0 = acc.use_device varPtr(%a : !llvm.ptr) -> !llvm.ptr
  acc.host_data dataOperands(%0 : !llvm.ptr) {
  
  }
  ```
  """

  OPERATION_NAME = "acc.host_data"

  _ODS_OPERAND_SEGMENTS = [0,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, dataClauseOperands, *, ifCond=None, ifPresent=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ifCond)
    operands.append(_get_op_results_or_values(dataClauseOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(ifPresent): attributes["ifPresent"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ifCond(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def dataClauseOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def ifPresent(self) -> bool:
    return "ifPresent" in self.operation.attributes

  @ifPresent.setter
  def ifPresent(self, value):
    if bool(value):
      self.operation.attributes["ifPresent"] = _ods_ir.UnitAttr.get()
    elif "ifPresent" in self.operation.attributes:
      del self.operation.attributes["ifPresent"]

  @ifPresent.deleter
  def ifPresent(self):
    del self.operation.attributes["ifPresent"]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def host_data(data_clause_operands, *, if_cond=None, if_present=None, loc=None, ip=None) -> HostDataOp:
  return HostDataOp(dataClauseOperands=data_clause_operands, ifCond=if_cond, ifPresent=if_present, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class InitOp(_ods_ir.OpView):
  r"""
  The "acc.init" operation represents the OpenACC init executable
  directive.
  
  Example:
  
  ```mlir
  acc.init
  acc.init device_num(%dev1 : i32)
  ```
  """

  OPERATION_NAME = "acc.init"

  _ODS_OPERAND_SEGMENTS = [0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, *, device_types=None, deviceNum=None, ifCond=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(deviceNum)
    operands.append(ifCond)
    _ods_context = _ods_get_default_loc_context(loc)
    if device_types is not None: attributes["device_types"] = (device_types if (
        isinstance(device_types, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_675')) else
          _ods_ir.AttrBuilder.get('anonymous_675')(device_types, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def deviceNum(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def ifCond(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def device_types(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "device_types" not in self.operation.attributes:
      return None
    return self.operation.attributes["device_types"]

  @device_types.setter
  def device_types(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["device_types"] = value
    elif "device_types" in self.operation.attributes:
      del self.operation.attributes["device_types"]

  @device_types.deleter
  def device_types(self):
    del self.operation.attributes["device_types"]

def init(*, device_types=None, device_num=None, if_cond=None, loc=None, ip=None) -> InitOp:
  return InitOp(device_types=device_types, deviceNum=device_num, ifCond=if_cond, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class KernelEnvironmentOp(_ods_ir.OpView):
  r"""
  The `acc.kernel_environment` operation represents a decomposition of
  any OpenACC compute construct (acc.kernels, acc.parallel, or
  acc.serial) that captures data mapping and asynchronous behavior:
  - data clause operands
  - async clause operands
  - wait clause operands
  
  This allows kernel execution parallelism and privatization to be
  handled separately, facilitating eventual lowering to GPU dialect where
  kernel launching and compute offloading are handled separately.
  """

  OPERATION_NAME = "acc.kernel_environment"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, dataClauseOperands, asyncOperands, waitOperands, *, asyncOperandsDeviceType=None, asyncOnly=None, waitOperandsSegments=None, waitOperandsDeviceType=None, hasWaitDevnum=None, waitOnly=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(dataClauseOperands))
    operands.append(_get_op_results_or_values(asyncOperands))
    operands.append(_get_op_results_or_values(waitOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if waitOperandsSegments is not None: attributes["waitOperandsSegments"] = (waitOperandsSegments if (
        isinstance(waitOperandsSegments, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(waitOperandsSegments, context=_ods_context))
    if waitOperandsDeviceType is not None: attributes["waitOperandsDeviceType"] = (waitOperandsDeviceType if (
        isinstance(waitOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(waitOperandsDeviceType, context=_ods_context))
    if hasWaitDevnum is not None: attributes["hasWaitDevnum"] = (hasWaitDevnum if (
        isinstance(hasWaitDevnum, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolArrayAttr')) else
          _ods_ir.AttrBuilder.get('BoolArrayAttr')(hasWaitDevnum, context=_ods_context))
    if waitOnly is not None: attributes["waitOnly"] = (waitOnly if (
        isinstance(waitOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(waitOnly, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def dataClauseOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def waitOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def waitOperandsSegments(self) -> _Optional[_ods_ir.DenseI32ArrayAttr]:
    if "waitOperandsSegments" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOperandsSegments"]

  @waitOperandsSegments.setter
  def waitOperandsSegments(self, value: _Optional[_ods_ir.DenseI32ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOperandsSegments"] = value
    elif "waitOperandsSegments" in self.operation.attributes:
      del self.operation.attributes["waitOperandsSegments"]

  @waitOperandsSegments.deleter
  def waitOperandsSegments(self):
    del self.operation.attributes["waitOperandsSegments"]

  @builtins.property
  def waitOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "waitOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOperandsDeviceType"]

  @waitOperandsDeviceType.setter
  def waitOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOperandsDeviceType"] = value
    elif "waitOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["waitOperandsDeviceType"]

  @waitOperandsDeviceType.deleter
  def waitOperandsDeviceType(self):
    del self.operation.attributes["waitOperandsDeviceType"]

  @builtins.property
  def hasWaitDevnum(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "hasWaitDevnum" not in self.operation.attributes:
      return None
    return self.operation.attributes["hasWaitDevnum"]

  @hasWaitDevnum.setter
  def hasWaitDevnum(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["hasWaitDevnum"] = value
    elif "hasWaitDevnum" in self.operation.attributes:
      del self.operation.attributes["hasWaitDevnum"]

  @hasWaitDevnum.deleter
  def hasWaitDevnum(self):
    del self.operation.attributes["hasWaitDevnum"]

  @builtins.property
  def waitOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "waitOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOnly"]

  @waitOnly.setter
  def waitOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOnly"] = value
    elif "waitOnly" in self.operation.attributes:
      del self.operation.attributes["waitOnly"]

  @waitOnly.deleter
  def waitOnly(self):
    del self.operation.attributes["waitOnly"]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def kernel_environment(data_clause_operands, async_operands, wait_operands, *, async_operands_device_type=None, async_only=None, wait_operands_segments=None, wait_operands_device_type=None, has_wait_devnum=None, wait_only=None, loc=None, ip=None) -> KernelEnvironmentOp:
  return KernelEnvironmentOp(dataClauseOperands=data_clause_operands, asyncOperands=async_operands, waitOperands=wait_operands, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, waitOperandsSegments=wait_operands_segments, waitOperandsDeviceType=wait_operands_device_type, hasWaitDevnum=has_wait_devnum, waitOnly=wait_only, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class KernelsOp(_ods_ir.OpView):
  r"""
  The "acc.kernels" operation represents a kernels construct block. It has
  one region to be compiled into a sequence of kernels for execution on the
  current device.
  
  Example:
  
  ```mlir
  acc.kernels num_gangs(%c10) num_workers(%c10)
      private(%c : memref<10xf32>) {
    // kernels region
  }
  ```
  
  `collapse`, `gang`, `worker`, `vector`, `seq`, `independent`, `auto` and
  `tile` operands are supported with `device_type` information. They should
  only be accessed by the extra provided getters. If modified, the
  corresponding `device_type` attributes must be modified as well.
  """

  OPERATION_NAME = "acc.kernels"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,-1,0,0,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, asyncOperands, waitOperands, numGangs, numWorkers, vectorLength, dataClauseOperands, *, asyncOperandsDeviceType=None, asyncOnly=None, waitOperandsSegments=None, waitOperandsDeviceType=None, hasWaitDevnum=None, waitOnly=None, numGangsSegments=None, numGangsDeviceType=None, numWorkersDeviceType=None, vectorLengthDeviceType=None, ifCond=None, selfCond=None, selfAttr=None, defaultAttr=None, combined=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(asyncOperands))
    operands.append(_get_op_results_or_values(waitOperands))
    operands.append(_get_op_results_or_values(numGangs))
    operands.append(_get_op_results_or_values(numWorkers))
    operands.append(_get_op_results_or_values(vectorLength))
    operands.append(ifCond)
    operands.append(selfCond)
    operands.append(_get_op_results_or_values(dataClauseOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if waitOperandsSegments is not None: attributes["waitOperandsSegments"] = (waitOperandsSegments if (
        isinstance(waitOperandsSegments, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(waitOperandsSegments, context=_ods_context))
    if waitOperandsDeviceType is not None: attributes["waitOperandsDeviceType"] = (waitOperandsDeviceType if (
        isinstance(waitOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(waitOperandsDeviceType, context=_ods_context))
    if hasWaitDevnum is not None: attributes["hasWaitDevnum"] = (hasWaitDevnum if (
        isinstance(hasWaitDevnum, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolArrayAttr')) else
          _ods_ir.AttrBuilder.get('BoolArrayAttr')(hasWaitDevnum, context=_ods_context))
    if waitOnly is not None: attributes["waitOnly"] = (waitOnly if (
        isinstance(waitOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(waitOnly, context=_ods_context))
    if numGangsSegments is not None: attributes["numGangsSegments"] = (numGangsSegments if (
        isinstance(numGangsSegments, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(numGangsSegments, context=_ods_context))
    if numGangsDeviceType is not None: attributes["numGangsDeviceType"] = (numGangsDeviceType if (
        isinstance(numGangsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(numGangsDeviceType, context=_ods_context))
    if numWorkersDeviceType is not None: attributes["numWorkersDeviceType"] = (numWorkersDeviceType if (
        isinstance(numWorkersDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(numWorkersDeviceType, context=_ods_context))
    if vectorLengthDeviceType is not None: attributes["vectorLengthDeviceType"] = (vectorLengthDeviceType if (
        isinstance(vectorLengthDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(vectorLengthDeviceType, context=_ods_context))
    if bool(selfAttr): attributes["selfAttr"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if defaultAttr is not None: attributes["defaultAttr"] = (defaultAttr if (
        isinstance(defaultAttr, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DefaultValueAttr')) else
          _ods_ir.AttrBuilder.get('DefaultValueAttr')(defaultAttr, context=_ods_context))
    if bool(combined): attributes["combined"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def waitOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def numGangs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def numWorkers(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def vectorLength(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def ifCond(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def selfCond(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def dataClauseOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 7)
    return operand_range

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def waitOperandsSegments(self) -> _Optional[_ods_ir.DenseI32ArrayAttr]:
    if "waitOperandsSegments" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOperandsSegments"]

  @waitOperandsSegments.setter
  def waitOperandsSegments(self, value: _Optional[_ods_ir.DenseI32ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOperandsSegments"] = value
    elif "waitOperandsSegments" in self.operation.attributes:
      del self.operation.attributes["waitOperandsSegments"]

  @waitOperandsSegments.deleter
  def waitOperandsSegments(self):
    del self.operation.attributes["waitOperandsSegments"]

  @builtins.property
  def waitOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "waitOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOperandsDeviceType"]

  @waitOperandsDeviceType.setter
  def waitOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOperandsDeviceType"] = value
    elif "waitOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["waitOperandsDeviceType"]

  @waitOperandsDeviceType.deleter
  def waitOperandsDeviceType(self):
    del self.operation.attributes["waitOperandsDeviceType"]

  @builtins.property
  def hasWaitDevnum(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "hasWaitDevnum" not in self.operation.attributes:
      return None
    return self.operation.attributes["hasWaitDevnum"]

  @hasWaitDevnum.setter
  def hasWaitDevnum(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["hasWaitDevnum"] = value
    elif "hasWaitDevnum" in self.operation.attributes:
      del self.operation.attributes["hasWaitDevnum"]

  @hasWaitDevnum.deleter
  def hasWaitDevnum(self):
    del self.operation.attributes["hasWaitDevnum"]

  @builtins.property
  def waitOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "waitOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOnly"]

  @waitOnly.setter
  def waitOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOnly"] = value
    elif "waitOnly" in self.operation.attributes:
      del self.operation.attributes["waitOnly"]

  @waitOnly.deleter
  def waitOnly(self):
    del self.operation.attributes["waitOnly"]

  @builtins.property
  def numGangsSegments(self) -> _Optional[_ods_ir.DenseI32ArrayAttr]:
    if "numGangsSegments" not in self.operation.attributes:
      return None
    return self.operation.attributes["numGangsSegments"]

  @numGangsSegments.setter
  def numGangsSegments(self, value: _Optional[_ods_ir.DenseI32ArrayAttr]):
    if value is not None:
      self.operation.attributes["numGangsSegments"] = value
    elif "numGangsSegments" in self.operation.attributes:
      del self.operation.attributes["numGangsSegments"]

  @numGangsSegments.deleter
  def numGangsSegments(self):
    del self.operation.attributes["numGangsSegments"]

  @builtins.property
  def numGangsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "numGangsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["numGangsDeviceType"]

  @numGangsDeviceType.setter
  def numGangsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["numGangsDeviceType"] = value
    elif "numGangsDeviceType" in self.operation.attributes:
      del self.operation.attributes["numGangsDeviceType"]

  @numGangsDeviceType.deleter
  def numGangsDeviceType(self):
    del self.operation.attributes["numGangsDeviceType"]

  @builtins.property
  def numWorkersDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "numWorkersDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["numWorkersDeviceType"]

  @numWorkersDeviceType.setter
  def numWorkersDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["numWorkersDeviceType"] = value
    elif "numWorkersDeviceType" in self.operation.attributes:
      del self.operation.attributes["numWorkersDeviceType"]

  @numWorkersDeviceType.deleter
  def numWorkersDeviceType(self):
    del self.operation.attributes["numWorkersDeviceType"]

  @builtins.property
  def vectorLengthDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "vectorLengthDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["vectorLengthDeviceType"]

  @vectorLengthDeviceType.setter
  def vectorLengthDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["vectorLengthDeviceType"] = value
    elif "vectorLengthDeviceType" in self.operation.attributes:
      del self.operation.attributes["vectorLengthDeviceType"]

  @vectorLengthDeviceType.deleter
  def vectorLengthDeviceType(self):
    del self.operation.attributes["vectorLengthDeviceType"]

  @builtins.property
  def selfAttr(self) -> bool:
    return "selfAttr" in self.operation.attributes

  @selfAttr.setter
  def selfAttr(self, value):
    if bool(value):
      self.operation.attributes["selfAttr"] = _ods_ir.UnitAttr.get()
    elif "selfAttr" in self.operation.attributes:
      del self.operation.attributes["selfAttr"]

  @selfAttr.deleter
  def selfAttr(self):
    del self.operation.attributes["selfAttr"]

  @builtins.property
  def defaultAttr(self) -> _Optional[_ods_ir.Attribute]:
    if "defaultAttr" not in self.operation.attributes:
      return None
    return self.operation.attributes["defaultAttr"]

  @defaultAttr.setter
  def defaultAttr(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["defaultAttr"] = value
    elif "defaultAttr" in self.operation.attributes:
      del self.operation.attributes["defaultAttr"]

  @defaultAttr.deleter
  def defaultAttr(self):
    del self.operation.attributes["defaultAttr"]

  @builtins.property
  def combined(self) -> bool:
    return "combined" in self.operation.attributes

  @combined.setter
  def combined(self, value):
    if bool(value):
      self.operation.attributes["combined"] = _ods_ir.UnitAttr.get()
    elif "combined" in self.operation.attributes:
      del self.operation.attributes["combined"]

  @combined.deleter
  def combined(self):
    del self.operation.attributes["combined"]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def kernels(async_operands, wait_operands, num_gangs, num_workers, vector_length, data_clause_operands, *, async_operands_device_type=None, async_only=None, wait_operands_segments=None, wait_operands_device_type=None, has_wait_devnum=None, wait_only=None, num_gangs_segments=None, num_gangs_device_type=None, num_workers_device_type=None, vector_length_device_type=None, if_cond=None, self_cond=None, self_attr=None, default_attr=None, combined=None, loc=None, ip=None) -> KernelsOp:
  return KernelsOp(asyncOperands=async_operands, waitOperands=wait_operands, numGangs=num_gangs, numWorkers=num_workers, vectorLength=vector_length, dataClauseOperands=data_clause_operands, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, waitOperandsSegments=wait_operands_segments, waitOperandsDeviceType=wait_operands_device_type, hasWaitDevnum=has_wait_devnum, waitOnly=wait_only, numGangsSegments=num_gangs_segments, numGangsDeviceType=num_gangs_device_type, numWorkersDeviceType=num_workers_device_type, vectorLengthDeviceType=vector_length_device_type, ifCond=if_cond, selfCond=self_cond, selfAttr=self_attr, defaultAttr=default_attr, combined=combined, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class LoopOp(_ods_ir.OpView):
  r"""
  The `acc.loop` operation represents the OpenACC loop construct and when
  bounds are included, the associated source language loop iterators. The
  lower and upper bounds specify a half-open range: the range includes the
  lower bound but does not include the upper bound. If the `inclusive`
  attribute is set then the upper bound is included.
  
  In cases where the OpenACC loop directive needs to capture multiple
  source language loops, such as in the case of `collapse` or `tile`,
  the multiple induction arguments are used to capture each case. Having
  such a representation makes sure no intermediate transformation such
  as Loop Invariant Code Motion breaks the property requested by the
  clause on the loop constructs.
  
  Each `acc.loop` holds private and reduction operands which are the
  ssa values from the corresponding `acc.private` or `acc.reduction`
  operations. Additionally, firstprivate operands are supported to
  represent cases where privatization is needed with initialization
  from an original value. While the OpenACC specification does not
  explicitly support firstprivate on loop constructs, this extension
  enables representing privatization scenarios that arise from an
  optimization and codegen pipeline operating on acc dialect.
  
  The operation supports capturing information that it comes combined
  constructs (e.g., `parallel loop`, `kernels loop`, `serial loop`)
  through the `combined` attribute despite requiring the `acc.loop`
  to be decomposed from the compute operation representing compute
  construct.
  
  Example:
  
  ```mlir
  acc.loop gang() vector() (%arg3 : index, %arg4 : index, %arg5 : index) =
      (%c0, %c0, %c0 : index, index, index) to 
      (%c10, %c10, %c10 : index, index, index) step 
      (%c1, %c1, %c1 : index, index, index) {
    // Loop body
    acc.yield
  } attributes { collapse = [3] }
  ```
  
  `collapse`, `gang`, `worker`, `vector`, `seq`, `independent`, `auto`,
  `cache`, and `tile` operands are supported with `device_type`
  information. These clauses should only be accessed through the provided
  device-type-aware getter methods. When modifying these operands, the
  corresponding `device_type` attributes must be updated to maintain
  consistency between operands and their target device types.
  
  The `unstructured` attribute indicates that the loops inside the OpenACC
  construct contain early exits and cannot be lowered to structured MLIR
  operations. When this flag is set, the acc.loop should have no induction
  variables and the loop must be implemented via explicit control flow
  inside its body.
  """

  OPERATION_NAME = "acc.loop"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, lowerbound, upperbound, step, gangOperands, workerNumOperands, vectorOperands, tileOperands, cacheOperands, privateOperands, firstprivateOperands, reductionOperands, *, inclusiveUpperbound=None, collapse=None, collapseDeviceType=None, gangOperandsArgType=None, gangOperandsSegments=None, gangOperandsDeviceType=None, workerNumOperandsDeviceType=None, vectorOperandsDeviceType=None, seq=None, independent=None, auto_=None, gang=None, worker=None, vector=None, tileOperandsSegments=None, tileOperandsDeviceType=None, privatizationRecipes=None, firstprivatizationRecipes=None, reductionRecipes=None, combined=None, unstructured=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(lowerbound))
    operands.append(_get_op_results_or_values(upperbound))
    operands.append(_get_op_results_or_values(step))
    operands.append(_get_op_results_or_values(gangOperands))
    operands.append(_get_op_results_or_values(workerNumOperands))
    operands.append(_get_op_results_or_values(vectorOperands))
    operands.append(_get_op_results_or_values(tileOperands))
    operands.append(_get_op_results_or_values(cacheOperands))
    operands.append(_get_op_results_or_values(privateOperands))
    operands.append(_get_op_results_or_values(firstprivateOperands))
    operands.append(_get_op_results_or_values(reductionOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    if inclusiveUpperbound is not None: attributes["inclusiveUpperbound"] = (inclusiveUpperbound if (
        isinstance(inclusiveUpperbound, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseBoolArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseBoolArrayAttr')(inclusiveUpperbound, context=_ods_context))
    if collapse is not None: attributes["collapse"] = (collapse if (
        isinstance(collapse, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(collapse, context=_ods_context))
    if collapseDeviceType is not None: attributes["collapseDeviceType"] = (collapseDeviceType if (
        isinstance(collapseDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(collapseDeviceType, context=_ods_context))
    if gangOperandsArgType is not None: attributes["gangOperandsArgType"] = (gangOperandsArgType if (
        isinstance(gangOperandsArgType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('GangArgTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('GangArgTypeArrayAttr')(gangOperandsArgType, context=_ods_context))
    if gangOperandsSegments is not None: attributes["gangOperandsSegments"] = (gangOperandsSegments if (
        isinstance(gangOperandsSegments, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(gangOperandsSegments, context=_ods_context))
    if gangOperandsDeviceType is not None: attributes["gangOperandsDeviceType"] = (gangOperandsDeviceType if (
        isinstance(gangOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(gangOperandsDeviceType, context=_ods_context))
    if workerNumOperandsDeviceType is not None: attributes["workerNumOperandsDeviceType"] = (workerNumOperandsDeviceType if (
        isinstance(workerNumOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(workerNumOperandsDeviceType, context=_ods_context))
    if vectorOperandsDeviceType is not None: attributes["vectorOperandsDeviceType"] = (vectorOperandsDeviceType if (
        isinstance(vectorOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(vectorOperandsDeviceType, context=_ods_context))
    if seq is not None: attributes["seq"] = (seq if (
        isinstance(seq, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(seq, context=_ods_context))
    if independent is not None: attributes["independent"] = (independent if (
        isinstance(independent, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(independent, context=_ods_context))
    if auto_ is not None: attributes["auto_"] = (auto_ if (
        isinstance(auto_, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(auto_, context=_ods_context))
    if gang is not None: attributes["gang"] = (gang if (
        isinstance(gang, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(gang, context=_ods_context))
    if worker is not None: attributes["worker"] = (worker if (
        isinstance(worker, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(worker, context=_ods_context))
    if vector is not None: attributes["vector"] = (vector if (
        isinstance(vector, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(vector, context=_ods_context))
    if tileOperandsSegments is not None: attributes["tileOperandsSegments"] = (tileOperandsSegments if (
        isinstance(tileOperandsSegments, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(tileOperandsSegments, context=_ods_context))
    if tileOperandsDeviceType is not None: attributes["tileOperandsDeviceType"] = (tileOperandsDeviceType if (
        isinstance(tileOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(tileOperandsDeviceType, context=_ods_context))
    if privatizationRecipes is not None: attributes["privatizationRecipes"] = (privatizationRecipes if (
        isinstance(privatizationRecipes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
          _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(privatizationRecipes, context=_ods_context))
    if firstprivatizationRecipes is not None: attributes["firstprivatizationRecipes"] = (firstprivatizationRecipes if (
        isinstance(firstprivatizationRecipes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
          _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(firstprivatizationRecipes, context=_ods_context))
    if reductionRecipes is not None: attributes["reductionRecipes"] = (reductionRecipes if (
        isinstance(reductionRecipes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
          _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(reductionRecipes, context=_ods_context))
    if combined is not None: attributes["combined"] = (combined if (
        isinstance(combined, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_CombinedConstructsAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_CombinedConstructsAttr')(combined, context=_ods_context))
    if bool(unstructured): attributes["unstructured"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lowerbound(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def upperbound(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def step(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def gangOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def workerNumOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def vectorOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def tileOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range

  @builtins.property
  def cacheOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 7)
    return operand_range

  @builtins.property
  def privateOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 8)
    return operand_range

  @builtins.property
  def firstprivateOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 9)
    return operand_range

  @builtins.property
  def reductionOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 10)
    return operand_range

  @builtins.property
  def inclusiveUpperbound(self) -> _Optional[_ods_ir.DenseBoolArrayAttr]:
    if "inclusiveUpperbound" not in self.operation.attributes:
      return None
    return self.operation.attributes["inclusiveUpperbound"]

  @inclusiveUpperbound.setter
  def inclusiveUpperbound(self, value: _Optional[_ods_ir.DenseBoolArrayAttr]):
    if value is not None:
      self.operation.attributes["inclusiveUpperbound"] = value
    elif "inclusiveUpperbound" in self.operation.attributes:
      del self.operation.attributes["inclusiveUpperbound"]

  @inclusiveUpperbound.deleter
  def inclusiveUpperbound(self):
    del self.operation.attributes["inclusiveUpperbound"]

  @builtins.property
  def collapse(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "collapse" not in self.operation.attributes:
      return None
    return self.operation.attributes["collapse"]

  @collapse.setter
  def collapse(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["collapse"] = value
    elif "collapse" in self.operation.attributes:
      del self.operation.attributes["collapse"]

  @collapse.deleter
  def collapse(self):
    del self.operation.attributes["collapse"]

  @builtins.property
  def collapseDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "collapseDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["collapseDeviceType"]

  @collapseDeviceType.setter
  def collapseDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["collapseDeviceType"] = value
    elif "collapseDeviceType" in self.operation.attributes:
      del self.operation.attributes["collapseDeviceType"]

  @collapseDeviceType.deleter
  def collapseDeviceType(self):
    del self.operation.attributes["collapseDeviceType"]

  @builtins.property
  def gangOperandsArgType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "gangOperandsArgType" not in self.operation.attributes:
      return None
    return self.operation.attributes["gangOperandsArgType"]

  @gangOperandsArgType.setter
  def gangOperandsArgType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["gangOperandsArgType"] = value
    elif "gangOperandsArgType" in self.operation.attributes:
      del self.operation.attributes["gangOperandsArgType"]

  @gangOperandsArgType.deleter
  def gangOperandsArgType(self):
    del self.operation.attributes["gangOperandsArgType"]

  @builtins.property
  def gangOperandsSegments(self) -> _Optional[_ods_ir.DenseI32ArrayAttr]:
    if "gangOperandsSegments" not in self.operation.attributes:
      return None
    return self.operation.attributes["gangOperandsSegments"]

  @gangOperandsSegments.setter
  def gangOperandsSegments(self, value: _Optional[_ods_ir.DenseI32ArrayAttr]):
    if value is not None:
      self.operation.attributes["gangOperandsSegments"] = value
    elif "gangOperandsSegments" in self.operation.attributes:
      del self.operation.attributes["gangOperandsSegments"]

  @gangOperandsSegments.deleter
  def gangOperandsSegments(self):
    del self.operation.attributes["gangOperandsSegments"]

  @builtins.property
  def gangOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "gangOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["gangOperandsDeviceType"]

  @gangOperandsDeviceType.setter
  def gangOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["gangOperandsDeviceType"] = value
    elif "gangOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["gangOperandsDeviceType"]

  @gangOperandsDeviceType.deleter
  def gangOperandsDeviceType(self):
    del self.operation.attributes["gangOperandsDeviceType"]

  @builtins.property
  def workerNumOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "workerNumOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["workerNumOperandsDeviceType"]

  @workerNumOperandsDeviceType.setter
  def workerNumOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["workerNumOperandsDeviceType"] = value
    elif "workerNumOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["workerNumOperandsDeviceType"]

  @workerNumOperandsDeviceType.deleter
  def workerNumOperandsDeviceType(self):
    del self.operation.attributes["workerNumOperandsDeviceType"]

  @builtins.property
  def vectorOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "vectorOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["vectorOperandsDeviceType"]

  @vectorOperandsDeviceType.setter
  def vectorOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["vectorOperandsDeviceType"] = value
    elif "vectorOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["vectorOperandsDeviceType"]

  @vectorOperandsDeviceType.deleter
  def vectorOperandsDeviceType(self):
    del self.operation.attributes["vectorOperandsDeviceType"]

  @builtins.property
  def seq(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "seq" not in self.operation.attributes:
      return None
    return self.operation.attributes["seq"]

  @seq.setter
  def seq(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["seq"] = value
    elif "seq" in self.operation.attributes:
      del self.operation.attributes["seq"]

  @seq.deleter
  def seq(self):
    del self.operation.attributes["seq"]

  @builtins.property
  def independent(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "independent" not in self.operation.attributes:
      return None
    return self.operation.attributes["independent"]

  @independent.setter
  def independent(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["independent"] = value
    elif "independent" in self.operation.attributes:
      del self.operation.attributes["independent"]

  @independent.deleter
  def independent(self):
    del self.operation.attributes["independent"]

  @builtins.property
  def auto_(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "auto_" not in self.operation.attributes:
      return None
    return self.operation.attributes["auto_"]

  @auto_.setter
  def auto_(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["auto_"] = value
    elif "auto_" in self.operation.attributes:
      del self.operation.attributes["auto_"]

  @auto_.deleter
  def auto_(self):
    del self.operation.attributes["auto_"]

  @builtins.property
  def gang(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "gang" not in self.operation.attributes:
      return None
    return self.operation.attributes["gang"]

  @gang.setter
  def gang(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["gang"] = value
    elif "gang" in self.operation.attributes:
      del self.operation.attributes["gang"]

  @gang.deleter
  def gang(self):
    del self.operation.attributes["gang"]

  @builtins.property
  def worker(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "worker" not in self.operation.attributes:
      return None
    return self.operation.attributes["worker"]

  @worker.setter
  def worker(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["worker"] = value
    elif "worker" in self.operation.attributes:
      del self.operation.attributes["worker"]

  @worker.deleter
  def worker(self):
    del self.operation.attributes["worker"]

  @builtins.property
  def vector(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "vector" not in self.operation.attributes:
      return None
    return self.operation.attributes["vector"]

  @vector.setter
  def vector(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["vector"] = value
    elif "vector" in self.operation.attributes:
      del self.operation.attributes["vector"]

  @vector.deleter
  def vector(self):
    del self.operation.attributes["vector"]

  @builtins.property
  def tileOperandsSegments(self) -> _Optional[_ods_ir.DenseI32ArrayAttr]:
    if "tileOperandsSegments" not in self.operation.attributes:
      return None
    return self.operation.attributes["tileOperandsSegments"]

  @tileOperandsSegments.setter
  def tileOperandsSegments(self, value: _Optional[_ods_ir.DenseI32ArrayAttr]):
    if value is not None:
      self.operation.attributes["tileOperandsSegments"] = value
    elif "tileOperandsSegments" in self.operation.attributes:
      del self.operation.attributes["tileOperandsSegments"]

  @tileOperandsSegments.deleter
  def tileOperandsSegments(self):
    del self.operation.attributes["tileOperandsSegments"]

  @builtins.property
  def tileOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "tileOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["tileOperandsDeviceType"]

  @tileOperandsDeviceType.setter
  def tileOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["tileOperandsDeviceType"] = value
    elif "tileOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["tileOperandsDeviceType"]

  @tileOperandsDeviceType.deleter
  def tileOperandsDeviceType(self):
    del self.operation.attributes["tileOperandsDeviceType"]

  @builtins.property
  def privatizationRecipes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "privatizationRecipes" not in self.operation.attributes:
      return None
    return self.operation.attributes["privatizationRecipes"]

  @privatizationRecipes.setter
  def privatizationRecipes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["privatizationRecipes"] = value
    elif "privatizationRecipes" in self.operation.attributes:
      del self.operation.attributes["privatizationRecipes"]

  @privatizationRecipes.deleter
  def privatizationRecipes(self):
    del self.operation.attributes["privatizationRecipes"]

  @builtins.property
  def firstprivatizationRecipes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "firstprivatizationRecipes" not in self.operation.attributes:
      return None
    return self.operation.attributes["firstprivatizationRecipes"]

  @firstprivatizationRecipes.setter
  def firstprivatizationRecipes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["firstprivatizationRecipes"] = value
    elif "firstprivatizationRecipes" in self.operation.attributes:
      del self.operation.attributes["firstprivatizationRecipes"]

  @firstprivatizationRecipes.deleter
  def firstprivatizationRecipes(self):
    del self.operation.attributes["firstprivatizationRecipes"]

  @builtins.property
  def reductionRecipes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "reductionRecipes" not in self.operation.attributes:
      return None
    return self.operation.attributes["reductionRecipes"]

  @reductionRecipes.setter
  def reductionRecipes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["reductionRecipes"] = value
    elif "reductionRecipes" in self.operation.attributes:
      del self.operation.attributes["reductionRecipes"]

  @reductionRecipes.deleter
  def reductionRecipes(self):
    del self.operation.attributes["reductionRecipes"]

  @builtins.property
  def combined(self) -> _Optional[_ods_ir.Attribute]:
    if "combined" not in self.operation.attributes:
      return None
    return self.operation.attributes["combined"]

  @combined.setter
  def combined(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["combined"] = value
    elif "combined" in self.operation.attributes:
      del self.operation.attributes["combined"]

  @combined.deleter
  def combined(self):
    del self.operation.attributes["combined"]

  @builtins.property
  def unstructured(self) -> bool:
    return "unstructured" in self.operation.attributes

  @unstructured.setter
  def unstructured(self, value):
    if bool(value):
      self.operation.attributes["unstructured"] = _ods_ir.UnitAttr.get()
    elif "unstructured" in self.operation.attributes:
      del self.operation.attributes["unstructured"]

  @unstructured.deleter
  def unstructured(self):
    del self.operation.attributes["unstructured"]

  @builtins.property
  def results_(self) -> _ods_ir.OpResultList:
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def loop(results_, lowerbound, upperbound, step, gang_operands, worker_num_operands, vector_operands, tile_operands, cache_operands, private_operands, firstprivate_operands, reduction_operands, *, inclusive_upperbound=None, collapse=None, collapse_device_type=None, gang_operands_arg_type=None, gang_operands_segments=None, gang_operands_device_type=None, worker_num_operands_device_type=None, vector_operands_device_type=None, seq=None, independent=None, auto_=None, gang=None, worker=None, vector=None, tile_operands_segments=None, tile_operands_device_type=None, privatization_recipes=None, firstprivatization_recipes=None, reduction_recipes=None, combined=None, unstructured=None, loc=None, ip=None) -> _Union[_ods_ir.OpResult, _ods_ir.OpResultList, LoopOp]:
  op = LoopOp(results_=results_, lowerbound=lowerbound, upperbound=upperbound, step=step, gangOperands=gang_operands, workerNumOperands=worker_num_operands, vectorOperands=vector_operands, tileOperands=tile_operands, cacheOperands=cache_operands, privateOperands=private_operands, firstprivateOperands=firstprivate_operands, reductionOperands=reduction_operands, inclusiveUpperbound=inclusive_upperbound, collapse=collapse, collapseDeviceType=collapse_device_type, gangOperandsArgType=gang_operands_arg_type, gangOperandsSegments=gang_operands_segments, gangOperandsDeviceType=gang_operands_device_type, workerNumOperandsDeviceType=worker_num_operands_device_type, vectorOperandsDeviceType=vector_operands_device_type, seq=seq, independent=independent, auto_=auto_, gang=gang, worker=worker, vector=vector, tileOperandsSegments=tile_operands_segments, tileOperandsDeviceType=tile_operands_device_type, privatizationRecipes=privatization_recipes, firstprivatizationRecipes=firstprivatization_recipes, reductionRecipes=reduction_recipes, combined=combined, unstructured=unstructured, loc=loc, ip=ip); results = op.results
  return results if len(results) > 1 else (results[0] if len(results) == 1 else op)

@_ods_cext.register_operation(_Dialect)
class NoCreateOp(_ods_ir.OpView):
  r"""
  Description of arguments:
  - `var`: The variable to copy. Must be either `MappableType` or
  `PointerLikeType`.
  - `varType`: The type of the variable that is being copied. When `var` is
  a `MappableType`, this matches the type of `var`. When `var` is a
  `PointerLikeType`, this type holds information about the target of the
  pointer.
  - `varPtrPtr`: Specifies the address of the address of `var` - only used
  when the variable copied is a field in a struct. This is important for
  OpenACC due to implicit attach semantics on data clauses (2.6.4).
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, readonly, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data entry operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.nocreate"

  _ODS_OPERAND_SEGMENTS = [1,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, varPtrPtr=None, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(var)
    operands.append(varPtrPtr)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(accVar)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def varPtrPtr(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def accVar(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def nocreate(acc_var, var, var_type, bounds, async_operands, *, var_ptr_ptr=None, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return NoCreateOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, varPtrPtr=var_ptr_ptr, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ParallelOp(_ods_ir.OpView):
  r"""
  The "acc.parallel" operation represents a parallel construct block. It has
  one region to be executed in parallel on the current device.
  
  Example:
  
  ```mlir
  acc.parallel num_gangs(%c10) num_workers(%c10)
      private(%c : memref<10xf32>) {
    // parallel region
  }
  ```
  
  `async`, `wait`, `num_gangs`, `num_workers` and `vector_length` operands are
  supported with `device_type` information. They should only be accessed by
  the extra provided getters. If modified, the corresponding `device_type`
  attributes must be modified as well.
  """

  OPERATION_NAME = "acc.parallel"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,-1,-1,0,0,-1,-1,-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, asyncOperands, waitOperands, numGangs, numWorkers, vectorLength, reductionOperands, privateOperands, firstprivateOperands, dataClauseOperands, *, asyncOperandsDeviceType=None, asyncOnly=None, waitOperandsSegments=None, waitOperandsDeviceType=None, hasWaitDevnum=None, waitOnly=None, numGangsSegments=None, numGangsDeviceType=None, numWorkersDeviceType=None, vectorLengthDeviceType=None, ifCond=None, selfCond=None, selfAttr=None, reductionRecipes=None, privatizationRecipes=None, firstprivatizationRecipes=None, defaultAttr=None, combined=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(asyncOperands))
    operands.append(_get_op_results_or_values(waitOperands))
    operands.append(_get_op_results_or_values(numGangs))
    operands.append(_get_op_results_or_values(numWorkers))
    operands.append(_get_op_results_or_values(vectorLength))
    operands.append(ifCond)
    operands.append(selfCond)
    operands.append(_get_op_results_or_values(reductionOperands))
    operands.append(_get_op_results_or_values(privateOperands))
    operands.append(_get_op_results_or_values(firstprivateOperands))
    operands.append(_get_op_results_or_values(dataClauseOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if waitOperandsSegments is not None: attributes["waitOperandsSegments"] = (waitOperandsSegments if (
        isinstance(waitOperandsSegments, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(waitOperandsSegments, context=_ods_context))
    if waitOperandsDeviceType is not None: attributes["waitOperandsDeviceType"] = (waitOperandsDeviceType if (
        isinstance(waitOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(waitOperandsDeviceType, context=_ods_context))
    if hasWaitDevnum is not None: attributes["hasWaitDevnum"] = (hasWaitDevnum if (
        isinstance(hasWaitDevnum, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolArrayAttr')) else
          _ods_ir.AttrBuilder.get('BoolArrayAttr')(hasWaitDevnum, context=_ods_context))
    if waitOnly is not None: attributes["waitOnly"] = (waitOnly if (
        isinstance(waitOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(waitOnly, context=_ods_context))
    if numGangsSegments is not None: attributes["numGangsSegments"] = (numGangsSegments if (
        isinstance(numGangsSegments, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(numGangsSegments, context=_ods_context))
    if numGangsDeviceType is not None: attributes["numGangsDeviceType"] = (numGangsDeviceType if (
        isinstance(numGangsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(numGangsDeviceType, context=_ods_context))
    if numWorkersDeviceType is not None: attributes["numWorkersDeviceType"] = (numWorkersDeviceType if (
        isinstance(numWorkersDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(numWorkersDeviceType, context=_ods_context))
    if vectorLengthDeviceType is not None: attributes["vectorLengthDeviceType"] = (vectorLengthDeviceType if (
        isinstance(vectorLengthDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(vectorLengthDeviceType, context=_ods_context))
    if bool(selfAttr): attributes["selfAttr"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if reductionRecipes is not None: attributes["reductionRecipes"] = (reductionRecipes if (
        isinstance(reductionRecipes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
          _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(reductionRecipes, context=_ods_context))
    if privatizationRecipes is not None: attributes["privatizationRecipes"] = (privatizationRecipes if (
        isinstance(privatizationRecipes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
          _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(privatizationRecipes, context=_ods_context))
    if firstprivatizationRecipes is not None: attributes["firstprivatizationRecipes"] = (firstprivatizationRecipes if (
        isinstance(firstprivatizationRecipes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
          _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(firstprivatizationRecipes, context=_ods_context))
    if defaultAttr is not None: attributes["defaultAttr"] = (defaultAttr if (
        isinstance(defaultAttr, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DefaultValueAttr')) else
          _ods_ir.AttrBuilder.get('DefaultValueAttr')(defaultAttr, context=_ods_context))
    if bool(combined): attributes["combined"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def waitOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def numGangs(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def numWorkers(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def vectorLength(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def ifCond(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def selfCond(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def reductionOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 7)
    return operand_range

  @builtins.property
  def privateOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 8)
    return operand_range

  @builtins.property
  def firstprivateOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 9)
    return operand_range

  @builtins.property
  def dataClauseOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 10)
    return operand_range

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def waitOperandsSegments(self) -> _Optional[_ods_ir.DenseI32ArrayAttr]:
    if "waitOperandsSegments" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOperandsSegments"]

  @waitOperandsSegments.setter
  def waitOperandsSegments(self, value: _Optional[_ods_ir.DenseI32ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOperandsSegments"] = value
    elif "waitOperandsSegments" in self.operation.attributes:
      del self.operation.attributes["waitOperandsSegments"]

  @waitOperandsSegments.deleter
  def waitOperandsSegments(self):
    del self.operation.attributes["waitOperandsSegments"]

  @builtins.property
  def waitOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "waitOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOperandsDeviceType"]

  @waitOperandsDeviceType.setter
  def waitOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOperandsDeviceType"] = value
    elif "waitOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["waitOperandsDeviceType"]

  @waitOperandsDeviceType.deleter
  def waitOperandsDeviceType(self):
    del self.operation.attributes["waitOperandsDeviceType"]

  @builtins.property
  def hasWaitDevnum(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "hasWaitDevnum" not in self.operation.attributes:
      return None
    return self.operation.attributes["hasWaitDevnum"]

  @hasWaitDevnum.setter
  def hasWaitDevnum(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["hasWaitDevnum"] = value
    elif "hasWaitDevnum" in self.operation.attributes:
      del self.operation.attributes["hasWaitDevnum"]

  @hasWaitDevnum.deleter
  def hasWaitDevnum(self):
    del self.operation.attributes["hasWaitDevnum"]

  @builtins.property
  def waitOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "waitOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOnly"]

  @waitOnly.setter
  def waitOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOnly"] = value
    elif "waitOnly" in self.operation.attributes:
      del self.operation.attributes["waitOnly"]

  @waitOnly.deleter
  def waitOnly(self):
    del self.operation.attributes["waitOnly"]

  @builtins.property
  def numGangsSegments(self) -> _Optional[_ods_ir.DenseI32ArrayAttr]:
    if "numGangsSegments" not in self.operation.attributes:
      return None
    return self.operation.attributes["numGangsSegments"]

  @numGangsSegments.setter
  def numGangsSegments(self, value: _Optional[_ods_ir.DenseI32ArrayAttr]):
    if value is not None:
      self.operation.attributes["numGangsSegments"] = value
    elif "numGangsSegments" in self.operation.attributes:
      del self.operation.attributes["numGangsSegments"]

  @numGangsSegments.deleter
  def numGangsSegments(self):
    del self.operation.attributes["numGangsSegments"]

  @builtins.property
  def numGangsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "numGangsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["numGangsDeviceType"]

  @numGangsDeviceType.setter
  def numGangsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["numGangsDeviceType"] = value
    elif "numGangsDeviceType" in self.operation.attributes:
      del self.operation.attributes["numGangsDeviceType"]

  @numGangsDeviceType.deleter
  def numGangsDeviceType(self):
    del self.operation.attributes["numGangsDeviceType"]

  @builtins.property
  def numWorkersDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "numWorkersDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["numWorkersDeviceType"]

  @numWorkersDeviceType.setter
  def numWorkersDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["numWorkersDeviceType"] = value
    elif "numWorkersDeviceType" in self.operation.attributes:
      del self.operation.attributes["numWorkersDeviceType"]

  @numWorkersDeviceType.deleter
  def numWorkersDeviceType(self):
    del self.operation.attributes["numWorkersDeviceType"]

  @builtins.property
  def vectorLengthDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "vectorLengthDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["vectorLengthDeviceType"]

  @vectorLengthDeviceType.setter
  def vectorLengthDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["vectorLengthDeviceType"] = value
    elif "vectorLengthDeviceType" in self.operation.attributes:
      del self.operation.attributes["vectorLengthDeviceType"]

  @vectorLengthDeviceType.deleter
  def vectorLengthDeviceType(self):
    del self.operation.attributes["vectorLengthDeviceType"]

  @builtins.property
  def selfAttr(self) -> bool:
    return "selfAttr" in self.operation.attributes

  @selfAttr.setter
  def selfAttr(self, value):
    if bool(value):
      self.operation.attributes["selfAttr"] = _ods_ir.UnitAttr.get()
    elif "selfAttr" in self.operation.attributes:
      del self.operation.attributes["selfAttr"]

  @selfAttr.deleter
  def selfAttr(self):
    del self.operation.attributes["selfAttr"]

  @builtins.property
  def reductionRecipes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "reductionRecipes" not in self.operation.attributes:
      return None
    return self.operation.attributes["reductionRecipes"]

  @reductionRecipes.setter
  def reductionRecipes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["reductionRecipes"] = value
    elif "reductionRecipes" in self.operation.attributes:
      del self.operation.attributes["reductionRecipes"]

  @reductionRecipes.deleter
  def reductionRecipes(self):
    del self.operation.attributes["reductionRecipes"]

  @builtins.property
  def privatizationRecipes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "privatizationRecipes" not in self.operation.attributes:
      return None
    return self.operation.attributes["privatizationRecipes"]

  @privatizationRecipes.setter
  def privatizationRecipes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["privatizationRecipes"] = value
    elif "privatizationRecipes" in self.operation.attributes:
      del self.operation.attributes["privatizationRecipes"]

  @privatizationRecipes.deleter
  def privatizationRecipes(self):
    del self.operation.attributes["privatizationRecipes"]

  @builtins.property
  def firstprivatizationRecipes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "firstprivatizationRecipes" not in self.operation.attributes:
      return None
    return self.operation.attributes["firstprivatizationRecipes"]

  @firstprivatizationRecipes.setter
  def firstprivatizationRecipes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["firstprivatizationRecipes"] = value
    elif "firstprivatizationRecipes" in self.operation.attributes:
      del self.operation.attributes["firstprivatizationRecipes"]

  @firstprivatizationRecipes.deleter
  def firstprivatizationRecipes(self):
    del self.operation.attributes["firstprivatizationRecipes"]

  @builtins.property
  def defaultAttr(self) -> _Optional[_ods_ir.Attribute]:
    if "defaultAttr" not in self.operation.attributes:
      return None
    return self.operation.attributes["defaultAttr"]

  @defaultAttr.setter
  def defaultAttr(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["defaultAttr"] = value
    elif "defaultAttr" in self.operation.attributes:
      del self.operation.attributes["defaultAttr"]

  @defaultAttr.deleter
  def defaultAttr(self):
    del self.operation.attributes["defaultAttr"]

  @builtins.property
  def combined(self) -> bool:
    return "combined" in self.operation.attributes

  @combined.setter
  def combined(self, value):
    if bool(value):
      self.operation.attributes["combined"] = _ods_ir.UnitAttr.get()
    elif "combined" in self.operation.attributes:
      del self.operation.attributes["combined"]

  @combined.deleter
  def combined(self):
    del self.operation.attributes["combined"]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def parallel(async_operands, wait_operands, num_gangs, num_workers, vector_length, reduction_operands, private_operands, firstprivate_operands, data_clause_operands, *, async_operands_device_type=None, async_only=None, wait_operands_segments=None, wait_operands_device_type=None, has_wait_devnum=None, wait_only=None, num_gangs_segments=None, num_gangs_device_type=None, num_workers_device_type=None, vector_length_device_type=None, if_cond=None, self_cond=None, self_attr=None, reduction_recipes=None, privatization_recipes=None, firstprivatization_recipes=None, default_attr=None, combined=None, loc=None, ip=None) -> ParallelOp:
  return ParallelOp(asyncOperands=async_operands, waitOperands=wait_operands, numGangs=num_gangs, numWorkers=num_workers, vectorLength=vector_length, reductionOperands=reduction_operands, privateOperands=private_operands, firstprivateOperands=firstprivate_operands, dataClauseOperands=data_clause_operands, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, waitOperandsSegments=wait_operands_segments, waitOperandsDeviceType=wait_operands_device_type, hasWaitDevnum=has_wait_devnum, waitOnly=wait_only, numGangsSegments=num_gangs_segments, numGangsDeviceType=num_gangs_device_type, numWorkersDeviceType=num_workers_device_type, vectorLengthDeviceType=vector_length_device_type, ifCond=if_cond, selfCond=self_cond, selfAttr=self_attr, reductionRecipes=reduction_recipes, privatizationRecipes=privatization_recipes, firstprivatizationRecipes=firstprivatization_recipes, defaultAttr=default_attr, combined=combined, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class PresentOp(_ods_ir.OpView):
  r"""
  Description of arguments:
  - `var`: The variable to copy. Must be either `MappableType` or
  `PointerLikeType`.
  - `varType`: The type of the variable that is being copied. When `var` is
  a `MappableType`, this matches the type of `var`. When `var` is a
  `PointerLikeType`, this type holds information about the target of the
  pointer.
  - `varPtrPtr`: Specifies the address of the address of `var` - only used
  when the variable copied is a field in a struct. This is important for
  OpenACC due to implicit attach semantics on data clauses (2.6.4).
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, readonly, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data entry operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.present"

  _ODS_OPERAND_SEGMENTS = [1,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, varPtrPtr=None, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(var)
    operands.append(varPtrPtr)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(accVar)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def varPtrPtr(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def accVar(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def present(acc_var, var, var_type, bounds, async_operands, *, var_ptr_ptr=None, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return PresentOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, varPtrPtr=var_ptr_ptr, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrivateOp(_ods_ir.OpView):
  r"""
  Description of arguments:
  - `var`: The variable to copy. Must be either `MappableType` or
  `PointerLikeType`.
  - `varType`: The type of the variable that is being copied. When `var` is
  a `MappableType`, this matches the type of `var`. When `var` is a
  `PointerLikeType`, this type holds information about the target of the
  pointer.
  - `varPtrPtr`: Specifies the address of the address of `var` - only used
  when the variable copied is a field in a struct. This is important for
  OpenACC due to implicit attach semantics on data clauses (2.6.4).
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, readonly, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data entry operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.private"

  _ODS_OPERAND_SEGMENTS = [1,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, varPtrPtr=None, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(var)
    operands.append(varPtrPtr)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(accVar)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def varPtrPtr(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def accVar(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def private(acc_var, var, var_type, bounds, async_operands, *, var_ptr_ptr=None, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return PrivateOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, varPtrPtr=var_ptr_ptr, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class PrivateRecipeOp(_ods_ir.OpView):
  r"""
  Declares an OpenACC privatization recipe. The operation requires one
  mandatory and one optional region.
  
    1. The initializer region specifies how to allocate and initialize a new
       private value. For example in Fortran, a derived-type might have a
       default initialization. The region has an argument that contains the
       original value that needs to be privatized, followed by bounds arguments
       (if any) in order from innermost to outermost dimension. The region
       must yield the privatized copy.
    2. The destroy region specifies how to destruct the value when it reaches
       its end of life. It takes the original value, the privatized value, and
       bounds arguments (if any) in the same order as the init region.
  
  A single privatization recipe can be used for multiple operand if they have
  the same type and do not require a specific default initialization.
  
  Example:
  
  ```mlir
  acc.private.recipe @privatization_memref : memref<10x20xf32> init {
  ^bb0(%original: memref<10x20xf32>):
    // init region contains a sequence of operations to create and
    // initialize the copy. It yields the privatized copy.
    %alloca = memref.alloca() : memref<10x20xf32>
    acc.yield %alloca : memref<10x20xf32>
  } destroy {
  ^bb0(%original: memref<10x20xf32>, %privatized: memref<10x20xf32>):
    // destroy region is empty since alloca is automatically cleaned up
    acc.terminator
  }
  
  // Example with bounds for array slicing:
  acc.private.recipe @privatization_slice : memref<10x20xf32> init {
  ^bb0(%original: memref<10x20xf32>, %bounds_inner: !acc.data_bounds_ty, %bounds_outer: !acc.data_bounds_ty):
    // Extract bounds and create appropriately sized allocation
    %extent_inner = acc.get_extent %bounds_inner : (!acc.data_bounds_ty) -> index
    %extent_outer = acc.get_extent %bounds_outer : (!acc.data_bounds_ty) -> index
    %slice_alloc = memref.alloca(%extent_outer, %extent_inner) : memref<?x?xf32>
    // ... base pointer adjustment logic ...
    acc.yield %result : memref<10x20xf32>
  } destroy {
  ^bb0(%original: memref<10x20xf32>, %privatized: memref<10x20xf32>, %bounds_inner: !acc.data_bounds_ty, %bounds_outer: !acc.data_bounds_ty):
    // Cleanup is automatic for alloca-based allocations
    acc.terminator
  }
  
  // The privatization symbol is then used in the corresponding operation.
  acc.parallel private(@privatization_memref -> %a : memref<10x20xf32>) {
  }
  ```
  """

  OPERATION_NAME = "acc.private.recipe"

  _ODS_REGIONS = (2, True)

  def __init__(self, sym_name, type_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def initRegion(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def destroyRegion(self) -> _ods_ir.Region:
    return self.regions[1]

def private_recipe(sym_name, type_, *, loc=None, ip=None) -> PrivateRecipeOp:
  return PrivateRecipeOp(sym_name=sym_name, type_=type_, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ReductionOp(_ods_ir.OpView):
  r"""
  Description of arguments:
  - `var`: The variable to copy. Must be either `MappableType` or
  `PointerLikeType`.
  - `varType`: The type of the variable that is being copied. When `var` is
  a `MappableType`, this matches the type of `var`. When `var` is a
  `PointerLikeType`, this type holds information about the target of the
  pointer.
  - `varPtrPtr`: Specifies the address of the address of `var` - only used
  when the variable copied is a field in a struct. This is important for
  OpenACC due to implicit attach semantics on data clauses (2.6.4).
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, readonly, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data entry operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.reduction"

  _ODS_OPERAND_SEGMENTS = [1,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, varPtrPtr=None, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(var)
    operands.append(varPtrPtr)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(accVar)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def varPtrPtr(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def accVar(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def reduction(acc_var, var, var_type, bounds, async_operands, *, var_ptr_ptr=None, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ReductionOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, varPtrPtr=var_ptr_ptr, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ReductionRecipeOp(_ods_ir.OpView):
  r"""
  Declares an OpenACC reduction recipe. The operation requires two
  mandatory regions and one optional region.
  
    1. The initializer region specifies how to initialize the local reduction
       value. The region has a first argument that contains the original value
       that needs to be reduced, followed by bounds arguments (if any) in order
       from innermost to outermost dimension. It is expected to `acc.yield` the
       initialized reduction value.
    2. The combiner region contains a sequence of operations to combine two
       values of the reduction type into one. It has the first reduction value,
       the second reduction value, followed by bounds arguments (if any) in the
       same order. It is expected to `acc.yield` the combined value.
    3. The optional destroy region specifies how to destruct the value when it
       reaches its end of life. It takes the original value, the reduction value,
       and bounds arguments (if any) in the same order.
  
  Example:
  
  ```mlir
  acc.reduction.recipe @reduction_add_memref : memref<10x20xf32> reduction_operator<add> init {
  ^bb0(%original: memref<10x20xf32>):
    // init region contains a sequence of operations to initialize the local
    // reduction value as specified in 2.5.15
    %alloca = memref.alloca() : memref<10x20xf32>
    %cst = arith.constant 0.0 : f32
    linalg.fill ins(%cst : f32) outs(%alloca : memref<10x20xf32>)
    acc.yield %alloca : memref<10x20xf32>
  } combiner {
  ^bb0(%lhs: memref<10x20xf32>, %rhs: memref<10x20xf32>):
    // combiner region contains a sequence of operations to combine
    // two values into one.
    linalg.add ins(%lhs, %rhs : memref<10x20xf32>, memref<10x20xf32>)
               outs(%lhs : memref<10x20xf32>)
    acc.yield %lhs : memref<10x20xf32>
  } destroy {
  ^bb0(%original: memref<10x20xf32>, %reduction: memref<10x20xf32>):
    // destroy region is empty since alloca is automatically cleaned up
    acc.terminator
  }
  
  // Example with bounds for array slicing:
  acc.reduction.recipe @reduction_add_slice : memref<10x20xf32> reduction_operator<add> init {
  ^bb0(%original: memref<10x20xf32>, %bounds_inner: !acc.data_bounds_ty, %bounds_outer: !acc.data_bounds_ty):
    // Extract bounds and create appropriately sized allocation
    %extent_inner = acc.get_extent %bounds_inner : (!acc.data_bounds_ty) -> index
    %extent_outer = acc.get_extent %bounds_outer : (!acc.data_bounds_ty) -> index
    %slice_alloc = memref.alloca(%extent_outer, %extent_inner) : memref<?x?xf32>
    %cst = arith.constant 0.0 : f32
    linalg.fill ins(%cst : f32) outs(%slice_alloc : memref<?x?xf32>)
    // ... base pointer adjustment logic ...
    acc.yield %result : memref<10x20xf32>
  } combiner {
  ^bb0(%lhs: memref<10x20xf32>, %rhs: memref<10x20xf32>, %bounds_inner: !acc.data_bounds_ty, %bounds_outer: !acc.data_bounds_ty):
    // Extract bounds to operate only on the slice portion
    %lb_inner = acc.get_lowerbound %bounds_inner : (!acc.data_bounds_ty) -> index
    %lb_outer = acc.get_lowerbound %bounds_outer : (!acc.data_bounds_ty) -> index
    %extent_inner = acc.get_extent %bounds_inner : (!acc.data_bounds_ty) -> index
    %extent_outer = acc.get_extent %bounds_outer : (!acc.data_bounds_ty) -> index
  
    // Create subviews to access only the slice portions
    %lhs_slice = memref.subview %lhs[%lb_outer, %lb_inner][%extent_outer, %extent_inner][1, 1]
      : memref<10x20xf32> to memref<?x?xf32, strided<[20, 1], offset: ?>>
    %rhs_slice = memref.subview %rhs[%lb_outer, %lb_inner][%extent_outer, %extent_inner][1, 1]
      : memref<10x20xf32> to memref<?x?xf32, strided<[20, 1], offset: ?>>
  
    // Combine only the slice portions
    linalg.add ins(%lhs_slice, %rhs_slice : memref<?x?xf32, strided<[20, 1], offset: ?>>, memref<?x?xf32, strided<[20, 1], offset: ?>>)
               outs(%lhs_slice : memref<?x?xf32, strided<[20, 1], offset: ?>>)
    acc.yield %lhs : memref<10x20xf32>
  }
  
  // The reduction symbol is then used in the corresponding operation.
  acc.parallel reduction(@reduction_add_memref -> %a : memref<10x20xf32>) {
  }
  ```
  
  The following table lists the valid operators and the initialization values
  according to OpenACC 3.3:
  
  |------------------------------------------------|
  |        C/C++          |        Fortran         |
  |-----------------------|------------------------|
  | operator | init value | operator | init value  |
  |     +    |      0     |     +    |      0      |
  |     *    |      1     |     *    |      1      |
  |    max   |    least   |    max   |    least    |
  |    min   |   largest  |    min   |   largest   |
  |     &    |     ~0     |   iand   | all bits on |
  |     |    |      0     |    ior   |      0      |
  |     ^    |      0     |   ieor   |      0      |
  |    &&    |      1     |   .and.  |    .true.   |
  |    ||    |      0     |    .or.  |   .false.   |
  |          |            |   .eqv.  |    .true.   |
  |          |            |  .neqv.  |   .false.   |
  -------------------------------------------------|
  """

  OPERATION_NAME = "acc.reduction.recipe"

  _ODS_REGIONS = (3, True)

  def __init__(self, sym_name, type_, reductionOperator, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["type"] = (type_ if (
    isinstance(type_, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(type_, context=_ods_context))
    attributes["reductionOperator"] = (reductionOperator if (
    isinstance(reductionOperator, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('OpenACC_ReductionOperatorAttr')) else
      _ods_ir.AttrBuilder.get('OpenACC_ReductionOperatorAttr')(reductionOperator, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def type_(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["type"]

  @type_.setter
  def type_(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["type"] = value

  @builtins.property
  def reductionOperator(self) -> _ods_ir.Attribute:
    return self.operation.attributes["reductionOperator"]

  @reductionOperator.setter
  def reductionOperator(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["reductionOperator"] = value

  @builtins.property
  def initRegion(self) -> _ods_ir.Region:
    return self.regions[0]

  @builtins.property
  def combinerRegion(self) -> _ods_ir.Region:
    return self.regions[1]

  @builtins.property
  def destroyRegion(self) -> _ods_ir.Region:
    return self.regions[2]

def reduction_recipe(sym_name, type_, reduction_operator, *, loc=None, ip=None) -> ReductionRecipeOp:
  return ReductionRecipeOp(sym_name=sym_name, type_=type_, reductionOperator=reduction_operator, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class RoutineOp(_ods_ir.OpView):
  r"""
  The `acc.routine` operation is used to capture the clauses of acc
  routine directive, including the associated function name. The associated
  function keeps track of its corresponding routine declaration through
  the `RoutineInfoAttr`.
  
  Example:
  
  ```mlir
  func.func @acc_func(%a : i64) -> () attributes 
      {acc.routine_info = #acc.routine_info<[@acc_func_rout1]>} {
    return
  }
  acc.routine @acc_func_rout1 func(@acc_func) gang
  ```
  
  `bind`, `gang`, `worker`, `vector` and `seq` operands are supported with
  `device_type` information. They should only be accessed by the extra
  provided getters. If modified, the corresponding `device_type` attributes
  must be modified as well.
  """

  OPERATION_NAME = "acc.routine"

  _ODS_REGIONS = (0, True)

  def __init__(self, sym_name, func_name, *, bindIdName=None, bindStrName=None, bindIdNameDeviceType=None, bindStrNameDeviceType=None, worker=None, vector=None, seq=None, nohost=None, implicit=None, gang=None, gangDim=None, gangDimDeviceType=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    attributes["func_name"] = (func_name if (
    isinstance(func_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(func_name, context=_ods_context))
    if bindIdName is not None: attributes["bindIdName"] = (bindIdName if (
        isinstance(bindIdName, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
          _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(bindIdName, context=_ods_context))
    if bindStrName is not None: attributes["bindStrName"] = (bindStrName if (
        isinstance(bindStrName, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
          _ods_ir.AttrBuilder.get('StrArrayAttr')(bindStrName, context=_ods_context))
    if bindIdNameDeviceType is not None: attributes["bindIdNameDeviceType"] = (bindIdNameDeviceType if (
        isinstance(bindIdNameDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(bindIdNameDeviceType, context=_ods_context))
    if bindStrNameDeviceType is not None: attributes["bindStrNameDeviceType"] = (bindStrNameDeviceType if (
        isinstance(bindStrNameDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(bindStrNameDeviceType, context=_ods_context))
    if worker is not None: attributes["worker"] = (worker if (
        isinstance(worker, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(worker, context=_ods_context))
    if vector is not None: attributes["vector"] = (vector if (
        isinstance(vector, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(vector, context=_ods_context))
    if seq is not None: attributes["seq"] = (seq if (
        isinstance(seq, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(seq, context=_ods_context))
    if bool(nohost): attributes["nohost"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(implicit): attributes["implicit"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if gang is not None: attributes["gang"] = (gang if (
        isinstance(gang, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(gang, context=_ods_context))
    if gangDim is not None: attributes["gangDim"] = (gangDim if (
        isinstance(gangDim, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('I64ArrayAttr')(gangDim, context=_ods_context))
    if gangDimDeviceType is not None: attributes["gangDimDeviceType"] = (gangDimDeviceType if (
        isinstance(gangDimDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(gangDimDeviceType, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def func_name(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["func_name"]

  @func_name.setter
  def func_name(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["func_name"] = value

  @builtins.property
  def bindIdName(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "bindIdName" not in self.operation.attributes:
      return None
    return self.operation.attributes["bindIdName"]

  @bindIdName.setter
  def bindIdName(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["bindIdName"] = value
    elif "bindIdName" in self.operation.attributes:
      del self.operation.attributes["bindIdName"]

  @bindIdName.deleter
  def bindIdName(self):
    del self.operation.attributes["bindIdName"]

  @builtins.property
  def bindStrName(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "bindStrName" not in self.operation.attributes:
      return None
    return self.operation.attributes["bindStrName"]

  @bindStrName.setter
  def bindStrName(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["bindStrName"] = value
    elif "bindStrName" in self.operation.attributes:
      del self.operation.attributes["bindStrName"]

  @bindStrName.deleter
  def bindStrName(self):
    del self.operation.attributes["bindStrName"]

  @builtins.property
  def bindIdNameDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "bindIdNameDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["bindIdNameDeviceType"]

  @bindIdNameDeviceType.setter
  def bindIdNameDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["bindIdNameDeviceType"] = value
    elif "bindIdNameDeviceType" in self.operation.attributes:
      del self.operation.attributes["bindIdNameDeviceType"]

  @bindIdNameDeviceType.deleter
  def bindIdNameDeviceType(self):
    del self.operation.attributes["bindIdNameDeviceType"]

  @builtins.property
  def bindStrNameDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "bindStrNameDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["bindStrNameDeviceType"]

  @bindStrNameDeviceType.setter
  def bindStrNameDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["bindStrNameDeviceType"] = value
    elif "bindStrNameDeviceType" in self.operation.attributes:
      del self.operation.attributes["bindStrNameDeviceType"]

  @bindStrNameDeviceType.deleter
  def bindStrNameDeviceType(self):
    del self.operation.attributes["bindStrNameDeviceType"]

  @builtins.property
  def worker(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "worker" not in self.operation.attributes:
      return None
    return self.operation.attributes["worker"]

  @worker.setter
  def worker(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["worker"] = value
    elif "worker" in self.operation.attributes:
      del self.operation.attributes["worker"]

  @worker.deleter
  def worker(self):
    del self.operation.attributes["worker"]

  @builtins.property
  def vector(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "vector" not in self.operation.attributes:
      return None
    return self.operation.attributes["vector"]

  @vector.setter
  def vector(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["vector"] = value
    elif "vector" in self.operation.attributes:
      del self.operation.attributes["vector"]

  @vector.deleter
  def vector(self):
    del self.operation.attributes["vector"]

  @builtins.property
  def seq(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "seq" not in self.operation.attributes:
      return None
    return self.operation.attributes["seq"]

  @seq.setter
  def seq(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["seq"] = value
    elif "seq" in self.operation.attributes:
      del self.operation.attributes["seq"]

  @seq.deleter
  def seq(self):
    del self.operation.attributes["seq"]

  @builtins.property
  def nohost(self) -> bool:
    return "nohost" in self.operation.attributes

  @nohost.setter
  def nohost(self, value):
    if bool(value):
      self.operation.attributes["nohost"] = _ods_ir.UnitAttr.get()
    elif "nohost" in self.operation.attributes:
      del self.operation.attributes["nohost"]

  @nohost.deleter
  def nohost(self):
    del self.operation.attributes["nohost"]

  @builtins.property
  def implicit(self) -> bool:
    return "implicit" in self.operation.attributes

  @implicit.setter
  def implicit(self, value):
    if bool(value):
      self.operation.attributes["implicit"] = _ods_ir.UnitAttr.get()
    elif "implicit" in self.operation.attributes:
      del self.operation.attributes["implicit"]

  @implicit.deleter
  def implicit(self):
    del self.operation.attributes["implicit"]

  @builtins.property
  def gang(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "gang" not in self.operation.attributes:
      return None
    return self.operation.attributes["gang"]

  @gang.setter
  def gang(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["gang"] = value
    elif "gang" in self.operation.attributes:
      del self.operation.attributes["gang"]

  @gang.deleter
  def gang(self):
    del self.operation.attributes["gang"]

  @builtins.property
  def gangDim(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "gangDim" not in self.operation.attributes:
      return None
    return self.operation.attributes["gangDim"]

  @gangDim.setter
  def gangDim(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["gangDim"] = value
    elif "gangDim" in self.operation.attributes:
      del self.operation.attributes["gangDim"]

  @gangDim.deleter
  def gangDim(self):
    del self.operation.attributes["gangDim"]

  @builtins.property
  def gangDimDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "gangDimDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["gangDimDeviceType"]

  @gangDimDeviceType.setter
  def gangDimDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["gangDimDeviceType"] = value
    elif "gangDimDeviceType" in self.operation.attributes:
      del self.operation.attributes["gangDimDeviceType"]

  @gangDimDeviceType.deleter
  def gangDimDeviceType(self):
    del self.operation.attributes["gangDimDeviceType"]

def routine(sym_name, func_name, *, bind_id_name=None, bind_str_name=None, bind_id_name_device_type=None, bind_str_name_device_type=None, worker=None, vector=None, seq=None, nohost=None, implicit=None, gang=None, gang_dim=None, gang_dim_device_type=None, loc=None, ip=None) -> RoutineOp:
  return RoutineOp(sym_name=sym_name, func_name=func_name, bindIdName=bind_id_name, bindStrName=bind_str_name, bindIdNameDeviceType=bind_id_name_device_type, bindStrNameDeviceType=bind_str_name_device_type, worker=worker, vector=vector, seq=seq, nohost=nohost, implicit=implicit, gang=gang, gangDim=gang_dim, gangDimDeviceType=gang_dim_device_type, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SerialOp(_ods_ir.OpView):
  r"""
  The "acc.serial" operation represents a serial construct block. It has
  one region to be executed in serial on the current device.
  
  Example:
  
  ```mlir
  acc.serial private(%c : memref<10xf32>) {
    // serial region
  }
  ```
  
  `async` and `wait` operands are supported with `device_type` information.
  They should only be accessed by the extra provided getters. If modified,
  the corresponding `device_type` attributes must be modified as well.
  """

  OPERATION_NAME = "acc.serial"

  _ODS_OPERAND_SEGMENTS = [-1,-1,0,0,-1,-1,-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, asyncOperands, waitOperands, reductionOperands, privateOperands, firstprivateOperands, dataClauseOperands, *, asyncOperandsDeviceType=None, asyncOnly=None, waitOperandsSegments=None, waitOperandsDeviceType=None, hasWaitDevnum=None, waitOnly=None, ifCond=None, selfCond=None, selfAttr=None, reductionRecipes=None, privatizationRecipes=None, firstprivatizationRecipes=None, defaultAttr=None, combined=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(asyncOperands))
    operands.append(_get_op_results_or_values(waitOperands))
    operands.append(ifCond)
    operands.append(selfCond)
    operands.append(_get_op_results_or_values(reductionOperands))
    operands.append(_get_op_results_or_values(privateOperands))
    operands.append(_get_op_results_or_values(firstprivateOperands))
    operands.append(_get_op_results_or_values(dataClauseOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if waitOperandsSegments is not None: attributes["waitOperandsSegments"] = (waitOperandsSegments if (
        isinstance(waitOperandsSegments, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(waitOperandsSegments, context=_ods_context))
    if waitOperandsDeviceType is not None: attributes["waitOperandsDeviceType"] = (waitOperandsDeviceType if (
        isinstance(waitOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(waitOperandsDeviceType, context=_ods_context))
    if hasWaitDevnum is not None: attributes["hasWaitDevnum"] = (hasWaitDevnum if (
        isinstance(hasWaitDevnum, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolArrayAttr')) else
          _ods_ir.AttrBuilder.get('BoolArrayAttr')(hasWaitDevnum, context=_ods_context))
    if waitOnly is not None: attributes["waitOnly"] = (waitOnly if (
        isinstance(waitOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(waitOnly, context=_ods_context))
    if bool(selfAttr): attributes["selfAttr"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if reductionRecipes is not None: attributes["reductionRecipes"] = (reductionRecipes if (
        isinstance(reductionRecipes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
          _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(reductionRecipes, context=_ods_context))
    if privatizationRecipes is not None: attributes["privatizationRecipes"] = (privatizationRecipes if (
        isinstance(privatizationRecipes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
          _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(privatizationRecipes, context=_ods_context))
    if firstprivatizationRecipes is not None: attributes["firstprivatizationRecipes"] = (firstprivatizationRecipes if (
        isinstance(firstprivatizationRecipes, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SymbolRefArrayAttr')) else
          _ods_ir.AttrBuilder.get('SymbolRefArrayAttr')(firstprivatizationRecipes, context=_ods_context))
    if defaultAttr is not None: attributes["defaultAttr"] = (defaultAttr if (
        isinstance(defaultAttr, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DefaultValueAttr')) else
          _ods_ir.AttrBuilder.get('DefaultValueAttr')(defaultAttr, context=_ods_context))
    if bool(combined): attributes["combined"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def waitOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def ifCond(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def selfCond(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def reductionOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 4)
    return operand_range

  @builtins.property
  def privateOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 5)
    return operand_range

  @builtins.property
  def firstprivateOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 6)
    return operand_range

  @builtins.property
  def dataClauseOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 7)
    return operand_range

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def waitOperandsSegments(self) -> _Optional[_ods_ir.DenseI32ArrayAttr]:
    if "waitOperandsSegments" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOperandsSegments"]

  @waitOperandsSegments.setter
  def waitOperandsSegments(self, value: _Optional[_ods_ir.DenseI32ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOperandsSegments"] = value
    elif "waitOperandsSegments" in self.operation.attributes:
      del self.operation.attributes["waitOperandsSegments"]

  @waitOperandsSegments.deleter
  def waitOperandsSegments(self):
    del self.operation.attributes["waitOperandsSegments"]

  @builtins.property
  def waitOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "waitOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOperandsDeviceType"]

  @waitOperandsDeviceType.setter
  def waitOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOperandsDeviceType"] = value
    elif "waitOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["waitOperandsDeviceType"]

  @waitOperandsDeviceType.deleter
  def waitOperandsDeviceType(self):
    del self.operation.attributes["waitOperandsDeviceType"]

  @builtins.property
  def hasWaitDevnum(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "hasWaitDevnum" not in self.operation.attributes:
      return None
    return self.operation.attributes["hasWaitDevnum"]

  @hasWaitDevnum.setter
  def hasWaitDevnum(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["hasWaitDevnum"] = value
    elif "hasWaitDevnum" in self.operation.attributes:
      del self.operation.attributes["hasWaitDevnum"]

  @hasWaitDevnum.deleter
  def hasWaitDevnum(self):
    del self.operation.attributes["hasWaitDevnum"]

  @builtins.property
  def waitOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "waitOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOnly"]

  @waitOnly.setter
  def waitOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOnly"] = value
    elif "waitOnly" in self.operation.attributes:
      del self.operation.attributes["waitOnly"]

  @waitOnly.deleter
  def waitOnly(self):
    del self.operation.attributes["waitOnly"]

  @builtins.property
  def selfAttr(self) -> bool:
    return "selfAttr" in self.operation.attributes

  @selfAttr.setter
  def selfAttr(self, value):
    if bool(value):
      self.operation.attributes["selfAttr"] = _ods_ir.UnitAttr.get()
    elif "selfAttr" in self.operation.attributes:
      del self.operation.attributes["selfAttr"]

  @selfAttr.deleter
  def selfAttr(self):
    del self.operation.attributes["selfAttr"]

  @builtins.property
  def reductionRecipes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "reductionRecipes" not in self.operation.attributes:
      return None
    return self.operation.attributes["reductionRecipes"]

  @reductionRecipes.setter
  def reductionRecipes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["reductionRecipes"] = value
    elif "reductionRecipes" in self.operation.attributes:
      del self.operation.attributes["reductionRecipes"]

  @reductionRecipes.deleter
  def reductionRecipes(self):
    del self.operation.attributes["reductionRecipes"]

  @builtins.property
  def privatizationRecipes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "privatizationRecipes" not in self.operation.attributes:
      return None
    return self.operation.attributes["privatizationRecipes"]

  @privatizationRecipes.setter
  def privatizationRecipes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["privatizationRecipes"] = value
    elif "privatizationRecipes" in self.operation.attributes:
      del self.operation.attributes["privatizationRecipes"]

  @privatizationRecipes.deleter
  def privatizationRecipes(self):
    del self.operation.attributes["privatizationRecipes"]

  @builtins.property
  def firstprivatizationRecipes(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "firstprivatizationRecipes" not in self.operation.attributes:
      return None
    return self.operation.attributes["firstprivatizationRecipes"]

  @firstprivatizationRecipes.setter
  def firstprivatizationRecipes(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["firstprivatizationRecipes"] = value
    elif "firstprivatizationRecipes" in self.operation.attributes:
      del self.operation.attributes["firstprivatizationRecipes"]

  @firstprivatizationRecipes.deleter
  def firstprivatizationRecipes(self):
    del self.operation.attributes["firstprivatizationRecipes"]

  @builtins.property
  def defaultAttr(self) -> _Optional[_ods_ir.Attribute]:
    if "defaultAttr" not in self.operation.attributes:
      return None
    return self.operation.attributes["defaultAttr"]

  @defaultAttr.setter
  def defaultAttr(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["defaultAttr"] = value
    elif "defaultAttr" in self.operation.attributes:
      del self.operation.attributes["defaultAttr"]

  @defaultAttr.deleter
  def defaultAttr(self):
    del self.operation.attributes["defaultAttr"]

  @builtins.property
  def combined(self) -> bool:
    return "combined" in self.operation.attributes

  @combined.setter
  def combined(self, value):
    if bool(value):
      self.operation.attributes["combined"] = _ods_ir.UnitAttr.get()
    elif "combined" in self.operation.attributes:
      del self.operation.attributes["combined"]

  @combined.deleter
  def combined(self):
    del self.operation.attributes["combined"]

  @builtins.property
  def region(self) -> _ods_ir.Region:
    return self.regions[0]

def serial(async_operands, wait_operands, reduction_operands, private_operands, firstprivate_operands, data_clause_operands, *, async_operands_device_type=None, async_only=None, wait_operands_segments=None, wait_operands_device_type=None, has_wait_devnum=None, wait_only=None, if_cond=None, self_cond=None, self_attr=None, reduction_recipes=None, privatization_recipes=None, firstprivatization_recipes=None, default_attr=None, combined=None, loc=None, ip=None) -> SerialOp:
  return SerialOp(asyncOperands=async_operands, waitOperands=wait_operands, reductionOperands=reduction_operands, privateOperands=private_operands, firstprivateOperands=firstprivate_operands, dataClauseOperands=data_clause_operands, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, waitOperandsSegments=wait_operands_segments, waitOperandsDeviceType=wait_operands_device_type, hasWaitDevnum=has_wait_devnum, waitOnly=wait_only, ifCond=if_cond, selfCond=self_cond, selfAttr=self_attr, reductionRecipes=reduction_recipes, privatizationRecipes=privatization_recipes, firstprivatizationRecipes=firstprivatization_recipes, defaultAttr=default_attr, combined=combined, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class SetOp(_ods_ir.OpView):
  r"""
  The "acc.set" operation represents the OpenACC set directive.
  
  Example:
  
  ```mlir
  acc.set device_num(%dev1 : i32)
  ```
  """

  OPERATION_NAME = "acc.set"

  _ODS_OPERAND_SEGMENTS = [0,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, *, device_type=None, defaultAsync=None, deviceNum=None, ifCond=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(defaultAsync)
    operands.append(deviceNum)
    operands.append(ifCond)
    _ods_context = _ods_get_default_loc_context(loc)
    if device_type is not None: attributes["device_type"] = (device_type if (
        isinstance(device_type, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DeviceTypeAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DeviceTypeAttr')(device_type, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def defaultAsync(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def deviceNum(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def ifCond(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def device_type(self) -> _Optional[_ods_ir.Attribute]:
    if "device_type" not in self.operation.attributes:
      return None
    return self.operation.attributes["device_type"]

  @device_type.setter
  def device_type(self, value: _Optional[_ods_ir.Attribute]):
    if value is not None:
      self.operation.attributes["device_type"] = value
    elif "device_type" in self.operation.attributes:
      del self.operation.attributes["device_type"]

  @device_type.deleter
  def device_type(self):
    del self.operation.attributes["device_type"]

def set(*, device_type=None, default_async=None, device_num=None, if_cond=None, loc=None, ip=None) -> SetOp:
  return SetOp(device_type=device_type, defaultAsync=default_async, deviceNum=device_num, ifCond=if_cond, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ShutdownOp(_ods_ir.OpView):
  r"""
  The "acc.shutdown" operation represents the OpenACC shutdown executable
  directive.
  
  Example:
  
  ```mlir
  acc.shutdown
  acc.shutdown device_num(%dev1 : i32)
  ```
  """

  OPERATION_NAME = "acc.shutdown"

  _ODS_OPERAND_SEGMENTS = [0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, *, device_types=None, deviceNum=None, ifCond=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(deviceNum)
    operands.append(ifCond)
    _ods_context = _ods_get_default_loc_context(loc)
    if device_types is not None: attributes["device_types"] = (device_types if (
        isinstance(device_types, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('anonymous_675')) else
          _ods_ir.AttrBuilder.get('anonymous_675')(device_types, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def deviceNum(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def ifCond(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def device_types(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "device_types" not in self.operation.attributes:
      return None
    return self.operation.attributes["device_types"]

  @device_types.setter
  def device_types(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["device_types"] = value
    elif "device_types" in self.operation.attributes:
      del self.operation.attributes["device_types"]

  @device_types.deleter
  def device_types(self):
    del self.operation.attributes["device_types"]

def shutdown(*, device_types=None, device_num=None, if_cond=None, loc=None, ip=None) -> ShutdownOp:
  return ShutdownOp(device_types=device_types, deviceNum=device_num, ifCond=if_cond, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TerminatorOp(_ods_ir.OpView):
  r"""
  A terminator operation for regions that appear in the body of OpenACC
  operation. Generic OpenACC construct regions are not expected to return any
  value so the terminator takes no operands. The terminator op returns control
  to the enclosing op.
  """

  OPERATION_NAME = "acc.terminator"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

def terminator(*, loc=None, ip=None) -> TerminatorOp:
  return TerminatorOp(loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class UpdateDeviceOp(_ods_ir.OpView):
  r"""
  Description of arguments:
  - `var`: The variable to copy. Must be either `MappableType` or
  `PointerLikeType`.
  - `varType`: The type of the variable that is being copied. When `var` is
  a `MappableType`, this matches the type of `var`. When `var` is a
  `PointerLikeType`, this type holds information about the target of the
  pointer.
  - `varPtrPtr`: Specifies the address of the address of `var` - only used
  when the variable copied is a field in a struct. This is important for
  OpenACC due to implicit attach semantics on data clauses (2.6.4).
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, readonly, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data entry operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.update_device"

  _ODS_OPERAND_SEGMENTS = [1,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, varPtrPtr=None, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(var)
    operands.append(varPtrPtr)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(accVar)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def varPtrPtr(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def accVar(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def update_device(acc_var, var, var_type, bounds, async_operands, *, var_ptr_ptr=None, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return UpdateDeviceOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, varPtrPtr=var_ptr_ptr, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class UpdateHostOp(_ods_ir.OpView):
  r"""
  - `varPtr`: The address of variable to copy back to.
      - `accVar`: The acc variable. This is the link from the data-entry
      operation used.
      - `bounds`: Used when copying just slice of array or array's bounds are not
      encoded in type. They are in rank order where rank 0 is inner-most dimension.
      - `asyncOperands` and `asyncOperandsDeviceType`:
      pair-wise lists of the async clause values associated with device_type's.
      - `asyncOnly`: a list of device_type's for which async clause
      does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
      - `dataClause`: Keeps track of the data clause the user used. This is because
      the acc operations are decomposed. So a 'copy' clause is decomposed to both 
      `acc.copyin` and `acc.copyout` operations, but both have dataClause that
      specifies `acc_copy` in this field.
      - `structured`: Flag to note whether this is associated with structured region
      (parallel, kernels, data) or unstructured (enter data, exit data). This is
      important due to spec specifically calling out structured and dynamic reference
      counters (2.6.7).
      - `implicit`: Whether this is an implicitly generated operation, such as copies
      done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
      - `modifiers`: Keeps track of the data clause modifiers (eg zero, always, etc)
      - `name`: Holds the name of variable as specified in user clause (including bounds).
  
      The async values attached to the data exit operation imply that the data
      action applies to all device types specified by the device_type clauses
      using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.update_host"

  _ODS_OPERAND_SEGMENTS = [1,1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(accVar)
    operands.append(var)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def accVar(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0]

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

def update_host(acc_var, var, var_type, bounds, async_operands, *, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> UpdateHostOp:
  return UpdateHostOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class UpdateOp(_ods_ir.OpView):
  r"""
  The `acc.update` operation represents the OpenACC update executable
  directive.
  As host and self clauses are synonyms, any operands for host and self are
  add to $hostOperands.
  
  Example:
  
  ```mlir
  acc.update device(%d1 : memref<10xf32>) attributes {async}
  ```
  
  `async` and `wait` operands are supported with `device_type` information.
  They should only be accessed by the extra provided getters. If modified,
  the corresponding `device_type` attributes must be modified as well.
  """

  OPERATION_NAME = "acc.update"

  _ODS_OPERAND_SEGMENTS = [0,-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, asyncOperands, waitOperands, dataClauseOperands, *, ifCond=None, asyncOperandsDeviceType=None, asyncOnly=None, waitOperandsSegments=None, waitOperandsDeviceType=None, hasWaitDevnum=None, waitOnly=None, ifPresent=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(ifCond)
    operands.append(_get_op_results_or_values(asyncOperands))
    operands.append(_get_op_results_or_values(waitOperands))
    operands.append(_get_op_results_or_values(dataClauseOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if waitOperandsSegments is not None: attributes["waitOperandsSegments"] = (waitOperandsSegments if (
        isinstance(waitOperandsSegments, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(waitOperandsSegments, context=_ods_context))
    if waitOperandsDeviceType is not None: attributes["waitOperandsDeviceType"] = (waitOperandsDeviceType if (
        isinstance(waitOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(waitOperandsDeviceType, context=_ods_context))
    if hasWaitDevnum is not None: attributes["hasWaitDevnum"] = (hasWaitDevnum if (
        isinstance(hasWaitDevnum, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolArrayAttr')) else
          _ods_ir.AttrBuilder.get('BoolArrayAttr')(hasWaitDevnum, context=_ods_context))
    if waitOnly is not None: attributes["waitOnly"] = (waitOnly if (
        isinstance(waitOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(waitOnly, context=_ods_context))
    if bool(ifPresent): attributes["ifPresent"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def ifCond(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def waitOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def dataClauseOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def waitOperandsSegments(self) -> _Optional[_ods_ir.DenseI32ArrayAttr]:
    if "waitOperandsSegments" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOperandsSegments"]

  @waitOperandsSegments.setter
  def waitOperandsSegments(self, value: _Optional[_ods_ir.DenseI32ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOperandsSegments"] = value
    elif "waitOperandsSegments" in self.operation.attributes:
      del self.operation.attributes["waitOperandsSegments"]

  @waitOperandsSegments.deleter
  def waitOperandsSegments(self):
    del self.operation.attributes["waitOperandsSegments"]

  @builtins.property
  def waitOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "waitOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOperandsDeviceType"]

  @waitOperandsDeviceType.setter
  def waitOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOperandsDeviceType"] = value
    elif "waitOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["waitOperandsDeviceType"]

  @waitOperandsDeviceType.deleter
  def waitOperandsDeviceType(self):
    del self.operation.attributes["waitOperandsDeviceType"]

  @builtins.property
  def hasWaitDevnum(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "hasWaitDevnum" not in self.operation.attributes:
      return None
    return self.operation.attributes["hasWaitDevnum"]

  @hasWaitDevnum.setter
  def hasWaitDevnum(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["hasWaitDevnum"] = value
    elif "hasWaitDevnum" in self.operation.attributes:
      del self.operation.attributes["hasWaitDevnum"]

  @hasWaitDevnum.deleter
  def hasWaitDevnum(self):
    del self.operation.attributes["hasWaitDevnum"]

  @builtins.property
  def waitOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "waitOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["waitOnly"]

  @waitOnly.setter
  def waitOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["waitOnly"] = value
    elif "waitOnly" in self.operation.attributes:
      del self.operation.attributes["waitOnly"]

  @waitOnly.deleter
  def waitOnly(self):
    del self.operation.attributes["waitOnly"]

  @builtins.property
  def ifPresent(self) -> bool:
    return "ifPresent" in self.operation.attributes

  @ifPresent.setter
  def ifPresent(self, value):
    if bool(value):
      self.operation.attributes["ifPresent"] = _ods_ir.UnitAttr.get()
    elif "ifPresent" in self.operation.attributes:
      del self.operation.attributes["ifPresent"]

  @ifPresent.deleter
  def ifPresent(self):
    del self.operation.attributes["ifPresent"]

def update(async_operands, wait_operands, data_clause_operands, *, if_cond=None, async_operands_device_type=None, async_only=None, wait_operands_segments=None, wait_operands_device_type=None, has_wait_devnum=None, wait_only=None, if_present=None, loc=None, ip=None) -> UpdateOp:
  return UpdateOp(asyncOperands=async_operands, waitOperands=wait_operands, dataClauseOperands=data_clause_operands, ifCond=if_cond, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, waitOperandsSegments=wait_operands_segments, waitOperandsDeviceType=wait_operands_device_type, hasWaitDevnum=has_wait_devnum, waitOnly=wait_only, ifPresent=if_present, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class UseDeviceOp(_ods_ir.OpView):
  r"""
  Description of arguments:
  - `var`: The variable to copy. Must be either `MappableType` or
  `PointerLikeType`.
  - `varType`: The type of the variable that is being copied. When `var` is
  a `MappableType`, this matches the type of `var`. When `var` is a
  `PointerLikeType`, this type holds information about the target of the
  pointer.
  - `varPtrPtr`: Specifies the address of the address of `var` - only used
  when the variable copied is a field in a struct. This is important for
  OpenACC due to implicit attach semantics on data clauses (2.6.4).
  - `bounds`: Used when copying just slice of array or array's bounds are not
  encoded in type. They are in rank order where rank 0 is inner-most dimension.
  - `asyncOperands` and `asyncOperandsDeviceType`:
  pair-wise lists of the async clause values associated with device_type's.
  - `asyncOnly`: a list of device_type's for which async clause
  does not specify a value (default is acc_async_noval - OpenACC 3.3 2.16.1).
  - `dataClause`: Keeps track of the data clause the user used. This is because
  the acc operations are decomposed. So a 'copy' clause is decomposed to both 
  `acc.copyin` and `acc.copyout` operations, but both have dataClause that
  specifies `acc_copy` in this field.
  - `structured`: Flag to note whether this is associated with structured region
  (parallel, kernels, data) or unstructured (enter data, exit data). This is
  important due to spec specifically calling out structured and dynamic reference
  counters (2.6.7).
  - `implicit`: Whether this is an implicitly generated operation, such as copies
  done to satisfy "Variables with Implicitly Determined Data Attributes" in 2.6.2.
  - `modifiers`: Keeps track of the data clause modifiers (eg zero, readonly, etc)
  - `name`: Holds the name of variable as specified in user clause (including bounds).
  
  The async values attached to the data entry operation imply that the data
  action applies to all device types specified by the device_type clauses
  using the activity queues on these devices as defined by the async values.
  """

  OPERATION_NAME = "acc.use_device"

  _ODS_OPERAND_SEGMENTS = [1,0,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, accVar, var, varType, bounds, asyncOperands, *, varPtrPtr=None, asyncOperandsDeviceType=None, asyncOnly=None, dataClause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(var)
    operands.append(varPtrPtr)
    operands.append(_get_op_results_or_values(bounds))
    operands.append(_get_op_results_or_values(asyncOperands))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["varType"] = (varType if (
    isinstance(varType, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('TypeAttr')) else
      _ods_ir.AttrBuilder.get('TypeAttr')(varType, context=_ods_context))
    if asyncOperandsDeviceType is not None: attributes["asyncOperandsDeviceType"] = (asyncOperandsDeviceType if (
        isinstance(asyncOperandsDeviceType, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOperandsDeviceType, context=_ods_context))
    if asyncOnly is not None: attributes["asyncOnly"] = (asyncOnly if (
        isinstance(asyncOnly, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DeviceTypeArrayAttr')) else
          _ods_ir.AttrBuilder.get('DeviceTypeArrayAttr')(asyncOnly, context=_ods_context))
    if dataClause is not None: attributes["dataClause"] = (dataClause if (
        isinstance(dataClause, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseAttr')(dataClause, context=_ods_context))
    if structured is not None: attributes["structured"] = (structured if (
        isinstance(structured, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(structured, context=_ods_context))
    if implicit is not None: attributes["implicit"] = (implicit if (
        isinstance(implicit, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(implicit, context=_ods_context))
    if modifiers is not None: attributes["modifiers"] = (modifiers if (
        isinstance(modifiers, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('OpenACC_DataClauseModifierAttr')) else
          _ods_ir.AttrBuilder.get('OpenACC_DataClauseModifierAttr')(modifiers, context=_ods_context))
    if name is not None: attributes["name"] = (name if (
        isinstance(name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(name, context=_ods_context))
    results = []
    results.append(accVar)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def var(self) -> _ods_ir.Value:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range[0]

  @builtins.property
  def varPtrPtr(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def bounds(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def asyncOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range

  @builtins.property
  def varType(self) -> _ods_ir.TypeAttr:
    return self.operation.attributes["varType"]

  @varType.setter
  def varType(self, value: _ods_ir.TypeAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["varType"] = value

  @builtins.property
  def asyncOperandsDeviceType(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOperandsDeviceType" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.setter
  def asyncOperandsDeviceType(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOperandsDeviceType"] = value
    elif "asyncOperandsDeviceType" in self.operation.attributes:
      del self.operation.attributes["asyncOperandsDeviceType"]

  @asyncOperandsDeviceType.deleter
  def asyncOperandsDeviceType(self):
    del self.operation.attributes["asyncOperandsDeviceType"]

  @builtins.property
  def asyncOnly(self) -> _Optional[_ods_ir.ArrayAttr]:
    if "asyncOnly" not in self.operation.attributes:
      return None
    return self.operation.attributes["asyncOnly"]

  @asyncOnly.setter
  def asyncOnly(self, value: _Optional[_ods_ir.ArrayAttr]):
    if value is not None:
      self.operation.attributes["asyncOnly"] = value
    elif "asyncOnly" in self.operation.attributes:
      del self.operation.attributes["asyncOnly"]

  @asyncOnly.deleter
  def asyncOnly(self):
    del self.operation.attributes["asyncOnly"]

  @builtins.property
  def dataClause(self) -> _ods_ir.Attribute:
    return self.operation.attributes["dataClause"]

  @dataClause.setter
  def dataClause(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dataClause"] = value

  @builtins.property
  def structured(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["structured"]

  @structured.setter
  def structured(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["structured"] = value

  @builtins.property
  def implicit(self) -> _ods_ir.BoolAttr:
    return self.operation.attributes["implicit"]

  @implicit.setter
  def implicit(self, value: _ods_ir.BoolAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["implicit"] = value

  @builtins.property
  def modifiers(self) -> _ods_ir.Attribute:
    return self.operation.attributes["modifiers"]

  @modifiers.setter
  def modifiers(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["modifiers"] = value

  @builtins.property
  def name(self) -> _Optional[_ods_ir.StringAttr]:
    if "name" not in self.operation.attributes:
      return None
    return self.operation.attributes["name"]

  @name.setter
  def name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["name"] = value
    elif "name" in self.operation.attributes:
      del self.operation.attributes["name"]

  @name.deleter
  def name(self):
    del self.operation.attributes["name"]

  @builtins.property
  def accVar(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def use_device(acc_var, var, var_type, bounds, async_operands, *, var_ptr_ptr=None, async_operands_device_type=None, async_only=None, data_clause=None, structured=None, implicit=None, modifiers=None, name=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return UseDeviceOp(accVar=acc_var, var=var, varType=var_type, bounds=bounds, asyncOperands=async_operands, varPtrPtr=var_ptr_ptr, asyncOperandsDeviceType=async_operands_device_type, asyncOnly=async_only, dataClause=data_clause, structured=structured, implicit=implicit, modifiers=modifiers, name=name, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class WaitOp(_ods_ir.OpView):
  r"""
  The "acc.wait" operation represents the OpenACC wait executable
  directive.
  
  Example:
  
  ```mlir
  acc.wait(%value1: index)
  acc.wait() async(%async1: i32)
  ```
  
  acc.wait does not implement MemoryEffects interface,
  so it affects all the resources. This is conservatively
  correct. More precise modelling of the memory effects
  seems to be impossible without the whole program analysis.
  """

  OPERATION_NAME = "acc.wait"

  _ODS_OPERAND_SEGMENTS = [-1,0,0,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, waitOperands, *, asyncOperand=None, waitDevnum=None, async_=None, ifCond=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(waitOperands))
    operands.append(asyncOperand)
    operands.append(waitDevnum)
    operands.append(ifCond)
    _ods_context = _ods_get_default_loc_context(loc)
    if bool(async_): attributes["async"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def waitOperands(self) -> _ods_ir.OpOperandList:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def asyncOperand(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def waitDevnum(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def ifCond(self) -> _Optional[_ods_ir.Value]:
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def async_(self) -> bool:
    return "async" in self.operation.attributes

  @async_.setter
  def async_(self, value):
    if bool(value):
      self.operation.attributes["async"] = _ods_ir.UnitAttr.get()
    elif "async" in self.operation.attributes:
      del self.operation.attributes["async"]

  @async_.deleter
  def async_(self):
    del self.operation.attributes["async"]

def wait(wait_operands, *, async_operand=None, wait_devnum=None, async_=None, if_cond=None, loc=None, ip=None) -> WaitOp:
  return WaitOp(waitOperands=wait_operands, asyncOperand=async_operand, waitDevnum=wait_devnum, async_=async_, ifCond=if_cond, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  r"""
  `acc.yield` is a special terminator operation for block inside regions in
  various acc ops (including parallel, loop, atomic.update). It returns values
  to the immediately enclosing acc op.
  """

  OPERATION_NAME = "acc.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def operands_(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(operands_, *, loc=None, ip=None) -> YieldOp:
  return YieldOp(operands_=operands_, loc=loc, ip=ip)
