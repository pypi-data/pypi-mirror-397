
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir
_ods_cext.globals.register_traceback_file_exclusion(__file__)

import builtins
from typing import Sequence as _Sequence, Union as _Union, Optional as _Optional


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "irdl"

@_ods_cext.register_operation(_Dialect)
class AllOfOp(_ods_ir.OpView):
  r"""
  `irdl.all_of` defines a constraint that accepts any type or attribute that
  satisfies all of its provided constraints.
  
  Example:
  
  ```mlir
  irdl.dialect @cmath {
    irdl.type @complex_f32 {
      %0 = irdl.is i32
      %1 = irdl.is f32
      %2 = irdl.any_of(%0, %1) // is 32-bit
  
      %3 = irdl.is f32
      %4 = irdl.is f64
      %5 = irdl.any_of(%3, %4) // is a float
  
      %6 = irdl.all_of(%2, %5) // is a 32-bit float
      irdl.parameters(%6)
    }
  }
  ```
  
  The above program defines a type `complex` inside the dialect `cmath` that
  has one parameter that must be 32-bit long and a float (in other
  words, that must be `f32`).
  """

  OPERATION_NAME = "irdl.all_of"

  _ODS_REGIONS = (0, True)

  def __init__(self, args, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def all_of(args, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AllOfOp(args=args, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AnyOfOp(_ods_ir.OpView):
  r"""
  `irdl.any_of` defines a constraint that accepts any type or attribute that
  satisfies at least one of its provided type constraints.
  
  Example:
  
  ```mlir
  irdl.dialect @cmath {
    irdl.type @complex {
      %0 = irdl.is i32
      %1 = irdl.is i64
      %2 = irdl.is f32
      %3 = irdl.is f64
      %4 = irdl.any_of(%0, %1, %2, %3)
      irdl.parameters(%4)
    }
  }
  ```
  
  The above program defines a type `complex` inside the dialect `cmath` that
  has a single type parameter that can be either `i32`, `i64`, `f32` or
  `f64`.
  """

  OPERATION_NAME = "irdl.any_of"

  _ODS_REGIONS = (0, True)

  def __init__(self, args, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    if results is None: results = [operands[0].type] * 1
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def any_of(args, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AnyOfOp(args=args, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AnyOp(_ods_ir.OpView):
  r"""
  `irdl.any` defines a constraint that accepts any type or attribute.
  
  Example:
  
  ```mlir
  irdl.dialect @cmath {
    irdl.type @complex_flexible {
      %0 = irdl.any
      irdl.parameters(%0)
    }
  }
  ```
  
  The above program defines a type `complex_flexible` inside the dialect
  `cmath` that has a single parameter that can be any attribute.
  """

  OPERATION_NAME = "irdl.any"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def any(*, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return AnyOp(results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class AttributeOp(_ods_ir.OpView):
  r"""
  `irdl.attribute` defines a new attribute belonging to the `irdl.dialect`
  parent.
  
  The attribute parameters can be defined with an `irdl.parameters` operation
  in the optional region.
  
  Example:
  
  ```mlir
  irdl.dialect @testd {
    irdl.attribute @enum_attr {
      %0 = irdl.is "foo"
      %1 = irdl.is "bar"
      %2 = irdl.any_of(%0, %1)
      irdl.parameters(%2)
    }
  }
  ```
  
  The above program defines an `enum_attr` attribute inside the `testd`
  dialect. The attribute has one `StringAttr` parameter that should be
  either a `"foo"` or a `"bar"`.
  """

  OPERATION_NAME = "irdl.attribute"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def attribute(sym_name, *, loc=None, ip=None) -> AttributeOp:
  return AttributeOp(sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class AttributesOp(_ods_ir.OpView):
  r"""
  `irdl.attributes` defines the attributes of the `irdl.operation` parent
  operation definition.
  
  In the following example, `irdl.attributes` defines the attributes of the
  `attr_op` operation:
  
  ```mlir
  irdl.dialect @example {
  
    irdl.operation @attr_op {
      %0 = irdl.any
      %1 = irdl.is i64
      irdl.attibutes {
        "attr1" = %0,
        "attr2" = %1
      }
    }
  }
  ```
  
  The operation will expect an arbitrary attribute "attr1" and an
  attribute "attr2" with value `i64`.
  """

  OPERATION_NAME = "irdl.attributes"

  _ODS_REGIONS = (0, True)

  def __init__(self, attributeValues, attributeValueNames, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(attributeValues))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["attributeValueNames"] = (attributeValueNames if (
    isinstance(attributeValueNames, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(attributeValueNames, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def attributeValues(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def attributeValueNames(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["attributeValueNames"]

  @attributeValueNames.setter
  def attributeValueNames(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["attributeValueNames"] = value

def attributes_(attribute_values, attribute_value_names, *, loc=None, ip=None) -> AttributesOp:
  return AttributesOp(attributeValues=attribute_values, attributeValueNames=attribute_value_names, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class BaseOp(_ods_ir.OpView):
  r"""
  `irdl.base` defines a constraint that only accepts a single type
  or attribute base, e.g. an `IntegerType`. The attribute base is defined
  either by a symbolic reference to the corresponding IRDL definition,
  or by the name of the base. Named bases are prefixed with `!` or `#`
  respectively for types and attributes.
  
  Example:
  
  ```mlir
  irdl.dialect @cmath {
    irdl.type @complex {
      %0 = irdl.base "!builtin.integer"
      irdl.parameters(%0)
    }
  
    irdl.type @complex_wrapper {
      %0 = irdl.base @cmath::@complex
      irdl.parameters(%0)
    }
  }
  ```
  
  The above program defines a `cmath.complex` type that expects a single
  parameter, which is a type with base name `builtin.integer`, which is the
  name of an `IntegerType` type.
  It also defines a `cmath.complex_wrapper` type that expects a single
  parameter, which is a type of base type `cmath.complex`.
  """

  OPERATION_NAME = "irdl.base"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, base_ref=None, base_name=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    if base_ref is not None: attributes["base_ref"] = (base_ref if (
        isinstance(base_ref, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
          _ods_ir.AttrBuilder.get('SymbolRefAttr')(base_ref, context=_ods_context))
    if base_name is not None: attributes["base_name"] = (base_name if (
        isinstance(base_name, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(base_name, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def base_ref(self) -> _Optional[_ods_ir.SymbolRefAttr]:
    if "base_ref" not in self.operation.attributes:
      return None
    return self.operation.attributes["base_ref"]

  @base_ref.setter
  def base_ref(self, value: _Optional[_ods_ir.SymbolRefAttr]):
    if value is not None:
      self.operation.attributes["base_ref"] = value
    elif "base_ref" in self.operation.attributes:
      del self.operation.attributes["base_ref"]

  @base_ref.deleter
  def base_ref(self):
    del self.operation.attributes["base_ref"]

  @builtins.property
  def base_name(self) -> _Optional[_ods_ir.StringAttr]:
    if "base_name" not in self.operation.attributes:
      return None
    return self.operation.attributes["base_name"]

  @base_name.setter
  def base_name(self, value: _Optional[_ods_ir.StringAttr]):
    if value is not None:
      self.operation.attributes["base_name"] = value
    elif "base_name" in self.operation.attributes:
      del self.operation.attributes["base_name"]

  @base_name.deleter
  def base_name(self):
    del self.operation.attributes["base_name"]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def base(*, base_ref=None, base_name=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return BaseOp(base_ref=base_ref, base_name=base_name, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class CPredOp(_ods_ir.OpView):
  r"""
  `irdl.c_pred` defines a constraint that is written in C++.
  
  Dialects using this operation cannot be registered at runtime, as it relies
  on C++ code.
  
  Special placeholders can be used to refer to entities in the context where
  this predicate is used. They serve as "hooks" to the enclosing environment.
  The following special placeholders are supported in constraints for an op:
  
  * `$_builder` will be replaced by a mlir::Builder instance.
  * `$_op` will be replaced by the current operation.
  * `$_self` will be replaced with the entity this predicate is attached to.
     Compared to ODS, `$_self` is always of type `mlir::Attribute`, and types
     are manipulated as `TypeAttr` attributes.
  
  Example:
  ```mlir
  irdl.type @op_with_attr {
    %0 = irdl.c_pred "::llvm::isa<::mlir::IntegerAttr>($_self)"
    irdl.parameters(%0)
  }
  ```
  
  In this example, @op_with_attr is defined as a type with a single
  parameter, which is an `IntegerAttr`, as constrained by the C++ predicate.
  """

  OPERATION_NAME = "irdl.c_pred"

  _ODS_REGIONS = (0, True)

  def __init__(self, pred, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["pred"] = (pred if (
    isinstance(pred, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(pred, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def pred(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["pred"]

  @pred.setter
  def pred(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["pred"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def c_pred(pred, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return CPredOp(pred=pred, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class DialectOp(_ods_ir.OpView):
  r"""
  The `irdl.dialect` operation defines a dialect. All operations, attributes,
  and types defined inside its region will be part of the dialect.
  
  Example:
  
  ```mlir
  irdl.dialect @cmath {
    ...
  }
  ```
  
  The above program defines a `cmath` dialect.
  """

  OPERATION_NAME = "irdl.dialect"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def dialect(sym_name, *, loc=None, ip=None) -> DialectOp:
  return DialectOp(sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class IsOp(_ods_ir.OpView):
  r"""
  `irdl.is` defines a constraint that only accepts a specific instance of a
  type or attribute.
  
  Example:
  
  ```mlir
  irdl.dialect @cmath {
    irdl.type @complex_i32 {
      %0 = irdl.is i32
      irdl.parameters(%0)
    }
  }
  ```
  
  The above program defines a `complex_i32` type inside the dialect `cmath`
  that can only have a `i32` as its parameter.
  """

  OPERATION_NAME = "irdl.is"

  _ODS_REGIONS = (0, True)

  def __init__(self, expected, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["expected"] = (expected if (
    isinstance(expected, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('AnyAttr')) else
      _ods_ir.AttrBuilder.get('AnyAttr')(expected, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def expected(self) -> _ods_ir.Attribute:
    return self.operation.attributes["expected"]

  @expected.setter
  def expected(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["expected"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def is_(expected, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return IsOp(expected=expected, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class OperandsOp(_ods_ir.OpView):
  r"""
  `irdl.operands` define the operands of the `irdl.operation` parent operation
  definition. Each operand is named after an identifier.
  
  In the following example, `irdl.operands` defines the operands of the
  `mul` operation:
  
  ```mlir
  irdl.dialect @cmath {
  
    irdl.type @complex { /* ... */ }
  
    irdl.operation @mul {
      %0 = irdl.any
      %1 = irdl.parametric @cmath::@complex<%0>
      irdl.results(res: %1)
      irdl.operands(lhs: %1, rhs: %1)
    }
  }
  ```
  
  The `mul` operation will expect two operands of type `cmath.complex`, that
  have the same type, and return a result of the same type.
  
  The operands can also be marked as variadic or optional:
  ```mlir
  irdl.operands(foo: %0, bar: single %1, baz: optional %2, qux: variadic %3)
  ```
  
  Here, foo and bar are required single operands, baz is an optional operand,
  and qux is a variadic operand.
  
  When more than one operand is marked as optional or variadic, the operation
  will expect a 'operandSegmentSizes' attribute that defines the number of
  operands in each segment.
  """

  OPERATION_NAME = "irdl.operands"

  _ODS_REGIONS = (0, True)

  def __init__(self, args, names, variadicity, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["names"] = (names if (
    isinstance(names, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(names, context=_ods_context))
    attributes["variadicity"] = (variadicity if (
    isinstance(variadicity, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VariadicityArrayAttr')) else
      _ods_ir.AttrBuilder.get('VariadicityArrayAttr')(variadicity, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def names(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["names"]

  @names.setter
  def names(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["names"] = value

  @builtins.property
  def variadicity(self) -> _ods_ir.Attribute:
    return self.operation.attributes["variadicity"]

  @variadicity.setter
  def variadicity(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["variadicity"] = value

def operands_(args, names, variadicity, *, loc=None, ip=None) -> OperandsOp:
  return OperandsOp(args=args, names=names, variadicity=variadicity, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class OperationOp(_ods_ir.OpView):
  r"""
  `irdl.operation` defines a new operation belonging to the `irdl.dialect`
  parent.
  
  Operations can define constraints on their operands and results with the
  `irdl.results` and `irdl.operands` operations. If these operations are not
  present in the region, the results or operands are expected to be empty.
  
  Example:
  
  ```mlir
  irdl.dialect @cmath {
  
    irdl.type @complex { /* ... */ }
  
    irdl.operation @norm {
      %0 = irdl.any
      %1 = irdl.parametric @cmath::@complex<%0>
      irdl.results(%0)
      irdl.operands(%1)
    }
  }
  ```
  
  The above program defines an operation `norm` inside the dialect `cmath`.
  The operation expects a single operand of base type `cmath.complex`, and
  returns a single result of the element type of the operand.
  """

  OPERATION_NAME = "irdl.operation"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def operation_(sym_name, *, loc=None, ip=None) -> OperationOp:
  return OperationOp(sym_name=sym_name, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ParametersOp(_ods_ir.OpView):
  r"""
  `irdl.parameters` defines the constraints on parameters of a type or
  attribute definition. Each parameter is named after an identifier.
  
  Example:
  
  ```mlir
  irdl.dialect @cmath {
    irdl.type @complex {
      %0 = irdl.is i32
      %1 = irdl.is i64
      %2 = irdl.any_of(%0, %1)
      irdl.parameters(elem: %2)
    }
  }
  ```
  
  The above program defines a type `complex` inside the dialect `cmath`. The
  type has a single parameter `elem` that should be either `i32` or `i64`.
  """

  OPERATION_NAME = "irdl.parameters"

  _ODS_REGIONS = (0, True)

  def __init__(self, args, names, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["names"] = (names if (
    isinstance(names, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(names, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def names(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["names"]

  @names.setter
  def names(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["names"] = value

def parameters(args, names, *, loc=None, ip=None) -> ParametersOp:
  return ParametersOp(args=args, names=names, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ParametricOp(_ods_ir.OpView):
  r"""
  `irdl.parametric` defines a constraint that accepts only a single type
  or attribute base. The attribute base is defined by a symbolic reference
  to the corresponding definition. It will additionally constraint the
  parameters of the type/attribute.
  
  Example:
  
  ```mlir
  irdl.dialect @cmath {
  
    irdl.type @complex { /* ... */ }
  
    irdl.operation @norm {
      %0 = irdl.any
      %1 = irdl.parametric @cmath::@complex<%0>
      irdl.operands(%1)
      irdl.results(%0)
    }
  }
  ```
  
  The above program defines an operation `norm` inside the dialect `cmath` that
  for any `T` takes a `cmath.complex` with parameter `T` and returns a `T`.
  """

  OPERATION_NAME = "irdl.parametric"

  _ODS_REGIONS = (0, True)

  def __init__(self, base_type, args, *, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["base_type"] = (base_type if (
    isinstance(base_type, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolRefAttr')) else
      _ods_ir.AttrBuilder.get('SymbolRefAttr')(base_type, context=_ods_context))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def base_type(self) -> _ods_ir.SymbolRefAttr:
    return self.operation.attributes["base_type"]

  @base_type.setter
  def base_type(self, value: _ods_ir.SymbolRefAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["base_type"] = value

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def parametric(base_type, args, *, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return ParametricOp(base_type=base_type, args=args, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RegionOp(_ods_ir.OpView):
  r"""
  The irdl.region construct defines a set of characteristics
  that a region of an operation should satify. Each region is named after
  an identifier.
  
  These characteristics include constraints for the entry block arguments
  of the region and the total number of blocks it contains.
  The number of blocks must be a non-zero and non-negative integer,
  and it is optional by default.
  The set of constraints for the entry block arguments may be optional or
  empty. If no parentheses are provided, the set is assumed to be optional,
  and the arguments are not constrained in any way. If parentheses are
  provided with no arguments, it means that the region must have
  no entry block arguments
  
  
  Example:
  
  ```mlir
  irdl.dialect @example {
    irdl.operation @op_with_regions {
        %r0 = irdl.region
        %r1 = irdl.region()
        %v0 = irdl.is i32
        %v1 = irdl.is i64
        %r2 = irdl.region(%v0, %v1)
        %r3 = irdl.region with size 3
  
        irdl.regions(foo: %r0, bar: %r1, baz: %r2, qux: %r3)
    }
  }
  ```
  
  The above snippet demonstrates an operation named `@op_with_regions`,
  which is constrained to have four regions.
  
  * Region `foo` doesn't have any constraints on the arguments
    or the number of blocks.
  * Region `bar` should have an empty set of arguments.
  * Region `baz` should have two arguments of types `i32` and `i64`.
  * Region `qux` should contain exactly three blocks.
  """

  OPERATION_NAME = "irdl.region"

  _ODS_REGIONS = (0, True)

  def __init__(self, entryBlockArgs, *, numberOfBlocks=None, constrainedArguments=None, results=None, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(entryBlockArgs))
    _ods_context = _ods_get_default_loc_context(loc)
    if numberOfBlocks is not None: attributes["numberOfBlocks"] = (numberOfBlocks if (
        isinstance(numberOfBlocks, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I32Attr')) else
          _ods_ir.AttrBuilder.get('I32Attr')(numberOfBlocks, context=_ods_context))
    if bool(constrainedArguments): attributes["constrainedArguments"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def entryBlockArgs(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def numberOfBlocks(self) -> _Optional[_ods_ir.IntegerAttr]:
    if "numberOfBlocks" not in self.operation.attributes:
      return None
    return self.operation.attributes["numberOfBlocks"]

  @numberOfBlocks.setter
  def numberOfBlocks(self, value: _Optional[_ods_ir.IntegerAttr]):
    if value is not None:
      self.operation.attributes["numberOfBlocks"] = value
    elif "numberOfBlocks" in self.operation.attributes:
      del self.operation.attributes["numberOfBlocks"]

  @numberOfBlocks.deleter
  def numberOfBlocks(self):
    del self.operation.attributes["numberOfBlocks"]

  @builtins.property
  def constrainedArguments(self) -> bool:
    return "constrainedArguments" in self.operation.attributes

  @constrainedArguments.setter
  def constrainedArguments(self, value):
    if bool(value):
      self.operation.attributes["constrainedArguments"] = _ods_ir.UnitAttr.get()
    elif "constrainedArguments" in self.operation.attributes:
      del self.operation.attributes["constrainedArguments"]

  @constrainedArguments.deleter
  def constrainedArguments(self):
    del self.operation.attributes["constrainedArguments"]

  @builtins.property
  def output(self) -> _ods_ir.OpResult:
    return self.operation.results[0]

def region(entry_block_args, *, number_of_blocks=None, constrained_arguments=None, results=None, loc=None, ip=None) -> _ods_ir.OpResult:
  return RegionOp(entryBlockArgs=entry_block_args, numberOfBlocks=number_of_blocks, constrainedArguments=constrained_arguments, results=results, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class RegionsOp(_ods_ir.OpView):
  r"""
  `irdl.regions` defines the regions of an operation by accepting
  values produced by `irdl.region` operation as arguments. Each
  region has an identifier as name.
  
  Example:
  
  ```mlir
  irdl.dialect @example {
    irdl.operation @op_with_regions {
      %r1 = irdl.region with size 3
      %0 = irdl.any
      %r2 = irdl.region(%0)
      irdl.regions(foo: %r1, bar: %r2)
    }
  }
  ```
  
  In the snippet above the operation is constrained to have two regions.
  The first region (`foo`) should contain three blocks.
  The second region (`bar`) should have one region with one argument.
  """

  OPERATION_NAME = "irdl.regions"

  _ODS_REGIONS = (0, True)

  def __init__(self, args, names, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["names"] = (names if (
    isinstance(names, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(names, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def names(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["names"]

  @names.setter
  def names(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["names"] = value

def regions_(args, names, *, loc=None, ip=None) -> RegionsOp:
  return RegionsOp(args=args, names=names, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class ResultsOp(_ods_ir.OpView):
  r"""
  `irdl.results` define the results of the `irdl.operation` parent operation
  definition. Each result is named after an identifier.
  
  In the following example, `irdl.results` defines the results of the
  `get_values` operation:
  
  ```mlir
  irdl.dialect @cmath {
  
    irdl.type @complex { /* ... */ }
  
    /// Returns the real and imaginary parts of a complex number.
    irdl.operation @get_values {
      %0 = irdl.any
      %1 = irdl.parametric @cmath::@complex<%0>
      irdl.results(re: %0, im: %0)
      irdl.operands(complex: %1)
    }
  }
  ```
  
  The operation will expect one operand of the `cmath.complex` type, and two
  results that have the underlying type of the `cmath.complex`.
  
  The results can also be marked as variadic or optional:
  ```mlir
  irdl.results(foo: %0, bar: single %1, baz: optional %2, qux: variadic %3)
  ```
  
  Here, foo and bar are required single results, baz is an optional result,
  and qux is a variadic result.
  
  When more than one result is marked as optional or variadic, the operation
  will expect a 'resultSegmentSizes' attribute that defines the number of
  results in each segment.
  """

  OPERATION_NAME = "irdl.results"

  _ODS_REGIONS = (0, True)

  def __init__(self, args, names, variadicity, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(args))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["names"] = (names if (
    isinstance(names, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrArrayAttr')) else
      _ods_ir.AttrBuilder.get('StrArrayAttr')(names, context=_ods_context))
    attributes["variadicity"] = (variadicity if (
    isinstance(variadicity, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('VariadicityArrayAttr')) else
      _ods_ir.AttrBuilder.get('VariadicityArrayAttr')(variadicity, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def args(self) -> _ods_ir.OpOperandList:
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def names(self) -> _ods_ir.ArrayAttr:
    return self.operation.attributes["names"]

  @names.setter
  def names(self, value: _ods_ir.ArrayAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["names"] = value

  @builtins.property
  def variadicity(self) -> _ods_ir.Attribute:
    return self.operation.attributes["variadicity"]

  @variadicity.setter
  def variadicity(self, value: _ods_ir.Attribute):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["variadicity"] = value

def results_(args, names, variadicity, *, loc=None, ip=None) -> ResultsOp:
  return ResultsOp(args=args, names=names, variadicity=variadicity, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class TypeOp(_ods_ir.OpView):
  r"""
  `irdl.type` defines a new type belonging to the `irdl.dialect` parent.
  
  The type parameters can be defined with an `irdl.parameters` operation in
  the optional region.
  
  Example:
  
  ```mlir
  irdl.dialect @cmath {
    irdl.type @complex {
      %0 = irdl.is i32
      %1 = irdl.is i64
      %2 = irdl.any_of(%0, %1)
      irdl.parameters(%2)
    }
  }
  ```
  
  The above program defines a type `complex` inside the dialect `cmath`. The
  type has a single parameter that should be either `i32` or `i64`.
  """

  OPERATION_NAME = "irdl.type"

  _ODS_REGIONS = (1, True)

  def __init__(self, sym_name, *, loc=None, ip=None):
    operands = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["sym_name"] = (sym_name if (
    isinstance(sym_name, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('SymbolNameAttr')) else
      _ods_ir.AttrBuilder.get('SymbolNameAttr')(sym_name, context=_ods_context))
    results = []
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def sym_name(self) -> _ods_ir.StringAttr:
    return self.operation.attributes["sym_name"]

  @sym_name.setter
  def sym_name(self, value: _ods_ir.StringAttr):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["sym_name"] = value

  @builtins.property
  def body(self) -> _ods_ir.Region:
    return self.regions[0]

def type_(sym_name, *, loc=None, ip=None) -> TypeOp:
  return TypeOp(sym_name=sym_name, loc=loc, ip=ip)
