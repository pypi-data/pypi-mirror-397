"""Pagination pattern with automatic route generation and state management"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/patterns/pagination.ipynb.

# %% auto 0
__all__ = ['PaginationStyle', 'Pagination']

# %% ../../nbs/patterns/pagination.ipynb 3
from typing import Dict, Any, Optional, Callable, List
from enum import Enum
from dataclasses import dataclass
from fasthtml.common import *
from fastcore.basics import patch

from ..core.html_ids import InteractionHtmlIds
from cjm_fasthtml_daisyui.components.actions.button import btn, btn_sizes, btn_styles, btn_behaviors
from cjm_fasthtml_daisyui.components.navigation.pagination import join
from cjm_fasthtml_tailwind.utilities.spacing import m
from cjm_fasthtml_tailwind.utilities.flexbox_and_grid import flex_display, justify
from cjm_fasthtml_tailwind.core.base import combine_classes

# %% ../../nbs/patterns/pagination.ipynb 5
class PaginationStyle(Enum):
    """Display styles for pagination controls."""
    SIMPLE = "simple"        # Previous/Next buttons with page info  
    COMPACT = "compact"      # Previous/Next buttons only (no page info)

# %% ../../nbs/patterns/pagination.ipynb 7
class Pagination:
    """Manage paginated views with automatic route generation and state management."""
    
    def __init__(
        self,
        pagination_id: str,  # Unique identifier for this pagination instance
        data_loader: Callable[[Any], List[Any]],  # Function that returns all items
        render_items: Callable[[List[Any], int, Any], Any],  # Function to render items for a page
        items_per_page: int = 20,  # Number of items per page
        container_id: str = None,  # HTML ID for container (auto-generated if None)
        content_id: str = None,  # HTML ID for content area (auto-generated if None)
        preserve_params: List[str] = None,  # Query parameters to preserve
        style: PaginationStyle = PaginationStyle.SIMPLE,  # Pagination display style
        prev_text: str = "« Previous",  # Text for previous button
        next_text: str = "Next »",  # Text for next button
        page_info_format: str = "Page {current} of {total}",  # Format for page info
        button_size: str = None,  # Button size class
        push_url: bool = True,  # Whether to update URL with hx-push-url
        show_endpoints: bool = False,  # Whether to show First/Last buttons
        first_text: str = "«« First",  # Text for first page button
        last_text: str = "Last »»",  # Text for last page button
        redirect_route: Optional[Callable[[int, Dict[str, Any]], str]] = None,  # Route to redirect non-HTMX requests
    ):
        """Initialize pagination manager."""
        self.pagination_id = pagination_id
        self.data_loader = data_loader
        self.render_items = render_items
        self.items_per_page = items_per_page
        self.preserve_params = preserve_params or []
        self.style = style
        self.prev_text = prev_text
        self.next_text = next_text
        self.page_info_format = page_info_format
        self.button_size = button_size
        self.push_url = push_url
        self.show_endpoints = show_endpoints
        self.first_text = first_text
        self.last_text = last_text
        self.redirect_route = redirect_route
        
        # Auto-generate IDs if not provided
        self.container_id = container_id or InteractionHtmlIds.pagination_container(pagination_id)
        self.content_id = content_id or InteractionHtmlIds.pagination_content(pagination_id)

# %% ../../nbs/patterns/pagination.ipynb 9
@patch
def get_total_pages(self:Pagination, 
                    total_items: int  # Total number of items
                   ) -> int:  # Total number of pages
    """Calculate total number of pages."""
    return max(1, (total_items + self.items_per_page - 1) // self.items_per_page)

# %% ../../nbs/patterns/pagination.ipynb 10
@patch
def get_page_items(self:Pagination,
                   all_items: List[Any],  # All items
                   page: int  # Current page number (1-indexed)
                  ) -> tuple:  # (page_items, start_idx, end_idx)
    """Get items for the current page."""
    start_idx = (page - 1) * self.items_per_page
    end_idx = min(start_idx + self.items_per_page, len(all_items))
    page_items = all_items[start_idx:end_idx]
    return page_items, start_idx, end_idx

# %% ../../nbs/patterns/pagination.ipynb 11
@patch
def build_route(self:Pagination,
                page: int,  # Page number
                request: Any,  # FastHTML request object
                page_route_func: Callable  # Route function from create_router
               ) -> str:  # Complete route with preserved params
    """Build route URL with preserved query parameters."""
    # Get preserved params from request
    params = {"page": page}
    for param in self.preserve_params:
        value = request.query_params.get(param)
        if value:
            params[param] = value
    
    # Build route with params
    return page_route_func.to(**params)

# %% ../../nbs/patterns/pagination.ipynb 13
@patch
def render_navigation_controls(self:Pagination,
                               current_page: int,  # Current page number
                               total_pages: int,  # Total number of pages
                               route_func: Callable[[int], str]  # Function to generate route for page
                              ) -> FT:  # Navigation controls element
    """Render pagination navigation controls."""
    # Calculate prev/next page numbers
    prev_page = max(1, current_page - 1)
    next_page = min(total_pages, current_page + 1)
    
    # Check if we're at boundaries
    is_first_page = current_page <= 1
    is_last_page = current_page >= total_pages
    
    # Build button classes
    button_classes = [btn]
    if self.button_size:
        button_classes.append(self.button_size)
    
    # Build button group content
    button_group_parts = []
    
    # Add First button if enabled
    if self.show_endpoints:
        first_button = A(
            self.first_text,
            href=route_func(1),
            hx_get=route_func(1),
            hx_target=InteractionHtmlIds.as_selector(self.content_id),
            hx_swap="outerHTML",
            hx_push_url="true" if self.push_url else None,
            cls=combine_classes(
                *button_classes,
                btn_styles.ghost if not is_first_page else btn_behaviors.disabled
            ),
            disabled=is_first_page
        )
        button_group_parts.append(first_button)
    
    # Create Previous button
    prev_button = A(
        self.prev_text,
        href=route_func(prev_page),
        hx_get=route_func(prev_page),
        hx_target=InteractionHtmlIds.as_selector(self.content_id),
        hx_swap="outerHTML",
        hx_push_url="true" if self.push_url else None,
        cls=combine_classes(
            *button_classes,
            btn_styles.ghost if not is_first_page else btn_behaviors.disabled
        ),
        disabled=is_first_page
    )
    button_group_parts.append(prev_button)
    
    # Add page info for SIMPLE style
    if self.style == PaginationStyle.SIMPLE:
        page_info = self.page_info_format.format(
            current=current_page,
            total=total_pages
        )
        button_group_parts.append(
            Span(page_info, cls=str(m.x(4)))
        )
    
    # Create Next button
    next_button = A(
        self.next_text,
        href=route_func(next_page),
        hx_get=route_func(next_page),
        hx_target=InteractionHtmlIds.as_selector(self.content_id),
        hx_swap="outerHTML",
        hx_push_url="true" if self.push_url else None,
        cls=combine_classes(
            *button_classes,
            btn_styles.ghost if not is_last_page else btn_behaviors.disabled
        ),
        disabled=is_last_page
    )
    button_group_parts.append(next_button)
    
    # Add Last button if enabled
    if self.show_endpoints:
        last_button = A(
            self.last_text,
            href=route_func(total_pages),
            hx_get=route_func(total_pages),
            hx_target=InteractionHtmlIds.as_selector(self.content_id),
            hx_swap="outerHTML",
            hx_push_url="true" if self.push_url else None,
            cls=combine_classes(
                *button_classes,
                btn_styles.ghost if not is_last_page else btn_behaviors.disabled
            ),
            disabled=is_last_page
        )
        button_group_parts.append(last_button)
    
    # Build container classes
    container_classes = [
        flex_display,
        justify.center,
        m.t(6)
    ]
    
    # Create the pagination container
    return Div(
        Div(
            *button_group_parts,
            cls=str(join)
        ),
        cls=combine_classes(*container_classes)
    )

# %% ../../nbs/patterns/pagination.ipynb 14
@patch
def render_page_content(self:Pagination,
                       page_items: List[Any],  # Items for current page
                       current_page: int,  # Current page number
                       total_pages: int,  # Total number of pages
                       request: Any,  # FastHTML request object
                       route_func: Callable[[int], str]  # Function to generate route for page
                      ) -> FT:  # Complete page content with items and navigation
    """Render complete page content with items and pagination controls."""
    # Render items using provided render function
    items_content = self.render_items(page_items, current_page, request)
    
    # Render navigation controls
    nav_controls = self.render_navigation_controls(current_page, total_pages, route_func)
    
    # Combine items and navigation
    return Div(
        items_content,
        nav_controls if total_pages > 1 else None,
        id=self.content_id
    )

# %% ../../nbs/patterns/pagination.ipynb 16
@patch
def create_router(self:Pagination,
                  prefix: str = ""  # URL prefix for routes (e.g., "/library")
                 ) -> APIRouter:  # APIRouter with generated routes
    """Create FastHTML router with generated routes for pagination."""
    router = APIRouter(prefix=prefix)
    
    # Store reference to pagination in router for access in route handlers
    router.pagination = self
    
    # Main content route
    @router
    def content(request, page: int = 1, **kwargs):
        """Handle paginated content requests."""
        from cjm_fasthtml_app_core.core.htmx import is_htmx_request
        
        # Check if this is a non-HTMX request (direct navigation/refresh)
        if not is_htmx_request(request) and self.redirect_route:
            # Build query params dict from preserved params
            params = {"page": page}
            for param in self.preserve_params:
                value = request.query_params.get(param)
                if value:
                    params[param] = value
            
            # Redirect to parent route with query params
            redirect_url = self.redirect_route(page, params)
            return RedirectResponse(url=redirect_url, status_code=303)
        
        # HTMX request or no redirect configured: return paginated content
        # Load all items
        all_items = self.data_loader(request)
        
        # Calculate pagination
        total_pages = self.get_total_pages(len(all_items))
        page_items, start_idx, end_idx = self.get_page_items(all_items, page)
        
        # Build route function for navigation
        def make_route(p: int) -> str:
            return self.build_route(p, request, content)
        
        # Render page content
        return self.render_page_content(
            page_items=page_items,
            current_page=page,
            total_pages=total_pages,
            request=request,
            route_func=make_route
        )
    
    return router
