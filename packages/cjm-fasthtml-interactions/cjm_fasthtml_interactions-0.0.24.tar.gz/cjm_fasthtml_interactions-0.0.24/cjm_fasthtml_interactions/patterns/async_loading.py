"""Pattern for asynchronous content loading with skeleton loaders and loading indicators"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/patterns/async_loading.ipynb.

# %% auto 0
__all__ = ['LoadingType', 'AsyncLoadingContainer']

# %% ../../nbs/patterns/async_loading.ipynb 3
from typing import Optional, Any, Union
from enum import Enum
from fasthtml.common import *

from cjm_fasthtml_daisyui.components.feedback.loading import loading, loading_styles, loading_sizes
from cjm_fasthtml_tailwind.utilities.flexbox_and_grid import flex_display, items, justify
from cjm_fasthtml_tailwind.utilities.spacing import p, m
from cjm_fasthtml_tailwind.core.base import combine_classes

# %% ../../nbs/patterns/async_loading.ipynb 5
class LoadingType(Enum):
    """Types of loading indicators for async content."""
    SPINNER = "spinner"  # Default spinning indicator
    DOTS = "dots"  # Animated dots
    RING = "ring"  # Ring spinner
    BALL = "ball"  # Bouncing ball
    BARS = "bars"  # Loading bars
    INFINITY = "infinity"  # Infinity symbol
    NONE = "none"  # No loading indicator (for custom skeleton)

# %% ../../nbs/patterns/async_loading.ipynb 7
def AsyncLoadingContainer(
    container_id: str,  # HTML ID for the container
    load_url: str,  # URL to fetch content from
    loading_type: LoadingType = LoadingType.SPINNER,  # Type of loading indicator
    loading_size: str = "lg",  # Size of loading indicator (xs, sm, md, lg)
    loading_message: Optional[str] = None,  # Optional message to display while loading
    skeleton_content: Optional[Any] = None,  # Optional skeleton/placeholder content
    trigger: str = "load",  # HTMX trigger event (default: load on page load)
    swap: str = "outerHTML",  # HTMX swap method (default: replace entire container)
    container_cls: Optional[str] = None,  # Additional CSS classes for container
    **kwargs  # Additional attributes for the container
) -> FT:  # Div element with async loading configured
    """Create a container that asynchronously loads content from a URL."""
    # Build content based on loading type
    content_parts = []
    
    # Add skeleton content if provided
    if skeleton_content:
        content_parts.append(skeleton_content)
    elif loading_type != LoadingType.NONE:
        # Create loading indicator
        loading_indicator_parts = []
        
        # Map loading type to style
        style_map = {
            LoadingType.SPINNER: loading_styles.spinner,
            LoadingType.DOTS: loading_styles.dots,
            LoadingType.RING: loading_styles.ring,
            LoadingType.BALL: loading_styles.ball,
            LoadingType.BARS: loading_styles.bars,
            LoadingType.INFINITY: loading_styles.infinity,
        }
        
        # Map size string to size class
        size_map = {
            "xs": loading_sizes.xs,
            "sm": loading_sizes.sm,
            "md": loading_sizes.md,
            "lg": loading_sizes.lg,
        }
        
        style = style_map.get(loading_type, loading_styles.spinner)
        size = size_map.get(loading_size, loading_sizes.lg)
        
        # Add spinner
        loading_indicator_parts.append(
            Span(cls=combine_classes(loading, style, size))
        )
        
        # Add loading message if provided
        if loading_message:
            loading_indicator_parts.append(
                P(loading_message, cls=str(m.t(4)))
            )
        
        # Wrap in centered flex container
        content_parts.append(
            Div(
                *loading_indicator_parts,
                cls=combine_classes(
                    flex_display,
                    items.center,
                    justify.center,
                    p(4)
                )
            )
        )
    
    # Build container classes
    container_classes = []
    if container_cls:
        container_classes.append(container_cls)
    
    # Create the async loading container
    return Div(
        *content_parts,
        id=container_id,
        hx_get=load_url,
        hx_trigger=trigger,
        hx_swap=swap,
        cls=combine_classes(*container_classes) if container_classes else None,
        **kwargs
    )
