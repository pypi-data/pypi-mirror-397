# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.4.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""The TimeTagger module measures timing events very accurately."""

from sys import version_info as _swig_python_version_info

# The Time Tagger library uses numpy to return array values
import numpy as _np

# Helper libraries
import os as _os
import sys as _sys
import platform as _platform

try:
    if __package__ or '.' in __name__:
        if not 'TIMETAGGER_DIR' in _os.environ:
          # find firmware files here
          _os.environ['TIMETAGGER_DIR'] = _os.path.dirname(__file__)

        from . import _TimeTagger
    else:
        import _TimeTagger

except:
    if _platform.system() != 'Windows':
        raise

    import winreg as _winreg

    with _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\Swabian Instruments\\Time Tagger') as key:
        _path = _winreg.QueryValueEx(key, 'BaseDirectory')[0] + _winreg.QueryValueEx(key, 'DllSubDirectory')[0]

    # add the new path
    if not _path in _sys.path:
        _sys.path.append(_path)

    import _TimeTagger

    # clear all local variables
    del _path, _winreg

# Check for Visual Studio redistributable and OpalKelly FrontPanel libraries.
_TimeTagger.checkSystemLibraries()


try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref


import enum as _enum
import json as _json
import time as _time
import traceback as _traceback

class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        r"""value(self) -> PyObject *"""
        return _TimeTagger.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        r"""incr(self, n=1) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        r"""decr(self, n=1) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        r"""distance(self, x) -> ptrdiff_t"""
        return _TimeTagger.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        r"""equal(self, x) -> bool"""
        return _TimeTagger.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        r"""copy(self) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        r"""next(self) -> PyObject *"""
        return _TimeTagger.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        r"""__next__(self) -> PyObject *"""
        return _TimeTagger.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        r"""previous(self) -> PyObject *"""
        return _TimeTagger.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        r"""advance(self, n) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        r"""__eq__(self, x) -> bool"""
        return _TimeTagger.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        r"""__ne__(self, x) -> bool"""
        return _TimeTagger.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        r"""__iadd__(self, n) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        r"""__isub__(self, n) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        r"""__add__(self, n) -> SwigPyIterator"""
        return _TimeTagger.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        r"""
        __sub__(self, n) -> SwigPyIterator
        __sub__(self, x) -> ptrdiff_t
        """
        return _TimeTagger.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _TimeTagger:
_TimeTagger.SwigPyIterator_swigregister(SwigPyIterator)
SHARED_PTR_DISOWN = _TimeTagger.SHARED_PTR_DISOWN

class _CharVector(object):
    r"""Proxy of C++ std::vector< signed char > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._CharVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._CharVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._CharVector___bool__(self)

    def __len__(self) -> "std::vector< signed char >::size_type":
        r"""__len__(self) -> std::vector< signed char >::size_type"""
        return _TimeTagger._CharVector___len__(self)

    def __getslice__(self, i: "std::vector< signed char >::difference_type", j: "std::vector< signed char >::difference_type") -> "std::vector< signed char,std::allocator< signed char > > *":
        r"""__getslice__(self, i, j) -> _CharVector"""
        return _TimeTagger._CharVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._CharVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< signed char >::difference_type", j: "std::vector< signed char >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._CharVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._CharVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< signed char >::value_type const &":
        r"""
        __getitem__(self, slice) -> _CharVector
        __getitem__(self, i) -> std::vector< signed char >::value_type const &
        """
        return _TimeTagger._CharVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._CharVector___setitem__(self, *args)

    def pop(self) -> "std::vector< signed char >::value_type":
        r"""pop(self) -> std::vector< signed char >::value_type"""
        return _TimeTagger._CharVector_pop(self)

    def append(self, x: "std::vector< signed char >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._CharVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._CharVector_empty(self)

    def size(self) -> "std::vector< signed char >::size_type":
        r"""size(self) -> std::vector< signed char >::size_type"""
        return _TimeTagger._CharVector_size(self)

    def swap(self, v: "_CharVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._CharVector_swap(self, v)

    def begin(self) -> "std::vector< signed char >::iterator":
        r"""begin(self) -> std::vector< signed char >::iterator"""
        return _TimeTagger._CharVector_begin(self)

    def end(self) -> "std::vector< signed char >::iterator":
        r"""end(self) -> std::vector< signed char >::iterator"""
        return _TimeTagger._CharVector_end(self)

    def rbegin(self) -> "std::vector< signed char >::reverse_iterator":
        r"""rbegin(self) -> std::vector< signed char >::reverse_iterator"""
        return _TimeTagger._CharVector_rbegin(self)

    def rend(self) -> "std::vector< signed char >::reverse_iterator":
        r"""rend(self) -> std::vector< signed char >::reverse_iterator"""
        return _TimeTagger._CharVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._CharVector_clear(self)

    def get_allocator(self) -> "std::vector< signed char >::allocator_type":
        r"""get_allocator(self) -> std::vector< signed char >::allocator_type"""
        return _TimeTagger._CharVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._CharVector_pop_back(self)

    def erase(self, *args) -> "std::vector< signed char >::iterator":
        r"""
        erase(self, pos) -> std::vector< signed char >::iterator
        erase(self, first, last) -> std::vector< signed char >::iterator
        """
        return _TimeTagger._CharVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _CharVector
        __init__(self, other) -> _CharVector
        __init__(self, size) -> _CharVector
        __init__(self, size, value) -> _CharVector
        """
        _TimeTagger._CharVector_swiginit(self, _TimeTagger.new__CharVector(*args))

    def push_back(self, x: "std::vector< signed char >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._CharVector_push_back(self, x)

    def front(self) -> "std::vector< signed char >::value_type const &":
        r"""front(self) -> std::vector< signed char >::value_type const &"""
        return _TimeTagger._CharVector_front(self)

    def back(self) -> "std::vector< signed char >::value_type const &":
        r"""back(self) -> std::vector< signed char >::value_type const &"""
        return _TimeTagger._CharVector_back(self)

    def assign(self, n: "std::vector< signed char >::size_type", x: "std::vector< signed char >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._CharVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._CharVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< signed char >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._CharVector_insert(self, *args)

    def reserve(self, n: "std::vector< signed char >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._CharVector_reserve(self, n)

    def capacity(self) -> "std::vector< signed char >::size_type":
        r"""capacity(self) -> std::vector< signed char >::size_type"""
        return _TimeTagger._CharVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__CharVector

# Register _CharVector in _TimeTagger:
_TimeTagger._CharVector_swigregister(_CharVector)
class _UCharVector(object):
    r"""Proxy of C++ std::vector< unsigned char > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._UCharVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._UCharVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._UCharVector___bool__(self)

    def __len__(self) -> "std::vector< unsigned char >::size_type":
        r"""__len__(self) -> std::vector< unsigned char >::size_type"""
        return _TimeTagger._UCharVector___len__(self)

    def __getslice__(self, i: "std::vector< unsigned char >::difference_type", j: "std::vector< unsigned char >::difference_type") -> "std::vector< unsigned char,std::allocator< unsigned char > > *":
        r"""__getslice__(self, i, j) -> _UCharVector"""
        return _TimeTagger._UCharVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._UCharVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned char >::difference_type", j: "std::vector< unsigned char >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._UCharVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._UCharVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned char >::value_type const &":
        r"""
        __getitem__(self, slice) -> _UCharVector
        __getitem__(self, i) -> std::vector< unsigned char >::value_type const &
        """
        return _TimeTagger._UCharVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._UCharVector___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned char >::value_type":
        r"""pop(self) -> std::vector< unsigned char >::value_type"""
        return _TimeTagger._UCharVector_pop(self)

    def append(self, x: "std::vector< unsigned char >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._UCharVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._UCharVector_empty(self)

    def size(self) -> "std::vector< unsigned char >::size_type":
        r"""size(self) -> std::vector< unsigned char >::size_type"""
        return _TimeTagger._UCharVector_size(self)

    def swap(self, v: "_UCharVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._UCharVector_swap(self, v)

    def begin(self) -> "std::vector< unsigned char >::iterator":
        r"""begin(self) -> std::vector< unsigned char >::iterator"""
        return _TimeTagger._UCharVector_begin(self)

    def end(self) -> "std::vector< unsigned char >::iterator":
        r"""end(self) -> std::vector< unsigned char >::iterator"""
        return _TimeTagger._UCharVector_end(self)

    def rbegin(self) -> "std::vector< unsigned char >::reverse_iterator":
        r"""rbegin(self) -> std::vector< unsigned char >::reverse_iterator"""
        return _TimeTagger._UCharVector_rbegin(self)

    def rend(self) -> "std::vector< unsigned char >::reverse_iterator":
        r"""rend(self) -> std::vector< unsigned char >::reverse_iterator"""
        return _TimeTagger._UCharVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._UCharVector_clear(self)

    def get_allocator(self) -> "std::vector< unsigned char >::allocator_type":
        r"""get_allocator(self) -> std::vector< unsigned char >::allocator_type"""
        return _TimeTagger._UCharVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._UCharVector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned char >::iterator":
        r"""
        erase(self, pos) -> std::vector< unsigned char >::iterator
        erase(self, first, last) -> std::vector< unsigned char >::iterator
        """
        return _TimeTagger._UCharVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _UCharVector
        __init__(self, other) -> _UCharVector
        __init__(self, size) -> _UCharVector
        __init__(self, size, value) -> _UCharVector
        """
        _TimeTagger._UCharVector_swiginit(self, _TimeTagger.new__UCharVector(*args))

    def push_back(self, x: "std::vector< unsigned char >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._UCharVector_push_back(self, x)

    def front(self) -> "std::vector< unsigned char >::value_type const &":
        r"""front(self) -> std::vector< unsigned char >::value_type const &"""
        return _TimeTagger._UCharVector_front(self)

    def back(self) -> "std::vector< unsigned char >::value_type const &":
        r"""back(self) -> std::vector< unsigned char >::value_type const &"""
        return _TimeTagger._UCharVector_back(self)

    def assign(self, n: "std::vector< unsigned char >::size_type", x: "std::vector< unsigned char >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._UCharVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._UCharVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< unsigned char >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._UCharVector_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned char >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._UCharVector_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned char >::size_type":
        r"""capacity(self) -> std::vector< unsigned char >::size_type"""
        return _TimeTagger._UCharVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__UCharVector

# Register _UCharVector in _TimeTagger:
_TimeTagger._UCharVector_swigregister(_UCharVector)
class _ShortVector(object):
    r"""Proxy of C++ std::vector< short > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._ShortVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._ShortVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._ShortVector___bool__(self)

    def __len__(self) -> "std::vector< short >::size_type":
        r"""__len__(self) -> std::vector< short >::size_type"""
        return _TimeTagger._ShortVector___len__(self)

    def __getslice__(self, i: "std::vector< short >::difference_type", j: "std::vector< short >::difference_type") -> "std::vector< short,std::allocator< short > > *":
        r"""__getslice__(self, i, j) -> _ShortVector"""
        return _TimeTagger._ShortVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._ShortVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< short >::difference_type", j: "std::vector< short >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._ShortVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._ShortVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< short >::value_type const &":
        r"""
        __getitem__(self, slice) -> _ShortVector
        __getitem__(self, i) -> std::vector< short >::value_type const &
        """
        return _TimeTagger._ShortVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._ShortVector___setitem__(self, *args)

    def pop(self) -> "std::vector< short >::value_type":
        r"""pop(self) -> std::vector< short >::value_type"""
        return _TimeTagger._ShortVector_pop(self)

    def append(self, x: "std::vector< short >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._ShortVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._ShortVector_empty(self)

    def size(self) -> "std::vector< short >::size_type":
        r"""size(self) -> std::vector< short >::size_type"""
        return _TimeTagger._ShortVector_size(self)

    def swap(self, v: "_ShortVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._ShortVector_swap(self, v)

    def begin(self) -> "std::vector< short >::iterator":
        r"""begin(self) -> std::vector< short >::iterator"""
        return _TimeTagger._ShortVector_begin(self)

    def end(self) -> "std::vector< short >::iterator":
        r"""end(self) -> std::vector< short >::iterator"""
        return _TimeTagger._ShortVector_end(self)

    def rbegin(self) -> "std::vector< short >::reverse_iterator":
        r"""rbegin(self) -> std::vector< short >::reverse_iterator"""
        return _TimeTagger._ShortVector_rbegin(self)

    def rend(self) -> "std::vector< short >::reverse_iterator":
        r"""rend(self) -> std::vector< short >::reverse_iterator"""
        return _TimeTagger._ShortVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._ShortVector_clear(self)

    def get_allocator(self) -> "std::vector< short >::allocator_type":
        r"""get_allocator(self) -> std::vector< short >::allocator_type"""
        return _TimeTagger._ShortVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._ShortVector_pop_back(self)

    def erase(self, *args) -> "std::vector< short >::iterator":
        r"""
        erase(self, pos) -> std::vector< short >::iterator
        erase(self, first, last) -> std::vector< short >::iterator
        """
        return _TimeTagger._ShortVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _ShortVector
        __init__(self, other) -> _ShortVector
        __init__(self, size) -> _ShortVector
        __init__(self, size, value) -> _ShortVector
        """
        _TimeTagger._ShortVector_swiginit(self, _TimeTagger.new__ShortVector(*args))

    def push_back(self, x: "std::vector< short >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._ShortVector_push_back(self, x)

    def front(self) -> "std::vector< short >::value_type const &":
        r"""front(self) -> std::vector< short >::value_type const &"""
        return _TimeTagger._ShortVector_front(self)

    def back(self) -> "std::vector< short >::value_type const &":
        r"""back(self) -> std::vector< short >::value_type const &"""
        return _TimeTagger._ShortVector_back(self)

    def assign(self, n: "std::vector< short >::size_type", x: "std::vector< short >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._ShortVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._ShortVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< short >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._ShortVector_insert(self, *args)

    def reserve(self, n: "std::vector< short >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._ShortVector_reserve(self, n)

    def capacity(self) -> "std::vector< short >::size_type":
        r"""capacity(self) -> std::vector< short >::size_type"""
        return _TimeTagger._ShortVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__ShortVector

# Register _ShortVector in _TimeTagger:
_TimeTagger._ShortVector_swigregister(_ShortVector)
class _UShortVector(object):
    r"""Proxy of C++ std::vector< unsigned short > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._UShortVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._UShortVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._UShortVector___bool__(self)

    def __len__(self) -> "std::vector< unsigned short >::size_type":
        r"""__len__(self) -> std::vector< unsigned short >::size_type"""
        return _TimeTagger._UShortVector___len__(self)

    def __getslice__(self, i: "std::vector< unsigned short >::difference_type", j: "std::vector< unsigned short >::difference_type") -> "std::vector< unsigned short,std::allocator< unsigned short > > *":
        r"""__getslice__(self, i, j) -> _UShortVector"""
        return _TimeTagger._UShortVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._UShortVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned short >::difference_type", j: "std::vector< unsigned short >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._UShortVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._UShortVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned short >::value_type const &":
        r"""
        __getitem__(self, slice) -> _UShortVector
        __getitem__(self, i) -> std::vector< unsigned short >::value_type const &
        """
        return _TimeTagger._UShortVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._UShortVector___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned short >::value_type":
        r"""pop(self) -> std::vector< unsigned short >::value_type"""
        return _TimeTagger._UShortVector_pop(self)

    def append(self, x: "std::vector< unsigned short >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._UShortVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._UShortVector_empty(self)

    def size(self) -> "std::vector< unsigned short >::size_type":
        r"""size(self) -> std::vector< unsigned short >::size_type"""
        return _TimeTagger._UShortVector_size(self)

    def swap(self, v: "_UShortVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._UShortVector_swap(self, v)

    def begin(self) -> "std::vector< unsigned short >::iterator":
        r"""begin(self) -> std::vector< unsigned short >::iterator"""
        return _TimeTagger._UShortVector_begin(self)

    def end(self) -> "std::vector< unsigned short >::iterator":
        r"""end(self) -> std::vector< unsigned short >::iterator"""
        return _TimeTagger._UShortVector_end(self)

    def rbegin(self) -> "std::vector< unsigned short >::reverse_iterator":
        r"""rbegin(self) -> std::vector< unsigned short >::reverse_iterator"""
        return _TimeTagger._UShortVector_rbegin(self)

    def rend(self) -> "std::vector< unsigned short >::reverse_iterator":
        r"""rend(self) -> std::vector< unsigned short >::reverse_iterator"""
        return _TimeTagger._UShortVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._UShortVector_clear(self)

    def get_allocator(self) -> "std::vector< unsigned short >::allocator_type":
        r"""get_allocator(self) -> std::vector< unsigned short >::allocator_type"""
        return _TimeTagger._UShortVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._UShortVector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned short >::iterator":
        r"""
        erase(self, pos) -> std::vector< unsigned short >::iterator
        erase(self, first, last) -> std::vector< unsigned short >::iterator
        """
        return _TimeTagger._UShortVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _UShortVector
        __init__(self, other) -> _UShortVector
        __init__(self, size) -> _UShortVector
        __init__(self, size, value) -> _UShortVector
        """
        _TimeTagger._UShortVector_swiginit(self, _TimeTagger.new__UShortVector(*args))

    def push_back(self, x: "std::vector< unsigned short >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._UShortVector_push_back(self, x)

    def front(self) -> "std::vector< unsigned short >::value_type const &":
        r"""front(self) -> std::vector< unsigned short >::value_type const &"""
        return _TimeTagger._UShortVector_front(self)

    def back(self) -> "std::vector< unsigned short >::value_type const &":
        r"""back(self) -> std::vector< unsigned short >::value_type const &"""
        return _TimeTagger._UShortVector_back(self)

    def assign(self, n: "std::vector< unsigned short >::size_type", x: "std::vector< unsigned short >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._UShortVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._UShortVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< unsigned short >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._UShortVector_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned short >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._UShortVector_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned short >::size_type":
        r"""capacity(self) -> std::vector< unsigned short >::size_type"""
        return _TimeTagger._UShortVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__UShortVector

# Register _UShortVector in _TimeTagger:
_TimeTagger._UShortVector_swigregister(_UShortVector)
class _IntVector(object):
    r"""Proxy of C++ std::vector< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._IntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._IntVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        r"""__len__(self) -> std::vector< int >::size_type"""
        return _TimeTagger._IntVector___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        r"""__getslice__(self, i, j) -> _IntVector"""
        return _TimeTagger._IntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._IntVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._IntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        r"""
        __getitem__(self, slice) -> _IntVector
        __getitem__(self, i) -> std::vector< int >::value_type const &
        """
        return _TimeTagger._IntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._IntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        r"""pop(self) -> std::vector< int >::value_type"""
        return _TimeTagger._IntVector_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._IntVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._IntVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        r"""size(self) -> std::vector< int >::size_type"""
        return _TimeTagger._IntVector_size(self)

    def swap(self, v: "_IntVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._IntVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        r"""begin(self) -> std::vector< int >::iterator"""
        return _TimeTagger._IntVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        r"""end(self) -> std::vector< int >::iterator"""
        return _TimeTagger._IntVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        r"""rbegin(self) -> std::vector< int >::reverse_iterator"""
        return _TimeTagger._IntVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        r"""rend(self) -> std::vector< int >::reverse_iterator"""
        return _TimeTagger._IntVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._IntVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        r"""get_allocator(self) -> std::vector< int >::allocator_type"""
        return _TimeTagger._IntVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._IntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        r"""
        erase(self, pos) -> std::vector< int >::iterator
        erase(self, first, last) -> std::vector< int >::iterator
        """
        return _TimeTagger._IntVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _IntVector
        __init__(self, other) -> _IntVector
        __init__(self, size) -> _IntVector
        __init__(self, size, value) -> _IntVector
        """
        _TimeTagger._IntVector_swiginit(self, _TimeTagger.new__IntVector(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._IntVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        r"""front(self) -> std::vector< int >::value_type const &"""
        return _TimeTagger._IntVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        r"""back(self) -> std::vector< int >::value_type const &"""
        return _TimeTagger._IntVector_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._IntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._IntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< int >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._IntVector_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._IntVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        r"""capacity(self) -> std::vector< int >::size_type"""
        return _TimeTagger._IntVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__IntVector

# Register _IntVector in _TimeTagger:
_TimeTagger._IntVector_swigregister(_IntVector)
class _UIntVector(object):
    r"""Proxy of C++ std::vector< unsigned int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._UIntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._UIntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._UIntVector___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type":
        r"""__len__(self) -> std::vector< unsigned int >::size_type"""
        return _TimeTagger._UIntVector___len__(self)

    def __getslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        r"""__getslice__(self, i, j) -> _UIntVector"""
        return _TimeTagger._UIntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._UIntVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._UIntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._UIntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        r"""
        __getitem__(self, slice) -> _UIntVector
        __getitem__(self, i) -> std::vector< unsigned int >::value_type const &
        """
        return _TimeTagger._UIntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._UIntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned int >::value_type":
        r"""pop(self) -> std::vector< unsigned int >::value_type"""
        return _TimeTagger._UIntVector_pop(self)

    def append(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._UIntVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._UIntVector_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type":
        r"""size(self) -> std::vector< unsigned int >::size_type"""
        return _TimeTagger._UIntVector_size(self)

    def swap(self, v: "_UIntVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._UIntVector_swap(self, v)

    def begin(self) -> "std::vector< unsigned int >::iterator":
        r"""begin(self) -> std::vector< unsigned int >::iterator"""
        return _TimeTagger._UIntVector_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator":
        r"""end(self) -> std::vector< unsigned int >::iterator"""
        return _TimeTagger._UIntVector_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        r"""rbegin(self) -> std::vector< unsigned int >::reverse_iterator"""
        return _TimeTagger._UIntVector_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        r"""rend(self) -> std::vector< unsigned int >::reverse_iterator"""
        return _TimeTagger._UIntVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._UIntVector_clear(self)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        r"""get_allocator(self) -> std::vector< unsigned int >::allocator_type"""
        return _TimeTagger._UIntVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._UIntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        r"""
        erase(self, pos) -> std::vector< unsigned int >::iterator
        erase(self, first, last) -> std::vector< unsigned int >::iterator
        """
        return _TimeTagger._UIntVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _UIntVector
        __init__(self, other) -> _UIntVector
        __init__(self, size) -> _UIntVector
        __init__(self, size, value) -> _UIntVector
        """
        _TimeTagger._UIntVector_swiginit(self, _TimeTagger.new__UIntVector(*args))

    def push_back(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._UIntVector_push_back(self, x)

    def front(self) -> "std::vector< unsigned int >::value_type const &":
        r"""front(self) -> std::vector< unsigned int >::value_type const &"""
        return _TimeTagger._UIntVector_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &":
        r"""back(self) -> std::vector< unsigned int >::value_type const &"""
        return _TimeTagger._UIntVector_back(self)

    def assign(self, n: "std::vector< unsigned int >::size_type", x: "std::vector< unsigned int >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._UIntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._UIntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< unsigned int >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._UIntVector_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned int >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._UIntVector_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned int >::size_type":
        r"""capacity(self) -> std::vector< unsigned int >::size_type"""
        return _TimeTagger._UIntVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__UIntVector

# Register _UIntVector in _TimeTagger:
_TimeTagger._UIntVector_swigregister(_UIntVector)
class _LongVector(object):
    r"""Proxy of C++ std::vector< long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._LongVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._LongVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._LongVector___bool__(self)

    def __len__(self) -> "std::vector< long >::size_type":
        r"""__len__(self) -> std::vector< long >::size_type"""
        return _TimeTagger._LongVector___len__(self)

    def __getslice__(self, i: "std::vector< long >::difference_type", j: "std::vector< long >::difference_type") -> "std::vector< long,std::allocator< long > > *":
        r"""__getslice__(self, i, j) -> _LongVector"""
        return _TimeTagger._LongVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._LongVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< long >::difference_type", j: "std::vector< long >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._LongVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._LongVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< long >::value_type const &":
        r"""
        __getitem__(self, slice) -> _LongVector
        __getitem__(self, i) -> std::vector< long >::value_type const &
        """
        return _TimeTagger._LongVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._LongVector___setitem__(self, *args)

    def pop(self) -> "std::vector< long >::value_type":
        r"""pop(self) -> std::vector< long >::value_type"""
        return _TimeTagger._LongVector_pop(self)

    def append(self, x: "std::vector< long >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._LongVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._LongVector_empty(self)

    def size(self) -> "std::vector< long >::size_type":
        r"""size(self) -> std::vector< long >::size_type"""
        return _TimeTagger._LongVector_size(self)

    def swap(self, v: "_LongVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._LongVector_swap(self, v)

    def begin(self) -> "std::vector< long >::iterator":
        r"""begin(self) -> std::vector< long >::iterator"""
        return _TimeTagger._LongVector_begin(self)

    def end(self) -> "std::vector< long >::iterator":
        r"""end(self) -> std::vector< long >::iterator"""
        return _TimeTagger._LongVector_end(self)

    def rbegin(self) -> "std::vector< long >::reverse_iterator":
        r"""rbegin(self) -> std::vector< long >::reverse_iterator"""
        return _TimeTagger._LongVector_rbegin(self)

    def rend(self) -> "std::vector< long >::reverse_iterator":
        r"""rend(self) -> std::vector< long >::reverse_iterator"""
        return _TimeTagger._LongVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._LongVector_clear(self)

    def get_allocator(self) -> "std::vector< long >::allocator_type":
        r"""get_allocator(self) -> std::vector< long >::allocator_type"""
        return _TimeTagger._LongVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._LongVector_pop_back(self)

    def erase(self, *args) -> "std::vector< long >::iterator":
        r"""
        erase(self, pos) -> std::vector< long >::iterator
        erase(self, first, last) -> std::vector< long >::iterator
        """
        return _TimeTagger._LongVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _LongVector
        __init__(self, other) -> _LongVector
        __init__(self, size) -> _LongVector
        __init__(self, size, value) -> _LongVector
        """
        _TimeTagger._LongVector_swiginit(self, _TimeTagger.new__LongVector(*args))

    def push_back(self, x: "std::vector< long >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._LongVector_push_back(self, x)

    def front(self) -> "std::vector< long >::value_type const &":
        r"""front(self) -> std::vector< long >::value_type const &"""
        return _TimeTagger._LongVector_front(self)

    def back(self) -> "std::vector< long >::value_type const &":
        r"""back(self) -> std::vector< long >::value_type const &"""
        return _TimeTagger._LongVector_back(self)

    def assign(self, n: "std::vector< long >::size_type", x: "std::vector< long >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._LongVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._LongVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< long >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._LongVector_insert(self, *args)

    def reserve(self, n: "std::vector< long >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._LongVector_reserve(self, n)

    def capacity(self) -> "std::vector< long >::size_type":
        r"""capacity(self) -> std::vector< long >::size_type"""
        return _TimeTagger._LongVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__LongVector

# Register _LongVector in _TimeTagger:
_TimeTagger._LongVector_swigregister(_LongVector)
class _ULongVector(object):
    r"""Proxy of C++ std::vector< unsigned long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._ULongVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._ULongVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._ULongVector___bool__(self)

    def __len__(self) -> "std::vector< unsigned long >::size_type":
        r"""__len__(self) -> std::vector< unsigned long >::size_type"""
        return _TimeTagger._ULongVector___len__(self)

    def __getslice__(self, i: "std::vector< unsigned long >::difference_type", j: "std::vector< unsigned long >::difference_type") -> "std::vector< unsigned long,std::allocator< unsigned long > > *":
        r"""__getslice__(self, i, j) -> _ULongVector"""
        return _TimeTagger._ULongVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._ULongVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned long >::difference_type", j: "std::vector< unsigned long >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._ULongVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._ULongVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned long >::value_type const &":
        r"""
        __getitem__(self, slice) -> _ULongVector
        __getitem__(self, i) -> std::vector< unsigned long >::value_type const &
        """
        return _TimeTagger._ULongVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._ULongVector___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned long >::value_type":
        r"""pop(self) -> std::vector< unsigned long >::value_type"""
        return _TimeTagger._ULongVector_pop(self)

    def append(self, x: "std::vector< unsigned long >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._ULongVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._ULongVector_empty(self)

    def size(self) -> "std::vector< unsigned long >::size_type":
        r"""size(self) -> std::vector< unsigned long >::size_type"""
        return _TimeTagger._ULongVector_size(self)

    def swap(self, v: "_ULongVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._ULongVector_swap(self, v)

    def begin(self) -> "std::vector< unsigned long >::iterator":
        r"""begin(self) -> std::vector< unsigned long >::iterator"""
        return _TimeTagger._ULongVector_begin(self)

    def end(self) -> "std::vector< unsigned long >::iterator":
        r"""end(self) -> std::vector< unsigned long >::iterator"""
        return _TimeTagger._ULongVector_end(self)

    def rbegin(self) -> "std::vector< unsigned long >::reverse_iterator":
        r"""rbegin(self) -> std::vector< unsigned long >::reverse_iterator"""
        return _TimeTagger._ULongVector_rbegin(self)

    def rend(self) -> "std::vector< unsigned long >::reverse_iterator":
        r"""rend(self) -> std::vector< unsigned long >::reverse_iterator"""
        return _TimeTagger._ULongVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._ULongVector_clear(self)

    def get_allocator(self) -> "std::vector< unsigned long >::allocator_type":
        r"""get_allocator(self) -> std::vector< unsigned long >::allocator_type"""
        return _TimeTagger._ULongVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._ULongVector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned long >::iterator":
        r"""
        erase(self, pos) -> std::vector< unsigned long >::iterator
        erase(self, first, last) -> std::vector< unsigned long >::iterator
        """
        return _TimeTagger._ULongVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _ULongVector
        __init__(self, other) -> _ULongVector
        __init__(self, size) -> _ULongVector
        __init__(self, size, value) -> _ULongVector
        """
        _TimeTagger._ULongVector_swiginit(self, _TimeTagger.new__ULongVector(*args))

    def push_back(self, x: "std::vector< unsigned long >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._ULongVector_push_back(self, x)

    def front(self) -> "std::vector< unsigned long >::value_type const &":
        r"""front(self) -> std::vector< unsigned long >::value_type const &"""
        return _TimeTagger._ULongVector_front(self)

    def back(self) -> "std::vector< unsigned long >::value_type const &":
        r"""back(self) -> std::vector< unsigned long >::value_type const &"""
        return _TimeTagger._ULongVector_back(self)

    def assign(self, n: "std::vector< unsigned long >::size_type", x: "std::vector< unsigned long >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._ULongVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._ULongVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< unsigned long >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._ULongVector_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned long >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._ULongVector_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned long >::size_type":
        r"""capacity(self) -> std::vector< unsigned long >::size_type"""
        return _TimeTagger._ULongVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__ULongVector

# Register _ULongVector in _TimeTagger:
_TimeTagger._ULongVector_swigregister(_ULongVector)
class _LongLongVector(object):
    r"""Proxy of C++ std::vector< long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._LongLongVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._LongLongVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._LongLongVector___bool__(self)

    def __len__(self) -> "std::vector< long long >::size_type":
        r"""__len__(self) -> std::vector< long long >::size_type"""
        return _TimeTagger._LongLongVector___len__(self)

    def __getslice__(self, i: "std::vector< long long >::difference_type", j: "std::vector< long long >::difference_type") -> "std::vector< long long,std::allocator< long long > > *":
        r"""__getslice__(self, i, j) -> _LongLongVector"""
        return _TimeTagger._LongLongVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._LongLongVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< long long >::difference_type", j: "std::vector< long long >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._LongLongVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._LongLongVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< long long >::value_type const &":
        r"""
        __getitem__(self, slice) -> _LongLongVector
        __getitem__(self, i) -> std::vector< long long >::value_type const &
        """
        return _TimeTagger._LongLongVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._LongLongVector___setitem__(self, *args)

    def pop(self) -> "std::vector< long long >::value_type":
        r"""pop(self) -> std::vector< long long >::value_type"""
        return _TimeTagger._LongLongVector_pop(self)

    def append(self, x: "std::vector< long long >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._LongLongVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._LongLongVector_empty(self)

    def size(self) -> "std::vector< long long >::size_type":
        r"""size(self) -> std::vector< long long >::size_type"""
        return _TimeTagger._LongLongVector_size(self)

    def swap(self, v: "_LongLongVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._LongLongVector_swap(self, v)

    def begin(self) -> "std::vector< long long >::iterator":
        r"""begin(self) -> std::vector< long long >::iterator"""
        return _TimeTagger._LongLongVector_begin(self)

    def end(self) -> "std::vector< long long >::iterator":
        r"""end(self) -> std::vector< long long >::iterator"""
        return _TimeTagger._LongLongVector_end(self)

    def rbegin(self) -> "std::vector< long long >::reverse_iterator":
        r"""rbegin(self) -> std::vector< long long >::reverse_iterator"""
        return _TimeTagger._LongLongVector_rbegin(self)

    def rend(self) -> "std::vector< long long >::reverse_iterator":
        r"""rend(self) -> std::vector< long long >::reverse_iterator"""
        return _TimeTagger._LongLongVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._LongLongVector_clear(self)

    def get_allocator(self) -> "std::vector< long long >::allocator_type":
        r"""get_allocator(self) -> std::vector< long long >::allocator_type"""
        return _TimeTagger._LongLongVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._LongLongVector_pop_back(self)

    def erase(self, *args) -> "std::vector< long long >::iterator":
        r"""
        erase(self, pos) -> std::vector< long long >::iterator
        erase(self, first, last) -> std::vector< long long >::iterator
        """
        return _TimeTagger._LongLongVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _LongLongVector
        __init__(self, other) -> _LongLongVector
        __init__(self, size) -> _LongLongVector
        __init__(self, size, value) -> _LongLongVector
        """
        _TimeTagger._LongLongVector_swiginit(self, _TimeTagger.new__LongLongVector(*args))

    def push_back(self, x: "std::vector< long long >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._LongLongVector_push_back(self, x)

    def front(self) -> "std::vector< long long >::value_type const &":
        r"""front(self) -> std::vector< long long >::value_type const &"""
        return _TimeTagger._LongLongVector_front(self)

    def back(self) -> "std::vector< long long >::value_type const &":
        r"""back(self) -> std::vector< long long >::value_type const &"""
        return _TimeTagger._LongLongVector_back(self)

    def assign(self, n: "std::vector< long long >::size_type", x: "std::vector< long long >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._LongLongVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._LongLongVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< long long >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._LongLongVector_insert(self, *args)

    def reserve(self, n: "std::vector< long long >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._LongLongVector_reserve(self, n)

    def capacity(self) -> "std::vector< long long >::size_type":
        r"""capacity(self) -> std::vector< long long >::size_type"""
        return _TimeTagger._LongLongVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__LongLongVector

# Register _LongLongVector in _TimeTagger:
_TimeTagger._LongLongVector_swigregister(_LongLongVector)
class _ULongLongVector(object):
    r"""Proxy of C++ std::vector< unsigned long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._ULongLongVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._ULongLongVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._ULongLongVector___bool__(self)

    def __len__(self) -> "std::vector< unsigned long long >::size_type":
        r"""__len__(self) -> std::vector< unsigned long long >::size_type"""
        return _TimeTagger._ULongLongVector___len__(self)

    def __getslice__(self, i: "std::vector< unsigned long long >::difference_type", j: "std::vector< unsigned long long >::difference_type") -> "std::vector< unsigned long long,std::allocator< unsigned long long > > *":
        r"""__getslice__(self, i, j) -> _ULongLongVector"""
        return _TimeTagger._ULongLongVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._ULongLongVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned long long >::difference_type", j: "std::vector< unsigned long long >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._ULongLongVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._ULongLongVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned long long >::value_type const &":
        r"""
        __getitem__(self, slice) -> _ULongLongVector
        __getitem__(self, i) -> std::vector< unsigned long long >::value_type const &
        """
        return _TimeTagger._ULongLongVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._ULongLongVector___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned long long >::value_type":
        r"""pop(self) -> std::vector< unsigned long long >::value_type"""
        return _TimeTagger._ULongLongVector_pop(self)

    def append(self, x: "std::vector< unsigned long long >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._ULongLongVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._ULongLongVector_empty(self)

    def size(self) -> "std::vector< unsigned long long >::size_type":
        r"""size(self) -> std::vector< unsigned long long >::size_type"""
        return _TimeTagger._ULongLongVector_size(self)

    def swap(self, v: "_ULongLongVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._ULongLongVector_swap(self, v)

    def begin(self) -> "std::vector< unsigned long long >::iterator":
        r"""begin(self) -> std::vector< unsigned long long >::iterator"""
        return _TimeTagger._ULongLongVector_begin(self)

    def end(self) -> "std::vector< unsigned long long >::iterator":
        r"""end(self) -> std::vector< unsigned long long >::iterator"""
        return _TimeTagger._ULongLongVector_end(self)

    def rbegin(self) -> "std::vector< unsigned long long >::reverse_iterator":
        r"""rbegin(self) -> std::vector< unsigned long long >::reverse_iterator"""
        return _TimeTagger._ULongLongVector_rbegin(self)

    def rend(self) -> "std::vector< unsigned long long >::reverse_iterator":
        r"""rend(self) -> std::vector< unsigned long long >::reverse_iterator"""
        return _TimeTagger._ULongLongVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._ULongLongVector_clear(self)

    def get_allocator(self) -> "std::vector< unsigned long long >::allocator_type":
        r"""get_allocator(self) -> std::vector< unsigned long long >::allocator_type"""
        return _TimeTagger._ULongLongVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._ULongLongVector_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned long long >::iterator":
        r"""
        erase(self, pos) -> std::vector< unsigned long long >::iterator
        erase(self, first, last) -> std::vector< unsigned long long >::iterator
        """
        return _TimeTagger._ULongLongVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _ULongLongVector
        __init__(self, other) -> _ULongLongVector
        __init__(self, size) -> _ULongLongVector
        __init__(self, size, value) -> _ULongLongVector
        """
        _TimeTagger._ULongLongVector_swiginit(self, _TimeTagger.new__ULongLongVector(*args))

    def push_back(self, x: "std::vector< unsigned long long >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._ULongLongVector_push_back(self, x)

    def front(self) -> "std::vector< unsigned long long >::value_type const &":
        r"""front(self) -> std::vector< unsigned long long >::value_type const &"""
        return _TimeTagger._ULongLongVector_front(self)

    def back(self) -> "std::vector< unsigned long long >::value_type const &":
        r"""back(self) -> std::vector< unsigned long long >::value_type const &"""
        return _TimeTagger._ULongLongVector_back(self)

    def assign(self, n: "std::vector< unsigned long long >::size_type", x: "std::vector< unsigned long long >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._ULongLongVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._ULongLongVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< unsigned long long >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._ULongLongVector_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned long long >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._ULongLongVector_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned long long >::size_type":
        r"""capacity(self) -> std::vector< unsigned long long >::size_type"""
        return _TimeTagger._ULongLongVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__ULongLongVector

# Register _ULongLongVector in _TimeTagger:
_TimeTagger._ULongLongVector_swigregister(_ULongLongVector)
class _FloatVector(object):
    r"""Proxy of C++ std::vector< float > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._FloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._FloatVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._FloatVector___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type":
        r"""__len__(self) -> std::vector< float >::size_type"""
        return _TimeTagger._FloatVector___len__(self)

    def __getslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "std::vector< float,std::allocator< float > > *":
        r"""__getslice__(self, i, j) -> _FloatVector"""
        return _TimeTagger._FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._FloatVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._FloatVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        r"""
        __getitem__(self, slice) -> _FloatVector
        __getitem__(self, i) -> std::vector< float >::value_type const &
        """
        return _TimeTagger._FloatVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._FloatVector___setitem__(self, *args)

    def pop(self) -> "std::vector< float >::value_type":
        r"""pop(self) -> std::vector< float >::value_type"""
        return _TimeTagger._FloatVector_pop(self)

    def append(self, x: "std::vector< float >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._FloatVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._FloatVector_empty(self)

    def size(self) -> "std::vector< float >::size_type":
        r"""size(self) -> std::vector< float >::size_type"""
        return _TimeTagger._FloatVector_size(self)

    def swap(self, v: "_FloatVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._FloatVector_swap(self, v)

    def begin(self) -> "std::vector< float >::iterator":
        r"""begin(self) -> std::vector< float >::iterator"""
        return _TimeTagger._FloatVector_begin(self)

    def end(self) -> "std::vector< float >::iterator":
        r"""end(self) -> std::vector< float >::iterator"""
        return _TimeTagger._FloatVector_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        r"""rbegin(self) -> std::vector< float >::reverse_iterator"""
        return _TimeTagger._FloatVector_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator":
        r"""rend(self) -> std::vector< float >::reverse_iterator"""
        return _TimeTagger._FloatVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._FloatVector_clear(self)

    def get_allocator(self) -> "std::vector< float >::allocator_type":
        r"""get_allocator(self) -> std::vector< float >::allocator_type"""
        return _TimeTagger._FloatVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._FloatVector_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator":
        r"""
        erase(self, pos) -> std::vector< float >::iterator
        erase(self, first, last) -> std::vector< float >::iterator
        """
        return _TimeTagger._FloatVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _FloatVector
        __init__(self, other) -> _FloatVector
        __init__(self, size) -> _FloatVector
        __init__(self, size, value) -> _FloatVector
        """
        _TimeTagger._FloatVector_swiginit(self, _TimeTagger.new__FloatVector(*args))

    def push_back(self, x: "std::vector< float >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._FloatVector_push_back(self, x)

    def front(self) -> "std::vector< float >::value_type const &":
        r"""front(self) -> std::vector< float >::value_type const &"""
        return _TimeTagger._FloatVector_front(self)

    def back(self) -> "std::vector< float >::value_type const &":
        r"""back(self) -> std::vector< float >::value_type const &"""
        return _TimeTagger._FloatVector_back(self)

    def assign(self, n: "std::vector< float >::size_type", x: "std::vector< float >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._FloatVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._FloatVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< float >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._FloatVector_insert(self, *args)

    def reserve(self, n: "std::vector< float >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._FloatVector_reserve(self, n)

    def capacity(self) -> "std::vector< float >::size_type":
        r"""capacity(self) -> std::vector< float >::size_type"""
        return _TimeTagger._FloatVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__FloatVector

# Register _FloatVector in _TimeTagger:
_TimeTagger._FloatVector_swigregister(_FloatVector)
class _DoubleVector(object):
    r"""Proxy of C++ std::vector< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._DoubleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._DoubleVector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        r"""__len__(self) -> std::vector< double >::size_type"""
        return _TimeTagger._DoubleVector___len__(self)

    def __getslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "std::vector< double,std::allocator< double > > *":
        r"""__getslice__(self, i, j) -> _DoubleVector"""
        return _TimeTagger._DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._DoubleVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        r"""
        __getitem__(self, slice) -> _DoubleVector
        __getitem__(self, i) -> std::vector< double >::value_type const &
        """
        return _TimeTagger._DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._DoubleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        r"""pop(self) -> std::vector< double >::value_type"""
        return _TimeTagger._DoubleVector_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._DoubleVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._DoubleVector_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        r"""size(self) -> std::vector< double >::size_type"""
        return _TimeTagger._DoubleVector_size(self)

    def swap(self, v: "_DoubleVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._DoubleVector_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        r"""begin(self) -> std::vector< double >::iterator"""
        return _TimeTagger._DoubleVector_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        r"""end(self) -> std::vector< double >::iterator"""
        return _TimeTagger._DoubleVector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        r"""rbegin(self) -> std::vector< double >::reverse_iterator"""
        return _TimeTagger._DoubleVector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        r"""rend(self) -> std::vector< double >::reverse_iterator"""
        return _TimeTagger._DoubleVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._DoubleVector_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        r"""get_allocator(self) -> std::vector< double >::allocator_type"""
        return _TimeTagger._DoubleVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._DoubleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        r"""
        erase(self, pos) -> std::vector< double >::iterator
        erase(self, first, last) -> std::vector< double >::iterator
        """
        return _TimeTagger._DoubleVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _DoubleVector
        __init__(self, other) -> _DoubleVector
        __init__(self, size) -> _DoubleVector
        __init__(self, size, value) -> _DoubleVector
        """
        _TimeTagger._DoubleVector_swiginit(self, _TimeTagger.new__DoubleVector(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._DoubleVector_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        r"""front(self) -> std::vector< double >::value_type const &"""
        return _TimeTagger._DoubleVector_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        r"""back(self) -> std::vector< double >::value_type const &"""
        return _TimeTagger._DoubleVector_back(self)

    def assign(self, n: "std::vector< double >::size_type", x: "std::vector< double >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._DoubleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._DoubleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< double >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._DoubleVector_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._DoubleVector_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        r"""capacity(self) -> std::vector< double >::size_type"""
        return _TimeTagger._DoubleVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__DoubleVector

# Register _DoubleVector in _TimeTagger:
_TimeTagger._DoubleVector_swigregister(_DoubleVector)
class _StringVector(object):
    r"""Proxy of C++ std::vector< std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._StringVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._StringVector___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        r"""__len__(self) -> std::vector< std::string >::size_type"""
        return _TimeTagger._StringVector___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        r"""__getslice__(self, i, j) -> _StringVector"""
        return _TimeTagger._StringVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._StringVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._StringVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._StringVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        r"""
        __getitem__(self, slice) -> _StringVector
        __getitem__(self, i) -> std::vector< std::string >::value_type const &
        """
        return _TimeTagger._StringVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._StringVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        r"""pop(self) -> std::vector< std::string >::value_type"""
        return _TimeTagger._StringVector_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._StringVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._StringVector_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        r"""size(self) -> std::vector< std::string >::size_type"""
        return _TimeTagger._StringVector_size(self)

    def swap(self, v: "_StringVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._StringVector_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        r"""begin(self) -> std::vector< std::string >::iterator"""
        return _TimeTagger._StringVector_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        r"""end(self) -> std::vector< std::string >::iterator"""
        return _TimeTagger._StringVector_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        r"""rbegin(self) -> std::vector< std::string >::reverse_iterator"""
        return _TimeTagger._StringVector_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        r"""rend(self) -> std::vector< std::string >::reverse_iterator"""
        return _TimeTagger._StringVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._StringVector_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        r"""get_allocator(self) -> std::vector< std::string >::allocator_type"""
        return _TimeTagger._StringVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._StringVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        r"""
        erase(self, pos) -> std::vector< std::string >::iterator
        erase(self, first, last) -> std::vector< std::string >::iterator
        """
        return _TimeTagger._StringVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _StringVector
        __init__(self, other) -> _StringVector
        __init__(self, size) -> _StringVector
        __init__(self, size, value) -> _StringVector
        """
        _TimeTagger._StringVector_swiginit(self, _TimeTagger.new__StringVector(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._StringVector_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        r"""front(self) -> std::vector< std::string >::value_type const &"""
        return _TimeTagger._StringVector_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        r"""back(self) -> std::vector< std::string >::value_type const &"""
        return _TimeTagger._StringVector_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._StringVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._StringVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< std::string >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._StringVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._StringVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        r"""capacity(self) -> std::vector< std::string >::size_type"""
        return _TimeTagger._StringVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__StringVector

# Register _StringVector in _TimeTagger:
_TimeTagger._StringVector_swigregister(_StringVector)
class _EventVector(object):
    r"""Proxy of C++ std::vector< Event > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._EventVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._EventVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._EventVector___bool__(self)

    def __len__(self) -> "std::vector< Event >::size_type":
        r"""__len__(self) -> std::vector< Event >::size_type"""
        return _TimeTagger._EventVector___len__(self)

    def __getslice__(self, i: "std::vector< Event >::difference_type", j: "std::vector< Event >::difference_type") -> "std::vector< Event,std::allocator< Event > > *":
        r"""__getslice__(self, i, j) -> _EventVector"""
        return _TimeTagger._EventVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._EventVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< Event >::difference_type", j: "std::vector< Event >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._EventVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._EventVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Event >::value_type const &":
        r"""
        __getitem__(self, slice) -> _EventVector
        __getitem__(self, i) -> Event
        """
        return _TimeTagger._EventVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._EventVector___setitem__(self, *args)

    def pop(self) -> "std::vector< Event >::value_type":
        r"""pop(self) -> Event"""
        return _TimeTagger._EventVector_pop(self)

    def append(self, x: "Event") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._EventVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._EventVector_empty(self)

    def size(self) -> "std::vector< Event >::size_type":
        r"""size(self) -> std::vector< Event >::size_type"""
        return _TimeTagger._EventVector_size(self)

    def swap(self, v: "_EventVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._EventVector_swap(self, v)

    def begin(self) -> "std::vector< Event >::iterator":
        r"""begin(self) -> std::vector< Event >::iterator"""
        return _TimeTagger._EventVector_begin(self)

    def end(self) -> "std::vector< Event >::iterator":
        r"""end(self) -> std::vector< Event >::iterator"""
        return _TimeTagger._EventVector_end(self)

    def rbegin(self) -> "std::vector< Event >::reverse_iterator":
        r"""rbegin(self) -> std::vector< Event >::reverse_iterator"""
        return _TimeTagger._EventVector_rbegin(self)

    def rend(self) -> "std::vector< Event >::reverse_iterator":
        r"""rend(self) -> std::vector< Event >::reverse_iterator"""
        return _TimeTagger._EventVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._EventVector_clear(self)

    def get_allocator(self) -> "std::vector< Event >::allocator_type":
        r"""get_allocator(self) -> std::vector< Event >::allocator_type"""
        return _TimeTagger._EventVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._EventVector_pop_back(self)

    def erase(self, *args) -> "std::vector< Event >::iterator":
        r"""
        erase(self, pos) -> std::vector< Event >::iterator
        erase(self, first, last) -> std::vector< Event >::iterator
        """
        return _TimeTagger._EventVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _EventVector
        __init__(self, other) -> _EventVector
        __init__(self, size) -> _EventVector
        __init__(self, size, value) -> _EventVector
        """
        _TimeTagger._EventVector_swiginit(self, _TimeTagger.new__EventVector(*args))

    def push_back(self, x: "Event") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._EventVector_push_back(self, x)

    def front(self) -> "std::vector< Event >::value_type const &":
        r"""front(self) -> Event"""
        return _TimeTagger._EventVector_front(self)

    def back(self) -> "std::vector< Event >::value_type const &":
        r"""back(self) -> Event"""
        return _TimeTagger._EventVector_back(self)

    def assign(self, n: "std::vector< Event >::size_type", x: "Event") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._EventVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._EventVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< Event >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._EventVector_insert(self, *args)

    def reserve(self, n: "std::vector< Event >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._EventVector_reserve(self, n)

    def capacity(self) -> "std::vector< Event >::size_type":
        r"""capacity(self) -> std::vector< Event >::size_type"""
        return _TimeTagger._EventVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__EventVector

# Register _EventVector in _TimeTagger:
_TimeTagger._EventVector_swigregister(_EventVector)
class _TimeTaggerServerVector(object):
    r"""Proxy of C++ std::vector< std::shared_ptr< TimeTaggerServer > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._TimeTaggerServerVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._TimeTaggerServerVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._TimeTaggerServerVector___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< TimeTaggerServer > >::size_type":
        r"""__len__(self) -> std::vector< std::shared_ptr< TimeTaggerServer > >::size_type"""
        return _TimeTagger._TimeTaggerServerVector___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< TimeTaggerServer > >::difference_type", j: "std::vector< std::shared_ptr< TimeTaggerServer > >::difference_type") -> "std::vector< std::shared_ptr< TimeTaggerServer >,std::allocator< std::shared_ptr< TimeTaggerServer > > > *":
        r"""__getslice__(self, i, j) -> _TimeTaggerServerVector"""
        return _TimeTagger._TimeTaggerServerVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._TimeTaggerServerVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< TimeTaggerServer > >::difference_type", j: "std::vector< std::shared_ptr< TimeTaggerServer > >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._TimeTaggerServerVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._TimeTaggerServerVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< TimeTaggerServer > >::value_type const &":
        r"""
        __getitem__(self, slice) -> _TimeTaggerServerVector
        __getitem__(self, i) -> std::vector< std::shared_ptr< TimeTaggerServer > >::value_type const &
        """
        return _TimeTagger._TimeTaggerServerVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._TimeTaggerServerVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< TimeTaggerServer > >::value_type":
        r"""pop(self) -> std::vector< std::shared_ptr< TimeTaggerServer > >::value_type"""
        return _TimeTagger._TimeTaggerServerVector_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< TimeTaggerServer > >::value_type const &") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._TimeTaggerServerVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._TimeTaggerServerVector_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< TimeTaggerServer > >::size_type":
        r"""size(self) -> std::vector< std::shared_ptr< TimeTaggerServer > >::size_type"""
        return _TimeTagger._TimeTaggerServerVector_size(self)

    def swap(self, v: "_TimeTaggerServerVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._TimeTaggerServerVector_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< TimeTaggerServer > >::iterator":
        r"""begin(self) -> std::vector< std::shared_ptr< TimeTaggerServer > >::iterator"""
        return _TimeTagger._TimeTaggerServerVector_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< TimeTaggerServer > >::iterator":
        r"""end(self) -> std::vector< std::shared_ptr< TimeTaggerServer > >::iterator"""
        return _TimeTagger._TimeTaggerServerVector_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< TimeTaggerServer > >::reverse_iterator":
        r"""rbegin(self) -> std::vector< std::shared_ptr< TimeTaggerServer > >::reverse_iterator"""
        return _TimeTagger._TimeTaggerServerVector_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< TimeTaggerServer > >::reverse_iterator":
        r"""rend(self) -> std::vector< std::shared_ptr< TimeTaggerServer > >::reverse_iterator"""
        return _TimeTagger._TimeTaggerServerVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._TimeTaggerServerVector_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< TimeTaggerServer > >::allocator_type":
        r"""get_allocator(self) -> std::vector< std::shared_ptr< TimeTaggerServer > >::allocator_type"""
        return _TimeTagger._TimeTaggerServerVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._TimeTaggerServerVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< TimeTaggerServer > >::iterator":
        r"""
        erase(self, pos) -> std::vector< std::shared_ptr< TimeTaggerServer > >::iterator
        erase(self, first, last) -> std::vector< std::shared_ptr< TimeTaggerServer > >::iterator
        """
        return _TimeTagger._TimeTaggerServerVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _TimeTaggerServerVector
        __init__(self, other) -> _TimeTaggerServerVector
        __init__(self, size) -> _TimeTaggerServerVector
        __init__(self, size, value) -> _TimeTaggerServerVector
        """
        _TimeTagger._TimeTaggerServerVector_swiginit(self, _TimeTagger.new__TimeTaggerServerVector(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< TimeTaggerServer > >::value_type const &") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._TimeTaggerServerVector_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< TimeTaggerServer > >::value_type const &":
        r"""front(self) -> std::vector< std::shared_ptr< TimeTaggerServer > >::value_type const &"""
        return _TimeTagger._TimeTaggerServerVector_front(self)

    def back(self) -> "std::vector< std::shared_ptr< TimeTaggerServer > >::value_type const &":
        r"""back(self) -> std::vector< std::shared_ptr< TimeTaggerServer > >::value_type const &"""
        return _TimeTagger._TimeTaggerServerVector_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< TimeTaggerServer > >::size_type", x: "std::vector< std::shared_ptr< TimeTaggerServer > >::value_type const &") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._TimeTaggerServerVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._TimeTaggerServerVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< std::shared_ptr< TimeTaggerServer > >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._TimeTaggerServerVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< TimeTaggerServer > >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._TimeTaggerServerVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< TimeTaggerServer > >::size_type":
        r"""capacity(self) -> std::vector< std::shared_ptr< TimeTaggerServer > >::size_type"""
        return _TimeTagger._TimeTaggerServerVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__TimeTaggerServerVector

# Register _TimeTaggerServerVector in _TimeTagger:
_TimeTagger._TimeTaggerServerVector_swigregister(_TimeTaggerServerVector)
class _IntVectorVector(object):
    r"""Proxy of C++ std::vector< std::vector< int > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._IntVectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._IntVectorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._IntVectorVector___bool__(self)

    def __len__(self) -> "std::vector< std::vector< int > >::size_type":
        r"""__len__(self) -> std::vector< std::vector< int > >::size_type"""
        return _TimeTagger._IntVectorVector___len__(self)

    def __getslice__(self, i: "std::vector< std::vector< int > >::difference_type", j: "std::vector< std::vector< int > >::difference_type") -> "std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > *":
        r"""__getslice__(self, i, j) -> _IntVectorVector"""
        return _TimeTagger._IntVectorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._IntVectorVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::vector< int > >::difference_type", j: "std::vector< std::vector< int > >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._IntVectorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._IntVectorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< int > >::value_type const &":
        r"""
        __getitem__(self, slice) -> _IntVectorVector
        __getitem__(self, i) -> _IntVector
        """
        return _TimeTagger._IntVectorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._IntVectorVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< int > >::value_type":
        r"""pop(self) -> _IntVector"""
        return _TimeTagger._IntVectorVector_pop(self)

    def append(self, x: "_IntVector") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._IntVectorVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._IntVectorVector_empty(self)

    def size(self) -> "std::vector< std::vector< int > >::size_type":
        r"""size(self) -> std::vector< std::vector< int > >::size_type"""
        return _TimeTagger._IntVectorVector_size(self)

    def swap(self, v: "_IntVectorVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._IntVectorVector_swap(self, v)

    def begin(self) -> "std::vector< std::vector< int > >::iterator":
        r"""begin(self) -> std::vector< std::vector< int > >::iterator"""
        return _TimeTagger._IntVectorVector_begin(self)

    def end(self) -> "std::vector< std::vector< int > >::iterator":
        r"""end(self) -> std::vector< std::vector< int > >::iterator"""
        return _TimeTagger._IntVectorVector_end(self)

    def rbegin(self) -> "std::vector< std::vector< int > >::reverse_iterator":
        r"""rbegin(self) -> std::vector< std::vector< int > >::reverse_iterator"""
        return _TimeTagger._IntVectorVector_rbegin(self)

    def rend(self) -> "std::vector< std::vector< int > >::reverse_iterator":
        r"""rend(self) -> std::vector< std::vector< int > >::reverse_iterator"""
        return _TimeTagger._IntVectorVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._IntVectorVector_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< int > >::allocator_type":
        r"""get_allocator(self) -> std::vector< std::vector< int > >::allocator_type"""
        return _TimeTagger._IntVectorVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._IntVectorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< int > >::iterator":
        r"""
        erase(self, pos) -> std::vector< std::vector< int > >::iterator
        erase(self, first, last) -> std::vector< std::vector< int > >::iterator
        """
        return _TimeTagger._IntVectorVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _IntVectorVector
        __init__(self, other) -> _IntVectorVector
        __init__(self, size) -> _IntVectorVector
        __init__(self, size, value) -> _IntVectorVector
        """
        _TimeTagger._IntVectorVector_swiginit(self, _TimeTagger.new__IntVectorVector(*args))

    def push_back(self, x: "_IntVector") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._IntVectorVector_push_back(self, x)

    def front(self) -> "std::vector< std::vector< int > >::value_type const &":
        r"""front(self) -> _IntVector"""
        return _TimeTagger._IntVectorVector_front(self)

    def back(self) -> "std::vector< std::vector< int > >::value_type const &":
        r"""back(self) -> _IntVector"""
        return _TimeTagger._IntVectorVector_back(self)

    def assign(self, n: "std::vector< std::vector< int > >::size_type", x: "_IntVector") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._IntVectorVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._IntVectorVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< std::vector< int > >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._IntVectorVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< int > >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._IntVectorVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< int > >::size_type":
        r"""capacity(self) -> std::vector< std::vector< int > >::size_type"""
        return _TimeTagger._IntVectorVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__IntVectorVector

# Register _IntVectorVector in _TimeTagger:
_TimeTagger._IntVectorVector_swigregister(_IntVectorVector)
class _EventVectorVector(object):
    r"""Proxy of C++ std::vector< std::vector< Event > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        r"""iterator(self) -> SwigPyIterator"""
        return _TimeTagger._EventVectorVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        r"""__nonzero__(self) -> bool"""
        return _TimeTagger._EventVectorVector___nonzero__(self)

    def __bool__(self) -> "bool":
        r"""__bool__(self) -> bool"""
        return _TimeTagger._EventVectorVector___bool__(self)

    def __len__(self) -> "std::vector< std::vector< Event > >::size_type":
        r"""__len__(self) -> std::vector< std::vector< Event > >::size_type"""
        return _TimeTagger._EventVectorVector___len__(self)

    def __getslice__(self, i: "std::vector< std::vector< Event > >::difference_type", j: "std::vector< std::vector< Event > >::difference_type") -> "std::vector< std::vector< Event,std::allocator< Event > >,std::allocator< std::vector< Event,std::allocator< Event > > > > *":
        r"""__getslice__(self, i, j) -> _EventVectorVector"""
        return _TimeTagger._EventVectorVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        r"""
        __setslice__(self, i, j)
        __setslice__(self, i, j, v)
        """
        return _TimeTagger._EventVectorVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::vector< Event > >::difference_type", j: "std::vector< std::vector< Event > >::difference_type") -> "void":
        r"""__delslice__(self, i, j)"""
        return _TimeTagger._EventVectorVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        r"""
        __delitem__(self, i)
        __delitem__(self, slice)
        """
        return _TimeTagger._EventVectorVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< Event > >::value_type const &":
        r"""
        __getitem__(self, slice) -> _EventVectorVector
        __getitem__(self, i) -> _EventVector
        """
        return _TimeTagger._EventVectorVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        r"""
        __setitem__(self, slice, v)
        __setitem__(self, slice)
        __setitem__(self, i, x)
        """
        return _TimeTagger._EventVectorVector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< Event > >::value_type":
        r"""pop(self) -> _EventVector"""
        return _TimeTagger._EventVectorVector_pop(self)

    def append(self, x: "_EventVector") -> "void":
        r"""append(self, x)"""
        return _TimeTagger._EventVectorVector_append(self, x)

    def empty(self) -> "bool":
        r"""empty(self) -> bool"""
        return _TimeTagger._EventVectorVector_empty(self)

    def size(self) -> "std::vector< std::vector< Event > >::size_type":
        r"""size(self) -> std::vector< std::vector< Event > >::size_type"""
        return _TimeTagger._EventVectorVector_size(self)

    def swap(self, v: "_EventVectorVector") -> "void":
        r"""swap(self, v)"""
        return _TimeTagger._EventVectorVector_swap(self, v)

    def begin(self) -> "std::vector< std::vector< Event > >::iterator":
        r"""begin(self) -> std::vector< std::vector< Event > >::iterator"""
        return _TimeTagger._EventVectorVector_begin(self)

    def end(self) -> "std::vector< std::vector< Event > >::iterator":
        r"""end(self) -> std::vector< std::vector< Event > >::iterator"""
        return _TimeTagger._EventVectorVector_end(self)

    def rbegin(self) -> "std::vector< std::vector< Event > >::reverse_iterator":
        r"""rbegin(self) -> std::vector< std::vector< Event > >::reverse_iterator"""
        return _TimeTagger._EventVectorVector_rbegin(self)

    def rend(self) -> "std::vector< std::vector< Event > >::reverse_iterator":
        r"""rend(self) -> std::vector< std::vector< Event > >::reverse_iterator"""
        return _TimeTagger._EventVectorVector_rend(self)

    def clear(self) -> "void":
        r"""clear(self)"""
        return _TimeTagger._EventVectorVector_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< Event > >::allocator_type":
        r"""get_allocator(self) -> std::vector< std::vector< Event > >::allocator_type"""
        return _TimeTagger._EventVectorVector_get_allocator(self)

    def pop_back(self) -> "void":
        r"""pop_back(self)"""
        return _TimeTagger._EventVectorVector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< Event > >::iterator":
        r"""
        erase(self, pos) -> std::vector< std::vector< Event > >::iterator
        erase(self, first, last) -> std::vector< std::vector< Event > >::iterator
        """
        return _TimeTagger._EventVectorVector_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> _EventVectorVector
        __init__(self, other) -> _EventVectorVector
        __init__(self, size) -> _EventVectorVector
        __init__(self, size, value) -> _EventVectorVector
        """
        _TimeTagger._EventVectorVector_swiginit(self, _TimeTagger.new__EventVectorVector(*args))

    def push_back(self, x: "_EventVector") -> "void":
        r"""push_back(self, x)"""
        return _TimeTagger._EventVectorVector_push_back(self, x)

    def front(self) -> "std::vector< std::vector< Event > >::value_type const &":
        r"""front(self) -> _EventVector"""
        return _TimeTagger._EventVectorVector_front(self)

    def back(self) -> "std::vector< std::vector< Event > >::value_type const &":
        r"""back(self) -> _EventVector"""
        return _TimeTagger._EventVectorVector_back(self)

    def assign(self, n: "std::vector< std::vector< Event > >::size_type", x: "_EventVector") -> "void":
        r"""assign(self, n, x)"""
        return _TimeTagger._EventVectorVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        r"""
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _TimeTagger._EventVectorVector_resize(self, *args)

    def insert(self, *args) -> "void":
        r"""
        insert(self, pos, x) -> std::vector< std::vector< Event > >::iterator
        insert(self, pos, n, x)
        """
        return _TimeTagger._EventVectorVector_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< Event > >::size_type") -> "void":
        r"""reserve(self, n)"""
        return _TimeTagger._EventVectorVector_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< Event > >::size_type":
        r"""capacity(self) -> std::vector< std::vector< Event > >::size_type"""
        return _TimeTagger._EventVectorVector_capacity(self)
    __swig_destroy__ = _TimeTagger.delete__EventVectorVector

# Register _EventVectorVector in _TimeTagger:
_TimeTagger._EventVectorVector_swigregister(_EventVectorVector)

def _timeout_handler(callback, timeout):
    r"""
        helper for splitting up timeouts in smaller calls. So CTRL-C will be able to interrupt blocking calls.
        timeout is in milliseconds, 0 means non-blocking, negative means no timeout.
        returns True on success and False on timeout.
    """

    if timeout == 0:
        return callback(timeout)

    maximum_timeout = 20

    if timeout < 0:
        while not callback(maximum_timeout):
            pass
        return True

    original_time = _time.monotonic()
    while True:
        remaining_timeout = max(0,min(maximum_timeout, timeout - round((_time.monotonic() - original_time)*1000)))
        if callback(remaining_timeout):
            return True
        if remaining_timeout == 0:
            return False


def getVersion() -> "std::string":
    r"""
    Time is measured and specified in picoseconds. Time-tags indicate time since device start-up, which is represented by
    a 64-bit integer number. Note that this implies that the time variable will roll over once approximately every 107
    days. This will most likely not be relevant to you unless you plan to run your software continuously over several
    months, and you are taking data at the instance when the rollover is happening.

    You can use the Time Tagger to detect both rising and falling edges. Throughout the software API, the rising edges
    are represented by positive channel numbers starting from 1 and the falling edges are represented by negative channel
    numbers. Virtual channels will automatically obtain numbers higher than the positive channel numbers.

    The Time Taggers delivered before mid 2018 have a different channel numbering. More details can be found in the
    Number Schema 0 and 1 <channel_number_schema>} section.

    Get the version of the Time Tagger software installed.

    :rtype: string
    :return: Version of the Time Tagger software.
    """
    return _TimeTagger.getVersion()

def getCompilerVersion() -> "std::string":
    r"""
    Query the compiler used for compiling the Time Tagger software suite.
    :rtype: string
    :return: The compiler identifier and its version.
    """
    return _TimeTagger.getCompilerVersion()

def getCompilationTimestamp() -> "int64_t":
    r"""
    Query the UNIX timestamp when Time Tagger software suite was compiled.
    :rtype: int
    :return: The amount of seconds since January first of 1970.
    """
    return _TimeTagger.getCompilationTimestamp()
Resolution_Standard = _TimeTagger.Resolution_Standard
r"""Use one time-to-digital conversion per channel. All physical inputs can be used."""
Resolution_HighResA = _TimeTagger.Resolution_HighResA
r"""
    Use two time-to-digital conversions per channel. The resolution is increased by a factor of :math:`\simeq\sqrt{2}`
    compared to the Standard mode, but only a reduced number of certain inputs can be used. Some inputs may remain in
    Standard mode depending on your license.
    """
Resolution_HighResB = _TimeTagger.Resolution_HighResB
r"""
    Use four time-to-digital conversions per channel. The resolution is increased by a factor of :math:`\simeq 2`
    compared to the Standard mode, but only a reduced number of certain inputs can be used. Some inputs may remain in
    Standard mode depending on your license.
    """
Resolution_HighResC = _TimeTagger.Resolution_HighResC
r"""
    Use eight time-to-digital conversions per channel. The resolution is increased by a factor of
    :math:`\simeq\sqrt{8}` compared to the Standard mode, but only a reduced number of certain inputs can be used. Some
    inputs may remain in Standard mode depending on your license.
    """
ChannelEdge_All = _TimeTagger.ChannelEdge_All
r"""Rising and falling edges of channels with HighRes and Standard resolution."""
ChannelEdge_Rising = _TimeTagger.ChannelEdge_Rising
r"""Rising edges of channels with HighRes and Standard resolution."""
ChannelEdge_Falling = _TimeTagger.ChannelEdge_Falling
r"""Falling edges of channels with HighRes and Standard resolution."""
ChannelEdge_HighResAll = _TimeTagger.ChannelEdge_HighResAll
r"""Rising and falling of channels edges with HighRes resolution."""
ChannelEdge_HighResRising = _TimeTagger.ChannelEdge_HighResRising
r"""Rising edges of channels with HighRes resolution."""
ChannelEdge_HighResFalling = _TimeTagger.ChannelEdge_HighResFalling
r"""Falling edges of channels with HighRes resolution."""
ChannelEdge_StandardAll = _TimeTagger.ChannelEdge_StandardAll
r"""Rising and falling edges of channels with Standard resolution."""
ChannelEdge_StandardRising = _TimeTagger.ChannelEdge_StandardRising
r"""Rising edges of channels with Standard resolution."""
ChannelEdge_StandardFalling = _TimeTagger.ChannelEdge_StandardFalling
r"""Falling edges of channels with Standard resolution."""
class SoftwareClockState(object):
    r"""The *SoftwareClockState* object contains the current configuration state:"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    clock_period: "long long" = property(_TimeTagger.SoftwareClockState_clock_period_get, _TimeTagger.SoftwareClockState_clock_period_set, doc=r"""The rounded clock period matching the input frequency set in `TimeTaggerBase::setSoftwareClock()`.""")
    input_channel: "int" = property(_TimeTagger.SoftwareClockState_input_channel_get, _TimeTagger.SoftwareClockState_input_channel_set, doc=r"""The input channel of the software clock set in `TimeTaggerBase::setSoftwareClock()`.""")
    ideal_clock_channel: "int" = property(_TimeTagger.SoftwareClockState_ideal_clock_channel_get, _TimeTagger.SoftwareClockState_ideal_clock_channel_set, doc=r"""
    A virtual channel number to receive the ideal clock tags.
    During a locking period, these tags are separated by clock_period by definition.
    To receive the rescaled measured clock tags, use *clock_channel*.
    """)
    averaging_periods: "double" = property(_TimeTagger.SoftwareClockState_averaging_periods_get, _TimeTagger.SoftwareClockState_averaging_periods_set, doc=r"""The averaging periods set in `TimeTaggerBase::setSoftwareClock()`.""")
    enabled: "bool" = property(_TimeTagger.SoftwareClockState_enabled_get, _TimeTagger.SoftwareClockState_enabled_set, doc=r"""Indicates whether the software clock is active or not.""")
    is_locked: "bool" = property(_TimeTagger.SoftwareClockState_is_locked_get, _TimeTagger.SoftwareClockState_is_locked_set, doc=r"""Indicates whether the PLL of the software clock was able to lock to the input signal.""")
    error_counter: "uint32_t" = property(_TimeTagger.SoftwareClockState_error_counter_get, _TimeTagger.SoftwareClockState_error_counter_set, doc=r"""Amount of locking errors since the last `TimeTaggerBase::setSoftwareClock()` call.""")
    last_ideal_clock_event: "long long" = property(_TimeTagger.SoftwareClockState_last_ideal_clock_event_get, _TimeTagger.SoftwareClockState_last_ideal_clock_event_set, doc=r"""Timestamp of the last ideal clock event in picoseconds.""")
    period_error: "double" = property(_TimeTagger.SoftwareClockState_period_error_get, _TimeTagger.SoftwareClockState_period_error_set, doc=r"""Current deviation of the measured clock period from the ideal period given by *clock_period*.""")
    phase_error_estimation: "double" = property(_TimeTagger.SoftwareClockState_phase_error_estimation_get, _TimeTagger.SoftwareClockState_phase_error_estimation_set, doc=r"""
    Current root of the squared differences of clock_input timestamps and ideal clock timestamps.
    This value includes the discretization noise of the *clock_input* channel.
    """)

    def __init__(self):
        r"""__init__(self) -> SoftwareClockState"""
        _TimeTagger.SoftwareClockState_swiginit(self, _TimeTagger.new_SoftwareClockState())
    __swig_destroy__ = _TimeTagger.delete_SoftwareClockState

# Register SoftwareClockState in _TimeTagger:
_TimeTagger.SoftwareClockState_swigregister(SoftwareClockState)
cvar = _TimeTagger.cvar
CHANNEL_UNUSED = cvar.CHANNEL_UNUSED
CHANNEL_UNUSED_OLD = cvar.CHANNEL_UNUSED_OLD
TT_CHANNEL_NUMBER_SCHEME_AUTO = cvar.TT_CHANNEL_NUMBER_SCHEME_AUTO
TT_CHANNEL_NUMBER_SCHEME_ZERO = cvar.TT_CHANNEL_NUMBER_SCHEME_ZERO
TT_CHANNEL_NUMBER_SCHEME_ONE = cvar.TT_CHANNEL_NUMBER_SCHEME_ONE
TT_CHANNEL_NUMBER_SCHEME_DEFAULT = cvar.TT_CHANNEL_NUMBER_SCHEME_DEFAULT
TT_CHANNEL_RISING_AND_FALLING_EDGES = cvar.TT_CHANNEL_RISING_AND_FALLING_EDGES
TT_CHANNEL_RISING_EDGES = cvar.TT_CHANNEL_RISING_EDGES
TT_CHANNEL_FALLING_EDGES = cvar.TT_CHANNEL_FALLING_EDGES

class ReferenceClockState(object):
    r"""Proxy of C++ ReferenceClockState class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    clock_period: "long long" = property(_TimeTagger.ReferenceClockState_clock_period_get, _TimeTagger.ReferenceClockState_clock_period_set, doc=r"""The rounded clock period matching the input frequency set in `TimeTaggerSource::setReferenceClock()`.""")
    clock_channel: "int" = property(_TimeTagger.ReferenceClockState_clock_channel_get, _TimeTagger.ReferenceClockState_clock_channel_set, doc=r"""The input channel of the periodic clock signal set in `TimeTaggerSource::setReferenceClock()`.""")
    synchronization_channel: "int" = property(_TimeTagger.ReferenceClockState_synchronization_channel_get, _TimeTagger.ReferenceClockState_synchronization_channel_set, doc=r"""The 1 pulse per second channel representing the (UTC) second `TimeTaggerSource::setReferenceClock()`.""")
    ideal_clock_channel: "int" = property(_TimeTagger.ReferenceClockState_ideal_clock_channel_get, _TimeTagger.ReferenceClockState_ideal_clock_channel_set, doc=r"""
    A virtual channel number to receive the ideal clock tags.
    During a locking period, these tags are separated by *clock_period* by definition.
    To receive the rescaled measured clock tags, use *clock_channel*.
    """)
    averaging_periods: "double" = property(_TimeTagger.ReferenceClockState_averaging_periods_get, _TimeTagger.ReferenceClockState_averaging_periods_set, doc=r"""The averaging periods set in `TimeTaggerBase::setReferenceClock()`.""")
    synchronization_offset: "long long" = property(_TimeTagger.ReferenceClockState_synchronization_offset_get, _TimeTagger.ReferenceClockState_synchronization_offset_set, doc=r"""
    The manual offset to the computer's system time in ps. This is necessary if the system time is badly
    aligned to the 1PPS signal of the synchronization system.
    """)
    enabled: "bool" = property(_TimeTagger.ReferenceClockState_enabled_get, _TimeTagger.ReferenceClockState_enabled_set, doc=r"""Indicates whether the reference clock is active or not.""")
    event_divider: "int" = property(_TimeTagger.ReferenceClockState_event_divider_get, _TimeTagger.ReferenceClockState_event_divider_set, doc=r"""The event divider of the *clock_channel*.""")
    is_locked: "bool" = property(_TimeTagger.ReferenceClockState_is_locked_get, _TimeTagger.ReferenceClockState_is_locked_set, doc=r"""Indicates whether the PLL of the software clock was able to lock to the input signal.""")
    is_synchronized: "bool" = property(_TimeTagger.ReferenceClockState_is_synchronized_get, _TimeTagger.ReferenceClockState_is_synchronized_set, doc=r"""Indicates whether the absolute timebase is aligned to the *synchronization_channel*.""")
    error_counter: "uint32_t" = property(_TimeTagger.ReferenceClockState_error_counter_get, _TimeTagger.ReferenceClockState_error_counter_set, doc=r"""Amount of locking errors since the last `TimeTaggerBase::setReferenceClock()` call.""")
    last_ideal_clock_event: "long long" = property(_TimeTagger.ReferenceClockState_last_ideal_clock_event_get, _TimeTagger.ReferenceClockState_last_ideal_clock_event_set, doc=r"""Timestamp of the last ideal clock event in picoseconds.""")
    period_error: "double" = property(_TimeTagger.ReferenceClockState_period_error_get, _TimeTagger.ReferenceClockState_period_error_set, doc=r"""Current deviation of the measured clock period from the ideal period given by *clock_period*.""")
    phase_error_estimation: "double" = property(_TimeTagger.ReferenceClockState_phase_error_estimation_get, _TimeTagger.ReferenceClockState_phase_error_estimation_set, doc=r"""
    Current root of the squared differences of *clock_input* timestamps and ideal clock timestamps.
    This value includes the discretization noise of the *clock_input* channel.
    """)

    def __init__(self):
        r"""__init__(self) -> ReferenceClockState"""
        _TimeTagger.ReferenceClockState_swiginit(self, _TimeTagger.new_ReferenceClockState())
    __swig_destroy__ = _TimeTagger.delete_ReferenceClockState

# Register ReferenceClockState in _TimeTagger:
_TimeTagger.ReferenceClockState_swigregister(ReferenceClockState)
FpgaLinkInterface_SFPP_10GE = _TimeTagger.FpgaLinkInterface_SFPP_10GE
r"""Use the SFP+ Port on the *Time Tagger X*for FPGA link output."""
FpgaLinkInterface_QSFPP_40GE = _TimeTagger.FpgaLinkInterface_QSFPP_40GE
r"""Use the QSFP+ Port on the *Time Tagger X*for FPGA link output."""

def createTimeTagger(*args, **kwargs) -> "TimeTagger":
    r"""
    Establishes the connection to a first available Time Tagger device and creates a TimeTagger object.
    Optionally, the connection to a specific device can be achieved by specifying the device serial number.

    If the HighRes mode is available, it can be selected from Resolution.
    Details on the available inputs are listed in the overview <HighResHardwareDescription>}.

    In MATLAB, this function is accessed as `TimeTagger.createTimeTagger`.

    :type serial: string, optional
    :param serial: Serial number string of the device or empty string.
    :type resolution: int, optional
    :param resolution: Select the resolution of the Time Tagger. The default is `Resolution::Standard`.

    :rtype: :py:class:`TimeTagger`
    :return: A Time Tagger object

    :raises: RuntimeError if no Time Tagger devices are available or if the serial number is not correct.
    """
    return _TimeTagger.createTimeTagger(*args, **kwargs)

def createTimeTaggerVirtual(*args, **kwargs) -> "TimeTaggerVirtual":
    r"""
    Creates a TimeTaggerVirtual object.
    Virtual Time Tagger uses files generated by the FileWriter as data source instead of the Time Tagger hardware.
    This allows you to use all Time Tagger library measurements for offline processing of the dumped time tag stream.
    For example, you can repeat the analysis of your experiment with different parameters, like different binwidths etc.

    The ``file`` parameter can specify a header file or single specific file as shown in the following example.

    .. code-block:: python

        # Assume we have following the files in the current directory:
        #   filename.ttbin
        #   filename.1.ttbin
        #   filename.2.ttbin

        # Replay all files named "filename.NN.ttbin" sequentially
        replay_source.appendFile('filename.ttbin')

        # Replay a single file "filename.1.ttbin"
        replay_source.appendFile('filename.1.ttbin')

    In MATLAB, this function is accessed as ``TimeTagger.createTimeTaggerVirtual``.

    :type filename: string, optional
    :param filename: File name of the initial file. This file defines the available external channels. Default is an
         empty string which creates a simulated Time Tagger with 18 channels.
    :type begin: int, optional
    :param begin: Time offset from the beginning of the file in ps to start the replay at. Default is 0.
    :type duration: int, optional
    :param duration: Duration in picoseconds to be read from the file. *duration=-1* will replay everything. Default is
         -1.

    :rtype: :py:class:`TimeTaggerVirtual`
    :return: Time Tagger Virtual object
    """
    return _TimeTagger.createTimeTaggerVirtual(*args, **kwargs)

def createTimeTaggerNetwork(*args) -> "TimeTaggerNetwork":
    r"""
    *Overload 1:*

    Creates a new TimeTaggerNetwork object.
    During creation, the object tries to open a connection to the specified Time Tagger server that have been created by
    `TimeTagger::startServer()`. This makes the remote time-tag stream locally available.

    In MATLAB, this function is accessed as `TimeTagger.createTimeTaggerNetwork`.

    :type address: string, optional
    :param address: IP address, or hostname, of the server. Use hostname:port.

    :rtype: :py:class:`TimeTaggerNetwork`
    :return: Time Tagger Network object

    :raises: RuntimeError if the connection to the server cannot be made.
    :raises: RuntimeError if the address string has an invalid format.

    |

    *Overload 2:*

    Creates a new TimeTaggerNetwork object.
    During creation, the object tries to open a connection to the specified Time Tagger servers that have been created by
    `TimeTagger::startServer()`. This makes the remote time-tag stream locally available.

    When more than one server is
    specified, the channel number of the n-th server is offset by n * 1000, e.g., channel 3 of the second server will
    become 2003. Moreover, the different servers must be synchronized to an external clock. If the connection fails, the
    method will throw an exception.

    In MATLAB, this function is accessed as `TimeTagger.createTimeTaggerNetwork`.

    :type addresses: std::vector< std::string,std::allocator< std::string > >
    :param addresses: IP addresses, or hostnames, of the servers. Use hostname:port for each server.

    :rtype: :py:class:`TimeTaggerNetwork`
    :return: Time Tagger Network object

    :raises: RuntimeError if the connection to the server cannot be made.
    :raises: RuntimeError if the address string has an invalid format.
    :raises: RuntimeError if attempting to connect to multiple non-synchronized servers.
    """
    return _TimeTagger.createTimeTaggerNetwork(*args)

def setCustomBitFileName(bitFileName: "std::string const &") -> "void":
    r"""
    set path and filename of the bitfile to be loaded into the FPGA

    For debugging/development purposes the firmware loaded into the FPGA can be set manually with this function. To load
    the default bitfile set bitFileName = ""

    :type bitFileName: string
    :param bitFileName: custom bitfile to use for the FPGA.
    """
    return _TimeTagger.setCustomBitFileName(bitFileName)

def __freeTimeTagger(tagger: "TimeTaggerBase") -> "void":
    r"""
    Releases all Time Tagger resources and terminates the active connection.

    :type tagger: :py:class:`TimeTaggerBase`
    :param tagger: Time Tagger Base object to disconnect
    """
    return _TimeTagger.__freeTimeTagger(tagger)

def scanTimeTagger(include_model_name: "bool"=False) -> "std::vector< std::string,std::allocator< std::string > >":
    r"""
    Returns a list of the serial numbers of the connected but not instantiated Time Taggers.
    It may return serials blocked by other processes or already disconnected some milliseconds later.

    In MATLAB this function is accessible as `TimeTagger.scanTimeTagger()`.

    :type include_model_name: boolean, optional
    :param include_model_name: If True, the method returns also the model for each device, as "serial,model" (default:
        False).
    :rtype: std::vector< std::string,std::allocator< std::string > >
    :return: List of serial numbers
    """
    return _TimeTagger.scanTimeTagger(include_model_name)

def getTimeTaggerServerInfo(*args, **kwargs) -> "std::string":
    r"""
    Returns Time Tagger configuration, exposed channels, hardware channels and virtual channels as a JSON formatted
    string.

    :type address: string, optional
    :param address: IP address, hostname or domain-name of the server, where the Time Tagger server is running. The port
        number is optional and can be specified if server listens on a port other than default 41101.

    :rtype: string
    :return: Information about server, available channels and exposed channels.

    :raises: RuntimeError if the connection to the server cannot be made.
    :raises: ValueError if the address string has an invalid format.
    """
    val = _TimeTagger.getTimeTaggerServerInfo(*args, **kwargs)

    val = _json.loads(val)


    return val

def scanTimeTaggerServers() -> "std::vector< std::string,std::allocator< std::string > >":
    r"""
    Scans the network for available Time Tagger servers.

    Notes: 
    The server discovery algorithm uses multicast UDP messages sent to the address
    ``239.255.255.83:41102``. This method is expected to work well in most situations, however there is a possibility
    when it could fail. The servers may not be discoverable if the system firewall rejects multicast traffic or
    blocks access to UDP port 41102.
    Additionally, multicast traffic is typically not forwarded to other IP networks by routers.

    :rtype: std::vector< std::string,std::allocator< std::string > >
    :return: A list of addresses of the Time Tagger servers that are available in the network.
    """
    return _TimeTagger.scanTimeTaggerServers()

def getTimeTaggerModel(serial: "std::string const &") -> "std::string":
    r"""getTimeTaggerModel(serial) -> std::string"""
    return _TimeTagger.getTimeTaggerModel(serial)

def setTimeTaggerChannelNumberScheme(scheme: "int") -> "void":
    r"""
    Deprecated: Since version 2.17 all values of *scheme* except for 1 are deprecated

    Selects whether the first physical channel starts with 0 or 1.

    This method is deprecated and will be removed soon.
    The only purpose of this method is to call `setTimeTaggerChannelNumberScheme(TT_CHANNEL_NUMBER_SCHEME_ONE)`
    with `TT_CHANNEL_NUMBER_SCHEME_ONE = 2`)
    before `createTimeTagger` for old devices (channel numbers starting with 0)
    which will suppress a deprecation warning.

    The method must be called before the first call to `createTimeTagger`.
    """
    return _TimeTagger.setTimeTaggerChannelNumberScheme(scheme)

def getTimeTaggerChannelNumberScheme() -> "int":
    r"""
    Deprecated: Since version 2.17 all values of *scheme* except for 1 are deprecated

    Returns the currently used channel scheme.

    :rtype: int
    :return: Channel scheme
    """
    return _TimeTagger.getTimeTaggerChannelNumberScheme()

def hasTimeTaggerVirtualLicense() -> "bool":
    r"""Check if a license for the TimeTaggerVirtual is available"""
    return _TimeTagger.hasTimeTaggerVirtualLicense()

def flashLicense(serial: "std::string const &", license: "std::string const &") -> "void":
    r"""
    Update the license on the device.

    Updated license may be fetched by getRemoteLicense.
    The Time Tagger must not be instantiated while updating the license.

    :type serial: string
    :param serial: the serial of the device to update the license. Must not be empty
    :type license: string
    :param license: the binary license, encoded as a hexadecimal string
    """
    return _TimeTagger.flashLicense(serial, license)

def extractDeviceLicense(license: "std::string const &") -> "std::string":
    r"""
    Converts binary license to JSON.

    :type license: string
    :param license: the binary license, encoded as a hexadecimal string
    :rtype: string
    :return: a JSON string containing the current device license
    """
    val = _TimeTagger.extractDeviceLicense(license)

    val = _json.loads(val)


    return val
LOGGER_ERROR = _TimeTagger.LOGGER_ERROR

LOGGER_WARNING = _TimeTagger.LOGGER_WARNING

LOGGER_INFO = _TimeTagger.LOGGER_INFO

class CustomLogger(object):
    r"""Helper class for setLogger"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r"""__init__(self) -> CustomLogger"""
        if self.__class__ == CustomLogger:
            _self = None
        else:
            _self = self
        _TimeTagger.CustomLogger_swiginit(self, _TimeTagger.new_CustomLogger(_self, ))
    __swig_destroy__ = _TimeTagger.delete_CustomLogger

    def enable(self) -> "void":
        r"""enable(self)"""
        return _TimeTagger.CustomLogger_enable(self)

    def disable(self) -> "void":
        r"""disable(self)"""
        return _TimeTagger.CustomLogger_disable(self)

    def Log(self, level: "int", msg: "std::string const &") -> "void":
        r"""Log(self, level, msg)"""
        return _TimeTagger.CustomLogger_Log(self, level, msg)
    def __disown__(self):
        self.this.disown()
        _TimeTagger.disown_CustomLogger(self)
        return weakref.proxy(self)

# Register CustomLogger in _TimeTagger:
_TimeTagger.CustomLogger_swigregister(CustomLogger)

def checkSystemLibraries() -> "void":
    r"""Checks the MSVCP and okFrontPanel system library if they match the expected versions"""
    return _TimeTagger.checkSystemLibraries()
class TimeTaggerSource(object):
    r"""
    This class defines methods used to configure a source of time tags, being either a TimeTaggerBase object,
    or a TimeTagger-like object such as a TimeTaggerServer. All Time Tagger classes implement these methods
    by subclassing TimeTaggerBase which itself subclasses TimeTaggerSource.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setInputDelay(self, channel: "int", delay: "long long") -> "void":
        r"""
        Convenience method that calls `setDelaySoftware()` if you use a *Time Tagger 20*or if the delay is beyond the
        supported range defined by `getDelayHardwareRange()`, otherwise `setDelayHardware()` is called.

        :type channel: int
        :param channel:  Channel number.
        :type delay: int
        :param delay:    Delay time in picoseconds.
        """
        return _TimeTagger.TimeTaggerSource_setInputDelay(self, channel, delay)

    def getInputDelay(self, channel: "int") -> "long long":
        r"""
        Convenience method that returns the sum of `getDelaySoftware()` and `getDelayHardware()`.

        :type channel: int
        :param channel:   Channel number.
        :rtype: int
        :return: Delay time in picoseconds.
        """
        return _TimeTagger.TimeTaggerSource_getInputDelay(self, channel)

    def setDelayHardware(self, channel: "int", delay: "long long") -> "void":
        r"""
        Sets an artificial delay per *channel*. The delay can be positive or negative.
        This delay is applied onboard the Time Tagger directly after the time-to-digital conversion,
        so it also affects the :doc:`Conditional Filter<InDepthGuides/ConditionalFilter>`}.
        The maximum/minimum value allowed can be retrieved using `getDelayHardwareRange()`.
        If you exceed the maximum hardware delay range, please use `setDelaySoftware()` instead.

        Notes: Method is not available for the *Time Tagger 20*.
        :type channel: int
        :param channel:  Channel number.
        :type delay: int
        :param delay:    Delay time in picoseconds.
        """
        return _TimeTagger.TimeTaggerSource_setDelayHardware(self, channel, delay)

    def getDelayHardware(self, channel: "int") -> "long long":
        r"""
        Returns the value of the delay applied onboard the Time Tagger in picoseconds for the specified *channel*.

        Notes: Method is not available for the *Time Tagger 20*.
        :type channel: int
        :param channel:   Channel number.
        :rtype: int
        :return: Delay time in picoseconds.
        """
        return _TimeTagger.TimeTaggerSource_getDelayHardware(self, channel)

    def getDelayHardwareRange(self, channel: "int") -> "std::vector< long long,std::allocator< long long > >":
        r"""
        Returns a vector containing the minimum and the maximum allowable values for the hardware input delay for the
        specified channel:

        Device    | Hardware delay range
        ----------| --------------------
        *Time Tagger 20*| not available
        *Time Tagger Ultra*| 2000000 (2 s)
        *Time Tagger X*| 1000000 (1 s)

        :type channel: int
        :param channel: Channel number.
        :rtype: std::vector< long long,std::allocator< long long > >
        :return: Minimum and maximum hardware input delay in picoseconds.
        """
        return _TimeTagger.TimeTaggerSource_getDelayHardwareRange(self, channel)

    def setDelaySoftware(self, channel: "int", delay: "long long") -> "void":
        r"""
        Sets an artificial delay per *channel*. The delay can be positive or negative.
        This delay is applied on the computer, so it does not affect onboard processes such as the Conditional Filter.

        Notes: This method has the best performance when less than 100 events arrive within the time of the largest delay
              set. For example, if the rate over all channels used is 10 MTags/s,
              the signal can be delayed efficiently up to 10 s.
              For larger delays, please consider using -DelayedChannel} instead.

        :type channel: int
        :param channel:  Channel number.
        :type delay: int
        :param delay:    Delay time in picoseconds.
        """
        return _TimeTagger.TimeTaggerSource_setDelaySoftware(self, channel, delay)

    def getDelaySoftware(self, channel: "int") -> "long long":
        r"""
        Returns the value of the delay applied on the computer in picoseconds for the specified *channel*.

        :type channel: int
        :param channel:  Channel number.
        :rtype: int
        :return: Delay time in picoseconds.
        """
        return _TimeTagger.TimeTaggerSource_getDelaySoftware(self, channel)

    def setDeadtime(self, channel: "int", deadtime: "long long") -> "long long":
        r"""
        Sets the dead time of a channel in picoseconds.
        The minimum dead time is defined by the internal clock period, which is 6 nsfor the *Time Tagger 20*,
        2 nsfor the *Time Tagger Ultra*, and 1.333 nsfor the *Time Tagger X*.
        For the *Time Tagger 20*, the requested dead time will be rounded
        to the nearest multiple of the 6 nsclock cycle.
        The other models allow for arbitrary dead times greater than the respective minimum dead time.

        As the dead time passed as an input might be altered to the rounded value, the rounded value will be returned.
        The maximum dead time is 393 s for the *Time Tagger 20*, 2147 s for the *Time Tagger Ultra*, and 716 s for the *Time Tagger X*.
        Larger dead times will result in an exception.

        Notes: The specified dead time is 2.1 ns for *Time Tagger Ultra*and 1.5 ns for *Time Tagger X*.
              With the default setting of the hardware dead time filter,
              an event arriving between the default hardware dead time and the specified dead time after the last event
              of that channel might be dropped (e.g., an event arriving between 2 ns and 2.1 ns
              after the last event on that channel for *Time Tagger Ultra*).
        :type channel: int
        :param channel: Channel number.
        :type deadtime: int
        :param deadtime: Dead time value in picoseconds.
        :rtype: int
        :return: Resulting dead time in picoseconds, that might be rounded to the nearest valid value
                    (minimum dead time or multiple of the clock period).
        """
        return _TimeTagger.TimeTaggerSource_setDeadtime(self, channel, deadtime)

    def getDeadtime(self, channel: "int") -> "long long":
        r"""
        Returns the dead time value for the specified *channel*.

        :type channel: int
        :param channel: Channel number.
        :rtype: int
        :return: Dead time value in picoseconds.
        """
        return _TimeTagger.TimeTaggerSource_getDeadtime(self, channel)

    def getDeadtimeRange(self, channel: "int") -> "std::vector< long long,std::allocator< long long > >":
        r"""
        Returns a vector containing the minimum and the maximum allowable values for the dead time for the specified
        channel.

        :type channel: int
        :param channel: Channel number.
        :rtype: std::vector< long long,std::allocator< long long > >
        :return: Minimum and maximum dead time values in picoseconds.
        """
        return _TimeTagger.TimeTaggerSource_getDeadtimeRange(self, channel)

    def setConditionalFilter(self, trigger: "_IntVector", filtered: "_IntVector") -> "void":
        r"""
        Activates or deactivates the conditional filter.
        Time tags on the filtered channels are discarded unless they were preceded by a time tag
        on one of the trigger channels, which reduces the data rate. More details can be found in the
        :doc:`In-Depth Guide: Conditional Filter <InDepthGuides/ConditionalFilter>`}.

        :type trigger: std::vector< int,std::allocator< int > >
        :param trigger: List of channel numbers
        :type filtered: std::vector< int,std::allocator< int > >
        :param filtered:  List of channel numbers
        """
        return _TimeTagger.TimeTaggerSource_setConditionalFilter(self, trigger, filtered)

    def clearConditionalFilter(self) -> "void":
        r"""Deactivates the event filter. Equivalent to `setConditionalFilter([], [])`."""
        return _TimeTagger.TimeTaggerSource_clearConditionalFilter(self)

    def getConditionalFilterTrigger(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        Returns the collection of trigger channels for the conditional filter.
        :rtype: std::vector< int,std::allocator< int > >
        :return: List of channel numbers.
        """
        return _TimeTagger.TimeTaggerSource_getConditionalFilterTrigger(self)

    def getConditionalFilterFiltered(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        Returns the collection of channels to which the conditional filter is currently applied.
        :rtype: std::vector< int,std::allocator< int > >
        :return: List of channel numbers.
        """
        return _TimeTagger.TimeTaggerSource_getConditionalFilterFiltered(self)

    def setEventDivider(self, channel: "int", divider: "unsigned int") -> "void":
        r"""
        Applies an event divider filter with the specified factor to a channel, which reduces the data rate.
        Only every n-th event from the input stream passes through the filter, as shown in the image.
        The divider is a 16 bit integer, so the maximum value is 65535.

        Note that if the conditional filter is also active, the conditional filter is applied first.

        Also note that the event divider is not supported on the TimeTaggerVirtual.

        :type channel: int
        :param channel: Physical channel number.
        :type divider: int
        :param divider: Divider factor, min. 1 and max. 65535.
        """
        return _TimeTagger.TimeTaggerSource_setEventDivider(self, channel, divider)

    def getEventDivider(self, channel: "int") -> "unsigned int":
        r"""
        Gets the event divider filter factor for the given *channel*.

        See setEventDivider for further details.

        :type channel: int
        :param channel: Physical channel number.
        :rtype: int
        :return: Divider factor value.
        """
        return _TimeTagger.TimeTaggerSource_getEventDivider(self, channel)

    def getOverflows(self) -> "long long":
        r"""
        Returns the number of overflows (missing blocks of time tags due to limited USB data rate)
        that occurred since start-up or last call to `clearOverflows()`.

        :rtype: int
        :return: Number of overflows.
        """
        return _TimeTagger.TimeTaggerSource_getOverflows(self)

    def getOverflowsAndClear(self) -> "long long":
        r"""
        Returns the number of overflows that occurred since start-up and sets them to zero (see, `clearOverflows()`).

        :rtype: int
        :return: Number of overflows.
        """
        return _TimeTagger.TimeTaggerSource_getOverflowsAndClear(self)

    def clearOverflows(self) -> "void":
        r"""Sets the overflow counter to zero."""
        return _TimeTagger.TimeTaggerSource_clearOverflows(self)

    def setReferenceClock(self, *args, **kwargs) -> "void":
        r"""
        Defines in software one of the input channels as the base clock for all channels.
        This feature sets up a software phase-locked loop (PLL) and rescales all incoming time-tags according to the time
        base provided by the *clock_channel*. This clock frequency alignment is called "syntonization".

        The Reference Clock is able to handle signals decimated by `setEventDivider()` and it is possible to recover the
        dismissed tags in software. The new time base is characterized by "ideal clock tags" separated by exactly the
        defined `clock_period = 1E12/clock_frequency`. For measurements, you can use both, rescaled and ideal clock tags.
        The injection of ideal clock tags can be controlled by `setConditionalFilter()`, by default all tags are injected.

        While the PLL is enabled but not locked, the time base of the instrument is invalid.
        In this case, the time-tag stream changes to the overflow mode.
        This means that after a call to `setReferenceClock()`, you will typically find overflows because the PLL starts
        from an unlocked state.

        Beyond the clock syntonization, the Reference Clock can also take a *synchronization_channel* to align the
        absolute time base of the Time Tagger to an external time base. Currently, the synchronization channel expects one
        pulse per second (1PPS) that is aligned precisely to a UTC second. The corresponding UTC second is retrieved from
        the computer's system clock which requires the use of a time standard via PTP. The synchronization feature is
        important for merging time-tag streams in the `TimeTaggerNetwork`.

        Warning: 
            For the *Time Tagger 20*, a phase error of 200 ps needs to be considered when using the reference clock.

        :type clock_channel: int
        :param clock_channel: The physical channel that is used as reference clock input.
        :type clock_frequency: float, optional
        :param clock_frequency: The frequency of the reference clock.
                   The value should not deviate from the real frequency by more than a few percent.
                   If the Event Divider is active on this channel, you still provide the original input frequency.
                   Default: 10E6, for 10 MHz.
        :type time_constant: float, optional
        :param time_constant: The time period to average over in seconds.
                   The suppression of discretization noise is improved by a higher *time_constant*.
                   If the value is too large, however, this will result in increased phase jitter due to the drift of the
                   internal clock or the applied software clock signal. Default: 1E-3, for 1 ms.
        :type synchronization_channel: int, optional
        :param synchronization_channel: The physical channel that provides a 1PPS signal representing a UTC second.
        :type synchronization_offset: int, optional
        :param synchronization_offset: Sets a manual offset to the computer's system time in ps. This is necessary if
                   the system time is badly aligned to the 1PPS signal of the synchronization system. As this might change
                   from start-up to start-up, it is recommended to synchronize both, the synchronization system and the
                   computer's system time, to UTC. Default is 0.
        :type wait_until_locked: boolean, optional
        :param wait_until_locked: Blocks the execution until the software clock is locked.
                   Throws an exception on locking errors.
                   All locking log messages are filtered while this call is executed. Default: True
        """
        return _TimeTagger.TimeTaggerSource_setReferenceClock(self, *args, **kwargs)

    def disableReferenceClock(self) -> "void":
        r"""Disable the software-defined reference clock."""
        return _TimeTagger.TimeTaggerSource_disableReferenceClock(self)

    def getReferenceClockState(self) -> "ReferenceClockState":
        r"""
        Provides an object representing the current state of the software-defined reference clock.
        This includes the configuration parameters as well as dynamic values generated based on the incoming signal.
        """
        return _TimeTagger.TimeTaggerSource_getReferenceClockState(self)
    __swig_destroy__ = _TimeTagger.delete_TimeTaggerSource

# Register TimeTaggerSource in _TimeTagger:
_TimeTagger.TimeTaggerSource_swigregister(TimeTaggerSource)
class TimeTaggerBase(TimeTaggerSource):
    r"""
    The TimeTaggerBase class defines methods and functionality present in all Time Tagger objects.
    Every :doc:`measurement <Measurements>`} and :doc:`virtual channel <VirtualChannels>`} instance
    requires a reference to a TimeTaggerBase object to associate with.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setSoftwareClock(self, input_channel: "int", input_frequency: "double"=10e6, averaging_periods: "double"=1000, wait_until_locked: "bool"=True) -> "void":
        r"""
        Defines in software one of the input channels as the base clock for all channels.
        This feature sets up a software phase-locked loop (PLL) and rescales
        all incoming time-tags according to the software clock defined.
        The PLL provides a new time base with "ideal clock tags" separated by exactly the defined *clock_period*.
        For measurements, you can use both, rescaled and ideal clock tags.

        While the PLL is not locked, the time base of the instrument is invalid.
        In this case, the time-tag stream changes to the overflow mode.
        This means that after every call to `setSoftwareClock()`,
        you will find overflows because the PLL starts from an unlocked state.

        Warning: 
             It is often useful to apply this feature in combination with `setEventDivider()`
             on the *input_channel*.
             The values of *input_frequency* and *averaging_periods* correspond to the transferred time-tags, not to the
             physical frequency.
             Changing the *divider* independently after setting up the software clock may lead to a failure of the locking
             process.
             Do not add *input_channel* to the list of *filtered* channels in `setConditionalFilter()`.


             For the *Time Tagger 20*, a phase error of 200 ps needs to be considered when using the software clock.

        :type input_channel: int
        :param input_channel: The physical channel that is used as software clock input.
        :type input_frequency: float, optional
        :param input_frequency: The frequency of the software clock after application of `setEventDivider()`
                       (e.g. a 10 MHz clock signal with **divider = 20** has **input_frequency = 500 000**).
                        The value should not deviate from the real frequency by more than a few percent.
                        Default: 10E6, for 10 MHz.
        :type averaging_periods: float, optional
        :param averaging_periods: The number of cycles to average over.
                        The suppression of discretization noise is improved by a higher *averaging_periods*.
                        If the value is too large, however, this will result in increased phase jitter
                        due to the drift of the internal clock or the applied software clock signal.
                        Default: 1000.
        :type wait_until_locked: boolean, optional
        :param wait_until_locked: Blocks the execution until the software clock is locked.
                        Throws an exception on locking errors. All locking log messages are filtered while this call is executed.
                        Default: True.
        """
        return _TimeTagger.TimeTaggerBase_setSoftwareClock(self, input_channel, input_frequency, averaging_periods, wait_until_locked)

    def disableSoftwareClock(self) -> "void":
        r"""
        Disable the software clock.
        Deprecated: use disableReferenceClock
        """
        return _TimeTagger.TimeTaggerBase_disableSoftwareClock(self)

    def getSoftwareClockState(self) -> "SoftwareClockState":
        r"""
        Provides an object representing the current software clock state.
        This includes the configuration parameters as well as dynamic values generated based on the incoming signal.

        :rtype: :py:class:`SoftwareClockState`
        :return: An object that contains the current state of the software clock.
        Deprecated: use getReferenceClock
        """
        return _TimeTagger.TimeTaggerBase_getSoftwareClockState(self)

    def getFence(self, alloc_fence: "bool"=True) -> "unsigned int":
        r"""
        Generate a new fence object, which validates the current configuration and the current time.
        This fence is uploaded to the earliest pipeline stage of the Time Tagger.
        Waiting on this fence ensures that all hardware settings, such as trigger levels, channel
        registrations, etc., have propagated to the FPGA and are physically active. Synchronizes
        the Time Tagger internal memory so that all tags arriving after the `waitForFence()` call were
        actually produced after the `getFence()` call. The `waitForFence()` function waits until
        all tags, which are present at the time of the function call within the internal memory of the Time Tagger, are
        processed. This call might block to limit the number of active fences.

        :type alloc_fence: boolean, optional
        :param alloc_fence: Optional. If False, a reference to the most recently created fence will be returned instead.
            Default: True.
        :rtype: int
        :return: The allocated fence.
        """
        return _TimeTagger.TimeTaggerBase_getFence(self, alloc_fence)

    def __waitForFence(self, fence: "unsigned int", timeout: "int64_t"=-1) -> "bool":
        r"""
        Wait for a fence in the data stream. See `getFence()` for more details.

        :type fence: int
        :param fence: Fence object, which shall be waited on.
        :type timeout: int, optional
        :param timeout: Optional. Timeout in milliseconds. Negative means no timeout, zero returns immediately. Default: -1.
        :rtype: boolean
        :return: True if the fence has passed, false on timeout.
        """
        return _TimeTagger.TimeTaggerBase___waitForFence(self, fence, timeout)

    def __sync(self, timeout: "int64_t"=-1) -> "bool":
        r"""
        Ensures that all hardware settings, such as trigger levels, channel registrations, etc.,
        have propagated to the FPGA and are physically active. Synchronizes the Time Tagger internal memory,
        so that all tags arriving after a sync call were actually produced after the sync call.
        The sync function waits until all tags, which are present at the time of the function call
        within the internal memory of the Time Tagger, are processed.
        It is equivalent to `waitForFence()`.

        The operation of this method on the TimeTaggerNetwork depends on the server access mode.
        If the TimeTaggerNetwork is connected to the Time Tagger server started in
        `AccessMode::Control` or `AccessMode::SynchronousControl`,
        the synchronization will be done all way through the server and the hardware.
        If the Time Tagger server started in `AccessMode::Listen`
        or `AccessMode::SynchronousListen`, the client will be able to synchronize
        only with the server but will not synchronize with the Time Tagger Hardware.
        However, if a USB synchronization fence was created by the server side, the clients will also see it.

        See also:
             * `getFence()`, `waitForFence()`, `TimeTagger::startServer()`, #AccessMode
             * :doc:`/InDepthGuides/PipelineSynchronization`}

        :type timeout: int, optional
        :param timeout: Optional. Timeout in milliseconds. Negative means no timeout, zero returns immediately. Default: -1.
        :rtype: boolean
        :return: True if the synchronization was successful, false on timeout.
        """
        return _TimeTagger.TimeTaggerBase___sync(self, timeout)

    def getInvertedChannel(self, channel: "int") -> "int":
        r"""
        Returns the channel number for the inverted edge of the channel passed in via the channel parameter.
        In case the given channel has no inverted channel, CHANNEL_UNUSED is returned.

        :type channel: int
        :param channel: Channel number.
        :rtype: int
        :return: The inverted channel number.
        """
        return _TimeTagger.TimeTaggerBase_getInvertedChannel(self, channel)

    def isUnusedChannel(self, channel: "int") -> "bool":
        r"""
        Returns true if the passed channel number is CHANNEL_UNUSED.

        :type channel: int
        :param channel: Channel number.
        :rtype: boolean
        :return: True/False.
        """
        return _TimeTagger.TimeTaggerBase_isUnusedChannel(self, channel)

    def getConfiguration(self) -> "std::string":
        r"""
        Returns a JSON formatted string (`dict` in Python)
        containing complete information on the Time Tagger settings.
        It also includes descriptions of measurements and virtual channels created on this Time Tagger instance.

        :rtype: string
        :return: Time Tagger settings and currently existing measurements.
        """
        val = _TimeTagger.TimeTaggerBase_getConfiguration(self)

        val = _json.loads(val)


        return val


    def getRegistrations(self, channel: "int") -> "int":
        r"""
        return the number of registrations for the channel.

        :type channel: int
        :param channel:   the channel
        """
        return _TimeTagger.TimeTaggerBase_getRegistrations(self, channel)

    def isChannelRegistered(self, channel: "int") -> "bool":
        r"""
        return the number of registrations for the channel.

        :type channel: int
        :param channel:   the channel
        """
        return _TimeTagger.TimeTaggerBase_isChannelRegistered(self, channel)

    def xtra_setAutoStart(self, auto_start: "bool") -> "void":
        r"""
        Configures if the new measurements and virtual channels start automatically upon creation.
        This is true by default for all measurements and virtual channels in all TimeTaggers,
        but disabled by default for the `SynchronizedMeasurements::getTagger()` proxy objects.

        Warning: 
        Disabling the auto start of new measurements and virtual channels is not recommended for most of the use cases
        and requires the user to start all the defined measurements and virtual channels in the correct order manually,
        with explicit calls to `IteratorBase::start()` or `IteratorBase::startFor()`,

        :type auto_start: boolean
        :param auto_start: Select whether the auto start of new measurements and virtual channel is enable.
        """
        return _TimeTagger.TimeTaggerBase_xtra_setAutoStart(self, auto_start)

    def xtra_getAutoStart(self) -> "bool":
        r"""
        Returns whether the auto start of new measurements and virtual channels is enabled.
        :rtype: boolean
        :return: The current auto start state of new measurements and virtual channel.
        """
        return _TimeTagger.TimeTaggerBase_xtra_getAutoStart(self)
    __swig_destroy__ = _TimeTagger.delete_TimeTaggerBase

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.this and self.thisown:
            self.__swig_destroy__(self)
            self.thisown = False
            self.this = None
        return False


    def sync(self, timeout=-1):
        r"""sync(self, timeout=-1) -> bool"""
        fence = self.getFence()
        return self.waitForFence(fence, timeout)


    def waitForFence(self, fence, timeout=-1):
        r"""waitForFence(self, fence, timeout=-1) -> bool"""
        return _timeout_handler(lambda t: self.__waitForFence(fence, t), timeout)


# Register TimeTaggerBase in _TimeTagger:
_TimeTagger.TimeTaggerBase_swigregister(TimeTaggerBase)
class TimeTaggerHardware(object):
    r"""
    This class provides the basic methods for configuring TimeTagger hardware, directly via USB or over the
    network.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setTriggerLevel(self, channel: "int", voltage: "double") -> "void":
        r"""
        Set the trigger level of an input channel in Volts.

        :type channel: int
        :param channel:   Physical channel number
        :type voltage: float
        :param voltage:   Trigger level in Volts
        """
        return _TimeTagger.TimeTaggerHardware_setTriggerLevel(self, channel, voltage)

    def getTriggerLevel(self, channel: "int") -> "double":
        r"""
        Returns trigger level for the specified physical channel number.

        :type channel: int
        :param channel: Physical channel number
        :rtype: float
        :return: The applied trigger voltage level in Volts,
            which might differ from the input parameter due to the DAC discretization.
        """
        return _TimeTagger.TimeTaggerHardware_getTriggerLevel(self, channel)

    def getHardwareDelayCompensation(self, channel: "int") -> "long long":
        r"""
        Get the hardware input delay compensation for the given *channel* in picoseconds.
        This compensation can be understood as an implicit part of `TimeTaggerSource::setDelayHardware()`
        and `TimeTaggerSource::setDelaySoftware()`. If your device is able to set an arbitrary delay onboard,
        this applies to the hardware delay compensation as well.

        :type channel: int
        :param channel: Physical channel number
        :rtype: int
        :return: Hardware delay compensation in picoseconds
        """
        return _TimeTagger.TimeTaggerHardware_getHardwareDelayCompensation(self, channel)

    def setHardwareDelayCompensationActive(self, use_compensation: "bool") -> "void":
        r"""
        Activate the hardware delay compensation of a channel

        The physical input delays are calibrated and compensated.
        However this compensation is implemented after the conditional filter and so affects its result.
        This function queries the effective input delay, which compensates the hardware delay.

        :type use_compensation: boolean
        :param use_compensation: set compensation state
        """
        return _TimeTagger.TimeTaggerHardware_setHardwareDelayCompensationActive(self, use_compensation)

    def setInputImpedanceHigh(self, channel: "int", high_impedance: "bool") -> "void":
        r"""
        Notes: Method is only available for the *Time Tagger X*.

        Sets the input impedance to High-Z for the specified *channel*.
        Before createTimeTagger, after `TimeTagger::reset()`, and after freeTimeTagger,
        If not set explicitly to High-Z by setInputImpedanceHigh,
        the input will switch to 50 Ohm by default as soon as the input is used.

        .. code-block:: python

            # Upon initialization, all inputs are in the High-Z state:
            tagger = TimeTagger.createTimeTagger()

            # If you want to keep a channel in High-Z, set it right after initialization:
            tagger.setInputImpedanceHigh(1, True)

            # The Time Tagger will now stay in High-Z on channel 1, channel 2 will switch to 50 Ohm:
            cr = TimeTagger.Countrate(tagger, [1, 2])

        :type channel: int
        :param channel: Physical channel number.
        :type high_impedance: boolean
        :param high_impedance: True/False.
        """
        return _TimeTagger.TimeTaggerHardware_setInputImpedanceHigh(self, channel, high_impedance)

    def getInputImpedanceHigh(self, channel: "int") -> "bool":
        r"""
        Returns whether the input impedance is set to high-Z for the specified *channel*.

        Notes: Method is only available for the *Time Tagger X*.
        :type channel: int
        :param channel: Physical channel number.
        :rtype: boolean
        :return: State of high input impedance.
        """
        return _TimeTagger.TimeTaggerHardware_getInputImpedanceHigh(self, channel)

    def setInputHysteresis(self, channel: "int", value: "int") -> "void":
        r"""
        Sets the input hysteresis value for the specified *channel*.
        Oscillations of the measured signal within the hysteresis range around the trigger value
        are ignored and therefore do not trigger new events.
        Supported values are 1 mV, 20 mV, 70 mV. Default input hysteresis value is 20 mV.

        Notes: Method is only available for the *Time Tagger X*.
        :type channel: int
        :param channel: Physical channel number.
        :type value: int
        :param value: Hysteresis voltage value in mV (1, 20, 70).
        """
        return _TimeTagger.TimeTaggerHardware_setInputHysteresis(self, channel, value)

    def getInputHysteresis(self, channel: "int") -> "int":
        r"""
        Returns the voltage value in mV of the input hysteresis for the specified *channel*.

        Notes: Method is only available for the *Time Tagger X*.
        :type channel: int
        :param channel: Physical channel number.
        :rtype: int
        :return: Hysteresis voltage value in mV.
        """
        return _TimeTagger.TimeTaggerHardware_getInputHysteresis(self, channel)

    def setNormalization(self, channels: "_IntVector", state: "bool") -> "void":
        r"""
        Enables or disables Gaussian normalization of the detection jitter. Enabled by default.

        :type channels: std::vector< int,std::allocator< int > >
        :param channels: List of physical channel numbers.
        :type state: boolean
        :param state: True/False.
        """
        return _TimeTagger.TimeTaggerHardware_setNormalization(self, channels, state)

    def getNormalization(self, channel: "int") -> "bool":
        r"""
        Returns whether the Gaussian normalization of the detection jitter is enabled for the specified channel.

        :type channel: int
        :param channel: The physical channel to query
        :rtype: boolean
        :return: True/False
        """
        return _TimeTagger.TimeTaggerHardware_getNormalization(self, channel)

    def getSerial(self) -> "std::string":
        r"""
        Returns the hardware serial number.
        :rtype: string
        :return: Serial number string.
        """
        return _TimeTagger.TimeTaggerHardware_getSerial(self)

    def getModel(self) -> "std::string":
        r"""
        Returns the model name as string.
        :rtype: string
        :return: Model name as string
        """
        return _TimeTagger.TimeTaggerHardware_getModel(self)

    def getPcbVersion(self) -> "std::string":
        r"""
        Returns Time Tagger PCB (Printed circuit board) version.
        :rtype: string
        :return: PCB version.
        """
        return _TimeTagger.TimeTaggerHardware_getPcbVersion(self)

    def getFirmwareVersion(self) -> "std::string":
        r"""
        Return an unique identifier for the applied firmware.

        This function returns a comma separated list of the firmware version with
        - the device identifier: TT-20 or TT-Ultra
        - the firmware identifier: FW 3
        - optional the timestamp of the assembling of the firmware
        - the firmware identifier of the USB chip: OK 1.30
        eg "TT-Ultra, FW 3, TS 2018-11-13 22:57:32, OK 1.30"
        """
        return _TimeTagger.TimeTaggerHardware_getFirmwareVersion(self)

    def getDACRange(self) -> "std::vector< double,std::allocator< double > >":
        r"""
        Return a vector containing the minimum and the maximum
        DAC (Digital-to-Analog Converter) voltage range for the trigger level.

        Deprecated: Since version 2.18. Please use `getTriggerLevelRange()` instead.
        :rtype: std::vector< double,std::allocator< double > >
        :return: Minimum and maximum voltage, in volts.
        """
        return _TimeTagger.TimeTaggerHardware_getDACRange(self)

    def getTriggerLevelRange(self, channel: "int") -> "std::vector< double,std::allocator< double > >":
        r"""
        Return a vector containing the minimum and the maximum voltage
        range for the trigger level of a given channel.
        :type channel: int
        :param channel: Physical channel number.
        :rtype: std::vector< double,std::allocator< double > >
        :return: Minimum and maximum voltage for the given *channel*, in volts.
        """
        return _TimeTagger.TimeTaggerHardware_getTriggerLevelRange(self, channel)

    def getChannelList(self, *args, **kwargs) -> "std::vector< int,std::allocator< int > >":
        r"""
        Returns a list of channels corresponding to the given *type*.
        :type type: int, optional
        :param type: Limits the returned channels to the specified channel edge type.
        :rtype: std::vector< int,std::allocator< int > >
        :return: List of channel numbers.
        """
        return _TimeTagger.TimeTaggerHardware_getChannelList(self, *args, **kwargs)

    def setHardwareBufferSize(self, size: "int") -> "void":
        r"""
        Sets the maximum buffer size within the Time Tagger.
        The default value is 64 MTags, but can be changed within the range of 32 kTags to 512 MTags.
        Please note that this buffer can only be filled with a total data rate of up to 500 MTags/s.
        See also, :doc:`/InDepthGuides/PipelineSynchronization`}.

        Notes: *Time Tagger 20*uses by default the whole buffer of 8 MTags,
        which can be filled with a total data rate of up to 40 MTags/s.

        :type size: int
        :param size: Buffer size, must be a positive number.
        """
        return _TimeTagger.TimeTaggerHardware_setHardwareBufferSize(self, size)

    def getHardwareBufferSize(self) -> "int":
        r"""
        Returns the maximum buffer size within the Time Tagger.

        :rtype: int
        :return: Maximum hardware buffer size.
        """
        return _TimeTagger.TimeTaggerHardware_getHardwareBufferSize(self)

    def getPsPerClock(self) -> "long long":
        r"""
        Returns the duration of a clock cycle in picoseconds. This is the inverse of the internal clock frequency.
        :rtype: int
        :return: The clock period in picoseconds.
        """
        return _TimeTagger.TimeTaggerHardware_getPsPerClock(self)

    def setStreamBlockSize(self, max_events: "int", max_latency: "int") -> "void":
        r"""
        This option controls the latency and the block size of the data stream.
        Depending on which of the two parameters is exceeded first, the block stream size is adjusted accordingly.

        Notes: The block size will be reduced even further when no new tag arrives within roughly 1-2 s.

        :type max_events: int
        :param max_events:  Maximum number of events within one block (4096 - 32M), default: 1M events
        :type max_latency: int
        :param max_latency: Maximum latency in milliseconds for constant input rates (1 to 10000), default: 20 ms.
        """
        return _TimeTagger.TimeTaggerHardware_setStreamBlockSize(self, max_events, max_latency)

    def getStreamBlockSizeEvents(self) -> "int":
        r"""
        Returns the block size of the data stream. See `setStreamBlockSize()` for further details.

        :rtype: int
        :return: The maximum number of events within one block.
        """
        return _TimeTagger.TimeTaggerHardware_getStreamBlockSizeEvents(self)

    def getStreamBlockSizeLatency(self) -> "int":
        r"""
        Returns the latency of the data stream. See `setStreamBlockSize()` for further details.


        :rtype: int
        :return: The maximum latency in milliseconds.
        """
        return _TimeTagger.TimeTaggerHardware_getStreamBlockSizeLatency(self)

    def setTestSignal(self, *args) -> "void":
        r"""
        *Overload 1:*

        enable/disable internal test signal on a channel.

        This will connect or disconnect the channel with the on-chip uncorrelated signal generator.

        :type channel: int
        :param channel:  the channel.
        :type enabled: boolean
        :param enabled:  enabled / disabled flag.

        |

        *Overload 2:*

        Connects or disconnects the channels with the on-chip uncorrelated signal generator.

        Notes: 
               When used on a TimeTaggerVirtual object, this method activates a Gaussian
               signal generator with a 9 ps RMS jitter, on the specified *channel*.
               *This functionality is primarily for development use and is not intended for general application.*

        :type channel: std::vector< int,std::allocator< int > >
        :param channel:  List of physical channel numbers.
        :type enabled: boolean
        :param enabled:  True/False
        """
        return _TimeTagger.TimeTaggerHardware_setTestSignal(self, *args)

    def getTestSignal(self, channel: "int") -> "bool":
        r"""
        Returns true if the internal test signal is activated on the specified *channel*.

        :type channel: int
        :param channel:   Physical channel number.
        :rtype: boolean
        :return: True/False.
        """
        return _TimeTagger.TimeTaggerHardware_getTestSignal(self, channel)

    def setTestSignalDivider(self, divider: "int") -> "void":
        r"""
        Change the frequency of the on-chip test signal.

        * For the *Time Tagger X*, the base frequency is 333.333 MHz and the default divider 375 corresponds to ~890 kCounts/s.
        * For the *Time Tagger Ultra*, the base frequency is 100.800 MHz and the default divider 126 corresponds to ~800 kCounts/s.
        * For the *Time Tagger 20*, the base frequency is 62.5 MHz and the default divider 74 corresponds to ~850 kCounts/s.

        :type divider: int
        :param divider: Frequency divisor factor.
        """
        return _TimeTagger.TimeTaggerHardware_setTestSignalDivider(self, divider)

    def getTestSignalDivider(self) -> "int":
        r"""
        Returns the value of test signal division factor.
        :rtype: int
        :return: The frequency divisor factor.
        """
        return _TimeTagger.TimeTaggerHardware_getTestSignalDivider(self)

    def getDeviceLicense(self) -> "std::string":
        r"""
        Returns a JSON formatted string (`dict` in Python) containing license information
        of the Time Tagger device, for instance, model, edition, and available channels.

        :rtype: string
        :return: License information.
        """
        val = _TimeTagger.TimeTaggerHardware_getDeviceLicense(self)

        val = _json.loads(val)


        return val


    def getSensorData(self) -> "std::string":
        r"""
        Prints a JSON formatted string (`dict` in Python) containing all available sensor
        data for the given board. The *Time Tagger 20*has no onboard sensors.

        :rtype: string
        :return: Sensor data.
        """
        val = _TimeTagger.TimeTaggerHardware_getSensorData(self)

        val = _json.loads(val)


        return val


    def disableLEDs(self, disabled: "bool") -> "void":
        r"""
        Disables all channel LEDs and back LEDs.

        Notes: This feature currently lacks support for disabling the power LED on the *Time Tagger X*.

        :type disabled: boolean
        :param disabled: True/False.
        """
        return _TimeTagger.TimeTaggerHardware_disableLEDs(self, disabled)

    def setLED(self, bitmask: "uint32_t") -> "void":
        r"""
        Manually change the state of the Time Tagger LEDs.
        The power LED of the *Time Tagger 20*cannot be programmed by software.

        Example:

        .. code-block:: python

            # Turn off all LEDs
            tagger.setLED(0x01FF0000)

            # Restore normal LEDs operation
            tagger.setLED(0)

        * 0 -> LED off
        * 1 -> LED on

        **illumination bits**
        * 0-2: status, rgb - all Time Tagger models
        * 3-5: power, rgb - *Time Tagger Ultra*only
        * 6-8: clock, rgb - *Time Tagger Ultra*only


        * 0 -> normal LED behavior, not overwritten by setLED
        * 1 -> LED state is overwritten by the corresponding bit of 0-8

        **mask bits**
        * 16-18: status, rgb - all Time Tagger models
        * 19-21: power, rgb - *Time Tagger Ultra*only
        * 22-24: clock, rgb - *Time Tagger Ultra*only

        :type bitmask: int
        :param bitmask:: LED bitmask.
        """
        return _TimeTagger.TimeTaggerHardware_setLED(self, bitmask)

    def setSoundFrequency(self, freq_hz: "uint32_t") -> "void":
        r"""
        Set the Time Tagger's internal buzzer to a frequency in Hz.

        :type freq_hz: int
        :param freq_hz: The sound frequency in Hz, use 0 to switch the buzzer off.
        """
        return _TimeTagger.TimeTaggerHardware_setSoundFrequency(self, freq_hz)

    def setTimeTaggerNetworkStreamCompression(self, active: "bool") -> "void":
        r"""
        Enables/disables the compression of TimeTags before they are streamed from the server to the clients.

        Notes: Activation can be helpful for slow network environments (<= 100 MBit/s)
        if the bandwidth is the limiting factor. For instance, the amount of streamed data of periodic signals
        is reduced by about a factor of 2. The compression, on the other hand,
        leads to increased CPU utilization and is not advantageous for fast networks (>= 1 GBit/s).

        :type active: boolean
        :param active: Flag defining whether the compression is enabled (default: False).
        """
        return _TimeTagger.TimeTaggerHardware_setTimeTaggerNetworkStreamCompression(self, active)

    def getChannelNumberScheme(self) -> "int":
        r"""
        Fetch the configured numbering scheme for this TimeTagger object

        Please see setTimeTaggerChannelNumberScheme() for details.
        """
        return _TimeTagger.TimeTaggerHardware_getChannelNumberScheme(self)
    __swig_destroy__ = _TimeTagger.delete_TimeTaggerHardware

# Register TimeTaggerHardware in _TimeTagger:
_TimeTagger.TimeTaggerHardware_swigregister(TimeTaggerHardware)
class TimeTaggerVirtual(TimeTaggerBase):
    r"""
    The TimeTaggerVirtual allows replaying earlier stored time-tag dump files created by the
    FileWriter. Using the virtual Time Tagger, you can repeat your experiment data analysis with different
    parameters or even perform different measurements.

    Here is a minimal code snippet showing how to replay your data setting one measurement:

    .. code-block:: python

        # Initialize the TimeTaggerVirtual by passing the name of the file to the constructor.
        virtual_tagger = TimeTagger.createTimeTaggerVirtual("filename.ttbin")

        # Define all the virtual channels and measurements by passing the TimeTaggerVirtual object
        # to the tagger argument.
        countrate = TimeTagger.Countrate(tagger=virtual_tagger, channels=[1,2])

        # Start the replay of the data using the method run()
        virtual_tagger.run()

        # Wait until all time tags, or the selected chunk of it, are analyzed
        virtual_tagger.waitUntilFinished()

        # Retrieve the data
        data = countrate.getData()

    Notes: 
       The virtual Time Tagger requires a free software license, which is automatically acquired from the
       Swabian Instruments license server when createTimeTagger or createTimeTaggerVirtual is
       called while a Time Tagger is attached. Once received, the license is permanently stored on this PC and the
       Virtual Time Tagger will work without Time Tagger hardware attached.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def run(self, speed: "double"=-1.0) -> "std::vector< uint64_t,std::allocator< uint64_t > >":
        r"""
        Start the replay at given speed factor.
        A value of *speed=1.0* will replay at a real-time rate.
        All *speed* values < 0.0 will replay the data as fast as possible but stops at the end of all data.
        If no file for replay is queued, *speed* < 0.0 is replaced by *speed* = 1.0 for simulations.
        This automatic speed selection is also the default value.
        Extreme slow replay speed between 0.0 and 0.1 is not supported.

        :type speed: float, optional
        :param speed: Replay speed factor.
        :rtype: std::vector< uint64_t,std::allocator< uint64_t > >
        :return: IDs of the queued files.
        """
        return _TimeTagger.TimeTaggerVirtual_run(self, speed)

    def replay(self, file: "std::string const &", begin: "long long"=0, duration: "long long"=-1, queue: "bool"=True) -> "uint64_t":
        r"""
        Deprecated: Since version 2.18. Please use createTimeTaggerVirtual
        and `run()`/`appendFile()` instead.

        Replay a dump file specified by its path *file* or add it to the replay queue.
        If the flag *queue* is false, the current queue will be discarded and file will be replayed immediately.
        The *file* parameter can specify a header file or single specific file as shown in the following example.

        also: :ref:`api-FileWriter`, :ref:`api-FileReader`, and :cpp:func:`mergeStreamFiles`.}

        :type file: string
        :param file: The file to be replayed.
        :type begin: int, optional
        :param begin: Duration in picoseconds to skip at the beginning of the file.
            A negative time will generate a pause in the replay.
        :type duration: int, optional
        :param duration: Duration in picoseconds to be read from the file. *duration=-1* will replay everything.
            (default: -1)
        :type queue: boolean, optional
        :param queue: flag if this file shall be queued. (default: *True)*
        :rtype: int
        :return: ID of the queued file.


        Warning: 
        Replaying data in small chunks is not recommended for long recordings.
        Each `replay()` call reads the file from the beginning
        up to the specified *begin*, even though only the data between
        *begin* and *begin* + *duration* is processed. This leads to significant
        overhead for chunks with higher *begin* values.
        Replaying the whole file at once is more efficient.
        """
        return _TimeTagger.TimeTaggerVirtual_replay(self, file, begin, duration, queue)

    def stop(self) -> "void":
        r"""This method stops the current file and clears the replay queue."""
        return _TimeTagger.TimeTaggerVirtual_stop(self)

    def appendFile(self, filename: "std::string const &", begin: "long long"=0, duration: "long long"=-1, clear: "bool"=False) -> "uint64_t":
        r"""
        Add a new file to the queue of files to be replayed.
        If the file includes channels that are not present in the initial file passed to
        createTimeTaggerVirtual,
        these channels will be ignored during replay and are not accessible by measurements.

        :type filename: string
        :param filename: The name of the file to be replayed.
        :type begin: int, optional
        :param begin: Duration in picoseconds to skip at the beginning of the file.
            A negative time will generate a pause in the replay.
        :type duration: int, optional
        :param duration: Duration in picoseconds to be read from the file.
            *duration=-1* will replay everything. (default: -1)
        :type clear: boolean, optional
        :param clear: If *True*, the current queue is cleared and the given file starts a new queue.
            (default: *False*, i.e. append to existing queue)
        :rtype: int
        :return: ID of the queued file.
        """
        return _TimeTagger.TimeTaggerVirtual_appendFile(self, filename, begin, duration, clear)

    def __waitForCompletion(self, ID: "uint64_t"=0, timeout: "int64_t"=-1) -> "bool":
        r"""
        Deprecated: Since version 2.18. Use Please `waitUntilFinished()` instead.

        Blocks the current thread until the replay is completed.
        """
        return _TimeTagger.TimeTaggerVirtual___waitForCompletion(self, ID, timeout)

    def __waitUntilFinished(self, ID: "uint64_t"=0, timeout: "int64_t"=-1) -> "bool":
        r"""
        Blocks the current thread until the replay is completed.

        This method blocks the current execution and waits until the given file has finished its replay.
        If no ID is provided, it waits until all queued files are replayed.

        This function does not block on a zero timeout. Negative timeouts are interpreted as infinite timeouts.

        Warning: 
           Calling `waitUntilFinished()` on a paused timebase, such as before calling `run()`,
           will block the current thread indefinitely.

        :type ID: int, optional
        :param ID: Selects which file to wait for. (default: 0)
        :type timeout: int, optional
        :param timeout: Timeout in milliseconds.
        :rtype: boolean
        :return: True if the file is complete, false on timeout.
        """
        return _TimeTagger.TimeTaggerVirtual___waitUntilFinished(self, ID, timeout)

    def setReplaySpeed(self, speed: "double") -> "void":
        r"""
        Deprecated: Since version 2.18. Please use `run()` instead.

        Configures the speed factor for the virtual tagger.
        A value of *speed=1.0* will replay at a real-time rate.
        All *speed* values < 0.0 will replay the data as fast as possible but stops at the end of all data.
        This is the default value.
        Extreme slow replay speed between 0.0 and 0.1 is not supported.

        :type speed: float
        :param speed: Replay speed factor.
        """
        return _TimeTagger.TimeTaggerVirtual_setReplaySpeed(self, speed)

    def getReplaySpeed(self) -> "double":
        r"""
        Returns the current speed factor. Please see also `setReplaySpeed()` for more details.

        :rtype: float
        :return: The replay speed factor
        """
        return _TimeTagger.TimeTaggerVirtual_getReplaySpeed(self)

    def reset(self) -> "void":
        r"""
        stops the all queued files and resets the TimeTaggerVirtual to its default settings

        This method stops the current file, clears the replay queue and resets the TimeTaggerVirtual to its default
        settings.
        """
        return _TimeTagger.TimeTaggerVirtual_reset(self)

    def getChannelList(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        Fetches channels from the input file.

        :rtype: std::vector< int,std::allocator< int > >
        :return: a vector of channels from the input file.
        """
        return _TimeTagger.TimeTaggerVirtual_getChannelList(self)

    def setTestSignal(self, *args) -> "void":
        r"""
        *Overload 1:*

        Deprecated: To set a test signal on a TimeTaggerVirtual, use a Signal Generator (see
        `Experimental::SignalGeneratorBase`).


        |

        *Overload 2:*

        Deprecated: To set a test signal on a TimeTaggerVirtual, use a Signal Generator (see
        `Experimental::SignalGeneratorBase`).
        """
        return _TimeTagger.TimeTaggerVirtual_setTestSignal(self, *args)

    def getTestSignal(self, channel: "int") -> "bool":
        r"""
        Deprecated: To set a test signal on a TimeTaggerVirtual, use a Signal Generator (see
        `Experimental::SignalGeneratorBase`).
        """
        return _TimeTagger.TimeTaggerVirtual_getTestSignal(self, channel)

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.this and self.thisown:
            self.__swig_destroy__(self)
            self.thisown = False
            self.this = None
        return False


    def waitForCompletion(self, ID=0, timeout=-1):
        r"""waitForCompletion(self, ID=0, timeout=-1) -> bool"""
        return _timeout_handler(lambda t: self.__waitForCompletion(ID, t), timeout)


    def waitUntilFinished(self, ID=0, timeout=-1):
        r"""waitUntilFinished(self, ID=0, timeout=-1) -> bool"""
        return _timeout_handler(lambda t: self.__waitUntilFinished(ID, t), timeout)

    __swig_destroy__ = _TimeTagger.delete_TimeTaggerVirtual

# Register TimeTaggerVirtual in _TimeTagger:
_TimeTagger.TimeTaggerVirtual_swigregister(TimeTaggerVirtual)
AccessMode_Listen = _TimeTagger.AccessMode_Listen
r"""
    Clients cannot change settings on the Time Tagger and only subscribe to the exposed channels.
    The data-blocks are delivered asynchronously to every client.
    """
AccessMode_SynchronousListen = _TimeTagger.AccessMode_SynchronousListen
r"""
    The same as `AccessMode::Listen` but the data is delivered synchronously to every client.

    Warning: 
    This mode is not recommended for general use.
    The server will attempt to deliver a data-block to every
    connected client before sending the next data-block. Therefore, the data transmission will always be limited by the
    slowest client. If any of the clients cannot handle the data rate fast enough compared to the data-rate produced by
    the Time Tagger hardware, all connected clients will be affected and the Time Tagger hardware buffer may overflow.
    This can happen due to the network speed limit or insufficient CPU speed on any of the connected clients.
    """
AccessMode_Control = _TimeTagger.AccessMode_Control
r"""
    Clients have control over all settings on the Time Tagger.
    The data-blocks are delivered asynchronously to every client.
    """
AccessMode_SynchronousControl = _TimeTagger.AccessMode_SynchronousControl
r"""
    The same as `AccessMode::Control` but the data is delivered synchronously to every client.

    Warning: 
    This mode is not recommended for general use.
    The server will attempt to deliver a data-block to every
    connected client before sending the next data-block. Therefore, the data transmission will always be limited by the
    slowest client. If any of the clients cannot handle the data rate fast enough compared to the data-rate produced by
    the Time Tagger hardware, all connected clients will be affected and the Time Tagger hardware buffer may overflow.
    This can happen due to the network speed limit or insufficient CPU speed on any of the connected clients.
    """
class TimeTaggerServer(TimeTaggerHardware, TimeTaggerSource):
    r"""Control and configure  individual TimeTagger servers via a TimeTaggerNetwork object."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getAddress(self) -> "std::string":
        r"""
        :rtype: string
        :return: the IP address, or hostname, of the server object.
        """
        return _TimeTagger.TimeTaggerServer_getAddress(self)

    def getAccessMode(self) -> "AccessMode":
        r"""
        :rtype: int
        :return: the AccessMode of the underlying TimeTagger server.
        """
        return _TimeTagger.TimeTaggerServer_getAccessMode(self)

    def getClientChannel(self, server_channel: "int") -> "int":
        r"""
        :rtype: int
        :return: the channel number on the `TimeTaggerNetwork` object corresponding to *server_channel*.
        """
        return _TimeTagger.TimeTaggerServer_getClientChannel(self, server_channel)
    __swig_destroy__ = _TimeTagger.delete_TimeTaggerServer

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.this and self.thisown:
            self.__swig_destroy__(self)
            self.thisown = False
            self.this = None
        return False


# Register TimeTaggerServer in _TimeTagger:
_TimeTagger.TimeTaggerServer_swigregister(TimeTaggerServer)
class TimeTaggerNetwork(TimeTaggerBase, TimeTaggerHardware):
    r"""
    The TimeTaggerNetwork represents a client-side of the Network Time Tagger and provides access to the Time
    Tagger server. A server can be created on any physical Time Tagger by calling TimeTagger::startServer.
    The TimeTaggerNetwork object is created by calling `createTimeTaggerNetwork`.

    Notes: 
          Although the TimeTaggerNetwork formally inherits from TimeTaggerBase, almost all methods of
          the hardware TimeTagger are available on the client (except for `TimeTagger::startServer()`
          and `TimeTagger::stopServer()`). These redundant methods are not listed in this section.
          A call to a method that exists on TimeTagger will be forwarded to the server.
          When using the TimeTaggerNetwork with multiple servers, these forwarded method calls are always
          directed to the first connected server. An exception is `TimeTaggerHardware::getChannelList()`,
          which is handled on the client and returns all channels available across all connected servers. To extract
          information or interact with a specific server, use `getServer()` to access
          a TimeTaggerServer object. Some methods on TimeTaggerNetwork offer similar functionality
          to those on the hardware TimeTagger, but are implemented on the client side and can be recognized
          by the suffix *Client*. If the server is running in `AccessMode::Listen` or
          `AccessMode::SynchronousListen` and a method call forwarded to the server would cause setting
          changes on the server-side, the call will raise an exception on the client.
          This scheme of forwarding may lead to unexpected behavior:
          If the server is started in `AccessMode::Listen` or
          `AccessMode::SynchronousListen` with a restricted set of *channels*
          and you call `TimeTaggerHardware::getChannelList()` on the client side, not all channels returned by
          this method can be accessed. You can request the list of accessible channels from the server with
          getTimeTaggerServerInfo.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def isConnected(self) -> "bool":
        r"""
        Check if the Network Time Tagger is currently connected to a server.

        :rtype: boolean
        :return: True/False.
        """
        return _TimeTagger.TimeTaggerNetwork_isConnected(self)

    def setDelayClient(self, channel: "int", time: "long long") -> "void":
        r"""
        Sets an artificial software delay per channel on the client side.
        To specify it on the server side, see `setDelaySoftware()`
        or `setDelayHardware()`. The latter is not available for the *Time Tagger 20*.
        This delay will be applied only on this object and will not affect the server settings or
        delays at any other clients connected to the same Time Tagger server.

        :type channel: int
        :param channel:  The channel number.
        :type time: int
        :param time:     Delay time in picoseconds.
        """
        return _TimeTagger.TimeTaggerNetwork_setDelayClient(self, channel, time)

    def getDelayClient(self, channel: "int") -> "long long":
        r"""
        Returns the value of the delay applied on the client-side in picoseconds for the specified channel.

        :type channel: int
        :param channel:  Channel number.
        :rtype: int
        :return: Input delay in picoseconds.
        """
        return _TimeTagger.TimeTaggerNetwork_getDelayClient(self, channel)

    def getOverflowsClient(self) -> "long long":
        r"""
        If the server is not able to send all the time-tags to the client, e.g. due to limited network bandwidth,
        the time-tag stream switches to the overflow mode.
        This means that the client might experience additional overflow events that are not originating from the hardware.
        This counter counts all missing blocks of time tags occurred in all the hardware devices and on the network since
        the client connection or last call to `clearOverflowsClient()`
        or `getOverflowsAndClearClient()`.

        :rtype: int
        :return: The value of the client-side overflow counter.
        """
        return _TimeTagger.TimeTaggerNetwork_getOverflowsClient(self)

    def getOverflowsAndClearClient(self) -> "long long":
        r"""
        The same as `getOverflowsClient()` but also clears the client-side counter.
        See `getOverflowsClient()` for more information on client-side overflows.
        """
        return _TimeTagger.TimeTaggerNetwork_getOverflowsAndClearClient(self)

    def clearOverflowsClient(self) -> "void":
        r"""
        Clears the overflow counter on the client-side.
        A call to `getOverflows()` will return the information
        as it is available on the server. See `getOverflowsClient()`
        for more information on client-side overflows.
        """
        return _TimeTagger.TimeTaggerNetwork_clearOverflowsClient(self)

    def getServer(self, ip_address: "std::string") -> "TimeTaggerServer":
        r"""
        :type ip_address: string
        :param ip_address: the IP address, or hostname, of the desired TimeTagger server.

        :raises: ValueError
            if *ip_address* does not match an address used in the call to `createTimeTaggerNetwork`.

        :rtype: :py:class:`TimeTaggerServer`
        :return: a `TimeTaggerServer` object, for configuration and control purposes.
        """
        return _TimeTagger.TimeTaggerNetwork_getServer(self, ip_address)

    def getServers(self) -> "list[TimeTaggerServer]":
        r"""
        :rtype: std::vector< std::shared_ptr< TimeTaggerServer >,std::allocator< std::shared_ptr< TimeTaggerServer > > >
        :return: a list of pointers to all `TimeTaggerServer` objects making up the `TimeTaggerNetwork` client.
        """
        return _TimeTagger.TimeTaggerNetwork_getServers(self)

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.this and self.thisown:
            self.__swig_destroy__(self)
            self.thisown = False
            self.this = None
        return False

    __swig_destroy__ = _TimeTagger.delete_TimeTaggerNetwork

# Register TimeTaggerNetwork in _TimeTagger:
_TimeTagger.TimeTaggerNetwork_swigregister(TimeTaggerNetwork)
class TimeTagger(TimeTaggerBase, TimeTaggerHardware):
    r"""
    This class provides access to the hardware and exposes methods to control hardware settings,
    such as trigger levels or even filters.
    Behind the scenes, it opens the USB connection, initializes the device and receives and manages the time-tag-stream.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def reset(self) -> "void":
        r"""Reset the Time Tagger to the start-up state."""
        return _TimeTagger.TimeTagger_reset(self)

    def autoCalibration(self) -> "void":
        r"""
        Runs an auto-calibration of the Time Tagger hardware using the built-in test signal.
        :rtype: void
        :return: The list of jitter of each input channel in picoseconds based on the calibration data.
        """
        return _TimeTagger.TimeTagger_autoCalibration(self)

    def getDistributionCount(self) -> "void":
        r"""
        Returns the calibration data represented in counts.
        :rtype: void
        :return: Calibration data in counts.
        """
        return _TimeTagger.TimeTagger_getDistributionCount(self)

    def getDistributionPSecs(self) -> "void":
        r"""
        Returns the calibration data represented in picoseconds.
        :rtype: void
        :return: Calibration data in picoseconds.
        """
        return _TimeTagger.TimeTagger_getDistributionPSecs(self)

    def enableFpgaLink(self, *args, **kwargs) -> "void":
        r"""
        Enable the FPGA link of the *Time Tagger X*.

        :type channels: std::vector< int,std::allocator< int > >
        :param channels: List of channels, which shall be streamed over the FPGA link.
        :type destination_mac: string
        :param destination_mac: Destination MAC, use an empty string for the broadcast address of "FF:FF:FF:FF:FF:FF".
        :type link_interface: int, optional
        :param link_interface: Selects which interface shall be used, default is `FpgaLinkInterface::SFPP_10GE`.
        :type exclusive: boolean, optional
        :param exclusive: Determines if time tags should exclusively be transmitted over Ethernet, increasing Ethernet
            performance and avoiding USB issues, default is mixed USB and ethernet.
        """
        return _TimeTagger.TimeTagger_enableFpgaLink(self, *args, **kwargs)

    def disableFpgaLink(self) -> "void":
        r"""Disable the FPGA link of the *Time Tagger X*."""
        return _TimeTagger.TimeTagger_disableFpgaLink(self)

    def startServer(self, *args, **kwargs) -> "void":
        r"""
        Start a Time Tagger server that can be accessed via TimeTaggerNetwork.
        The server access mode controls if the clients are allowed to change the hardware parameters.
        See also: #AccessMode.

        :raises: RuntimeError If server is already running.

        :type access_mode: int
        :param access_mode: #AccessMode in which the server should run. Either control or listen.
        :type channels: std::vector< int,std::allocator< int > >, optional
        :param channels:    Channels to be streamed. Used only when `access_mode=AccessMode.Listen` or
            `access_mode=AccessMode.SynchronousListen`.
        :type port: int, optional
        :param port:        Port at which this Time Tagger server will be listening on.
        """
        return _TimeTagger.TimeTagger_startServer(self, *args, **kwargs)

    def stopServer(self) -> "void":
        r"""Stops the Time Tagger server if currently running, otherwise does nothing."""
        return _TimeTagger.TimeTagger_stopServer(self)

    def isServerRunning(self) -> "bool":
        r"""
        Checks if the server is still running.

        :rtype: boolean
        :return: True is server is running and False otherwise.
        """
        return _TimeTagger.TimeTagger_isServerRunning(self)

    def setServerAddress(self, ip_address: "std::string") -> "void":
        r"""
        By default a Time Tagger in server mode will bind to IP address `0.0.0.0`, exposing the server via all
        IPv4 addresses of the local machine. This may be undesirable in the presence of multiple network hardware within
        the same machine. To prevent exposure to multiple networks, the binding IP address may be configured to refer to
        specific network hardware.

        :type ip_address: string
        :param ip_address: The IP address, or hostname.
        """
        return _TimeTagger.TimeTagger_setServerAddress(self, ip_address)

    def getServerAddress(self) -> "std::string":
        r"""
        Gets the IP address, or hostname, to which the Time Tagger server shall bind.

        :rtype: string
        :return: The IP address, or hostname.
        """
        return _TimeTagger.TimeTagger_getServerAddress(self)

    def getConnectedClients(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        Returns the IP addresses and port numbers of the clients currently connected to the Time Tagger server.

        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of IP addresses and port numbers, as strings.
        """
        return _TimeTagger.TimeTagger_getConnectedClients(self)

    def xtra_setAvgRisingFalling(self, channel: "int", enable: "bool") -> "void":
        r"""
        Configures if the rising and falling events shall be averaged.

        This is implemented on the device before any filter like event divider and it
        does not require to transfer both events.

        They need to be manually delayed to be within a window of +-500 ps of error, else events might get lost.
        This method has no side effects on the channel `getInvertedChannel()`, you can still fetch the original
        events there. However if both are configured to return the averaged result, the timestamps will be identical.

        :type channel: int
        :param channel: The channel, on which the average value shall be returned.
        :type enable: boolean
        :param enable:  Select whether the averaging feature is enabled.
        """
        return _TimeTagger.TimeTagger_xtra_setAvgRisingFalling(self, channel, enable)

    def xtra_getAvgRisingFalling(self, channel: "int") -> "bool":
        r"""
        Return the state of the averaging of rising and falling edges.

        :type channel: int
        :param channel: The channel for which the averaging state is returned.
        :rtype: boolean
        :return: The current enable state.
        """
        return _TimeTagger.TimeTagger_xtra_getAvgRisingFalling(self, channel)

    def xtra_setHighPrioChannel(self, channel: "int", enable: "bool") -> "void":
        r"""
        Sets the priority state of a channel. This setting is applied on the hardware before USB transfer.

        If a buffer overflow occurs, channels with high-priority state will interrupt the overflow mode and
        be transmitted as standard time-tags (`Tag::Type::TimeTag`).
        Timing information of low-priority channels is dismissed in overflow mode and only the number of
        counts is transmitted (`Tag::Type::MissedEvents`).
        A typical application of the high-priority channels is CountBetweenMarkers
        with high-priority markers. In this case, the overflow range will be ideally sliced by the markers.

        Warning: Interrupting the overflow mode may break the protection mechanism the overflow mode provides.
        This may lead to irreversible loss of events, not only loss of their timing information.
        High priority should only be assigned to low-countrate channels, e.g. pixel triggers or similar control events.

        :type channel: int
        :param channel: The channel on which the high-priority state shall be enabled.
        :type enable: boolean
        :param enable: Select whether high priority is enabled.
        """
        return _TimeTagger.TimeTagger_xtra_setHighPrioChannel(self, channel, enable)

    def xtra_getHighPrioChannel(self, channel: "int") -> "bool":
        r"""
        Get the priority state of a channel.

        :type channel: int
        :param channel: The channel for which the priority state is returned.
        :rtype: boolean
        :return: The current enable state of the high-priority feature on this channel.
        """
        return _TimeTagger.TimeTagger_xtra_getHighPrioChannel(self, channel)

    def xtra_setAuxOut(self, channel: "int", enabled: "bool") -> "void":
        r"""
        Enables/Disables the Aux Out signal for the specified Aux *channel*.

        :type channel: int
        :param channel: Aux channel number.
        :type enabled: boolean
        :param enabled: True/False.
        """
        return _TimeTagger.TimeTagger_xtra_setAuxOut(self, channel, enabled)

    def xtra_getAuxOut(self, channel: "int") -> "bool":
        r"""
        Returns whether the Aux Out signal is enabled for the specified Aux *channel*.

        :type channel: int
        :param channel: Aux channel number.
        :rtype: boolean
        :return: State of the Aux Out signal.
        """
        return _TimeTagger.TimeTagger_xtra_getAuxOut(self, channel)

    def xtra_setAuxOutSignal(self, channel: "int", divider: "int", duty_cycle: "double"=0.5) -> "void":
        r"""
        Sets the signal shape, i.e., duty cycle and frequency, of the Aux out signal for the specified Aux *channel*.

        :type channel: int
        :param channel: Aux channel number.
        :type divider: int
        :param divider: Divider of the Aux Out base signal frequency (333 MHz).
        :type duty_cycle: float, optional
        :param duty_cycle: The duty cycle of the aux signal.
        """
        return _TimeTagger.TimeTagger_xtra_setAuxOutSignal(self, channel, divider, duty_cycle)

    def xtra_getAuxOutSignalDivider(self, channel: "int") -> "int":
        r"""
        Returns the divider for the frequency of the Aux Out signal generator or the specified Aux *channel*.

        :type channel: int
        :param channel: Aux channel number.
        :rtype: int
        :return: Divider for the frequency of the Aux Out signal generator,
        """
        return _TimeTagger.TimeTagger_xtra_getAuxOutSignalDivider(self, channel)

    def xtra_getAuxOutSignalDutyCycle(self, channel: "int") -> "double":
        r"""
        Returns the duty cycle of the Aux Out signal for the specified Aux *channel*.

        :type channel: int
        :param channel: Aux channel number.
        :rtype: float
        :return: Duty cycle of the Aux Out signal generator.
        """
        return _TimeTagger.TimeTagger_xtra_getAuxOutSignalDutyCycle(self, channel)

    def xtra_measureTriggerLevel(self, channel: "int") -> "double":
        r"""
        Measures and returns the applied voltage threshold of the specified *channel*.

        :type channel: int
        :param channel: Channel number.
        :rtype: float
        :return: Applied voltage threshold of a channel
        """
        return _TimeTagger.TimeTagger_xtra_measureTriggerLevel(self, channel)

    def xtra_setClockSource(self, source: "int") -> "void":
        r"""
        Specifies the different clock sources:
        * 0 - internal clock
        * 1 - external clock 10 Mhz
        * 2 - external clock 500 MHz.

        :type source: int
        :param source: Number of the clock source. Allowed values: 0, 1, 2.
        """
        return _TimeTagger.TimeTagger_xtra_setClockSource(self, source)

    def xtra_getClockSource(self) -> "int":
        r"""
        Returns the used clock source:

        * -1: auto selecting of below options
        * 0: internal clock
        * 1: external 10 MHz
        * 2: external 500 MHz.

        :rtype: int
        :return: Number of the clock source.
        """
        return _TimeTagger.TimeTagger_xtra_getClockSource(self)

    def xtra_setClockAutoSelect(self, enabled: "bool") -> "void":
        r"""
        Enables/Disables the auto clocking function.

        :type enabled: boolean
        :param enabled: True/False.
        """
        return _TimeTagger.TimeTagger_xtra_setClockAutoSelect(self, enabled)

    def xtra_getClockAutoSelect(self) -> "bool":
        r"""
        Returns whether the auto clocking function is enabled.

        :rtype: boolean
        :return: State of auto clocking.
        """
        return _TimeTagger.TimeTagger_xtra_getClockAutoSelect(self)

    def xtra_setClockOut(self, enabled: "bool") -> "void":
        r"""
        Activates/Deactivates the 10 MHz clock output.

        :type enabled: boolean
        :param enabled: True/False.
        """
        return _TimeTagger.TimeTagger_xtra_setClockOut(self, enabled)

    def xtra_setFanSpeed(self, percentage: "double"=-1) -> "void":
        r"""
        configures the FAN speed on TTU HW >= 1.3
        :type percentage: float, optional
        :param percentage: the new speed, 0 means off, 100 means full on, negative means controlled.
        Notes: This setting will get reset on USB errors.
        """
        return _TimeTagger.TimeTagger_xtra_setFanSpeed(self, percentage)

    def setInputMux(self, channel: "int", mux_mode: "int") -> "void":
        r"""
        configures the input multiplexer

        Every physical input channel has an input multiplexer with 4 modes:
        0: normal input mode
        1: use the input from channel -1 (left)
        2: use the input from channel +1 (right)
        3: use the reference oscillator

        Mode 1 and 2 cascades, so many inputs can be configured to get the same input events.

        :type channel: int
        :param channel: the physical channel of the input multiplexer
        :type mux_mode: int
        :param mux_mode: the configuration mode of the input multiplexer
        """
        return _TimeTagger.TimeTagger_setInputMux(self, channel, mux_mode)

    def getInputMux(self, channel: "int") -> "int":
        r"""
        fetches the configuration of the input multiplexer

        :type channel: int
        :param channel: the physical channel of the input multiplexer
        :rtype: int
        :return: the configuration mode of the input multiplexer
        """
        return _TimeTagger.TimeTagger_getInputMux(self, channel)

    def factoryAccess(self, pw: "uint32_t", addr: "uint32_t", data: "uint32_t", mask: "uint32_t", use_wb: "bool"=False) -> "uint32_t":
        r"""
        Direct read/write access to WireIn/WireOuts in FPGA (mask==0 for readonly)

        DO NOT USE. Only for internal debug purposes.
        """
        return _TimeTagger.TimeTagger_factoryAccess(self, pw, addr, data, mask, use_wb)

    def updateBMCFirmware(self, firmware: "std::string const &") -> "void":
        r"""
        updates the firmware of the *Time Tagger X*board management controller

        Notes: The firmware is applied on the next power cycle of the device, *not* on pressing the power button.

        :type firmware: string
        :param firmware: filename of the new firmware on disc
        """
        return _TimeTagger.TimeTagger_updateBMCFirmware(self, firmware)

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.this and self.thisown:
            self.__swig_destroy__(self)
            self.thisown = False
            self.this = None
        return False

    __swig_destroy__ = _TimeTagger.delete_TimeTagger

# Register TimeTagger in _TimeTagger:
_TimeTagger.TimeTagger_swigregister(TimeTagger)
class Tag(object):
    r"""
    a single event on a channel

    Channel events are passed from the backend to registered iterators
    by the IteratorBase::next() callback function.

    A Tag describes a single event on a channel.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Type_TimeTag = _TimeTagger.Tag_Type_TimeTag
    r"""Indicates a standard event corresponding to a detected signal edge."""
    Type_Error = _TimeTagger.Tag_Type_Error
    r"""
    Indicates a hardware or communication-related error condition
    (e.g., plugging an external clock source, invalidating the global time base).
    """
    Type_OverflowBegin = _TimeTagger.Tag_Type_OverflowBegin
    r"""Marks the beginning of an interval with incomplete data because of too high data rates."""
    Type_OverflowEnd = _TimeTagger.Tag_Type_OverflowEnd
    r"""Marks the point where the internal overflow condition ended, resuming normal event tagging."""
    Type_MissedEvents = _TimeTagger.Tag_Type_MissedEvents
    r"""
    A virtual event indicating the number of lost events per channel within an overflow interval.
    This event might be sent repeatedly if the number of lost events is large.
    """
    type: "Tag::Type" = property(_TimeTagger.Tag_type_get, _TimeTagger.Tag_type_set, doc=r"""type""")
    reserved: "char" = property(_TimeTagger.Tag_reserved_get, _TimeTagger.Tag_reserved_set, doc=r"""
    8 bit padding

    Reserved for future use. Set it to zero.
    """)
    missed_events: "unsigned short" = property(_TimeTagger.Tag_missed_events_get, _TimeTagger.Tag_missed_events_set, doc=r"""
    Amount of missed events in overflow mode

    Within overflow intervals, the timing of all events is skipped. However, the total amount of events is still
    recorded. For events with type = MissedEvents, this indicates that a given amount of tags for this channel have
    been skipped in the interval. Note: There might be many missed events tags per overflow interval and channel. The
    accumulated amount represents the total skipped events.
    """)
    channel: "int" = property(_TimeTagger.Tag_channel_get, _TimeTagger.Tag_channel_set, doc=r"""the channel number""")
    time: "long long" = property(_TimeTagger.Tag_time_get, _TimeTagger.Tag_time_set, doc=r"""the timestamp of the event in picoseconds""")

    def __init__(self, *args):
        r"""
        __init__(self) -> Tag
        __init__(self, ts, ch, type=TimeTag) -> Tag
        __init__(self, type, reserved, missed_events, ch, ts) -> Tag
        """
        _TimeTagger.Tag_swiginit(self, _TimeTagger.new_Tag(*args))
    __swig_destroy__ = _TimeTagger.delete_Tag

# Register Tag in _TimeTagger:
_TimeTagger.Tag_swigregister(Tag)
class IteratorBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_IteratorBase

    def clear(self) -> "void":
        r"""
        Discards accumulated measurement data, initializes the data buffer with zero values,
        and resets the state to the initial state.
        """
        return _TimeTagger.IteratorBase_clear(self)

    def start(self) -> "void":
        r"""Starts or continues data acquisition. This method is implicitly called when a measurement object is created."""
        return _TimeTagger.IteratorBase_start(self)

    def startFor(self, capture_duration: "long long", clear: "bool"=True) -> "void":
        r"""
        Starts or continues the data acquisition for the given duration (in ps). After the *duration* time,
        the method `stop()` is called and `isRunning()` will return False.
        Whether the accumulated data is cleared at the beginning of `startFor()`
        is controlled with the second parameter *clear*, which is True by default.

        :type capture_duration: int
        :param capture_duration: Acquisition duration in picoseconds.
        :type clear: boolean, optional
        :param clear: Resets the accumulated data at the beginning (default: True).
        """
        return _TimeTagger.IteratorBase_startFor(self, capture_duration, clear)

    def stop(self) -> "void":
        r"""
        After calling this method, the measurement will stop processing incoming tags.
        Use `start()` or `startFor()` to continue or restart the measurement.
        """
        return _TimeTagger.IteratorBase_stop(self)

    def abort(self) -> "void":
        r"""
        Immediately aborts the measurement, discarding accumulated measurement data, and resets the state to the
        initial state.

        Warning: After calling `abort()`, the last block of data might become irreversibly corrupted.
        Please always use `stop()` to end a measurement.
        """
        return _TimeTagger.IteratorBase_abort(self)

    def isRunning(self) -> "bool":
        r"""
        Returns True if the measurement is collecting the data.
        This method will return False if the measurement was stopped manually by calling `stop()` or
        automatically after calling `startFor()` and the *duration* has passed.

        Notes: All measurements start accumulating data immediately after their creation.
        :rtype: boolean
        :return: True if the measurement is still running.
        """
        return _TimeTagger.IteratorBase_isRunning(self)

    def __waitUntilFinished(self, timeout: "int64_t"=-1) -> "bool":
        r"""
        Blocks the execution until the measurement has finished. Can be used with `startFor()`.
        This is roughly equivalent to a polling loop with sleep().

        .. code-block:: python

            measurement.waitUntilFinished(timeout=-1)
            # is roughly equivalent to
            while measurement.isRunning():
                sleep(0.01)

        :type timeout: int, optional
        :param timeout: Timeout in milliseconds. Negative value means no timeout, zero returns immediately.
        :rtype: boolean
        :return: True if the measurement has finished, False on timeout.
        """
        return _TimeTagger.IteratorBase___waitUntilFinished(self, timeout)

    def getCaptureDuration(self) -> "long long":
        r"""
        Total capture duration since the measurement creation or last call to `clear()`.

        :rtype: int
        :return: Capture duration in ps.
        """
        return _TimeTagger.IteratorBase_getCaptureDuration(self)

    def getConfiguration(self) -> "std::string":
        r"""
        Returns configuration data of the measurement object. The configuration includes the measurement name,
        and the values of the current parameters.
        Information returned by this method is also provided with `TimeTaggerBase::getConfiguration()`.

        :rtype: string
        :return: Configuration data of the measurement object.
        """
        val = _TimeTagger.IteratorBase_getConfiguration(self)

        val = _json.loads(val)


        return val


    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.this and self.thisown:
            self.__swig_destroy__(self)
            self.thisown = False
            self.this = None
        return False


    def waitUntilFinished(self, timeout=-1):
        r"""waitUntilFinished(self, timeout=-1) -> bool"""
        return _timeout_handler(self.__waitUntilFinished, timeout)


# Register IteratorBase in _TimeTagger:
_TimeTagger.IteratorBase_swigregister(IteratorBase)
LanguageUsed_Cpp = _TimeTagger.LanguageUsed_Cpp

LanguageUsed_Python = _TimeTagger.LanguageUsed_Python

LanguageUsed_Csharp = _TimeTagger.LanguageUsed_Csharp

LanguageUsed_Matlab = _TimeTagger.LanguageUsed_Matlab

LanguageUsed_Labview = _TimeTagger.LanguageUsed_Labview

LanguageUsed_Mathematica = _TimeTagger.LanguageUsed_Mathematica

LanguageUsed_Unknown = _TimeTagger.LanguageUsed_Unknown

FrontendType_Undefined = _TimeTagger.FrontendType_Undefined

FrontendType_WebApp = _TimeTagger.FrontendType_WebApp

FrontendType_Firefly = _TimeTagger.FrontendType_Firefly

FrontendType_Pyro5RPC = _TimeTagger.FrontendType_Pyro5RPC

FrontendType_UserFrontend = _TimeTagger.FrontendType_UserFrontend

FrontendType_DLScat = _TimeTagger.FrontendType_DLScat


def setLanguageInfo(pw: "std::uint32_t", language: "LanguageUsed", version: "std::string") -> "void":
    r"""
    sets the language being used currently for usage statistics system.

    :type pw: int
    :param pw:  password for authorization to change the language.
    :type language: int
    :param language:  programming language being used.
    :type version: string
    :param version:  version of the programming language being used.
    """
    return _TimeTagger.setLanguageInfo(pw, language, version)

def setFrontend(frontend: "FrontendType") -> "void":
    r"""
    sets the frontend being used currently for usage statistics system.

    :type frontend: int
    :param frontend:  the frontend currently being used.
    """
    return _TimeTagger.setFrontend(frontend)
UsageStatisticsStatus_Disabled = _TimeTagger.UsageStatisticsStatus_Disabled
r"""Usage statistics collection and upload is disabled."""
UsageStatisticsStatus_Collecting = _TimeTagger.UsageStatisticsStatus_Collecting
r"""
    Enable usage statistics collection local but without automatic uploading.
    This option might be useful to collect usage statistics for debugging purpose.
    """
UsageStatisticsStatus_CollectingAndUploading = _TimeTagger.UsageStatisticsStatus_CollectingAndUploading
r"""Enable usage statistics collection and automatic upload"""

def setUsageStatisticsStatus(new_status: "UsageStatisticsStatus") -> "void":
    r"""
    This function allows a user to override the system-wide default setting on collection and submission of the usage
    statistics data. This function operates within the scope of a current OS user. The system-wide default setting is
    given during the installation of the Time Tagger software. Please run the installer again to allow collection and
    uploading or to disable the usage statistics.

    :type new_status: int
    :param new_status: New status of the usage statistics data collection.
    """
    return _TimeTagger.setUsageStatisticsStatus(new_status)

def getUsageStatisticsStatus() -> "UsageStatisticsStatus":
    r"""
    Get the current status of the usage statistics for the current user.
    The status is described by the UsageStatisticsStatus.

    :rtype: int
    :return: Current status of the usage statistics for the current user.
    """
    return _TimeTagger.getUsageStatisticsStatus()

def getUsageStatisticsReport() -> "std::string":
    r"""
    This function returns the current state of the usage statistics report as a JSON formatted string.
    If there is no report data available or it was submitted just now, the output is a message: **Info: No report data
    available yet**. If you had given your consent earlier and then revoked it, this function will still return
    earlier accumulated report data.

    :rtype: string
    :return: Usage statistics data encoded as JSON string.
    """
    return _TimeTagger.getUsageStatisticsReport()

def mergeStreamFiles(output_filename: "std::string const &", input_filenames: "_StringVector", channel_offsets: "_IntVector", time_offsets: "_LongLongVector", overlap_only: "bool") -> "void":
    r"""
    This function merges a list of time tag stream files into one file.
    The merged stream file can be loaded into the TimeTaggerVirtual for processing.
    The file merging combines streams into one with the possibility of specifying a constant time offset for each input
    stream file.
    Additionally, it is possible to specify channel number offset if the input stream files were recorded from the same
    channel numbers, for instance, using two Time Tagger devices
    The parameters `input_filenames`, `channel_offsets`, and `time_offsets` shall be of equal length.

    This function handles the ``*.ttbin`` files the same way as the `TimeTaggerVirtual::replay()`.

    See also: -FileWriter}, -FileReader}, and -tagger-virtual}.

    Notes: 
          When merging multiple stream files recorded at different times or from different devices,
          you have to be aware of possible time base differences.
          This function does not rescale the data into a common time base as this would
          require additional information and external synchronization signal.
          If you want to improve the synchronicity of the time base between two devices,
          please send the reference clock signal to any of the available inputs of each Time
          Tagger and set up the software clock `TimeTaggerBase::setSoftwareClock()`.

    :type output_filename: string
    :param output_filename:  Filename where to store the merge result ``*.ttbin``.
    :type input_filenames: std::vector< std::string,std::allocator< std::string > >
    :param input_filenames:  List of dump files that will be merged.
    :type channel_offsets: std::vector< int,std::allocator< int > >
    :param channel_offsets:  Channel number offset for each ``*.ttbin`` file. Useful when input files have the same
         channel numbers.
    :type time_offsets: std::vector< long long,std::allocator< long long > >
    :param time_offsets:     Time offset for each ``*.ttbin`` file in picoseconds.
    :type overlap_only: boolean
    :param overlap_only:     If True, then merge only the regions where the time is overlapping.
    """
    return _TimeTagger.mergeStreamFiles(output_filename, input_filenames, channel_offsets, time_offsets, overlap_only)
class ChannelGate(object):
    r"""Proxy of C++ ChannelGate class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        This object defines an evaluation gate that is passed to a measurement class.
        The time-tag stream itself is not modified but sections of the stream can be excluded from the evaluation.
        In contrast to time-tag stream based gating (see GatedChannel),
        this concept allows the measurement class to calculate the correct data normalization.

        :type gate_open_channel: int
        :param gate_open_channel:   Number of the channel that opens the evaluation gate.
        :type gate_close_channel: int
        :param gate_close_channel:  Number of the channel that closes the evaluation gate.
        :type initial: int, optional
        :param initial:             Initial state of the evaluation gate.
        """
        _TimeTagger.ChannelGate_swiginit(self, _TimeTagger.new_ChannelGate(*args, **kwargs))
    gate_open_channel: "int const" = property(_TimeTagger.ChannelGate_gate_open_channel_get, doc=r"""gate_open_channel""")
    gate_close_channel: "int const" = property(_TimeTagger.ChannelGate_gate_close_channel_get, doc=r"""gate_close_channel""")
    initial: "GatedChannelInitial const" = property(_TimeTagger.ChannelGate_initial_get, doc=r"""initial""")
    __swig_destroy__ = _TimeTagger.delete_ChannelGate

# Register ChannelGate in _TimeTagger:
_TimeTagger.ChannelGate_swigregister(ChannelGate)
CoincidenceTimestamp_Last = _TimeTagger.CoincidenceTimestamp_Last
r"""Use the last time-tag to define the timestamp of the coincidence."""
CoincidenceTimestamp_Average = _TimeTagger.CoincidenceTimestamp_Average
r"""Calculate the average timestamp of all time-tags in the coincidence and use it as the timestamp of the coincidence."""
CoincidenceTimestamp_First = _TimeTagger.CoincidenceTimestamp_First
r"""Use the first time-tag to define the timestamp of the coincidence."""
CoincidenceTimestamp_ListedFirst = _TimeTagger.CoincidenceTimestamp_ListedFirst
r"""
    Use the timestamp of the channel at the first position of the list when Coincidence or a group of
    Coincidences is instantiated.
    """
class Coincidences(IteratorBase):
    r"""
    Image: Coincidences.svg

    Detects coincidence clicks on multiple channel groups within a given window.
    If several different coincidences are required with the same window size, `Coincidences` provides
    better performance compared to multiple virtual `Coincidence` channels.
    One object of the `Coincidence` class is limited to 64 unique channels
    in the list of channel groups (*coincidenceGroups)*.

    Example code:

    .. code-block:: python

        from Swabian.TimeTagger import Coincidence, Coincidences, CoincidenceTimestamp, createTimeTagger
        tagger = createTimeTagger()

        coinc = Coincidences(tagger, [[1,2], [2,3,5]], coincidenceWindow=10000, timestamp=CoincidenceTimestamp.ListedFirst)
        coinc_chans = coinc.getChannels()
        coinc1_ch = coinc_chans[0]  # double coincidence in channels [1,2] with timestamp of channel 1
        coinc2_ch = coinc_chans[1]  # triple coincidence in channels [2,3,5] with timestamp of channel 2

        # or equivalent but less performant
        coinc1 = Coincidence(tagger, [1,2], coincidenceWindow=10000, timestamp=CoincidenceTimestamp.ListedFirst)
        coinc2 = Coincidence(tagger, [2,3,5], coincidenceWindow=10000, timestamp=CoincidenceTimestamp.ListedFirst)
        coinc1_ch = coinc1.getChannel()  # double coincidence in channels [1,2] with timestamp of channel 1
        coinc2_ch = coinc2.getChannel()  # triple coincidence in channels [2,3,5] with timestamp of channel 2



    Notes: 
    Only C++ and python support jagged arrays (array of arrays, like uint[][]) which are required to combine
    several coincidence groups and pass them to the constructor of the Coincidences class.
    Hence, the API differs for Matlab, which requires a cell array of 1D vectors to be passed to the constructor
    (see Matlab examples provided with the installer).
    For LabVIEW, a CoincidencesFactory-Class is available to create a Coincidences object,
    which is also shown in the LabVIEW examples provided with the installer).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:               Time Tagger object instance.
        :type coincidenceGroups: std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >
        :param coincidenceGroups:    List of channel groups on which coincidence will be detected in the virtual channel.
        :type coincidenceWindow: int
        :param coincidenceWindow:    Maximum time between all events for a coincidence in picoseconds.
        :type timestamp: int, optional
        :param timestamp:            Type of timestamp for the virtual channel (default: Last).
        """
        _TimeTagger.Coincidences_swiginit(self, _TimeTagger.new_Coincidences(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Coincidences

    def getChannels(self) -> "std::vector< int,std::allocator< int > >":
        r"""getChannels(self) -> _IntVector"""
        return _TimeTagger.Coincidences_getChannels(self)

    def setCoincidenceWindow(self, coincidenceWindow: "long long") -> "void":
        r"""setCoincidenceWindow(self, coincidenceWindow)"""
        return _TimeTagger.Coincidences_setCoincidenceWindow(self, coincidenceWindow)

# Register Coincidences in _TimeTagger:
_TimeTagger.Coincidences_swigregister(Coincidences)
class Coincidence(Coincidences):
    r"""
    Image: Coincidence.svg

    Detects coincidence clicks on two or more channels within a given window.
    Every time a coincidence is detected on the input channels (AND logic),
    `Coincidence` emits a tag on the virtual channel.
    The timestamp assigned to the coincidence on the virtual channel can be set using the parameter *timestamp*.
    By default, the timestamp from the last event received to complete the coincidence is used.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:              Time Tagger object instance.
        :type channels: std::vector< int,std::allocator< int > >
        :param channels:            List of channels on which coincidence will be detected in the virtual channel.
        :type coincidenceWindow: int, optional
        :param coincidenceWindow:   Maximum time between all events for a coincidence in picoseconds (default: 1000).
        :type timestamp: int, optional
        :param timestamp:           Type of timestamp for the virtual channel (default: Last).
        """
        _TimeTagger.Coincidence_swiginit(self, _TimeTagger.new_Coincidence(*args, **kwargs))

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.Coincidence_getChannel(self)
    __swig_destroy__ = _TimeTagger.delete_Coincidence

# Register Coincidence in _TimeTagger:
_TimeTagger.Coincidence_swigregister(Coincidence)
class Combinations(IteratorBase):
    r"""
    Image: Combinations.svg

    A combination is a group of clicks on a set of channels within a given time window. This time
    window is surrounded by two guard windows of the same width. These guard windows do not
    contain any events on the channels being monitored.

    The heralding guard window precedes the first click in the combination. The following guard
    window starts at the time of the last event within the combination window. If there is a click on one
    of the monitored channels within the guard windows, no combination event is generated. A new
    combination window then starts with the next click after an empty guard window.

    Every time a combination is detected on the monitored channels, `Combinations` emits a tag on the
    corresponding virtual channel. The timestamp on this virtual channel is the time of the last event
    included in the combination. Given :math:`N` input channels to be monitored, there will be :math:`2^{N} - 1`
    possible combinations, each having a corresponding virtual channel number.

    In addition, :math:`N` extra virtual channels called *SumChannels* are created.
    This class emits a click on the *n-th* of these channels on each *n-fold* *combination*,
    regardless of the channels that contributed to the combination.
    For instance, this is useful for pseudo-photon-number-resolution with detector arrays.



    Notes: Multiple events on the same channel within one time window are counted as one.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", channels: "_IntVector", window_size: "long long"):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:      Time Tagger object instance.
        :type channels: std::vector< int,std::allocator< int > >
        :param channels:    List of channels on which the combinations will be detected.
        :type window_size: int
        :param window_size: Maximum time between all events to make a combination,
            minimum time without any event detected before and after the combination window, expressed in picoseconds.
        """
        _TimeTagger.Combinations_swiginit(self, _TimeTagger.new_Combinations(tagger, channels, window_size))
    __swig_destroy__ = _TimeTagger.delete_Combinations

    def getChannel(self, input_channels: "_IntVector") -> "int":
        r"""
        Returns the virtual channel number corresponding to the combination formed by the given set of input channels.

        Warning: The `Combinations` class enables the virtual channel corresponding to a specific combination
        of input channels only after an explicit call to `getChannel()`, `getChannels()` or `getChannelByMask()`.
        This is essential to manage computational demands, as the number of possible combinations increases
        exponentially with the number of input channels.

        :type input_channels: std::vector< int,std::allocator< int > >
        :param input_channels: List of channels forming the combination monitored by the returned virtual channel.
        :rtype: int
        :return: Virtual channel number monitoring the combination.
        """
        return _TimeTagger.Combinations_getChannel(self, input_channels)

    def getChannels(self, list_of_input_channel_sets: "_IntVectorVector") -> "std::vector< int,std::allocator< int > >":
        r"""
        Returns a list of virtual channel numbers corresponding to the combinations formed by
        the given list of sets of input channels.
        Warning: This method can quickly increase the computational demands of the `Combinations` class,
        as all returned virtual channels are automatically enabled.

        :type list_of_input_channel_sets: std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >
        :param list_of_input_channel_sets: List of sets of channels forming the combinations monitored
            by the returned virtual channels.
        :rtype: std::vector< int,std::allocator< int > >
        :return: List of virtual channel numbers monitoring the set of combinations.
        """
        return _TimeTagger.Combinations_getChannels(self, list_of_input_channel_sets)

    def getChannelByMask(self, input_mask: "uint32_t") -> "int":
        r"""
        Returns the virtual channel number corresponding to the combination formed by the given set of input channels
        encoded as mask.

        Warning: The `Combinations` class enables the virtual channel corresponding to a specific combination
        of input channels only after an explicit call to `getChannel()`, `getChannels()` or `getChannelByMask()`.
        This is essential to manage computational demands, as the number of possible combinations increases
        exponentially with the number of input channels.

        :type input_mask: int
        :param input_mask: Bitmask of channels forming the combination monitored by the returned virtual channel.
        :rtype: int
        :return: Virtual channel number monitoring the combination.
        """
        return _TimeTagger.Combinations_getChannelByMask(self, input_mask)

    def getCombination(self, virtual_channel: "int") -> "std::vector< int,std::allocator< int > >":
        r"""
        Returns the set of input channels forming a combination event on the given virtual channel *virtual_channel*.

        :type virtual_channel: int
        :param virtual_channel: Virtual channel storing the clicks from the combination formed by the returned channels.
        :rtype: std::vector< int,std::allocator< int > >
        :return: List of channels forming the combination monitored by the input virtual channel.
        """
        return _TimeTagger.Combinations_getCombination(self, virtual_channel)

    def getSumChannel(self, n_channels: "int") -> "int":
        r"""
        Returns the virtual channel number on which an event is generated when any combination of exactly
        *n_channels* clicks is detected within the *window_size*.

        :type n_channels: int
        :param n_channels: Length of the combinations monitored by the returned virtual channel.
        :rtype: int
        :return: Virtual channel number monitoring all combinations of *n_channel* clicks.
        """
        return _TimeTagger.Combinations_getSumChannel(self, n_channels)

# Register Combinations in _TimeTagger:
_TimeTagger.Combinations_swigregister(Combinations)
class Combiner(IteratorBase):
    r"""
    Image: Combiner.svg

    Merges two or more channels into one. Every time an event is detected on any of the input channels (OR logic),
    `Combiner` emits a tag on the corresponding virtual channel.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", channels: "_IntVector"):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:    Time Tagger object instance.
        :type channels: std::vector< int,std::allocator< int > >
        :param channels:  List of channels to be combined into a single virtual channel.
        """
        _TimeTagger.Combiner_swiginit(self, _TimeTagger.new_Combiner(tagger, channels))
    __swig_destroy__ = _TimeTagger.delete_Combiner

    def getChannelCounts(self) -> "void":
        r"""
        get sum of counts

        For reference, this iterators sums up how much ticks are generated because of which input channel.
        So this functions returns an array with one value per input channel.
        """
        return _TimeTagger.Combiner_getChannelCounts(self)

    def getData(self) -> "void":
        r"""
        get sum of counts

        deprecated, use getChannelCounts instead.
        """
        return _TimeTagger.Combiner_getData(self)

    def getChannel(self) -> "int":
        r"""
        the new virtual channel

        This function returns the new allocated virtual channel.
        It can be used now in any new iterator.
        """
        return _TimeTagger.Combiner_getChannel(self)

# Register Combiner in _TimeTagger:
_TimeTagger.Combiner_swigregister(Combiner)
class ConditionalFilterChannel(IteratorBase):
    r"""Proxy of C++ ConditionalFilterChannel class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self, tagger, filter_channels, trigger_channels) -> ConditionalFilterChannel
        __init__(self, tagger, filter_channel, trigger_channels) -> ConditionalFilterChannel
        """
        _TimeTagger.ConditionalFilterChannel_swiginit(self, _TimeTagger.new_ConditionalFilterChannel(*args))
    __swig_destroy__ = _TimeTagger.delete_ConditionalFilterChannel

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.ConditionalFilterChannel_getChannel(self)

    def getChannels(self) -> "std::vector< int,std::allocator< int > >":
        r"""getChannels(self) -> _IntVector"""
        return _TimeTagger.ConditionalFilterChannel_getChannels(self)

# Register ConditionalFilterChannel in _TimeTagger:
_TimeTagger.ConditionalFilterChannel_swigregister(ConditionalFilterChannel)
class ConstantFractionDiscriminator(IteratorBase):
    r"""
    Image: ConstantFractionDiscriminator.svg

    Constant Fraction Discriminator (CFD) detects rising and falling edges of an input pulse and returns
    the average time of both edges. This is useful in situations when precise timing of the pulse position
    is desired for the pulses of varying durations and amplitudes.

    For example, the figure above shows four input pulses separated by 15 nanoseconds.
    The first two pulses have equal widths but different amplitudes, the middle two pulses have equal amplitude
    but different durations, and the last pulse has a duration longer than the *search_window* and is therefore skipped.
    For such input signal, if we measure the time of the rising edges only, we get an error in the pulse positions,
    while with CFD this error is eliminated for symmetric pulses.



    Notes: The virtual CFD requires the time tags of the **rising** and **falling** edge. This leads to:
     - The transferred data of the input channel is twice the regular input rate.
     - When you shift the signal, e.g., via `TimeTaggerBase::setInputDelay()`, you have to shift both edges.
     - When you use the conditional filter, apply the trigger from both channels.
     .
    In addition, you may encounter data rate limitations due the computational complexity of this virtual channel.
    Consider using `TimeTagger::xtra_setAvgRisingFalling()` for similar functionality when the variation between
    pulse durations is small. There, the computations are performed on the Time Tagger hardware instead of on your PC,
    and only half the data rate needs to be transferred for the same result.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", channels: "_IntVector", search_window: "long long"):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:                Time Tagger object instance.
        :type channels: std::vector< int,std::allocator< int > >
        :param channels:              List of channels on which to perform the CFD. Specify rising edges only;
            corresponding falling edges will be registered automatically.
        :type search_window: int
        :param search_window:         Maximum pulse duration, in picoseconds, for detection.
        """
        _TimeTagger.ConstantFractionDiscriminator_swiginit(self, _TimeTagger.new_ConstantFractionDiscriminator(tagger, channels, search_window))
    __swig_destroy__ = _TimeTagger.delete_ConstantFractionDiscriminator

    def getChannels(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        the list of new virtual channels

        This function returns the list of new allocated virtual channels.
        It can be used now in any new measurement class.
        """
        return _TimeTagger.ConstantFractionDiscriminator_getChannels(self)

# Register ConstantFractionDiscriminator in _TimeTagger:
_TimeTagger.ConstantFractionDiscriminator_swigregister(ConstantFractionDiscriminator)
class Correlation(IteratorBase):
    r"""
    Image: Correlation.svg

    Accumulates time differences between clicks on two channels into a histogram, where all clicks are considered both as
    start and stop clicks and both positive and negative time differences are calculated.

    Notes: To perform multiple cross-correlations between any pairs within a set of channels,
    `CorrelationPairs` might offer a better performance.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:        Time tagger object.
        :type channel_1: int
        :param channel_1:     Channel on which (stop) clicks are received.
        :type channel_2: int, optional
        :param channel_2:     Channel on which reference clicks (start) are received (when left empty or set to
            'CHANNEL_UNUSED' -> an auto-correlation measurement is performed,
            which is the same as setting `channel_1 = channel_2`)
            (default: 'CHANNEL_UNUSED').
        :type binwidth: int, optional
        :param binwidth:      Bin width in ps (default: 1000).
        :type n_bins: int, optional
        :param n_bins:        The number of bins in the resulting histogram (default: 1000).
        """
        _TimeTagger.Correlation_swiginit(self, _TimeTagger.new_Correlation(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Correlation

    def getData(self) -> "void":
        r"""
        :rtype: void
        :return: A one-dimensional array of size *n_bins* containing the histogram.
        """
        return _TimeTagger.Correlation_getData(self)

    def getDataNormalized(self) -> "void":
        r"""
        Return the data normalized as:

        .. math::

            g^{(2)}(\tau) = \frac{\Delta{t}}{binwidth(\tau) \cdot N_1 \cdot N_2} \cdot histogram(\tau),
        where :math:`\Delta{t}` is the capture duration, :math:`N_1` and :math:`N_2` are number of events in each channel.

        :rtype: void
        :return: Data normalized by the binwidth and the average count rate.
        """
        return _TimeTagger.Correlation_getDataNormalized(self)

    def getIndex(self) -> "void":
        r"""
        :rtype: void
        :return: A vector of size *n_bins* containing the time bins in ps.
        """
        return _TimeTagger.Correlation_getIndex(self)

# Register Correlation in _TimeTagger:
_TimeTagger.Correlation_swigregister(Correlation)
class CorrelationPairsData(object):
    r"""Proxy of C++ CorrelationPairsData class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_CorrelationPairsData

    def getCounts(self, exclude_self_coincidences: "bool"=True) -> "void":
        r"""
        :type exclude_self_coincidences: boolean, optional
        :param exclude_self_coincidences: Controls if autocorrelation histograms (i == j) exclude
            same-event pairs (a timestamp correlated with itself), removing the :math:`\delta`-like spike at :math:`\tau` = 0
            (default: True).
        :rtype: void
        :return: A three-dimensional array of size *n_channels* x *n_channels* x *n_bins* containing the
            histogram, where *n_channels* is the total number of channels:
              - The first index selects the **start channel**.
              - The second index selects the **stop channel**.
              - The third index runs over the histogram bins.
        """
        return _TimeTagger.CorrelationPairsData_getCounts(self, exclude_self_coincidences)

    def getG2(self, exclude_self_coincidences: "bool"=True) -> "void":
        r"""
        Return the data normalized as:

        .. math::

            g^{(2)}(\tau) = \frac{\Delta{t}}{binwidth(\tau) \cdot N_1 \cdot N_2} \cdot histogram(\tau),
        where :math:`\Delta{t}` is the capture duration, :math:`N_1` and :math:`N_2` are number of events in each channel.

        :type exclude_self_coincidences: boolean, optional
        :param exclude_self_coincidences: Controls if autocorrelation histograms (i == j) exclude
            same-event pairs (a timestamp correlated with itself), removing the :math:`\delta`-like spike at :math:`\tau` = 0
            (default: True).
        :rtype: void
        :return: A three-dimensional array of size *n_channels* x *n_channels* x *n_bins* containing the data
            normalized by the *binwidth* and the average count rate, where *n_channels* is the total number of channels:
              - The first index selects the **start channel**.
              - The second index selects the **stop channel**.
              - The third index runs over the histogram bins.
        """
        return _TimeTagger.CorrelationPairsData_getG2(self, exclude_self_coincidences)

    def getIndex(self) -> "void":
        r"""
        :rtype: void
        :return: A vector of size *n_bins* containing the time bins in ps.
        """
        return _TimeTagger.CorrelationPairsData_getIndex(self)

# Register CorrelationPairsData in _TimeTagger:
_TimeTagger.CorrelationPairsData_swigregister(CorrelationPairsData)
class CorrelationPairs(IteratorBase):
    r"""
    Accumulates time differences between clicks on any pair of channels into a histogram, where all clicks are considered
    both as start and stop clicks and both positive and negative time differences are calculated.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", channels: "_IntVector", binwidth: "long long"=1000, n_bins: "int"=1000):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:        Time tagger object.
        :type channels: std::vector< int,std::allocator< int > >
        :param channels:      List of channels on which reference (start) events and (stop) clicks are received.
        :type binwidth: int, optional
        :param binwidth:      Bin width in ps (default: 1000).
        :type n_bins: int, optional
        :param n_bins:        The number of bins in the resulting histogram per pair of channels (default: 1000).
        """
        _TimeTagger.CorrelationPairs_swiginit(self, _TimeTagger.new_CorrelationPairs(tagger, channels, binwidth, n_bins))
    __swig_destroy__ = _TimeTagger.delete_CorrelationPairs

    def getDataObject(self) -> "CorrelationPairsData":
        r"""
        Returns a `CorrelationPairsData` object containing a snapshot of the data accumulated in the `CorrelationPairs`
        at the time this method is called.
        :rtype: :py:class:`CorrelationPairsData`
        :return: An object providing access to a snapshot data.
        """
        return _TimeTagger.CorrelationPairs_getDataObject(self)

    def getIndex(self) -> "void":
        r"""
        :rtype: void
        :return: A vector of size *n_bins* containing the time bins in ps.
        """
        return _TimeTagger.CorrelationPairs_getIndex(self)

# Register CorrelationPairs in _TimeTagger:
_TimeTagger.CorrelationPairs_swigregister(CorrelationPairs)
class CountBetweenMarkers(IteratorBase):
    r"""
    Image: CountBetweenMarkers.svg

    Counts events on a single channel within the time indicated by a start and stop signals. The bin edges between
    which counts are accumulated are determined by one or more hardware triggers. Specifically, the measurement records
    data into a vector of length *n_values* (initially filled with zeros). It waits for tags on the *begin_channel*.
    When a tag is detected on the *begin_channel* it starts counting tags on the *click_channel*. When the next tag is
    detected on the *begin_channel* it stores the current counter value as the next entry in the data vector,
    resets the counter to zero and starts accumulating counts again.
    If an *end_channel* is specified, the measurement stores the current counter
    value and resets the counter when a tag is detected on the *end_channel* rather than the *begin_channel*.
    You can use this, e.g., to accumulate counts within a gate by using rising edges on one channel as the
    *begin_channel* and falling edges on the same channel as the *end_channel*.
    The accumulation time for each value can be accessed via
    `getBinWidths()`. The measurement stops when all entries in the data vector are filled.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:         Time tagger object.
        :type click_channel: int
        :param click_channel:  Channel on which clicks are received, gated by *begin_channel* and *end_channel*.
        :type begin_channel: int
        :param begin_channel:  Channel that triggers the beginning of counting and stepping to the next value.
        :type end_channel: int, optional
        :param end_channel:    Channel that triggers the end of counting
            (optional, default: 'CHANNEL_UNUSED')
        :type n_values: int, optional
        :param n_values:       Number of values stored (data buffer size) (default: 1000)
        """
        _TimeTagger.CountBetweenMarkers_swiginit(self, _TimeTagger.new_CountBetweenMarkers(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_CountBetweenMarkers

    def getData(self) -> "void":
        r"""
        :rtype: void
        :return: Array of size *n_values* containing the acquired counter values.
        """
        return _TimeTagger.CountBetweenMarkers_getData(self)

    def getIndex(self) -> "void":
        r"""
        :rtype: void
        :return: Vector of size *n_values* containing the time in ps of each start click in respect to
            the very first start click.
        """
        return _TimeTagger.CountBetweenMarkers_getIndex(self)

    def getBinWidths(self) -> "void":
        r"""
        :rtype: void
        :return: Vector of size *n_values* containing the time differences of 'start -> (next start or stop)'
            for the acquired counter values.
        """
        return _TimeTagger.CountBetweenMarkers_getBinWidths(self)

    def ready(self) -> "bool":
        r"""
        :rtype: boolean
        :return: True when the entire array is filled.
        """
        return _TimeTagger.CountBetweenMarkers_ready(self)

# Register CountBetweenMarkers in _TimeTagger:
_TimeTagger.CountBetweenMarkers_swigregister(CountBetweenMarkers)
class CounterData(object):
    r"""
    Objects of this class are created and returned by `Counter::getDataObject()`,
    and contain a snapshot of the data accumulated by the `Counter` measurement.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_CounterData

    def getIndex(self) -> "void":
        r"""
        Returns the relative time of the bins in ps.
        The first entry of the returned vector is always 0 for `size()` > 0.

        :rtype: void
        :return: A vector of size `size()` containing the relative time bins in ps.
        """
        return _TimeTagger.CounterData_getIndex(self)

    def getData(self) -> "void":
        r"""
        :rtype: void
        :return: An array of size **number of channels** by `size()` containing only fully integrated bins.
        """
        return _TimeTagger.CounterData_getData(self)

    def getDataNormalized(self) -> "void":
        r"""
        Does the same as `getData()` but returns the count rate in Hz.
        Bins in overflow mode are marked as *NaN*.

        :rtype: void
        :return: An array of size **number of channels** by `size()` containing the count rate in Hz
            as a float only for fully integrated bins.
        """
        return _TimeTagger.CounterData_getDataNormalized(self)

    def getFrequency(self, *args, **kwargs) -> "void":
        r"""
        Returns the counts normalized to the specified time scale. Bins in overflow mode are marked as *NaN*.

        :type time_scale: int, optional
        :param time_scale: Scales the return value to this time interval.
            Default is 1 s, so the return value is in Hz. For negative values, the time scale is set to *binwidth*.

        :rtype: void
        :return: An array of size **number of channels** by `size()` containing the counts
            normalized to the specified time scale.
        """
        return _TimeTagger.CounterData_getFrequency(self, *args, **kwargs)

    def getDataTotalCounts(self) -> "void":
        r"""
        Returns the total number of events per channel since the last call to `IteratorBase::clear()`,
        excluding the counts of the internal bin where data is currently integrated into.
        This method works correctly even when the USB transfer rate or backend processing capabilities are exceeded.

        :rtype: void
        :return: Number of events per channel.
        """
        return _TimeTagger.CounterData_getDataTotalCounts(self)

    def getTime(self) -> "void":
        r"""
        This is similar to `getIndex()` but it returns the absolute timestamps of the bins.
        For subsequent calls to `Counter::getDataObject`,
        these arrays can be concatenated to obtain a full index array.

        :rtype: void
        :return: A vector of size `size()` containing the time corresponding
            to the return value of `getData()` in ps.
        """
        return _TimeTagger.CounterData_getTime(self)

    def getOverflowMask(self) -> "void":
        r"""
        Array of values for each bin that indicate if an overflow occurred during accumulation of the respective bin.

        :rtype: void
        :return: An array of size `size()` containing overflow mask.
        """
        return _TimeTagger.CounterData_getOverflowMask(self)

    def getChannels(self) -> "void":
        r"""getChannels(self)"""
        return _TimeTagger.CounterData_getChannels(self)
    size: "uint32_t const" = property(_TimeTagger.CounterData_size_get, doc=r"""Number of returned bins.""")
    dropped_bins: "uint32_t const" = property(_TimeTagger.CounterData_dropped_bins_get, doc=r"""Number of bins which have been dropped because *n_values* of the `Counter` measurement has been exceeded.""")
    overflow: "bool const" = property(_TimeTagger.CounterData_overflow_get, doc=r"""Status flag for whether any of the returned bins have been in overflow mode.""")

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.this and self.thisown:
            self.__swig_destroy__(self)
            self.thisown = False
            self.this = None
        return False


# Register CounterData in _TimeTagger:
_TimeTagger.CounterData_swigregister(CounterData)
class Counter(IteratorBase):
    r"""
    Image: Counter.svg

    Time trace of the count rate on one or more channels.
    Specifically, this measurement repeatedly counts tags within a time interval *binwidth*
    and stores the results in a two-dimensional array of size **number of channels** by *n_values*.
    The incoming data is first accumulated in a not-accessible bin.
    When the integration time of this bin has passed, the accumulated data is added to the internal buffer,
    which can be accessed via the *getData...* methods.
    Data stored in the internal circular buffer is overwritten when *n_values* are exceeded. You can prevent this by
    automatically stopping the measurement in time as follows ``counter.startFor(duration=binwidth*n_values)``.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", channels: "_IntVector", binwidth: "long long"=1000000000, n_values: "int32_t"=1):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:       Time tagger object.
        :type channels: std::vector< int,std::allocator< int > >
        :param channels:     Channels used for counting tags.
        :type binwidth: int, optional
        :param binwidth:     Bin width in ps (default: 1e9).
        :type n_values: int, optional
        :param n_values:     Number of bins (default: 1).
        """
        _TimeTagger.Counter_swiginit(self, _TimeTagger.new_Counter(tagger, channels, binwidth, n_values))
    __swig_destroy__ = _TimeTagger.delete_Counter

    def getData(self, rolling: "bool"=True) -> "void":
        r"""
        Returns an array of accumulated counter bins for each channel.
        The optional parameter *rolling*, controls if the not integrated bins are padded before
        or after the integrated bins.

        When ``rolling=True``, the most recent data is stored in the last bin of the array and every
        new completed bin shifts all other bins right-to-left.
        When continuously plotted, this creates an effect of rolling trace plot.
        For instance, it is useful for continuous monitoring of countrate changes over time.

        When ``rolling=False``, the most recent data is stored in the next bin after previous
        such that the array is filled up left-to-right.
        When array becomes full and the Counter is still running, the array index will be reset to zero
        and the array will be filled again overwriting previous values.
        This operation is sometimes called "sweep plotting".

        :type rolling: boolean, optional
        :param rolling: Controls how the counter array is filled (default: True).
        :rtype: void
        :return: An array of size **number of channels** by *n_values* containing the counts
            in each fully integrated bin.
        """
        return _TimeTagger.Counter_getData(self, rolling)

    def getIndex(self) -> "void":
        r"""
        Returns the relative time of the bins in ps. The first entry of the returned vector is always 0.
        :rtype: void
        :return: A vector of size *n_values* containing the time bins in ps.
        """
        return _TimeTagger.Counter_getIndex(self)

    def getDataNormalized(self, rolling: "bool"=True) -> "void":
        r"""
        Does the same as `getData()` but returns the count rate in Hz as a float.
        Not integrated bins and bins in overflow mode are marked as *NaN*.

        :type rolling: boolean, optional
        :param rolling: Controls how the counter array is filled (default: True).
        :rtype: void
        :return: An array of size **number of channels** by *n_values* containing the count rate in Hz as a float
            in each fully integrated bin.
        """
        return _TimeTagger.Counter_getDataNormalized(self, rolling)

    def getDataTotalCounts(self) -> "void":
        r"""
        Returns total number of events per channel since the last call to `clear()`,
        including the currently integrating bin.
        This method works correctly even when the USB transfer rate or backend processing capabilities are exceeded.

        :rtype: void
        :return: Number of events per channel.
        """
        return _TimeTagger.Counter_getDataTotalCounts(self)

    def getDataObject(self, remove: "bool"=False) -> "CounterData":
        r"""
        Returns `CounterData` object containing a snapshot of the data accumulated in the `Counter`
        at the time this method is called.

        :type remove: boolean, optional
        :param remove: Controls if the returned data shall be removed from the internal buffer (default: False).
        :rtype: :py:class:`CounterData`
        :return: A CounterData object providing access to a snapshot data.
        """
        return _TimeTagger.Counter_getDataObject(self, remove)

# Register Counter in _TimeTagger:
_TimeTagger.Counter_swigregister(Counter)
class Countrate(IteratorBase):
    r"""
    Image: Countrate.svg

    Measures the average count rate on one or more channels. Specifically, it
    determines the counts per second on the specified channels starting from the very first tag
    arriving after the instantiation or last call to `clear()` of the measurement.
    The `Countrate` works correctly even when the USB transfer rate or backend processing
    capabilities are exceeded.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", channels: "_IntVector"):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:    Time tagger object instance.
        :type channels: std::vector< int,std::allocator< int > >
        :param channels:  Channels for which the average count rate is measured.
        """
        _TimeTagger.Countrate_swiginit(self, _TimeTagger.new_Countrate(tagger, channels))
    __swig_destroy__ = _TimeTagger.delete_Countrate

    def getData(self) -> "void":
        r"""
        :rtype: void
        :return: Average count rate in counts per second.
        """
        return _TimeTagger.Countrate_getData(self)

    def getCountsTotal(self) -> "void":
        r"""
        :rtype: void
        :return: The total number of events since the instantiation of this object.
        """
        return _TimeTagger.Countrate_getCountsTotal(self)

# Register Countrate in _TimeTagger:
_TimeTagger.Countrate_swigregister(Countrate)
class CustomMeasurementBase(IteratorBase):
    r"""
    Helper class for custom measurements in Python and C#

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase"):
        r"""__init__(self, tagger) -> CustomMeasurementBase"""
        if self.__class__ == CustomMeasurementBase:
            _self = None
        else:
            _self = self
        _TimeTagger.CustomMeasurementBase_swiginit(self, _TimeTagger.new_CustomMeasurementBase(_self, tagger))
    __swig_destroy__ = _TimeTagger.delete_CustomMeasurementBase

    @staticmethod
    def stop_all_custom_measurements() -> "void":
        r"""stop_all_custom_measurements()"""
        return _TimeTagger.CustomMeasurementBase_stop_all_custom_measurements()

    def register_channel(self, channel: "int") -> "void":
        r"""register_channel(self, channel)"""
        return _TimeTagger.CustomMeasurementBase_register_channel(self, channel)

    def unregister_channel(self, channel: "int") -> "void":
        r"""unregister_channel(self, channel)"""
        return _TimeTagger.CustomMeasurementBase_unregister_channel(self, channel)

    def finalize_init(self) -> "void":
        r"""finalize_init(self)"""
        return _TimeTagger.CustomMeasurementBase_finalize_init(self)

    def is_running(self) -> "bool":
        r"""is_running(self) -> bool"""
        return _TimeTagger.CustomMeasurementBase_is_running(self)

    def _lock(self) -> "void":
        r"""_lock(self)"""
        return _TimeTagger.CustomMeasurementBase__lock(self)

    def _unlock(self) -> "void":
        r"""_unlock(self)"""
        return _TimeTagger.CustomMeasurementBase__unlock(self)

    def next_impl(self, incoming_tags: "std::vector< Tag,std::allocator< Tag > > &", begin_time: "long long", end_time: "long long") -> "bool":
        r"""next_impl(self, incoming_tags, begin_time, end_time) -> bool"""
        return _TimeTagger.CustomMeasurementBase_next_impl(self, incoming_tags, begin_time, end_time)

    def next_impl_cs(self, tags_ptr: "void *", num_tags: "uint64_t", begin_time: "long long", end_time: "long long") -> "void":
        r"""next_impl_cs(self, tags_ptr, num_tags, begin_time, end_time)"""
        return _TimeTagger.CustomMeasurementBase_next_impl_cs(self, tags_ptr, num_tags, begin_time, end_time)

    def clear_impl(self) -> "void":
        r"""clear_impl(self)"""
        return _TimeTagger.CustomMeasurementBase_clear_impl(self)

    def on_start(self) -> "void":
        r"""on_start(self)"""
        return _TimeTagger.CustomMeasurementBase_on_start(self)

    def on_stop(self) -> "void":
        r"""on_stop(self)"""
        return _TimeTagger.CustomMeasurementBase_on_stop(self)

    def pre_stop(self) -> "void":
        r"""pre_stop(self)"""
        return _TimeTagger.CustomMeasurementBase_pre_stop(self)
    def __disown__(self):
        self.this.disown()
        _TimeTagger.disown_CustomMeasurementBase(self)
        return weakref.proxy(self)

# Register CustomMeasurementBase in _TimeTagger:
_TimeTagger.CustomMeasurementBase_swigregister(CustomMeasurementBase)
class DelayedChannels(IteratorBase):
    r"""
    Clones multiple input channels, which can be delayed by a time specified with the *delay* parameter in the
    constructor or the `DelayedChannels::setDelay()` method. A negative delay will delay all other events.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", input_channels: "_IntVector", delay: "long long"):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:                Time Tagger object instance.
        :type input_channels: std::vector< int,std::allocator< int > >
        :param input_channels:        Channels to be delayed.
        :type delay: int
        :param delay:                 Time by which the inputs are delayed, expressed in picoseconds.
        """
        _TimeTagger.DelayedChannels_swiginit(self, _TimeTagger.new_DelayedChannels(tagger, input_channels, delay))
    __swig_destroy__ = _TimeTagger.delete_DelayedChannels

    def getChannels(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        the new virtual channels

        This function returns the new allocated virtual channels.
        It can be used now in any new iterator.
        """
        return _TimeTagger.DelayedChannels_getChannels(self)

    def setDelay(self, delay: "long long") -> "void":
        r"""
        Allows modifying the delay time.

        Warning: 
        Calling this method with a reduced delay time may result in a partial loss of the internally buffered time tags.

        :type delay: int
        :param delay: Delay time in picoseconds.
        """
        return _TimeTagger.DelayedChannels_setDelay(self, delay)

# Register DelayedChannels in _TimeTagger:
_TimeTagger.DelayedChannels_swigregister(DelayedChannels)
class DelayedChannel(DelayedChannels):
    r"""
    Image: DelayedChannel.svg

    Clones an input channel, which can be delayed by a time specified with the *delay* parameter in the
    constructor or the `DelayedChannel::setDelay()` method. A negative delay will delay all other events.

    If several different delayed channels are required with the delay, `DelayedChannels` provides
    better performance compared to multiple virtual `DelayedChannel` channels.



    Notes: If you want to set a global delay for one or more input channels, `TimeTaggerBase::setInputDelay()`
    is recommended as long as the delays are small, which means that not more than 100 events on all channels
    should arrive within the maximum delay set.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", input_channel: "int", delay: "long long"):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:                Time Tagger object instance.
        :type input_channel: int
        :param input_channel:         Channel to be delayed.
        :type delay: int
        :param delay:                 Time by which the inputs are delayed, expressed in picoseconds.
        """
        _TimeTagger.DelayedChannel_swiginit(self, _TimeTagger.new_DelayedChannel(tagger, input_channel, delay))

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.DelayedChannel_getChannel(self)
    __swig_destroy__ = _TimeTagger.delete_DelayedChannel

# Register DelayedChannel in _TimeTagger:
_TimeTagger.DelayedChannel_swigregister(DelayedChannel)
class Dump(IteratorBase):
    r"""
    Writes the timetag stream into a file in a simple uncompressed binary format that store timetags
    as 128bit records, see -tag-format}.

    Warning: 
    The files created with this class are not readable by `TimeTaggerVirtual` and `FileReader`.
    For storing time tag data intended for re-reading or postprocessing, use the
    `FileWriter` measurement class instead.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:        Time Tagger object instance.
        :type filename: string
        :param filename:      Name of the output file.
        :type max_tags: int
        :param max_tags:      Stop after this number of tags has been dumped. Negative values will dump forever.
        :type channels: std::vector< int,std::allocator< int > >, optional
        :param channels:      List of channels which are dumped to the file
            (when empty or not passed all active channels are dumped).
        """
        _TimeTagger.Dump_swiginit(self, _TimeTagger.new_Dump(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Dump

# Register Dump in _TimeTagger:
_TimeTagger.Dump_swigregister(Dump)
class EventGenerator(IteratorBase):
    r"""
    Image: EventGenerator.svg

    Emits an arbitrary pattern of timestamps for every trigger event.
    The number of trigger events can be reduced by *trigger_divider*.
    The start of a new pattern does not abort the execution of unfinished patterns, so patterns may overlap.
    The execution of all running patterns can be aborted by a click of the *stop_channel*, i.e. overlapping
    patterns can be avoided by setting the *stop_channel* to the *trigger_channel*.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:          Time Tagger object instance.
        :type trigger_channel: int
        :param trigger_channel: Channel number of the trigger signal.
        :type pattern: std::vector< long long,std::allocator< long long > >
        :param pattern:         List of relative timestamps defining the pattern executed upon a trigger event.
        :type trigger_divider: int, optional
        :param trigger_divider: Factor by which the number of trigger events is reduced (default: 1).
        :type divider_offset: int, optional
        :param divider_offset:  If *trigger_divider* > 1, the *divider_offset* the number of trigger clicks to be ignored
            before emitting the first pattern (default: 0).
        :type stop_channel: int, optional
        :param stop_channel:    Channel number of the stop channel.
        """
        _TimeTagger.EventGenerator_swiginit(self, _TimeTagger.new_EventGenerator(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_EventGenerator

    def getChannel(self) -> "int":
        r"""
        the new virtual channel

        This function returns the new allocated virtual channel.
        It can be used now in any new iterator.
        """
        return _TimeTagger.EventGenerator_getChannel(self)

# Register EventGenerator in _TimeTagger:
_TimeTagger.EventGenerator_swigregister(EventGenerator)
class FileReader(object):
    r"""
    This class allows you to read data files store with `FileReader`.
    The `FileReader` reads a data block of the specified size into a `TimeTagStreamBuffer` object and
    returns this object. The returned data object is exactly the same as returned by the `TimeTagStream` measurement
    and allows you to create a custom data processing algorithms that will work both,
    for reading from a file and for the on-the-fly processing.

    The `FileReader` will automatically recognize if the files were split and read them too one by one.

    Example:

    .. code-block:: python

        # Lets assume we have following files created with the FileWriter
        #  measurement.ttbin     # sequence header file with no data blocks
        #  measurement.1.ttbin   # the first file with data blocks
        #  measurement.2.ttbin
        #  measurement.3.ttbin
        #  measurement.4.ttbin
        #  another_meas.ttbin
        #  another_meas.1.ttbin

        # Read all files in the sequence 'measurement'
        fr = FileReader("measurement.ttbin")

        # Read only the first data file
        fr = FileReader("measurement.1.ttbin")

        # Read only the first two files
        fr = FileReader(["measurement.1.ttbin", "measurement.2.ttbin"])

        # Read the sequence 'measurement' and then the sequence 'another_meas'
        fr = FileReader(["measurement.ttbin", "another_meas.ttbin"])

    See also: -FileWriter}, -tagger-virtual}, and mergeStreamFiles.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        This is the class constructor.
        The `FileReader` automatically continues to read files that were split by the `FileWriter`.

        :type filenames: std::vector< std::string,std::allocator< std::string > >
        :param filenames: Filename(s) of the files to read.

        |

        *Overload 2:*

        Creates a file reader with the given filename.

        The file reader automatically continues to read split FileWriter Streams

        :type filename: string
        :param filename: file to read, must be encoded as UTF-8
        """
        _TimeTagger.FileReader_swiginit(self, _TimeTagger.new_FileReader(*args))
    __swig_destroy__ = _TimeTagger.delete_FileReader

    def getData(self, n_events: "uint64_t") -> "TimeTagStreamBuffer":
        r"""
        Reads the next *n_events* and returns the buffer object with the specified number of timetags.
        The FileReader stores the current location in the data file and guarantees that every timetag is returned once.
        If less than *n_elements* are returned, the reader has reached the end of the last file
        in the file-list *filenames*.
        To check if more data is available for reading, it is more convenient to use `hasData()`.

        :type n_events: int
        :param n_events: Number of timetags to read from the file.
        :rtype: :py:class:`TimeTagStreamBuffer`
        :return: A buffer of size *n_events*.
        """
        return _TimeTagger.FileReader_getData(self, n_events)

    def hasData(self) -> "bool":
        r"""
        :rtype: boolean
        :return: `True` if more data is available for reading,
            `False` if all data has been read from all the files specified in the class constructor.
        """
        return _TimeTagger.FileReader_hasData(self)

    def getConfiguration(self) -> "std::string":
        r"""
        :rtype: string
        :return: A JSON formatted string (`dict` in Python) that contains
            the Time Tagger configuration at the time of file creation.
        """
        val = _TimeTagger.FileReader_getConfiguration(self)

        val = _json.loads(val)


        return val


    def getChannelList(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        :rtype: std::vector< int,std::allocator< int > >
        :return: All channels available within the input file
        """
        return _TimeTagger.FileReader_getChannelList(self)

    def getLastMarker(self) -> "std::string":
        r"""
        :rtype: string
        :return: The last processed marker from the file (see also `FileWriter::setMarker()`).
        """
        return _TimeTagger.FileReader_getLastMarker(self)

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.this and self.thisown:
            self.__swig_destroy__(self)
            self.thisown = False
            self.this = None
        return False


# Register FileReader in _TimeTagger:
_TimeTagger.FileReader_swigregister(FileReader)
class FileWriter(IteratorBase):
    r"""
    Writes the time-tag-stream into a file in a structured binary format with a lossless compression.
    The estimated file size requirements are 2-4 Bytes per time tag, not including the container the data is stored in.
    The continuous background data rate for the container can be modified via `TimeTagger::setStreamBlockSize()`.
    Data is processed in blocks and each block header has a size of 160 Bytes. The default processing latency is 20 ms,
    which means that a block is written every 20 ms resulting in a background data rate of 8 kB/s.
    By increasing the processing latency via
    `TimeTagger::setStreamBlockSize(max_events=524288, max_latency=1000)` to 1 s,
    the resulting data rate for the container is reduced to one 160 B/s.
    The files created with `FileWriter` measurement can be read using `FileReader`
    or loaded into the Virtual Time Tagger.

    Notes: You can use the `Dump` for dumping into a simple uncompressed binary format.
    However, you will not be able to use this file with Virtual Time Tagger or `FileReader`.

    The `FileWriter` is able to split the data into multiple files seamlessly when the file size reaches a maximal size.
    For the file splitting to work properly, the filename specified by the user will be extended with a suffix
    containing sequential counter, so the filenames will look like in the following example:

    .. code-block:: python

        fw = FileWriter(tagger, 'filename.ttbin', [1,2,3]) # Store tags from channels 1,2,3
        # When splitting occurs the files with following names will be created
        #    filename.ttbin     # the sequence header file with no data blocks
        #    filename.1.ttbin   # the first file with data block
        #    filename.2.ttbin
        #    filename.3.ttbin
        #    ...

    In addition, the `FileWriter` will query and store the configuration of the Time Tagger in the same format
    as returned by the `TimeTaggerBase::getConfiguration()` method.
    The configuration is always written into every file.

    See also: -FileReader}, -tagger-virtual}, and mergeStreamFiles.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", filename: "std::string const &", channels: "_IntVector"):
        r"""
        Class constructor. As with all other measurements, the data recording starts immediately after the class
        instantiation unless you initialize the `FileWriter` with a `SynchronizedMeasurements`.

        Notes: Compared to the `Dump` measurement, the `FileWriter` requires explicit specification of the channels.
        If you want to store timetags from all input channels,
        you can query the list of all input channels with `TimeTagger::getChannelList()`.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:        The time tagger object.
        :type filename: string
        :param filename:      Name of the output file.
        :type channels: std::vector< int,std::allocator< int > >
        :param channels:      List of real or virtual channels.
        """
        _TimeTagger.FileWriter_swiginit(self, _TimeTagger.new_FileWriter(tagger, filename, channels))
    __swig_destroy__ = _TimeTagger.delete_FileWriter

    def split(self, *args, **kwargs) -> "void":
        r"""
        Close the current file and create a new one. If the *new_filename* is provided, the data writing
        will continue into the file with the new filename and the sequence counter will be reset to zero.

        You can force the file splitting when you call this method without parameter or
        when the *new_filename* is an empty string.

        :type new_filename: string, optional
        :param new_filename: Filename of the new file. If empty, the old one will be used (default: empty).
        """
        return _TimeTagger.FileWriter_split(self, *args, **kwargs)

    def setMaxFileSize(self, max_file_size: "uint64_t") -> "void":
        r"""
        Set the maximum file size on disk. When this size is exceeded a new file will be automatically created
        to continue recording.

        The actual file size might be larger by one block.

        :type max_file_size: int
        :param max_file_size: Maximum file size in bytes (default: ~1 GByte).
        """
        return _TimeTagger.FileWriter_setMaxFileSize(self, max_file_size)

    def getMaxFileSize(self) -> "uint64_t":
        r"""
        :rtype: int
        :return: The maximal file size in bytes. See also `setMaxFileSize()`.
        """
        return _TimeTagger.FileWriter_getMaxFileSize(self)

    def getTotalEvents(self) -> "uint64_t":
        r"""
        :rtype: int
        :return: The total number of events written into the file(s).
        """
        return _TimeTagger.FileWriter_getTotalEvents(self)

    def getTotalSize(self) -> "uint64_t":
        r"""
        :rtype: int
        :return: The total number of bytes written into the file(s).
        """
        return _TimeTagger.FileWriter_getTotalSize(self)

    def setMarker(self, marker: "std::string const &") -> "void":
        r"""
        Writes a comment into the file. While reading the file using the `FileReader`,
        the last marker can be extracted.

        :type marker: string
        :param marker: An arbitrary marker string to write at the current location in the file.
        """
        return _TimeTagger.FileWriter_setMarker(self, marker)

# Register FileWriter in _TimeTagger:
_TimeTagger.FileWriter_swigregister(FileWriter)
class FlimAbstract(IteratorBase):
    r"""
    This is an interface class for FLIM measurements that defines common
    methods.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_FlimAbstract

    def isAcquiring(self) -> "bool":
        r"""
        Tells if the class is still acquiring data. It can only reach the false state if `stop_after_outputframe > 0`.

        This method is different from `isRunning()`
        and indicates if the specified number of frames is acquired.
        After acquisition completed, it can't be started again.

        :rtype: boolean
        :return: True/False.
        """
        return _TimeTagger.FlimAbstract_isAcquiring(self)

# Register FlimAbstract in _TimeTagger:
_TimeTagger.FlimAbstract_swigregister(FlimAbstract)
class FlimBase(FlimAbstract):
    r"""
    This is a minimal class that acquires a FLIM frame and calls virtual/abstract `frameReady()`
    callback method with the frame data as parameters.
    This class is intended for custom implementations of fast FLIM frame processing with minimal overhead.
    You can reach frame acquisition rates suitable for realtime video observation.

    If you need custom FLIM frame processing implementation while retaining functionality present in the `Flim` class,
    consider subclassing `Flim` instead.

    Warning: When overriding this class, you must set `pre_initialize=False` and then call `initialize()`
    at the end of your custom constructor code. Otherwise, you may experience unstable or erratic behavior
    of your program, as the callback `frameReady()` may be called before construction of the subclass completed.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:                   Time tagger object instance.
        :type start_channel: int
        :param start_channel:            Channel on which start clicks are received for the time differences histogramming.
        :type click_channel: int
        :param click_channel:            Channel on which clicks are received for the time differences histogramming.
        :type pixel_begin_channel: int
        :param pixel_begin_channel:      Start marker of a pixel (histogram).
        :type n_pixels: int
        :param n_pixels:                 Number of pixels (histograms) of one frame.
        :type n_bins: int
        :param n_bins:                   Number of histogram bins for each pixel.
        :type binwidth: int
        :param binwidth:                 Bin size in picoseconds.
        :type pixel_end_channel: int, optional
        :param pixel_end_channel:        End marker of a pixel - incoming clicks on the *click_channel* will be ignored
                                            afterwards (optional, default: 'CHANNEL_UNUSED').
        :type frame_begin_channel: int, optional
        :param frame_begin_channel:      Start the frame, or reset the pixel index
            (optional, default: 'CHANNEL_UNUSED').
        :type finish_after_outputframe: int, optional
        :param finish_after_outputframe: Sets the number of frames stored within the measurement class. After
                                            reaching the number, the measurement will stop. If the number is 0,
                                            one frame is stored and the measurement runs continuously (optional, default: 0).
        :type n_frame_average: int, optional
        :param n_frame_average:          Average multiple input frames into one output frame (default: 1).
        :type pre_initialize: boolean, optional
        :param pre_initialize:           Initializes the measurement on constructing (optional, default: True).
                                            On subclassing, you must set this parameter to False,
                                            and then call `initialize()` at the end of your custom constructor method.
        """
        if self.__class__ == FlimBase:
            _self = None
        else:
            _self = self
        _TimeTagger.FlimBase_swiginit(self, _TimeTagger.new_FlimBase(_self, *args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_FlimBase

    def initialize(self) -> "void":
        r"""
        This function initialized the Flim object and starts execution.
        It does nothing if constructor parameter `pre_initialize==True`.
        """
        return _TimeTagger.FlimBase_initialize(self)

    def frameReady(self, frame_number: "uint32_t", data: "_UIntVector", pixel_begin_times: "_LongLongVector", pixel_end_times: "_LongLongVector", frame_begin_time: "long long", frame_end_time: "long long") -> "void":
        r"""
        The method is called automatically by the Time Tagger engine for each completely acquired frame.
        In its parameters, it provides FLIM frame data and related information.
        You have to override this method with your own implementation.

        Warning: The code of override must be fast, as it is executed in context of Time Tagger processing thread and
          blocks the processing pipeline. Slow override code may lead to the buffer overflows.

        :type frame_number: int
        :param frame_number:      Current frame number.
        :type data: std::vector< uint32_t,std::allocator< uint32_t > >
        :param data:              1D array containing the raw histogram data, with the data of pixel  `i` and time bin `j`
            at index `i * n_bins + j`.
        :type pixel_begin_times: std::vector< long long,std::allocator< long long > >
        :param pixel_begin_times: Start time for each pixel.
        :type pixel_end_times: std::vector< long long,std::allocator< long long > >
        :param pixel_end_times:   End time for each pixel.
        :type frame_begin_time: int
        :param frame_begin_time:  Start time of the frame.
        :type frame_end_time: int
        :param frame_end_time:    End time of the frame.
        """
        return _TimeTagger.FlimBase_frameReady(self, frame_number, data, pixel_begin_times, pixel_end_times, frame_begin_time, frame_end_time)
    def __disown__(self):
        self.this.disown()
        _TimeTagger.disown_FlimBase(self)
        return weakref.proxy(self)

# Register FlimBase in _TimeTagger:
_TimeTagger.FlimBase_swigregister(FlimBase)
class FlimFrameInfo(object):
    r"""
    This is a simple class that contains FLIM frame data and provides convenience accessor methods.
    Notes: Objects of this class are returned by the methods of the |FLIM| classes.
    Normally user will not construct `FlimFrameInfo` objects themselves.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_FlimFrameInfo

    def getFrameNumber(self) -> "int32_t":
        r"""
        :rtype: int
        :return: The frame number, starting from 0 for the very first frame acquired.
            If the index is -1, it is an invalid frame which is returned on error.
        """
        return _TimeTagger.FlimFrameInfo_getFrameNumber(self)

    def isValid(self) -> "bool":
        r"""
        :rtype: boolean
        :return: A boolean which tells if this frame is valid or not. Invalid frames are possible on errors,
            such as requesting the last completed frame when no frame has been completed so far.
        """
        return _TimeTagger.FlimFrameInfo_isValid(self)

    def getPixelPosition(self) -> "uint32_t":
        r"""
        :rtype: int
        :return: A value which tells how many pixels were processed for this frame.
        """
        return _TimeTagger.FlimFrameInfo_getPixelPosition(self)

    def getHistograms(self) -> "void":
        r"""
        :rtype: void
        :return: All histograms of the frame, 2D array with dimensions [n_bins, n_pixels].
        """
        return _TimeTagger.FlimFrameInfo_getHistograms(self)

    def getIntensities(self) -> "void":
        r"""
        :rtype: void
        :return: The summed counts of each histogram divided by the integration time.
        """
        return _TimeTagger.FlimFrameInfo_getIntensities(self)

    def getSummedCounts(self) -> "void":
        r"""The summed counts of each histogram."""
        return _TimeTagger.FlimFrameInfo_getSummedCounts(self)

    def getPixelBegins(self) -> "void":
        r"""An array of the start timestamps of each pixel."""
        return _TimeTagger.FlimFrameInfo_getPixelBegins(self)

    def getPixelEnds(self) -> "void":
        r"""An array of the end timestamps of each pixel."""
        return _TimeTagger.FlimFrameInfo_getPixelEnds(self)
    pixels: "uint32_t" = property(_TimeTagger.FlimFrameInfo_pixels_get, _TimeTagger.FlimFrameInfo_pixels_set, doc=r"""Number of pixels in the frame.""")
    bins: "uint32_t" = property(_TimeTagger.FlimFrameInfo_bins_get, _TimeTagger.FlimFrameInfo_bins_set, doc=r"""Number of bins of each histogram.""")
    frame_number: "int32_t" = property(_TimeTagger.FlimFrameInfo_frame_number_get, _TimeTagger.FlimFrameInfo_frame_number_set, doc=r"""Current frame number.""")
    pixel_position: "uint32_t" = property(_TimeTagger.FlimFrameInfo_pixel_position_get, _TimeTagger.FlimFrameInfo_pixel_position_set, doc=r"""Current pixel position.""")
    valid: "bool" = property(_TimeTagger.FlimFrameInfo_valid_get, _TimeTagger.FlimFrameInfo_valid_set, doc=r"""valid""")

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.this and self.thisown:
            self.__swig_destroy__(self)
            self.thisown = False
            self.this = None
        return False


# Register FlimFrameInfo in _TimeTagger:
_TimeTagger.FlimFrameInfo_swigregister(FlimFrameInfo)
class Flim(FlimAbstract):
    r"""
    High-Level class for implementing FLIM measurements.
    The Flim class includes buffering of images and several analysis methods.

    This class supports expansion of functionality with custom FLIM frame processing
    by overriding virtual/abstract `frameReady()` callback.
    If you need custom implementation with minimal overhead and highest performance,
    consider overriding `FlimBase` class instead.

    Warning: 
    When overriding this class, you must set `pre_initialize=False`
    and then call `initialize()` at the end of your custom constructor code.
    Otherwise, you may experience unstable or erratic behavior of your program,
    as the callback `frameReady()` may be called before construction of the subclass completed.

    The data query methods are organized into a few groups.

    The methods `getCurrentFrame...()` relate to the active frame which is currently being acquired.

    The methods `getReadyFrame...()` relate to the last completely acquired frame.

    The methods `getSummedFrames...()` operate to all frames which have been acquired so far.
    Optional parameter *only_ready_frames* selects if the current incomplete frame shall be included
    or excluded from calculation.

     The methods `get...Ex` instead of an array return a `FlimFrameInfo` object
    containing frame data with additional information collected at the same time instance.

    'See all common methods'
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:                   Time tagger object instance.
        :type start_channel: int
        :param start_channel:            Channel on which start clicks are received for the time differences histogramming.
        :type click_channel: int
        :param click_channel:            Channel on which clicks are received for the time differences histogramming.
        :type pixel_begin_channel: int
        :param pixel_begin_channel:      Start marker of a pixel (histogram).
        :type n_pixels: int
        :param n_pixels:                 Number of pixels (histograms) of one frame.
        :type n_bins: int
        :param n_bins:                   Number of histogram bins for each pixel.
        :type binwidth: int
        :param binwidth:                 Bin size in picoseconds.
        :type pixel_end_channel: int, optional
        :param pixel_end_channel:        End marker of a pixel - incoming clicks on the *click_channel* will be ignored
                                            afterwards (optional, default: 'CHANNEL_UNUSED').
        :type frame_begin_channel: int, optional
        :param frame_begin_channel:      Start the frame, or reset the pixel index
            (optional, default: 'CHANNEL_UNUSED').
        :type finish_after_outputframe: int, optional
        :param finish_after_outputframe: Sets the number of frames stored within the measurement class. After
                                            reaching the number, the measurement will stop. If the number is 0,
                                            one frame is stored and the measurement runs continuously (optional, default: 0).
        :type n_frame_average: int, optional
        :param n_frame_average:          Average multiple input frames into one output frame (default: 1).
        :type pre_initialize: boolean, optional
        :param pre_initialize:           Initializes the measurement on constructing (optional, default: True).
                                            On subclassing, you must set this parameter to False,
                                            and then call `initialize()` at the end of your custom constructor method.
        """
        if self.__class__ == Flim:
            _self = None
        else:
            _self = self
        _TimeTagger.Flim_swiginit(self, _TimeTagger.new_Flim(_self, *args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Flim

    def getCurrentFrame(self) -> "void":
        r"""
        :rtype: void
        :return: The histograms for all pixels of the currently active frame,
            2D array with dimensions [n_bins, n_pixels].
        """
        return _TimeTagger.Flim_getCurrentFrame(self)

    def getCurrentFrameEx(self) -> "FlimFrameInfo":
        r"""
        :rtype: :py:class:`FlimFrameInfo`
        :return: The currently active frame data with additional information collected at the same instance of time.
        """
        return _TimeTagger.Flim_getCurrentFrameEx(self)

    def getCurrentFrameIntensity(self) -> "void":
        r"""
        :rtype: void
        :return: The intensities of all pixels of the currently active frame. The pixel intensity is defined by
            the number of counts acquired within the pixel divided by the respective integration time.
        """
        return _TimeTagger.Flim_getCurrentFrameIntensity(self)

    def getFramesAcquired(self) -> "uint32_t":
        r"""
        :rtype: int
        :return: The number of frames that have been completed so far, since the creation or last clear of the object.
        """
        return _TimeTagger.Flim_getFramesAcquired(self)

    def getIndex(self) -> "void":
        r"""
        :rtype: void
        :return: A vector of size n_bins containing the time bins in ps.
        """
        return _TimeTagger.Flim_getIndex(self)

    def getReadyFrame(self, index: "int32_t"=-1) -> "void":
        r"""
        :type index: int, optional
        :param index:  Index of the frame to be obtained.
            If -1, the last frame which has been completed is returned. (optional, default: -1).
        :rtype: void
        :return: The histograms for all pixels according to the frame index given.
            If *index* is -1, it will return the last frame, which has been completed.
            When *stop_after_outputframe* is 0, the index value must be -1. If `index >= stop_after_outputframe`,
            it will throw an error. 2D array with dimensions [n_bins, n_pixels]
        """
        return _TimeTagger.Flim_getReadyFrame(self, index)

    def getReadyFrameEx(self, index: "int32_t"=-1) -> "FlimFrameInfo":
        r"""
        :type index: int, optional
        :param index:  Index of the frame to be obtained.
            If -1, the last frame which has been completed is returned. (optional, default: -1).
        :rtype: :py:class:`FlimFrameInfo`
        :return: The frame according to the index given. If *index* is -1, it will return the latest completed frame.
            When *stop_after_outputframe* is 0, index must be -1.
            If `index >= stop_after_outputframe`, it will throw an error.
        """
        return _TimeTagger.Flim_getReadyFrameEx(self, index)

    def getReadyFrameIntensity(self, index: "int32_t"=-1) -> "void":
        r"""
        :type index: int, optional
        :param index:  Index of the frame to be obtained.
            If -1, the last frame which has been completed is returned. (optional, default: -1).
        :rtype: void
        :return: The intensities according to the frame index given.
            If *index* is -1, it will return the intensity of the last frame, which has been completed.
            When *stop_after_outputframe* is 0, the index value must be -1.
            If `index >= stop_after_outputframe`, it will throw an error.
            The pixel intensity is defined by the number of counts acquired within the pixel
            divided by the respective integration time.
        """
        return _TimeTagger.Flim_getReadyFrameIntensity(self, index)

    def getSummedFrames(self, only_ready_frames: "bool"=True, clear_summed: "bool"=False) -> "void":
        r"""
        :type only_ready_frames: boolean, optional
        :param only_ready_frames:  If true, only the finished frames are added.
            On false, the currently active frame is aggregated. (optional, default: True).
        :type clear_summed: boolean, optional
        :param clear_summed:       If True, the summed frames memory will be cleared. (optional, default: False).
        :rtype: void
        :return: The histograms for all pixels. The counts within the histograms are integrated since the start
            or the last clear of the measurement.
        """
        return _TimeTagger.Flim_getSummedFrames(self, only_ready_frames, clear_summed)

    def getSummedFramesEx(self, only_ready_frames: "bool"=True, clear_summed: "bool"=False) -> "FlimFrameInfo":
        r"""
        :type only_ready_frames: boolean, optional
        :param only_ready_frames:  If true, only the finished frames are added.
            On false, the currently active frame is aggregated. (optional, default: True).
        :type clear_summed: boolean, optional
        :param clear_summed:       If True, the summed frames memory will be cleared. (optional, default: False).
        :rtype: :py:class:`FlimFrameInfo`
        :return: A sum of all acquired frames with additional information collected at the same instance of time.
        """
        return _TimeTagger.Flim_getSummedFramesEx(self, only_ready_frames, clear_summed)

    def getSummedFramesIntensity(self, only_ready_frames: "bool"=True, clear_summed: "bool"=False) -> "void":
        r"""
        :type only_ready_frames: boolean, optional
        :param only_ready_frames:  If true, only the finished frames are added.
            On false, the currently active frame is aggregated. (optional, default: True).
        :type clear_summed: boolean, optional
        :param clear_summed:       If True, the summed frames memory will be cleared. (optional, default: False).
        :rtype: void
        :return: The intensities of all pixels summed over all acquired frames.
            The pixel intensity is the number of counts within the pixel divided by the integration time.
        """
        return _TimeTagger.Flim_getSummedFramesIntensity(self, only_ready_frames, clear_summed)

    def initialize(self) -> "void":
        r"""
        This function initialized the Flim object and starts execution.
        It does nothing if constructor parameter `pre_initialize==True`.
        """
        return _TimeTagger.Flim_initialize(self)

    def frameReady(self, frame_number: "uint32_t", data: "_UIntVector", pixel_begin_times: "_LongLongVector", pixel_end_times: "_LongLongVector", frame_begin_time: "long long", frame_end_time: "long long") -> "void":
        r"""
        The method is called automatically by the Time Tagger engine for each completely acquired frame.
        In its parameters, it provides FLIM frame data and related information.
        You have to override this method with your own implementation.

        Warning: The code of override must be fast, as it is executed in context of Time Tagger processing thread and
          blocks the processing pipeline. Slow override code may lead to the buffer overflows.

        :type frame_number: int
        :param frame_number:      Current frame number.
        :type data: std::vector< uint32_t,std::allocator< uint32_t > >
        :param data:              1D array containing the raw histogram data, with the data of pixel  `i` and time bin `j`
            at index `i * n_bins + j`.
        :type pixel_begin_times: std::vector< long long,std::allocator< long long > >
        :param pixel_begin_times: Start time for each pixel.
        :type pixel_end_times: std::vector< long long,std::allocator< long long > >
        :param pixel_end_times:   End time for each pixel.
        :type frame_begin_time: int
        :param frame_begin_time:  Start time of the frame.
        :type frame_end_time: int
        :param frame_end_time:    End time of the frame.
        """
        return _TimeTagger.Flim_frameReady(self, frame_number, data, pixel_begin_times, pixel_end_times, frame_begin_time, frame_end_time)
    def __disown__(self):
        self.this.disown()
        _TimeTagger.disown_Flim(self)
        return weakref.proxy(self)

# Register Flim in _TimeTagger:
_TimeTagger.Flim_swigregister(Flim)
class FrequencyCounterData(object):
    r"""Proxy of C++ FrequencyCounterData class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_FrequencyCounterData

    def getIndex(self) -> "void":
        r"""
        Index of the samples. The reference sample would have index 0, counting starts with 1 at the first sampling point.
        :rtype: void
        :return: The index of the samples.
        """
        return _TimeTagger.FrequencyCounterData_getIndex(self)

    def getTime(self) -> "void":
        r"""
        Array of timestamps of the sampling points.
        :rtype: void
        :return: The timestamps of the sampling points.
        """
        return _TimeTagger.FrequencyCounterData_getTime(self)

    def getPeriodsCount(self) -> "void":
        r"""
        The integer part of the phase, i.e. full periods of the oscillation.
        :rtype: void
        :return: Full cycles per channel and sampling point.
        """
        return _TimeTagger.FrequencyCounterData_getPeriodsCount(self)

    def getPeriodsFraction(self) -> "void":
        r"""
        The fraction of the current period at the sampling time.
        Warning: Be careful with adding `getPeriodsCount()` and `getPeriodsFraction()`
        as the required precision can overflow a 64bit double precision within minutes.
        In doubt, please use `getPhase()` with the expected frequency instead.
        :rtype: void
        :return: A fractional value in range [0, 1) per channel and sampling point.
        """
        return _TimeTagger.FrequencyCounterData_getPeriodsFraction(self)

    def getPhase(self, reference_frequency: "double"=0) -> "void":
        r"""
        The relative phase with respect to a numerical reference signal, typically at the expected frequency.
        The reference signal starts at phase *0* at index *0*, so the return value of this method is identical
        to that of `getPeriodsFraction()` for index *0*.

        :type reference_frequency: float, optional
        :param reference_frequency: The reference frequency in Hz to subtract (default: 0.0 Hz).
        :rtype: void
        :return: Relative phase values per channel and sampling point.
        """
        return _TimeTagger.FrequencyCounterData_getPhase(self, reference_frequency)

    def getFrequency(self, *args, **kwargs) -> "void":
        r"""
        The frequency derived from the accumulated phase difference since the last sampling interval.
        At index *0*, there is no previous phase value to compare with,
        so the method returns an undefined value *NaN*.

        :type time_scale: int, optional
        :param time_scale: Scales the return value to this time interval. Default is 1 s, so the return value is in Hz.
            For negative values, the time scale is set to *sampling_interval*.
        :rtype: void
        :return: A frequency value per channel and sampling point.
        """
        return _TimeTagger.FrequencyCounterData_getFrequency(self, *args, **kwargs)

    def getFrequencyInstantaneous(self) -> "void":
        r"""
        The instantaneous frequency with respect to the current fitting window.
        This value corresponds to the slope of the linear fit.

        :rtype: void
        :return: An instantaneous frequency value per channel and sampling point.
        """
        return _TimeTagger.FrequencyCounterData_getFrequencyInstantaneous(self)

    def getOverflowMask(self) -> "void":
        r"""
        If an overflow range overlaps with a fitting window, the values are invalid.
        This mask array indicates invalid elements and can be used to filter the results of the other getters.

        :rtype: void
        :return: 1 indicates that the sampling point was affected by an overflow range, 0 indicates valid data.
        """
        return _TimeTagger.FrequencyCounterData_getOverflowMask(self)
    size: "unsigned int const" = property(_TimeTagger.FrequencyCounterData_size_get, doc=r"""Number of sampling points represented by the object.""")
    overflow_samples: "long long const" = property(_TimeTagger.FrequencyCounterData_overflow_samples_get, doc=r"""Number of sampling points affected by an overflow range since the start of the measurement.""")
    align_to_reference: "bool const" = property(_TimeTagger.FrequencyCounterData_align_to_reference_get, doc=r"""Indicates if the sampling grid has been aligned to the *ReferenceClock*.""")
    sampling_interval: "long long const" = property(_TimeTagger.FrequencyCounterData_sampling_interval_get, doc=r"""The sampling interval in picoseconds.""")
    sample_offset: "long long const" = property(_TimeTagger.FrequencyCounterData_sample_offset_get, doc=r"""Index offset of the first sampling point in the object.""")
    channels_last_dim: "bool const" = property(_TimeTagger.FrequencyCounterData_channels_last_dim_get, doc=r"""
    The memory layout of the output data:
    - If True, the data is stored with channels as the last dimension
      (row-major order for channels).
    - If False, the data is stored with channels as the first dimension
      (column-major order for channels).
    """)

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.this and self.thisown:
            self.__swig_destroy__(self)
            self.thisown = False
            self.this = None
        return False


# Register FrequencyCounterData in _TimeTagger:
_TimeTagger.FrequencyCounterData_swigregister(FrequencyCounterData)
class FrequencyCounter(IteratorBase):
    r"""
    This measurement calculates the frequency and the phase of a periodic signal at evenly spaced sampling times.
    If the *ReferenceClock* is active, the sampling times will automatically align with the
    `ReferenceClockState::ideal_clock_channel`.
    For details on using an external reference via the *ReferenceClock* see the
    :doc:`In Depth Guide: Software-Defined Reference Clock <InDepthGuides/ReferenceClock>`}.

    Multiple channels can be analyzed in parallel to compare the phase evolution in time.
    Around every sampling time, the time tags within an adjustable *fitting_window* are used to fit the phase.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", channels: "_IntVector", sampling_interval: "long long", fitting_window: "long long", n_values: "int32_t"=0):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:              Time Tagger object instance.
        :type channels: std::vector< int,std::allocator< int > >
        :param channels:            List of channels to analyze.
        :type sampling_interval: int
        :param sampling_interval:   The sampling interval in picoseconds. If the *ReferenceClock* is active,
            it is recommended to set this value to an integer multiple of the `ReferenceClockState::clock_period`.
        :type fitting_window: int
        :param fitting_window:      Time tags within this range around a sampling point are fitted for phase calculation.
        :type n_values: int, optional
        :param n_values:            Maximum number of sampling points to store.
        """
        _TimeTagger.FrequencyCounter_swiginit(self, _TimeTagger.new_FrequencyCounter(tagger, channels, sampling_interval, fitting_window, n_values))
    __swig_destroy__ = _TimeTagger.delete_FrequencyCounter

    def getDataObject(self, event_divider: "uint16_t"=1, remove: "bool"=False, channels_last_dim: "bool"=False) -> "FrequencyCounterData":
        r"""
        Returns a `FrequencyCounterData` object containing a snapshot of the data accumulated in the `FrequencyCounter`
        at the time this method is called.
        The *event_divider* argument can be used to scale the results according to the current setting of
        `TimeTagger::setEventDivider()`.
        The *remove* argument allows you to control whether the data should be removed from the internal buffer or not.

        :type event_divider: int, optional
        :param event_divider:       Compensate for the *EventDivider* (default: 1).
        :type remove: boolean, optional
        :param remove:              Control if data is removed from the internal buffer (default: True).
        :type channels_last_dim: boolean, optional
        :param channels_last_dim:   Determines the memory layout of the output data (default: False).
                                         - If true, data is stored with channels as the last dimension
                                         (row-major order for channels).
                                         - If false, data is stored with channels as the first dimension
                                         (column-major order for channels).
        :rtype: :py:class:`FrequencyCounterData`
        :return: An object providing access to a snapshot data.
        """
        return _TimeTagger.FrequencyCounter_getDataObject(self, event_divider, remove, channels_last_dim)

# Register FrequencyCounter in _TimeTagger:
_TimeTagger.FrequencyCounter_swigregister(FrequencyCounter)
class FrequencyMultiplier(IteratorBase):
    r"""
    Image: FrequencyMultiplier.svg

    The `FrequencyMultiplier` inserts copies of the original input events from the *input_channel*
    and adds additional events to match the upscaling factor.
    The algorithm used assumes a constant frequency and calculates out of
    the last two incoming events the intermediate time stamps to match the frequency given
    by the *multiplier* parameter.

    The `FrequencyMultiplier` can be used to restore the actual frequency applied to an *input_channel*
    which was reduces via the 'EventDivider' to lower the effective data rate.



    Warning: 
    Very high output frequencies create a high CPU load,
    eventually leading to <hw-overflows>}.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", input_channel: "int", multiplier: "int32_t"):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:                Time Tagger object instance.
        :type input_channel: int
        :param input_channel:         Channel on which the upscaling of the frequency is based on.
        :type multiplier: int
        :param multiplier:            Frequency upscaling factor.
        """
        _TimeTagger.FrequencyMultiplier_swiginit(self, _TimeTagger.new_FrequencyMultiplier(tagger, input_channel, multiplier))
    __swig_destroy__ = _TimeTagger.delete_FrequencyMultiplier

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.FrequencyMultiplier_getChannel(self)

    def getMultiplier(self) -> "int32_t":
        r"""getMultiplier(self) -> int32_t"""
        return _TimeTagger.FrequencyMultiplier_getMultiplier(self)

# Register FrequencyMultiplier in _TimeTagger:
_TimeTagger.FrequencyMultiplier_swigregister(FrequencyMultiplier)
class FrequencyStabilityData(object):
    r"""Proxy of C++ FrequencyStabilityData class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_FrequencyStabilityData

    def getTau(self) -> "void":
        r"""
        The :math:`\tau` axis for all deviations. This is the product of the *steps* parameter of the
        `FrequencyStability` measurement and the measured average period of the signal.

        :rtype: void
        :return: The :math:`\tau` values.
        """
        return _TimeTagger.FrequencyStabilityData_getTau(self)

    def getADEV(self) -> "void":
        r"""
        The overlapping Allan deviation, the most common analysis framework.
        In a log-log plot, the slope allows one to identify the type of noise:
        - -1: white or flicker phase noise like discretization or analog noisy delay
        - -0.5: white period noise
        - 0: flicker period noise like electric noisy oscillator
        - 0.5: integrated white period noise (random walk period)
        - 1: frequency drift, e.g., induced thermally.


        :rtype: void
        :return: The overlapping Allan Deviation.
        """
        return _TimeTagger.FrequencyStabilityData_getADEV(self)

    def getMDEV(self) -> "void":
        r"""
        Modified overlapping Allan deviation. It averages the second derivate before calculating the RMS.
        This splits the slope of white and flicker phase noise:
        - -1.5: white phase noise, like discretization
        - -1.0: flicker phase noise, like an electric noisy delay.

        The metric is more commonly used in the time domain, see `getTDEV()`:

        :rtype: void
        :return: The overlapping MDEV.
        """
        return _TimeTagger.FrequencyStabilityData_getMDEV(self)

    def getHDEV(self) -> "void":
        r"""
        The overlapping Hadamard deviation uses the third derivate of the phase. This cancels the effect
        of a constant phase drift and converges for more divergent noise sources at higher slopes:

        - 1: integrated flicker period noise (flicker walk period)
        - 1.5: double integrated white period noise (random run period).

        It is scaled to match the ADEV for white period noise.

        :rtype: void
        :return: The overlapping HDEV.
        """
        return _TimeTagger.FrequencyStabilityData_getHDEV(self)

    def getSTDD(self) -> "void":
        r"""
        Standard deviation of the periods.
        Warning: The standard deviation is not recommended as a measure of frequency stability because
        it is non-convergent for some types of noise commonly found in frequency sources,
        most noticeable the frequency drift.


        :rtype: void
        :return: The standard deviation.
        """
        return _TimeTagger.FrequencyStabilityData_getSTDD(self)

    def getADEVScaled(self) -> "void":
        r"""
        :rtype: void
        :return: The scaled version of the overlapping Allan Deviation, equivalent to
            `getADEV()` * `getTau()` / :math:`\sqrt{3}`.
        """
        return _TimeTagger.FrequencyStabilityData_getADEVScaled(self)

    def getTDEV(self) -> "void":
        r"""
        The Time Deviation (TDEV) is the common representation of the Modified overlapping Allan deviation
        `getMDEV()`.
        Taking the log-log slope +1 and the splitting of the slope of white and flicker phase noise into account,
        it allows an easy identification of the two contributions:
        - -0.5: white phase noise, like discretization
        - 0: flicker phase noise, like an electric noisy delay.


        :rtype: void
        :return: The overlapping Time Deviation, equivalent to `getMDEV()`*
            `getTau()` / :math:`\sqrt{3}`.
        """
        return _TimeTagger.FrequencyStabilityData_getTDEV(self)

    def getHDEVScaled(self) -> "void":
        r"""
        Warning: While HDEV is scaled to match ADEV for white period noise,
        this function is scaled to match the TDEV for white phase noise.
        The difference of period vs phase matching is roughly 5% and easy to overlook.


        :rtype: void
        :return: The scaled version of the overlapping Hadamard Deviation,
            equivalent to `getHDEV()` *
            `getTau()` / :math:`\sqrt{10 / 3}`.
        """
        return _TimeTagger.FrequencyStabilityData_getHDEVScaled(self)

    def getTraceIndex(self) -> "void":
        r"""
        The time axis for `getTracePhase()` and
        `getTraceFrequency()`.
        :rtype: void
        :return: The time index in seconds of the phase and frequency error trace.
        """
        return _TimeTagger.FrequencyStabilityData_getTraceIndex(self)

    def getTracePhase(self) -> "void":
        r"""
        Provides the time offset of the averaged timestamps from a linear fit over
        the last *trace_len* averaged timestamps.
        :rtype: void
        :return: A trace of the last *trace_len* phase samples in seconds.
        """
        return _TimeTagger.FrequencyStabilityData_getTracePhase(self)

    def getTraceFrequency(self) -> "void":
        r"""
        Provides the relative frequency offset from the average frequency
        during the last *trace_len* + 1 averaged timestamps.
        :rtype: void
        :return: A trace of the last *trace_len* normalized frequency error data points in pp1.
        """
        return _TimeTagger.FrequencyStabilityData_getTraceFrequency(self)

    def getTraceFrequencyAbsolute(self, input_frequency: "double"=0.0) -> "void":
        r"""
        Provides the absolute frequency offset from a given *input_frequency*
        during the last *trace_len* + 1 averaged timestamps.

        :type input_frequency: float, optional
        :param input_frequency: Nominal frequency of the periodic signal (default: 0 Hz).
        :rtype: void
        :return: A trace of the last *trace_len* frequency data points in Hz.
        """
        return _TimeTagger.FrequencyStabilityData_getTraceFrequencyAbsolute(self, input_frequency)

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.this and self.thisown:
            self.__swig_destroy__(self)
            self.thisown = False
            self.this = None
        return False


# Register FrequencyStabilityData in _TimeTagger:
_TimeTagger.FrequencyStabilityData_swigregister(FrequencyStabilityData)
class FrequencyStability(IteratorBase):
    r"""
    Frequency Stability Analysis is used to characterize periodic signals and to identify sources
    of deviations from the perfect periodicity.
    It can be employed to evaluate the frequency stability of oscillators, for example.
    When the Time Taggers internal clock stability falls short of requirements,
    locking to a stable external reference is recommended.
    This can be achieved by calling `TimeTaggerSource::setReferenceClock()`.
    See the :doc:`In Depth Guide: Software-Defined Reference Clock <InDepthGuides/ReferenceClock>`}
    for details.

    A set of established metrics provides insights into the oscillator characteristics on different time scales.
    The most prominent metric is the Allan Deviation (ADEV). `FrequencyStability` class executes the calculation of
    often used metrics in parallel and conforms to the IEEE 1139 standard. For more information, we recommend the
    [Handbook of Frequency Stability
    Analysis](https://www.nist.gov/publications/handbook-frequency-stability-analysis).

    The calculated deviations are the root-mean-square :math:`\sqrt{f_n \sum_i\left(E_i^{(n)}\right)^2}`
    of a specific set of error samples :math:`E^{(n)}` with a normalization factor :math:`f_n`.
    The step size :math:`n` together with the oscillator period :math:`T` defines the time span :math:`\tau_n = n T`
    that is investigated by the sample.
    The error samples :math:`E^{(n)}` are calculated from the phase samples :math:`t` that are generated by the
    `FrequencyStability` class by averaging over the timestamps of a configurable number of time-tags.
    To investigate the averaged phase samples directly, a trace of configurable length is stored to display the
    current evolution of frequency and phase errors.

    Each of the available deviations has its specific sample :math:`E^{(n)}`.
    For example, the Allan Deviation investigates the second derivative of the phase :math:`t` using the sample
    :math:`E_i^{(n)} = t_i - 2 t_{i+n} + t_{i+2n}`.
    The full formula of the Allan deviation for a set of :math:`N` averaged timestamps is

    .. math::

        \mathrm{ADEV}(\tau_n) = \sqrt{\frac{1}{2(N-2n)\tau_n^2}
          \sum_{i=1}^{N-2n}\left(t_i - 2 t_{i+n} + t_{i+2n}\right)^2}.

    The deviations can be displayed in the Allan domain or in the time domain.
    For the time domain, the Allan domain data is multiplied by a factor proportional to :math:`\tau`.
    This means that in a log-log plot, all slopes of the time domain curves are increased by +1
    compared to the Allan ones.
    The factor :math:`\sqrt{3}` for |ADEV|/|MDEV| and :math:`\sqrt{10/3}` for |HDEV|, respectively,
    is used so that the scaled deviations of a white phase noise distortion correspond to
    the standard deviation of the averaged timestamps :math:`t`.
    In some cases, there are different established names for the representations.
    The `FrequencyStability` class provides numerous metrics for both domains:

    |Allan domain                       |Time domain

    |                                   |Standard Deviation (STDD)
    |Allan Deviation (ADEV)             |ADEVScaled = :math:`\frac{\tau}{\sqrt{3}}` ADEV
    |Modified Allan Deviation (ADEV)    |Time Deviation TDEV = :math:`\frac{\tau}{\sqrt{3}}` MDEV
    |Hadamard Deviation (HDEV )         |HDEVScaled = :math:`\frac{\tau}{\sqrt{10 / 3}}` HDEV


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", channel: "int", steps: "_ULongVector", average: "long long"=1000, trace_len: "uint64_t"=1000):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:      Time tagger object.
        :type channel: int
        :param channel:     The input channel number.
        :type steps: std::vector< uint64_t,std::allocator< uint64_t > >
        :param steps:       The step sizes to consider in the calculation.
            The length of the list determines the maximum number of data points.
            Because the oscillator frequency is unknown, it is not possible to define :math:`\tau` directly.
        :type average: int, optional
        :param average:     The number of time-tags to average internally.
            This downsampling allows for a reduction of noise and memory requirements (default: 1000).
        :type trace_len: int, optional
        :param trace_len:   Number of data points in the phase and frequency error traces, calculated from averaged data.
            The trace always contains the latest data (default: 1000).

        Notes: Use *average* and `TimeTagger::setEventDivider()` with care:
        The event divider can be used to save USB bandwidth.
        If possible, transfer more data via USB and use *average* to improve your results.
        """
        _TimeTagger.FrequencyStability_swiginit(self, _TimeTagger.new_FrequencyStability(tagger, channel, steps, average, trace_len))
    __swig_destroy__ = _TimeTagger.delete_FrequencyStability

    def getDataObject(self) -> "FrequencyStabilityData":
        r"""
        :rtype: :py:class:`FrequencyStabilityData`
        :return: An object that allows access to the current metrics.
        """
        return _TimeTagger.FrequencyStability_getDataObject(self)

# Register FrequencyStability in _TimeTagger:
_TimeTagger.FrequencyStability_swigregister(FrequencyStability)
class GatedChannel(IteratorBase):
    r"""
    Image: GatedChannel.svg

    Transmits the signal from an *input_channel* to a new virtual channel between an edge detected
    at the *gate_start_channel* and the *gate_stop_channel*.



    Notes: 
    If you assign the same channel to *input_channel* and to *gate_start_channel* or *gate_stop_channel*,
    respectively, the internal execution order of the transmission decision and the gate operation
    (opening or closing) becomes important:
    For each tag on the *input_channel*, the decision is made based on the previous state.
    After this decision is made for itself, the tag might toggle the gate state.
    - **input_channel == gate_stop_channel**:
     If the gate is open prior to the arrival of the tag, the tag will pass the gate and close it afterward.
     All subsequent tags will be eliminated until an event on *gate_start_channel* opens the gate again.
     This means that after the gate has been opened, only a single tag will pass the gate,
     which is exactly the behavior of the Conditional Filter with with *gate_start_channel* acting as the trigger
     and *input_channel* acting as the filtered channel.
    - **input_channel == gate_start_channel**:
     If the gate is open prior to the arrival of the tag, the tag itself will be blocked but opens the gate afterward.
     All subsequent tags will pass the gate until an event on *gate_stop_channel* closes the gate again.
     This means that every event on *gate_stop_channel* will eliminate exactly the next event on the *input_channel*.
    .
    This behavior applies to all software versions starting from 2.10.8.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        Notes: Note that **gate_stop_channel == gate_start_channel** will result in an exception.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:                Time Tagger object instance.
        :type input_channel: int
        :param input_channel:         Channel which is gated.
        :type gate_start_channel: int
        :param gate_start_channel:    Channel on which a signal detected will start the transmission of the
            *input_channel* through the gate.
        :type gate_stop_channel: int
        :param gate_stop_channel:     Channel on which a signal detected will stop the transmission of the
            *input_channel* through the gate.
        :type initial: int, optional
        :param initial:               The initial state of the gate. If overflows occur,
            the gate will be reset to this state as well (default: `GatedChannelInitial::Closed`).
        """
        _TimeTagger.GatedChannel_swiginit(self, _TimeTagger.new_GatedChannel(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_GatedChannel

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.GatedChannel_getChannel(self)

# Register GatedChannel in _TimeTagger:
_TimeTagger.GatedChannel_swigregister(GatedChannel)
GatedChannelInitial_Closed = _TimeTagger.GatedChannelInitial_Closed
r"""The gate is closed initially."""
GatedChannelInitial_Open = _TimeTagger.GatedChannelInitial_Open
r"""The gate is open initially."""
class HistogramLogBinsData(object):
    r"""Contains the histogram counts :math:`H(\tau)` and the corresponding normalization function :math:`\widetilde{H}(\tau)`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_HistogramLogBinsData

    def getG2(self) -> "void":
        r"""
        :rtype: void
        :return: A one-dimensional array of size *n_bins* containing the normalized histogram
            :math:`H(\tau)/\widetilde{H}(\tau)`.
        """
        return _TimeTagger.HistogramLogBinsData_getG2(self)

    def getCounts(self) -> "void":
        r"""
        :rtype: void
        :return: A one-dimensional array of size *n_bins* containing the raw histogram :math:`H(\tau)`.
        """
        return _TimeTagger.HistogramLogBinsData_getCounts(self)

    def getG2Normalization(self) -> "void":
        r"""
        :rtype: void
        :return: A one-dimensional array of size *n_bins* containing the normalization
            :math:`\widetilde{H}(\tau)`.
        """
        return _TimeTagger.HistogramLogBinsData_getG2Normalization(self)
    accumulation_time_start: "long long const" = property(_TimeTagger.HistogramLogBinsData_accumulation_time_start_get, doc=r"""accumulation_time_start""")
    accumulation_time_click: "long long const" = property(_TimeTagger.HistogramLogBinsData_accumulation_time_click_get, doc=r"""accumulation_time_click""")

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.this and self.thisown:
            self.__swig_destroy__(self)
            self.thisown = False
            self.this = None
        return False


# Register HistogramLogBinsData in _TimeTagger:
_TimeTagger.HistogramLogBinsData_swigregister(HistogramLogBinsData)
class HistogramLogBins(IteratorBase):
    r"""
    Image: HistogramLogBins.svg

    The HistogramLogBins measurement is similar to `Histogram` but the bin edges are spaced logarithmically.
    As the bins do not have a homogeneous binwidth, a proper normalization is required to interpret the raw data.

    For excluding time ranges from the histogram evaluation while maintaining a proper normalization,
    `HistogramLogBins` optionally takes two gating arguments of type `ChannelGate`.
    This can, e.g., be used to pause the acquisition during erroneous ranges that have to be identified
    by virtual channels. The same mechanism automatically applies to overflow ranges.

    The acquired histogram :math:`H(t)` is normalized by

    .. math::

        \widetilde{H}(\tau) = I(\tau) \cdot C_\mathrm{click} \cdot C_\mathrm{start},
    with an estimation of counts :math:`I(\tau)` and the click and start channel count rates,
    :math:`C_\mathrm{click} = N_\mathrm{click}/t_\mathrm{click}` and
    :math:`C_\mathrm{start} = N_\mathrm{start}/t_\mathrm{start}` , respectively.
    Typically, this will be used to calculate

    .. math::

        g^{(2)}(\tau) = \frac{H(\tau)}{\widetilde{H}(\tau)}.
    For :math:`t \gg 10^\mathrm{exp\_stop} \,\mathrm{s}` and without interruptions,
    :math:`I(\tau) / t` will approach the binwidth of the respective bin.
    During the early acquisition and in case of interruptions, :math:`I(\tau)` can be significantly smaller,
    which compensates for counts that are excluded from :math:`H(\tau)`.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", click_channel: "int", start_channel: "int", exp_start: "double", exp_stop: "double", n_bins: "int32_t", click_gate: "ChannelGate"=None, start_gate: "ChannelGate"=None):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:           Time tagger object instance.
        :type click_channel: int
        :param click_channel:    Channel on which clicks are received.
        :type start_channel: int
        :param start_channel:    Channel on which start clicks are received.
        :type exp_start: float
        :param exp_start:        Exponent `10^exp_start` in seconds where the very first bin begins.
        :type exp_stop: float
        :param exp_stop:         Exponent `10^exp_stop` in seconds where the very last bin ends.
        :type n_bins: int
        :param n_bins:           The number of bins in the histogram.
        :type click_gate: :py:class:`ChannelGate`, optional
        :param click_gate:       Optional evaluation gate for the *click_channel*.
        :type start_gate: :py:class:`ChannelGate`, optional
        :param start_gate:       Optional evaluation gate for the *start_channel*.
        """
        _TimeTagger.HistogramLogBins_swiginit(self, _TimeTagger.new_HistogramLogBins(tagger, click_channel, start_channel, exp_start, exp_stop, n_bins, click_gate, start_gate))
    __swig_destroy__ = _TimeTagger.delete_HistogramLogBins

    def getDataObject(self) -> "HistogramLogBinsData":
        r"""
        :rtype: :py:class:`HistogramLogBinsData`
        :return: A data object containing raw and normalization data.
        """
        return _TimeTagger.HistogramLogBins_getDataObject(self)

    def getBinEdges(self) -> "void":
        r"""
        :rtype: void
        :return: A vector of size *n_bins+1* containing the bin edges in picoseconds.
        """
        return _TimeTagger.HistogramLogBins_getBinEdges(self)

    def getData(self) -> "void":
        r"""
        Deprecated: Since version 2.17.0. Please use `getDataObject()`
        and `HistogramLogBinsData::getCounts()` instead.

        :rtype: void
        :return: A one-dimensional array of size *n_bins* containing the histogram.
        """
        return _TimeTagger.HistogramLogBins_getData(self)

    def getDataNormalizedCountsPerPs(self) -> "void":
        r"""
        Deprecated: Since version 2.17.0.

        :rtype: void
        :return: The counts normalized by the binwidth of each bin.
        """
        return _TimeTagger.HistogramLogBins_getDataNormalizedCountsPerPs(self)

    def getDataNormalizedG2(self) -> "void":
        r"""
        Deprecated: Since version 2.17.0. Please use `getDataObject()`
        and `HistogramLogBinsData::getG2()` instead.

        :rtype: void
        :return: The counts normalized by the binwidth of each bin and the average count rate.
        """
        return _TimeTagger.HistogramLogBins_getDataNormalizedG2(self)

# Register HistogramLogBins in _TimeTagger:
_TimeTagger.HistogramLogBins_swigregister(HistogramLogBins)
class HistogramCustomBins(HistogramLogBins):
    r"""
    The HistogramCustomBins measurement is an alternative to the `HistogramLogBins` measurement.
    It supports custom bin edges and, like `HistogramLogBins`, is optimized for applications with very large
    bin sizes. Its performance is much better compared to `Histogram` if the bins are, on average, much larger
    than the average period of the input data - and much worse otherwise.

    The primary use case for HistogramCustomBins is for analyzing data over extremely large correlation windows where
    the bin edges must be defined manually (e.g. correlation spectroscopy with pulsed laser excitation).

    The measurement data can be retrieved equivalently to `HistogramLogBins` using the `HistogramLogBinsData` object.
    For more details, please see `HistogramLogBins` and the `Tutorials` section.

    Notes: This measurement and HistogramLogBins have a time complexity of `(start_rate + click_rate) * n_bins`.
    So it is good to keep the amount of bins small, usually down to just a few hundred bins.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", click_channel: "int", start_channel: "int", binedges: "_LongLongVector", click_gate: "ChannelGate"=None, start_gate: "ChannelGate"=None):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:           Time tagger object instance.
        :type click_channel: int
        :param click_channel:    Channel on which clicks are received.
        :type start_channel: int
        :param start_channel:    Channel on which start clicks are received.
        :type binedges: std::vector< long long,std::allocator< long long > >
        :param binedges:         The timestamps of the edges of the bins.
        :type click_gate: :py:class:`ChannelGate`, optional
        :param click_gate:       Optional evaluation gate for the *click_channel*.
        :type start_gate: :py:class:`ChannelGate`, optional
        :param start_gate:       Optional evaluation gate for the *start_channel*.
        """
        _TimeTagger.HistogramCustomBins_swiginit(self, _TimeTagger.new_HistogramCustomBins(tagger, click_channel, start_channel, binedges, click_gate, start_gate))
    __swig_destroy__ = _TimeTagger.delete_HistogramCustomBins

# Register HistogramCustomBins in _TimeTagger:
_TimeTagger.HistogramCustomBins_swigregister(HistogramCustomBins)
class Histogram2D(IteratorBase):
    r"""
    Image: Histogram2D.svg

    This measurement is a 2-dimensional version of the `Histogram` measurement.
    The measurement accumulates two-dimensional histogram where stop signals from two
    separate channels define the bin coordinate. For instance, this kind of measurement
    is similar to that of typical 2D NMR spectroscopy.
    The data within the histogram is acquired via a single-start, single-stop analysis for each axis.
    The first stop click of each axis is taken after the start click to evaluate the histogram counts.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", start_channel: "int", stop_channel_1: "int", stop_channel_2: "int", binwidth_1: "long long", binwidth_2: "long long", n_bins_1: "int32_t", n_bins_2: "int32_t"):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:          Time tagger object
        :type start_channel: int
        :param start_channel:   Channel on which start clicks are received
        :type stop_channel_1: int
        :param stop_channel_1:  Channel on which stop clicks for the time axis 1 are received
        :type stop_channel_2: int
        :param stop_channel_2:  Channel on which stop clicks for the time axis 2 are received
        :type binwidth_1: int
        :param binwidth_1:      Bin width in ps for the time axis 1
        :type binwidth_2: int
        :param binwidth_2:      Bin width in ps for the time axis 2
        :type n_bins_1: int
        :param n_bins_1:        The number of bins along the time axis 1
        :type n_bins_2: int
        :param n_bins_2:        The number of bins along the time axis 2
        """
        _TimeTagger.Histogram2D_swiginit(self, _TimeTagger.new_Histogram2D(tagger, start_channel, stop_channel_1, stop_channel_2, binwidth_1, binwidth_2, n_bins_1, n_bins_2))
    __swig_destroy__ = _TimeTagger.delete_Histogram2D

    def getData(self) -> "void":
        r"""
        :rtype: void
        :return: A two-dimensional array of size *n_bins_1* by *n_bins_2* containing the 2D histogram.
        """
        return _TimeTagger.Histogram2D_getData(self)

    def getIndex(self) -> "void":
        r"""
        Returns a 3D array containing two coordinate matrices (*meshgrid)* for time bins in ps for the time axes 1 and 2.
        For details on *meshgrid* please take a look at the respective documentation either for
        [Matlab](https://www.mathworks.com/help/matlab/ref/meshgrid.html) or
        [Python NumPy](https://numpy.org/doc/stable/reference/generated/numpy.meshgrid.html).

        :rtype: void
        :return: A three-dimensional array of size *n_bins_1* x *n_bins_2* x 2.
        """
        return _TimeTagger.Histogram2D_getIndex(self)

    def getIndex_1(self) -> "void":
        r"""
        :rtype: void
        :return: A vector of size *n_bins_1* containing the bin locations in ps for the time axis 1.
        """
        return _TimeTagger.Histogram2D_getIndex_1(self)

    def getIndex_2(self) -> "void":
        r"""
        :rtype: void
        :return: A vector of size *n_bins_2* containing the bin locations in ps for the time axis 2.
        """
        return _TimeTagger.Histogram2D_getIndex_2(self)

# Register Histogram2D in _TimeTagger:
_TimeTagger.Histogram2D_swigregister(Histogram2D)
class HistogramND(IteratorBase):
    r"""
    This measurement is the generalization of `Histogram2D` to an arbitrary number of dimensions.
    The data within the histogram is acquired via a single-start, single-stop analysis for each axis.
    The first stop click of each axis is taken after the start click to evaluate the histogram counts.

    `HistogramND` can be used as a 1D `Histogram` with single-start single-stop behavior.

    'See all common methods'
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", start_channel: "int", stop_channels: "_IntVector", binwidths: "_LongLongVector", n_bins: "_IntVector"):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:        Time tagger object.
        :type start_channel: int
        :param start_channel: Channel on which start clicks are received.
        :type stop_channels: std::vector< int,std::allocator< int > >
        :param stop_channels: Channel list on which stop clicks are received defining the time axes.
        :type binwidths: std::vector< long long,std::allocator< long long > >
        :param binwidths:     Bin width in ps for the corresponding time axis.
        :type n_bins: std::vector< int32_t,std::allocator< int32_t > >
        :param n_bins:        The number of bins along the corresponding time axis.
        """
        _TimeTagger.HistogramND_swiginit(self, _TimeTagger.new_HistogramND(tagger, start_channel, stop_channels, binwidths, n_bins))
    __swig_destroy__ = _TimeTagger.delete_HistogramND

    def getData(self) -> "void":
        r"""
        Returns a one-dimensional array of the size of the product of *n_bins* containing the histogram data.
        The array order is in row-major. For example, with `stop_channels=[ch1, ch2]` and `n_bins=[2, 2]`,
        the 1D array would represent 2D bin indices in the order `[(0,0), (0,1), (1,0), (1,1)]`,
        with (index of `ch1`, index of `ch2`). Please reshape the 1D array to get the N-dimensional array.
        The following code demonstrates how to reshape the returned 1D array into multidimensional array using NumPy:

        .. code-block:: python

            channels = [2, 3, 4, 5]
            n_bins = [5, 3, 4, 6]
            binwidths = [100, 100, 100, 50]
            histogram_nd = HistogramND(tagger, 1, channels, binwidths, n_bins)
            sleep(1)  # Wait to accumulate the data
            data = histogram_nd.getData()
            multidim_array = numpy.reshape(data, n_bins)
        :rtype: void
        :return: Flattened array of histogram bins.
        """
        return _TimeTagger.HistogramND_getData(self)

    def getIndex(self, dim: "int32_t"=0) -> "void":
        r"""
        :rtype: void
        :return: A vector of size *n_bins[dim]* containing the bin locations in ps for the corresponding time axis.
        """
        return _TimeTagger.HistogramND_getIndex(self, dim)

# Register HistogramND in _TimeTagger:
_TimeTagger.HistogramND_swigregister(HistogramND)
class Iterator(IteratorBase):
    r"""
    a deprecated simple event queue

    A simple Iterator, just keeping a first-in first-out queue of event timestamps.

    Deprecated: use TimeTagStream
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", channel: "int"):
        r"""
        standard constructor

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:        the backend
        :type channel: int
        :param channel:       the channel to get events from
        """
        _TimeTagger.Iterator_swiginit(self, _TimeTagger.new_Iterator(tagger, channel))
    __swig_destroy__ = _TimeTagger.delete_Iterator

    def next(self) -> "long long":
        r"""
        get next timestamp

        get the next timestamp from the queue.
        """
        return _TimeTagger.Iterator_next(self)

    def size(self) -> "uint64_t":
        r"""get queue size"""
        return _TimeTagger.Iterator_size(self)

# Register Iterator in _TimeTagger:
_TimeTagger.Iterator_swigregister(Iterator)
class Experimental_MarkovProcessGenerator(IteratorBase):
    r"""Proxy of C++ Experimental::MarkovProcessGenerator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        Construct a continuous-time Markov chain process.

        https://en.wikipedia.org/wiki/Continuous-time_Markov_chain

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:          reference to a TimeTagger
        :type num_states: int
        :param num_states:      Number of exponential states.
        :type frequencies: std::vector< double,std::allocator< double > >
        :param frequencies:     frequencies of each state transition, it's size is num_states * num_states.
        :type ref_channels: std::vector< int,std::allocator< int > >
        :param ref_channels:    tells the net channel to look at on a state transition. its size is num_states * num_states.
        :type base_channels: std::vector< int,std::allocator< int > >, optional
        :param base_channels:   channels in which to generate or add the new timetags if CHANNEL_UNUSED or empty, generate
                                   a new virtual channel
        :type seed: int, optional
        :param seed:            Seed number for the Pseudo-random number generator. Use -1 to use the
                                   current time as seed.
        """
        _TimeTagger.Experimental_MarkovProcessGenerator_swiginit(self, _TimeTagger.new_Experimental_MarkovProcessGenerator(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Experimental_MarkovProcessGenerator

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.Experimental_MarkovProcessGenerator_getChannel(self)

    def getChannels(self) -> "std::vector< int,std::allocator< int > >":
        r"""getChannels(self) -> _IntVector"""
        return _TimeTagger.Experimental_MarkovProcessGenerator_getChannels(self)

# Register Experimental_MarkovProcessGenerator in _TimeTagger:
_TimeTagger.Experimental_MarkovProcessGenerator_swigregister(Experimental_MarkovProcessGenerator)
class OverflowInjector(IteratorBase):
    r"""Proxy of C++ OverflowInjector class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", delay: "long long", length: "long long"):
        r"""__init__(self, tagger, delay, length) -> OverflowInjector"""
        _TimeTagger.OverflowInjector_swiginit(self, _TimeTagger.new_OverflowInjector(tagger, delay, length))
    __swig_destroy__ = _TimeTagger.delete_OverflowInjector

# Register OverflowInjector in _TimeTagger:
_TimeTagger.OverflowInjector_swigregister(OverflowInjector)
class PhaseNoiseData(object):
    r"""Proxy of C++ PhaseNoiseData class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_PhaseNoiseData

    def getPhaseNoise(self) -> "void":
        r"""
        Array of phase noise measurement results.
        :rtype: void
        :return: The phase noise measurement results in dBc/Hz.
        """
        return _TimeTagger.PhaseNoiseData_getPhaseNoise(self)

    def getIntegratedJitter(self, lower_bound: "double"=12000.0, upper_bound: "double"=-1.0) -> "double":
        r"""
        Integrates the phase noise and calculate the estimated RMS jitter.
        :type lower_bound: float, optional
        :param lower_bound: The lower frequency offset boundary for the integration in Hz (default: 12e3).
        :type upper_bound: float, optional
        :param upper_bound: The upper frequency offset boundary for the integration in Hz (default: -1).
            Negative values are interpreted as the Nyquist frequency.
        :rtype: float
        :return: The integrated phase noise as estimated RMS jitter in seconds.
        Notes: The integration starting from 0 Hz will diverge for any noise source with a spectral power density law
        starting from `1/f`. This includes Flicker phase noise, any frequency noise and any frequency drifts.
        """
        return _TimeTagger.PhaseNoiseData_getIntegratedJitter(self, lower_bound, upper_bound)

    def getOffset(self) -> "void":
        r"""
        Array of frequency offsets for all spectral samples.
        :rtype: void
        :return: The frequency offset for each spectral sample in Hz.
        """
        return _TimeTagger.PhaseNoiseData_getOffset(self)

    def getAveragedSequences(self) -> "void":
        r"""
        Array of the number of averaged sequences for all spectral samples.
        :rtype: void
        :return: The number of averaged sequences for each spectral samples.
        """
        return _TimeTagger.PhaseNoiseData_getAveragedSequences(self)

    def getFrequency(self) -> "double":
        r"""
        Average carrier frequency of the PhaseNoise measurement.
        :rtype: float
        :return: The average carrier frequency in Hz.
        """
        return _TimeTagger.PhaseNoiseData_getFrequency(self)

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.this and self.thisown:
            self.__swig_destroy__(self)
            self.thisown = False
            self.this = None
        return False


# Register PhaseNoiseData in _TimeTagger:
_TimeTagger.PhaseNoiseData_swigregister(PhaseNoiseData)
class PhaseNoise(IteratorBase):
    r"""
    This measurement provides a phase noise estimator with spectral samples
    distributed quasi-logarithmically over frequency offset.
    When the Time Taggers internal clock stability falls short of requirements,
    locking to a stable external reference is recommended.
    This can be achieved by calling `TimeTaggerSource::setReferenceClock()`.
    See the :doc:`In Depth Guide: Software-Defined Reference Clock <InDepthGuides/ReferenceClock>`}
    for details.

    Welchs method is employed to estimate the power spectral density (PSD) from the time tag stream:
    * The time tag stream is divided into overlapping sequences of `NFFT = 4 * samples_per_octave` samples.
    * The linear regression is applied to each sequence to
      remove constant phase and frequency offsets, yielding demodulated phase samples.
    * A Hann window is applied to each sequence to suppress spectral leakage and mitigate edge effects
      in the Fast Fourier Transform (FFT).
      These windowing operations are visualized in the sketch as the colored envelope curves (red, orange, brown)
      spanning overlapping time tags sequences.
    * The squared magnitude of each FFT result is computed and averaged over time to reduce variance.
    * Sequences are processed with 50% overlap to improve spectral stability
      and compensate for the windows reduced sensitivity at the edges.

    Welch's method provides a spectrum with linearly spaced spectral samples. To achieve a quasi-logarithmic
    distribution, only the upper half of each FFT output is retained.
    The lower-frequency half is reconstructed by recursively averaging
    adjacent timestamp pairs and reapplying Welchs method at each level of decimation, as shown in the sketch.
    This recursive refinement yields `samples_per_octave` spectral samples per octave.

    'See all common methods'
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", channel: "int", samples_per_octave: "int"=32):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:              Time Tagger object instance.
        :type channel: int
        :param channel:             The channel to analyze.
        :type samples_per_octave: int, optional
        :param samples_per_octave:  The number of phase noise samples per octave (default: 32).
                                       For optimal FFT performance, this should be set to a power of two.
        """
        _TimeTagger.PhaseNoise_swiginit(self, _TimeTagger.new_PhaseNoise(tagger, channel, samples_per_octave))
    __swig_destroy__ = _TimeTagger.delete_PhaseNoise

    def getDataObject(self) -> "PhaseNoiseData":
        r"""
        Returns a `PhaseNoiseData` object containing a snapshot of the data accumulated in the `PhaseNoise`
        at the time this method is called.
        :rtype: :py:class:`PhaseNoiseData`
        :return: An object providing access to a snapshot data.
        """
        return _TimeTagger.PhaseNoise_getDataObject(self)

# Register PhaseNoise in _TimeTagger:
_TimeTagger.PhaseNoise_swigregister(PhaseNoise)
class Experimental_PhotonNumber(IteratorBase):
    r"""Photon number resolution"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", trigger_ch: "int", signal_start_ch: "int", signal_stop_ch: "int", slope: "double", x_intercepts: "_DoubleVector", dead_time: "long long"):
        r"""
        construct a PhotonNumber

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:      reference to a TimeTagger
        :type trigger_ch: int
        :param trigger_ch:  trigger channel
        :type signal_start_ch: int
        :param signal_start_ch:   start-of-signal channel (likely rising edge)
        :type signal_stop_ch: int
        :param signal_stop_ch:   end-of-signal channel (likely falling edge)
        :type slope: float
        :param slope:       common slope of decision boundary lines
        :type x_intercepts: std::vector< double,std::allocator< double > >
        :param x_intercepts: x-intercepts of decision boundary lines. Has to be in descending order
        :type dead_time: int
        :param dead_time:   the dead time of the detector
        """
        _TimeTagger.Experimental_PhotonNumber_swiginit(self, _TimeTagger.new_Experimental_PhotonNumber(tagger, trigger_ch, signal_start_ch, signal_stop_ch, slope, x_intercepts, dead_time))
    __swig_destroy__ = _TimeTagger.delete_Experimental_PhotonNumber

    def getChannels(self) -> "std::vector< int,std::allocator< int > > const &":
        r"""
        the new virtual channels

        This function returns the IDs of the allocated virtual channels, corresponding to photon counts of :math:`1, \ldots,N, \geq N+1` for given :math:`N` decision boundary lines.

        """
        return _TimeTagger.Experimental_PhotonNumber_getChannels(self)

# Register Experimental_PhotonNumber in _TimeTagger:
_TimeTagger.Experimental_PhotonNumber_swigregister(Experimental_PhotonNumber)
class Experimental_PulsePerSecondData(object):
    r"""Proxy of C++ Experimental::PulsePerSecondData class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getIndices(self) -> "void":
        r"""
        The indices of each reference pulse in the `PulsePerSecondData` object.
        The first reference pulse will have index 0, each subsequent pulse from the reference source
        increments the index by one. In case of overflows in the reference channel,
        this index will be incremented by the number of missed pulses.

        :rtype: void
        :return: A list of indices for each pulse from the reference source.
        """
        return _TimeTagger.Experimental_PulsePerSecondData_getIndices(self)

    def getReferenceOffsets(self) -> "void":
        r"""
        A list of offsets of each reference pulse with respective to its predecessor, with the period subtracted.
        For a perfect PPS source, this offset would always be zero. The offset of the first pulse is always
        defined to be zero. If a reference signal is missing, its offset is defined to be *NaN*.

        :rtype: void
        :return: A list of the offsets of each reference with respect to the previous.
        """
        return _TimeTagger.Experimental_PulsePerSecondData_getReferenceOffsets(self)

    def getSignalOffsets(self) -> "void":
        r"""
        For each reference contained in the `PulsePerSecondData` object a list of offsets for each signal channel is
        given, in the channel order given by *signal_channels*.
        If any signal is missing, its offset is defined to be *NaN*.

        :rtype: void
        :return: A list of lists of offsets for each signal_channel for given reference pulses.
        """
        return _TimeTagger.Experimental_PulsePerSecondData_getSignalOffsets(self)

    def getUtcSeconds(self) -> "void":
        r"""
        The number of elapsed seconds from the beginning of the Unix epoch (1st of January 1970) to the time at
        which each reference pulse is processed, as a floating point number.

        :rtype: void
        :return: A list of the number of seconds since the Unix epoch to the time of processing, for each reference pulse.
        """
        return _TimeTagger.Experimental_PulsePerSecondData_getUtcSeconds(self)

    def getUtcDates(self) -> "std::vector< std::string,std::allocator< std::string > >":
        r"""
        The UTC timestamps for the system time at which each reference pulse is processed, as a string with ISO 8601
        formatting (`YYYY-MM-DD hh:mm:ss.ssssss`).

        :rtype: std::vector< std::string,std::allocator< std::string > >
        :return: A list of the UTC timestamp at processing time, for each reference pulse.
        """
        return _TimeTagger.Experimental_PulsePerSecondData_getUtcDates(self)

    def getStatus(self) -> "void":
        r"""
        A list of booleans values describing whether all signals, including from the reference source, were detected.
        *True* corresponds to a complete collection of signals, *False* otherwise.

        :rtype: void
        :return: A list of bools describing the signal integrity for each reference pulse.
        """
        return _TimeTagger.Experimental_PulsePerSecondData_getStatus(self)
    size: "size_t const" = property(_TimeTagger.Experimental_PulsePerSecondData_size_get, doc=r"""Number of reference pulses contained in the `PulsePerSecondData` object.""")
    __swig_destroy__ = _TimeTagger.delete_Experimental_PulsePerSecondData

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.this and self.thisown:
            self.__swig_destroy__(self)
            self.thisown = False
            self.this = None
        return False


# Register Experimental_PulsePerSecondData in _TimeTagger:
_TimeTagger.Experimental_PulsePerSecondData_swigregister(Experimental_PulsePerSecondData)
class Experimental_PulsePerSecondMonitor(IteratorBase):
    r"""
    This measurement allows the user to monitor the synchronicity of different sources of 1 pulse per second (PPS)
    signals with respect to a reference source. For each signal from the reference PPS source, comparative offsets are
    calculated for the other signal channels. Upon processing, a UTC timestamp from the system time is associated with
    each reference pulse.

    The monitoring starts on the first signal from the reference source and will run uninterrupted until the measurement
    is stopped. If a signal from a channel is not detected within one and a half periods, its respective offset will not
    be calculated but the measurement will continue nonetheless.

    By specifying an output file name, the monitoring data can be continuously written to a comma-separated value file
    (.csv).

    Notes: If you need to monitor reference drift over many PPS epochs,
     using `PulsePerSecondData::getReferenceOffsets()`,
     or you need traceability to a lab standard, it is advisable to feed a stable external reference (e.g., 10 MHz)
     into a regular input of the Time Tagger and enable the *ReferenceClock*
     via `TimeTaggerSource::setReferenceClock()`.
     See the :doc:`In Depth Guide: Software-Defined Reference Clock <InDepthGuides/ReferenceClock>`}
     for details. On the other hand, the internal clock is sufficient to monitor time offsets
     of multiple PPS channels relative to one reference PPS, provided the edges refer to the same nominal second.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:            Time Tagger object instance.
        :type reference_channel: int
        :param reference_channel: The channel number corresponding to the PPS reference source.
        :type signal_channels: std::vector< int,std::allocator< int > >
        :param signal_channels:   A list of channel numbers with PPS signals to be compared to the reference.
        :type filename: string, optional
        :param filename:          The name of the .csv file to store measurement data.
            By default, no data is written to file (default: "").
        :type period: int, optional
        :param period:            The assumed period of the reference source, typically one second, in picoseconds
            (default: 1e12).
        """
        _TimeTagger.Experimental_PulsePerSecondMonitor_swiginit(self, _TimeTagger.new_Experimental_PulsePerSecondMonitor(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Experimental_PulsePerSecondMonitor

    def getDataObject(self, remove: "bool"=False) -> "Experimental::PulsePerSecondData":
        r"""
        Returns a `PulsePerSecondData` object containing a snapshot of the data accumulated in the `PulsePerSecondMonitor`
        at the time this method is called.
        To remove the data from the internal memory after each call, set *remove* to *True*.

        :type remove: boolean, optional
        :param remove: Controls if the returned data shall be removed from the internal buffer.
        :rtype: :py:class:`PulsePerSecondData`
        :return: An object providing access to a snapshot data.
        """
        return _TimeTagger.Experimental_PulsePerSecondMonitor_getDataObject(self, remove)

# Register Experimental_PulsePerSecondMonitor in _TimeTagger:
_TimeTagger.Experimental_PulsePerSecondMonitor_swigregister(Experimental_PulsePerSecondMonitor)
class Sampler(IteratorBase):
    r"""
    Image: Sampler.svg

    The `Sampler` class allows sampling the state of a set of channels via a trigger channel.

    For every event on the trigger input, the current state (low: 0, high: 1, unknown: 2)
    will be written to an internal buffer. Fetching the data of the internal buffer will clear
    its internal buffer, so every event will be returned only once.

    Time Tagger detects pulse edges and therefore a channel will be in the unknown state until
    an edge detection event was received on that channel from the start of the measurement or after an overflow.
    The internal processing assumes that no event could be received within the channel's deadtime otherwise
    invalid data will be reported until the next event on this input channel.

    Notes: The maximum number of channels is limited to 63 for one `Sampler` instance.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", trigger: "int", channels: "_IntVector", max_triggers: "size_t"):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:        The time tagger object instance.
        :type trigger: int
        :param trigger:       Channel number of the trigger signal.
        :type channels: std::vector< int,std::allocator< int > >
        :param channels:      List of channels to be sampled.
        :type max_triggers: int
        :param max_triggers:  The number of triggers and their respective sampled data,
            which is stored within the measurement class.
        """
        _TimeTagger.Sampler_swiginit(self, _TimeTagger.new_Sampler(tagger, trigger, channels, max_triggers))
    __swig_destroy__ = _TimeTagger.delete_Sampler

    def getData(self) -> "void":
        r"""
        Returns and removes the stored data as a 2D array (*n_triggers* x (*n_channels* + 1)):

        .. code-block:: python

            [timestamp of first trigger,  state of channel 0, state of channel 1, ...],
            [timestamp of second trigger, state of channel 0, state of channel 1, ...],
            ...

        Where the state means:

        .. code-block:: python

              0 -- low
              1 -- high
              2 -- undefined (after overflow)

        :rtype: void
        :return: Sampled data
        """
        return _TimeTagger.Sampler_getData(self)

    def getDataAsMask(self) -> "void":
        r"""
        Returns and removes the stored data as a 2D array (*n_triggers* x 2):

        .. code-block:: python

            [timestamp of first trigger,  (state of channel 0) << 0 | (state of channel 1) << 1 | ... | any_undefined << 63],
            [timestamp of second trigger, (state of channel 0) << 0 | (state of channel 1) << 1 | ... | any_undefined << 63],
            ...

        Where state means:

        .. code-block:: python

              0 -- low or undefined (after overflow)
              1 -- high

        If the highest bit (data[63]) is marked, one of the channels has been in an undefined state.

        :rtype: void
        :return: Sampled data.
        """
        return _TimeTagger.Sampler_getDataAsMask(self)

# Register Sampler in _TimeTagger:
_TimeTagger.Sampler_swigregister(Sampler)
UNKNOWN = _TimeTagger.UNKNOWN

HIGH = _TimeTagger.HIGH

LOW = _TimeTagger.LOW

class Event(object):
    r"""Pair of the timestamp and the new state returned by `Scope::getData()`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    time: "long long" = property(_TimeTagger.Event_time_get, _TimeTagger.Event_time_set, doc=r"""Timestamp in ps.""")
    state: "State" = property(_TimeTagger.Event_state_get, _TimeTagger.Event_state_set, doc=r"""Input state.""")

    def __init__(self):
        r"""__init__(self) -> Event"""
        _TimeTagger.Event_swiginit(self, _TimeTagger.new_Event())
    __swig_destroy__ = _TimeTagger.delete_Event

# Register Event in _TimeTagger:
_TimeTagger.Event_swigregister(Event)
class Scope(IteratorBase):
    r"""
    Image: Scope.svg

    The `Scope` class allows to visualize time tags for rising and falling edges in a time trace diagram similarly to an
    ultrafast logic analyzer. The trace recording is synchronized to a trigger signal which can be any physical or
    virtual channel. However, only physical channels can be specified to the *event_channels* parameter.
    Additionally, one has to specify the time *window_size* which is the timetrace duration to be recorded,
    the number of traces to be recorded and the maximum number of events to be detected.
    If `n_traces < 1` then retriggering will occur infinitely, which is similar to the normal mode of an oscilloscope.

    Notes: Scope class implicitly enables the detection of positive and negative edges for every physical channel
    specified in *event_channels*. This accordingly doubles the data rate requirement per input.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", event_channels: "_IntVector", trigger_channel: "int", window_size: "long long"=1000000000, n_traces: "int32_t"=1, n_max_events: "int32_t"=1000):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:                The time tagger object instance.
        :type event_channels: std::vector< int,std::allocator< int > >
        :param event_channels:        List of channels.
        :type trigger_channel: int
        :param trigger_channel:       Channel number of the trigger signal.
        :type window_size: int, optional
        :param window_size:           Time window in picoseconds (default: 1 ms).
        :type n_traces: int, optional
        :param n_traces:              Number of trigger events to be detected (default: 1).
        :type n_max_events: int, optional
        :param n_max_events:          Max number of events to be detected (default: 1000).
        """
        _TimeTagger.Scope_swiginit(self, _TimeTagger.new_Scope(tagger, event_channels, trigger_channel, window_size, n_traces, n_max_events))
    __swig_destroy__ = _TimeTagger.delete_Scope

    def getData(self) -> "std::vector< std::vector< Event,std::allocator< Event > >,std::allocator< std::vector< Event,std::allocator< Event > > > >":
        r"""
        Returns a tuple of the size equal to the number of *event_channels* multiplied by *n_traces*,
        where each element is a tuple of `Event`.

        :rtype: std::vector< std::vector< Event,std::allocator< Event > >,std::allocator< std::vector< Event,std::allocator< Event > > > >
        :return: Event list for each trace.
        """
        return _TimeTagger.Scope_getData(self)

    def ready(self) -> "bool":
        r"""
        :rtype: boolean
        :return: Returns whether the acquisition is complete which means that all traces (*n_traces)* are acquired.
        """
        return _TimeTagger.Scope_ready(self)

    def triggered(self) -> "int32_t":
        r"""
        :rtype: int
        :return: Returns number of trigger events have been captured so far.
        """
        return _TimeTagger.Scope_triggered(self)

    def getWindowSize(self) -> "long long":
        r"""
        :rtype: int
        :return: Returns the *windows_size* parameter.
        """
        return _TimeTagger.Scope_getWindowSize(self)

# Register Scope in _TimeTagger:
_TimeTagger.Scope_swigregister(Scope)
class Experimental_SignalGeneratorBase(IteratorBase):
    r"""Proxy of C++ Experimental::SignalGeneratorBase class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_Experimental_SignalGeneratorBase

    def getChannel(self) -> "int":
        r"""
        the new virtual channel

        This function returns the new allocated virtual channel.
        It can be used now in any new iterator.
        """
        return _TimeTagger.Experimental_SignalGeneratorBase_getChannel(self)

# Register Experimental_SignalGeneratorBase in _TimeTagger:
_TimeTagger.Experimental_SignalGeneratorBase_swigregister(Experimental_SignalGeneratorBase)
class Experimental_PhotonGenerator(Experimental_SignalGeneratorBase):
    r"""Proxy of C++ Experimental::PhotonGenerator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", countrate: "double", base_channel: "int", seed: "int32_t"=-1):
        r"""
        A generator for TimeTags arising from a laser driven process. `PhotonGenerator` should be used as the base
        class of a virtual class with a dedicated `get_intensity` function which models the relevant physical processes.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:                reference to a TimeTagger.
        :type countrate: float
        :param countrate:             rate (in Hz) of Time Tags to be generated.
        :type base_channel: int
        :param base_channel:          base channel to which this signal will be added. If unused, a new channel will be
                                         created.
        :type seed: int, optional
        :param seed:                  Seed number for the Pseudo-random number generator. Use -1 to use the
                                         current time as seed.
        """
        if self.__class__ == Experimental_PhotonGenerator:
            _self = None
        else:
            _self = self
        _TimeTagger.Experimental_PhotonGenerator_swiginit(self, _TimeTagger.new_Experimental_PhotonGenerator(_self, tagger, countrate, base_channel, seed))
    __swig_destroy__ = _TimeTagger.delete_Experimental_PhotonGenerator

    def finalize_init(self) -> "void":
        r"""finalize_init(self)"""
        return _TimeTagger.Experimental_PhotonGenerator_finalize_init(self)

    def set_T_PERIOD(self, new_T: "long long") -> "void":
        r"""set_T_PERIOD(self, new_T)"""
        return _TimeTagger.Experimental_PhotonGenerator_set_T_PERIOD(self, new_T)

    def get_T_PERIOD(self) -> "long long":
        r"""get_T_PERIOD(self) -> long long"""
        return _TimeTagger.Experimental_PhotonGenerator_get_T_PERIOD(self)

    def initialize(self, initial_time: "long long") -> "void":
        r"""initialize(self, initial_time)"""
        return _TimeTagger.Experimental_PhotonGenerator_initialize(self, initial_time)

    def on_restart(self, restart_time: "long long") -> "void":
        r"""on_restart(self, restart_time)"""
        return _TimeTagger.Experimental_PhotonGenerator_on_restart(self, restart_time)

    def get_next(self) -> "long long":
        r"""get_next(self) -> long long"""
        return _TimeTagger.Experimental_PhotonGenerator_get_next(self)

    def get_intensity(self) -> "double":
        r"""get_intensity(self) -> double"""
        return _TimeTagger.Experimental_PhotonGenerator_get_intensity(self)
    def __disown__(self):
        self.this.disown()
        _TimeTagger.disown_Experimental_PhotonGenerator(self)
        return weakref.proxy(self)

    def clear_impl(self) -> "void":
        r"""
        clear Iterator state.

        Each Iterator should implement the clear_impl() method to reset
        its internal state.
        The clear_impl() function is guarded by the update lock.
        """
        return _TimeTagger.Experimental_PhotonGenerator_clear_impl(self)

    def on_start(self) -> "void":
        r"""
        callback when the measurement class is started

        This function is guarded by the update lock.
        """
        return _TimeTagger.Experimental_PhotonGenerator_on_start(self)

    def on_stop(self) -> "void":
        r"""on_stop(self)"""
        return _TimeTagger.Experimental_PhotonGenerator_on_stop(self)

    def pre_stop(self) -> "void":
        r"""
        callback before the measurement class is stopped

        Both the measurement mutex and the pre_mutex are locked.
        So at this stage, it is save to unlock the measurement lock and still no other thread will call this instance.
        """
        return _TimeTagger.Experimental_PhotonGenerator_pre_stop(self)

    def next_impl(self, incoming_tags: "std::vector< Tag,std::allocator< Tag > > &", begin_time: "long long", end_time: "long long") -> "bool":
        r"""next_impl(self, incoming_tags, begin_time, end_time) -> bool"""
        return _TimeTagger.Experimental_PhotonGenerator_next_impl(self, incoming_tags, begin_time, end_time)

# Register Experimental_PhotonGenerator in _TimeTagger:
_TimeTagger.Experimental_PhotonGenerator_swigregister(Experimental_PhotonGenerator)
class Experimental_DlsSignalGenerator(Experimental_PhotonGenerator):
    r"""Proxy of C++ Experimental::DlsSignalGenerator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        DlsSignalGenerator(tagger, decay_time, countrate, output_channel=CHANNEL_UNUSED, seed=-1) -> Experimental_DlsSignalGenerator
        __init__(self, tagger, decay_times, countrate, output_channel=CHANNEL_UNUSED, seed=-1) -> Experimental_DlsSignalGenerator
        """
        _TimeTagger.Experimental_DlsSignalGenerator_swiginit(self, _TimeTagger.new_Experimental_DlsSignalGenerator(*args))
    __swig_destroy__ = _TimeTagger.delete_Experimental_DlsSignalGenerator

    def get_N(self) -> "unsigned int":
        r"""get_N(self) -> unsigned int"""
        return _TimeTagger.Experimental_DlsSignalGenerator_get_N(self)

# Register Experimental_DlsSignalGenerator in _TimeTagger:
_TimeTagger.Experimental_DlsSignalGenerator_swigregister(Experimental_DlsSignalGenerator)
class Experimental_FcsSignalGenerator(Experimental_PhotonGenerator):
    r"""Proxy of C++ Experimental::FcsSignalGenerator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        Construct an FCS event channel.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:                reference to a TimeTagger.
        :type correlation_time: float
        :param correlation_time:      characteristic correlation time in the exponential g2 curve.
        :type countrate: float
        :param countrate:             rate (in Hz) of Time Tags to be generated.
        :type N_focus: float
        :param N_focus:               the average number of particles in the laser focus.
        :type output_channel: int, optional
        :param output_channel:        base channel to which this signal will be added. If unused, a new channel will be
                                         created.
        :type seed: int, optional
        :param seed:                  Seed number for the Pseudo-random number generator. Use -1 to use the
                                         current time as seed.
        """
        _TimeTagger.Experimental_FcsSignalGenerator_swiginit(self, _TimeTagger.new_Experimental_FcsSignalGenerator(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Experimental_FcsSignalGenerator

    def get_N(self) -> "unsigned int":
        r"""get_N(self) -> unsigned int"""
        return _TimeTagger.Experimental_FcsSignalGenerator_get_N(self)

    def set_boundary_limit(self, new_boundary: "double") -> "void":
        r"""set_boundary_limit(self, new_boundary)"""
        return _TimeTagger.Experimental_FcsSignalGenerator_set_boundary_limit(self, new_boundary)

# Register Experimental_FcsSignalGenerator in _TimeTagger:
_TimeTagger.Experimental_FcsSignalGenerator_swigregister(Experimental_FcsSignalGenerator)
class Experimental_UniformSignalGenerator(Experimental_SignalGeneratorBase):
    r"""Proxy of C++ Experimental::UniformSignalGenerator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        Construct a random uniform event channel.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:              reference to a TimeTagger
        :type upper_bound: int
        :param upper_bound:         Max possible offset of event generated compared to latest.
        :type lower_bound: int, optional
        :param lower_bound:         Min possible offset of event generated, must be higher than 0.
        :type base_channel: int, optional
        :param base_channel:        base channel to which this signal will be added. If unused, a new channel will be
                                       created.
        :type seed: int, optional
        :param seed:                Seed number for the Pseudo-random number generator. Use -1 to use the current time as
                                       seed.
        """
        _TimeTagger.Experimental_UniformSignalGenerator_swiginit(self, _TimeTagger.new_Experimental_UniformSignalGenerator(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Experimental_UniformSignalGenerator

# Register Experimental_UniformSignalGenerator in _TimeTagger:
_TimeTagger.Experimental_UniformSignalGenerator_swigregister(Experimental_UniformSignalGenerator)
class Experimental_GaussianSignalGenerator(Experimental_SignalGeneratorBase):
    r"""Proxy of C++ Experimental::GaussianSignalGenerator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        Construct a gaussian event channel.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:              reference to a TimeTagger
        :type mean: float
        :param mean:                mean time each event is generated.
        :type standard_deviation: float
        :param standard_deviation:  standard deviation of the normal distribution.
        :type base_channel: int, optional
        :param base_channel:        base channel to which this signal will be added. If unused, a new channel will be
                                       created.
        :type seed: int, optional
        :param seed:                Seed number for the Pseudo-random number generator. Use -1 to use the current time as
                                       seed.
        """
        _TimeTagger.Experimental_GaussianSignalGenerator_swiginit(self, _TimeTagger.new_Experimental_GaussianSignalGenerator(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Experimental_GaussianSignalGenerator

# Register Experimental_GaussianSignalGenerator in _TimeTagger:
_TimeTagger.Experimental_GaussianSignalGenerator_swigregister(Experimental_GaussianSignalGenerator)
class Experimental_OscillatorSimulation(Experimental_SignalGeneratorBase):
    r"""Proxy of C++ Experimental::OscillatorSimulation class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        Construct a simulated oscillator event channel.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:              reference to a TimeTagger
        :type nominal_frequency: float
        :param nominal_frequency:   Normal frequency of the oscillator in Hz
        :type coeff_phase_white: float, optional
        :param coeff_phase_white:    RMS value of the white phase noise in seconds.
        :type coeff_phase_flicker: float, optional
        :param coeff_phase_flicker:   RMS value of the flicker phase noise in seconds per octave.
        :type coeff_freq_white: float, optional
        :param coeff_freq_white:     Scaling parameter for the white frequency modulated noise in sqrt(s),
                                       use `10e-12 * sqrt(1e-3)` for 10 ppt RMS error at 1 kHz cutoff frequency.
        :type coeff_freq_flicker: float, optional
        :param coeff_freq_flicker:    Scaling parameter for the relative flicker frequency modulated noise,
                                       use `10e-12` for 10 ppt error per octave.
        :type coeff_random_drift: float, optional
        :param coeff_random_drift:   Scaling parameter for the random walk drift in sqrt(Hz),
                                       use `10e-9 / sqrt(60*60*24)` for 10 ppb / sqrt(day).
        :type coeff_linear_drift: float, optional
        :param coeff_linear_drift:   Scaling parameter for the relative linear frequency drift in Hz,
                                       use `1e-6 / (60*60*24*365)` for 1 ppm / year.
        :type base_channel: int, optional
        :param base_channel:        base channel to which this signal will be added. If unused, a new channel will be
                                       created.
        :type seed: int, optional
        :param seed:                Seed number for the Pseudo-random number generator. Use -1 to use the current time as
                                       seed.
        """
        _TimeTagger.Experimental_OscillatorSimulation_swiginit(self, _TimeTagger.new_Experimental_OscillatorSimulation(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Experimental_OscillatorSimulation

# Register Experimental_OscillatorSimulation in _TimeTagger:
_TimeTagger.Experimental_OscillatorSimulation_swigregister(Experimental_OscillatorSimulation)
class Experimental_TwoStateExponentialSignalGenerator(Experimental_SignalGeneratorBase):
    r"""Proxy of C++ Experimental::TwoStateExponentialSignalGenerator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        Construct a two-state exponential event channel.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:          reference to a TimeTagger
        :type excitation_time: float
        :param excitation_time: excitation time in seconds.
        :type life_time: float
        :param life_time:       life time of the excited state in seconds
        :type base_channel: int, optional
        :param base_channel:    base channel to which this signal will be added. If unused, a new channel will be
                                   created.
        :type seed: int, optional
        :param seed:            Seed number for the Pseudo-random number generator. Use -1 to use the current time as
                                   seed.
        """
        _TimeTagger.Experimental_TwoStateExponentialSignalGenerator_swiginit(self, _TimeTagger.new_Experimental_TwoStateExponentialSignalGenerator(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Experimental_TwoStateExponentialSignalGenerator

# Register Experimental_TwoStateExponentialSignalGenerator in _TimeTagger:
_TimeTagger.Experimental_TwoStateExponentialSignalGenerator_swigregister(Experimental_TwoStateExponentialSignalGenerator)
class Experimental_ExponentialSignalGenerator(Experimental_SignalGeneratorBase):
    r"""Proxy of C++ Experimental::ExponentialSignalGenerator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        Construct a exponential event channel.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:              reference to a TimeTagger
        :type rate: float
        :param rate:                event rate in herz
        :type base_channel: int, optional
        :param base_channel:        base channel to which this signal will be added. If unused, a new channel will be
                                       created.
        :type seed: int, optional
        :param seed:                Seed number for the Pseudo-random number generator. Use -1 to use the current time as
                                       seed.
        """
        _TimeTagger.Experimental_ExponentialSignalGenerator_swiginit(self, _TimeTagger.new_Experimental_ExponentialSignalGenerator(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Experimental_ExponentialSignalGenerator

# Register Experimental_ExponentialSignalGenerator in _TimeTagger:
_TimeTagger.Experimental_ExponentialSignalGenerator_swigregister(Experimental_ExponentialSignalGenerator)
class Experimental_GammaSignalGenerator(Experimental_SignalGeneratorBase):
    r"""Proxy of C++ Experimental::GammaSignalGenerator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        Construct a gamma event channel.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:              reference to a TimeTagger
        :type alpha: float
        :param alpha:               alpha value of the gamma distribution
        :type beta: float
        :param beta:                beta value of the gamma distribution
        :type base_channel: int, optional
        :param base_channel:        base channel to which this signal will be added. If unused, a new channel will be
                                       created.
        :type seed: int, optional
        :param seed:                Seed number for the Pseudo-random number generator. Use -1 to use the current time as
                                       seed.
        """
        _TimeTagger.Experimental_GammaSignalGenerator_swiginit(self, _TimeTagger.new_Experimental_GammaSignalGenerator(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Experimental_GammaSignalGenerator

# Register Experimental_GammaSignalGenerator in _TimeTagger:
_TimeTagger.Experimental_GammaSignalGenerator_swigregister(Experimental_GammaSignalGenerator)
class Experimental_PatternSignalGenerator(Experimental_SignalGeneratorBase):
    r"""Proxy of C++ Experimental::PatternSignalGenerator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        Construct a pattern event generator.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:        reference to a TimeTagger
        :type sequence: std::vector< long long,std::allocator< long long > >
        :param sequence:      sequence of offsets pattern to be used continuously.
        :type repeat: boolean, optional
        :param repeat:        tells if to repeat the pattern or only generate it once.
        :type start_delay: int, optional
        :param start_delay:   initial delay before the first pattern is applied.
        :type spacing: int, optional
        :param spacing:       delay between pattern repetitions.
        :type base_channel: int, optional
        :param base_channel:  base channel to which this signal will be added. If unused, a new channel will be
                                 created.
        """
        _TimeTagger.Experimental_PatternSignalGenerator_swiginit(self, _TimeTagger.new_Experimental_PatternSignalGenerator(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Experimental_PatternSignalGenerator

# Register Experimental_PatternSignalGenerator in _TimeTagger:
_TimeTagger.Experimental_PatternSignalGenerator_swigregister(Experimental_PatternSignalGenerator)
class Experimental_SimSignalSplitter(IteratorBase):
    r"""Proxy of C++ Experimental::SimSignalSplitter class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", input_channel: "int", ratio: "double"=0.5, seed: "int32_t"=-1):
        r"""
        Construct a signal splitter which will split events from an input channel
        into a left and a right virtual channels.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:        reference to a TimeTagger
        :type input_channel: int
        :param input_channel: channel to be split.
        :type ratio: float, optional
        :param ratio:         bias towards right or left channel.
        :type seed: int, optional
        :param seed:          Seed number for the Pseudo-random number generator. Use -1 to use the current time as
                                 seed.
        """
        _TimeTagger.Experimental_SimSignalSplitter_swiginit(self, _TimeTagger.new_Experimental_SimSignalSplitter(tagger, input_channel, ratio, seed))
    __swig_destroy__ = _TimeTagger.delete_Experimental_SimSignalSplitter

    def getChannels(self) -> "std::vector< int,std::allocator< int > >":
        r"""getChannels(self) -> _IntVector"""
        return _TimeTagger.Experimental_SimSignalSplitter_getChannels(self)

    def getLeftChannel(self) -> "int":
        r"""getLeftChannel(self) -> int"""
        return _TimeTagger.Experimental_SimSignalSplitter_getLeftChannel(self)

    def getRightChannel(self) -> "int":
        r"""getRightChannel(self) -> int"""
        return _TimeTagger.Experimental_SimSignalSplitter_getRightChannel(self)

# Register Experimental_SimSignalSplitter in _TimeTagger:
_TimeTagger.Experimental_SimSignalSplitter_swigregister(Experimental_SimSignalSplitter)
class Experimental_TransformEfficiency(IteratorBase):
    r"""Proxy of C++ Experimental::TransformEfficiency class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", input_channel: "int", efficiency: "double", copy: "bool"=False, seed: "int32_t"=-1):
        r"""
        Construct a transformation that will apply an efficiency filter to an
        specified channel. An efficiency filter will drop events based on an efficiency
        value. A perfect effcincy of 1.0 won't drop any events, an efficiency of 0.5
        will drop half the events.

        Notes: this measurement is a transformation, it will modify the input channel
        unless its copy parameter is set to to true, in that case the modifications will
        be reflected on a virtual channel.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:        reference to a TimeTagger
        :type input_channel: int
        :param input_channel: channel to be filtered.
        :type efficiency: float
        :param efficiency:    efficiency of the transformation. a 0.5 efficiency will drop half the events.
                                 A 1.0 won't drop any.
        :type copy: boolean, optional
        :param copy:          tells if this transformation modifies the input or creates a new virtual channel
                                 with the transformation.
        :type seed: int, optional
        :param seed:          Seed number for the Pseudo-random number generator. Use -1 to use the current time as
                                 seed.
        """
        _TimeTagger.Experimental_TransformEfficiency_swiginit(self, _TimeTagger.new_Experimental_TransformEfficiency(tagger, input_channel, efficiency, copy, seed))
    __swig_destroy__ = _TimeTagger.delete_Experimental_TransformEfficiency

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.Experimental_TransformEfficiency_getChannel(self)

# Register Experimental_TransformEfficiency in _TimeTagger:
_TimeTagger.Experimental_TransformEfficiency_swigregister(Experimental_TransformEfficiency)
class Experimental_TransformGaussianBroadening(IteratorBase):
    r"""Proxy of C++ Experimental::TransformGaussianBroadening class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", input_channel: "int", standard_deviation: "double", copy: "bool"=False, seed: "int32_t"=-1):
        r"""
        Construct a transformation that will apply gaussian brodening to each event in an
        specified channel.

        Notes: this measurement is a transformation, it will modify the input channel
        unless its copy parameter is set to to true, in that case the modifications will
        be reflected on a virtual channel.

        -2 broadening will be limited to 5 times the standard deviation.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:              reference to a TimeTagger
        :type input_channel: int
        :param input_channel:       channel to be transformed.
        :type standard_deviation: float
        :param standard_deviation:  gaussian standard deviation which will affect the broadening
        :type copy: boolean, optional
        :param copy:                tells if this transformation modifies the input or creates a new virtual channel
                                       with the transformation.
        :type seed: int, optional
        :param seed:                Seed number for the Pseudo-random number generator. Use -1 to use the current time as
                                       seed.
        """
        _TimeTagger.Experimental_TransformGaussianBroadening_swiginit(self, _TimeTagger.new_Experimental_TransformGaussianBroadening(tagger, input_channel, standard_deviation, copy, seed))
    __swig_destroy__ = _TimeTagger.delete_Experimental_TransformGaussianBroadening

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.Experimental_TransformGaussianBroadening_getChannel(self)

# Register Experimental_TransformGaussianBroadening in _TimeTagger:
_TimeTagger.Experimental_TransformGaussianBroadening_swigregister(Experimental_TransformGaussianBroadening)
class Experimental_TransformDeadtime(IteratorBase):
    r"""Proxy of C++ Experimental::TransformDeadtime class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", input_channel: "int", deadtime: "double", copy: "bool"=False):
        r"""
        Construct a transformation that will apply deadtime every event, filtering any events
        within the deadtime period.

        Notes: this measurement is a transformation, it will modify the input channel
        unless its copy parameter is set to to true, in that case the modifications will
        be reflected on a virtual channel.


        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:              reference to a TimeTagger
        :type input_channel: int
        :param input_channel:       channel to transform.
        :type deadtime: float
        :param deadtime:            deadtime in seconds.
        :type copy: boolean, optional
        :param copy:                tells if this transformation modifies the input or creates a new virtual channel
                                       with the transformation.
        """
        _TimeTagger.Experimental_TransformDeadtime_swiginit(self, _TimeTagger.new_Experimental_TransformDeadtime(tagger, input_channel, deadtime, copy))
    __swig_destroy__ = _TimeTagger.delete_Experimental_TransformDeadtime

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.Experimental_TransformDeadtime_getChannel(self)

# Register Experimental_TransformDeadtime in _TimeTagger:
_TimeTagger.Experimental_TransformDeadtime_swigregister(Experimental_TransformDeadtime)
class Experimental_TransformCrosstalk(IteratorBase):
    r"""Proxy of C++ Experimental::TransformCrosstalk class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", input_channel: "int", relay_input_channel: "int", delay: "double", tau: "double", copy: "bool"=False):
        r"""
        Construct a transformation that will apply crosstalk effect between an input
        channel and a relay channel.

        Notes: this measurement is a transformation, it will modify the input channel
        unless its copy parameter is set to to true, in that case the modifications will
        be reflected on a virtual channel.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:              reference to a TimeTagger
        :type input_channel: int
        :param input_channel:       channel to transform.
        :type relay_input_channel: int
        :param relay_input_channel: channel that causes the delays
        :type delay: float
        :param delay:               amount of delay triggered by relay channel.
        :type tau: float
        :param tau:                 the decay after which an event of relay input channel has no effect anymore.
        :type copy: boolean, optional
        :param copy:                tells if this transformation modifies the input or creates a new virtual channel
                                       with the transformation.
        """
        _TimeTagger.Experimental_TransformCrosstalk_swiginit(self, _TimeTagger.new_Experimental_TransformCrosstalk(tagger, input_channel, relay_input_channel, delay, tau, copy))
    __swig_destroy__ = _TimeTagger.delete_Experimental_TransformCrosstalk

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.Experimental_TransformCrosstalk_getChannel(self)

# Register Experimental_TransformCrosstalk in _TimeTagger:
_TimeTagger.Experimental_TransformCrosstalk_swigregister(Experimental_TransformCrosstalk)
class Experimental_SimDetector(object):
    r"""Proxy of C++ Experimental::SimDetector class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", input_channel: "int", efficiency: "double"=1.0, darkcount_rate: "double"=0.0, jitter: "double"=0, deadtime: "double"=0.0, seed: "int32_t"=-1):
        r"""
        Construct a simulation of a physical detector for a given channel/signal.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:              reference to a TimeTagger
        :type input_channel: int
        :param input_channel:       channel with the signal passing through the virtual detector
        :type efficiency: float, optional
        :param efficiency:          rate of acceptance for inputs.
        :type darkcount_rate: float, optional
        :param darkcount_rate:      rate of noise in Herz.
        :type jitter: float, optional
        :param jitter:              standard deviation of the gaussian broadening, in seconds.
        :type deadtime: float, optional
        :param deadtime:            deadtime, in seconds.
        :type seed: int, optional
        :param seed:                Seed number for the Pseudo-random number generator. Use -1 to use the current time as
                                       seed.
        """
        _TimeTagger.Experimental_SimDetector_swiginit(self, _TimeTagger.new_Experimental_SimDetector(tagger, input_channel, efficiency, darkcount_rate, jitter, deadtime, seed))
    __swig_destroy__ = _TimeTagger.delete_Experimental_SimDetector

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.Experimental_SimDetector_getChannel(self)

# Register Experimental_SimDetector in _TimeTagger:
_TimeTagger.Experimental_SimDetector_swigregister(Experimental_SimDetector)
class Experimental_SimLifetime(IteratorBase):
    r"""Proxy of C++ Experimental::SimLifetime class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", input_channel: "int", lifetime: "double", emission_rate: "double"=0.1, seed: "int32_t"=-1):
        r"""
        Construct a simulation of a physical exaltation.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:              reference to a TimeTagger
        :type input_channel: int
        :param input_channel:       channel which triggers the exaltation.
        :type lifetime: float
        :param lifetime:            lifetime of the exaltation.
        :type emission_rate: float, optional
        :param emission_rate:       poissonian emission rate for each input event.
        :type seed: int, optional
        :param seed:                Seed number for the Pseudo-random number generator. Use -1 to use the current time as
                                       seed.
        """
        _TimeTagger.Experimental_SimLifetime_swiginit(self, _TimeTagger.new_Experimental_SimLifetime(tagger, input_channel, lifetime, emission_rate, seed))
    __swig_destroy__ = _TimeTagger.delete_Experimental_SimLifetime

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.Experimental_SimLifetime_getChannel(self)

    def registerLifetimeReactor(self, trigger_channel: "int", lifetimes: "_DoubleVector", repeat: "bool") -> "void":
        r"""registerLifetimeReactor(self, trigger_channel, lifetimes, repeat)"""
        return _TimeTagger.Experimental_SimLifetime_registerLifetimeReactor(self, trigger_channel, lifetimes, repeat)

    def registerEmissionReactor(self, trigger_channel: "int", emissions: "_DoubleVector", repeat: "bool") -> "void":
        r"""registerEmissionReactor(self, trigger_channel, emissions, repeat)"""
        return _TimeTagger.Experimental_SimLifetime_registerEmissionReactor(self, trigger_channel, emissions, repeat)

# Register Experimental_SimLifetime in _TimeTagger:
_TimeTagger.Experimental_SimLifetime_swigregister(Experimental_SimLifetime)
class StartStop(IteratorBase):
    r"""
    Image: StartStop.svg

    A simple start-stop measurement.
    This class performs a start-stop measurement between two channels
    and stores the time differences in a histogram. The histogram resolution
    is specified beforehand (*binwidth)* but the histogram range is unlimited.
    It is adapted to the largest time difference that was detected. Thus
    all pairs of subsequent clicks are registered. Only non-empty bins are recorded.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:            Time tagger object instance.
        :type click_channel: int
        :param click_channel:     Channel on which stop clicks are received.
        :type start_channel: int, optional
        :param start_channel:     Channel on which start clicks are received
            (default: 'CHANNEL_UNUSED').
        :type binwidth: int, optional
        :param binwidth:          Bin width in ps (default: 1000).
        """
        _TimeTagger.StartStop_swiginit(self, _TimeTagger.new_StartStop(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_StartStop

    def getData(self) -> "void":
        r"""
        :rtype: void
        :return: An array of tuples (array of shape Nx2) containing the times (in ps) and counts of each bin.
            Only non-empty bins are returned.
        """
        return _TimeTagger.StartStop_getData(self)

# Register StartStop in _TimeTagger:
_TimeTagger.StartStop_swigregister(StartStop)
class SynchronizedMeasurements(object):
    r"""
    The `SynchronizedMeasurements` class allows for synchronizing multiple measurement classes in a way that ensures
    all these measurements to start, stop simultaneously and operate on exactly the same time tags.
    You can pass a Time Tagger proxy-object returned by `getTagger()` to every measurement
    you create. This will simultaneously disable their autostart and register for synchronization.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase"):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger: The time tagger object instance.
        """
        _TimeTagger.SynchronizedMeasurements_swiginit(self, _TimeTagger.new_SynchronizedMeasurements(tagger))
    __swig_destroy__ = _TimeTagger.delete_SynchronizedMeasurements

    def getTagger(self) -> "TimeTaggerBase *":
        r"""
        Returns a proxy tagger object which can be passed to the constructor of a measurement class
        to register the measurements at initialization to the synchronized measurement object.
        Those measurements will not start automatically.

        Notes: 
        The proxy tagger object returned by `getTagger()` is not identical
        with the `TimeTagger` object created by `createTimeTagger()`.
        You can create synchronized measurements with the proxy object the following way:

        .. code-block:: python

            tagger = TimeTagger.createTimeTagger()
            syncMeas = TimeTagger.SynchronizedMeasurements(tagger)
            taggerSync = syncMeas.getTagger()
            counter = TimeTagger.Counter(taggerSync, [1, 2])
            countrate = TimeTagger.Countrate(taggerSync, [3, 4])
        Passing *tagger* as a constructor parameter would lead to the not synchronized behavior.
        """
        return _TimeTagger.SynchronizedMeasurements_getTagger(self)

    def start(self) -> "void":
        r"""Calls `IteratorBase::start()` for every registered measurement in a synchronized way."""
        return _TimeTagger.SynchronizedMeasurements_start(self)

    def startFor(self, capture_duration: "long long", clear: "bool"=True) -> "void":
        r"""
        Calls `IteratorBase::startFor()` for every registered measurement in a synchronized way.

        :type capture_duration: int
        :param capture_duration: Acquisition duration in picoseconds.
        :type clear: boolean, optional
        :param clear: Resets the accumulated data at the beginning (default: True).
        """
        return _TimeTagger.SynchronizedMeasurements_startFor(self, capture_duration, clear)

    def stop(self) -> "void":
        r"""Calls `IteratorBase::stop()` for every registered measurement in a synchronized way."""
        return _TimeTagger.SynchronizedMeasurements_stop(self)

    def clear(self) -> "void":
        r"""Calls `IteratorBase::clear()` for every registered measurement in a synchronized way."""
        return _TimeTagger.SynchronizedMeasurements_clear(self)

    def __waitUntilFinished(self, timeout: "int64_t"=-1) -> "bool":
        r"""
        Equivalent to `IteratorBase::waitUntilFinished()` for synchronized measurements.

        :type timeout: int, optional
        :param timeout: Timeout in milliseconds. Negative value means no timeout, zero returns immediately.
        :rtype: boolean
        :return: True if the synchronized measurements have finished, False on timeout.
        """
        return _TimeTagger.SynchronizedMeasurements___waitUntilFinished(self, timeout)

    def isRunning(self) -> "bool":
        r"""Calls `IteratorBase::isRunning()` for every registered measurement and returns true if any measurement is running."""
        return _TimeTagger.SynchronizedMeasurements_isRunning(self)

    def registerMeasurement(self, measurement: "IteratorBase") -> "void":
        r"""
        Registers the *measurement* object into a pool of the synchronized measurements.

        Notes: Registration of the measurement classes with this method does not synchronize them.
        In order to start/stop/clear these measurements synchronously, call these functions on the
        `SynchronizedMeasurements` object after registering the measurement objects, which should be synchronized.

        :type measurement: :py:class:`IteratorBase`
        :param measurement: Any measurement (`IteratorBase`) object.
        """
        return _TimeTagger.SynchronizedMeasurements_registerMeasurement(self, measurement)

    def unregisterMeasurement(self, measurement: "IteratorBase") -> "void":
        r"""
        Unregisters the *measurement* object out of the pool of the synchronized measurements.

        Notes: This method does nothing if the provided measurement is not currently registered.

        :type measurement: :py:class:`IteratorBase`
        :param measurement: Any measurement (`IteratorBase`) object.
        """
        return _TimeTagger.SynchronizedMeasurements_unregisterMeasurement(self, measurement)

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.this and self.thisown:
            self.__swig_destroy__(self)
            self.thisown = False
            self.this = None
        return False


    def waitUntilFinished(self, timeout=-1):
        r"""waitUntilFinished(self, timeout=-1) -> bool"""
        return _timeout_handler(self.__waitUntilFinished, timeout)


# Register SynchronizedMeasurements in _TimeTagger:
_TimeTagger.SynchronizedMeasurements_swigregister(SynchronizedMeasurements)
class SyntheticSingleTag(IteratorBase):
    r"""
    synthetic trigger timetag generator.

    Creates timetags based on a trigger method. Whenever the user calls the 'trigger'
    method, a timetag will be added to the base_channel.

    This synthetic channel can inject timetags into an existing channel or create a new virtual channel.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        Construct a pulse event generator.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:        reference to a TimeTagger
        :type base_channel: int, optional
        :param base_channel:  base channel to which this signal will be added. If unused, a new channel will be
                                 created.
        """
        _TimeTagger.SyntheticSingleTag_swiginit(self, _TimeTagger.new_SyntheticSingleTag(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_SyntheticSingleTag

    def trigger(self) -> "void":
        r"""Generate a timetag for each call of this method."""
        return _TimeTagger.SyntheticSingleTag_trigger(self)

    def getChannel(self) -> "int":
        r"""getChannel(self) -> int"""
        return _TimeTagger.SyntheticSingleTag_getChannel(self)

# Register SyntheticSingleTag in _TimeTagger:
_TimeTagger.SyntheticSingleTag_swigregister(SyntheticSingleTag)
class TimeDifferences(IteratorBase):
    r"""
    Image: TimeDifferences.svg

    A one-dimensional array of time-difference histograms with the option to include up to two additional channels
    that control how to step through the indices of the histogram array.
    This is a very powerful and generic measurement.
    You can use it to record consecutive cross-correlation, lifetime measurements,
    fluorescence lifetime imaging and many more measurements based on pulsed excitation.
    Specifically, the measurement waits for a tag on the *start_channel*, then measures the time difference between
    the start tag and all subsequent tags on the *click_channel* and stores them in a histogram. If no *start_channel*
    is specified, the *click_channel* is used as *start_channel* corresponding to an auto-correlation measurement.
    The histogram has a number *n_bins* of bins of bin width *binwidth*. Clicks that fall outside the histogram
    range are discarded. Data accumulation is performed independently for all start tags.
    This type of measurement is frequently referred to as 'multiple start, multiple stop' measurement and corresponds
    to a full auto- or cross-correlation measurement.

    The time-difference data can be accumulated into a single histogram or into multiple subsequent histograms.
    In this way, you can record a sequence of time-difference histograms.
    To switch from one histogram to the next one you have to specify a channel that provide switch markers
    (*next_channel* parameter).
    Also you need to specify the number of histograms with the parameter *n_histograms*.
    After each tag on the *next_channel*, the histogram index is incremented by one and reset to zero after
    reaching the last valid index. The measurement starts with the first tag on the *next_channel*.

    You can also provide a synchronization marker that resets the histogram index by specifying a *sync_channel*.
    The measurement starts when a tag on the *sync_channel* arrives with a subsequent tag on *next_channel*.
    When a rollover occurs, the accumulation is stopped until the next sync and subsequent next signal.
    A sync signal before a rollover will stop the accumulation, reset the histogram index and a subsequent
    signal on the *next_channel* starts the accumulation again.

    Typically, you will run the measurement indefinitely until stopped by the user.
    However, it is also possible to specify the maximum number of rollovers of the histogram index.
    In this case, the measurement stops when the number of rollovers has reached the specified value.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        Notes: A rollover occurs on a *next_channel* event while the histogram index is already in the last histogram.
        If *sync_channel* is defined, the measurement will pause at a rollover until a *sync_channel*
        event occurs and continues at the next *next_channel* event.
        With undefined *sync_channel*, the measurement will continue without interruption at histogram index 0.

        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:         Time tagger object instance.
        :type click_channel: int
        :param click_channel:  Channel on which stop clicks are received.
        :type start_channel: int, optional
        :param start_channel:  Channel that sets start times relative to which clicks on the click channel are measured.
        :type next_channel: int, optional
        :param next_channel:   Channel that increments the histogram index.
        :type sync_channel: int, optional
        :param sync_channel:   Channel that resets the histogram index to zero.
        :type binwidth: int, optional
        :param binwidth:       Binwidth in picoseconds.
        :type n_bins: int, optional
        :param n_bins:         Number of bins in each histogram.
        :type n_histograms: int, optional
        :param n_histograms:   Number of histograms.
        """
        _TimeTagger.TimeDifferences_swiginit(self, _TimeTagger.new_TimeDifferences(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_TimeDifferences

    def getData(self) -> "void":
        r"""
        :rtype: void
        :return: A two-dimensional array of size *n_histograms* by *n_bins* containing the histograms in row-major format.
        """
        return _TimeTagger.TimeDifferences_getData(self)

    def getIndex(self) -> "void":
        r"""
        :rtype: void
        :return: A vector of size *n_bins* containing the time bins in ps.
        """
        return _TimeTagger.TimeDifferences_getIndex(self)

    def setMaxCounts(self, max_counts: "uint64_t") -> "void":
        r"""
        Deprecated: Please use `setMaxRollovers()` instead.
        Sets the number of rollovers at which the measurement stops integrating.
        To integrate infinitely, set the value to 0, which is the default value.

        :type max_counts: int
        :param max_counts: Maximum number of sync/next clicks.
        """
        return _TimeTagger.TimeDifferences_setMaxCounts(self, max_counts)

    def setMaxRollovers(self, max_rollovers: "uint64_t") -> "void":
        r"""
        Sets the number of rollovers at which the measurement stops.
        To integrate infinitely, set the value to 0, which is the default value.

        :type max_rollovers: int
        :param max_rollovers: Maximum number of rollovers (histogram index resets).
        """
        return _TimeTagger.TimeDifferences_setMaxRollovers(self, max_rollovers)

    def getHistogramIndex(self) -> "int32_t":
        r"""
        :rtype: int
        :return: The index of the currently processed histogram or the waiting state. Possible return values are:
            - -2: Waiting for an event on *sync_channel* (only if *sync_channel* is defined)
            - -1: Waiting for an event on *next_channel* (only if *sync_channel* is defined)
            - 0 ... (*n_histograms* - 1): Index of the currently processed histogram.
        """
        return _TimeTagger.TimeDifferences_getHistogramIndex(self)

    def getCounts(self) -> "uint64_t":
        r"""
        :rtype: int
        :return: The number of rollovers (histogram index resets).
        """
        return _TimeTagger.TimeDifferences_getCounts(self)

    def ready(self) -> "bool":
        r"""
        :rtype: boolean
        :return: True when the required number of rollovers set by `setMaxCounts()` has been reached.
        """
        return _TimeTagger.TimeDifferences_ready(self)

# Register TimeDifferences in _TimeTagger:
_TimeTagger.TimeDifferences_swigregister(TimeDifferences)
class Histogram(IteratorBase):
    r"""
    Image: Histogram.svg

    Accumulate time differences into a histogram.
    This is a simple multiple start, multiple stop measurement. This is a special
    case of the more general `TimeDifferences` measurement.
    Specifically, the measurement waits for clicks on the *start_channel*,
    and for each start click, it measures the time difference between
    the start clicks and all subsequent clicks on the *click_channel*
    and stores them in a histogram.
    The histogram range and resolution are specified by the number of bins
    and the bin width specified in ps. Clicks that fall outside the histogram range are ignored.
    Data accumulation is performed independently for all start clicks.
    This type of measurement is frequently referred to as a 'multiple start, multiple stop'
    measurement and corresponds to a full auto- or cross-correlation measurement.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:            Time tagger object instance.
        :type click_channel: int
        :param click_channel:     Channel on which clicks are received.
        :type start_channel: int, optional
        :param start_channel:     Channel on which start clicks are received
            (default: 'CHANNEL_UNUSED').
        :type binwidth: int, optional
        :param binwidth:          Bin width in ps (default: 1000).
        :type n_bins: int, optional
        :param n_bins:            The number of bins in the histogram (default: 1000).
        """
        _TimeTagger.Histogram_swiginit(self, _TimeTagger.new_Histogram(*args, **kwargs))
    __swig_destroy__ = _TimeTagger.delete_Histogram

    def getData(self) -> "void":
        r"""
        :rtype: void
        :return: A one-dimensional array of size *n_bins* containing the histogram.
        """
        return _TimeTagger.Histogram_getData(self)

    def getIndex(self) -> "void":
        r"""
        :rtype: void
        :return: A vector of size *n_bins* containing the time bins in ps.
        """
        return _TimeTagger.Histogram_getIndex(self)

# Register Histogram in _TimeTagger:
_TimeTagger.Histogram_swigregister(Histogram)
class TimeDifferencesND(IteratorBase):
    r"""
    Image: TimeDifferencesND.svg

    This is an implementation of the `TimeDifferences` measurement class
    that extends histogram indexing into multiple dimensions.
    Please read the documentation of `TimeDifferences` first.

    It captures many multiple start - multiple stop histograms, but with many asynchronous *next_channel* triggers.
    After each tag on each *next_channel*, the histogram index of the associated dimension is
    incremented by one and reset to zero after reaching the last valid index.
    The elements of the parameter *n_histograms* specify the number of histograms per dimension.
    The accumulation starts when *next_channel* has been triggered on all dimensions.

    You should provide a synchronization trigger by specifying a *sync_channel* per dimension.
    It will stop the accumulation when an associated histogram index rollover occurs.
    A sync event will also stop the accumulation and reset the histogram index of the associated dimension.
    A subsequent event on the corresponding *next_channel* will start the accumulation again.
    The synchronization is done asynchronously, so an event on the *next_channel* increments the histogram index
    even if the accumulation is stopped. The accumulation will start when a tag on the sync_channel arrives
     with a subsequent tag on *next_channel* for all dimensions.

    Please use `TimeTaggerBase::setInputDelay()` to adjust the latency of all channels.
    In general, the order of the provided triggers including maximum jitter should be:

    old start trigger -> all sync triggers -> all next triggers -> new start trigger.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", click_channel: "int", start_channel: "int", next_channels: "_IntVector", sync_channels: "_IntVector", n_histograms: "_IntVector", binwidth: "long long", n_bins: "int32_t"):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:          Time tagger object instance.
        :type click_channel: int
        :param click_channel:   Channel on which stop clicks are received.
        :type start_channel: int
        :param start_channel:   Channel that sets start times relative to which clicks on the click channel are measured.
        :type next_channels: std::vector< int,std::allocator< int > >
        :param next_channels:   Vector of channels that increments the histogram index.
        :type sync_channels: std::vector< int,std::allocator< int > >
        :param sync_channels:   Vector of channels that resets the histogram index to zero.
        :type n_histograms: std::vector< int32_t,std::allocator< int32_t > >
        :param n_histograms:    Vector of numbers of histograms per dimension.
        :type binwidth: int
        :param binwidth:        Width of one histogram bin in ps.
        :type n_bins: int
        :param n_bins:          Number of bins in each histogram.
        """
        _TimeTagger.TimeDifferencesND_swiginit(self, _TimeTagger.new_TimeDifferencesND(tagger, click_channel, start_channel, next_channels, sync_channels, n_histograms, binwidth, n_bins))
    __swig_destroy__ = _TimeTagger.delete_TimeDifferencesND

    def getData(self) -> "void":
        r"""
        :rtype: void
        :return: A two-dimensional array of size *M* by *n_bins* containing the histograms in row-major
            format, where *M* is the total number of histograms, calculated as the product of all elements in *n_histograms*.
            The histograms are indexed according to the multidimensional shape defined by *n_histograms*,
            with each row representing a unique combination of histogram trigger indices.
            The ordering of histograms in the output is based on the standard left-to-right index mapping (`std::layout_left`),
            with the leftmost index in `n_histograms` changing most frequently when counting through the histograms. The
            position of each histogram is computed as a linear offset using strides that increase from left to right.
        """
        return _TimeTagger.TimeDifferencesND_getData(self)

    def getIndex(self) -> "void":
        r"""
        :rtype: void
        :return: A vector of size *n_bins* containing the time bins in ps.
        """
        return _TimeTagger.TimeDifferencesND_getIndex(self)

    def setMaxRollovers(self, max_rollovers: "_ULongVector") -> "void":
        r"""
        Sets the maximum number of rollovers per direction at which the measurement stops.
           It stops after the first maximum is met.
        To integrate infinitely, set the value to 0, which is the default value.

        :type max_rollovers: std::vector< uint64_t,std::allocator< uint64_t > >
        :param max_rollovers: Maximum number of rollovers (histogram index resets).
        """
        return _TimeTagger.TimeDifferencesND_setMaxRollovers(self, max_rollovers)

    def getHistogramIndex(self) -> "void":
        r"""
        :rtype: void
        :return: The indices of the currently processed histogram or the waiting state. Possible return
            values are:
            - -2: Waiting for an event on *sync_channel* (only if *sync_channel* is defined)
            - -1: Waiting for an event on *next_channel* (only if *sync_channel* is defined)
            - 0 ... (*n_histograms* - 1): Index of the currently processed histogram.
        """
        return _TimeTagger.TimeDifferencesND_getHistogramIndex(self)

    def getRollovers(self) -> "void":
        r"""
        :rtype: void
        :return: The number of rollovers (histogram index resets).
        """
        return _TimeTagger.TimeDifferencesND_getRollovers(self)

# Register TimeDifferencesND in _TimeTagger:
_TimeTagger.TimeDifferencesND_swigregister(TimeDifferencesND)
class TimeTagStream(IteratorBase):
    r"""
    Allows user to access a copy of the time tag stream. It allocates a memory buffer of the size *max_tags*
    which is filled with the incoming time tags that arrive from the specified channels.
    User shall call `getData()` method periodically to obtain the current buffer
    containing timetags collected. This action will return the current buffer object and create another empty buffer
    to be filled until the next call to `getData()`.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", n_max_events: "uint64_t", channels: "_IntVector"):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:        Time tagger object instance.
        :type n_max_events: int
        :param n_max_events:  Buffer size for storing time tags.
        :type channels: std::vector< int,std::allocator< int > >
        :param channels:      List of channels to be captured.
        """
        _TimeTagger.TimeTagStream_swiginit(self, _TimeTagger.new_TimeTagStream(tagger, n_max_events, channels))
    __swig_destroy__ = _TimeTagger.delete_TimeTagStream

    def getData(self) -> "TimeTagStreamBuffer":
        r"""
        Returns a `TimeTagStreamBuffer` object and clears the internal buffer of the `TimeTagStream` measurement.
        Clearing the internal buffer on each call to `getData()` guarantees that consecutive calls
        to this method will return every time-tag only once.
        Data loss may occur if `getData()` is not called frequently enough with respect to *n_max_events*.

        :rtype: :py:class:`TimeTagStreamBuffer`
        :return: Buffer object containing timetags collected.
        """
        return _TimeTagger.TimeTagStream_getData(self)

    def getCounts(self) -> "uint64_t":
        r"""
        :rtype: int
        :return: The number of stored tags since the last call to `getData()`.
        """
        return _TimeTagger.TimeTagStream_getCounts(self)

# Register TimeTagStream in _TimeTagger:
_TimeTagger.TimeTagStream_swigregister(TimeTagStream)
class TimeTagStreamBuffer(object):
    r"""Proxy of C++ TimeTagStreamBuffer class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _TimeTagger.delete_TimeTagStreamBuffer

    def getTimestamps(self) -> "void":
        r"""
        Returns an array of timestamps.

        :rtype: void
        :return: Event timestamps in picoseconds for all chosen channels.
        """
        return _TimeTagger.TimeTagStreamBuffer_getTimestamps(self)

    def getChannels(self) -> "void":
        r"""
        Returns an array of channel numbers for every timestamp.

        :rtype: void
        :return: Channel number for each detected event.
        """
        return _TimeTagger.TimeTagStreamBuffer_getChannels(self)

    def getOverflows(self) -> "void":
        r"""Deprecated: Since version 2.5. Please use `getEventTypes()` instead."""
        return _TimeTagger.TimeTagStreamBuffer_getOverflows(self)

    def getEventTypes(self) -> "void":
        r"""
        Returns an array of event type for every timestamp.
        See, -tag-format}.
        The method returns plain integers, but you can use `Tag::Type` to compare the values.

        :rtype: void
        :return: Event type value for each detected event.
        """
        return _TimeTagger.TimeTagStreamBuffer_getEventTypes(self)

    def getMissedEvents(self) -> "void":
        r"""
        Returns an array of missed event counts during an stream overflow situation.

        :rtype: void
        :return: Missed events value for each detected event.
        """
        return _TimeTagger.TimeTagStreamBuffer_getMissedEvents(self)
    size: "uint64_t" = property(_TimeTagger.TimeTagStreamBuffer_size_get, _TimeTagger.TimeTagStreamBuffer_size_set, doc=r"""
    Number of events stored in the buffer. If the size equals the maximum size of the buffer set in
    `TimeTagStream` via *n_max_events*, events have likely been discarded.
    """)
    hasOverflows: "bool" = property(_TimeTagger.TimeTagStreamBuffer_hasOverflows_get, _TimeTagger.TimeTagStreamBuffer_hasOverflows_set, doc=r"""
    Returns True if a stream overflow was detected in any of the tags received.
    Note: this is independent of an overflow of the internal buffer of `TimeTagStream`.
    """)
    tStart: "long long" = property(_TimeTagger.TimeTagStreamBuffer_tStart_get, _TimeTagger.TimeTagStreamBuffer_tStart_set, doc=r"""Return the data-stream time position when the `TimeTagStream` or `FileWriter` started data acquisition.""")
    tGetData: "long long" = property(_TimeTagger.TimeTagStreamBuffer_tGetData_get, _TimeTagger.TimeTagStreamBuffer_tGetData_set, doc=r"""
    Return the data-stream time position of the call to `TimeTagStream::getData()` method
    that created this object.
    """)

    def __enter__(self):
        return self

    def __exit__(self, type, value, tb):
        if self.this and self.thisown:
            self.__swig_destroy__(self)
            self.thisown = False
            self.this = None
        return False


# Register TimeTagStreamBuffer in _TimeTagger:
_TimeTagger.TimeTagStreamBuffer_swigregister(TimeTagStreamBuffer)
class TriggerOnCountrate(IteratorBase):
    r"""
    Measures the count rate inside a rolling time window and emits tags when a defined
    *reference_countrate* is crossed.
    A `TriggerOnCountrate` object provides two virtual channels: the *above* and the *below* channels.
    The *above* channel is triggered when the count rate
    exceeds the threshold (transition from *below* to *above)*. The *below* channel is triggered when the count rate
    falls below the threshold (transition from *above* to *below)*.

    To avoid the emission of multiple trigger tags in the transition area, the *hysteresis* count rate modifies
    the threshold with respect to the transition direction:
    An event in the *above* channel will be triggered when the channel is in the *below* state and rises to
    `reference_countrate + hysteresis` or above.
    Vice versa, the *below* channel fires when the channel is in the *above* state and falls to the limit of
    `reference_countrate - hysteresis` or below.

    The time tags are always injected at the end of the integration window.
    You can use the `DelayedChannel` to adjust the temporal position of the trigger tags with respect to the integration
    time window.

    The very first tag of the virtual channel will be emitted a *time_window* after the instantiation of the object and
    will reflect the current state, so either *above* or *below*.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tagger: "TimeTaggerBase", input_channel: "int", reference_countrate: "double", hysteresis: "double", time_window: "long long"):
        r"""
        :type tagger: :py:class:`TimeTaggerBase`
        :param tagger:              Time Tagger object instance.
        :type input_channel: int
        :param input_channel:       Channel number of the channel whose count rate will control the trigger channels.
        :type reference_countrate: float
        :param reference_countrate: The reference count rate in Hz that separates the *above* range from the *below*
                                       range.
        :type hysteresis: float
        :param hysteresis:          The threshold count rate in Hz for transitioning to the *above* threshold state
                                       is `countrate >= reference_countrate + hysteresis`, whereas it is `countrate <=
                                       reference_countrate - hysteresis` for transitioning to the *below* threshold state.
                                       The hysteresis avoids the emission of multiple trigger tags upon a single transition.
        :type time_window: int
        :param time_window:         Rolling time window size in picoseconds. The count rate is analyzed within this time
                                       window and compared to the threshold count rate.
        """
        _TimeTagger.TriggerOnCountrate_swiginit(self, _TimeTagger.new_TriggerOnCountrate(tagger, input_channel, reference_countrate, hysteresis, time_window))
    __swig_destroy__ = _TimeTagger.delete_TriggerOnCountrate

    def getChannelAbove(self) -> "int":
        r"""Get the channel number of the *above* channel."""
        return _TimeTagger.TriggerOnCountrate_getChannelAbove(self)

    def getChannelBelow(self) -> "int":
        r"""Get the channel number of the *below* channel."""
        return _TimeTagger.TriggerOnCountrate_getChannelBelow(self)

    def getChannels(self) -> "std::vector< int,std::allocator< int > >":
        r"""Get both virtual channel numbers: [`getChannelAbove()`, `getChannelBelow()`]"""
        return _TimeTagger.TriggerOnCountrate_getChannels(self)

    def getCurrentCountrate(self) -> "double":
        r"""Get the current count rate averaged within the *time_window*."""
        return _TimeTagger.TriggerOnCountrate_getCurrentCountrate(self)

    def injectCurrentState(self) -> "bool":
        r"""
        Emits a time tag into the respective channel according to the current state.
        This is useful if you start a new measurement that requires the information.
        The function returns whether it was possible to inject the event.
        The injection is not possible if the Time Tagger is in overflow mode or the time window has not passed yet.
        The function call is non-blocking.
        """
        return _TimeTagger.TriggerOnCountrate_injectCurrentState(self)

    def isAbove(self) -> "bool":
        r"""Returns whether the Virtual Channel is currently in the *above* state."""
        return _TimeTagger.TriggerOnCountrate_isAbove(self)

    def isBelow(self) -> "bool":
        r"""Returns whether the Virtual Channel is currently in the *below* state."""
        return _TimeTagger.TriggerOnCountrate_isBelow(self)

# Register TriggerOnCountrate in _TimeTagger:
_TimeTagger.TriggerOnCountrate_swigregister(TriggerOnCountrate)

class CustomMeasurement(CustomMeasurementBase):
    INCOMING_TAGS_DTYPE = _np.dtype({'names':['type','missed_events','channel','time'], 'formats':['u1','<u2','<i4','<i8'], 'offsets':[0,2,4,8], 'itemsize':16}, align=True)

    def __init__(self, time_tagger):
        CustomMeasurementBase.__init__(self, time_tagger)
        self.showError = True

        class TTMutex(object):
            def __init__(self, iter):
                self.iter = iter
            def __enter__(self):
                self.iter._lock()
                return self
            def __exit__(self, type, value, tb):
                self.iter._unlock()
                return False
        self.mutex = TTMutex(self)

    def stop(self, *args, **kwargs):
        if self.this:
            CustomMeasurementBase.stop(self, *args, **kwargs)

    def __exit__(self, *args, **kwargs):
        if self.this:
            self.stop()
        return CustomMeasurementBase.__exit__(self, *args, **kwargs)

    def process(self, incoming_tags, begin_time, end_time):
        if self.showError:
            print("ERROR: The process() method of the Python-CustomMeasurement must be overwritten!")
            self.showError = False

    def next_impl_cs(self, incoming_tags, begin_time, end_time):
        tags = incoming_tags.view(self.INCOMING_TAGS_DTYPE)
        try:
            self.process(tags, begin_time, end_time)
        except Exception as inst:
            _traceback.print_exc()
            raise inst

        return False

# Stop all custom measurements on shutdown. Else the virtual function might still be called while the interpreter is going to shut down.
__import__('atexit').register(CustomMeasurementBase.stop_all_custom_measurements)

def setLogger(callback):
    """
    Sets the notifier callback which is called for each log message

    :param callback: The callback for the log message, like lambda level, msg: print(msg)
    :return: returns nothing
    """
    class PyLogger(CustomLogger):
        def __init__(self, callback):
            CustomLogger.__init__(self)
            self.callback = callback
            self.enable()
        def Log(self, level, message):
            self.callback(level, message)
    setLogger.logger = None
    if callback:
        setLogger.logger = PyLogger(callback)
setLogger.logger = None

def freeTimeTagger(tagger: "TimeTaggerBase") -> "None":
    r"""freeTimeTagger(tagger) -> None"""
    if not isinstance(tagger, TimeTaggerBase):
        raise TypeError('in method \'freeTimeTagger\', argument 1 of type \'TimeTaggerBase\'')
    if tagger.this and tagger.thisown:
        __freeTimeTagger(tagger)
        tagger.thisown = False
        tagger.this = None


class Experimental:
    pass

expt_classes = [(key,val) for key, val in locals().items() if key.startswith("Experimental_")]
for class_name, class_ptr in expt_classes:
    setattr(Experimental,
            class_name[len("Experimental_"):],
            class_ptr)
    del locals()[class_name]
del class_ptr
del class_name
del expt_classes



class CoincidenceTimestamp(_enum.IntEnum):
    Last = CoincidenceTimestamp_Last
    Average = CoincidenceTimestamp_Average
    First = CoincidenceTimestamp_First
    ListedFirst = CoincidenceTimestamp_ListedFirst

class Resolution(_enum.IntEnum):
    Standard = Resolution_Standard
    HighResA = Resolution_HighResA
    HighResB = Resolution_HighResB
    HighResC = Resolution_HighResC

class ChannelEdge(_enum.IntFlag):
    All = ChannelEdge_All
    Rising = ChannelEdge_Rising
    Falling = ChannelEdge_Falling
    HighResAll = ChannelEdge_HighResAll
    HighResRising = ChannelEdge_HighResRising
    HighResFalling = ChannelEdge_HighResFalling
    StandardAll = ChannelEdge_StandardAll
    StandardRising = ChannelEdge_StandardRising
    StandardFalling = ChannelEdge_StandardFalling

class UsageStatisticsStatus(_enum.IntEnum):
    Disabled = UsageStatisticsStatus_Disabled
    Collecting = UsageStatisticsStatus_Collecting
    CollectingAndUploading = UsageStatisticsStatus_CollectingAndUploading

class FrontendType(_enum.IntEnum):
    Undefined = FrontendType_Undefined
    WebApp = FrontendType_WebApp
    Firefly = FrontendType_Firefly
    Pyro5RPC = FrontendType_Pyro5RPC
    UserFrontend = FrontendType_UserFrontend

class LanguageUsed(_enum.IntEnum):
    Cpp = LanguageUsed_Cpp
    Python = LanguageUsed_Python
    Csharp = LanguageUsed_Csharp
    Matlab = LanguageUsed_Matlab
    Labview = LanguageUsed_Labview
    Mathematica = LanguageUsed_Mathematica
    Unknown = LanguageUsed_Unknown

class AccessMode(_enum.IntFlag):
    Listen = AccessMode_Listen
    SynchronousListen = AccessMode_SynchronousListen
    Control = AccessMode_Control
    SynchronousControl = AccessMode_SynchronousControl

class TagType(_enum.IntEnum):
    TimeTag = Tag.Type_TimeTag
    Error = Tag.Type_Error
    OverflowBegin = Tag.Type_OverflowBegin
    OverflowEnd = Tag.Type_OverflowEnd
    MissedEvents = Tag.Type_MissedEvents

class GatedChannelInitial(_enum.IntEnum):
    Closed = GatedChannelInitial_Closed
    Open = GatedChannelInitial_Open

class FpgaLinkInterface(_enum.IntEnum):
    SFPP_10GE = FpgaLinkInterface_SFPP_10GE
    QSFPP_40GE = FpgaLinkInterface_QSFPP_40GE



