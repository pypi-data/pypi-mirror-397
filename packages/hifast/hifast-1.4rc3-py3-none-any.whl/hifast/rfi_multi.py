# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/S3-rfi.ipynb (unless otherwise specified).

__all__ = ['IO']

# Cell
from .utils.io import *
from copy import deepcopy
#nbdev_comment _all_ = ['parser']

# Internal Cell
sep_line = '##'+'#'*70+'##'
parser = ArgumentParser(prog=f"python -m hifast.{os.path.basename(sys.argv[0])[:-3]}",
                        formatter_class=formatter_class, allow_abbrev=False,
                        description='rfi_multi', )
add_common_argument(parser)
parser.add_argument('fpath',
                    help='input baselined spectra file path.')
# not support --frange
parser.add_argument('--no_radec', action='store_true', not_in_write_out_config_file=True,
                    help="don't check or add ra dec")
parser.add_argument('--all_beams', type=bool_fun, choices=[True, False], default='True',
                   help='find time rfi after averaging all 19 beams')

parser.add_argument('--replace_rfi', type=bool_fun, choices=[True, False], default='False',
                   help='If True, replace find rfi as np.nan')
                    #, otherwise store ``is_rfi`` array in output file')

group = parser.add_argument_group(f'*mark rfi from a DS9 regions file\n{sep_line}')
group.add_argument('--reg_from', default='none',
                   help='If not set as ``none``, mark rfi through regions from a DS9 format regions file. ' + \
                        "If set as ``shared``, beams will shared one region file" + \
                        "If set as ``default``, will try to find the file:  the input spectra  fpath + '.reg'. If set as other string, will be treated as a file path")

#################### Time domain continuous RFI ######################
group = parser.add_argument_group(f'*Time domain continuous RFI\n{sep_line}')
group.add_argument('--tr', '--time_rfi', type=bool_fun, choices=[True, False], default='False',
                   help='')
group.add_argument('--tr_s_method_t', default='gaussian',
                   help='smoothing method along time axis')
group.add_argument('--tr_s_sigma_t', type=int, default=10,
                   help='')
group.add_argument('--tr_s_method_freq', default='gaussian',
                   help='smoothing method along time freq')
group.add_argument('--tr_s_sigma_freq', type=float, default=5,
                   help='')
group.add_argument('--tr_n_continue', type=int, default=100,
                   help='')
group.add_argument('--tr_times', type=float, default=6.,
                   help='')
group.add_argument('--tr_times_s', type=float, default=1.5,
                   help='')
group.add_argument('--ext_add', type=int, default=0,
                   help='extend rfi range')
group.add_argument('--ext_frac', type=float, default=0.,
                   help='between 0 and 1, extend rfi range')
# parser.add_argument('--cross_frac', type=float, default=0.,
#                    help='between 0 and 1')

####################### Narrowband single channel RFI #########################
group = parser.add_argument_group(f'*Narrowband single channel RFI\n{sep_line}')
group.add_argument('--nr', '--narr_rfi', type=bool_fun, choices=[True, False], default='False',
                   help='find long time narrow single channel rfi')
group.add_argument('--nr_mean_times', type=float, default=100,
                   help="first threhold, rfi is this times of median value after mean along time axis; \
                   ")
group.add_argument('--nr_diff_times', type=float, default=30,
                   help="second threhold, sharp edge on time axis. diff above this times of median will be recognized; \
                   ")
group.add_argument('--nr_rfi_width_lim',type=int, nargs=2, default= [0, 2],
                   help='rfi channel width limit')
group.add_argument('--nr_mask_rms_times',type = float, default=0,
                   help='if == 0, mask whole channel; if > 0, mask RMS above ~ times of RMS. ')

####################### Polarized RFI #######################################
group = parser.add_argument_group(f'*Polarized RFI\n{sep_line}')
group.add_argument('--pr', '--polar_rfi', type=bool_fun, choices=[True, False], default='False',
                   help='')
group.add_argument('--pr_s_sigma', type=float, default=5,
                   help='gaussian smooth size for spectra smoothing along time axis')
group.add_argument('--pr_times', type=float, default=6,
                   help='')
group.add_argument('--pr_times_s', type=float, default=1,
                   help='')

####################### 19Beam RFI #######################################
group = parser.add_argument_group(f'*19Beam RFI\n{sep_line}')
group.add_argument('--b19', '--beam19_rfi', type=bool_fun, choices=[True, False], default='False',
                   help='Enable or disable 19-beam RFI detection')
group.add_argument('--b19_times', type=float, default=3,
                   help='Threshold multiplier for 19-beam RFI detection')
group.add_argument('--b19_min_percent', type=float, default=0.23,
                   help='Minimum percent of beams that must exceed the threshold to classify as RFI')

###################### Time domain uncontinuous RFI #########################
parser.add_argument('--rms_frange', type=float, nargs=2,
                   help='freq range to compute rms, NEED TO DEFINE when sf, pdr')
parser.add_argument('--mw_frange', type=float, nargs=2,
                   help='milky way freq range')
## long freq time rfi
group = parser.add_argument_group(f'*Long freq \n{sep_line}')
group.add_argument('--lf', '--long_freq', type=bool_fun, choices=[True, False], default='False',
                   help='find time rfi')
group.add_argument('--lsn_thr_type', default='input_med_times', 
                   choices=['input_med_times','input_absmed_times','input_posimed_times'],
                   help='input times of median value, its absolute value, or add an offset to make it positive.\
                   used for lf, sf, nr')
group.add_argument('--lf_frange', type=float, nargs=2, default = [1400, 1500],
                   help='freq range exists long-freq time rfi')
group.add_argument('--lf_mean_times', type=float, default=2,
                   help="first threhold, rfi is this times of median value after mean along time axis; \
                   ")
group.add_argument('--lf_diff_times', type=float, default=0,
                   help='set 0 and do not change this parameter')
group.add_argument('--lf_rfi_last',type=float, nargs=2, default= [50, float("INF")],
                   help='rfi lasts at least ~ spec numbers')
group.add_argument('--lf_ext_add',type = int,default=50,
                   help='extend edge')
group.add_argument('--lf_mask_rms_times',type = float, default=-1,
                   help='if == -1, mask whole spec; if == 0, only mask region in frange; \
                   if > 0, mask RMS above ~ times of RMS. ')
## short freq time rfi
group = parser.add_argument_group(f'*Short freq \n{sep_line}')
group.add_argument('--sf', '--short_freq', type=bool_fun, choices=[True, False], default='False',
                   help='find time rfi')
group.add_argument('--sf_use_time_only', type=bool_fun, choices=[True, False], default='False',
                   help="if true, only use 'is_timerfi' of 19 beams")
group.add_argument('--sf_frange', type=float, nargs=2, default = [1370, 1390],
                   help='freq range exists short-freq time rfi')
group.add_argument('--sf_frange_step',type = int,
                   help='if sf_frange is None and sf_file is None, cycle in whole freq band.')
group.add_argument('--sf_file',
                   help='freq range exists short-freq time rfi npy filename')
group.add_argument('--sf_mean_times', type=float, default=3,
                   help="first threhold, rfi is this times of median value after mean along time axis; \
                   ")
group.add_argument('--sf_diff_times', type=float, default=1,
                   help="second threhold, sharp edge on time axis. diff above this times of median will be recognized; \
                   ")
group.add_argument('--sf_rfi_last',type=float, nargs=2, default=[10,float("INF")],
                   help='rfi lasts at least 10 spec numbers')
group.add_argument('--sf_ext_add',type = int,default=0,
                   help='extend edge')
group.add_argument('--sf_mask_rms_times',type = float, default=3,
                   help='mask from peak to 2 sides, until RMS drops to 3 times of RMS')

################## Period 8 MHZ RFI #######################
parser.add_argument('--rms_sigma', type=float, default =6,
                   help='gauss filter sigma to compute real rms')
## smooth
group = parser.add_argument_group('preprocessing before finding pdr')
group.add_argument('--s_method_t', default='none', choices=['none', 'gaussian', 'boxcar', 'median'],
                   help='')
group.add_argument('--s_sigma_t', type=int, default=5,
                   help='')
group.add_argument('--s_method_freq', default='none', choices=['none', 'median', 'gaussian', 'boxcar'],
                   help='')
group.add_argument('--s_sigma_freq', type=float, default=5,
                   help='')
## find rfi
group = parser.add_argument_group(f'*find Period 8MHz \n{sep_line}')
group.add_argument('--pdr', '--period_rfi', type=bool_fun, choices=[True, False], default='False',
                   help='find period 8 MHz rfi')
group.add_argument('--rfi_thr', type=float, default=3,
                   help='default 3 times of rms threshold')
group.add_argument('--rfi_width_lim', type=float, default=10,
                   help='rfi should contain more channels than limit')
group.add_argument('--ext_sec', type=int, default=30,
                   help='extend channel number of start and end of each section')
group.add_argument('--freq_thr', type=float, default=.5,
                   help='estimate error when looking for peaks to polyfit')
group.add_argument('--freq_step', type=float, default = 8.1,
                   help='rfi period MHz')
group.add_argument('--rfi_groups', default = 'two_groups', choices=['two_groups','three_groups','all'],
                    help='divide rfi into 2 or 3 groups')

## mask rfi
group = parser.add_argument_group('mask 8 Mhz RFI')
group.add_argument('--mask_RFI_method',default='fixed_freq',choices=['2_sides','fixed_freq'],
                     help='from center to two sides, or use a fixed freq width')
group.add_argument('--freq_from_theory', type=float, default=.5,
                    help='mask width from theory center')
group.add_argument('--mask_thr', type=float, default=.7,
                   help=' above ~ times of rms threshold will be masked')
group.add_argument('--ext_edge', type=int, default= 0,
                   help=' extend result channel on freq axis')

### 2 sides
group.add_argument('--small_rfi_times',type=float, default=2,
                    help='small rfi below, eg.2*RMS will not be masked')
group.add_argument('--chan_step' ,type=int, default=5,
                    help='channel step when walk from center to two sides')
### fixed freq
group.add_argument('--mask_all_theory', action= 'store_true',
                   help='mask_all_theory')
### time coherent
group.add_argument('--time_coherent_per', type=float, default = 1,
                   help='rfi in one freq appears more than emmm, maybe 0.7, mask them all on time axis.')

# Cell
class IO(BaseIO):
    ver = 'old'
    def _get_fpart(self,):
        return '-19rfi'

    def _import_m(self,):
        """
        need modify this function
        """
        super()._import_m()
        global h5py, OrderedDict, np

        import h5py
        from collections import OrderedDict
        import numpy as np
        
    def get_from_regions(self,):

        from .core.regions import read_regions, replace_region

        args = self.args
        if args.reg_from is None or args.reg_from == 'none':
            return None
        if args.reg_from == 'default':
            print('try to find the default regions file')
            fpath_reg = args.fpath + '.reg'
            if not os.path.exists(fpath_reg):
                print(f'can not find the default regions file {fpath_reg}, skipping')
                return None
        elif args.reg_from == 'shared':
            from glob import glob
            fpath_regs = glob(os.path.dirname(args.fpath) + '/*.reg')
            length = len(fpath_regs)
            if length == 1:
                fpath_reg = fpath_regs[0]
            elif length == 0:
                print('can not find any specified regions files, skipping')
                return None
            else:
                raise FileError('Too many regions file! All 19 beams should share only one.')
        else:
            nB = get_nB(args.fpath)
            project = get_project(args.fpath)
            date = get_date_from_path(args.fpath)
            fpath_reg = sub_patten(args.reg_from, date=date, nB=f'{nB:02d}', project=project)
            if not os.path.exists(fpath_reg):
                print(f'can not find the specified regions file {fpath_reg}, skipping')
                return None
        print(f'read regions from {fpath_reg}')
        regions = read_regions(fpath_reg)
        if regions is None:
            return None
        is_rfi = np.full(self.s2p.shape[:2], False)
        replace_region(is_rfi, regions, fill_value=True)
        return is_rfi

    def get_tr(self,):
        """
        Time domain continuous RFI
        """
        args = self.args
        from .core.rfi_t import mask_rfi_t
        fit_kwargs = {}
        keys = ['tr_n_continue',
                'tr_s_method_freq',
                'tr_s_method_t',
                'tr_s_sigma_freq',
                'tr_s_sigma_t',
                'tr_times',
                'tr_times_s',
                'ext_add', 'ext_frac']
        for key in keys[:-2]:
            fit_kwargs[key[3:]] = getattr(args, key)
        for key in keys[-2:]:
            fit_kwargs[key] = getattr(args, key)

        return mask_rfi_t(self.freq, self.s2p, method='smooth', **fit_kwargs)

    def get_pr(self,):
        """
        Polarized RFI
        """
        args = self.args
        from .core.rfi_polar import mask_rfi_p
        fit_kwargs = {}
        keys = ['pr_s_sigma',
                'pr_times',
                'pr_times_s',
                'ext_add', 'ext_frac']
        for key in keys[:-2]:
            fit_kwargs[key[3:]] = getattr(args, key)
        for key in keys[-2:]:
            fit_kwargs[key] = getattr(args, key)
        p_rfi = mask_rfi_p(self.s2p_mask, **fit_kwargs)
        p_rfi[:,self.protect_use] = False
        return p_rfi

    def get_nr(self):
        """
        Narrowband single channel RFI
        """
        args = self.args
        T = np.nanmean(self.s2p_mask, axis = 2)
        from .ripple.mark_timeRFI import mask_freq_rfi

        narr_args = {}
        keys = ['nr_mean_times',
                'nr_diff_times',
                'nr_mask_rms_times',
                'nr_rfi_width_lim']
        for key in keys:
            narr_args[key[3:]] = getattr(args, key)
        narr_args['frange'] = None
        narr_args['rfi_width_lim'] = [0,2]
        narr_args['rms_frange'] = args.rms_frange
        narr_args['ext_add'] = 1
        narr_args['thr_type'] = args.lsn_thr_type

        return mask_freq_rfi(T, self.freq, rtype = 'long-time',plot = False,
                              **narr_args)

    def get_lf(self,T):
        """
        Time domain uncontinuous RFI: long freq time RFI
        """
        args = self.args
        from .ripple.mark_timeRFI import mask_time_rfi

        longf_args = {}
        keys = ['lf_frange',
                'lf_mean_times',
                'lf_diff_times',
                'lf_ext_add',
                'lf_mask_rms_times',]
        for key in keys:
            longf_args[key[3:]] = getattr(args, key)
        longf_args['rfi_width_lim'] = args.lf_rfi_last
        longf_args['rms_frange'] = args.rms_frange
        longf_args['thr_type'] = args.lsn_thr_type

        return mask_time_rfi(T, self.freq, rtype = 'long-freq',plot = False,
                              **longf_args)

    def get_sf(self,T,is_rfi = None):
        """
        Time domain uncontinuous RFI: short freq time RFI
        """
        args = self.args
        from .ripple.mark_timeRFI import mask_time_rfi

        shortf_args = {}
        keys = ['sf_file',
                'sf_frange',
                'sf_frange_step',
                'sf_mean_times',
                'sf_diff_times',
                'sf_ext_add',
                'sf_mask_rms_times',]
        for key in keys:
            shortf_args[key[3:]] = getattr(args, key)
        shortf_args['rfi_width_lim'] = args.sf_rfi_last
        shortf_args['rms_frange'] = args.rms_frange
        shortf_args['thr_type'] = args.lsn_thr_type

        if is_rfi is not None and args.all_beams:
            whole_rfi = np.all(is_rfi, axis = 1)
            is_rfi[whole_rfi] = False
            is_timerfi = np.any(is_rfi, axis = 1)
            shortf_args['is_timerfi'] = is_timerfi

        return mask_time_rfi(T, self.freq, rtype = 'short-freq',plot = False,
                               **shortf_args)

    def get_time_rfi(self,is_rfi = None, is_rfi_tmp = None):
        """
        lf & sf
        """
        args = self.args
        T = self.s2p_mean

        t_rfi = np.isnan(T)
        Tt = deepcopy(T)
        Tt[:,self.protect_use] = 0
        if is_rfi_tmp is not None: Tt[is_rfi_tmp] = 0 

        if args.lf:
            print('finding lf')
            t_rfi |= self.get_lf(Tt)
            
        Tt[t_rfi] = 0
        if args.sf:
            print('finding sf')
            t_rfi |= self.get_sf(Tt,is_rfi)

        return t_rfi
        

    def get_pdr(self):
        """
        Period 8 MHZ RFI
        """
        args = self.args
        T = np.nanmean(self.s2p_mask, axis = 2)
        sm_kwargs = {}
        keys = ['s_method_t', 's_sigma_t', 's_method_freq', 's_sigma_freq',]
        for key in keys:
            sm_kwargs[key] = getattr(args, key)
        sm_kwargs['is_rfi'] = np.isnan(T)
        from .ripple.util import do_smooth
        T = do_smooth(T, **sm_kwargs)

        find_args = {}
        keys = ['rfi_width_lim', 'ext_sec', 'freq_thr', 'freq_step', 'rfi_groups',
                'mask_RFI_method', 'freq_from_theory', 'mask_thr', 'ext_edge',
                'small_rfi_times', 'chan_step',
                'mask_all_theory']
        for key in keys:
            find_args[key] = getattr(args, key)

        from .ripple.markRFI import find_RFI, real_rms
        from tqdm import tqdm
        rfi_thr = args.rfi_thr
        pd_rfi = np.full(T.shape, False, dtype=bool)

        print("Looking for period RFI...")
        for tn in tqdm(range(T.shape[0])):
            if tn in self.not_rfi_num:
                spec = deepcopy(T[tn,:])
                RMS = real_rms(spec, self.freq, args.rms_sigma, args.rms_frange)
#                 is_rfi_mw = (spec > RMS * rfi_thr)
                is_rfi = (spec > RMS * rfi_thr) & (~self.protect_use)
                try:
                    pd_rfi[tn,:],_ = find_RFI(spec,self.freq,is_rfi,RMS = RMS,
                                        plot = False,**find_args)
                except ValueError:
                    pd_rfi[tn,:] = True
                    print(f"tn={tn} has a ValueError !")
#                     import traceback
#                     traceback.print_exc()
        print("Finish finding period RFI...")

        time_coherent_per = args.time_coherent_per
        if (time_coherent_per > 0)&(time_coherent_per <1):
            per_use = (np.sum(pd_rfi,axis = 0)/pd_rfi.shape[0] > time_coherent_per)
            pd_rfi[:,per_use] = True

        return pd_rfi

    def protect_mw(self):
        args = self.args
        freq = self.freq
        mw_frange = args.mw_frange

        if mw_frange is None:
            mw_frange = [1419, 1422]
            if (freq[0] > mw_frange[1]) or (freq[-1] < mw_frange[0]):
                # Do not need to protect mw.
                pass
            else:
                print(f"mw_frange redicting to {mw_frange}, you should check it again.")

        protect_use = (freq>mw_frange[0])&(freq<mw_frange[1])
        return protect_use

    def check_rms_range(self):
        args = self.args
        rms_frange = args.rms_frange
        if (rms_frange is None) or (rms_frange[1] - rms_frange[0] <= 0):
            from .ripple.markRFI import get_rms_frange
            spec = np.nanmean(np.nanmean(self.s2p, axis = 0),axis = -1)
            self.args.rms_frange = get_rms_frange(spec,self.freq,rms_step=10,)
        else:
            freq = self.freq
            if (rms_frange[0] < freq[0]) or (rms_frange[1] > freq[-1]):
                raise ValueError(f"rms frange {rms_frange} is not in freq range {[freq[0],freq[-1]]}.")

    def _glob_names(self,):
        args = self.args
        
        from glob import glob
        import re
        subname = args.fpath
        key = re.findall(r'-M[0-1][0-9]', os.path.basename(subname))[0]
        namelist = os.path.basename(subname).split(key)
        name = os.path.join(os.path.dirname(subname), namelist[0]+'-M*'+namelist[1])
        names = glob(name)
        names.sort()
        return  names
    
    def iter_19rfi(self, names):
        args = self.args
        b19 = args.b19
        
        from .ripple.mark_timeRFI import load_hdf5_spec
        data_mean = load_hdf5_spec(names[0])
        if b19: 
            print("finding b19")
            num_19rfi = self.get_1beam_rfi(data_mean)
        
        import re
        print(re.findall(r'-M[0-1][0-9]', os.path.basename(names[0]))[0])
#         from tqdm import tqdm
        k = 1
        for name in names[1:]:
            print(re.findall(r'-M[0-1][0-9]', os.path.basename(name))[0])
            sys.stdout.flush()
            data = load_hdf5_spec(name)
            if b19: 
                num_19rfi_ = self.get_1beam_rfi(data)
                num_19rfi += num_19rfi_
            else:
                data_mean += data

            k += 1
        
        if b19: 
            num_19rfi = num_19rfi.astype(float)
            num_19rfi /= k

            data_mean = np.stack((num_19rfi, num_19rfi), axis=-1)
        else:
            data_mean /= k
            
        return data_mean
    
        
    def get_1beam_rfi(self, data):
        args = self.args

        rfi_kwargs = {}
        keys = ['b19_times',
                'ext_add',
                'ext_frac',
                'rms_frange',]
        for key in keys[:1]:
            rfi_kwargs[key[4:]] = getattr(args, key)
        for key in keys[1:]:
            rfi_kwargs[key] = getattr(args, key)
            
        rfi_kwargs['s_sigma'] = args.s_sigma_freq
        
        from .ripple.mark_timeRFI import mask_thr_rfi
        is_rfi = mask_thr_rfi(data, self.freq, **rfi_kwargs).astype(int)
        
        return is_rfi
    
    
    def gen_s2p_out(self,):
        args = self.args
        
        if args.all_beams:
            names = self._glob_names()
            print(f"Creating 19 beams rfi file  ...")
            self.s2p_out = self.iter_19rfi(names)
        else:
            raise TypeError("all_beams = True!")
            
    def gen_is_rfi(self):
        args = self.args
        self.gen_s2p_out()

        print("############ find RFI for all beams #############")
        self.s2p = self.s2p_out[:]
        self.s2p_mean = np.mean(self.s2p,axis = 2) 
        
        is_rfi = np.isnan(self.s2p_mean) | np.isinf(self.s2p_mean)
        self.s2p[is_rfi] = np.nan
        self.s2p_mean[is_rfi] = np.nan

        # manual regions
        is_rfi_tmp = self.get_from_regions()
        if is_rfi_tmp is not None:
            is_rfi |= is_rfi_tmp

        self.protect_use = self.protect_mw()
        self.check_rms_range()
        
        for key in ['tr', 'pr', 'nr', 'lf', 'pdr']:
            setattr(args, key, False)

        if args.lf or args.sf:
            is_rfi |= self.get_time_rfi(is_rfi = None, is_rfi_tmp = is_rfi_tmp)

        whole_rfi = np.all(is_rfi,axis = 1)
        self.not_rfi_num = np.arange(is_rfi.shape[0])[~whole_rfi]
        self.is_rfi_num = np.arange(is_rfi.shape[0])[whole_rfi]

        # time continuous RFI 
        if args.tr:
            print('finding tr')
            is_rfi |= self.get_tr()

        if is_rfi.any():
            self.s2p_mask = deepcopy(self.s2p)
            self.s2p_mask[is_rfi,:] = np.nan
        else:
            self.s2p_mask = self.s2p
        
        # narrowband RFI
        if args.nr:
            print('finding nr')
            is_rfi |= self.get_nr()
        
        # 8.1 MHz period RFI
        if args.pdr:
            print('finding period rfi')
            is_rfi |= self.get_pdr()
        
        # polarized RFI
        if args.pr:
            print('finding pr')
            is_rfi |= self.get_pr()

        # existing RFI
        if 'is_rfi' in self.fs.keys():
            is_rfi |= self.fs['is_rfi'][:]
            
        return is_rfi


    def __call__(self, save=True):
        args = self.args
        is_rfi = self.gen_is_rfi()
        if args.replace_rfi:
            self.s2p_out[is_rfi>0] = np.nan
        self.gen_dict_out(is_rfi = is_rfi)
        if not args.all_beams:
            # replace outfield as h5py.ExternalLink
            if self.dict_in is None:
                self.dict_out[self.outfield] = h5py.ExternalLink(os.path.relpath(
                    args.fpath, os.path.dirname(self.fpath_out)), f'/S/{self.infield}')
        if save:
            self.save()

# Cell
if __name__ == '__main__':
    # for clarity and testing purpose
    dests_hide = [
                 'rms_sigma',
                 's_method_t',
                 's_sigma_t',
                 's_method_freq',
                 's_sigma_freq',
                 'pdr',
                 'rfi_thr',
                 'rfi_width_lim',
                 'ext_sec',
                 'freq_thr',
                 'freq_step',
                 'rfi_groups',
                 'mask_RFI_method',
                 'freq_from_theory',
                 'mask_thr',
                 'ext_edge',
                 'small_rfi_times',
                 'chan_step',
                 'mask_all_theory',
                 'time_coherent_per'
                 ]
    hide_paras(parser, dests_hide)

    args_ = parser.parse_args()
    # print(parser.format_help())
    # print("----------")
    print('#'*35+'Args'+'#'*35)
    print(del_paras_in_string(parser.format_values(), dests_hide))  # useful for logging where different settings came from
    print('#'*35+'####'+'#'*35)
    io = IO(args_)
    io()

