'''
"""Aggregation fields"""
type CustomerAggregate {
  count: Int
  max: CustomerMinMaxFields!
  min: CustomerMinMaxFields!
  sum: CustomerSumFields!
}

"""
Boolean expression to compare aggregated fields. All fields are combined with logical 'AND'.
"""
input CustomerAggregateBoolExp {
  count: CustomerAggregateBoolExpCount
  maxDatetime: CustomerAggregateBoolExpMaxdatetime
  maxString: CustomerAggregateBoolExpMaxstring
  minDatetime: CustomerAggregateBoolExpMindatetime
  minString: CustomerAggregateBoolExpMinstring
  sum: CustomerAggregateBoolExpSum
}

"""Boolean expression to compare count aggregation."""
input CustomerAggregateBoolExpCount {
  arguments: [CustomerCountFields!] = []
  predicate: IntOrderComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare max aggregation."""
input CustomerAggregateBoolExpMaxdatetime {
  arguments: [CustomerMinMaxDateTimeFieldsEnum!]!
  predicate: DateTimeComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare max aggregation."""
input CustomerAggregateBoolExpMaxstring {
  arguments: [CustomerMinMaxStringFieldsEnum!]!
  predicate: TextComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare min aggregation."""
input CustomerAggregateBoolExpMindatetime {
  arguments: [CustomerMinMaxDateTimeFieldsEnum!]!
  predicate: DateTimeComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare min aggregation."""
input CustomerAggregateBoolExpMinstring {
  arguments: [CustomerMinMaxStringFieldsEnum!]!
  predicate: TextComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare sum aggregation."""
input CustomerAggregateBoolExpSum {
  arguments: [CustomerSumFieldsEnum!]!
  predicate: FloatOrderComparison!
  distinct: Boolean = false
}

input CustomerAggregateMinMaxDatetimeFieldsOrderBy {
  createdAt: OrderByEnum!
  updatedAt: OrderByEnum!
}

input CustomerAggregateMinMaxStringFieldsOrderBy {
  name: OrderByEnum!
}

input CustomerAggregateNumericFieldsOrderBy {
  name: OrderByEnum!
}

input CustomerAggregateOrderBy {
  count: OrderByEnum
  maxDatetime: CustomerAggregateMinMaxDatetimeFieldsOrderBy
  maxString: CustomerAggregateMinMaxStringFieldsOrderBy
  minDatetime: CustomerAggregateMinMaxDatetimeFieldsOrderBy
  minString: CustomerAggregateMinMaxStringFieldsOrderBy
  sum: CustomerAggregateNumericFieldsOrderBy
}

"""
Boolean expression to compare fields. All fields are combined with logical 'AND'.
"""
input CustomerBoolExp {
  _and: [CustomerBoolExp!]! = []
  _or: [CustomerBoolExp!]! = []
  _not: CustomerBoolExp
  projectsAggregate: ProjectAggregateBoolExp
  projects: ProjectBoolExp
  name: TextComparison
  id: UUIDGenericComparison
  createdAt: DateTimeComparison
  updatedAt: DateTimeComparison
}

enum CustomerCountFields {
  name
  id
  createdAt
  updatedAt
}

"""Create input"""
input CustomerCreate {
  projects: CustomerProjectsIdFieldsInputProjectCreateCustomerProjectsUpdateFieldsCustomerProjectsConflictFieldsToManyCreateInput
  name: String!
  id: UUID
}

enum CustomerMinMaxDateTimeFieldsEnum {
  createdAt
  updatedAt
}

"""GraphQL type"""
type CustomerMinMaxFields {
  name: String
  createdAt: DateTime
  updatedAt: DateTime
}

enum CustomerMinMaxStringFieldsEnum {
  name
}

"""
Boolean expression to compare fields. All fields are combined with logical 'AND'.
"""
input CustomerOrderBy {
  projectsAggregate: ProjectAggregateOrderBy
  projects: ProjectOrderBy
  name: OrderByEnum
  id: OrderByEnum
  createdAt: OrderByEnum
  updatedAt: OrderByEnum
}

"""Conflict fields enum"""
enum CustomerProjectsConflictFields {
  id
}

"""Identifier input"""
input CustomerProjectsIdFieldsInput {
  id: UUID!
}

"""Add new or existing objects"""
input CustomerProjectsIdFieldsInputProjectCreateCustomerProjectsUpdateFieldsCustomerProjectsConflictFieldsToManyCreateInput {
  set: [CustomerProjectsIdFieldsInput!]
  add: [CustomerProjectsIdFieldsInput!]
  create: [ProjectCreate!]
  upsert: CustomerProjectsIdFieldsInputProjectCreateCustomerProjectsUpdateFieldsCustomerProjectsConflictFieldsToManyUpsertInput
}

"""Add new objects or update if existing"""
input CustomerProjectsIdFieldsInputProjectCreateCustomerProjectsUpdateFieldsCustomerProjectsConflictFieldsToManyUpsertInput {
  create: [ProjectCreate!]!
  conflictFields: CustomerProjectsConflictFields!
  updateFields: [CustomerProjectsUpdateFields!]
}

"""Update fields enum"""
enum CustomerProjectsUpdateFields {
  tagId
  name
  id
}

"""GraphQL type"""
type CustomerSumFields {
  name: String
}

enum CustomerSumFieldsEnum {
  name
}

"""GraphQL type"""
type CustomerType {
  projectsAggregate: ProjectAggregate!

  """Fetch objects from the ProjectType collection"""
  projects(filter: ProjectFilter = null, orderBy: [ProjectOrder!] = null): [ProjectType!]!
  name: String!
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""Date with time (isoformat)"""
scalar DateTime

"""
Boolean expression to compare DateTime fields. All fields are combined with logical 'AND'
"""
input DateTimeComparison {
  eq: DateTime
  neq: DateTime
  isNull: Boolean
  in: [DateTime!]
  nin: [DateTime!]
  gt: DateTime
  gte: DateTime
  lt: DateTime
  lte: DateTime
  year: IntOrderComparison
  month: IntOrderComparison
  day: IntOrderComparison
  weekDay: IntOrderComparison
  week: IntOrderComparison
  quarter: IntOrderComparison
  isoYear: IntOrderComparison
  isoWeekDay: IntOrderComparison
  hour: IntOrderComparison
  minute: IntOrderComparison
  second: IntOrderComparison
}

"""Base interface for expected errors"""
interface ErrorType {
  id: String!
}

"""
Boolean expression to compare fields supporting order comparisons. All fields are combined with logical 'AND'
"""
input FloatOrderComparison {
  eq: Float
  neq: Float
  isNull: Boolean
  in: [Float!]
  nin: [Float!]
  gt: Float
  gte: Float
  lt: Float
  lte: Float
}

"""
Boolean expression to compare fields supporting order comparisons. All fields are combined with logical 'AND'
"""
input IntOrderComparison {
  eq: Int
  neq: Int
  isNull: Boolean
  in: [Int!]
  nin: [Int!]
  gt: Int
  gte: Int
  lt: Int
  lte: Int
}

"""Indicate validation error type and location."""
type LocalizedErrorType implements ErrorType {
  id: String!
  loc: [String!]!
  message: String!
  type: String!
}

"""Aggregation fields"""
type MilestoneAggregate {
  count: Int
  max: MilestoneMinMaxFields!
  min: MilestoneMinMaxFields!
  sum: MilestoneSumFields!
}

"""
Boolean expression to compare aggregated fields. All fields are combined with logical 'AND'.
"""
input MilestoneAggregateBoolExp {
  count: MilestoneAggregateBoolExpCount
  maxDatetime: MilestoneAggregateBoolExpMaxdatetime
  maxString: MilestoneAggregateBoolExpMaxstring
  minDatetime: MilestoneAggregateBoolExpMindatetime
  minString: MilestoneAggregateBoolExpMinstring
  sum: MilestoneAggregateBoolExpSum
}

"""Boolean expression to compare count aggregation."""
input MilestoneAggregateBoolExpCount {
  arguments: [MilestoneCountFields!] = []
  predicate: IntOrderComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare max aggregation."""
input MilestoneAggregateBoolExpMaxdatetime {
  arguments: [MilestoneMinMaxDateTimeFieldsEnum!]!
  predicate: DateTimeComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare max aggregation."""
input MilestoneAggregateBoolExpMaxstring {
  arguments: [MilestoneMinMaxStringFieldsEnum!]!
  predicate: TextComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare min aggregation."""
input MilestoneAggregateBoolExpMindatetime {
  arguments: [MilestoneMinMaxDateTimeFieldsEnum!]!
  predicate: DateTimeComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare min aggregation."""
input MilestoneAggregateBoolExpMinstring {
  arguments: [MilestoneMinMaxStringFieldsEnum!]!
  predicate: TextComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare sum aggregation."""
input MilestoneAggregateBoolExpSum {
  arguments: [MilestoneSumFieldsEnum!]!
  predicate: FloatOrderComparison!
  distinct: Boolean = false
}

input MilestoneAggregateMinMaxDatetimeFieldsOrderBy {
  createdAt: OrderByEnum!
  updatedAt: OrderByEnum!
}

input MilestoneAggregateMinMaxStringFieldsOrderBy {
  name: OrderByEnum!
}

input MilestoneAggregateNumericFieldsOrderBy {
  name: OrderByEnum!
}

input MilestoneAggregateOrderBy {
  count: OrderByEnum
  maxDatetime: MilestoneAggregateMinMaxDatetimeFieldsOrderBy
  maxString: MilestoneAggregateMinMaxStringFieldsOrderBy
  minDatetime: MilestoneAggregateMinMaxDatetimeFieldsOrderBy
  minString: MilestoneAggregateMinMaxStringFieldsOrderBy
  sum: MilestoneAggregateNumericFieldsOrderBy
}

"""
Boolean expression to compare fields. All fields are combined with logical 'AND'.
"""
input MilestoneBoolExp {
  _and: [MilestoneBoolExp!]! = []
  _or: [MilestoneBoolExp!]! = []
  _not: MilestoneBoolExp
  projectAggregate: ProjectAggregateBoolExp
  project: ProjectBoolExp
  name: TextComparison
  projectId: UUIDGenericComparison
  id: UUIDGenericComparison
  createdAt: DateTimeComparison
  updatedAt: DateTimeComparison
}

enum MilestoneCountFields {
  name
  projectId
  id
  createdAt
  updatedAt
}

"""Create input"""
input MilestoneCreate {
  project: MilestoneProjectIdFieldsInputProjectCreateMilestoneProjectUpdateFieldsMilestoneProjectConflictFieldsToOneInput = null
  name: String!
  id: UUID
}

enum MilestoneMinMaxDateTimeFieldsEnum {
  createdAt
  updatedAt
}

"""GraphQL type"""
type MilestoneMinMaxFields {
  name: String
  createdAt: DateTime
  updatedAt: DateTime
}

enum MilestoneMinMaxStringFieldsEnum {
  name
}

"""
Boolean expression to compare fields. All fields are combined with logical 'AND'.
"""
input MilestoneOrderBy {
  projectAggregate: ProjectAggregateOrderBy
  project: ProjectOrderBy
  name: OrderByEnum
  projectId: OrderByEnum
  id: OrderByEnum
  createdAt: OrderByEnum
  updatedAt: OrderByEnum
}

"""Conflict fields enum"""
enum MilestoneProjectConflictFields {
  id
}

"""Identifier input"""
input MilestoneProjectIdFieldsInput {
  id: UUID!
}

"""Add a new or existing object"""
input MilestoneProjectIdFieldsInputProjectCreateMilestoneProjectUpdateFieldsMilestoneProjectConflictFieldsToOneInput {
  set: MilestoneProjectIdFieldsInput
  create: ProjectCreate
  upsert: MilestoneProjectIdFieldsInputProjectCreateMilestoneProjectUpdateFieldsMilestoneProjectConflictFieldsToOneUpsertInput
}

"""Add new object or update if existing"""
input MilestoneProjectIdFieldsInputProjectCreateMilestoneProjectUpdateFieldsMilestoneProjectConflictFieldsToOneUpsertInput {
  create: ProjectCreate!
  conflictFields: MilestoneProjectConflictFields
  updateFields: [MilestoneProjectUpdateFields!]
}

"""Update fields enum"""
enum MilestoneProjectUpdateFields {
  tagId
  name
  id
}

"""GraphQL type"""
type MilestoneSumFields {
  name: String
}

enum MilestoneSumFieldsEnum {
  name
}

"""GraphQL type"""
type MilestoneType {
  project: ProjectType
  name: String!
  projectId: UUID
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Mutation {
  """Fetch object from the TicketType collection by id"""
  createTicket(data: TicketCreate!): TicketTypeValidationErrorType!

  """Fetch objects from the TicketType collection"""
  createTickets(data: [TicketCreate!]!): [TicketType!]!

  """Fetch object from the TicketType collection by id"""
  upsertTicket(updateFields: [TicketUpsertFields!] = null, conflictFields: TicketUpsertConflictFields = null, data: TicketCreate!): TicketType!

  """Fetch object from the ProjectType collection by id"""
  createProject(data: ProjectCreate!): ProjectType!

  """Fetch objects from the ProjectType collection"""
  createProjects(data: [ProjectCreate!]!): [ProjectType!]!

  """Fetch object from the MilestoneType collection by id"""
  createMilestone(data: MilestoneCreate!): MilestoneType!

  """Fetch object from the TicketType collection by id"""
  updateTicketsByIds(data: TicketUpdate!, filter: TicketFilter = null): TicketType!

  """Fetch objects from the TicketType collection"""
  updateTickets(data: TicketPartial!, filter: TicketFilter = null): [TicketType!]!

  """Fetch objects from the TicketType collection"""
  deleteTicket(filter: TicketFilter!): [TicketType!]!

  """Fetch object from the CustomerType collection by id"""
  createCustomer(data: CustomerCreate!): CustomerType!
}

enum OrderByEnum {
  ASC
  ASC_NULLS_FIRST
  ASC_NULLS_LAST
  DESC
  DESC_NULLS_FIRST
  DESC_NULLS_LAST
}

"""Aggregation fields"""
type ProjectAggregate {
  count: Int
  max: ProjectMinMaxFields!
  min: ProjectMinMaxFields!
  sum: ProjectSumFields!
}

"""
Boolean expression to compare aggregated fields. All fields are combined with logical 'AND'.
"""
input ProjectAggregateBoolExp {
  count: ProjectAggregateBoolExpCount
  maxDatetime: ProjectAggregateBoolExpMaxdatetime
  maxString: ProjectAggregateBoolExpMaxstring
  minDatetime: ProjectAggregateBoolExpMindatetime
  minString: ProjectAggregateBoolExpMinstring
  sum: ProjectAggregateBoolExpSum
}

"""Boolean expression to compare count aggregation."""
input ProjectAggregateBoolExpCount {
  arguments: [ProjectCountFields!] = []
  predicate: IntOrderComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare max aggregation."""
input ProjectAggregateBoolExpMaxdatetime {
  arguments: [ProjectMinMaxDateTimeFieldsEnum!]!
  predicate: DateTimeComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare max aggregation."""
input ProjectAggregateBoolExpMaxstring {
  arguments: [ProjectMinMaxStringFieldsEnum!]!
  predicate: TextComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare min aggregation."""
input ProjectAggregateBoolExpMindatetime {
  arguments: [ProjectMinMaxDateTimeFieldsEnum!]!
  predicate: DateTimeComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare min aggregation."""
input ProjectAggregateBoolExpMinstring {
  arguments: [ProjectMinMaxStringFieldsEnum!]!
  predicate: TextComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare sum aggregation."""
input ProjectAggregateBoolExpSum {
  arguments: [ProjectSumFieldsEnum!]!
  predicate: FloatOrderComparison!
  distinct: Boolean = false
}

input ProjectAggregateMinMaxDatetimeFieldsOrderBy {
  createdAt: OrderByEnum!
  updatedAt: OrderByEnum!
}

input ProjectAggregateMinMaxStringFieldsOrderBy {
  name: OrderByEnum!
}

input ProjectAggregateNumericFieldsOrderBy {
  name: OrderByEnum!
}

input ProjectAggregateOrderBy {
  count: OrderByEnum
  maxDatetime: ProjectAggregateMinMaxDatetimeFieldsOrderBy
  maxString: ProjectAggregateMinMaxStringFieldsOrderBy
  minDatetime: ProjectAggregateMinMaxDatetimeFieldsOrderBy
  minString: ProjectAggregateMinMaxStringFieldsOrderBy
  sum: ProjectAggregateNumericFieldsOrderBy
}

"""
Boolean expression to compare fields. All fields are combined with logical 'AND'.
"""
input ProjectBoolExp {
  _and: [ProjectBoolExp!]! = []
  _or: [ProjectBoolExp!]! = []
  _not: ProjectBoolExp
  ticketsAggregate: TicketAggregateBoolExp
  tickets: TicketFilter
  milestonesAggregate: MilestoneAggregateBoolExp
  milestones: MilestoneBoolExp
  tagAggregate: TagAggregateBoolExp
  tag: TagBoolExp
  customersAggregate: CustomerAggregateBoolExp
  customers: CustomerBoolExp
  tagId: UUIDGenericComparison
  name: TextComparison
  id: UUIDGenericComparison
  createdAt: DateTimeComparison
  updatedAt: DateTimeComparison
}

enum ProjectCountFields {
  tagId
  name
  id
  createdAt
  updatedAt
}

"""Create input"""
input ProjectCreate {
  name: String!
}

"""
Boolean expression to compare fields. All fields are combined with logical 'AND'.
"""
input ProjectFilter {
  _and: [ProjectFilter!]! = []
  _or: [ProjectFilter!]! = []
  not_: ProjectFilter
  ticketsAggregate: TicketAggregateBoolExp
  tickets: TicketFilter
  milestonesAggregate: MilestoneAggregateBoolExp
  milestones: MilestoneBoolExp
  tagAggregate: TagAggregateBoolExp
  tag: TagBoolExp
  customersAggregate: CustomerAggregateBoolExp
  customers: CustomerBoolExp
  tagId: UUIDGenericComparison
  name: TextComparison
  id: UUIDGenericComparison
  createdAt: DateTimeComparison
  updatedAt: DateTimeComparison
}

enum ProjectMinMaxDateTimeFieldsEnum {
  createdAt
  updatedAt
}

"""GraphQL type"""
type ProjectMinMaxFields {
  name: String
  createdAt: DateTime
  updatedAt: DateTime
}

enum ProjectMinMaxStringFieldsEnum {
  name
}

"""
Boolean expression to compare fields. All fields are combined with logical 'AND'.
"""
input ProjectOrder {
  ticketsAggregate: TicketAggregateOrderBy
  tickets: TicketOrder
  milestonesAggregate: MilestoneAggregateOrderBy
  milestones: MilestoneOrderBy
  tagAggregate: TagAggregateOrderBy
  tag: TagOrderBy
  customersAggregate: CustomerAggregateOrderBy
  customers: CustomerOrderBy
  tagId: OrderByEnum
  name: OrderByEnum
  id: OrderByEnum
  createdAt: OrderByEnum
  updatedAt: OrderByEnum
}

"""
Boolean expression to compare fields. All fields are combined with logical 'AND'.
"""
input ProjectOrderBy {
  ticketsAggregate: TicketAggregateOrderBy
  tickets: TicketOrder
  milestonesAggregate: MilestoneAggregateOrderBy
  milestones: MilestoneOrderBy
  tagAggregate: TagAggregateOrderBy
  tag: TagOrderBy
  customersAggregate: CustomerAggregateOrderBy
  customers: CustomerOrderBy
  tagId: OrderByEnum
  name: OrderByEnum
  id: OrderByEnum
  createdAt: OrderByEnum
  updatedAt: OrderByEnum
}

"""GraphQL type"""
type ProjectSumFields {
  name: String
}

enum ProjectSumFieldsEnum {
  name
}

"""GraphQL type"""
type ProjectType {
  ticketsAggregate: TicketAggregate!

  """Fetch objects from the TicketType collection"""
  tickets(filter: TicketFilter = null, orderBy: [TicketOrder!] = null): [TicketType!]!
  milestonesAggregate: MilestoneAggregate!

  """Fetch objects from the MilestoneType collection"""
  milestones: [MilestoneType!]!
  tag: TagType
  customersAggregate: CustomerAggregate!

  """Fetch objects from the CustomerType collection"""
  customers: [CustomerType!]!
  tagId: UUID
  name: String!
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Query {
  """Fetch object from the TicketType collection by id"""
  ticket(id: UUID!): TicketType!

  """Fetch objects from the TicketType collection"""
  tickets(filter: TicketFilter = null, orderBy: [TicketOrder!] = null): [TicketType!]!

  """Fetch object from the ProjectType collection by id"""
  project(id: UUID!): ProjectType!

  """Fetch objects from the ProjectType collection"""
  projects(filter: ProjectFilter = null, orderBy: [ProjectOrder!] = null): [ProjectType!]!

  """Fetch objects from the MilestoneType collection"""
  milestones: [MilestoneType!]!
}

"""
Boolean expression to compare aggregated fields. All fields are combined with logical 'AND'.
"""
input TagAggregateBoolExp {
  count: TagAggregateBoolExpCount
  maxDatetime: TagAggregateBoolExpMaxdatetime
  maxString: TagAggregateBoolExpMaxstring
  minDatetime: TagAggregateBoolExpMindatetime
  minString: TagAggregateBoolExpMinstring
  sum: TagAggregateBoolExpSum
}

"""Boolean expression to compare count aggregation."""
input TagAggregateBoolExpCount {
  arguments: [TagCountFields!] = []
  predicate: IntOrderComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare max aggregation."""
input TagAggregateBoolExpMaxdatetime {
  arguments: [TagMinMaxDateTimeFieldsEnum!]!
  predicate: DateTimeComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare max aggregation."""
input TagAggregateBoolExpMaxstring {
  arguments: [TagMinMaxStringFieldsEnum!]!
  predicate: TextComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare min aggregation."""
input TagAggregateBoolExpMindatetime {
  arguments: [TagMinMaxDateTimeFieldsEnum!]!
  predicate: DateTimeComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare min aggregation."""
input TagAggregateBoolExpMinstring {
  arguments: [TagMinMaxStringFieldsEnum!]!
  predicate: TextComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare sum aggregation."""
input TagAggregateBoolExpSum {
  arguments: [TagSumFieldsEnum!]!
  predicate: FloatOrderComparison!
  distinct: Boolean = false
}

input TagAggregateMinMaxDatetimeFieldsOrderBy {
  createdAt: OrderByEnum!
  updatedAt: OrderByEnum!
}

input TagAggregateMinMaxStringFieldsOrderBy {
  name: OrderByEnum!
}

input TagAggregateNumericFieldsOrderBy {
  name: OrderByEnum!
}

input TagAggregateOrderBy {
  count: OrderByEnum
  maxDatetime: TagAggregateMinMaxDatetimeFieldsOrderBy
  maxString: TagAggregateMinMaxStringFieldsOrderBy
  minDatetime: TagAggregateMinMaxDatetimeFieldsOrderBy
  minString: TagAggregateMinMaxStringFieldsOrderBy
  sum: TagAggregateNumericFieldsOrderBy
}

"""
Boolean expression to compare fields. All fields are combined with logical 'AND'.
"""
input TagBoolExp {
  _and: [TagBoolExp!]! = []
  _or: [TagBoolExp!]! = []
  _not: TagBoolExp
  name: TextComparison
  id: UUIDGenericComparison
  createdAt: DateTimeComparison
  updatedAt: DateTimeComparison
}

enum TagCountFields {
  name
  id
  createdAt
  updatedAt
}

enum TagMinMaxDateTimeFieldsEnum {
  createdAt
  updatedAt
}

enum TagMinMaxStringFieldsEnum {
  name
}

"""
Boolean expression to compare fields. All fields are combined with logical 'AND'.
"""
input TagOrderBy {
  name: OrderByEnum
  id: OrderByEnum
  createdAt: OrderByEnum
  updatedAt: OrderByEnum
}

enum TagSumFieldsEnum {
  name
}

"""GraphQL type"""
type TagType {
  name: String!
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""
Boolean expression to compare String fields. All fields are combined with logical 'AND'
"""
input TextComparison {
  eq: String
  neq: String
  isNull: Boolean
  in: [String!]
  nin: [String!]
  gt: String
  gte: String
  lt: String
  lte: String
  like: String
  nlike: String
  ilike: String
  nilike: String
  regexp: String
  iregexp: String
  nregexp: String
  inregexp: String
  startswith: String
  endswith: String
  contains: String
  istartswith: String
  iendswith: String
  icontains: String
}

"""Aggregation fields"""
type TicketAggregate {
  count: Int
  max: TicketMinMaxFields!
  min: TicketMinMaxFields!
  sum: TicketSumFields!
}

"""
Boolean expression to compare aggregated fields. All fields are combined with logical 'AND'.
"""
input TicketAggregateBoolExp {
  count: TicketAggregateBoolExpCount
  maxDatetime: TicketAggregateBoolExpMaxdatetime
  maxString: TicketAggregateBoolExpMaxstring
  minDatetime: TicketAggregateBoolExpMindatetime
  minString: TicketAggregateBoolExpMinstring
  sum: TicketAggregateBoolExpSum
}

"""Boolean expression to compare count aggregation."""
input TicketAggregateBoolExpCount {
  arguments: [TicketCountFields!] = []
  predicate: IntOrderComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare max aggregation."""
input TicketAggregateBoolExpMaxdatetime {
  arguments: [TicketMinMaxDateTimeFieldsEnum!]!
  predicate: DateTimeComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare max aggregation."""
input TicketAggregateBoolExpMaxstring {
  arguments: [TicketMinMaxStringFieldsEnum!]!
  predicate: TextComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare min aggregation."""
input TicketAggregateBoolExpMindatetime {
  arguments: [TicketMinMaxDateTimeFieldsEnum!]!
  predicate: DateTimeComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare min aggregation."""
input TicketAggregateBoolExpMinstring {
  arguments: [TicketMinMaxStringFieldsEnum!]!
  predicate: TextComparison!
  distinct: Boolean = false
}

"""Boolean expression to compare sum aggregation."""
input TicketAggregateBoolExpSum {
  arguments: [TicketSumFieldsEnum!]!
  predicate: FloatOrderComparison!
  distinct: Boolean = false
}

input TicketAggregateMinMaxDatetimeFieldsOrderBy {
  createdAt: OrderByEnum!
  updatedAt: OrderByEnum!
}

input TicketAggregateMinMaxStringFieldsOrderBy {
  name: OrderByEnum!
}

input TicketAggregateNumericFieldsOrderBy {
  name: OrderByEnum!
}

input TicketAggregateOrderBy {
  count: OrderByEnum
  maxDatetime: TicketAggregateMinMaxDatetimeFieldsOrderBy
  maxString: TicketAggregateMinMaxStringFieldsOrderBy
  minDatetime: TicketAggregateMinMaxDatetimeFieldsOrderBy
  minString: TicketAggregateMinMaxStringFieldsOrderBy
  sum: TicketAggregateNumericFieldsOrderBy
}

enum TicketCountFields {
  name
  projectId
  id
  createdAt
  updatedAt
}

"""Create input"""
input TicketCreate {
  project: TicketProjectIdFieldsInputTicketProjectInputTicketProjectUpdateFieldsTicketProjectConflictFieldsToOneInput = null
  name: String!
  id: UUID
}

"""
Boolean expression to compare fields. All fields are combined with logical 'AND'.
"""
input TicketFilter {
  _and: [TicketFilter!]! = []
  _or: [TicketFilter!]! = []
  _not: TicketFilter
  projectAggregate: ProjectAggregateBoolExp
  project: ProjectBoolExp
  name: TextComparison
  projectId: UUIDGenericComparison
  id: UUIDGenericComparison
  createdAt: DateTimeComparison
  updatedAt: DateTimeComparison
}

enum TicketMinMaxDateTimeFieldsEnum {
  createdAt
  updatedAt
}

"""GraphQL type"""
type TicketMinMaxFields {
  name: String
  createdAt: DateTime
  updatedAt: DateTime
}

enum TicketMinMaxStringFieldsEnum {
  name
}

"""
Boolean expression to compare fields. All fields are combined with logical 'AND'.
"""
input TicketOrder {
  projectAggregate: ProjectAggregateOrderBy
  project: ProjectOrderBy
  name: OrderByEnum
  projectId: OrderByEnum
  id: OrderByEnum
  createdAt: OrderByEnum
  updatedAt: OrderByEnum
}

"""Filter update input"""
input TicketPartial {
  project: TicketProjectIdFieldsInputTicketProjectInputTicketProjectUpdateFieldsTicketProjectConflictFieldsToOneInput
  name: String
  id: UUID
}

"""Conflict fields enum"""
enum TicketProjectConflictFields {
  id
}

"""Identifier input"""
input TicketProjectIdFieldsInput {
  id: UUID!
}

"""Add a new or existing object"""
input TicketProjectIdFieldsInputTicketProjectInputTicketProjectUpdateFieldsTicketProjectConflictFieldsToOneInput {
  set: TicketProjectIdFieldsInput
  create: ProjectCreate
  upsert: TicketProjectIdFieldsInputTicketProjectInputTicketProjectUpdateFieldsTicketProjectConflictFieldsToOneUpsertInput
}

"""Add new object or update if existing"""
input TicketProjectIdFieldsInputTicketProjectInputTicketProjectUpdateFieldsTicketProjectConflictFieldsToOneUpsertInput {
  create: ProjectCreate!
  conflictFields: TicketProjectConflictFields
  updateFields: [TicketProjectUpdateFields!]
}

"""Update fields enum"""
enum TicketProjectUpdateFields {
  tagId
  name
  id
}

"""GraphQL type"""
type TicketSumFields {
  name: String
}

enum TicketSumFieldsEnum {
  name
}

"""GraphQL type"""
type TicketType {
  project: ProjectType
  name: String!
  projectId: UUID
  id: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

union TicketTypeValidationErrorType = TicketType | ValidationErrorType

"""Identifier update input"""
input TicketUpdate {
  project: TicketProjectIdFieldsInputTicketProjectInputTicketProjectUpdateFieldsTicketProjectConflictFieldsToOneInput
  name: String
  id: UUID!
}

enum TicketUpsertConflictFields {
  id
}

enum TicketUpsertFields {
  name
  projectId
  id
}

scalar UUID

"""
Boolean expression to compare fields supporting equality comparisons. All fields are combined with logical 'AND'
"""
input UUIDGenericComparison {
  eq: UUID
  neq: UUID
  isNull: Boolean
  in: [UUID!]
  nin: [UUID!]
}

"""Input is malformed or invalid."""
type ValidationErrorType implements ErrorType {
  id: String!
  errors: [LocalizedErrorType!]!
}
'''