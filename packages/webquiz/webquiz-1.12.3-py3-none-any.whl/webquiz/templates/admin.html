<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü–∞–Ω–µ–ª—å –ê–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–∞ WebQuiz</title>
    <style>
        :root {
            --bg-color: #f5f5f5;
            --container-bg: white;
            --text-color: #333;
            --border-color: #ddd;
            --button-bg: #007bff;
            --button-hover: #0056b3;
            --success-bg: #d4edda;
            --success-border: #c3e6cb;
            --success-color: #155724;
            --error-bg: #f8d7da;
            --error-border: #f5c6cb;
            --error-color: #721c24;
            --warning-bg: #fff3cd;
            --warning-border: #ffeaa7;
            --warning-color: #856404;
            --disabled-bg: #ccc;
            --light-bg: #fafafa;
            --success-green: #28a745;
            --success-green-hover: #218838;
            --danger-red: #dc3545;
            --danger-red-hover: #c82333;
            --muted-gray: #6c757d;
            --light-gray: #aaa;
            --text-muted: #666;
            --white: white;
            --shadow: rgba(0,0,0,0.1);
            --modal-overlay: rgba(0,0,0,0.5);
        }

        [data-theme="dark"] {
            --bg-color: #1a1a1a;
            --container-bg: #2d2d2d;
            --text-color: #e0e0e0;
            --border-color: #555;
            --button-bg: #0d6efd;
            --button-hover: #0b5ed7;
            --success-bg: #1e3a1e;
            --success-border: #2d5a2d;
            --success-color: #a5d6a7;
            --error-bg: #3a1a1a;
            --error-border: #5a2d2d;
            --error-color: #ef9a9a;
            --warning-bg: #3d3a1a;
            --warning-border: #5a5a2d;
            --warning-color: #fff3cd;
            --disabled-bg: #555;
            --light-bg: #333;
            --success-green: #2e7d32;
            --success-green-hover: #1b5e20;
            --danger-red: #c62828;
            --danger-red-hover: #b71c1c;
            --muted-gray: #757575;
            --light-gray: #888;
            --text-muted: #aaa;
            --white: white;
            --shadow: rgba(0,0,0,0.3);
            --modal-overlay: rgba(0,0,0,0.7);
        }

        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .container {
            background: var(--container-bg);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px var(--shadow);
            margin-bottom: 20px;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            position: relative;
        }

        h1 {
            text-align: center;
            color: var(--text-color);
            margin-bottom: 30px;
        }

        .form-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input[type="password"],
        input[type="text"],
        input[type="number"],
        select {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            font-size: 16px;
            box-sizing: border-box;
            background: var(--container-bg);
            color: var(--text-color);
        }

        textarea {
            background: var(--container-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 5px;
        }

        button {
            background: var(--button-bg);
            color: var(--white);
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }

        button:hover {
            background: var(--button-hover);
        }

        button:disabled {
            background: var(--disabled-bg);
            cursor: not-allowed;
        }

        .hidden {
            display: none;
        }

        .message {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .success {
            background: var(--success-bg);
            border: 1px solid var(--success-border);
            color: var(--success-color);
        }

        .error {
            background: var(--error-bg);
            border: 1px solid var(--error-border);
            color: var(--error-color);
        }

        .warning {
            background: var(--warning-bg);
            border: 1px solid var(--warning-border);
            color: var(--warning-color);
        }



        /* Multi-select quiz dropdown */
        .quiz-select {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            font-size: 14px;
            box-sizing: border-box;
            background: var(--light-bg);
            font-family: monospace;
        }

        .quiz-select option {
            padding: 8px;
        }

        .quiz-select option.current-quiz {
            font-weight: bold;
            background: var(--warning-bg);
        }

        .selection-hint {
            font-size: 0.85em;
            color: var(--text-muted);
            margin-top: 5px;
            font-style: italic;
        }

        .btn-success {
            background: var(--success-green);
            color: var(--white);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
        }

        .btn-success:hover {
            background: var(--success-green-hover);
        }

        .hidden {
            display: none !important;
        }

        /* Mobile responsive for quiz select */
        @media (max-width: 768px) {
            .quiz-select {
                font-size: 16px; /* Prevent zoom on iOS */
            }

            .selection-hint {
                display: none; /* Hide Ctrl+click hint on mobile */
            }
        }

        .current-quiz-display {
            margin-top: 10px;
            padding: 10px 15px;
            background: var(--success-bg);
            border: 1px solid var(--success-border);
            border-radius: 5px;
            color: var(--success-color);
            font-weight: bold;
        }

        .current-quiz-display.no-quiz {
            background: var(--warning-bg);
            border-color: var(--warning-border);
            color: var(--warning-color);
        }

        .actions {
            text-align: center;
            margin-top: 20px;
        }

        .actions-sticky {
            position: sticky;
            bottom: 0;
            background: var(--container-bg);
            padding: 15px 0;
            margin-top: 20px;
            margin-left: -15px;
            margin-right: -15px;
            margin-bottom: -15px;
            border-top: 1px solid var(--border-color);
            box-shadow: 0 -2px 10px var(--shadow);
            z-index: 10;
            text-align: center;
        }

        .back-link {
            text-align: center;
            margin-top: 20px;
        }

        .back-link a {
            color: var(--button-bg);
            text-decoration: none;
        }

        .back-link a:hover {
            text-decoration: underline;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-overlay);
        }

        .modal-content {
            background-color: var(--container-bg);
            margin: 5% auto;
            padding: 15px;
            border-radius: 10px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .close {
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            color: var(--light-gray);
        }

        .close:hover {
            color: var(--text-color);
        }

        .editor-content {
            margin-top: 12px;
        }

        .question-item {
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 10px;
            margin: 8px 0;
            background: var(--light-bg);
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding: 10px;
            background: var(--question-bg, #e9ecef);
            border-radius: 5px;
            cursor: pointer;
            user-select: none;
        }

        .question-header:hover {
            background: var(--question-bg-hover, #dee2e6);
        }

        .question-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            min-width: 0;
        }

        .question-collapse-icon {
            font-size: 12px;
            transition: transform 0.2s ease;
            color: var(--text-muted);
            margin-top: 3px;
        }

        .question-item.collapsed .question-collapse-icon {
            transform: rotate(-90deg);
        }

        .question-number {
            font-weight: bold;
            white-space: nowrap;
        }

        .question-preview {
            color: var(--text-muted);
            font-size: 0.9em;
            flex: 1;
        }

        .question-indicators {
            display: flex;
            gap: 5px;
            margin-left: 8px;
            flex-shrink: 0;
        }

        .question-indicator {
            font-size: 14px;
            opacity: 0.8;
        }

        .question-indicator.points-indicator {
            color: darkgoldenrod;
            font-weight: bold;
        }

        .question-header-buttons {
            display: flex;
            gap: 5px;
            flex-shrink: 0;
            align-self: flex-start;
        }

        .question-header-buttons button {
            padding: 5px 8px;
            font-size: 12px;
            margin: 0;
        }

        .drag-handle {
            cursor: grab;
            color: var(--text-muted);
            font-size: 16px;
            padding: 2px 4px;
            user-select: none;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .question-item.dragging {
            opacity: 0.5;
            background: var(--question-bg-hover, #dee2e6);
        }

        .question-item.drag-over {
            border-top: 3px solid var(--button-bg);
        }

        .question-body {
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.2s ease, padding 0.2s ease;
            max-height: 2000px;
            opacity: 1;
            padding-top: 10px;
        }

        .question-item.collapsed .question-body {
            max-height: 0;
            opacity: 0;
            padding-top: 0;
        }

        .question-item.collapsed {
            padding-bottom: 0;
        }

        .option-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }

        .option-item input[type="text"] {
            flex: 1;
            margin: 0 10px;
        }

        .option-item input[type="radio"] {
            margin-right: 5px;
        }

        .validation-errors {
            color: var(--error-color);
            background: var(--error-bg);
            border: 1px solid var(--error-border);
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
        }

        .quiz-actions {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .quiz-actions button {
            flex: 1;
        }

        .btn-danger {
            background: var(--danger-red);
        }

        .btn-danger:hover {
            background: var(--danger-red-hover);
        }

        .downloadable-quiz-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            margin-bottom: 10px;
            background: var(--white);
        }

        .downloadable-quiz-info {
            flex: 1;
        }

        .downloadable-quiz-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .downloadable-quiz-url {
            font-size: 0.9em;
            color: var(--text-muted);
            word-break: break-all;
        }

        .download-btn {
            background: var(--success-green);
            color: var(--white);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }

        .download-btn:hover {
            background: var(--success-green-hover);
        }

        .download-btn:disabled {
            background: var(--muted-gray);
            cursor: not-allowed;
        }

        .btn-danger:disabled {
            background: var(--danger-red);
            color: var(--white);
            opacity: 0.6;
        }

        /* Network info styles */
        .network-info {
            background: var(--warning-bg);
            border: 1px solid var(--warning-border);
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
        }

        .network-info h3 {
            margin-top: 0;
            color: var(--warning-color);
        }

        .info-section {
            margin: 15px 0;
        }

        .url-list {
            margin-top: 10px;
        }

        .url-item {
            background: var(--white);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 10px;
            margin: 5px 0;
            font-family: monospace;
        }

        .tunnel-info {
            background: var(--info-bg);
            border: 1px solid var(--info-border);
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
        }

        .tunnel-info h3 {
            margin-top: 0;
            color: var(--info-color);
        }

        .tunnel-public-key {
            background: var(--white);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
            word-break: break-all;
            position: relative;
        }

        .copy-button {
            margin-left: 10px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
        }

        .tunnel-url {
            background: var(--success-bg);
            border: 1px solid var(--success-border);
            border-radius: 3px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
        }

        .tunnel-error {
            color: var(--error-color);
            margin: 10px 0;
        }

        .url-item .label {
            font-weight: bold;
            color: var(--button-bg);
            margin-bottom: 5px;
        }

        .url-item .url {
            color: var(--text-muted);
            font-size: 14px;
        }

        .url-item a {
            color: var(--button-bg);
            text-decoration: none;
            margin-right: 15px;
        }

        .url-item a:hover {
            text-decoration: underline;
        }

        /* Image picker styles */
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .image-item {
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--container-bg);
        }

        .image-item:hover {
            border-color: var(--button-bg);
            transform: scale(1.05);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .image-item img {
            width: 100%;
            height: 100px;
            object-fit: cover;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .image-filename {
            font-size: 12px;
            color: var(--text-color);
            word-break: break-word;
            line-height: 1.2;
        }

        #image-picker-modal .modal-content {
            max-width: 800px;
            width: 90%;
        }

        /* File picker styles */
        .file-list {
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: var(--container-bg);
        }

        .file-item:hover {
            border-color: var(--button-bg);
            background: var(--stats-bg);
        }

        .file-item-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .file-item-icon {
            font-size: 20px;
        }

        .file-item-name {
            font-size: 14px;
            color: var(--text-color);
            word-break: break-word;
        }

        .file-item-size {
            font-size: 12px;
            color: var(--text-muted);
            white-space: nowrap;
        }

        /* Quiz Editor Form Styles */
        .question-text, .question-image, .option-text {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .options-container {
            margin: 10px 0;
        }

        /* Image preview styles in quiz editor */
        .image-preview-container {
            margin-top: 8px;
            display: none;
        }

        .image-preview-container.has-image {
            display: block;
        }

        .image-preview {
            max-width: 200px;
            max-height: 150px;
            border-radius: 8px;
            border: 2px solid var(--border-color);
            object-fit: contain;
            background: var(--light-bg);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .image-preview:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 12px var(--shadow);
            border-color: var(--button-bg);
        }

        .option-image-preview {
            max-width: 80px;
            max-height: 60px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            object-fit: contain;
            background: var(--light-bg);
            margin-left: 5px;
            cursor: pointer;
            vertical-align: middle;
        }

        .option-image-preview:hover {
            border-color: var(--button-bg);
        }

        /* Full-size image preview modal */
        .image-fullscreen-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            cursor: pointer;
        }

        .image-fullscreen-modal img {
            max-width: 90%;
            max-height: 90%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .image-fullscreen-close {
            position: absolute;
            top: 20px;
            right: 30px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
        }

        .image-fullscreen-close:hover {
            color: var(--button-bg);
        }

        /* Pending Approvals Section */
        .pending-approvals {
            margin-top: 30px;
            background: var(--warning-bg);
            border: 2px solid var(--warning-border);
            border-radius: 8px;
            padding: 20px;
        }

        .pending-user-item {
            background: var(--white);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pending-user-info {
            flex: 1;
        }

        .pending-user-name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .pending-user-data {
            color: var(--text-muted);
            font-size: 14px;
            margin: 3px 0;
        }

        .approve-btn {
            background: var(--success-green);
            color: var(--white);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        .approve-btn:hover {
            background: var(--success-green-hover);
        }

        /* Downloadable Quizzes Section */
        .downloadable-quizzes {
            margin-top: 30px;
        }

        /* Question type toggle buttons */
        .question-type-toggle {
            background: var(--option-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 8px 16px;
            margin: 0 5px 10px 0;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .question-type-toggle:hover {
            background: var(--option-hover);
        }

        .question-type-toggle.active {
            background: var(--button-bg);
            color: var(--white);
            border-color: var(--button-bg);
        }

        .min-correct-container {
            background: var(--light-bg);
            padding: 15px;
            border-radius: 5px;
            margin-top: 10px;
        }

        /* Footer styles */
        .admin-footer {
            text-align: center;
            padding: 20px;
            margin-top: 30px;
            border-top: 1px solid var(--border-color);
            color: var(--text-muted);
            font-size: 14px;
        }

        .footer-version {
            margin-bottom: 10px;
        }

        .footer-update {
            display: none;
            background: var(--warning-bg);
            border: 1px solid var(--warning-border);
            color: var(--warning-color);
            padding: 10px 15px;
            border-radius: 5px;
            margin-top: 10px;
            display: inline-block;
        }

        .footer-update a {
            color: var(--button-bg);
            text-decoration: none;
            font-weight: bold;
        }

        .footer-update a:hover {
            text-decoration: underline;
        }

        .footer-update.hidden {
            display: none;
        }

        .footer-restart {
            margin-top: 10px;
            color: var(--text-muted);
        }

        .footer-restart.hidden {
            display: none;
        }

        /* Theme toggle button */
        .top-right-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .theme-toggle {
            background: var(--light-bg);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            padding: 8px;
            cursor: pointer;
            font-size: 16px;
            color: var(--text-color);
            transition: all 0.3s ease;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .theme-toggle:hover {
            background: var(--border-color);
        }

        /* Dark mode overrides for form elements */
        [data-theme="dark"] input[type="text"],
        [data-theme="dark"] input[type="number"],
        [data-theme="dark"] input[type="password"],
        [data-theme="dark"] textarea,
        [data-theme="dark"] select {
            background: var(--light-bg);
            color: var(--text-color);
            border-color: var(--border-color);
        }

        [data-theme="dark"] .question-item {
            background: var(--light-bg);
        }

        [data-theme="dark"] .question-header {
            background: #3a3a3a;
        }

        [data-theme="dark"] .question-header:hover {
            background: #444;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="top-right-controls">
            <button class="theme-toggle" onclick="toggleTheme()" title="–ü–µ—Ä–µ–º–∫–Ω—É—Ç–∏ —Ç–µ–º—É">üåô</button>
        </div>
        <h1>üîß –ü–∞–Ω–µ–ª—å –ê–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–∞ WebQuiz</h1>

        <!-- Authentication Section -->
        <div id="auth-section">
            <div class="form-group">
                <label for="master-key">–ö–ª—é—á:</label>
                <input type="password" id="master-key" placeholder="–í–≤–µ–¥—ñ—Ç—å –∫–ª—é—á">
            </div>
            <div class="actions">
                <button onclick="authenticate()">–£–≤—ñ–π—Ç–∏</button>
            </div>
        </div>

        <!-- Admin Panel (hidden until authenticated) -->
        <div id="admin-panel" class="hidden">

            <div class="form-group">
                <label>–î–æ—Å—Ç—É–ø–Ω—ñ –§–∞–π–ª–∏ Quiz:</label>
                <select id="quiz-select" class="quiz-select" multiple size="8">
                    <!-- Options populated by JavaScript -->
                </select>
                <div class="selection-hint">
                    Ctrl+–∫–ª—ñ–∫ –¥–ª—è –≤–∏–±–æ—Ä—É –¥–µ–∫—ñ–ª—å–∫–æ—Ö, Shift+–∫–ª—ñ–∫ –¥–ª—è –¥—ñ–∞–ø–∞–∑–æ–Ω—É
                </div>
                <div id="current-quiz-display" class="current-quiz-display no-quiz">
                    –ü–æ—Ç–æ—á–Ω–∏–π quiz: –Ω–µ –≤–∏–±—Ä–∞–Ω–æ
                </div>
            </div>

            <div class="actions" id="single-quiz-actions">
                <button id="switch-btn" onclick="switchQuiz()" disabled>–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç–∏—Å—è –Ω–∞ –í–∏–±—Ä–∞–Ω–∏–π Quiz</button>
                <button onclick="refreshQuizzes()">üîÑ</button>
                <button id="edit-btn" onclick="editSelectedQuiz()" disabled>‚úèÔ∏è</button>
                <button id="duplicate-btn" onclick="duplicateSelectedQuiz()" disabled>üìã</button>
            </div>

            <div class="actions hidden" id="multi-quiz-actions">
                <button id="unite-btn" onclick="uniteSelectedQuizzes()" class="btn-success">üîó –û–±'—î–¥–Ω–∞—Ç–∏ quizzes</button>
                <button onclick="refreshQuizzes()">üîÑ</button>
            </div>

            <div class="quiz-actions">
                <button onclick="createNewQuiz()">üìù –°—Ç–≤–æ—Ä–∏—Ç–∏ –ù–æ–≤–∏–π Quiz</button>
                <button id="delete-btn" onclick="deleteSelectedQuiz()" disabled class="btn-danger">üóëÔ∏è –í–∏–¥–∞–ª–∏—Ç–∏ Quiz</button>
            </div>

            <!-- Pending Approvals Section (only shown when registration.approve is true) -->
            <div id="pending-approvals-section" class="pending-approvals hidden">
                <h3 style="margin-top: 0;">‚è≥ –û—á—ñ–∫—É—é—á—ñ –ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è</h3>
                <div id="pending-users-list">
                    <p style="text-align: center; color: var(--text-muted);">–ù–µ–º–∞—î –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤, —â–æ –æ—á—ñ–∫—É—é—Ç—å –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è</p>
                </div>
            </div>

            <!-- Show Answers Control Section -->
            <div id="show-answers-section" class="show-answers-control hidden" style="margin-top: 20px;">
                <div style="background: var(--light-bg); padding: 15px; border-radius: 5px; border-left: 4px solid var(--button-bg);">
                    <p style="margin: 0 0 10px 0; color: var(--text-muted); font-size: 14px;">
                        –î–æ–∑–≤–æ–ª—è—î –≤—ñ–¥–∫—Ä–∏—Ç–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ –¥–ª—è –≤—Å—ñ—Ö —É—á–Ω—ñ–≤, –Ω–µ —á–µ–∫–∞—é—á–∏ –ø–æ–∫–∏ –≤—Å—ñ –∑–∞–≤–µ—Ä—à–∞—Ç—å —Ç–µ—Å—Ç.
                    </p>
                    <div id="answers-status" style="margin-bottom: 10px; padding: 8px; border-radius: 4px; font-weight: bold; display: none;">
                        <!-- Status will be shown here when answers are forced -->
                    </div>
                    <button id="show-answers-btn" onclick="forceShowAnswers()"
                            style="background: #ff9800; color: white; border: 2px solid #f57c00; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 14px;">
                        üîì –í—ñ–¥–∫—Ä–∏—Ç–∏ –í—ñ–¥–ø–æ–≤—ñ–¥—ñ –¥–ª—è –í—Å—ñ—Ö
                    </button>
                </div>
            </div>

            <!-- Downloadable Quizzes Section -->
            <div id="downloadable-quizzes-section" class="downloadable-quizzes hidden">
                <div class="form-group">
                    <label>–î–æ—Å—Ç—É–ø–Ω—ñ Quiz –¥–ª—è –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è:</label>
                    <div id="downloadable-quiz-list" class="quiz-list">
                        <!-- Downloadable quizzes will be populated by JavaScript -->
                    </div>
                </div>
            </div>

            <!-- Network Access Information -->
            <div class="network-info" id="network-info">
                <div id="access-urls" class="info-section">
                    <strong>URL –¥–ª—è –¥–æ—Å—Ç—É–ø—É –∑ —ñ–Ω—à–∏—Ö –ø—Ä–∏—Å—Ç—Ä–æ—ó–≤:</strong>
                    <div id="url-list" class="url-list">
                        –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è –º–µ—Ä–µ–∂–µ–≤–∏—Ö —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ñ–≤...
                    </div>
                </div>
            </div>

            <!-- SSH Tunnel Section -->
            <div class="tunnel-info" id="tunnel-section" style="display: none;">
                <h3>SSH Tunnel</h3>
                <div class="info-section">
                    <strong>Server:</strong> <span id="tunnel-server"></span>
                </div>
                <div id="tunnel-socket-name-section" class="info-section" style="display: none;">
                    <strong>Socket Name:</strong> <span id="tunnel-socket-name"></span>
                </div>
                <div id="tunnel-public-key-section" class="info-section" style="display: none;">
                    <strong>Public Key:</strong>
                    <div style="display: flex; align-items: center; gap: 10px; margin-top: 5px;">
                        <textarea id="tunnel-public-key" readonly style="flex: 1; font-family: monospace; font-size: 12px; padding: 8px; min-height: 30px; resize: vertical; background: #f5f5f5; border: 1px solid #ddd; border-radius: 4px;"></textarea>
                        <button id="copy-public-key-btn" onclick="copyPublicKey()" style="align-self: flex-start; padding: 8px 12px; white-space: nowrap;">üìã Copy</button>
                    </div>
                </div>
                <div class="info-section">
                    <button id="tunnel-connect-btn" onclick="toggleTunnel()" style="margin-top: 10px;">Connect</button>
                </div>
                <div id="tunnel-error" class="tunnel-error" style="display: none;"></div>
            </div>

            <div class="back-link">
                <a href="/">‚Üê –ù–∞–∑–∞–¥ –¥–æ Quiz</a>
                <span style="margin: 0 10px;">|</span>
                <a href="/files/">üìÅ File Manager</a>
                <span style="margin: 0 10px;">|</span>
                <a href="/live-stats/">üìä Live Stats</a>
            </div>

            <!-- Footer -->
            <div class="admin-footer">
                <div class="footer-version" id="footer-version">
                    WebQuiz v<span id="version-number">...</span>
                    <span id="footer-docs-link" style="margin-left: 15px;"></span>
                </div>
                <div id="footer-update" class="footer-update hidden"></div>
                <div id="footer-restart" class="footer-restart hidden">
                    New version installed (v<span id="new-version-number"></span>), restart required
                </div>
            </div>
        </div>

        <!-- Messages -->
        <div id="message-area"></div>
    </div>

    <!-- Quiz Editor Modal -->
    <div id="quiz-editor-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modal-title">–°—Ç–≤–æ—Ä–∏—Ç–∏ –ù–æ–≤–∏–π Quiz</h2>
                <span class="close" onclick="closeQuizEditor()">&times;</span>
            </div>

            <div class="form-group">
                <label for="quiz-filename">–Ü–º'—è –§–∞–π–ª—É Quiz:</label>
                <input type="text" id="quiz-filename" placeholder="–í–≤–µ–¥—ñ—Ç—å —ñ–º'—è —Ñ–∞–π–ª—É (–±–µ–∑ —Ä–æ–∑—à–∏—Ä–µ–Ω–Ω—è .yaml)" style="width: 100%;">
            </div>

            <div class="editor-content">
                <!-- Wizard Form -->
                <div id="wizard-form">
                    <div class="form-group">
                        <label>–ù–∞–∑–≤–∞ Quiz (–Ω–µ–æ–±–æ–≤'—è–∑–∫–æ–≤–æ):</label>
                        <input type="text" id="quiz-title" placeholder="–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –ú–∞—Ç–µ–º–∞—Ç–∏—á–Ω–∏–π Quiz" style="width: 100%;">
                    </div>
                    <div class="form-group">
                        <label style="display: flex; align-items: center;">
                            <input type="checkbox" id="show-right-answer" checked style="margin-right: 10px;" onchange="toggleShowAnswersOnCompletion()">
                            –ü–æ–∫–∞–∑—É–≤–∞—Ç–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ
                        </label>
                    </div>
                    <div class="form-group" id="show-answers-on-completion-group" style="display: none;">
                        <label style="display: flex; align-items: center;">
                            <input type="checkbox" id="show-answers-on-completion" style="margin-right: 10px;">
                            –ü–æ–∫–∞–∑—É–≤–∞—Ç–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –≤—Å—ñ–º–∞
                        </label>
                    </div>
                    <div class="form-group">
                        <label style="display: flex; align-items: center;">
                            <input type="checkbox" id="randomize-questions" style="margin-right: 10px;">
                            –†–∞–Ω–¥–æ–º—ñ–∑—É–≤–∞—Ç–∏ –ø–æ—Ä—è–¥–æ–∫ –ø–∏—Ç–∞–Ω—å
                        </label>
                    </div>
                    <div class="form-group">
                        <div id="questions-container">
                            <!-- Questions will be added dynamically -->
                        </div>
                        <button type="button" onclick="addQuestion()">‚ûï –î–æ–¥–∞—Ç–∏ –ü–∏—Ç–∞–Ω–Ω—è</button>
                    </div>
                </div>
            </div>

            <div class="actions-sticky">
                <button onclick="saveQuiz()">üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ Quiz</button>
                <button id="save-continue-btn" onclick="saveQuizAndContinue()">üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ —ñ –ü—Ä–æ–¥–æ–≤–∂–∏—Ç–∏</button>
                <button onclick="closeQuizEditor()">‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏</button>
            </div>
        </div>
    </div>

    <!-- Image Picker Modal -->
    <div id="image-picker-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üì∑ –í–∏–±—Ä–∞—Ç–∏ –ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è</h2>
                <span class="close" onclick="closeImagePicker()">&times;</span>
            </div>

            <div id="image-picker-content">
                <div id="image-grid" class="image-grid">
                    –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω—å...
                </div>
            </div>
        </div>
    </div>

    <!-- Fullscreen Image Preview Modal -->
    <div id="image-fullscreen-modal" class="image-fullscreen-modal" onclick="closeFullscreenPreview()">
        <span class="image-fullscreen-close">&times;</span>
        <img id="fullscreen-image" src="" alt="Full size preview">
    </div>

    <!-- File Picker Modal -->
    <div id="file-picker-modal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h2>üìé –í–∏–±—Ä–∞—Ç–∏ –§–∞–π–ª</h2>
                <span class="close" onclick="closeFilePicker()">&times;</span>
            </div>

            <div id="file-picker-content">
                <div id="file-list" class="file-list">
                    –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—ñ–≤...
                </div>
            </div>
        </div>
    </div>

    <script>
        // Theme management
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            if (savedTheme === 'dark') {
                document.body.setAttribute('data-theme', 'dark');
                document.querySelector('.theme-toggle').textContent = '‚òÄÔ∏è';
            }
        }

        function toggleTheme() {
            const currentTheme = document.body.getAttribute('data-theme');
            const toggleButton = document.querySelector('.theme-toggle');

            if (currentTheme === 'dark') {
                document.body.removeAttribute('data-theme');
                toggleButton.textContent = 'üåô';
                localStorage.setItem('theme', 'light');
            } else {
                document.body.setAttribute('data-theme', 'dark');
                toggleButton.textContent = '‚òÄÔ∏è';
                localStorage.setItem('theme', 'dark');
            }
        }

        // Initialize theme on page load
        initializeTheme();

        let currentMasterKey = '';
        let selectedQuizzes = [];  // Array of selected quiz filenames
        let currentQuiz = '';

        // HTML escape function to prevent quote truncation in form inputs
        function escapeHtml(text) {
            if (text === null || text === undefined) {
                return '';
            }
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            };
            return String(text).replace(/[&<>"']/g, m => map[m]);
        }

        // Toggle visibility of show_answers_on_completion based on show_right_answer state
        function toggleShowAnswersOnCompletion() {
            const showRightAnswer = document.getElementById('show-right-answer').checked;
            const showAnswersOnCompletionGroup = document.getElementById('show-answers-on-completion-group');

            // Only show the option when show_right_answer is FALSE
            if (showRightAnswer) {
                showAnswersOnCompletionGroup.style.display = 'none';
                // Also uncheck it when hiding
                document.getElementById('show-answers-on-completion').checked = false;
            } else {
                showAnswersOnCompletionGroup.style.display = 'block';
            }
        }

        async function authenticate() {
            const masterKey = document.getElementById('master-key').value.trim();
            if (!masterKey) {
                showMessage('–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –∫–ª—é—á', 'error');
                return;
            }

            try {
                const response = await fetch('/api/admin/auth', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({master_key: masterKey}),
                    credentials: 'same-origin'  // Include cookies for session
                });

                const data = await response.json();

                if (response.ok) {
                    currentMasterKey = 'session';  // Session is now managed by cookie
                    document.getElementById('auth-section').style.display = 'none';
                    document.getElementById('admin-panel').classList.remove('hidden');
                    showMessage('–£—Å–ø—ñ—à–Ω–∞ –∞–≤—Ç–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ü—ñ—è!', 'success');
                    await loadQuizzes();
                    displayNetworkInfo();
                    displayDownloadableQuizzes();
                    connectToAdminWebSocket(); // Connect to admin WebSocket for approvals
                    displayVersion(); // Display version in footer
                    checkForUpdates(); // Check for updates
                } else {
                    showMessage(data.error || '–ê–≤—Ç–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ü—ñ—è –Ω–µ–≤–¥–∞–ª–∞', 'error');
                }
            } catch (error) {
                showMessage('–ü–æ–º–∏–ª–∫–∞ –∑\'—î–¥–Ω–∞–Ω–Ω—è: ' + error.message, 'error');
            }
        }

        async function loadQuizzes() {
            try {
                const response = await fetch('/api/admin/list-quizzes', {
                    credentials: 'same-origin'
                });

                const data = await response.json();

                if (response.ok) {
                    currentQuiz = data.current_quiz;
                    displayQuizzes(data.quizzes);
                    // Initialize button state based on force_all_completed flag
                    if (data.force_all_completed !== undefined) {
                        updateAnswersForcedStatus(data.force_all_completed);
                    }
                    // Show/hide answer control section based on show_answers_on_completion flag
                    const showAnswersSection = document.getElementById('show-answers-section');
                    if (data.show_answers_on_completion === true) {
                        showAnswersSection.classList.remove('hidden');
                    } else {
                        showAnswersSection.classList.add('hidden');
                    }
                } else {
                    showMessage(data.error || '–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ quiz', 'error');
                }
            } catch (error) {
                showMessage('–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è quiz: ' + error.message, 'error');
            }
        }

        function displayQuizzes(quizzes) {
            const quizSelect = document.getElementById('quiz-select');
            const currentQuizDisplay = document.getElementById('current-quiz-display');

            if (quizzes.length === 0) {
                quizSelect.innerHTML = '<option disabled>–§–∞–π–ª–∏ quiz –Ω–µ –∑–Ω–∞–π–¥–µ–Ω—ñ</option>';
                updateCurrentQuizDisplay(null, null);
                return;
            }

            quizSelect.innerHTML = '';
            let currentQuizTitle = null;
            quizzes.forEach(quiz => {
                const option = document.createElement('option');
                const filename = quiz.filename;
                const title = quiz.title;
                option.value = filename;

                // Build display text: filename with optional title
                let displayText = filename;
                if (title) {
                    displayText = `${filename} - ${title}`;
                }
                if (filename === currentQuiz) {
                    displayText += ' (–ø–æ—Ç–æ—á–Ω–∏–π)';
                    option.classList.add('current-quiz');
                    currentQuizTitle = title;
                }
                option.textContent = displayText;
                quizSelect.appendChild(option);
            });

            // Update current quiz display
            updateCurrentQuizDisplay(currentQuiz, currentQuizTitle);

            // Add change event listener
            quizSelect.onchange = handleQuizSelectionChange;

            // Update button visibility based on current selection state
            updateButtonVisibility();
        }

        function updateCurrentQuizDisplay(quizFilename, quizTitle) {
            const display = document.getElementById('current-quiz-display');
            if (quizFilename) {
                let text = `–ü–æ—Ç–æ—á–Ω–∏–π quiz: ${quizFilename}`;
                if (quizTitle) {
                    text += ` - ${quizTitle}`;
                }
                display.textContent = text;
                display.classList.remove('no-quiz');
            } else {
                display.textContent = '–ü–æ—Ç–æ—á–Ω–∏–π quiz: –Ω–µ –≤–∏–±—Ä–∞–Ω–æ';
                display.classList.add('no-quiz');
            }
        }

        function handleQuizSelectionChange() {
            const quizSelect = document.getElementById('quiz-select');
            selectedQuizzes = Array.from(quizSelect.selectedOptions).map(opt => opt.value);
            updateButtonVisibility();
        }

        function updateButtonVisibility() {
            const singleActions = document.getElementById('single-quiz-actions');
            const multiActions = document.getElementById('multi-quiz-actions');
            const switchBtn = document.getElementById('switch-btn');
            const editBtn = document.getElementById('edit-btn');
            const duplicateBtn = document.getElementById('duplicate-btn');
            const deleteBtn = document.getElementById('delete-btn');

            const count = selectedQuizzes.length;

            if (count === 0) {
                // No selection - show single actions, all disabled
                singleActions.classList.remove('hidden');
                multiActions.classList.add('hidden');
                switchBtn.disabled = true;
                editBtn.disabled = true;
                duplicateBtn.disabled = true;
                deleteBtn.disabled = true;
            } else if (count === 1) {
                // Single selection - show standard buttons
                singleActions.classList.remove('hidden');
                multiActions.classList.add('hidden');

                const selected = selectedQuizzes[0];
                switchBtn.disabled = false;
                switchBtn.textContent = selected === currentQuiz
                    ? '–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–∏ –ü–æ—Ç–æ—á–Ω–∏–π Quiz'
                    : '–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç–∏—Å—è –Ω–∞ –í–∏–±—Ä–∞–Ω–∏–π Quiz';
                editBtn.disabled = false;
                duplicateBtn.disabled = false;
                deleteBtn.disabled = selected === currentQuiz;
            } else {
                // Multiple selection - show unite button, hide switch/edit/duplicate
                singleActions.classList.add('hidden');
                multiActions.classList.remove('hidden');

                // Delete enabled if none of selected is current quiz
                deleteBtn.disabled = selectedQuizzes.includes(currentQuiz);
            }
        }

        async function switchQuiz() {
            if (selectedQuizzes.length !== 1) {
                showMessage('–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–∏–±–µ—Ä—ñ—Ç—å –æ–¥–∏–Ω quiz', 'warning');
                return;
            }

            const selectedQuiz = selectedQuizzes[0];
            const isRestart = selectedQuiz === currentQuiz;

            const switchBtn = document.getElementById('switch-btn');
            switchBtn.disabled = true;
            switchBtn.textContent = isRestart ? 'Restarting...' : 'Switching...';

            try {
                const response = await fetch('/api/admin/switch-quiz', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        quiz_filename: selectedQuiz
                    }),
                    credentials: 'same-origin'
                });

                const data = await response.json();

                if (response.ok) {
                    const action = isRestart ? 'restarted' : 'switched to';
                    showMessage(`Successfully ${action} "${selectedQuiz}". CSV file: ${data.csv_file}`, 'success');
                    currentQuiz = selectedQuiz;

                    // Refresh the quiz list to update current indicators
                    await loadQuizzes();

                    // Reset selection
                    selectedQuizzes = [];
                    switchBtn.textContent = '–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç–∏—Å—è –Ω–∞ –í–∏–±—Ä–∞–Ω–∏–π Quiz';
                } else {
                    showMessage(data.error || `Failed to ${isRestart ? 'restart' : 'switch'} quiz`, 'error');
                    switchBtn.disabled = false;
                    switchBtn.textContent = isRestart ? 'Restart Current Quiz' : 'Switch to Selected Quiz';
                }
            } catch (error) {
                showMessage(`Error ${isRestart ? 'restarting' : 'switching'} quiz: ` + error.message, 'error');
                switchBtn.disabled = false;
                switchBtn.textContent = isRestart ? 'Restart Current Quiz' : 'Switch to Selected Quiz';
            }
        }

        async function refreshQuizzes() {
            await loadQuizzes();
            showMessage('–°–ø–∏—Å–æ–∫ quiz –æ–Ω–æ–≤–ª–µ–Ω–æ', 'success');
        }

        function showMessage(text, type) {
            const messageArea = document.getElementById('message-area');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = text;

            messageArea.appendChild(messageDiv);

            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        // Allow Enter key to authenticate
        document.getElementById('master-key').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                authenticate();
            }
        });

        // Quiz Editor Variables
        let isEditMode = false;
        let editingQuizName = '';
        let questionCounter = 1;

        // Quiz Editor Functions
        function createNewQuiz() {
            isEditMode = false;
            editingQuizName = '';
            document.getElementById('modal-title').textContent = '–°—Ç–≤–æ—Ä–∏—Ç–∏ –ù–æ–≤–∏–π Quiz';
            document.getElementById('quiz-filename').value = '';
            document.getElementById('quiz-filename').disabled = false;
            resetQuizEditor();
            document.getElementById('quiz-editor-modal').style.display = 'block';
        }

        async function editSelectedQuiz(quizFilename = null) {
            // If quizFilename is provided, use it; otherwise check selection
            if (!quizFilename && selectedQuizzes.length !== 1) {
                showMessage('–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–∏–±–µ—Ä—ñ—Ç—å –æ–¥–∏–Ω quiz –¥–ª—è —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è', 'warning');
                return;
            }

            const selectedQuiz = quizFilename || selectedQuizzes[0];
            isEditMode = true;
            editingQuizName = selectedQuiz;
            document.getElementById('modal-title').textContent = `–†–µ–¥–∞–≥—É–≤–∞—Ç–∏ Quiz: ${selectedQuiz}`;
            document.getElementById('quiz-filename').value = selectedQuiz.replace('.yaml', '');
            document.getElementById('quiz-filename').disabled = false;

            try {
                const response = await fetch(`/api/admin/quiz/${selectedQuiz}`, {
                    credentials: 'same-origin'
                });

                const data = await response.json();

                if (response.ok) {
                    // Load quiz data into editor
                    if (data.parsed) {
                        loadQuizDataToWizard(data.parsed);
                    }
                    document.getElementById('quiz-editor-modal').style.display = 'block';
                } else {
                    showMessage(data.error || '–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ quiz', 'error');
                }
            } catch (error) {
                showMessage('–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è quiz: ' + error.message, 'error');
            }
        }

        async function duplicateSelectedQuiz() {
            if (selectedQuizzes.length !== 1) {
                showMessage('–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–∏–±–µ—Ä—ñ—Ç—å –æ–¥–∏–Ω quiz –¥–ª—è –¥—É–±–ª—é–≤–∞–Ω–Ω—è', 'warning');
                return;
            }

            const selectedQuiz = selectedQuizzes[0];
            const newFilename = prompt(`–í–≤–µ–¥—ñ—Ç—å —ñ–º'—è –¥–ª—è –¥—É–±–ª—å–æ–≤–∞–Ω–æ–≥–æ quiz:`, selectedQuiz.replace('.yaml', '_copy'));
            if (!newFilename) {
                return;
            }

            try {
                // First get the original quiz content
                const getResponse = await fetch(`/api/admin/quiz/${selectedQuiz}`, {
                    credentials: 'same-origin'
                });

                const getResult = await getResponse.json();

                if (!getResponse.ok) {
                    showMessage(getResult.error || '–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏–π quiz', 'error');
                    return;
                }

                // Create new quiz with the same content
                const createResponse = await fetch('/api/admin/create-quiz', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        filename: newFilename,
                        mode: 'text',
                        content: getResult.content
                    }),
                    credentials: 'same-origin'
                });

                const createResult = await createResponse.json();

                if (createResponse.ok) {
                    showMessage(`Quiz duplicated successfully as "${createResult.filename}"`, 'success');
                    await loadQuizzes();
                    // Automatically open the duplicated quiz for editing
                    await editSelectedQuiz(createResult.filename);
                } else {
                    showMessage(createResult.error || '–ù–µ –≤–¥–∞–ª–æ—Å—è –¥—É–±–ª—é–≤–∞—Ç–∏ quiz', 'error');
                }
            } catch (error) {
                showMessage('–ü–æ–º–∏–ª–∫–∞ –¥—É–±–ª—é–≤–∞–Ω–Ω—è quiz: ' + error.message, 'error');
            }
        }

        async function deleteSelectedQuiz() {
            if (selectedQuizzes.length === 0) {
                showMessage('–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–∏–±–µ—Ä—ñ—Ç—å quiz –¥–ª—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è', 'warning');
                return;
            }

            // Check if any selected is current quiz
            if (selectedQuizzes.includes(currentQuiz)) {
                showMessage('–ù–µ–º–æ–∂–ª–∏–≤–æ –≤–∏–¥–∞–ª–∏—Ç–∏ –ø–æ—Ç–æ—á–Ω–∏–π –∞–∫—Ç–∏–≤–Ω–∏–π quiz', 'error');
                return;
            }

            const message = selectedQuizzes.length === 1
                ? `–í–∏ –≤–ø–µ–≤–Ω–µ–Ω—ñ, —â–æ —Ö–æ—á–µ—Ç–µ –≤–∏–¥–∞–ª–∏—Ç–∏ "${selectedQuizzes[0]}"?`
                : `–í–∏ –≤–ø–µ–≤–Ω–µ–Ω—ñ, —â–æ —Ö–æ—á–µ—Ç–µ –≤–∏–¥–∞–ª–∏—Ç–∏ ${selectedQuizzes.length} quiz(—ñ–≤)?`;

            if (!confirm(message + ' –¶—è –¥—ñ—è –Ω–µ –º–æ–∂–µ –±—É—Ç–∏ —Å–∫–∞—Å–æ–≤–∞–Ω–∞.')) {
                return;
            }

            // Delete each quiz sequentially
            const errors = [];
            let successCount = 0;

            for (const quiz of selectedQuizzes) {
                try {
                    const response = await fetch(`/api/admin/quiz/${quiz}`, {
                        method: 'DELETE',
                        credentials: 'same-origin'
                    });

                    if (response.ok) {
                        successCount++;
                    } else {
                        const data = await response.json();
                        errors.push(`${quiz}: ${data.error || '–ü–æ–º–∏–ª–∫–∞'}`);
                    }
                } catch (error) {
                    errors.push(`${quiz}: ${error.message}`);
                }
            }

            if (errors.length === 0) {
                showMessage(`–£—Å–ø—ñ—à–Ω–æ –≤–∏–¥–∞–ª–µ–Ω–æ ${successCount} quiz(—ñ–≤)`, 'success');
            } else if (successCount > 0) {
                showMessage(`–í–∏–¥–∞–ª–µ–Ω–æ ${successCount} quiz(—ñ–≤). –ü–æ–º–∏–ª–∫–∏: ${errors.join(', ')}`, 'warning');
            } else {
                showMessage(`–ü–æ–º–∏–ª–∫–∞ –≤–∏–¥–∞–ª–µ–Ω–Ω—è: ${errors.join(', ')}`, 'error');
            }

            selectedQuizzes = [];
            await loadQuizzes();
        }

        async function uniteSelectedQuizzes() {
            if (selectedQuizzes.length < 2) {
                showMessage('–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–∏–±–µ—Ä—ñ—Ç—å –ø—Ä–∏–Ω–∞–π–º–Ω—ñ 2 quiz –¥–ª—è –æ–±\'—î–¥–Ω–∞–Ω–Ω—è', 'warning');
                return;
            }

            // Suggest name based on first quiz
            const suggestedName = selectedQuizzes[0].replace('.yaml', '_united');
            const newFilename = prompt(
                `–í–≤–µ–¥—ñ—Ç—å —ñ–º'—è –¥–ª—è –æ–±'—î–¥–Ω–∞–Ω–æ–≥–æ quiz (${selectedQuizzes.length} quizzes):`,
                suggestedName
            );

            if (!newFilename) {
                return;
            }

            const uniteBtn = document.getElementById('unite-btn');
            uniteBtn.disabled = true;
            uniteBtn.textContent = '–û–±\'—î–¥–Ω–∞–Ω–Ω—è...';

            try {
                const response = await fetch('/api/admin/unite-quizzes', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        quiz_filenames: selectedQuizzes,
                        new_name: newFilename
                    }),
                    credentials: 'same-origin'
                });

                const data = await response.json();

                if (response.ok) {
                    let message = `Quiz —É—Å–ø—ñ—à–Ω–æ –æ–±'—î–¥–Ω–∞–Ω–æ –≤ "${data.filename}". –ó–∞–≥–∞–ª–æ–º –ø–∏—Ç–∞–Ω—å: ${data.total_questions}`;
                    if (data.warning) {
                        message += `. ${data.warning}`;
                    }
                    showMessage(message, 'success');
                    selectedQuizzes = [];
                    await loadQuizzes();
                    // Automatically open the united quiz for editing
                    await editSelectedQuiz(data.filename);
                } else {
                    showMessage(data.error || '–ù–µ –≤–¥–∞–ª–æ—Å—è –æ–±\'—î–¥–Ω–∞—Ç–∏ quizzes', 'error');
                }
            } catch (error) {
                showMessage('–ü–æ–º–∏–ª–∫–∞ –æ–±\'—î–¥–Ω–∞–Ω–Ω—è quiz: ' + error.message, 'error');
            } finally {
                uniteBtn.disabled = false;
                uniteBtn.textContent = 'üîó –û–±\'—î–¥–Ω–∞—Ç–∏ quizzes';
            }
        }

        function closeQuizEditor() {
            document.getElementById('quiz-editor-modal').style.display = 'none';
            resetQuizEditor();
        }

        function resetQuizEditor() {
            questionCounter = 1;

            // Clear content
            document.getElementById('questions-container').innerHTML = '';

            // Add initial question
            addQuestion();
        }

        function addQuestion(collapsed = false) {
            const container = document.getElementById('questions-container');
            const questionDiv = document.createElement('div');
            questionDiv.className = collapsed ? 'question-item collapsed' : 'question-item';
            questionDiv.dataset.questionId = questionCounter;
            questionDiv.draggable = true;

            questionDiv.innerHTML = `
                <div class="question-header" onclick="toggleQuestionCollapse(${questionCounter}, event)">
                    <div class="question-header-left">
                        <span class="drag-handle" title="–ü–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å –¥–ª—è –∑–º—ñ–Ω–∏ –ø–æ—Ä—è–¥–∫—É">‚ò∞</span>
                        <span class="question-collapse-icon">‚ñº</span>
                        <span class="question-number">${questionCounter}.</span>
                        <span class="question-indicators"></span>
                        <span class="question-preview"></span>
                    </div>
                    <div class="question-header-buttons">
                        <button type="button" onclick="moveQuestion(${questionCounter}, 'up', event)" title="–ü–µ—Ä–µ–º—ñ—Å—Ç–∏—Ç–∏ –≤–≥–æ—Ä—É">‚Üë</button>
                        <button type="button" onclick="moveQuestion(${questionCounter}, 'down', event)" title="–ü–µ—Ä–µ–º—ñ—Å—Ç–∏—Ç–∏ –≤–Ω–∏–∑">‚Üì</button>
                        <button type="button" onclick="removeQuestion(${questionCounter}, event)" class="btn-danger" title="–í–∏–¥–∞–ª–∏—Ç–∏">√ó</button>
                    </div>
                </div>
                <div class="question-body">
                    <div class="form-group">
                        <label>–¢–µ–∫—Å—Ç –ü–∏—Ç–∞–Ω–Ω—è (–Ω–µ–æ–±–æ–≤'—è–∑–∫–æ–≤–æ, —è–∫—â–æ —î –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è):</label>
                        <input type="text" class="question-text" placeholder="–í–≤–µ–¥—ñ—Ç—å —Ç–µ–∫—Å—Ç –ø–∏—Ç–∞–Ω–Ω—è" style="width: 100%;" oninput="updateQuestionPreview(this)">
                    </div>
                    <div class="form-group">
                        <label>–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è –ü–∏—Ç–∞–Ω–Ω—è (–Ω–µ–æ–±–æ–≤'—è–∑–∫–æ–≤–æ, —è–∫—â–æ —î —Ç–µ–∫—Å—Ç):</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <input type="text" class="question-image" placeholder="–Ω–∞–ø—Ä., /imgs/diagram.png" style="width: 100%;" oninput="updateQuestionImagePreview(this); updateQuestionPreview(this)">
                            <button type="button" onclick="openImagePicker('question-image', ${questionCounter})" style="padding: 5px 8px; font-size: 16px;" title="Select image">üì∑</button>
                        </div>
                        <div class="image-preview-container">
                            <img class="image-preview" src="" alt="Preview" onclick="openFullscreenPreview(this.src)" title="Click to enlarge">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>–§–∞–π–ª –¥–ª—è –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è (–Ω–µ–æ–±–æ–≤'—è–∑–∫–æ–≤–æ):</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <input type="text" class="question-file" placeholder="–Ω–∞–ø—Ä., data.xlsx" style="width: 100%;" oninput="updateQuestionPreview(this)">
                            <button type="button" onclick="openFilePicker(${questionCounter})" style="padding: 5px 8px; font-size: 16px;" title="Select file">üìé</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>–¢–∏–ø –ü–∏—Ç–∞–Ω–Ω—è:</label>
                        <div style="margin: 10px 0;">
                            <button type="button" class="question-type-toggle active" data-type="single" onclick="toggleQuestionType(${questionCounter}, 'single')">üìù –û–¥–Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å</button>
                            <button type="button" class="question-type-toggle" data-type="multiple" onclick="toggleQuestionType(${questionCounter}, 'multiple')">‚òëÔ∏è –ö—ñ–ª—å–∫–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö –≤—ñ–¥–ø–æ–≤—ñ–¥–µ–π</button>
                            <button type="button" class="question-type-toggle" data-type="text" onclick="toggleQuestionType(${questionCounter}, 'text')">‚úçÔ∏è –¢–µ–∫—Å—Ç–æ–≤–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å</button>
                        </div>
                    </div>
                    <div class="choice-question-fields">
                        <div class="form-group">
                            <label>–í–∞—Ä—ñ–∞–Ω—Ç–∏ –í—ñ–¥–ø–æ–≤—ñ–¥–µ–π:</label>
                            <div class="options-container">
                                <div class="option-item">
                                    <input type="radio" name="correct-${questionCounter}" value="0" checked>
                                    <input type="text" class="option-text" placeholder="–í–∞—Ä—ñ–∞–Ω—Ç 1" oninput="updateOptionImagePreview(this)">
                                    <button type="button" onclick="openImagePicker('option-text', ${questionCounter}, 0)" style="padding: 2px 5px; font-size: 12px;" title="Select image">üì∑</button>
                                    <button type="button" onclick="removeOption(this)">√ó</button>
                                </div>
                                <div class="option-item">
                                    <input type="radio" name="correct-${questionCounter}" value="1">
                                    <input type="text" class="option-text" placeholder="–í–∞—Ä—ñ–∞–Ω—Ç 2" oninput="updateOptionImagePreview(this)">
                                    <button type="button" onclick="openImagePicker('option-text', ${questionCounter}, 1)" style="padding: 2px 5px; font-size: 12px;" title="Select image">üì∑</button>
                                    <button type="button" onclick="removeOption(this)">√ó</button>
                                </div>
                            </div>
                            <button type="button" onclick="addOption(${questionCounter})">+ –î–æ–¥–∞—Ç–∏ –í–∞—Ä—ñ–∞–Ω—Ç</button>
                        </div>
                        <div class="form-group min-correct-container" style="display: none;">
                            <label for="min-correct-${questionCounter}">–ú—ñ–Ω—ñ–º—É–º –ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö –≤—ñ–¥–ø–æ–≤—ñ–¥–µ–π:</label>
                            <input type="number" id="min-correct-${questionCounter}" class="min-correct-input" min="1" placeholder="–£—Å—ñ –ø—Ä–∞–≤–∏–ª—å–Ω—ñ" style="width: 80px;">
                        </div>
                    </div>
                    <div class="text-question-fields" style="display: none;">
                        <div class="form-group">
                            <label>–ü–æ—á–∞—Ç–∫–æ–≤–µ –ó–Ω–∞—á–µ–Ω–Ω—è (–ø–æ–∫–∞–∑—É—î—Ç—å—Å—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É):</label>
                            <textarea class="default-value-input" placeholder="–í–≤–µ–¥—ñ—Ç—å –ø–æ—á–∞—Ç–∫–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è –¥–ª—è –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è..." style="width: 100%; min-height: 60px; font-family: monospace;">0</textarea>
                        </div>
                        <div class="form-group">
                            <label>–ü—Ä–∞–≤–∏–ª—å–Ω–∞ –í—ñ–¥–ø–æ–≤—ñ–¥—å (–ø–æ–∫–∞–∑—É—î—Ç—å—Å—è –ø—Ä–∏ –ø–æ–º–∏–ª—Ü—ñ):</label>
                            <textarea class="correct-value-input" placeholder="–í–≤–µ–¥—ñ—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—É –≤—ñ–¥–ø–æ–≤—ñ–¥—å..." style="width: 100%; min-height: 60px; font-family: monospace;">1000</textarea>
                        </div>
                        <div class="form-group">
                            <label>–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ (Python –∫–æ–¥):</label>
                            <div style="display: flex; gap: 10px; margin-bottom: 5px;">
                                <select class="checker-template-select" onchange="insertCheckerTemplate(${questionCounter}, this)" style="flex: 1;">
                                    <option value="">-- –û–±–µ—Ä—ñ—Ç—å —à–∞–±–ª–æ–Ω --</option>
                                </select>
                            </div>
                            <textarea class="checker-input" style="width: 100%; min-height: 120px; font-family: monospace;">assert 900 < to_int(user_answer) < 1100, "–í–∏–π—à–ª–∏ –∑–∞ —Ä–∞–º–∫–∏"</textarea>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="points-${questionCounter}" style="display: inline-block;">–ë–∞–ª–∏ –∑–∞ –ø–∏—Ç–∞–Ω–Ω—è:</label>
                        <input type="number" id="points-${questionCounter}" class="points-input" min="1" value="1" placeholder="1" style="width: 80px;" oninput="updateQuestionPreview(this)">
                    </div>
                    <div class="form-group">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" class="stick-to-previous-checkbox" onchange="updateQuestionPreview(this)">
                            <span>–ü—Ä–∏–≤'—è–∑–∞—Ç–∏ –¥–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–≥–æ –ø–∏—Ç–∞–Ω–Ω—è (–ø—Ä–∏ —Ä–∞–Ω–¥–æ–º—ñ–∑–∞—Ü—ñ—ó)</span>
                        </label>
                    </div>
                </div>
            `;

            container.appendChild(questionDiv);
            setupDragEvents(questionDiv);
            questionCounter++;
            updateQuestionNumbers();

            // Scroll the new question into view and focus if not collapsed
            if (!collapsed) {
                questionDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

                // Focus on the question text input
                const questionTextInput = questionDiv.querySelector('.question-text');
                if (questionTextInput) {
                    setTimeout(() => questionTextInput.focus(), 300);
                }
            }
        }

        // Drag and drop functionality
        let draggedQuestion = null;

        function setupDragEvents(questionDiv) {
            questionDiv.addEventListener('dragstart', handleDragStart);
            questionDiv.addEventListener('dragend', handleDragEnd);
            questionDiv.addEventListener('dragover', handleDragOver);
            questionDiv.addEventListener('dragenter', handleDragEnter);
            questionDiv.addEventListener('dragleave', handleDragLeave);
            questionDiv.addEventListener('drop', handleDrop);
        }

        function handleDragStart(e) {
            draggedQuestion = this;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.dataset.questionId);
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            document.querySelectorAll('.question-item').forEach(item => {
                item.classList.remove('drag-over');
            });
            draggedQuestion = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            if (this !== draggedQuestion) {
                this.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            this.classList.remove('drag-over');

            if (draggedQuestion && this !== draggedQuestion) {
                const container = document.getElementById('questions-container');
                const allQuestions = Array.from(container.children);
                const draggedIndex = allQuestions.indexOf(draggedQuestion);
                const dropIndex = allQuestions.indexOf(this);

                if (draggedIndex < dropIndex) {
                    this.parentNode.insertBefore(draggedQuestion, this.nextSibling);
                } else {
                    this.parentNode.insertBefore(draggedQuestion, this);
                }

                updateQuestionNumbers();
            }
        }

        function toggleQuestionCollapse(questionId, event) {
            // Don't toggle if clicking on buttons or drag handle
            if (event && (event.target.closest('.question-header-buttons') || event.target.closest('.drag-handle'))) {
                return;
            }
            const questionDiv = document.querySelector(`[data-question-id="${questionId}"]`);
            if (questionDiv) {
                questionDiv.classList.toggle('collapsed');
            }
        }

        function updateQuestionPreview(input) {
            const questionDiv = input.closest('.question-item');
            if (!questionDiv) return;

            const previewSpan = questionDiv.querySelector('.question-preview');
            const indicatorsSpan = questionDiv.querySelector('.question-indicators');
            if (!previewSpan) return;

            const questionText = questionDiv.querySelector('.question-text').value.trim();
            const questionImage = questionDiv.querySelector('.question-image').value.trim();
            const questionFile = questionDiv.querySelector('.question-file').value.trim();
            const pointsInput = questionDiv.querySelector('.points-input');
            const points = pointsInput ? parseInt(pointsInput.value) || 1 : 1;
            const stickCheckbox = questionDiv.querySelector('.stick-to-previous-checkbox');
            const stickToPrevious = stickCheckbox ? stickCheckbox.checked : false;

            // Set preview text (full text, no truncation)
            previewSpan.textContent = questionText || '';

            // Set indicators for image, file, points, and stick_to_the_previous
            if (indicatorsSpan) {
                let indicators = '';
                if (stickToPrevious) {
                    indicators += '<span class="question-indicator" title="–ü—Ä–∏–≤\'—è–∑–∞–Ω–æ –¥–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–≥–æ">üîó</span>';
                }
                if (questionImage) {
                    indicators += '<span class="question-indicator" title="–ú–∞—î –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è">üñºÔ∏è</span>';
                }
                if (questionFile) {
                    indicators += '<span class="question-indicator" title="–ú–∞—î —Ñ–∞–π–ª">üìé</span>';
                }
                if (points > 1) {
                    indicators += `<span class="question-indicator points-indicator" title="${points} –±–∞–ª—ñ–≤"> üèÜ${points}</span>`;
                }
                indicatorsSpan.innerHTML = indicators;
            }
        }

        function removeQuestion(questionId, event) {
            if (event) event.stopPropagation();

            // Show confirmation dialog
            if (!confirm('–í–∏ –≤–ø–µ–≤–Ω–µ–Ω—ñ, —â–æ —Ö–æ—á–µ—Ç–µ –≤–∏–¥–∞–ª–∏—Ç–∏ —Ü–µ –ø–∏—Ç–∞–Ω–Ω—è?')) {
                return;
            }

            const questionDiv = document.querySelector(`[data-question-id="${questionId}"]`);
            if (questionDiv) {
                questionDiv.remove();
                updateQuestionNumbers();
            }
        }

        function moveQuestion(questionId, direction, event) {
            if (event) event.stopPropagation();
            const questionDiv = document.querySelector(`[data-question-id="${questionId}"]`);
            if (!questionDiv) return;

            const container = document.getElementById('questions-container');
            const allQuestions = Array.from(container.children);
            const currentIndex = allQuestions.indexOf(questionDiv);

            let moved = false;
            if (direction === 'up' && currentIndex > 0) {
                // Move up
                container.insertBefore(questionDiv, allQuestions[currentIndex - 1]);
                updateQuestionNumbers();
                moved = true;
            } else if (direction === 'down' && currentIndex < allQuestions.length - 1) {
                // Move down
                container.insertBefore(allQuestions[currentIndex + 1], questionDiv);
                updateQuestionNumbers();
                moved = true;
            }

            // Animate scroll to the moved question
            if (moved) {
                setTimeout(() => {
                    questionDiv.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center',
                        inline: 'nearest'
                    });

                    // Add a brief highlight animation
                    questionDiv.style.transition = 'background-color 0.3s ease';
                    const originalBg = getComputedStyle(questionDiv).backgroundColor;
                    questionDiv.style.backgroundColor = 'var(--option-selected)';

                    setTimeout(() => {
                        questionDiv.style.backgroundColor = originalBg;
                        setTimeout(() => {
                            questionDiv.style.transition = '';
                        }, 300);
                    }, 300);
                }, 50);
            }
        }

        function updateQuestionNumbers() {
            const container = document.getElementById('questions-container');
            const questions = container.children;

            // Store checked states before updating names
            const checkedStates = [];
            for (let i = 0; i < questions.length; i++) {
                const questionDiv = questions[i];
                const radioButtons = questionDiv.querySelectorAll('input[type="radio"]');
                let checkedIndex = -1;
                radioButtons.forEach((radio, index) => {
                    if (radio.checked) {
                        checkedIndex = index;
                    }
                });
                checkedStates[i] = checkedIndex;
            }

            // Update numbers and radio button names
            for (let i = 0; i < questions.length; i++) {
                const questionDiv = questions[i];
                const questionNumber = i + 1;

                // Update the visual question number in header
                const numberSpan = questionDiv.querySelector('.question-number');
                if (numberSpan) {
                    numberSpan.textContent = `${questionNumber}.`;
                }

                // Update radio button names to ensure correct grouping
                const radioButtons = questionDiv.querySelectorAll('input[type="radio"]');
                radioButtons.forEach((radio, index) => {
                    radio.name = `correct-${questionNumber}`;
                    // Restore checked state
                    radio.checked = (index === checkedStates[i]);
                });
            }

            // Update button visibility
            updateMoveButtonVisibility();
        }

        function updateMoveButtonVisibility() {
            const container = document.getElementById('questions-container');
            const questions = container.children;

            for (let i = 0; i < questions.length; i++) {
                const questionDiv = questions[i];
                const upButton = questionDiv.querySelector('button[onclick*="up"]');
                const downButton = questionDiv.querySelector('button[onclick*="down"]');

                if (upButton) {
                    upButton.style.display = i === 0 ? 'none' : 'inline-block';
                }

                if (downButton) {
                    downButton.style.display = i === questions.length - 1 ? 'none' : 'inline-block';
                }
            }
        }

        function toggleQuestionType(questionId, type) {
            const questionDiv = document.querySelector(`[data-question-id="${questionId}"]`);
            if (!questionDiv) return;

            const toggleButtons = questionDiv.querySelectorAll('.question-type-toggle');
            const optionInputs = questionDiv.querySelectorAll('.choice-question-fields input[type="radio"], .choice-question-fields input[type="checkbox"]');
            const minCorrectContainer = questionDiv.querySelector('.min-correct-container');
            const choiceFields = questionDiv.querySelector('.choice-question-fields');
            const textFields = questionDiv.querySelector('.text-question-fields');

            // Update toggle button states
            toggleButtons.forEach(btn => {
                if (btn.dataset.type === type) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Show/hide appropriate fields
            if (type === 'text') {
                // Text input question
                choiceFields.style.display = 'none';
                textFields.style.display = 'block';
                // Load checker templates
                loadCheckerTemplates(questionId);
            } else {
                // Choice question (single or multiple)
                choiceFields.style.display = 'block';
                textFields.style.display = 'none';

                // Convert input types
                if (type === 'multiple') {
                    // Convert to checkboxes
                    optionInputs.forEach(input => {
                        if (input.type === 'radio') {
                            input.type = 'checkbox';
                            input.name = `correct-${questionId}-multiple`;
                        }
                    });
                    minCorrectContainer.style.display = 'block';
                } else {
                    // Convert to radio buttons
                    optionInputs.forEach((input, index) => {
                        if (input.type === 'checkbox') {
                            input.type = 'radio';
                            input.name = `correct-${questionId}`;
                            // Keep only first checked item for radio mode
                            input.checked = index === 0;
                        }
                    });
                    minCorrectContainer.style.display = 'none';
                }
            }
        }

        // Cache for checker templates
        let checkerTemplatesCache = null;

        async function loadCheckerTemplates(questionId) {
            const questionDiv = document.querySelector(`[data-question-id="${questionId}"]`);
            if (!questionDiv) return;

            const select = questionDiv.querySelector('.checker-template-select');
            if (!select) return;

            // Check if already loaded
            if (select.options.length > 1) return;

            // Load from cache or fetch
            if (!checkerTemplatesCache) {
                try {
                    const response = await fetch('/api/admin/list-checker-templates');
                    if (response.ok) {
                        const data = await response.json();
                        checkerTemplatesCache = data.templates || [];
                    } else {
                        checkerTemplatesCache = [];
                    }
                } catch (e) {
                    console.error('Failed to load checker templates:', e);
                    checkerTemplatesCache = [];
                }
            }

            // Populate select
            checkerTemplatesCache.forEach(template => {
                const option = document.createElement('option');
                option.value = template.code;
                option.textContent = template.name;
                select.appendChild(option);
            });
        }

        function insertCheckerTemplate(questionId, selectElement) {
            if (!selectElement.value) return;

            const questionDiv = document.querySelector(`[data-question-id="${questionId}"]`);
            if (!questionDiv) return;

            const checkerInput = questionDiv.querySelector('.checker-input');
            if (checkerInput) {
                checkerInput.value = selectElement.value;
            }

            // Reset select
            selectElement.selectedIndex = 0;
        }

        function addOption(questionId) {
            const questionDiv = document.querySelector(`[data-question-id="${questionId}"]`);
            const optionsContainer = questionDiv.querySelector('.options-container');
            const optionIndex = optionsContainer.children.length;

            // Determine current question type
            const isMultiple = questionDiv.querySelector('.question-type-toggle[data-type="multiple"]').classList.contains('active');
            const inputType = isMultiple ? 'checkbox' : 'radio';
            const inputName = isMultiple ? `correct-${questionId}-multiple` : `correct-${questionId}`;

            const optionDiv = document.createElement('div');
            optionDiv.className = 'option-item';
            optionDiv.innerHTML = `
                <input type="${inputType}" name="${inputName}" value="${optionIndex}">
                <input type="text" class="option-text" placeholder="–í–∞—Ä—ñ–∞–Ω—Ç ${optionIndex + 1}" oninput="updateOptionImagePreview(this)">
                <button type="button" onclick="openImagePicker('option-text', ${questionId}, ${optionIndex})" style="padding: 2px 5px; font-size: 12px;" title="Select image">üì∑</button>
                <button type="button" onclick="removeOption(this)">√ó</button>
            `;

            optionsContainer.appendChild(optionDiv);
        }

        function removeOption(button) {
            const optionDiv = button.parentElement;
            const optionsContainer = optionDiv.parentElement;

            if (optionsContainer.children.length > 2) {
                optionDiv.remove();

                // Re-index radio buttons and update values
                Array.from(optionsContainer.children).forEach((option, index) => {
                    const radio = option.querySelector('input[type="radio"]');
                    radio.value = index;
                });
            } else {
                showMessage('–ü–∏—Ç–∞–Ω–Ω—è –º–∞—î –º–∞—Ç–∏ –ø—Ä–∏–Ω–∞–π–º–Ω—ñ 2 –≤–∞—Ä—ñ–∞–Ω—Ç–∏', 'warning');
            }
        }

        function loadQuizDataToWizard(quizData) {
            const container = document.getElementById('questions-container');
            container.innerHTML = '';
            questionCounter = 1;

            // Populate title field
            document.getElementById('quiz-title').value = quizData.title || '';

            // Populate show_right_answer field
            document.getElementById('show-right-answer').checked = quizData.show_right_answer !== false;

            // Populate randomize_questions field
            document.getElementById('randomize-questions').checked = quizData.randomize_questions === true;

            // Populate show_answers_on_completion field
            document.getElementById('show-answers-on-completion').checked = quizData.show_answers_on_completion === true;

            // Update visibility of show_answers_on_completion based on show_right_answer
            toggleShowAnswersOnCompletion();

            if (quizData.questions) {
                quizData.questions.forEach(question => {
                    const questionDiv = document.createElement('div');
                    // Start collapsed when editing existing quiz
                    questionDiv.className = 'question-item collapsed';
                    questionDiv.dataset.questionId = questionCounter;
                    questionDiv.draggable = true;

                    // Check if this is a text question (has checker)
                    const isTextQuestion = 'checker' in question;
                    const isMultipleChoice = !isTextQuestion && Array.isArray(question.correct_answer);
                    const correctAnswers = isMultipleChoice ? question.correct_answer : [question.correct_answer || 0];
                    const inputType = isMultipleChoice ? 'checkbox' : 'radio';
                    const inputName = isMultipleChoice ? `correct-${questionCounter}-multiple` : `correct-${questionCounter}`;

                    // Build options HTML (for choice questions only)
                    let optionsHtml = '';
                    if (!isTextQuestion && question.options) {
                        question.options.forEach((option, index) => {
                            const isCorrect = correctAnswers.includes(index);
                            const isImageOption = option && option.startsWith('/imgs/');
                            optionsHtml += `
                                <div class="option-item">
                                    <input type="${inputType}" name="${inputName}" value="${index}" ${isCorrect ? 'checked' : ''}>
                                    <input type="text" class="option-text" value="${escapeHtml(option)}" placeholder="–í–∞—Ä—ñ–∞–Ω—Ç ${index + 1}" oninput="updateOptionImagePreview(this)">
                                    ${isImageOption ? `<img class="option-image-preview" src="${option}" alt="Option preview" title="Click to enlarge" onclick="openFullscreenPreview(this.src)">` : ''}
                                    <button type="button" onclick="openImagePicker('option-text', ${questionCounter}, ${index})" style="padding: 2px 5px; font-size: 12px;" title="Select image">üì∑</button>
                                    <button type="button" onclick="removeOption(this)">√ó</button>
                                </div>
                            `;
                        });
                    } else if (!isTextQuestion) {
                        // Default empty options for new choice question
                        optionsHtml = `
                            <div class="option-item">
                                <input type="radio" name="${inputName}" value="0" checked>
                                <input type="text" class="option-text" placeholder="–í–∞—Ä—ñ–∞–Ω—Ç 1" oninput="updateOptionImagePreview(this)">
                                <button type="button" onclick="openImagePicker('option-text', ${questionCounter}, 0)" style="padding: 2px 5px; font-size: 12px;" title="Select image">üì∑</button>
                                <button type="button" onclick="removeOption(this)">√ó</button>
                            </div>
                            <div class="option-item">
                                <input type="radio" name="${inputName}" value="1">
                                <input type="text" class="option-text" placeholder="–í–∞—Ä—ñ–∞–Ω—Ç 2" oninput="updateOptionImagePreview(this)">
                                <button type="button" onclick="openImagePicker('option-text', ${questionCounter}, 1)" style="padding: 2px 5px; font-size: 12px;" title="Select image">üì∑</button>
                                <button type="button" onclick="removeOption(this)">√ó</button>
                            </div>
                        `;
                    }

                    const minCorrectValue = question.min_correct || '';
                    const minCorrectDisplay = isMultipleChoice ? 'block' : 'none';
                    const pointsValue = question.points || 1;

                    // Build preview text (full text, no truncation)
                    const previewText = question.question || '';

                    // Build indicators for stick_to_the_previous, image, file, and points
                    let indicatorsHtml = '';
                    if (question.stick_to_the_previous) {
                        indicatorsHtml += '<span class="question-indicator" title="–ü—Ä–∏–≤\'—è–∑–∞–Ω–æ –¥–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–≥–æ">üîó</span>';
                    }
                    if (question.image) {
                        indicatorsHtml += '<span class="question-indicator" title="–ú–∞—î –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è">üñºÔ∏è</span>';
                    }
                    if (question.file) {
                        indicatorsHtml += '<span class="question-indicator" title="–ú–∞—î —Ñ–∞–π–ª">üìé</span>';
                    }
                    if (pointsValue > 1) {
                        indicatorsHtml += `<span class="question-indicator points-indicator" title="${pointsValue} –±–∞–ª—ñ–≤">üèÜ ${pointsValue}</span>`;
                    }

                    questionDiv.innerHTML = `
                        <div class="question-header" onclick="toggleQuestionCollapse(${questionCounter}, event)">
                            <div class="question-header-left">
                                <span class="drag-handle" title="–ü–µ—Ä–µ—Ç—è–≥–Ω—ñ—Ç—å –¥–ª—è –∑–º—ñ–Ω–∏ –ø–æ—Ä—è–¥–∫—É">‚ò∞</span>
                                <span class="question-collapse-icon">‚ñº</span>
                                <span class="question-number">${questionCounter}.</span>
                                <span class="question-indicators">${indicatorsHtml}</span>
                                <span class="question-preview">${escapeHtml(previewText)}</span>
                            </div>
                            <div class="question-header-buttons">
                                <button type="button" onclick="moveQuestion(${questionCounter}, 'up', event)" title="–ü–µ—Ä–µ–º—ñ—Å—Ç–∏—Ç–∏ –≤–≥–æ—Ä—É">‚Üë</button>
                                <button type="button" onclick="moveQuestion(${questionCounter}, 'down', event)" title="–ü–µ—Ä–µ–º—ñ—Å—Ç–∏—Ç–∏ –≤–Ω–∏–∑">‚Üì</button>
                                <button type="button" onclick="removeQuestion(${questionCounter}, event)" class="btn-danger" title="–í–∏–¥–∞–ª–∏—Ç–∏">√ó</button>
                            </div>
                        </div>
                        <div class="question-body">
                            <div class="form-group">
                                <label>–¢–µ–∫—Å—Ç –ü–∏—Ç–∞–Ω–Ω—è (–Ω–µ–æ–±–æ–≤'—è–∑–∫–æ–≤–æ, —è–∫—â–æ —î –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è):</label>
                                <input type="text" class="question-text" value="${escapeHtml(question.question || '')}" placeholder="–í–≤–µ–¥—ñ—Ç—å —Ç–µ–∫—Å—Ç –ø–∏—Ç–∞–Ω–Ω—è" style="width: 100%;" oninput="updateQuestionPreview(this)">
                            </div>
                            <div class="form-group">
                                <label>–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è –ü–∏—Ç–∞–Ω–Ω—è (–Ω–µ–æ–±–æ–≤'—è–∑–∫–æ–≤–æ, —è–∫—â–æ —î —Ç–µ–∫—Å—Ç):</label>
                                <div style="display: flex; align-items: center; gap: 5px;">
                                    <input type="text" class="question-image" value="${escapeHtml(question.image || '')}" placeholder="–Ω–∞–ø—Ä., /imgs/diagram.png" style="width: 100%;" oninput="updateQuestionImagePreview(this); updateQuestionPreview(this)">
                                    <button type="button" onclick="openImagePicker('question-image', ${questionCounter})" style="padding: 5px 8px; font-size: 16px;" title="Select image">üì∑</button>
                                </div>
                                <div class="image-preview-container${question.image ? ' has-image' : ''}">
                                    <img class="image-preview" src="${question.image || ''}" alt="Preview" onclick="openFullscreenPreview(this.src)" title="Click to enlarge">
                                </div>
                            </div>
                            <div class="form-group">
                                <label>–§–∞–π–ª –¥–ª—è –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è (–Ω–µ–æ–±–æ–≤'—è–∑–∫–æ–≤–æ):</label>
                                <div style="display: flex; align-items: center; gap: 5px;">
                                    <input type="text" class="question-file" value="${escapeHtml(question.file || '')}" placeholder="–Ω–∞–ø—Ä., data.xlsx" style="width: 100%;" oninput="updateQuestionPreview(this)">
                                    <button type="button" onclick="openFilePicker(${questionCounter})" style="padding: 5px 8px; font-size: 16px;" title="Select file">üìé</button>
                                </div>
                            </div>
                            <div class="form-group">
                                <label>–¢–∏–ø –ü–∏—Ç–∞–Ω–Ω—è:</label>
                                <div style="margin: 10px 0;">
                                    <button type="button" class="question-type-toggle ${!isMultipleChoice && !isTextQuestion ? 'active' : ''}" data-type="single" onclick="toggleQuestionType(${questionCounter}, 'single')">üìù –û–¥–Ω–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å</button>
                                    <button type="button" class="question-type-toggle ${isMultipleChoice ? 'active' : ''}" data-type="multiple" onclick="toggleQuestionType(${questionCounter}, 'multiple')">‚òëÔ∏è –ö—ñ–ª—å–∫–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö –≤—ñ–¥–ø–æ–≤—ñ–¥–µ–π</button>
                                    <button type="button" class="question-type-toggle ${isTextQuestion ? 'active' : ''}" data-type="text" onclick="toggleQuestionType(${questionCounter}, 'text')">‚úçÔ∏è –¢–µ–∫—Å—Ç–æ–≤–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å</button>
                                </div>
                            </div>
                            <div class="choice-question-fields" style="display: ${isTextQuestion ? 'none' : 'block'};">
                                <div class="form-group">
                                    <label>–í–∞—Ä—ñ–∞–Ω—Ç–∏ –í—ñ–¥–ø–æ–≤—ñ–¥–µ–π:</label>
                                    <div class="options-container">
                                        ${optionsHtml}
                                    </div>
                                    <button type="button" onclick="addOption(${questionCounter})">+ –î–æ–¥–∞—Ç–∏ –í–∞—Ä—ñ–∞–Ω—Ç</button>
                                </div>
                                <div class="form-group min-correct-container" style="display: ${minCorrectDisplay};">
                                    <label for="min-correct-${questionCounter}">–ú—ñ–Ω—ñ–º—É–º –ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö –≤—ñ–¥–ø–æ–≤—ñ–¥–µ–π:</label>
                                    <input type="number" id="min-correct-${questionCounter}" class="min-correct-input" min="1" value="${minCorrectValue}" placeholder="–£—Å—ñ –ø—Ä–∞–≤–∏–ª—å–Ω—ñ" style="width: 80px;">
                                </div>
                            </div>
                            <div class="text-question-fields" style="display: ${isTextQuestion ? 'block' : 'none'};">
                                <div class="form-group">
                                    <label>–ü–æ—á–∞—Ç–∫–æ–≤–µ –ó–Ω–∞—á–µ–Ω–Ω—è (–ø–æ–∫–∞–∑—É—î—Ç—å—Å—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—É):</label>
                                    <textarea class="default-value-input" placeholder="–í–≤–µ–¥—ñ—Ç—å –ø–æ—á–∞—Ç–∫–æ–≤–µ –∑–Ω–∞—á–µ–Ω–Ω—è –¥–ª—è –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è..." style="width: 100%; min-height: 60px; font-family: monospace;">${escapeHtml(question.default_value || '')}</textarea>
                                </div>
                                <div class="form-group">
                                    <label>–ü—Ä–∞–≤–∏–ª—å–Ω–∞ –í—ñ–¥–ø–æ–≤—ñ–¥—å (–ø–æ–∫–∞–∑—É—î—Ç—å—Å—è –ø—Ä–∏ –ø–æ–º–∏–ª—Ü—ñ):</label>
                                    <textarea class="correct-value-input" placeholder="–í–≤–µ–¥—ñ—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—É –≤—ñ–¥–ø–æ–≤—ñ–¥—å..." style="width: 100%; min-height: 60px; font-family: monospace;">${escapeHtml(question.correct_value || '')}</textarea>
                                </div>
                                <div class="form-group">
                                    <label>–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ (Python –∫–æ–¥):</label>
                                    <div style="display: flex; gap: 10px; margin-bottom: 5px;">
                                        <select class="checker-template-select" onchange="insertCheckerTemplate(${questionCounter}, this)" style="flex: 1;">
                                            <option value="">-- –û–±–µ—Ä—ñ—Ç—å —à–∞–±–ª–æ–Ω --</option>
                                        </select>
                                    </div>
                                    <textarea class="checker-input" style="width: 100%; min-height: 120px; font-family: monospace;">${escapeHtml(question.checker)}</textarea>
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="points-${questionCounter}" style="display: inline-block;">–ë–∞–ª–∏ –∑–∞ –ø–∏—Ç–∞–Ω–Ω—è:</label>
                                <input type="number" id="points-${questionCounter}" class="points-input" min="1" value="${pointsValue}" placeholder="1" style="width: 80px;" oninput="updateQuestionPreview(this)">
                            </div>
                            <div class="form-group">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" class="stick-to-previous-checkbox" ${question.stick_to_the_previous ? 'checked' : ''} onchange="updateQuestionPreview(this)">
                                    <span>–ü—Ä–∏–≤'—è–∑–∞—Ç–∏ –¥–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—å–æ–≥–æ –ø–∏—Ç–∞–Ω–Ω—è (–ø—Ä–∏ —Ä–∞–Ω–¥–æ–º—ñ–∑–∞—Ü—ñ—ó)</span>
                                </label>
                            </div>
                        </div>
                    `;

                    container.appendChild(questionDiv);
                    setupDragEvents(questionDiv);
                    questionCounter++;
                });
                updateQuestionNumbers();
            }
        }

        function getWizardData() {
            const questions = [];
            const questionDivs = document.querySelectorAll('.question-item');

            questionDivs.forEach((div, index) => {
                const questionText = div.querySelector('.question-text').value.trim();
                const questionImage = div.querySelector('.question-image').value.trim();
                const questionFile = div.querySelector('.question-file').value.trim();

                // Either question text OR image must be provided
                const hasQuestionContent = questionText || questionImage;
                if (!hasQuestionContent) return;

                // Determine question type
                const isText = div.querySelector('.question-type-toggle[data-type="text"]').classList.contains('active');
                const isMultiple = div.querySelector('.question-type-toggle[data-type="multiple"]').classList.contains('active');

                let questionData;

                if (isText) {
                    // Text input question (detected by checker/correct_value, no type field needed)
                    questionData = {};

                    // Get text question fields
                    const defaultValueInput = div.querySelector('.default-value-input');
                    const correctValueInput = div.querySelector('.correct-value-input');
                    const checkerInput = div.querySelector('.checker-input');

                    if (defaultValueInput && defaultValueInput.value) {
                        questionData.default_value = defaultValueInput.value;
                    }
                    if (correctValueInput && correctValueInput.value) {
                        questionData.correct_value = correctValueInput.value;
                    }
                    if (checkerInput && checkerInput.value.trim()) {
                        questionData.checker = checkerInput.value;
                    }
                } else {
                    // Choice question (single or multiple)
                    const options = Array.from(div.querySelectorAll('.option-text')).map(input => input.value.trim());

                    // Check if we have valid options
                    if (!options.every(opt => opt) || options.length === 0) return;

                    questionData = {
                        options: options
                    };

                    if (isMultiple) {
                        // Multiple choice - collect all checked checkboxes
                        const checkedCheckboxes = Array.from(div.querySelectorAll('.choice-question-fields input[type="checkbox"]:checked'));
                        const correctAnswers = checkedCheckboxes.map(cb => parseInt(cb.value)).sort((a, b) => a - b);

                        if (correctAnswers.length > 0) {
                            questionData.correct_answer = correctAnswers;

                            // Add min_correct if specified
                            const minCorrectInput = div.querySelector('.min-correct-input');
                            if (minCorrectInput && minCorrectInput.value.trim()) {
                                const minCorrect = parseInt(minCorrectInput.value);
                                if (minCorrect > 0 && minCorrect <= correctAnswers.length) {
                                    questionData.min_correct = minCorrect;
                                }
                            }
                        } else {
                            // Default to first option if no checkboxes selected
                            questionData.correct_answer = [0];
                        }
                    } else {
                        // Single choice - get checked radio button
                        const correctRadio = div.querySelector('.choice-question-fields input[type="radio"]:checked');
                        questionData.correct_answer = correctRadio ? parseInt(correctRadio.value) : 0;
                    }
                }

                // Include question text if provided
                if (questionText) {
                    questionData.question = questionText;
                }

                // Include image if provided
                if (questionImage) {
                    questionData.image = questionImage;
                }

                // Include file if provided
                if (questionFile) {
                    questionData.file = questionFile;
                }

                // Include points if different from default (1)
                const pointsInput = div.querySelector('.points-input');
                if (pointsInput && pointsInput.value.trim()) {
                    const points = parseInt(pointsInput.value);
                    if (points > 1) {
                        questionData.points = points;
                    }
                }

                // Include stick_to_the_previous if checked
                const stickCheckbox = div.querySelector('.stick-to-previous-checkbox');
                if (stickCheckbox && stickCheckbox.checked) {
                    questionData.stick_to_the_previous = true;
                }

                questions.push(questionData);
            });

            const quizData = { questions };

            // Include title if provided
            const quizTitle = document.getElementById('quiz-title').value.trim();
            if (quizTitle) {
                quizData.title = quizTitle;
            }

            // Include show_right_answer setting
            quizData.show_right_answer = document.getElementById('show-right-answer').checked;

            // Include randomize_questions setting
            quizData.randomize_questions = document.getElementById('randomize-questions').checked;

            // Include show_answers_on_completion setting
            quizData.show_answers_on_completion = document.getElementById('show-answers-on-completion').checked;

            return quizData;
        }

        async function saveQuiz() {
            const filename = document.getElementById('quiz-filename').value.trim();

            if (!filename) {
                showMessage('–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å —ñ–º\'—è —Ñ–∞–π–ª—É', 'error');
                return;
            }

            const quizData = getWizardData();
            if (!quizData.questions || quizData.questions.length === 0) {
                showMessage('–ë—É–¥—å –ª–∞—Å–∫–∞, –¥–æ–¥–∞–π—Ç–µ –ø—Ä–∏–Ω–∞–π–º–Ω—ñ –æ–¥–Ω–µ –ø–∏—Ç–∞–Ω–Ω—è', 'error');
                return;
            }

            try {
                const url = isEditMode ? `/api/admin/quiz/${editingQuizName}` : '/api/admin/create-quiz';
                const method = isEditMode ? 'PUT' : 'POST';

                const response = await fetch(url, {
                    method,
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        filename,
                        mode: 'wizard',
                        quiz_data: quizData
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    // Update editingQuizName if quiz was renamed
                    if (isEditMode && data.renamed) {
                        editingQuizName = data.filename;
                        document.getElementById('modal-title').textContent = `–†–µ–¥–∞–≥—É–≤–∞—Ç–∏ Quiz: ${data.filename}`;
                    }
                    showMessage(data.message, 'success');
                    closeQuizEditor();
                    await loadQuizzes();
                } else {
                    showMessage(data.error || '–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–±–µ—Ä–µ–≥—Ç–∏ quiz', 'error');
                }
            } catch (error) {
                showMessage('–ü–æ–º–∏–ª–∫–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è quiz: ' + error.message, 'error');
            }
        }

        async function saveQuizAndContinue() {
            const filename = document.getElementById('quiz-filename').value.trim();

            if (!filename) {
                showMessage('–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å —ñ–º\'—è —Ñ–∞–π–ª—É', 'error');
                return;
            }

            const quizData = getWizardData();
            if (!quizData.questions || quizData.questions.length === 0) {
                showMessage('–ë—É–¥—å –ª–∞—Å–∫–∞, –¥–æ–¥–∞–π—Ç–µ –ø—Ä–∏–Ω–∞–π–º–Ω—ñ –æ–¥–Ω–µ –ø–∏—Ç–∞–Ω–Ω—è', 'error');
                return;
            }

            const button = document.getElementById('save-continue-btn');
            const originalText = 'üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ —ñ –ü—Ä–æ–¥–æ–≤–∂–∏—Ç–∏';
            button.disabled = true;
            button.innerHTML = '‚è≥ –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è...';
            button.style.backgroundColor = '';

            let success = false;

            try {
                const url = isEditMode ? `/api/admin/quiz/${editingQuizName}` : '/api/admin/create-quiz';
                const method = isEditMode ? 'PUT' : 'POST';

                const response = await fetch(url, {
                    method,
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        filename,
                        mode: 'wizard',
                        quiz_data: quizData
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    success = true;
                    showMessage(data.message, 'success');
                    // If this was a new quiz, switch to edit mode
                    if (!isEditMode) {
                        isEditMode = true;
                        editingQuizName = filename + '.yaml';
                        document.getElementById('modal-title').textContent = `–†–µ–¥–∞–≥—É–≤–∞—Ç–∏ Quiz: ${editingQuizName}`;
                        document.getElementById('quiz-filename').disabled = false;
                    }
                    // If quiz was renamed in edit mode, update tracking variables
                    else if (data.renamed) {
                        editingQuizName = data.filename;
                        document.getElementById('modal-title').textContent = `–†–µ–¥–∞–≥—É–≤–∞—Ç–∏ Quiz: ${data.filename}`;
                        document.getElementById('quiz-filename').value = data.filename.replace('.yaml', '');
                    }
                    // Reload quiz list in background
                    loadQuizzes();
                } else {
                    showMessage(data.error || '–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–±–µ—Ä–µ–≥—Ç–∏ quiz', 'error');
                }
            } catch (error) {
                showMessage('–ü–æ–º–∏–ª–∫–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è quiz: ' + error.message, 'error');
            }

            // Show result state
            if (success) {
                button.innerHTML = '‚úÖ –ó–±–µ—Ä–µ–∂–µ–Ω–æ';
                button.style.backgroundColor = '#28a745';
            } else {
                button.innerHTML = '‚ùå –ü–æ–º–∏–ª–∫–∞';
                button.style.backgroundColor = '#dc3545';
            }

            // Return to default state after delay
            setTimeout(() => {
                button.disabled = false;
                button.innerHTML = originalText;
                button.style.backgroundColor = '';
            }, 1500);
        }

        // Network information display using server-generated data
        function displayNetworkInfo() {
            if (typeof NETWORK_INFO === 'undefined') {
                document.getElementById('wifi-name').textContent = '–ú–µ—Ä–µ–∂–µ–≤–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞';
                document.getElementById('url-list').innerHTML = '<div class="url-item">Network detection failed</div>';
                return;
            }

            // Generate URL list from server data
            let urlHtml = '';

            if (NETWORK_INFO.urls && NETWORK_INFO.urls.length > 0) {
                NETWORK_INFO.urls.forEach(url => {
                    urlHtml += `
                        <div class="url-item">
                            <div class="label"><a href="${url.quiz_url}" target="_blank">${url.quiz_url}</a></div>
                        </div>
                    `;
                });
            } else {
                urlHtml += `
                    <div class="url-item">
                        <div class="label">‚ö†Ô∏è –ó–æ–≤–Ω—ñ—à–Ω—ñ –ú–µ—Ä–µ–∂–µ–≤—ñ –Ü–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∏ –ù–µ –ó–Ω–∞–π–¥–µ–Ω—ñ</div>
                        <div class="url">
                            –°–µ—Ä–≤–µ—Ä –¥–æ—Å—Ç—É–ø–Ω–∏–π —Ç—ñ–ª—å–∫–∏ –ª–æ–∫–∞–ª—å–Ω–æ. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –º–µ—Ä–µ–∂–µ–≤—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∞–±–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ —Ñ–∞–π—Ä–≤–æ–ª–∞.
                        </div>
                    </div>
                `;
            }

            document.getElementById('url-list').innerHTML = urlHtml;
        }

        // Image picker functionality
        let currentImageTarget = null;

        async function openImagePicker(fieldType, questionId, optionIndex = null) {
            try {
                // Store the target information
                currentImageTarget = { fieldType, questionId, optionIndex };

                // Load images from server
                const response = await fetch('/api/admin/list-images', {
                    credentials: 'same-origin'
                });

                const data = await response.json();

                if (response.ok) {
                    displayImageGrid(data.images);
                    document.getElementById('image-picker-modal').style.display = 'block';
                } else {
                    showMessage(data.error || '–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è', 'error');
                }
            } catch (error) {
                showMessage('–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –∑–æ–±—Ä–∞–∂–µ–Ω—å: ' + error.message, 'error');
            }
        }

        function displayImageGrid(images) {
            const gridContainer = document.getElementById('image-grid');

            if (!images || images.length === 0) {
                gridContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: var(--text-muted);">
                        <p>–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω—ñ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó quizzes/imgs</p>
                        <small>–î–æ–¥–∞–π—Ç–µ —Ñ–∞–π–ª–∏ –∑–æ–±—Ä–∞–∂–µ–Ω—å –¥–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó quizzes/imgs, —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ —ó—Ö —Ç—É—Ç</small>
                    </div>
                `;
                return;
            }

            let gridHtml = '';
            images.forEach(image => {
                gridHtml += `
                    <div class="image-item" onclick="selectImage('${image.path}')" title="${image.filename}">
                        <img src="${image.path}" alt="${image.filename}" loading="lazy">
                        <div class="image-filename">${image.filename}</div>
                    </div>
                `;
            });

            gridContainer.innerHTML = gridHtml;
        }

        function selectImage(imagePath) {
            if (!currentImageTarget) {
                showMessage('–ü–æ–ª–µ –Ω–µ –≤–∏–±—Ä–∞–Ω–æ', 'error');
                return;
            }

            // Find the target input field based on stored information
            let targetInput = null;

            if (currentImageTarget.fieldType === 'question-image') {
                // Find question image field by question ID
                const questionDiv = document.querySelector(`[data-question-id="${currentImageTarget.questionId}"]`);
                if (questionDiv) {
                    targetInput = questionDiv.querySelector('.question-image');
                }
            } else if (currentImageTarget.fieldType === 'option-text') {
                // Find option text field by question ID and option index
                const questionDiv = document.querySelector(`[data-question-id="${currentImageTarget.questionId}"]`);
                if (questionDiv) {
                    const optionInputs = questionDiv.querySelectorAll('.option-text');
                    if (optionInputs[currentImageTarget.optionIndex]) {
                        targetInput = optionInputs[currentImageTarget.optionIndex];
                    }
                }
            }

            if (targetInput) {
                targetInput.value = imagePath;
                // Trigger preview update
                if (currentImageTarget.fieldType === 'question-image') {
                    updateQuestionImagePreview(targetInput);
                } else if (currentImageTarget.fieldType === 'option-text') {
                    updateOptionImagePreview(targetInput);
                }
                closeImagePicker();
                showMessage(`–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è –≤–∏–±—Ä–∞–Ω–æ: ${imagePath}`, 'success');
            } else {
                showMessage('–ü–æ–ª–µ –≤–≤–æ–¥—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ', 'error');
            }
        }

        function closeImagePicker() {
            document.getElementById('image-picker-modal').style.display = 'none';
            currentImageTarget = null;
        }

        // File picker functionality
        let currentFileQuestionId = null;

        async function openFilePicker(questionId) {
            try {
                currentFileQuestionId = questionId;

                // Load files from server
                const response = await fetch('/api/admin/list-files', {
                    credentials: 'same-origin'
                });

                const data = await response.json();

                if (response.ok) {
                    displayFileList(data.files);
                    document.getElementById('file-picker-modal').style.display = 'block';
                } else {
                    showMessage(data.error || '–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Ñ–∞–π–ª–∏', 'error');
                }
            } catch (error) {
                showMessage('–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—ñ–≤: ' + error.message, 'error');
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function displayFileList(files) {
            const listContainer = document.getElementById('file-list');

            if (!files || files.length === 0) {
                listContainer.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: var(--text-muted);">
                        <p>–§–∞–π–ª–∏ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω—ñ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó quizzes/attach</p>
                        <small>–î–æ–¥–∞–π—Ç–µ —Ñ–∞–π–ª–∏ –¥–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó quizzes/attach, —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ —ó—Ö —Ç—É—Ç</small>
                    </div>
                `;
                return;
            }

            let listHtml = '';
            files.forEach(file => {
                listHtml += `
                    <div class="file-item" onclick="selectFile('${file.path}')" title="${file.filename}">
                        <div class="file-item-info">
                            <span class="file-item-icon">üìÑ</span>
                            <span class="file-item-name">${file.filename}</span>
                        </div>
                        <span class="file-item-size">${formatFileSize(file.size)}</span>
                    </div>
                `;
            });

            listContainer.innerHTML = listHtml;
        }

        function selectFile(filePath) {
            if (currentFileQuestionId === null) {
                showMessage('–ü–∏—Ç–∞–Ω–Ω—è –Ω–µ –≤–∏–±—Ä–∞–Ω–æ', 'error');
                return;
            }

            // Extract just the filename from the path (remove /attach/ prefix)
            const filename = filePath.replace(/^\/attach\//, '');

            // Find the question div by question ID
            const questionDiv = document.querySelector(`[data-question-id="${currentFileQuestionId}"]`);
            if (questionDiv) {
                const fileInput = questionDiv.querySelector('.question-file');
                if (fileInput) {
                    fileInput.value = filename;
                    closeFilePicker();
                    showMessage(`–§–∞–π–ª –≤–∏–±—Ä–∞–Ω–æ: ${filename}`, 'success');
                } else {
                    showMessage('–ü–æ–ª–µ –≤–≤–æ–¥—É —Ñ–∞–π–ª—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ', 'error');
                }
            } else {
                showMessage('–ü–∏—Ç–∞–Ω–Ω—è –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ', 'error');
            }
        }

        function closeFilePicker() {
            document.getElementById('file-picker-modal').style.display = 'none';
            currentFileQuestionId = null;
        }

        // Image preview functions
        function updateQuestionImagePreview(input) {
            const imagePath = input.value.trim();
            const previewContainer = input.closest('.form-group').querySelector('.image-preview-container');
            const previewImg = previewContainer.querySelector('.image-preview');

            if (imagePath && imagePath.startsWith('/imgs/')) {
                previewImg.src = imagePath;
                previewImg.onerror = function() {
                    previewContainer.classList.remove('has-image');
                };
                previewImg.onload = function() {
                    previewContainer.classList.add('has-image');
                };
            } else {
                previewContainer.classList.remove('has-image');
                previewImg.src = '';
            }
        }

        function updateOptionImagePreview(input) {
            const imagePath = input.value.trim();
            const optionItem = input.closest('.option-item');
            let previewImg = optionItem.querySelector('.option-image-preview');

            if (imagePath && imagePath.startsWith('/imgs/')) {
                if (!previewImg) {
                    // Create preview image if it doesn't exist
                    previewImg = document.createElement('img');
                    previewImg.className = 'option-image-preview';
                    previewImg.alt = 'Option preview';
                    previewImg.title = 'Click to enlarge';
                    previewImg.onclick = function() { openFullscreenPreview(this.src); };
                    // Insert after the input field
                    input.parentNode.insertBefore(previewImg, input.nextSibling);
                }
                previewImg.src = imagePath;
                previewImg.style.display = 'inline-block';
                previewImg.onerror = function() {
                    this.style.display = 'none';
                };
            } else if (previewImg) {
                previewImg.style.display = 'none';
            }
        }

        function openFullscreenPreview(src) {
            if (!src) return;
            const modal = document.getElementById('image-fullscreen-modal');
            const fullscreenImg = document.getElementById('fullscreen-image');
            fullscreenImg.src = src;
            modal.style.display = 'block';
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
        }

        function closeFullscreenPreview() {
            const modal = document.getElementById('image-fullscreen-modal');
            modal.style.display = 'none';
            document.body.style.overflow = '';
        }

        // Close fullscreen preview on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeFullscreenPreview();
            }
        });

        // Downloadable Quizzes Functions
        function displayDownloadableQuizzes() {
            if (typeof DOWNLOADABLE_QUIZZES !== 'undefined' && DOWNLOADABLE_QUIZZES.length > 0) {
                const section = document.getElementById('downloadable-quizzes-section');
                const quizList = document.getElementById('downloadable-quiz-list');

                section.classList.remove('hidden');

                let html = '';
                DOWNLOADABLE_QUIZZES.forEach((quiz, index) => {
                    html += `
                        <div class="downloadable-quiz-item">
                            <div class="downloadable-quiz-info">
                                <div class="downloadable-quiz-name">${quiz.name}</div>
                                <div class="downloadable-quiz-url">${quiz.download_path}</div>
                                <small style="color: var(--text-muted);">–ü–∞–ø–∫–∞: ${quiz.folder}</small>
                            </div>
                            <button class="download-btn" onclick="downloadQuiz(${index})" id="download-btn-${index}">
                                üì• –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏
                            </button>
                        </div>
                    `;
                });
                quizList.innerHTML = html;
            }
        }

        function downloadQuiz(quizIndex) {
            // Validate inputs
            if (typeof DOWNLOADABLE_QUIZZES === 'undefined' || !DOWNLOADABLE_QUIZZES[quizIndex]) {
                showMessage('‚ùå Quiz –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ', 'error');
                return;
            }

            const quiz = DOWNLOADABLE_QUIZZES[quizIndex];
            const button = document.getElementById(`download-btn-${quizIndex}`);

            if (!button) {
                showMessage('‚ùå –ö–Ω–æ–ø–∫–∞ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–∞', 'error');
                return;
            }

            // Show confirmation
            const confirmed = confirm(`–ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ quiz "${quiz.name}"?\n\n–¶–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç—å —Ç–∞ —Ä–æ–∑–ø–∞–∫—É—î —Ñ–∞–π–ª–∏ –∑:\n${quiz.download_path}\n\n–§–∞–π–ª–∏ –±—É–¥—É—Ç—å –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞–Ω—ñ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó quizzes.`);
            if (!confirmed) {
                return;
            }

            // Disable button and show loading state
            button.disabled = true;
            button.innerHTML = '‚è≥ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...';

            // Use async IIFE to handle async operations
            (async () => {
                try {
                    const response = await fetch('/api/admin/download-quiz', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Admin-Key': currentMasterKey
                        },
                        body: JSON.stringify({
                            name: quiz.name,
                            download_path: quiz.download_path,
                            folder: quiz.folder
                        }),
                        credentials: 'same-origin'
                    });

                    const data = await response.json();

                    if (response.ok && data.success) {
                        showMessage(`‚úÖ ${data.message}`, 'success');
                        // Refresh quiz list to show newly downloaded quizzes
                        await loadQuizzes();
                    } else {
                        showMessage(`‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è: ${data.error}`, 'error');
                    }
                } catch (error) {
                    console.error('Download quiz error:', error);
                    showMessage(`‚ùå –ü–æ–º–∏–ª–∫–∞ –º–µ—Ä–µ–∂—ñ: ${error.message}`, 'error');
                } finally {
                    // Re-enable button
                    button.disabled = false;
                    button.innerHTML = 'üì• –ó–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏';
                }
            })();
        }

        // Admin WebSocket for Pending Approvals
        let adminWebSocket = null;
        let pendingUsers = {};

        function connectToAdminWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/admin`;

            adminWebSocket = new WebSocket(wsUrl);

            adminWebSocket.onopen = () => {
                console.log('Admin WebSocket connected');
            };

            adminWebSocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleAdminWebSocketMessage(data);
                } catch (error) {
                    console.error('Error parsing admin WebSocket message:', error);
                }
            };

            adminWebSocket.onclose = () => {
                console.log('Admin WebSocket disconnected');
                // Reconnect after 5 seconds
                setTimeout(connectToAdminWebSocket, 5000);
            };

            adminWebSocket.onerror = (error) => {
                console.error('Admin WebSocket error:', error);
            };
        }

        function handleAdminWebSocketMessage(data) {
            if (data.type === 'initial_state') {
                // Initial state - show/hide section based on requires_approval
                if (data.requires_approval) {
                    document.getElementById('pending-approvals-section').classList.remove('hidden');
                    pendingUsers = data.pending_users || {};
                    displayPendingUsers();
                }
                // Handle tunnel initial state
                if (data.tunnel) {
                    updateTunnelUI(data.tunnel);
                }
            } else if (data.type === 'tunnel_status') {
                // Tunnel status update
                if (data.tunnel) {
                    updateTunnelUI(data.tunnel);
                }
            } else if (data.type === 'new_registration') {
                // New user registered - data now contains user_id, username, registration_fields
                pendingUsers[data.user_id] = {
                    username: data.username,
                    registration_fields: data.registration_fields || {}
                };
                document.getElementById('pending-approvals-section').classList.remove('hidden');
                displayPendingUsers();
                showMessage(`–ù–æ–≤–∏–π –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á: ${data.username}`, 'success');
            } else if (data.type === 'registration_updated') {
                // User updated registration data - data now contains user_id, username, registration_fields
                pendingUsers[data.user_id] = {
                    username: data.username,
                    registration_fields: data.registration_fields || {}
                };
                displayPendingUsers();
                showMessage(`–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á ${data.username} –æ–Ω–æ–≤–∏–≤ –¥–∞–Ω—ñ`, 'success');
            } else if (data.type === 'user_approved') {
                // User was approved
                const user_id = data.user_id;
                if (pendingUsers[user_id]) {
                    delete pendingUsers[user_id];
                    displayPendingUsers();
                }
            } else if (data.type === 'answers_forced') {
                // Admin forced answers to be shown
                updateAnswersForcedStatus(data.forced);
                if (data.message) {
                    showMessage(data.message, 'success');
                }
            }
        }

        function fieldNameToLabel(fieldName) {
            // Convert field name to label: "–º–æ–ª—è_–ø–∞—Ä–æ–ª–∞" -> "–ú–æ–ª—è –ü–∞—Ä–æ–ª–∞"
            return fieldName
                .split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        function displayPendingUsers() {
            const listContainer = document.getElementById('pending-users-list');
            const userIds = Object.keys(pendingUsers);

            if (userIds.length === 0) {
                listContainer.innerHTML = '<p style="text-align: center; color: var(--text-muted);">–ù–µ–º–∞—î –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤, —â–æ –æ—á—ñ–∫—É—é—Ç—å –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è</p>';
                return;
            }

            let html = '';
            for (const user_id of userIds) {
                const user = pendingUsers[user_id];
                html += `
                    <div class="pending-user-item" id="pending-user-${user_id}">
                        <div class="pending-user-info">
                            <div class="pending-user-name">üë§ ${user.username}</div>
                `;

                // Add registration fields (only custom fields from server)
                for (const [key, value] of Object.entries(user.registration_fields || {})) {
                    const label = fieldNameToLabel(key);
                    html += `<div class="pending-user-data">${label}: ${value}</div>`;
                }

                html += `
                        </div>
                        <button class="approve-btn" onclick="approveUser('${user_id}')">‚úì –ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏</button>
                    </div>
                `;
            }

            listContainer.innerHTML = html;
        }

        async function approveUser(userId) {
            if (!currentMasterKey) {
                showMessage('–ü–æ—Ç—Ä—ñ–±–Ω–∞ –∞–≤—Ç–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ü—ñ—è', 'error');
                return;
            }

            try {
                const response = await fetch('/api/admin/approve-user', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ user_id: userId }),
                    credentials: 'same-origin'
                });

                const data = await response.json();

                if (response.ok) {
                    showMessage(`–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–æ!`, 'success');
                    // Remove from pending list
                    if (pendingUsers[userId]) {
                        delete pendingUsers[userId];
                        displayPendingUsers();
                    }
                } else {
                    showMessage(data.error || '–ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è', 'error');
                }
            } catch (error) {
                showMessage('–ü–æ–º–∏–ª–∫–∞ –∑\'—î–¥–Ω–∞–Ω–Ω—è: ' + error.message, 'error');
            }
        }

        async function forceShowAnswers() {
            if (!currentMasterKey) {
                showMessage('–ü–æ—Ç—Ä—ñ–±–Ω–∞ –∞–≤—Ç–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ü—ñ—è', 'error');
                return;
            }

            if (!confirm('–í–∏ –≤–ø–µ–≤–Ω–µ–Ω—ñ, —â–æ —Ö–æ—á–µ—Ç–µ –≤—ñ–¥–∫—Ä–∏—Ç–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ –¥–ª—è –≤—Å—ñ—Ö —É—á–Ω—ñ–≤?\n\n–¶—é –¥—ñ—é –Ω–µ–º–æ–∂–ª–∏–≤–æ —Å–∫–∞—Å—É–≤–∞—Ç–∏ (–¥–æ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫—É quiz).')) {
                return;
            }

            try {
                const response = await fetch('/api/admin/force-show-answers', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'same-origin'
                });

                const data = await response.json();

                if (response.ok) {
                    showMessage(`–í—ñ–¥–ø–æ–≤—ñ–¥—ñ –≤—ñ–¥–∫—Ä–∏—Ç–æ! (${data.completed_count}/${data.total_count} —É—á–Ω—ñ–≤ –∑–∞–≤–µ—Ä—à–∏–ª–∏ —Ç–µ—Å—Ç)`, 'success');
                    updateAnswersForcedStatus(true);
                } else {
                    showMessage(data.error || '–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–∫—Ä–∏—Ç—Ç—è –≤—ñ–¥–ø–æ–≤—ñ–¥–µ–π', 'error');
                }
            } catch (error) {
                showMessage('–ü–æ–º–∏–ª–∫–∞ –∑\'—î–¥–Ω–∞–Ω–Ω—è: ' + error.message, 'error');
            }
        }

        function updateAnswersForcedStatus(forced) {
            const statusDiv = document.getElementById('answers-status');
            const button = document.getElementById('show-answers-btn');

            if (forced) {
                statusDiv.style.display = 'block';
                statusDiv.style.background = '#4caf50';
                statusDiv.style.color = 'white';
                statusDiv.style.border = '1px solid #45a049';
                statusDiv.textContent = '‚úì –í—ñ–¥–ø–æ–≤—ñ–¥—ñ –≤—ñ–¥–∫—Ä–∏—Ç–æ –¥–ª—è –≤—Å—ñ—Ö —É—á–Ω—ñ–≤';

                button.disabled = true;
                button.style.background = '#ccc';
                button.style.cursor = 'not-allowed';
                button.textContent = '‚úì –í—ñ–¥–ø–æ–≤—ñ–¥—ñ –í–∂–µ –í—ñ–¥–∫—Ä–∏—Ç—ñ';
            } else {
                statusDiv.style.display = 'none';
                button.disabled = false;
                button.style.background = '#ff9800';
                button.style.cursor = 'pointer';
                button.textContent = 'üîì –í—ñ–¥–∫—Ä–∏—Ç–∏ –í—ñ–¥–ø–æ–≤—ñ–¥—ñ –¥–ª—è –í—Å—ñ—Ö';
            }
        }

        // Auto-authenticate function that shows admin panel
        function showAdminPanel(message) {
            document.getElementById('auth-section').style.display = 'none';
            document.getElementById('admin-panel').classList.remove('hidden');
            showMessage(message, 'success');
            loadQuizzes();
            displayNetworkInfo();
            displayDownloadableQuizzes();
            connectToAdminWebSocket();
            displayVersion();
            checkForUpdates();
        }

        // Check for existing session cookie on page load
        async function checkExistingSession() {
            try {
                const response = await fetch('/api/admin/check-session', {
                    method: 'GET',
                    credentials: 'same-origin'
                });

                if (response.ok) {
                    // Valid session found - auto-authenticate
                    currentMasterKey = 'session'; // Placeholder, actual auth is via cookie
                    showAdminPanel('–°–µ—Å—ñ—é –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ');
                    return true;
                }
            } catch (error) {
                // Session check failed, fall through to other auth methods
            }
            return false;
        }

        // Initialize authentication
        (async function initAuth() {
            // First, try to restore existing session
            const hasSession = await checkExistingSession();
            if (hasSession) return;

            // Fall back to trusted IP auto-authentication
            if (typeof IS_TRUSTED_IP !== 'undefined' && IS_TRUSTED_IP) {
                currentMasterKey = 'trusted-ip';
                showAdminPanel('–ê–≤—Ç–æ-–∞–≤—Ç–µ–Ω—Ç–∏—Ñ—ñ–∫–∞—Ü—ñ—è –∑ –¥–æ–≤—ñ—Ä–µ–Ω–æ–≥–æ IP');
            }
        })();

        // Version display functionality
        function displayVersion() {
            const versionSpan = document.getElementById('version-number');
            const docsLinkSpan = document.getElementById('footer-docs-link');

            if (typeof WEBQUIZ_VERSION !== 'undefined') {
                versionSpan.textContent = WEBQUIZ_VERSION;

                // Add documentation link
                const docUrl = `https://github.com/oduvan/webquiz/releases/download/v${WEBQUIZ_VERSION}/webquiz-documentation-uk.pdf`;
                docsLinkSpan.innerHTML = `| <a href="${docUrl}" target="_blank" style="color: var(--button-bg); text-decoration: none;">üìÑ –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è</a>`;
            } else {
                versionSpan.textContent = 'unknown';
                docsLinkSpan.innerHTML = '';
            }
        }

        // Version check functionality
        async function checkForUpdates() {
            // Only check if version is defined
            if (typeof WEBQUIZ_VERSION === 'undefined') {
                return;
            }

            try {
                const response = await fetch('https://pypi.org/pypi/webquiz/json', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });

                if (!response.ok) {
                    return; // Silently fail
                }

                const data = await response.json();
                const latestVersion = data.info.version;
                const currentVersion = WEBQUIZ_VERSION;

                // Parse versions into arrays of integers
                const parseVersion = (version) => {
                    return version.split('.').map(part => parseInt(part, 10) || 0);
                };

                const currentParts = parseVersion(currentVersion);
                const latestParts = parseVersion(latestVersion);

                // Compare versions
                const maxLength = Math.max(currentParts.length, latestParts.length);
                let isNewer = false;

                for (let i = 0; i < maxLength; i++) {
                    const current = currentParts[i] || 0;
                    const latest = latestParts[i] || 0;

                    if (latest > current) {
                        isNewer = true;
                        break;
                    } else if (latest < current) {
                        break;
                    }
                }

                // Show update notification if newer version available
                if (isNewer) {
                    const updateElement = document.getElementById('footer-update');
                    updateElement.classList.remove('hidden');
                    updateElement.innerHTML = `‚¨ÜÔ∏è Update available: <a href="https://github.com/oduvan/webquiz/releases/tag/v${latestVersion}" target="_blank">v${latestVersion}</a>`;
                }
            } catch (error) {
                // Silently fail - don't show any error messages
                return;
            }
        }

        // Package version check (file vs memory)
        async function checkPackageVersionMismatch() {
            try {
                const response = await fetch('/api/admin/version-check');
                if (!response.ok) {
                    return;
                }

                const data = await response.json();
                if (data.restart_required) {
                    // Hide update notification when restart is required
                    const updateElement = document.getElementById('footer-update');
                    updateElement.classList.add('hidden');

                    const restartElement = document.getElementById('footer-restart');
                    const newVersionSpan = document.getElementById('new-version-number');
                    newVersionSpan.textContent = data.file_version;
                    restartElement.classList.remove('hidden');
                }
            } catch (error) {
                // Silently fail
                return;
            }
        }

        // Periodically check for package version mismatch (every 5 minutes)
        setInterval(checkPackageVersionMismatch, 300000);

        // Initial check after page load
        setTimeout(checkPackageVersionMismatch, 2000);

        // Tunnel Management Functions
        function updateTunnelUI(tunnelData) {
            const tunnelSection = document.getElementById('tunnel-section');

            // Only hide tunnel section if explicitly not configured (initial load)
            if (!tunnelData) {
                tunnelSection.style.display = 'none';
                return;
            }

            // If configured is explicitly false, hide section
            if (tunnelData.configured === false) {
                tunnelSection.style.display = 'none';
                return;
            }

            // Show tunnel section (for both initial load and status updates)
            tunnelSection.style.display = 'block';

            // Update server name (only if provided, to preserve during status updates)
            if (tunnelData.server) {
                document.getElementById('tunnel-server').textContent = tunnelData.server;
            }

            // Update socket name if provided
            const socketNameSection = document.getElementById('tunnel-socket-name-section');
            if (tunnelData.socket_name) {
                document.getElementById('tunnel-socket-name').textContent = tunnelData.socket_name;
                socketNameSection.style.display = 'block';
            } else {
                socketNameSection.style.display = 'none';
            }

            // Display public key if tunnel is configured
            const publicKeySection = document.getElementById('tunnel-public-key-section');
            if (tunnelData.configured && tunnelData.keys_status === 'ok' && typeof TUNNEL_PUBLIC_KEY !== 'undefined') {
                document.getElementById('tunnel-public-key').value = TUNNEL_PUBLIC_KEY;
                publicKeySection.style.display = 'block';
            } else {
                publicKeySection.style.display = 'none';
            }

            // Update connect button and error display
            const connectBtn = document.getElementById('tunnel-connect-btn');
            const errorSection = document.getElementById('tunnel-error');
            const urlList = document.getElementById('url-list');

            if (tunnelData.connected) {
                connectBtn.textContent = 'Disconnect';
                connectBtn.disabled = false;
                errorSection.style.display = 'none';

                // Add tunnel URL to main URL list if not already present
                if (tunnelData.url && !document.getElementById('tunnel-url-item')) {
                    const tunnelUrlItem = document.createElement('div');
                    tunnelUrlItem.id = 'tunnel-url-item';
                    tunnelUrlItem.className = 'url-item';
                    tunnelUrlItem.style.backgroundColor = '#e8f5e9';
                    tunnelUrlItem.style.borderColor = '#81c784';
                    tunnelUrlItem.innerHTML = `
                        <div class="label">
                            <strong>üåê –ó–æ–≤–Ω—ñ—à–Ω—ñ–π URL:</strong>
                            <a href="${tunnelData.url}" target="_blank">${tunnelData.url}</a>
                        </div>
                    `;
                    urlList.insertBefore(tunnelUrlItem, urlList.firstChild);
                }
            } else {
                connectBtn.textContent = 'Connect';
                connectBtn.disabled = tunnelData.keys_status !== 'ok';

                // Remove tunnel URL from main URL list
                const existingTunnelItem = document.getElementById('tunnel-url-item');
                if (existingTunnelItem) {
                    existingTunnelItem.remove();
                }

                if (tunnelData.error) {
                    errorSection.textContent = 'Error: ' + tunnelData.error;
                    errorSection.style.display = 'block';
                } else {
                    errorSection.style.display = 'none';
                }
            }
        }

        function copyPublicKey() {
            const textarea = document.getElementById('tunnel-public-key');
            const copyBtn = document.getElementById('copy-public-key-btn');

            try {
                // Try modern clipboard API first (works on HTTPS/localhost)
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(textarea.value).then(() => {
                        // Visual feedback
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = '‚úÖ Copied!';
                        copyBtn.style.background = '#4CAF50';
                        copyBtn.style.color = 'white';

                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                            copyBtn.style.background = '';
                            copyBtn.style.color = '';
                        }, 2000);
                    }).catch(error => {
                        showMessage('Failed to copy: ' + error.message, 'error');
                    });
                } else {
                    // Fallback for non-secure contexts (HTTP over IP)
                    textarea.select();
                    textarea.setSelectionRange(0, 99999); // For mobile devices

                    const successful = document.execCommand('copy');

                    if (successful) {
                        // Visual feedback
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = '‚úÖ Copied!';
                        copyBtn.style.background = '#4CAF50';
                        copyBtn.style.color = 'white';

                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                            copyBtn.style.background = '';
                            copyBtn.style.color = '';
                        }, 2000);

                        // Deselect
                        window.getSelection().removeAllRanges();
                    } else {
                        showMessage('Failed to copy to clipboard. Please copy manually.', 'error');
                    }
                }
            } catch (error) {
                showMessage('Failed to copy: ' + error.message, 'error');
            }
        }

        async function toggleTunnel() {
            const connectBtn = document.getElementById('tunnel-connect-btn');
            const isConnected = connectBtn.textContent === 'Disconnect';

            try {
                connectBtn.disabled = true;

                const endpoint = isConnected ? '/api/admin/tunnel/disconnect' : '/api/admin/tunnel/connect';

                const response = await fetch(endpoint, {
                    method: 'POST',
                    credentials: 'same-origin'
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Operation failed');
                }

                if (isConnected) {
                    showMessage('Tunnel disconnected', 'success');
                } else {
                    showMessage('Tunnel connected! Public URL: ' + data.url, 'success');
                }

            } catch (error) {
                showMessage('Tunnel operation failed: ' + error.message, 'error');
                connectBtn.disabled = false;
            }
        }

    </script>

</body>
</html>
