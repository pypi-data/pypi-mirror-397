<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>{{QUIZ_TITLE}}</title>
    <style>
        :root {
            --bg-color: #f5f5f5;
            --container-bg: white;
            --text-color: #333;
            --border-color: #ddd;
            --option-bg: white;
            --option-border: #ccc;
            --option-hover: #e8f4f8;
            --option-selected: #e3f2fd;
            --option-selected-border: #2196f3;
            --question-bg: #fafafa;
            --current-question-bg: #f8f9fa;
            --stats-bg: #e7f3ff;
            --progress-bg: #f0f0f0;
            --shadow: rgba(0,0,0,0.1);
        }

        [data-theme="dark"] {
            --bg-color: #1a1a1a;
            --container-bg: #2d2d2d;
            --text-color: #e0e0e0;
            --border-color: #555;
            --option-bg: #3a3a3a;
            --option-border: #666;
            --option-hover: #404040;
            --option-selected: #1a3a52;
            --option-selected-border: #2196f3;
            --question-bg: #333;
            --current-question-bg: #2a2a2a;
            --stats-bg: #1e3a5f;
            --progress-bg: #444;
            --shadow: rgba(0,0,0,0.3);
        }

        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .container {
            background: var(--container-bg);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px var(--shadow);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            position: relative;
        }
        .top-right-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .theme-toggle {
            background: var(--option-bg);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            padding: 8px;
            cursor: pointer;
            font-size: 16px;
            color: var(--text-color);
            transition: all 0.3s ease;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .theme-toggle:hover {
            background: var(--option-hover);
        }
        .question {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background: var(--question-bg);
            transition: all 0.3s ease;
        }
        .options {
            margin: 10px 0;
        }
        .option {
            margin: 5px 0;
            padding: 10px;
            background: var(--option-bg);
            border: 1px solid var(--option-border);
            border-radius: 3px;
            cursor: pointer;
            color: var(--text-color);
            transition: all 0.3s ease;
        }
        .option:hover {
            background: var(--option-hover);
        }
        .option.selected {
            background: var(--option-selected);
            border-color: var(--option-selected-border);
        }

        .option.feedback-correct {
            background: #ffffff !important;
            border-color: #2d731c !important;
            border-width: 3px !important;
            color: #155724 !important;
            position: relative;
        }

        .option.feedback-correct::after {
            content: '‚úì –ü—Ä–∞–≤–∏–ª—å–Ω–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å';
            position: absolute;
            top: -25px;
            right: 0;
            background: #2d731c;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            white-space: nowrap;
            z-index: 10;
        }

        .option.feedback-incorrect {
            background: #f8d7da !important;
            border-color: #dc3545 !important;
            border-width: 3px !important;
            color: #721c24 !important;
            position: relative;
        }

        .option.feedback-incorrect::after {
            content: '‚úó –í–∞—à–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å';
            position: absolute;
            top: -25px;
            right: 0;
            background: #dc3545;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            white-space: nowrap;
            z-index: 10;
        }

        .option.feedback-missed {
            background: #e3f2fd !important;
            border-color: #1976d2 !important;
            border-width: 3px !important;
            border-style: dashed !important;
            color: #0d47a1 !important;
            position: relative;
        }

        .option.feedback-missed::after {
            content: '‚úì –¢–µ–∂ –ø—Ä–∞–≤–∏–ª—å–Ω–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å';
            position: absolute;
            top: -25px;
            right: 0;
            background: #1976d2;
            color: white;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            white-space: nowrap;
            z-index: 10;
        }

        .option.disabled {
            cursor: not-allowed !important;
            opacity: 0.6 !important;
            pointer-events: none !important;
        }

        [data-theme="dark"] .option.feedback-correct {
            background: #2d5a2d !important;
            border-color: #4caf50 !important;
            color: #a5d6a7 !important;
        }

        [data-theme="dark"] .option.feedback-correct.disabled {
            background: #2d5a2d !important;
            border-color: #4caf50 !important;
            color: #a5d6a7 !important;
            opacity: 1 !important;
        }

        [data-theme="dark"] .option.feedback-incorrect {
            background: #c20909 !important;
            border-color: #f44336 !important;
            color: #ef9a9a !important;
        }

        [data-theme="dark"] .option.feedback-missed {
            background: #1a237e !important;
            border-color: #3f51b5 !important;
            color: #9fa8da !important;
        }
        .question-image {
            max-width: 100%;
            height: auto;
            margin: 15px 0;
            border-radius: 5px;
            box-shadow: 0 2px 8px var(--shadow);
            display: block;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .question-image:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 12px var(--shadow);
        }
        .option-image {
            max-width: 300px;
            height: auto;
            margin: 5px 0;
            border-radius: 3px;
            box-shadow: 0 1px 4px var(--shadow);
            display: block;
        }
        .option-content {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        .question-file {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: var(--option-bg);
            border: 2px solid var(--option-border);
            border-radius: 8px;
            color: var(--text-color);
            text-decoration: none;
            font-size: 14px;
            margin: 15px 0;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .question-file:hover {
            background: var(--option-hover);
            border-color: var(--option-selected-border);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px var(--shadow);
        }
        .question-file-icon {
            font-size: 18px;
        }
        .question-file-name {
            font-weight: 500;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px 5px;
        }
        button:hover {
            background: #0056b3;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }
        .button-container {
            position: relative;
            margin: 20px 0;
            height: 50px;
        }
        #submit-answer-btn {
            position: absolute;
            left: 0;
        }
        #continue-btn {
            position: absolute;
            right: 0;
        }
        .hidden {
            display: none;
        }
        .stats {
            background: var(--stats-bg);
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            transition: background-color 0.3s ease;
        }
        .correct {
            color: #28a745;
        }
        .incorrect {
            color: #dc3545;
        }
        .progress {
            width: 100%;
            background: var(--progress-bg);
            border-radius: 10px;
            margin: 20px 0;
            position: relative;
            height: 30px;
            transition: background-color 0.3s ease;
        }
        #progress-fill {
            height: 100%;
            background: #007bff;
            border-radius: 10px;
            width: 0%;
            transition: width 0.3s ease;
        }
        #progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-color);
            font-weight: bold;
        }
        .current-question {
            background: var(--current-question-bg);
            padding: 30px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid #007bff;
            transition: background-color 0.3s ease;
        }

        /* Question transition animations */
        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-10px);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .question-fade-out {
            animation: fadeOut 0.45s ease-out forwards;
        }

        .question-fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }
        #loading {
            text-align: center;
            padding: 40px;
        }
        #loading p {
            color: var(--text-color);
            font-style: italic;
        }
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 14px;
        }
        .results-table th {
            background-color: var(--question-bg);
            border: 1px solid var(--border-color);
            padding: 12px;
            text-align: left;
            font-weight: bold;
            color: var(--text-color);
        }
        .results-table td {
            border: 1px solid var(--border-color);
            padding: 12px;
            vertical-align: top;
            color: var(--text-color);
        }
        .results-table tr:nth-child(even) {
            background-color: var(--question-bg);
        }
        .results-table tr:hover {
            background-color: var(--option-hover);
        }

        /* Registration form styles */
        .registration-table {
            margin: 10px auto;
            border-collapse: collapse;
            max-width: 500px;
            width: 100%;
        }
        .registration-label {
            padding: 5px 10px;
            text-align: right;
            font-weight: bold;
        }
        .registration-input {
            padding: 5px 10px;
        }
        .registration-input input {
            padding: 8px;
            width: 100%;
            max-width: 250px;
            box-sizing: border-box;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background: var(--option-bg);
            color: var(--text-color);
        }

        /* Question points badge */
        .question-points-badge {
            position: absolute;
            top: 0;
            right: 0;
            background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
            color: #000;
            font-size: 13px;
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 0 8px 0 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        /* Mobile responsive styles */
        @media screen and (max-width: 768px) {
            /* Full width mobile layout - no side margins */
            body {
                padding: 0;
                margin: 0;
            }

            .container {
                padding: 10px 0;
                border-radius: 0;
                box-shadow: none;
            }

            .current-question {
                padding: 10px 0;
                margin: 8px 0;
                border-radius: 0;
                border: none;
            }

            .question {
                padding: 10px 0;
                margin: 8px 0;
                border-radius: 0;
                border-left: none;
                border-right: none;
            }

            .option {
                padding: 12px 10px;
                margin: 4px 0;
                border-radius: 0;
                border-left: none;
                border-right: none;
            }

            /* Image options: remove padding so images go edge-to-edge */
            .option:has(.option-image) {
                padding: 8px 0;
            }

            .option-image {
                max-width: 100%;
                width: 100%;
                margin: 0;
            }

            .option-content {
                width: 100%;
            }

            .question-image {
                border-radius: 0;
            }

            .progress {
                border-radius: 0;
                margin: 10px 0;
            }

            h1 {
                padding: 0 10px;
                margin-top: 60px;
            }

            .question-text, h3 {
                padding: 0 10px;
            }

            .multiple-choice-hint {
                padding: 0 10px;
            }

            .results-table {
                font-size: 12px;
                overflow-x: auto;
                display: block;
                white-space: nowrap;
            }

            /* Mobile responsive input */
            #username {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
            }

            /* Mobile responsive registration fields */
            .registration-field {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
            }

            /* Mobile responsive waiting approval fields */
            .waiting-field, #waiting-username {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
            }

            /* Make registration tables responsive on mobile */
            #registration, #waiting-approval {
                padding: 0 10px;
            }

            .registration-table {
                width: 100%;
                max-width: 100%;
            }

            .registration-table tr {
                display: block;
                margin-bottom: 10px;
            }

            .registration-table .registration-label,
            .registration-table .registration-input {
                display: block;
                width: 100%;
                text-align: left;
                padding: 5px 0;
            }

            .registration-table .registration-input input {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
            }


            h2 {
                padding: 0 10px;
            }
            .results-table thead,
            .results-table tbody,
            .results-table th,
            .results-table td,
            .results-table tr {
                display: block;
            }
            .results-table thead tr {
                position: absolute;
                top: -9999px;
                left: -9999px;
            }
            .results-table tr {
                border: 1px solid var(--border-color);
                margin-bottom: 10px;
                padding: 10px;
                border-radius: 5px;
                white-space: normal;
            }
            .results-table td {
                border: none;
                padding: 5px 0;
                position: relative;
                padding-left: 50%;
            }
            .results-table td:before {
                content: attr(data-label) ": ";
                position: absolute;
                left: 6px;
                width: 45%;
                padding-right: 10px;
                white-space: nowrap;
                font-weight: bold;
            }
        }
        .answer-correct {
            color: #28a745;
            font-weight: bold;
        }
        .answer-incorrect {
            color: #dc3545;
            font-weight: bold;
        }
        .correct-answer-hint {
            color: var(--text-color);
            font-size: 12px;
            margin-top: 4px;
        }
        .user-info {
            background: var(--option-bg);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 14px;
            color: var(--text-color);
            transition: all 0.3s ease;
            display: none;
        }
        .user-info.visible {
            display: block;
        }
        .user-info:hover {
            background: var(--option-hover);
        }
        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 14px;
        }
        [data-theme="dark"] .error-message {
            background-color: #2d1b1b;
            color: #f8d7da;
            border-color: #721c24;
        }

        /* Text input question styles */
        .text-input-container {
            margin: 15px 0;
        }
        .text-answer-input {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 2px solid var(--option-border);
            border-radius: 8px;
            background: var(--option-bg);
            color: var(--text-color);
            font-family: monospace;
            font-size: 14px;
            resize: vertical;
            box-sizing: border-box;
            transition: border-color 0.3s ease;
        }
        .text-answer-input:focus {
            border-color: var(--option-selected-border);
            outline: none;
        }
        .text-answer-input.feedback-correct {
            border-color: #2d731c;
            background: #f0fff0;
        }
        .text-answer-input.feedback-incorrect {
            border-color: #dc3545;
            background: #fff0f0;
        }
        [data-theme="dark"] .text-answer-input.feedback-correct {
            background: #1a3a1a;
        }
        [data-theme="dark"] .text-answer-input.feedback-incorrect {
            background: #3a1a1a;
        }
        .checker-error {
            background: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 13px;
        }
        [data-theme="dark"] .checker-error {
            background: #3d3a1a;
            border-color: #ffc107;
            color: #ffc107;
        }
        .correct-value-display {
            background: #d4edda;
            border: 1px solid #28a745;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 13px;
        }
        [data-theme="dark"] .correct-value-display {
            background: #1a3a1a;
            border-color: #28a745;
            color: #a5d6a7;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="top-right-controls">
            <div class="user-info" id="user-info">
                üë§ <span id="username-display"></span>
            </div>
            <button class="theme-toggle" onclick="toggleTheme()" title="–ü–µ—Ä–µ–º–∫–Ω—É—Ç–∏ —Ç–µ–º—É">üåô</button>
        </div>
        <h1>{{QUIZ_TITLE}}</h1>

        <!-- Loading State -->
        <div id="loading" class="section">
            <h2>–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</h2>
            <p>–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤–∞—à–∏—Ö –¥–∞–Ω–∏—Ö...</p>
        </div>

        <!-- Registration Form -->
        <div id="registration" class="section hidden">
            <h2>–ó–∞—Ä–µ—î—Å—Ç—Ä—É–π—Ç–µ—Å—è –¥–ª—è –ø–æ—á–∞—Ç–∫—É —Ç–µ—Å—Ç—É</h2>
            <div id="registration-error" class="error-message hidden"></div>
            {{REGISTRATION_FIELDS}}
            <div style="text-align: center; margin-top: 15px;">
                <button class="register-btn" onclick="registerUser()">–ó–∞—Ä–µ—î—Å—Ç—Ä—É–≤–∞—Ç–∏—Å—è</button>
            </div>
        </div>

        <!-- Waiting for Approval Section -->
        <div id="waiting-approval" class="section hidden">
            <h2>–û—á—ñ–∫—É–≤–∞–Ω–Ω—è –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è</h2>
            <p style="text-align: center; color: var(--text-color); margin: 20px 0;">
                –í–∞—à–∞ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—è –æ—á—ñ–∫—É—î –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –∞–¥–º—ñ–Ω—ñ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.<br>
                –í–∏ –º–æ–∂–µ—Ç–µ –∑–º—ñ–Ω–∏—Ç–∏ —Å–≤–æ—ó –¥–∞–Ω—ñ –Ω–∏–∂—á–µ —Ç–∞ –Ω–∞—Ç–∏—Å–Ω—É—Ç–∏ –∫–Ω–æ–ø–∫—É "–ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏", —â–æ–± –¥—ñ–∑–Ω–∞—Ç–∏—Å—è —á–∏ –≤–∞—Å –ø—ñ–¥—Ç–≤–µ—Ä–¥–∏–ª–∏.
            </p>
            <div id="waiting-error" class="error-message hidden"></div>
            <div id="waiting-registration-fields"></div>
            <div style="text-align: center; margin-top: 20px;">
                <button onclick="updateRegistrationData()" style="margin-right: 10px;">üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ –∑–º—ñ–Ω–∏</button>
                <button onclick="checkApprovalStatus()">üîÑ –ü–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏</button>
            </div>
        </div>

        <!-- Test Section -->
        <div id="test-section" class="section hidden">
            <div id="progress-bar" class="progress">
                <div id="progress-fill"></div>
                <span id="progress-text">–ü–∏—Ç–∞–Ω–Ω—è 1 –∑ 5</span>
            </div>
            <div id="test-error" class="error-message hidden"></div>
            <div id="current-question-container"></div>
            <div class="button-container">
                <button id="submit-answer-btn" onclick="submitCurrentAnswer()" disabled>–í—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥—å</button>
                <button id="continue-btn" onclick="continueToNextQuestion()" class="hidden">–ü—Ä–æ–¥–æ–≤–∂–∏—Ç–∏</button>
            </div>
        </div>

        <!-- Results Section -->
        <div id="results" class="section hidden">
            <div id="results-content"></div>
        </div>
    </div>

    <script>
        let currentUsername = null;
        let currentUserId = null;
        let questions = {{QUESTIONS_DATA}};
        let showRightAnswer = {{SHOW_RIGHT_ANSWER}};
        let currentQuestionIndex = 0;
        let selectedAnswer = null;
        let selectedAnswers = []; // For multiple choice questions
        let textAnswer = ''; // For text input questions
        let testResults = [];

        // Helper function to convert absolute paths to relative paths
        function makeRelativePath(path) {
            if (path && typeof path === 'string' && path.startsWith('/')) {
                return path.substring(1);
            }
            return path;
        }

        // Notify server when question starts (for timing and live stats)
        async function notifyQuestionStart(questionId) {
            try {
                await fetch('api/question-start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_id: currentUserId,
                        question_id: questionId
                    })
                });
            } catch (error) {
                console.log('Failed to notify question start:', error);
            }
        }

        // Error message utilities
        function showError(elementId, message) {
            const errorElement = document.getElementById(elementId);
            if (errorElement) {
                errorElement.textContent = message;
                errorElement.classList.remove('hidden');
                setTimeout(() => {
                    hideError(elementId);
                }, 5000); // Auto-hide after 5 seconds
            }
        }

        function hideError(elementId) {
            const errorElement = document.getElementById(elementId);
            if (errorElement) {
                errorElement.classList.add('hidden');
                errorElement.textContent = '';
            }
        }

        // Theme management
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            if (savedTheme === 'dark') {
                document.body.setAttribute('data-theme', 'dark');
                document.querySelector('.theme-toggle').textContent = '‚òÄÔ∏è';
            }
        }

        function toggleTheme() {
            const currentTheme = document.body.getAttribute('data-theme');
            const toggleButton = document.querySelector('.theme-toggle');

            if (currentTheme === 'dark') {
                document.body.removeAttribute('data-theme');
                toggleButton.textContent = 'üåô';
                localStorage.setItem('theme', 'light');
            } else {
                document.body.setAttribute('data-theme', 'dark');
                toggleButton.textContent = '‚òÄÔ∏è';
                localStorage.setItem('theme', 'dark');
            }
        }

        // Username display management
        function showUsername(username) {
            document.getElementById('username-display').textContent = username;
            document.getElementById('user-info').classList.add('visible');
        }

        function hideUsername() {
            document.getElementById('user-info').classList.remove('visible');
        }

        // Registration data storage management
        const REGISTRATION_STORAGE_KEY = 'webquiz_registration_data';

        function saveRegistrationData(data) {
            try {
                localStorage.setItem(REGISTRATION_STORAGE_KEY, JSON.stringify(data));
            } catch (error) {
                console.log('Failed to save registration data to localStorage:', error);
            }
        }

        function loadRegistrationData() {
            try {
                const storedData = localStorage.getItem(REGISTRATION_STORAGE_KEY);
                return storedData ? JSON.parse(storedData) : null;
            } catch (error) {
                console.log('Failed to load registration data from localStorage:', error);
                return null;
            }
        }

        function prefillRegistrationForm() {
            const savedData = loadRegistrationData();
            if (!savedData) return;

            // Pre-fill username field
            const usernameField = document.getElementById('username');
            if (usernameField && savedData.username) {
                usernameField.value = savedData.username;
            }

            // Pre-fill additional registration fields
            const additionalFields = document.querySelectorAll('.registration-field');
            for (const field of additionalFields) {
                const fieldName = field.getAttribute('data-field-name');
                if (fieldName && savedData[fieldName]) {
                    field.value = savedData[fieldName];
                }
            }
        }

        // Cookie management
        function setCookie(name, value, days = 30) {
            const expires = new Date();
            expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
            document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for(let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        // Question order management (for randomization)
        function applyQuestionOrder(questionOrder) {
            /**
             * Reorder the questions array based on server-provided question order.
             * questionOrder: array of question IDs in desired order
             */
            if (!questionOrder || questionOrder.length === 0) {
                return;  // No reordering needed
            }

            console.log('Applying question order:', questionOrder);

            // Create a new array with questions in the specified order
            const reorderedQuestions = [];
            for (const questionId of questionOrder) {
                const question = questions.find(q => q.id === questionId);
                if (question) {
                    reorderedQuestions.push(question);
                }
            }

            // Replace the questions array with the reordered one
            if (reorderedQuestions.length === questions.length) {
                questions = reorderedQuestions;
                console.log('Questions reordered successfully');
            } else {
                console.warn('Question order mismatch - keeping original order');
            }
        }

        // Initialize theme and check for stored user ID on page load
        initializeTheme();
        checkStoredUserId();

        async function checkStoredUserId() {
            const storedUserId = getCookie('user_id');

            if (storedUserId) {
                // User ID stored, verify it with server
                try {
                    const response = await fetch(`api/verify-user/${storedUserId}`);
                    const data = await response.json();

                    if (response.ok && data.valid) {
                        // Valid user ID, set user data
                        currentUserId = data.user_id;
                        currentUsername = data.username;

                        // Apply question order if provided (for randomization)
                        if (data.question_order) {
                            applyQuestionOrder(data.question_order);
                        }

                        // Show username on page
                        showUsername(currentUsername);

                        // Check if user is waiting for approval
                        if (data.requires_approval && !data.approved) {
                            // User is waiting for approval
                            document.getElementById('loading').classList.add('hidden');
                            // Show waiting screen with user's data
                            if (data.user_data) {
                                showWaitingForApproval(data.user_data);
                            }
                        } else if (data.test_completed && data.final_results) {
                            // Test is completed, show final results
                            showCompletedTestResults(data.final_results);
                        } else {
                            // Approved or no approval required - resume test
                            currentQuestionIndex = data.next_question_index;
                            await hideLoadingShowTest();
                            await notifyQuestionStart(questions[currentQuestionIndex].id);
                        }
                    } else {
                        // Invalid user ID, need registration
                        hideLoadingShowRegistration();
                    }
                } catch (error) {
                    // Error verifying, need registration
                    hideLoadingShowRegistration();
                }
            } else {
                // No stored user ID, show registration form
                hideLoadingShowRegistration();
            }
        }

        function hideLoadingShowRegistration() {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('registration').classList.remove('hidden');
            // Pre-fill form with previously saved data
            prefillRegistrationForm();
        }

        async function hideLoadingShowTest() {
            document.getElementById('loading').classList.add('hidden');
            await startTest();
        }



        async function registerUser() {
            const username = document.getElementById('username').value.trim();
            if (!username) {
                showError('registration-error', '–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å —ñ–º\'—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞');
                return;
            }

            // Collect registration data
            const registrationData = { username: username };

            // Collect additional registration fields
            const additionalFields = document.querySelectorAll('.registration-field');
            for (const field of additionalFields) {
                const fieldName = field.getAttribute('data-field-name');
                const fieldValue = field.value.trim();

                // Get field label from the table TD
                const fieldRow = field.closest('tr');
                const fieldLabel = fieldRow ? fieldRow.querySelector('td:first-child')?.textContent.replace(':', '').trim() : fieldName;

                if (!fieldValue) {
                    showError('registration-error', `–ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞–ø–æ–≤–Ω—ñ—Ç—å –ø–æ–ª–µ "${fieldLabel}"`);
                    return;
                }
                registrationData[fieldName] = fieldValue;
            }

            // Clear previous errors
            hideError('registration-error');

            try {
                const response = await fetch('api/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(registrationData)
                });

                const data = await response.json();
                if (response.ok) {
                    currentUsername = data.username;
                    currentUserId = data.user_id;
                    setCookie('user_id', currentUserId);

                    // Save registration data to localStorage for future use
                    saveRegistrationData(registrationData);

                    // Show username on page
                    showUsername(currentUsername);

                    // Apply question order if provided (for randomization)
                    if (data.question_order) {
                        applyQuestionOrder(data.question_order);
                    }

                    // Check if approval is required
                    if (data.requires_approval && !data.approved) {
                        // Hide registration, show waiting for approval
                        document.getElementById('registration').classList.add('hidden');
                        showWaitingForApproval(registrationData);
                    } else {
                        // Approved or no approval required - start test
                        currentQuestionIndex = 0; // New user starts from beginning
                        document.getElementById('registration').classList.add('hidden');
                        await startTest();
                        await notifyQuestionStart(questions[currentQuestionIndex].id);
                    }
                } else {
                    showError('registration-error', data.error || '–ü–æ–º–∏–ª–∫–∞ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó');
                }
            } catch (error) {
                showError('registration-error', '–ü–æ–º–∏–ª–∫–∞: ' + error.message);
            }
        }

        function showWaitingForApproval(registrationData) {
            // Populate the waiting approval form with current registration data
            const waitingFieldsContainer = document.getElementById('waiting-registration-fields');

            // Create a table similar to registration form using CSS classes
            let fieldsHTML = '<table class="registration-table">';
            fieldsHTML += `<tr><td class="registration-label">{{USERNAME_LABEL}}:</td><td class="registration-input"><input type="text" id="waiting-username" value="${registrationData.username || ''}" /></td></tr>`;

            // Add additional registration fields if they exist
            const additionalFields = document.querySelectorAll('.registration-field');
            for (const field of additionalFields) {
                const fieldName = field.getAttribute('data-field-name');
                const fieldRow = field.closest('tr');
                const fieldLabel = fieldRow ? fieldRow.querySelector('td:first-child')?.textContent.trim() : fieldName;
                const fieldValue = registrationData[fieldName] || '';

                fieldsHTML += `<tr><td class="registration-label">${fieldLabel}</td><td class="registration-input"><input type="text" class="waiting-field" data-field-name="${fieldName}" value="${fieldValue}" /></td></tr>`;
            }
            fieldsHTML += '</table>';

            waitingFieldsContainer.innerHTML = fieldsHTML;
            document.getElementById('waiting-approval').classList.remove('hidden');
        }

        async function updateRegistrationData() {
            const username = document.getElementById('waiting-username').value.trim();
            if (!username) {
                showError('waiting-error', '–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å —ñ–º\'—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞');
                return;
            }

            // Collect updated registration data
            const updatedData = {
                user_id: currentUserId,
                username: username
            };

            // Collect additional fields
            const waitingFields = document.querySelectorAll('.waiting-field');
            for (const field of waitingFields) {
                const fieldName = field.getAttribute('data-field-name');
                updatedData[fieldName] = field.value.trim();
            }

            hideError('waiting-error');

            try {
                const response = await fetch('api/update-registration', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updatedData)
                });

                const data = await response.json();
                if (response.ok) {
                    // Show success message
                    const errorElement = document.getElementById('waiting-error');
                    errorElement.textContent = '‚úì –î–∞–Ω—ñ —É—Å–ø—ñ—à–Ω–æ –æ–Ω–æ–≤–ª–µ–Ω–æ!';
                    errorElement.style.backgroundColor = '#d4edda';
                    errorElement.style.color = '#155724';
                    errorElement.style.borderColor = '#c3e6cb';
                    errorElement.classList.remove('hidden');
                    setTimeout(() => {
                        hideError('waiting-error');
                        errorElement.style.backgroundColor = '';
                        errorElement.style.color = '';
                        errorElement.style.borderColor = '';
                    }, 3000);

                    currentUsername = updatedData.username;
                    showUsername(currentUsername);

                    // Save updated registration data to localStorage for future use
                    saveRegistrationData(updatedData);
                } else {
                    showError('waiting-error', data.error || '–ü–æ–º–∏–ª–∫–∞ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–∞–Ω–∏—Ö');
                }
            } catch (error) {
                showError('waiting-error', '–ü–æ–º–∏–ª–∫–∞: ' + error.message);
            }
        }

        async function checkApprovalStatus() {
            if (!currentUserId) {
                showError('waiting-error', 'User ID not found');
                return;
            }

            hideError('waiting-error');

            try {
                const response = await fetch(`api/verify-user/${currentUserId}`);
                const data = await response.json();

                if (response.ok && data.valid) {
                    if (data.approved) {
                        // User has been approved! Start the test

                        // Apply question order if provided (for randomization)
                        if (data.question_order) {
                            applyQuestionOrder(data.question_order);
                        }

                        document.getElementById('waiting-approval').classList.add('hidden');
                        currentQuestionIndex = 0;
                        await startTest();
                        await notifyQuestionStart(questions[currentQuestionIndex].id);
                    } else {
                        // Still waiting for approval
                        showError('waiting-error', '–í–∏ —â–µ –Ω–µ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω—ñ. –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–∞—á–µ–∫–∞–π—Ç–µ.');
                    }
                } else {
                    showError('waiting-error', data.message || '–ü–æ–º–∏–ª–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å—É');
                }
            } catch (error) {
                showError('waiting-error', '–ü–æ–º–∏–ª–∫–∞: ' + error.message);
            }
        }


        async function startTest() {
            selectedAnswer = null;
            testResults = [];
            document.getElementById('test-section').classList.remove('hidden');
            await showCurrentQuestion(false); // Don't animate first question
        }

        async function showCurrentQuestion(withAnimation = true) {
            if (currentQuestionIndex >= questions.length) {
                // Test completed - fetch final results from server to ensure consistency
                await fetchAndShowFinalResults();
                return;
            }

            const question = questions[currentQuestionIndex];
            selectedAnswer = null;
            selectedAnswers = [];
            textAnswer = question.type === 'text' ? (question.default_value || '') : '';

            // Update progress
            const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
            document.getElementById('progress-fill').style.width = progress + '%';
            document.getElementById('progress-text').textContent = `–ü–∏—Ç–∞–Ω–Ω—è ${currentQuestionIndex + 1} –∑ ${questions.length}`;

            // Show current question
            const container = document.getElementById('current-question-container');
            const questionPoints = question.points || 1;
            const isTextQuestion = question.type === 'text';

            let questionContent;
            if (isTextQuestion) {
                // Text input question
                questionContent = `
                    <div class="text-input-container">
                        <p style="font-size: 14px; color: var(--text-muted); margin-bottom: 10px;">‚úçÔ∏è –í–≤–µ–¥—ñ—Ç—å –≤–∞—à—É –≤—ñ–¥–ø–æ–≤—ñ–¥—å:</p>
                        <textarea id="text-answer-input" class="text-answer-input" placeholder="–í–≤–µ–¥—ñ—Ç—å –≤—ñ–¥–ø–æ–≤—ñ–¥—å..." oninput="onTextAnswerInput(this)">${question.default_value || ''}</textarea>
                        <div id="checker-feedback"></div>
                    </div>
                `;
            } else {
                // Choice question (single or multiple)
                questionContent = `
                    <div class="options">
                        ${question.is_multiple_choice ? '<p class="multiple-choice-hint" style="font-size: 14px; color: var(--text-muted); margin-bottom: 10px;">üìã –ú–æ–∂–Ω–∞ –æ–±—Ä–∞—Ç–∏ –∫—ñ–ª—å–∫–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥–µ–π</p>' : ''}
                        ${question.options.map((option, optionIndex) => {
                            const isImageOption = option.startsWith('/');

                            if (isImageOption) {
                                return `
                                    <div class="option quiz-option" data-option-index="${optionIndex}" onclick="selectCurrentAnswer(${optionIndex})" id="option_${optionIndex}">
                                        <div class="option-content">
                                            <img src="${makeRelativePath(option)}" alt="Option ${optionIndex + 1}" class="option-image">
                                        </div>
                                    </div>
                                `;
                            } else {
                                return `
                                    <div class="option quiz-option" data-option-index="${optionIndex}" onclick="selectCurrentAnswer(${optionIndex})" id="option_${optionIndex}">
                                        ${option}
                                    </div>
                                `;
                            }
                        }).join('')}
                    </div>
                `;
            }

            container.innerHTML = `
                <div class="current-question active-question" style="position: relative;">
                    ${questionPoints > 1 ? `<div class="question-points-badge">üèÜ ${questionPoints} ${questionPoints >= 2 && questionPoints <= 4 ? '–±–∞–ª–∏' : '–±–∞–ª—ñ–≤'}</div>` : ''}
                    ${question.question ? `<h3 class="question-text">${question.question}</h3>` : ''}
                    ${question.image ? `<a href="${makeRelativePath(question.image)}" target="_blank"><img src="${makeRelativePath(question.image)}" alt="Question image" class="question-image quiz-question-img"></a>` : ''}
                    ${question.file ? `<a href="${makeRelativePath(question.file)}" download class="question-file"><span class="question-file-icon">üìé</span><span class="question-file-name">${question.file.split('/').pop()}</span></a>` : ''}
                    ${questionContent}
                </div>
            `;

            // Add fade-in animation to newly displayed question (only for manual transitions)
            if (withAnimation) {
                const newQuestion = container.querySelector('.current-question');
                if (newQuestion) {
                    newQuestion.classList.add('question-fade-in');
                }
            }

            // Reset button states
            const submitBtn = document.getElementById('submit-answer-btn');
            const continueBtn = document.getElementById('continue-btn');

            submitBtn.classList.remove('hidden');
            // For text questions, enable submit if there's a default value or any text
            if (isTextQuestion) {
                submitBtn.disabled = !textAnswer.trim();
            } else {
                submitBtn.disabled = true;
            }
            continueBtn.classList.add('hidden');
        }

        // Handle text input changes
        function onTextAnswerInput(textarea) {
            textAnswer = textarea.value;
            const submitBtn = document.getElementById('submit-answer-btn');
            submitBtn.disabled = !textAnswer.trim();
        }

        function selectCurrentAnswer(optionIndex) {
            // Don't allow selection if already submitted
            if (document.querySelector('.option.disabled')) {
                return;
            }

            const question = questions[currentQuestionIndex];
            const optionElement = document.getElementById(`option_${optionIndex}`);

            if (question.is_multiple_choice) {
                // Multiple choice logic - toggle selection
                if (selectedAnswers.includes(optionIndex)) {
                    // Deselect if already selected
                    selectedAnswers = selectedAnswers.filter(idx => idx !== optionIndex);
                    optionElement.classList.remove('selected');
                } else {
                    // Select if not selected
                    selectedAnswers.push(optionIndex);
                    optionElement.classList.add('selected');
                }

                // Enable submit button if at least one answer is selected
                document.getElementById('submit-answer-btn').disabled = selectedAnswers.length === 0;
            } else {
                // Single choice logic - selecting new option deselects previous
                if (selectedAnswer === optionIndex) {
                    // Deselect if clicking the same option
                    selectedAnswer = null;
                    optionElement.classList.remove('selected');
                    document.getElementById('submit-answer-btn').disabled = true;
                } else {
                    // Clear previous selections
                    document.querySelectorAll('.option').forEach(option => {
                        option.classList.remove('selected');
                    });

                    // Select current option
                    selectedAnswer = optionIndex;
                    optionElement.classList.add('selected');
                    document.getElementById('submit-answer-btn').disabled = false;
                }
            }
        }

        async function submitCurrentAnswer() {
            const question = questions[currentQuestionIndex];
            const isTextQuestion = question.type === 'text';

            // Validate selection based on question type
            if (isTextQuestion) {
                if (!textAnswer.trim()) {
                    showError('test-error', '–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –≤—ñ–¥–ø–æ–≤—ñ–¥—å');
                    return;
                }
            } else if (question.is_multiple_choice) {
                if (selectedAnswers.length === 0) {
                    showError('test-error', '–ë—É–¥—å –ª–∞—Å–∫–∞, –æ–±–µ—Ä—ñ—Ç—å —Ö–æ—á–∞ –± –æ–¥–Ω—É –≤—ñ–¥–ø–æ–≤—ñ–¥—å');
                    return;
                }
            } else {
                if (selectedAnswer === null) {
                    showError('test-error', '–ë—É–¥—å –ª–∞—Å–∫–∞, –æ–±–µ—Ä—ñ—Ç—å –≤—ñ–¥–ø–æ–≤—ñ–¥—å');
                    return;
                }
            }

            // Clear previous errors
            hideError('test-error');

            // Disable submit button immediately to prevent double-clicks
            const submitBtn = document.getElementById('submit-answer-btn');
            submitBtn.disabled = true;

            // Determine the answer to submit
            let answerToSubmit;
            if (isTextQuestion) {
                answerToSubmit = textAnswer;
            } else if (question.is_multiple_choice) {
                answerToSubmit = selectedAnswers.slice().sort((a, b) => a - b);
            } else {
                answerToSubmit = selectedAnswer;
            }

            try {
                const response = await fetch('api/submit-answer', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        user_id: currentUserId,
                        question_id: question.id,
                        selected_answer: answerToSubmit
                    })
                });

                if (!response.ok) {
                    // Try to parse error response as JSON
                    const errorText = await response.text();
                    try {
                        const errorData = JSON.parse(errorText);
                        throw new Error(errorData.error || errorText);
                    } catch (parseError) {
                        // If JSON parsing fails, use the raw text
                        throw new Error(errorText);
                    }
                }

                const responseText = await response.text();
                let data;
                try {
                    data = JSON.parse(responseText);
                } catch (parseError) {
                    console.error('JSON Parse Error:', parseError);
                    console.error('Response text:', responseText);
                    throw new Error(`Invalid JSON response: ${responseText.substring(0, 100)}`);
                }

                // Format selected answer for display
                let selectedAnswerDisplay;
                if (isTextQuestion) {
                    selectedAnswerDisplay = textAnswer;
                } else if (question.is_multiple_choice) {
                    selectedAnswerDisplay = selectedAnswers.map(idx => question.options[idx]).join(' | ');
                } else {
                    selectedAnswerDisplay = question.options[selectedAnswer];
                }

                testResults.push({
                    questionId: question.id,
                    question: question.question,
                    image: question.image,
                    file: question.file,
                    selectedAnswer: selectedAnswerDisplay,
                    isCorrect: data.is_correct !== undefined ? data.is_correct : null,  // null when not provided
                    timeTaken: data.time_taken || 0,
                    isMultipleChoice: question.is_multiple_choice,
                    isTextQuestion: isTextQuestion,
                    checkerError: data.checker_error,
                    correctValue: data.correct_value
                });

                // Show feedback on selected answer
                showAnswerFeedback(data.is_correct, data.correct_answer, data.is_text_question, data.checker_error, data.correct_value);

            } catch (error) {
                showError('test-error', '–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ: ' + error.message);
                // Re-enable submit button on error so user can retry
                submitBtn.disabled = false;
            }
        }

        function showAnswerFeedback(isCorrect, correctAnswer, isTextQuestion, checkerError, correctValue) {
            const question = questions[currentQuestionIndex];
            const actualIsTextQuestion = question.type === 'text';

            // If isCorrect is undefined, don't show any feedback (show_right_answer is false)
            if (isCorrect === undefined) {
                // Disable all options or text input to prevent further selection
                if (actualIsTextQuestion) {
                    const textInput = document.getElementById('text-answer-input');
                    if (textInput) {
                        textInput.disabled = true;
                    }
                } else {
                    document.querySelectorAll('.option').forEach(option => {
                        option.classList.add('disabled');
                    });
                }

                // Hide submit button (no continue button needed - auto-advance)
                const submitBtn = document.getElementById('submit-answer-btn');
                submitBtn.classList.add('hidden');

                // Auto-advance to next question with animation after a brief pause
                // Brief delay allows user to see their selection before transition
                setTimeout(() => {
                    continueToNextQuestion(true);
                }, 100);
                return;
            }

            if (actualIsTextQuestion) {
                // Text input question feedback
                const textInput = document.getElementById('text-answer-input');
                const feedbackContainer = document.getElementById('checker-feedback');

                if (textInput) {
                    textInput.disabled = true;
                    textInput.classList.add(isCorrect ? 'feedback-correct' : 'feedback-incorrect');
                }

                if (feedbackContainer) {
                    let feedbackHtml = '';

                    // Show checker error if present and answer is incorrect
                    if (!isCorrect && checkerError) {
                        feedbackHtml += `<div class="checker-error">‚ö†Ô∏è ${checkerError}</div>`;
                    }

                    // Show correct value if answer is incorrect and correct value is available
                    if (!isCorrect && correctValue) {
                        feedbackHtml += `<div class="correct-value-display">‚úì –ü—Ä–∞–≤–∏–ª—å–Ω–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å: <pre style="margin: 5px 0 0 0; white-space: pre-wrap;">${correctValue}</pre></div>`;
                    }

                    feedbackContainer.innerHTML = feedbackHtml;
                }
            } else if (question.is_multiple_choice) {
                // Multiple choice feedback
                const correctAnswerArray = Array.isArray(correctAnswer) ? correctAnswer : [];

                // First, mark all user's selected answers
                selectedAnswers.forEach(answerIndex => {
                    const optionElement = document.getElementById(`option_${answerIndex}`);
                    if (correctAnswerArray.includes(answerIndex)) {
                        // User selected a correct answer
                        optionElement.classList.add('feedback-correct');
                    } else {
                        // User selected an incorrect answer
                        optionElement.classList.add('feedback-incorrect');
                    }
                });

                // Then, highlight any missed correct answers (always show all correct answers)
                correctAnswerArray.forEach(correctIndex => {
                    if (!selectedAnswers.includes(correctIndex)) {
                        // This is a correct answer the user missed
                        const correctOption = document.getElementById(`option_${correctIndex}`);
                        if (correctOption) {
                            correctOption.classList.add('feedback-missed');
                        }
                    }
                });
            } else {
                // Single choice feedback
                const selectedOption = document.querySelector('.option.selected');
                if (selectedOption) {
                    selectedOption.classList.add(isCorrect ? 'feedback-correct' : 'feedback-incorrect');
                }

                // If answer is incorrect and correctAnswer is provided, highlight the correct answer
                if (!isCorrect && correctAnswer !== undefined && correctAnswer !== null) {
                    const correctOption = document.getElementById(`option_${correctAnswer}`);
                    if (correctOption) {
                        correctOption.classList.add('feedback-correct');
                    }
                }
            }

            // Disable all options to prevent further selection (for choice questions)
            if (!actualIsTextQuestion) {
                document.querySelectorAll('.option').forEach(option => {
                    option.classList.add('disabled');
                });
            }

            // Hide submit button and show continue button
            const submitBtn = document.getElementById('submit-answer-btn');
            const continueBtn = document.getElementById('continue-btn');

            submitBtn.classList.add('hidden');
            continueBtn.classList.remove('hidden');
            continueBtn.disabled = false; // Re-enable for the next question
        }

        async function continueToNextQuestion(withAnimation = true) {
            // Disable continue button to prevent double-clicks during animation
            const continueBtn = document.getElementById('continue-btn');
            if (continueBtn) {
                continueBtn.disabled = true;
            }

            // Only apply fade-out animation for manual transitions (not auto-advance)
            if (withAnimation) {
                const container = document.getElementById('current-question-container');
                const currentQuestion = container.querySelector('.current-question');

                if (currentQuestion) {
                    currentQuestion.classList.add('question-fade-out');
                    // Wait for fade-out animation to complete (450ms)
                    await new Promise(resolve => setTimeout(resolve, 450));
                }
            }

            // Move to next question
            currentQuestionIndex++;

            // Check if we've reached the end before notifying server
            if (currentQuestionIndex >= questions.length) {
                // Test completed - go directly to results
                await showCurrentQuestion(false); // No animation for results screen
                return;
            }

            // Notify server that question is being displayed (for live stats and timing)
            // This should ONLY happen when user clicks "–ü—Ä–æ–¥–æ–≤–∂–∏—Ç–∏" to open next question
            notifyQuestionStart(questions[currentQuestionIndex].id);

            await showCurrentQuestion(withAnimation); // Pass animation parameter through

            // If animation was applied, wait for it to complete before allowing further interaction
            // This ensures Selenium tests can reliably detect the new question after animation
            if (withAnimation) {
                await new Promise(resolve => setTimeout(resolve, 525)); // Wait for fade-in to complete (500ms + buffer)
            }
        }

        async function fetchAndShowFinalResults() {
            try {
                // Fetch final results from server to ensure consistency with page reload
                const response = await fetch(`api/verify-user/${currentUserId}`);
                const data = await response.json();

                if (response.ok && data.valid && data.test_completed && data.final_results) {
                    // Use the same function as page reload to ensure identical display
                    showCompletedTestResults(data.final_results);
                } else {
                    // Fallback to client-side results if server fetch fails
                    showFinalResults();
                }
            } catch (error) {
                console.error('Error fetching final results from server:', error);
                // Fallback to client-side results
                showFinalResults();
            }
        }

        function formatQuestionForDisplay(questionText, questionImage, questionFile) {
            let html = '';

            // Add question text if present
            if (questionText) {
                html += questionText;
            }

            // Add image if present
            if (questionImage && questionImage.startsWith('/')) {
                if (html) html += '<br>';
                html += `<img src="${makeRelativePath(questionImage)}" alt="Question image" style="max-width: 200px; max-height: 150px; border-radius: 5px;">`;
            }

            // Add file download link if present
            if (questionFile && questionFile.startsWith('/')) {
                if (html) html += '<br>';
                const fileName = questionFile.split('/').pop();
                html += `<a href="${makeRelativePath(questionFile)}" download class="question-file" style="display: inline-flex; margin-top: 5px; padding: 5px 10px; font-size: 12px;"><span class="question-file-icon">üìé</span><span class="question-file-name">${fileName}</span></a>`;
            }

            // Fallback if nothing present
            if (!html) {
                return questionImage || questionFile || '–ù–µ–º–∞—î –∫–æ–Ω—Ç–µ–Ω—Ç—É –ø–∏—Ç–∞–Ω–Ω—è';
            }

            return html;
        }

        function formatAnswerForDisplay(answerText) {
            if (!answerText) return '';

            // Check if it's multiple answers (contains | separator)
            if (answerText.includes('|')) {
                const answers = answerText.split('|');
                return answers.map(answer => {
                    const trimmedAnswer = answer.trim();
                    if (trimmedAnswer.startsWith('/')) {
                        // Image answer
                        return `<div style="margin: 2px 0;"><img src="${makeRelativePath(trimmedAnswer)}" alt="Answer option" style="max-width: 100px; max-height: 75px; border-radius: 3px;"></div>`;
                    } else {
                        // Text answer
                        return `<div style="margin: 2px 0;">${trimmedAnswer}</div>`;
                    }
                }).join('');
            } else {
                // Single answer
                if (answerText.startsWith('/')) {
                    // Display image for answer option
                    return `<img src="${makeRelativePath(answerText)}" alt="Answer option" style="max-width: 100px; max-height: 75px; border-radius: 3px;">`;
                } else {
                    // Text answer
                    return answerText;
                }
            }
        }

        function showFinalResults() {
            document.getElementById('test-section').classList.add('hidden');

            const container = document.getElementById('results-content');
            container.innerHTML = '';

            const correctCount = testResults.filter(r => r.isCorrect === true).length;  // Only count explicitly true values
            const totalCount = testResults.length;
            const percentage = Math.round((correctCount / totalCount) * 100);
            const totalTime = testResults.reduce((sum, r) => sum + r.timeTaken, 0);
            const avgTime = totalTime / totalCount;

            // Build table with results using CSS classes
            let tableContent = `
                <p><strong>–†–µ–∑—É–ª—å—Ç–∞—Ç:</strong> ${correctCount}/${totalCount} (${percentage}%)</p>
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>–ü–∏—Ç–∞–Ω–Ω—è</th>
                            <th>–í–∞—à–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å</th>
                            <th style="text-align: center;">–ó–∞—Ä–∞—Ö–æ–≤–∞–Ω–æ</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            testResults.forEach((result, index) => {
                // Note: testResults uses different property names than server data
                const correctAnswer = (questions[index] && questions[index].correct_answer !== undefined) ? questions[index].options[questions[index].correct_answer] : null;
                tableContent += `
                    <tr>
                        <td data-label="–ü–∏—Ç–∞–Ω–Ω—è">${formatQuestionForDisplay(result.question, result.image, result.file)}</td>
                        <td data-label="–í–∞—à–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å">
                            <span class="${result.isCorrect === true ? 'answer-correct' : (result.isCorrect === false ? 'answer-incorrect' : '')}">
                                ${formatAnswerForDisplay(result.selectedAnswer)}
                            </span>
                            ${result.isCorrect === false && correctAnswer && showRightAnswer ? `<div class="correct-answer-hint">–ü—Ä–∞–≤–∏–ª—å–Ω–∞: ${formatAnswerForDisplay(correctAnswer)}</div>` : ''}
                        </td>
                        <td data-label="–ü—Ä–∞–≤–∏–ª—å–Ω–æ" style="text-align: center;">
                            ${result.isCorrect !== null ? `<span class="${result.isCorrect ? 'correct' : 'incorrect'}" style="font-size: 18px;">${result.isCorrect ? '‚úì' : '‚úó'}</span>` : '<span style="color: #666;">‚Äî</span>'}
                        </td>
                    </tr>
                `;
            });

            tableContent += `
                    </tbody>
                </table>
            `;

            container.innerHTML = tableContent;

            document.getElementById('test-section').classList.add('hidden');
            document.getElementById('results').classList.remove('hidden');
        }

        function showCompletedTestResults(finalResults) {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('test-section').classList.add('hidden');

            const container = document.getElementById('results-content');
            container.innerHTML = '';

            const correctCount = finalResults.correct_count;
            const totalCount = finalResults.total_count;
            const percentage = finalResults.percentage;
            const earnedPoints = finalResults.earned_points || 0;
            const totalPoints = finalResults.total_points || totalCount;
            const pointsPercentage = finalResults.points_percentage || percentage;
            const showAnswersOnCompletion = finalResults.show_answers_on_completion || false;
            const allCompleted = finalResults.all_completed || false;

            // Determine if we should show the waiting message
            const shouldShowWaitingMessage = showAnswersOnCompletion && !allCompleted;

            // Check if correct answers are available (is_correct field exists in test_results)
            const hasCorrectAnswers = finalResults.test_results.length > 0 &&
                                      finalResults.test_results[0].is_correct !== undefined;

            // Build results display - show points if there are questions with non-default points
            const hasCustomPoints = totalPoints !== totalCount;
            const pointsDisplay = hasCustomPoints
                ? `<p><strong>–ë–∞–ª–∏:</strong> ${earnedPoints}/${totalPoints} (${pointsPercentage}%)</p>`
                : '';

            container.innerHTML = `
                <p><strong>–†–µ–∑—É–ª—å—Ç–∞—Ç:</strong> ${correctCount}/${totalCount} (${percentage}%)</p>
                ${pointsDisplay}
                ${shouldShowWaitingMessage ? `
                    <div style="background: var(--stats-bg); padding: 15px; border-radius: 5px; margin: 15px 0; border-left: 4px solid #2196f3;">
                        <p style="margin: 0 0 10px 0;"><strong>‚ÑπÔ∏è –ü—Ä–∞–≤–∏–ª—å–Ω—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ –±—É–¥—É—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ñ –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è —Ç–µ—Å—Ç—É –≤—Å—ñ–º–∞ —É—á–Ω—è–º–∏.</strong></p>
                        <p style="margin: 0 0 10px 0; font-size: 14px;">–ü–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Å—Ç–æ—Ä—ñ–Ω–∫—É –ø—ñ–∑–Ω—ñ—à–µ, —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ñ –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ.</p>
                        <button onclick="location.reload()" style="background: #2196f3; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 14px;">
                            üîÑ –ü–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ —Å—Ç–æ—Ä—ñ–Ω–∫—É
                        </button>
                    </div>
                ` : ''}
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>–ü–∏—Ç–∞–Ω–Ω—è</th>
                            <th>–í–∞—à–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å</th>
                            <th style="text-align: center;">–ü—Ä–∞–≤–∏–ª—å–Ω–æ</th>
                            ${hasCustomPoints ? '<th style="text-align: center;">–ë–∞–ª–∏</th>' : ''}
                        </tr>
                    </thead>
                    <tbody>
                        ${finalResults.test_results.map((result, index) => `
                            <tr>
                                <td data-label="–ü–∏—Ç–∞–Ω–Ω—è">${formatQuestionForDisplay(result.question, result.image, result.file)}</td>
                                <td data-label="–í–∞—à–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å">
                                    <span class="${result.is_correct === true ? 'answer-correct' : (result.is_correct === false ? 'answer-incorrect' : '')}">
                                        ${formatAnswerForDisplay(result.selected_answer)}
                                    </span>
                                    ${result.is_correct === false && result.correct_answer && (showRightAnswer || hasCorrectAnswers) ? `<div class="correct-answer-hint">–ü—Ä–∞–≤–∏–ª—å–Ω–∞: ${formatAnswerForDisplay(result.correct_answer)}</div>` : ''}
                                </td>
                                <td data-label="–ü—Ä–∞–≤–∏–ª—å–Ω–æ" style="text-align: center;">
                                    ${result.is_correct !== undefined ? `<span class="${result.is_correct ? 'correct' : 'incorrect'}" style="font-size: 18px;">${result.is_correct ? '‚úì' : '‚úó'}</span>` : '<span style="color: #666;">–Ω–µ –≤—ñ–¥–æ–º–æ</span>'}
                                </td>
                                ${hasCustomPoints ? `<td data-label="–ë–∞–ª–∏" style="text-align: center;">${result.earned_points !== undefined ? result.earned_points : (result.is_correct ? (result.points || 1) : 0)}/${result.points || 1}</td>` : ''}
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;

            document.getElementById('results').classList.remove('hidden');
        }
    </script>

    <div style="text-align: center; margin-top: 40px; padding: 20px; border-top: 1px solid var(--border-color); color: var(--text-color); font-size: 12px; opacity: 0.7;">
        WebQuiz v{{WEBQUIZ_VERSION}}
    </div>
</body>
</html>
