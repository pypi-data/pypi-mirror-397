"""
This type stub file was generated by pyright.
"""

import asyncpg
import pydantic
from typing import Annotated, Any, TypeVar
from aiohttp.web import HTTPError, HTTPSuccessful
from alxhttp.typescript.type_checks import TypeType
from alxhttp.typescript.types import TSEnum

def recursive_json_loads(typ: TypeType, data: Any) -> Any:
  """
  json loads anything that requires recursive model verification
  """
  ...

BaseModelType = TypeVar('BaseModelType', bound='BaseModel')
def replace_datetime_values_with_timestamps(value: dict[str, Any] | list[Any] | Any) -> dict[str, Any] | list[Any]:
  ...

def serialize_datetimes_as_timestamps(value: Any, nxt: pydantic.SerializerFunctionWrapHandler) -> Any:
  ...

class BaseModel(pydantic.BaseModel):
  """
  A Pydantic model with some opinions:
  - extra values are not allowed
  - datetimes are serialized as float timestamps
  """
  model_config = ...
  @pydantic.field_serializer('*', mode='wrap', when_used='json')
  def datetimes_as_timestamps(self, value: Any, nxt: pydantic.SerializerFunctionWrapHandler) -> Any:
    ...
  
  @classmethod
  def from_record(cls: type[BaseModelType], record: asyncpg.Record | None) -> BaseModelType:
    ...
  
  def exception(self, status_code: int = ...): # -> BaseModelException[Self]:
    """
    Wrap the model in an exception that will render as JSON
    """
    ...
  


class Empty(BaseModel):
  ...


class ErrorModel(BaseModel):
  """
  Our base class for 4XX/5XX responses. 'error' is used to allow us to treat this as
  a discriminated union and switch on it in typescript.
  """
  error: str = ...
  status_code: int = ...
  request_id: str | None = ...
  def exception(self, status_code: int = ...): # -> ErrorModelException[Self]:
    """
    Wrap the model in an exception that will render as JSON

    Intentionally does not take a status_code argument. override it on your derived class instead
    """
    ...
  


BaseModelType = TypeVar('BaseModelType', bound=BaseModel)
class BaseModelException[BaseModelType](HTTPSuccessful):
  """
  Pydantic models can't be used in mixin-inheritance so instead if we want to
  raise a model as an exception we have to store it inside a real exception.

  To help the type hinting work this is a generic class parameterized over
  your derived error type.
  """
  status_code: int = ...
  def __init__(self, model: BaseModelType, status_code: int = ...) -> None:
    ...
  


ErrorModelType = TypeVar('ErrorModelType', bound=ErrorModel)
class ErrorModelException[ErrorModelType](HTTPError):
  """
  Pydantic models can't be used in mixin-inheritance so instead if we want to
  raise a model as an exception we have to store it inside a real exception.

  To help the type hinting work this is a generic class parameterized over
  your derived error type.
  """
  status_code: int = ...
  def __init__(self, model: ErrorModelType) -> None:
    ...
  


class PydanticErrorDetails(BaseModel):
  """
  How a pydantic validation error is represented to the UI
  """
  type: str
  loc: list[int | str]
  msg: str
  input: str
  ctx: dict[str, str] | None = ...


class PydanticValidationError(ErrorModel):
  """
  How a pydantic validation error is represented to the UI
  """
  error: Annotated[str, TSEnum('ErrorCode', 'PydanticValidationError')] = ...
  errors: list[PydanticErrorDetails]


def fix_loc_list(loc: tuple[int | str | Any, ...]) -> list[int | str]:
  ...

