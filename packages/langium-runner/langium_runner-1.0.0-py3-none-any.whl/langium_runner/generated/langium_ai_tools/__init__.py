# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: interface.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    Dict,
    List,
    Optional,
)

import betterproto


class DiagnosticSeverity(betterproto.Enum):
    """Diagnostic severity levels"""

    UNSPECIFIED = 0
    ERROR = 1
    WARNING = 2
    INFORMATION = 3
    HINT = 4


@dataclass(eq=False, repr=False)
class Position(betterproto.Message):
    """Position in a text document (line and character offsets)"""

    line: int = betterproto.uint32_field(1)
    """Line position (zero-based)"""

    character: int = betterproto.uint32_field(2)
    """Character position (zero-based)"""


@dataclass(eq=False, repr=False)
class Range(betterproto.Message):
    """Text range with start and end positions"""

    start: "Position" = betterproto.message_field(1)
    """Start position"""

    end: "Position" = betterproto.message_field(2)
    """End position"""


@dataclass(eq=False, repr=False)
class Diagnostic(betterproto.Message):
    """VS Code diagnostic information"""

    range: "Range" = betterproto.message_field(1)
    """Range where the diagnostic applies"""

    message: str = betterproto.string_field(2)
    """Human-readable message"""

    severity: Optional["DiagnosticSeverity"] = betterproto.enum_field(3, optional=True)
    """Severity level"""

    code: Optional[str] = betterproto.string_field(4, optional=True)
    """Optional diagnostic code"""

    source: Optional[str] = betterproto.string_field(5, optional=True)
    """Optional source identifier (e.g., "langium")"""


@dataclass(eq=False, repr=False)
class LangiumEvaluatorResultDataMsg(betterproto.Message):
    """Langium-specific evaluator result data"""

    runtime: Optional[float] = betterproto.double_field(1, optional=True)
    """Optional runtime in milliseconds"""

    failures: int = betterproto.uint32_field(2)
    """Number of validation failures"""

    errors: int = betterproto.uint32_field(3)
    """Number of errors"""

    warnings: int = betterproto.uint32_field(4)
    """Number of warnings"""

    infos: int = betterproto.uint32_field(5)
    """Number of infos"""

    hints: int = betterproto.uint32_field(6)
    """Number of hints"""

    unassigned: int = betterproto.uint32_field(7)
    """Number of unassigned diagnostics"""

    response_length: int = betterproto.uint32_field(8)
    """Length of the response in characters"""

    diagnostics: List["Diagnostic"] = betterproto.message_field(9)
    """Raw diagnostic data"""


@dataclass(eq=False, repr=False)
class DiversityMetrics(betterproto.Message):
    """Diversity metrics for rule usage patterns"""

    entropy: float = betterproto.double_field(1)
    """
    Shannon entropy - information diversity measure
     Range: 0 to logâ‚‚(n) where n = number of rules
     Low (0-1): dominated by few rules
     Medium (1-3): moderate diversity
     High (>3): high diversity
    """

    gini_coefficient: float = betterproto.double_field(2)
    """
    Gini coefficient - inequality measure
     Range: 0 to 1
     Low (0-0.3): equal distribution
     Medium (0.3-0.7): moderate inequality
     High (0.7-1): high inequality
    """

    simpson_index: float = betterproto.double_field(3)
    """
    Simpson's diversity index - probability that two randomly selected items are different
     Range: 0 to 1
     Low (0-0.3): low diversity
     Medium (0.3-0.7): moderate diversity
     High (0.7-1): high diversity
    """


@dataclass(eq=False, repr=False)
class SyntaxStatistic(betterproto.Message):
    """Syntax usage statistics for grammar analysis"""

    rule_usage: Dict[str, int] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_UINT32
    )
    """Map of rule names to their usage counts"""

    coverage: float = betterproto.double_field(2)
    """Percentage of used rules compared to all available rules"""

    diversity: "DiversityMetrics" = betterproto.message_field(3)
    """Diversity metrics for rule usage patterns"""


@dataclass(eq=False, repr=False)
class NestedMetadata(betterproto.Message):
    """Nested metadata container (workaround for map in oneof restriction)"""

    values: Dict[str, "MetadataValue"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass(eq=False, repr=False)
class MetadataValue(betterproto.Message):
    """Metadata value wrapper to support different types of metadata"""

    string_value: str = betterproto.string_field(1, group="value")
    """String value"""

    number_value: float = betterproto.double_field(2, group="value")
    """Number value"""

    bool_value: bool = betterproto.bool_field(3, group="value")
    """Boolean value"""

    nested_metadata_value: "NestedMetadata" = betterproto.message_field(
        4, group="value"
    )
    """Nested metadata (workaround for map limitation in oneof)"""

    syntax_statistic_value: "SyntaxStatistic" = betterproto.message_field(
        5, group="value"
    )
    """Syntax statistics value"""


@dataclass(eq=False, repr=False)
class EvaluatorResultMsg(betterproto.Message):
    """Generic evaluator result container"""

    name: str = betterproto.string_field(1)
    """Name of this evaluation"""

    metadata: Dict[str, "MetadataValue"] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """
    Optional metadata as key-value pairs supporting different value types
    """

    data: "LangiumEvaluatorResultDataMsg" = betterproto.message_field(3)
    """Langium-specific data"""
