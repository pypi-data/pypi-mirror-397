##########################################
# DO NOT EDIT - THIS FILE IS AUTOGENERATED
##########################################

import os
from ctypes import (
    CDLL,
    POINTER,
    Structure,
    c_bool,
    c_int8,
    c_int16,
    c_int32,
    c_int64,
    c_uint8,
    c_uint16,
    c_uint32,
    c_uint64,
    c_void_p,
    cast,
    cdll,
    create_string_buffer,
    pointer,
    sizeof,
    string_at,
)

c_lib: CDLL = cdll.LoadLibrary(os.path.join(os.path.dirname(__file__), "ext/build/keyedDecrypt.so"))

u8 = c_uint8
u32 = c_uint32
u64 = c_uint64
s64 = c_int64
b8 = c_bool
void = None


class ComplexCrypt(Structure):
    _fields_ = [
        ("key_size", c_uint8),
        ("ignore_zero", c_bool),
        ("offset", c_uint32),
        ("starting_key", c_uint64),
        ("key_increment", c_int64),
    ]
    key_size: int
    ignore_zero: bool
    offset: int
    starting_key: int
    key_increment: int


class BasicCrypt(Structure):
    _fields_ = [
        ("deob_key", c_uint8),
        ("offset", c_uint32),
    ]
    deob_key: int
    offset: int


c_rolling_xor_decrypt = c_lib.rolling_xor_decrypt
c_rolling_xor_decrypt.argtypes = [
    POINTER(c_uint8),  # output_buffer
    POINTER(c_uint8),  # input_buffer
    c_uint32,  # buffer_size
    c_uint8,  # start_key
]
c_rolling_xor_decrypt.restype = None


def rolling_xor_decrypt(
    output_buffer_byte_count: int,
    input_buffer: bytes,
    buffer_size: int,
    start_key: int,
) -> bytes:
    """Returns output_buffer."""
    output_buffer_buffer: POINTER(c_uint8) = cast(
        create_string_buffer(output_buffer_byte_count * sizeof(c_uint8)), POINTER(c_uint8)
    )

    c_rolling_xor_decrypt(
        output_buffer_buffer,
        cast(input_buffer, POINTER(c_uint8)),
        c_uint32(buffer_size),
        c_uint8(start_key),
    )

    output_buffer: bytes = string_at(output_buffer_buffer, output_buffer_byte_count)
    return output_buffer


c_rolling_xor_find = c_lib.rolling_xor_find
c_rolling_xor_find.argtypes = [
    POINTER(c_uint32),  # offsets
    c_uint32,  # offset_count_max
    POINTER(c_uint32),  # offset_count
    POINTER(c_uint8),  # buffer
    c_uint32,  # buffer_size
    POINTER(c_uint8),  # pattern
    c_uint32,  # pattern_size
    c_uint32,  # pattern_offset
]
c_rolling_xor_find.restype = None


def rolling_xor_find(
    offsets_element_count: int,
    offset_count_max: int,
    buffer: bytes,
    buffer_size: int,
    pattern: bytes,
    pattern_size: int,
    pattern_offset: int,
) -> tuple[list[int], int]:
    """Returns offsets, offset_count."""
    offsets_buffer: POINTER(c_uint32) = cast(
        create_string_buffer(offsets_element_count * sizeof(c_uint32)), POINTER(c_uint32)
    )
    offset_count_indirect: POINTER(c_uint32) = pointer(c_uint32(0))

    c_rolling_xor_find(
        offsets_buffer,
        c_uint32(offset_count_max),
        offset_count_indirect,
        cast(buffer, POINTER(c_uint8)),
        c_uint32(buffer_size),
        cast(pattern, POINTER(c_uint8)),
        c_uint32(pattern_size),
        c_uint32(pattern_offset),
    )

    offsets: list[int] = [offsets_buffer[i] for i in range(offsets_element_count)]
    offset_count: int = offset_count_indirect.contents.value
    return offsets, offset_count


c_xor_decrypt = c_lib.xor_decrypt
c_xor_decrypt.argtypes = [
    POINTER(c_uint8),  # output_buffer
    POINTER(c_uint8),  # input_buffer
    c_uint32,  # buffer_size
    c_uint64,  # key
    c_uint8,  # key_size
    c_int64,  # key_increment
    c_bool,  # ignore_zero
]
c_xor_decrypt.restype = None


def xor_decrypt(
    output_buffer_byte_count: int,
    input_buffer: bytes,
    buffer_size: int,
    key: int,
    key_size: int,
    key_increment: int,
    ignore_zero: bool,
) -> bytes:
    """Returns output_buffer."""
    output_buffer_buffer: POINTER(c_uint8) = cast(
        create_string_buffer(output_buffer_byte_count * sizeof(c_uint8)), POINTER(c_uint8)
    )

    c_xor_decrypt(
        output_buffer_buffer,
        cast(input_buffer, POINTER(c_uint8)),
        c_uint32(buffer_size),
        c_uint64(key),
        c_uint8(key_size),
        c_int64(key_increment),
        c_bool(ignore_zero),
    )

    output_buffer: bytes = string_at(output_buffer_buffer, output_buffer_byte_count)
    return output_buffer


c_xor_find = c_lib.xor_find
c_xor_find.argtypes = [
    POINTER(ComplexCrypt),  # results
    c_uint32,  # result_count_max
    POINTER(c_uint32),  # result_count
    POINTER(c_uint8),  # buffer
    c_uint32,  # buffer_size
    POINTER(c_uint8),  # pattern
    c_uint32,  # pattern_size
    c_uint32,  # pattern_offset
]
c_xor_find.restype = None


def xor_find(
    results_element_count: int,
    result_count_max: int,
    buffer: bytes,
    buffer_size: int,
    pattern: bytes,
    pattern_size: int,
    pattern_offset: int,
) -> tuple[list[ComplexCrypt], int]:
    """Returns results, result_count."""
    results_buffer: POINTER(ComplexCrypt) = cast(
        create_string_buffer(results_element_count * sizeof(ComplexCrypt)), POINTER(ComplexCrypt)
    )
    result_count_indirect: POINTER(c_uint32) = pointer(c_uint32(0))

    c_xor_find(
        results_buffer,
        c_uint32(result_count_max),
        result_count_indirect,
        cast(buffer, POINTER(c_uint8)),
        c_uint32(buffer_size),
        cast(pattern, POINTER(c_uint8)),
        c_uint32(pattern_size),
        c_uint32(pattern_offset),
    )

    results: list[ComplexCrypt] = [results_buffer[i] for i in range(results_element_count)]
    result_count: int = result_count_indirect.contents.value
    return results, result_count


c_add_decrypt = c_lib.add_decrypt
c_add_decrypt.argtypes = [
    POINTER(c_uint8),  # output_buffer
    POINTER(c_uint8),  # input_buffer
    c_uint32,  # buffer_size
    c_uint8,  # key
]
c_add_decrypt.restype = None


def add_decrypt(
    output_buffer_byte_count: int,
    input_buffer: bytes,
    buffer_size: int,
    key: int,
) -> bytes:
    """Returns output_buffer."""
    output_buffer_buffer: POINTER(c_uint8) = cast(
        create_string_buffer(output_buffer_byte_count * sizeof(c_uint8)), POINTER(c_uint8)
    )

    c_add_decrypt(
        output_buffer_buffer,
        cast(input_buffer, POINTER(c_uint8)),
        c_uint32(buffer_size),
        c_uint8(key),
    )

    output_buffer: bytes = string_at(output_buffer_buffer, output_buffer_byte_count)
    return output_buffer


c_add_find = c_lib.add_find
c_add_find.argtypes = [
    POINTER(BasicCrypt),  # results
    c_uint32,  # result_count_max
    POINTER(c_uint32),  # result_count
    POINTER(c_uint8),  # buffer
    c_uint32,  # buffer_size
    POINTER(c_uint8),  # pattern
    c_uint32,  # pattern_size
    c_uint32,  # pattern_offset
]
c_add_find.restype = None


def add_find(
    results_element_count: int,
    result_count_max: int,
    buffer: bytes,
    buffer_size: int,
    pattern: bytes,
    pattern_size: int,
    pattern_offset: int,
) -> tuple[list[BasicCrypt], int]:
    """Returns results, result_count."""
    results_buffer: POINTER(BasicCrypt) = cast(
        create_string_buffer(results_element_count * sizeof(BasicCrypt)), POINTER(BasicCrypt)
    )
    result_count_indirect: POINTER(c_uint32) = pointer(c_uint32(0))

    c_add_find(
        results_buffer,
        c_uint32(result_count_max),
        result_count_indirect,
        cast(buffer, POINTER(c_uint8)),
        c_uint32(buffer_size),
        cast(pattern, POINTER(c_uint8)),
        c_uint32(pattern_size),
        c_uint32(pattern_offset),
    )

    results: list[BasicCrypt] = [results_buffer[i] for i in range(results_element_count)]
    result_count: int = result_count_indirect.contents.value
    return results, result_count


c_rol_decrypt = c_lib.rol_decrypt
c_rol_decrypt.argtypes = [
    POINTER(c_uint8),  # output_buffer
    POINTER(c_uint8),  # input_buffer
    c_uint32,  # buffer_size
    c_uint8,  # key
]
c_rol_decrypt.restype = None


def rol_decrypt(
    output_buffer_byte_count: int,
    input_buffer: bytes,
    buffer_size: int,
    key: int,
) -> bytes:
    """Returns output_buffer."""
    output_buffer_buffer: POINTER(c_uint8) = cast(
        create_string_buffer(output_buffer_byte_count * sizeof(c_uint8)), POINTER(c_uint8)
    )

    c_rol_decrypt(
        output_buffer_buffer,
        cast(input_buffer, POINTER(c_uint8)),
        c_uint32(buffer_size),
        c_uint8(key),
    )

    output_buffer: bytes = string_at(output_buffer_buffer, output_buffer_byte_count)
    return output_buffer


c_rol_find = c_lib.rol_find
c_rol_find.argtypes = [
    POINTER(BasicCrypt),  # results
    c_uint32,  # result_count_max
    POINTER(c_uint32),  # result_count
    POINTER(c_uint8),  # buffer
    c_uint32,  # buffer_size
    POINTER(c_uint8),  # pattern
    c_uint32,  # pattern_size
    c_uint32,  # pattern_offset
]
c_rol_find.restype = None


def rol_find(
    results_element_count: int,
    result_count_max: int,
    buffer: bytes,
    buffer_size: int,
    pattern: bytes,
    pattern_size: int,
    pattern_offset: int,
) -> tuple[list[BasicCrypt], int]:
    """Returns results, result_count."""
    results_buffer: POINTER(BasicCrypt) = cast(
        create_string_buffer(results_element_count * sizeof(BasicCrypt)), POINTER(BasicCrypt)
    )
    result_count_indirect: POINTER(c_uint32) = pointer(c_uint32(0))

    c_rol_find(
        results_buffer,
        c_uint32(result_count_max),
        result_count_indirect,
        cast(buffer, POINTER(c_uint8)),
        c_uint32(buffer_size),
        cast(pattern, POINTER(c_uint8)),
        c_uint32(pattern_size),
        c_uint32(pattern_offset),
    )

    results: list[BasicCrypt] = [results_buffer[i] for i in range(results_element_count)]
    result_count: int = result_count_indirect.contents.value
    return results, result_count
