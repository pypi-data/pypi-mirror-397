from __future__ import annotations

import copy
import os
import time
from dataclasses import dataclass
from typing import TYPE_CHECKING

from bittensor import Subtensor
from bittensor.core.metagraph import Metagraph

from bt_ddos_shield.blockchain_manager import (
    AbstractBlockchainManager,
    BittensorBlockchainManager,
    BlockchainManagerException,
)
from bt_ddos_shield.certificate_manager import (
    Certificate,
    EDDSACertificateManager,
    PublicKey,
)
from bt_ddos_shield.encryption_manager import (
    AbstractEncryptionManager,
    ECIESEncryptionManager,
)
from bt_ddos_shield.event_processor import AbstractMinerShieldEventProcessor, PrintingMinerShieldEventProcessor
from bt_ddos_shield.manifest_manager import (
    JsonManifestSerializer,
    Manifest,
    ManifestDeserializationException,
    ReadOnlyManifestManager,
)
from bt_ddos_shield.utils import extract_commitment_url, run_async_in_thread

if TYPE_CHECKING:
    import bittensor
    import bittensor_wallet

    from bt_ddos_shield.utils import Hotkey


@dataclass
class ShieldMetagraphOptions:
    replace_ip_address_for_axon: bool = True
    """
    Determines how shield address is added to axon info in metagraph. If True, shield address will replace original one
    in `ip` field, otherwise new field `shield_address` will be added. In both cases, port will be replaced with port
    from shield.
    """

    certificate_path: str | None = None
    """
    Path to file where certificate is stored. If file does not exist, new certificate will be generated and saved to
    this file. If file exists, certificate will be loaded from it. If this path is not set, it will be loaded from
    environment variable VALIDATOR_SHIELD_CERTIFICATE_PATH. If both are not set, default path './validator_cert.pem'
    will be used.
    """

    disable_uploading_certificate: bool = False
    """
    Special option for testing purposes. If True, certificate will not be uploaded to blockchain in ShieldMetagraph
    constructor.
    """


class ShieldMetagraph(Metagraph):
    """
    Wrapper class for Metagraph. It allows Validator to retrieve addresses generated by MinerShield instead of Miners
    addresses presented in original metagraph. If given Miner is not shielded, it will return their original address.

    To use this class in your code just replace your Metagraph instance with ShieldMetagraph instance. If you were
    using subtensor.metagraph() before, you should now use constructor with sync param set to True and other params
    set appropriately.
    """

    wallet: bittensor_wallet.Wallet
    """ Validator's wallet. """
    certificate: Certificate
    """ Certificate used for encryption of addresses generated for Validator by Miners. """
    event_processor: AbstractMinerShieldEventProcessor
    encryption_manager: AbstractEncryptionManager
    certificate_manager: EDDSACertificateManager
    blockchain_manager: AbstractBlockchainManager
    manifest_manager: ReadOnlyManifestManager
    options: ShieldMetagraphOptions

    def __init__(
        self,
        wallet: bittensor_wallet.Wallet,
        netuid: int,
        network: str | None = None,
        lite: bool = True,
        sync: bool = True,
        block: int | None = None,
        subtensor: bittensor.Subtensor | None = None,
        event_processor: AbstractMinerShieldEventProcessor | None = None,
        encryption_manager: AbstractEncryptionManager | None = None,
        certificate_manager: EDDSACertificateManager | None = None,
        blockchain_manager: AbstractBlockchainManager | None = None,
        manifest_manager: ReadOnlyManifestManager | None = None,
        options: ShieldMetagraphOptions | None = None,
    ):
        if subtensor is None:
            subtensor = Subtensor(network=network)
        super().__init__(
            netuid=netuid,
            lite=lite,
            sync=False,
            subtensor=subtensor,
            **({'network': network} if network is not None else {}),
        )

        self.wallet = wallet
        self.options = options or ShieldMetagraphOptions()
        self.event_processor = event_processor or PrintingMinerShieldEventProcessor()
        self.encryption_manager = encryption_manager or self.create_default_encryption_manager()
        self.certificate_manager = certificate_manager or self.create_default_certificate_manager()
        self.blockchain_manager = blockchain_manager or self.create_default_blockchain_manager(
            self.subtensor, netuid, wallet, self.event_processor
        )
        self.manifest_manager = manifest_manager or self.create_default_manifest_manager(
            self.event_processor, self.encryption_manager
        )

        self._init_certificate()

        if sync:
            self.sync(block=block, lite=lite, subtensor=self.subtensor)
        elif block is not None:
            raise ValueError('Block argument is valid only when sync is True')

    def _init_certificate(self) -> None:
        certificate_path: str = self.options.certificate_path or os.getenv(
            'VALIDATOR_SHIELD_CERTIFICATE_PATH', './validator_cert.pem'
        )
        try:
            self.certificate = self.certificate_manager.load_certificate(certificate_path)
            public_key: PublicKey | None = self.blockchain_manager.get_own_public_key()
            if self.certificate.public_key == public_key:
                return
        except FileNotFoundError:
            self.certificate = self.certificate_manager.generate_certificate()
            self.certificate_manager.save_certificate(self.certificate, certificate_path)

        if not self.options.disable_uploading_certificate:
            try:
                self.blockchain_manager.upload_public_key(self.certificate.public_key, self.certificate.algorithm)
            except BlockchainManagerException:
                # Retry once
                time.sleep(3)
                self.blockchain_manager.upload_public_key(self.certificate.public_key, self.certificate.algorithm)

    def __deepcopy__(self, memo):
        cls = self.__class__
        new_instance = cls.__new__(cls)
        memo[id(self)] = new_instance

        ignored_fields = {
            # Ignored also in Metagraph.__deepcopy__:
            'subtensor',
            # Ignored in this class:
            'wallet',
            'certificate',
            'event_processor',
            'encryption_manager',
            'certificate_manager',
            'blockchain_manager',
            'manifest_manager',
        }

        for key, value in self.__dict__.items():
            if key in ignored_fields:
                setattr(new_instance, key, None)  # Set fields to None to be compatible with Metagraph.__deepcopy__
            else:
                setattr(new_instance, key, copy.deepcopy(value, memo))

        return new_instance

    @classmethod
    def create_default_encryption_manager(cls):
        return ECIESEncryptionManager()

    @classmethod
    def create_default_certificate_manager(cls):
        return EDDSACertificateManager()

    @classmethod
    def create_default_manifest_manager(
        cls,
        event_processor: AbstractMinerShieldEventProcessor,
        encryption_manager: AbstractEncryptionManager,
    ) -> ReadOnlyManifestManager:
        return ReadOnlyManifestManager(JsonManifestSerializer(), encryption_manager, event_processor)

    @classmethod
    def create_default_blockchain_manager(
        cls,
        subtensor: bittensor.Subtensor,
        netuid: int,
        wallet: bittensor_wallet.Wallet,
        event_processor: AbstractMinerShieldEventProcessor,
    ) -> AbstractBlockchainManager:
        return BittensorBlockchainManager(
            subtensor=subtensor,
            netuid=netuid,
            wallet=wallet,
            event_processor=event_processor,
        )

    def sync(self, block: int | None = None, lite: bool | None = None, subtensor: bittensor.Subtensor | None = None):
        super().sync(block=block, lite=lite, subtensor=subtensor)
        hotkeys: list[str] = self.hotkeys

        # Use run_async_in_thread hack, because this function can be called from inside currently running event loop
        raw_commitments: dict[Hotkey, str | None] = run_async_in_thread(
            self.blockchain_manager.get_manifest_urls(hotkeys)
        )
        manifest_urls: dict[Hotkey, str | None] = {}
        for hotkey in hotkeys:
            commitment_value: str | None = raw_commitments.get(hotkey)
            url, _, _ = extract_commitment_url(commitment_value)
            manifest_urls[hotkey] = url
        manifests: dict[Hotkey, Manifest | None] = run_async_in_thread(
            self.manifest_manager.get_manifests(manifest_urls)
        )

        own_hotkey: Hotkey = self.wallet.hotkey.ss58_address
        for axon in self.axons:
            manifest: Manifest | None = manifests.get(axon.hotkey)
            if manifest is not None:
                try:
                    shield_address: tuple[str, int] | None = self.manifest_manager.get_address_for_validator(
                        manifest, own_hotkey, self.certificate.private_key
                    )
                except ManifestDeserializationException as e:
                    self.event_processor.event(
                        'Error while getting shield address for miner {hotkey}', exception=e, hotkey=axon.hotkey
                    )
                    continue
                if shield_address is not None:
                    if self.options.replace_ip_address_for_axon:
                        axon.ip = shield_address[0]
                    else:
                        axon.shield_address = shield_address[0]
                    axon.port = shield_address[1]
