# This file was generated by Nuitka

# Stubs included by default
from __future__ import annotations
from collections.abc import Callable
from honeio.layers._sag9hjwy3tes0o8 import govii3izp3e69nagd0
from honeio.layers.dropout import DropoutLayer
from honeio.layers.general import PytorchGeneralHSM
from honeio.layers.weighted import WeightedLayer
from sklearn.base import BaseEstimator, ClassifierMixin, RegressorMixin
from sklearn.preprocessing import StandardScaler
from torch.utils.data import DataLoader, TensorDataset
from tqdm import tqdm
from typing import Self, TypedDict, Unpack
from typing_extensions import TypeAlias
from dataclasses import dataclass
import numpy
import torch

def _init_weighted_layer() -> WeightedLayer:
    ...

class ModelParameters(TypedDict):
    hilbert_space_dim: int
    epochs: int
    random_state: int
    lr: float
    weights_lr: float
    loss: str
    device: str
    batch_size: int | None
    groups: list[list[int]] | None
    dropout_rate: float
    verbose: int
    input_operator_count: int
    output_operator_count: int
    classes_: list

class SaveModelKwargs(TypedDict):
    scaler: StandardScaler
    weighted_layer_state_dict: dict
    model_parameters: ModelParameters

SaveModelFn: TypeAlias = Callable[[Unpack[SaveModelKwargs]], None]
LoadStatesFn: TypeAlias = Callable[[], tuple[StandardScaler, dict, ModelParameters]]
@dataclass
class QCMLBase(BaseEstimator):
    def _train_loop(self: Self, X: np.ndarray, y: np.ndarray, batch_size_override: list[int] | None) -> Self: ...
    def _fit_no_batch(self: Self, X: np.ndarray, y: np.ndarray) -> None: ...
    def _fit_batch(self: Self, X: np.ndarray, y: np.ndarray, batch_size_override: list[int] | None, use_dataloader: bool) -> None: ...
    def weight_feature_importances_(self: Self) -> np.ndarray: ...
    def grad_feature_importances_(self: Self) -> np.ndarray: ...
    def check_is_fitted(self: Self) -> None: ...

@dataclass
class QCMLRegressor(RegressorMixin, QCMLBase):
    def __init__(self: Self) -> None: ...
    def _fit_transform_targets(self: Self, y: np.ndarray) -> np.ndarray: ...
    def _fit(self: Self, X: np.ndarray, y: np.ndarray, batch_size_override: list[int] | None) -> Self: ...
    def fit(self: Self, X: np.ndarray, y: np.ndarray, batch_size_override: list[int] | None) -> 'QCMLRegressor': ...
    def predict(self: Self, X: np.ndarray) -> np.ndarray: ...
    def save(self: Self) -> None: ...
    @classmethod
    def load(cls, load_states_fn: LoadStatesFn) -> Self: ...

@dataclass
class QCMLClassifier(ClassifierMixin, QCMLBase):
    def __init__(self: Self) -> None: ...
    def _fit(self: Self, X: np.ndarray, y: np.ndarray, classes: list | None, batch_size_override: list[int] | None) -> Self: ...
    def fit(self: Self, X: np.ndarray, y: np.ndarray, classes: list | None, batch_size_override: list[int] | None) -> 'QCMLClassifier': ...
    def predict_proba(self: Self, X: np.ndarray) -> np.ndarray: ...
    def predict(self: Self, X: np.ndarray) -> np.ndarray: ...
    def save(self: Self) -> None: ...
    @classmethod
    def load(cls, load_states_fn: LoadStatesFn) -> Self: ...


__name__ = ...



# Modules used internally, to allow implicit dependencies to be seen:
import collections
import collections.abc
import typing
import numpy
import torch
import honeio
import honeio.layers
import honeio.layers._sag9hjwy3tes0o8
import honeio.layers.dropout
import honeio.layers.general
import honeio.layers.weighted
import sklearn
import sklearn.base
import sklearn.preprocessing
import torch.utils
import torch.utils.data
import tqdm