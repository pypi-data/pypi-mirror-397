# File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

from __future__ import annotations

from typing import Dict, Union, Iterable
from typing_extensions import Literal, Required, Annotated, TypedDict

from ..._types import Base64FileInput
from ..._utils import PropertyInfo
from ..._models import set_pydantic_config

__all__ = [
    "ContentParam",
    "Part",
    "PartCodeExecutionResult",
    "PartExecutableCode",
    "PartFileData",
    "PartFunctionCall",
    "PartFunctionResponse",
    "PartFunctionResponsePart",
    "PartFunctionResponsePartInlineData",
    "PartInlineData",
    "PartVideoMetadata",
]


class PartCodeExecutionResult(TypedDict, total=False):
    """Result of executing the `ExecutableCode`.

    Only generated when using the `CodeExecution`, and always follows a `part`
    containing the `ExecutableCode`.
    """

    outcome: Required[Literal["OUTCOME_UNSPECIFIED", "OUTCOME_OK", "OUTCOME_FAILED", "OUTCOME_DEADLINE_EXCEEDED"]]
    """Required. Outcome of the code execution."""

    output: str
    """Optional.

    Contains stdout when code execution is successful, stderr or other description
    otherwise.
    """


class PartExecutableCode(TypedDict, total=False):
    """
    Code generated by the model that is meant to be executed, and the result
    returned to the model.

    Only generated when using the `CodeExecution` tool, in which the code will
    be automatically executed, and a corresponding `CodeExecutionResult` will
    also be generated.
    """

    code: Required[str]
    """Required. The code to be executed."""

    language: Required[Literal["LANGUAGE_UNSPECIFIED", "PYTHON"]]
    """Required. Programming language of the `code`."""


class PartFileData(TypedDict, total=False):
    """URI based data."""

    file_uri: Required[Annotated[str, PropertyInfo(alias="fileUri")]]
    """Required. URI."""

    mime_type: Annotated[str, PropertyInfo(alias="mimeType")]
    """Optional. The IANA standard MIME type of the source data."""


class PartFunctionCall(TypedDict, total=False):
    """
    A predicted `FunctionCall` returned from the model that contains
    a string representing the `FunctionDeclaration.name` with the
    arguments and their values.
    """

    name: Required[str]
    """Required.

    The name of the function to call. Must be a-z, A-Z, 0-9, or contain underscores
    and dashes, with a maximum length of 64.
    """

    id: str
    """Optional.

    The unique id of the function call. If populated, the client to execute the
    `function_call` and return the response with the matching `id`.
    """

    args: Dict[str, object]
    """Optional. The function parameters and values in JSON object format."""


class PartFunctionResponsePartInlineData(TypedDict, total=False):
    """Raw media bytes for function response.

    Text should not be sent as raw bytes, use the 'FunctionResponse.response'
    field.
    """

    data: Annotated[Union[str, Base64FileInput], PropertyInfo(format="base64")]
    """Raw bytes for media formats."""

    mime_type: Annotated[str, PropertyInfo(alias="mimeType")]
    """The IANA standard MIME type of the source data. Examples:

    - image/png
    - image/jpeg If an unsupported MIME type is provided, an error will be returned.
      For a complete list of supported types, see
      [Supported file formats](https://ai.google.dev/gemini-api/docs/prompting_with_media#supported_file_formats).
    """


set_pydantic_config(PartFunctionResponsePartInlineData, {"arbitrary_types_allowed": True})


class PartFunctionResponsePart(TypedDict, total=False):
    """A datatype containing media that is part of a `FunctionResponse` message.

    A `FunctionResponsePart` consists of data which has an associated datatype. A
    `FunctionResponsePart` can only contain one of the accepted types in
    `FunctionResponsePart.data`.

    A `FunctionResponsePart` must have a fixed IANA MIME type identifying the
    type and subtype of the media if the `inline_data` field is filled with raw
    bytes.
    """

    inline_data: Annotated[PartFunctionResponsePartInlineData, PropertyInfo(alias="inlineData")]
    """Raw media bytes for function response.

    Text should not be sent as raw bytes, use the 'FunctionResponse.response' field.
    """


class PartFunctionResponse(TypedDict, total=False):
    """
    The result output from a `FunctionCall` that contains a string
    representing the `FunctionDeclaration.name` and a structured JSON
    object containing any output from the function is used as context to
    the model. This should contain the result of a`FunctionCall` made
    based on model prediction.
    """

    name: Required[str]
    """Required.

    The name of the function to call. Must be a-z, A-Z, 0-9, or contain underscores
    and dashes, with a maximum length of 64.
    """

    response: Required[Dict[str, object]]
    """Required.

    The function response in JSON object format. Callers can use any keys of their
    choice that fit the function's syntax to return the function output, e.g.
    "output", "result", etc. In particular, if the function call failed to execute,
    the response can have an "error" key to return error details to the model.
    """

    id: str
    """Optional.

    The id of the function call this response is for. Populated by the client to
    match the corresponding function call `id`.
    """

    parts: Iterable[PartFunctionResponsePart]
    """Optional.

    Ordered `Parts` that constitute a function response. Parts may have different
    IANA MIME types.
    """

    scheduling: Literal["SCHEDULING_UNSPECIFIED", "SILENT", "WHEN_IDLE", "INTERRUPT"]
    """Optional.

    Specifies how the response should be scheduled in the conversation. Only
    applicable to NON_BLOCKING function calls, is ignored otherwise. Defaults to
    WHEN_IDLE.
    """

    will_continue: Annotated[bool, PropertyInfo(alias="willContinue")]
    """Optional.

    Signals that function call continues, and more responses will be returned,
    turning the function call into a generator. Is only applicable to NON_BLOCKING
    function calls, is ignored otherwise. If set to false, future responses will not
    be considered. It is allowed to return empty `response` with
    `will_continue=False` to signal that the function call is finished. This may
    still trigger the model generation. To avoid triggering the generation and
    finish the function call, additionally set `scheduling` to `SILENT`.
    """


class PartInlineData(TypedDict, total=False):
    """Raw media bytes.

    Text should not be sent as raw bytes, use the 'text' field.
    """

    data: Annotated[Union[str, Base64FileInput], PropertyInfo(format="base64")]
    """Raw bytes for media formats."""

    mime_type: Annotated[str, PropertyInfo(alias="mimeType")]
    """The IANA standard MIME type of the source data. Examples:

    - image/png
    - image/jpeg If an unsupported MIME type is provided, an error will be returned.
      For a complete list of supported types, see
      [Supported file formats](https://ai.google.dev/gemini-api/docs/prompting_with_media#supported_file_formats).
    """


set_pydantic_config(PartInlineData, {"arbitrary_types_allowed": True})


class PartVideoMetadata(TypedDict, total=False):
    """Metadata describes the input video content."""

    end_offset: Annotated[str, PropertyInfo(alias="endOffset")]
    """Optional. The end offset of the video."""

    fps: float
    """Optional.

    The frame rate of the video sent to the model. If not specified, the default
    value will be 1.0. The fps range is (0.0, 24.0].
    """

    start_offset: Annotated[str, PropertyInfo(alias="startOffset")]
    """Optional. The start offset of the video."""


class Part(TypedDict, total=False):
    """A datatype containing media that is part of a multi-part `Content` message.

    A `Part` consists of data which has an associated datatype. A `Part` can only
    contain one of the accepted types in `Part.data`.

    A `Part` must have a fixed IANA MIME type identifying the type and subtype
    of the media if the `inline_data` field is filled with raw bytes.
    """

    code_execution_result: Annotated[PartCodeExecutionResult, PropertyInfo(alias="codeExecutionResult")]
    """Result of executing the `ExecutableCode`.

    Only generated when using the `CodeExecution`, and always follows a `part`
    containing the `ExecutableCode`.
    """

    executable_code: Annotated[PartExecutableCode, PropertyInfo(alias="executableCode")]
    """
    Code generated by the model that is meant to be executed, and the result
    returned to the model.

    Only generated when using the `CodeExecution` tool, in which the code will be
    automatically executed, and a corresponding `CodeExecutionResult` will also be
    generated.
    """

    file_data: Annotated[PartFileData, PropertyInfo(alias="fileData")]
    """URI based data."""

    function_call: Annotated[PartFunctionCall, PropertyInfo(alias="functionCall")]
    """
    A predicted `FunctionCall` returned from the model that contains a string
    representing the `FunctionDeclaration.name` with the arguments and their values.
    """

    function_response: Annotated[PartFunctionResponse, PropertyInfo(alias="functionResponse")]
    """
    The result output from a `FunctionCall` that contains a string representing the
    `FunctionDeclaration.name` and a structured JSON object containing any output
    from the function is used as context to the model. This should contain the
    result of a`FunctionCall` made based on model prediction.
    """

    inline_data: Annotated[PartInlineData, PropertyInfo(alias="inlineData")]
    """Raw media bytes.

    Text should not be sent as raw bytes, use the 'text' field.
    """

    part_metadata: Annotated[Dict[str, object], PropertyInfo(alias="partMetadata")]
    """
    Custom metadata associated with the Part. Agents using genai.Part as content
    representation may need to keep track of the additional information. For example
    it can be name of a file/source from which the Part originates or a way to
    multiplex multiple Part streams.
    """

    text: str
    """Inline text."""

    thought: bool
    """Optional. Indicates if the part is thought from the model."""

    thought_signature: Annotated[Union[str, Base64FileInput], PropertyInfo(alias="thoughtSignature", format="base64")]
    """Optional.

    An opaque signature for the thought so it can be reused in subsequent requests.
    """

    video_metadata: Annotated[PartVideoMetadata, PropertyInfo(alias="videoMetadata")]
    """Metadata describes the input video content."""


set_pydantic_config(Part, {"arbitrary_types_allowed": True})


class ContentParam(TypedDict, total=False):
    """The base structured datatype containing multi-part content of a message.

    A `Content` includes a `role` field designating the producer of the `Content`
    and a `parts` field containing multi-part data that contains the content of
    the message turn.
    """

    parts: Iterable[Part]
    """Ordered `Parts` that constitute a single message.

    Parts may have different MIME types.
    """

    role: str
    """Optional. The producer of the content. Must be either 'user' or 'model'.

    Useful to set for multi-turn conversations, otherwise can be left blank or
    unset.
    """
