## Yaml pipeline configuration

---
# A really basic pipeline configuration
pipeline_config:

  # Configuration for the data loader
  # Pour Domain Gap, on utilise PLUSIEURS dataloaders
  # Le gap sera calculé entre source et target
  dataloaders:
    source_dataset:
      type: parquet
      path: packages/dqm-ml-pipeline/tests/data/source_500.parquet
      batch_size: 50
      memory_limit: 2GB
      threads: 4

    target_dataset:
      type: parquet
      path: packages/dqm-ml-pipeline/tests/data/target_500.parquet
      batch_size: 50
      memory_limit: 2GB
      threads: 4

  metrics_processor:
    # Pour le domain gap, on peut utiliser les embeddings d'abord à part
    image_embedding:
      type: image_embedding
      DATA: # ou input column
        image_column: image_path  # ou file_path
        mode: path               # ou path
      model_config: # voir aussi si on peut extraitere plusieurs embeddings
        arch: resnet18
        n_layer_feature: -2  # couche d'extraction
        device: cpu               # ou cuda
      infer:
        batch_size: 18
        height: 299
        width: 299
        norm_mean: [0.485, 0.456,0.406]
        norm_std: [0.229,0.224,0.225]

    # Étape 2: Calculer domain gap depuis embeddings
    domain_gap:
      type: domain_gap
      INPUT:
        embedding_col: embedding
      DELTA:
        metric: wasserstein_1d  # klmvn_diag|mmd_linear|fid|wasserstein_1d
      # SUMMARY: auto-configuré selon la métrique !
      # fid → collect_sum_outer: true
      # wasserstein_1d → collect_hist_1d: true
      # klmvn_diag/mmd_linear → minimal

  compute_delta: True

  outputs :

    metrics:
      type: parquet
      path_pattern: packages/dqm-ml-pipeline/tests/output/metrics_domain_gap_wasserstein_{}-{}.parquet
      columns: [domain_gap_results]