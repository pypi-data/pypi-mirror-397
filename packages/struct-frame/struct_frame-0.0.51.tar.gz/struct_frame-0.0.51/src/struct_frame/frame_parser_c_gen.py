#!/usr/bin/env python3
# kate: replace-tabs on; indent-width 4;

"""
C Frame Parser Generator

Generates C code for frame parsers based on frame format definitions.
"""

from struct_frame import version
import time


def camel_to_snake(name):
    """Convert CamelCase to snake_case"""
    import re
    name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', name)
    return name.lower()


def camel_to_upper_snake(name):
    """Convert CamelCase to UPPER_SNAKE_CASE"""
    return camel_to_snake(name).upper()


class FrameParserCGen:
    """Generates C code for frame parsers"""

    @staticmethod
    def generate_base(formats):
        """Generate the base C header file with common utilities"""
        yield '/* Automatically generated frame parser base utilities */\n'
        yield '/* Generated by %s at %s. */\n\n' % (version, time.asctime())
        yield '#pragma once\n\n'
        yield '#include <stdbool.h>\n'
        yield '#include <stddef.h>\n'
        yield '#include <stdint.h>\n'
        yield '#include <string.h>\n\n'

        # Generate frame format enum
        yield '/* Frame format type enumeration */\n'
        yield 'typedef enum FrameFormatType {\n'
        for i, fmt in enumerate(formats):
            enum_name = camel_to_upper_snake(fmt.name)
            yield f'    FRAME_FORMAT_{enum_name} = {i},\n'
        yield '} FrameFormatType;\n\n'

        # Generate checksum function
        yield '/*===========================================================================\n'
        yield ' * Checksum Calculation\n'
        yield ' *===========================================================================*/\n\n'
        yield '''typedef struct frame_checksum {
    uint8_t byte1;
    uint8_t byte2;
} frame_checksum_t;

/**
 * Calculate Fletcher-16 checksum over the given data
 */
static inline frame_checksum_t frame_fletcher_checksum(const uint8_t* data, size_t length) {
    frame_checksum_t ck = {0, 0};
    for (size_t i = 0; i < length; i++) {
        ck.byte1 = (uint8_t)(ck.byte1 + data[i]);
        ck.byte2 = (uint8_t)(ck.byte2 + ck.byte1);
    }
    return ck;
}

'''

        # Generate common result type
        yield '''/* Parse result */
typedef struct frame_msg_info {
    bool valid;
    uint8_t msg_id;
    size_t msg_len;
    uint8_t* msg_data;
} frame_msg_info_t;

/*===========================================================================
 * Shared Payload Parsing Functions
 *===========================================================================
 * These functions handle payload validation/encoding independent of framing.
 * Frame formats (Tiny/Basic) use these for the common parsing logic.
 */

/**
 * Validate a payload with CRC (shared by Default, Extended, etc. payload types).
 * 
 * @param buffer Complete packet buffer (including any start bytes)
 * @param length Total buffer length
 * @param header_size Size of header (start_bytes + length + msg_id + extra fields)
 * @param length_bytes Number of length bytes (1 or 2)
 * @param crc_start_offset Offset from start of buffer where CRC calculation begins
 * @return frame_msg_info_t with valid=true if checksum matches
 */
static inline frame_msg_info_t frame_validate_payload_with_crc(
    const uint8_t* buffer, size_t length,
    size_t header_size, size_t length_bytes, size_t crc_start_offset) {
    
    frame_msg_info_t result = {false, 0, 0, NULL};
    const size_t footer_size = 2; /* CRC is always 2 bytes */
    const size_t overhead = header_size + footer_size;
    
    if (length < overhead) {
        return result;
    }
    
    size_t msg_length = length - overhead;
    
    /* Calculate expected CRC range: from crc_start_offset to before the CRC bytes */
    size_t crc_data_len = msg_length + 1 + length_bytes; /* msg_id (1) + length_bytes + payload */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + crc_start_offset, crc_data_len);
    
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[header_size - 1]; /* msg_id is last byte of header */
        result.msg_len = msg_length;
        result.msg_data = (uint8_t*)(buffer + header_size);
    }
    
    return result;
}

/**
 * Validate a minimal payload (no CRC, no length field).
 * 
 * @param buffer Complete packet buffer (including any start bytes)
 * @param length Total buffer length
 * @param header_size Size of header (start_bytes + msg_id)
 * @return frame_msg_info_t with packet data
 */
static inline frame_msg_info_t frame_validate_payload_minimal(
    const uint8_t* buffer, size_t length, size_t header_size) {
    
    frame_msg_info_t result = {false, 0, 0, NULL};
    
    if (length < header_size) {
        return result;
    }
    
    result.valid = true;
    result.msg_id = buffer[header_size - 1]; /* msg_id is last byte of header */
    result.msg_len = length - header_size;
    result.msg_data = (uint8_t*)(buffer + header_size);
    
    return result;
}

/**
 * Encode payload with length and CRC into output buffer.
 * 
 * @param output Output buffer to write to (after start bytes)
 * @param msg_id Message ID
 * @param msg Message payload data
 * @param msg_size Size of message payload
 * @param length_bytes Number of length bytes (1 or 2)
 * @param crc_start Pointer to start of CRC calculation (typically after start bytes)
 * @return Number of bytes written (length + msg_id + payload + CRC)
 */
static inline size_t frame_encode_payload_with_crc(
    uint8_t* output, uint8_t msg_id, const uint8_t* msg, size_t msg_size,
    size_t length_bytes, const uint8_t* crc_start) {
    
    size_t idx = 0;
    
    /* Add length field */
    if (length_bytes == 1) {
        output[idx++] = (uint8_t)(msg_size & 0xFF);
    } else {
        output[idx++] = (uint8_t)(msg_size & 0xFF);
        output[idx++] = (uint8_t)((msg_size >> 8) & 0xFF);
    }
    
    /* Add msg_id */
    output[idx++] = msg_id;
    
    /* Add payload */
    if (msg_size > 0 && msg != NULL) {
        memcpy(output + idx, msg, msg_size);
        idx += msg_size;
    }
    
    /* Calculate and add CRC */
    size_t crc_data_len = msg_size + 1 + length_bytes;
    frame_checksum_t ck = frame_fletcher_checksum(crc_start, crc_data_len);
    output[idx++] = ck.byte1;
    output[idx++] = ck.byte2;
    
    return idx;
}

/**
 * Encode minimal payload (no length, no CRC) into output buffer.
 * 
 * @param output Output buffer to write to (after start bytes)
 * @param msg_id Message ID
 * @param msg Message payload data
 * @param msg_size Size of message payload
 * @return Number of bytes written (msg_id + payload)
 */
static inline size_t frame_encode_payload_minimal(
    uint8_t* output, uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    
    size_t idx = 0;
    
    /* Add msg_id */
    output[idx++] = msg_id;
    
    /* Add payload */
    if (msg_size > 0 && msg != NULL) {
        memcpy(output + idx, msg, msg_size);
        idx += msg_size;
    }
    
    return idx;
}
'''

    @staticmethod
    def generate_format_file(fmt):
        """Generate a C header file for a single frame format"""
        prefix = camel_to_snake(fmt.name)
        PREFIX = camel_to_upper_snake(fmt.name)

        yield '/* Automatically generated frame parser */\n'
        yield '/* Generated by %s at %s. */\n\n' % (version, time.asctime())
        yield '#pragma once\n\n'
        yield '#include "frame_base.h"\n\n'

        yield from FrameParserCGen.generate_format(fmt)

    @staticmethod
    def generate_main_header(formats):
        """Generate main header that includes all frame format headers"""
        yield '/* Automatically generated frame parser main header */\n'
        yield '/* Generated by %s at %s. */\n\n' % (version, time.asctime())
        yield '#pragma once\n\n'
        yield '/* Base utilities */\n'
        yield '#include "frame_base.h"\n\n'
        yield '/* Individual frame format parsers */\n'
        for fmt in formats:
            snake_name = camel_to_snake(fmt.name)
            yield f'#include "{snake_name}.h"\n'

    @staticmethod
    def generate_header(formats):
        """Generate the complete frame parser header file (single file, legacy mode)"""
        yield '/* Automatically generated frame parser header */\n'
        yield '/* Generated by %s at %s. */\n\n' % (version, time.asctime())
        yield '#pragma once\n\n'
        yield '#include <stdbool.h>\n'
        yield '#include <stddef.h>\n'
        yield '#include <stdint.h>\n'
        yield '#include <string.h>\n\n'
        
        # Generate frame format enum
        yield '/* Frame format type enumeration */\n'
        yield 'typedef enum FrameFormatType {\n'
        for i, fmt in enumerate(formats):
            enum_name = camel_to_upper_snake(fmt.name)
            yield f'    FRAME_FORMAT_{enum_name} = {i},\n'
        yield '} FrameFormatType;\n\n'
        
        # Generate checksum function
        yield '/*===========================================================================\n'
        yield ' * Checksum Calculation\n'
        yield ' *===========================================================================*/\n\n'
        yield '''typedef struct frame_checksum {
    uint8_t byte1;
    uint8_t byte2;
} frame_checksum_t;

/**
 * Calculate Fletcher-16 checksum over the given data
 */
static inline frame_checksum_t frame_fletcher_checksum(const uint8_t* data, size_t length) {
    frame_checksum_t ck = {0, 0};
    for (size_t i = 0; i < length; i++) {
        ck.byte1 = (uint8_t)(ck.byte1 + data[i]);
        ck.byte2 = (uint8_t)(ck.byte2 + ck.byte1);
    }
    return ck;
}

'''
        
        # Generate common result type
        yield '''/* Parse result */
typedef struct frame_msg_info {
    bool valid;
    uint8_t msg_id;
    size_t msg_len;
    uint8_t* msg_data;
} frame_msg_info_t;

/*===========================================================================
 * Shared Payload Parsing Functions
 *===========================================================================
 * These functions handle payload validation/encoding independent of framing.
 * Frame formats (Tiny/Basic) use these for the common parsing logic.
 */

/**
 * Validate a payload with CRC (shared by Default, Extended, etc. payload types).
 */
static inline frame_msg_info_t frame_validate_payload_with_crc(
    const uint8_t* buffer, size_t length,
    size_t header_size, size_t length_bytes, size_t crc_start_offset) {
    
    frame_msg_info_t result = {false, 0, 0, NULL};
    const size_t footer_size = 2;
    const size_t overhead = header_size + footer_size;
    
    if (length < overhead) {
        return result;
    }
    
    size_t msg_length = length - overhead;
    size_t crc_data_len = msg_length + 1 + length_bytes;
    frame_checksum_t ck = frame_fletcher_checksum(buffer + crc_start_offset, crc_data_len);
    
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[header_size - 1];
        result.msg_len = msg_length;
        result.msg_data = (uint8_t*)(buffer + header_size);
    }
    
    return result;
}

/**
 * Validate a minimal payload (no CRC, no length field).
 */
static inline frame_msg_info_t frame_validate_payload_minimal(
    const uint8_t* buffer, size_t length, size_t header_size) {
    
    frame_msg_info_t result = {false, 0, 0, NULL};
    
    if (length < header_size) {
        return result;
    }
    
    result.valid = true;
    result.msg_id = buffer[header_size - 1];
    result.msg_len = length - header_size;
    result.msg_data = (uint8_t*)(buffer + header_size);
    
    return result;
}

/**
 * Encode payload with length and CRC into output buffer.
 */
static inline size_t frame_encode_payload_with_crc(
    uint8_t* output, uint8_t msg_id, const uint8_t* msg, size_t msg_size,
    size_t length_bytes, const uint8_t* crc_start) {
    
    size_t idx = 0;
    
    if (length_bytes == 1) {
        output[idx++] = (uint8_t)(msg_size & 0xFF);
    } else {
        output[idx++] = (uint8_t)(msg_size & 0xFF);
        output[idx++] = (uint8_t)((msg_size >> 8) & 0xFF);
    }
    
    output[idx++] = msg_id;
    
    if (msg_size > 0 && msg != NULL) {
        memcpy(output + idx, msg, msg_size);
        idx += msg_size;
    }
    
    size_t crc_data_len = msg_size + 1 + length_bytes;
    frame_checksum_t ck = frame_fletcher_checksum(crc_start, crc_data_len);
    output[idx++] = ck.byte1;
    output[idx++] = ck.byte2;
    
    return idx;
}

/**
 * Encode minimal payload (no length, no CRC) into output buffer.
 */
static inline size_t frame_encode_payload_minimal(
    uint8_t* output, uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    
    size_t idx = 0;
    
    output[idx++] = msg_id;
    
    if (msg_size > 0 && msg != NULL) {
        memcpy(output + idx, msg, msg_size);
        idx += msg_size;
    }
    
    return idx;
}

'''
        
        # Generate individual frame format code
        for fmt in formats:
            yield from FrameParserCGen.generate_format(fmt)
            yield '\n'
            
    @staticmethod
    def generate_format(fmt):
        """Generate C code for a single frame format"""
        name = fmt.name
        prefix = camel_to_snake(name)
        PREFIX = camel_to_upper_snake(name)
        
        # Skip formats without start bytes (they need external sync)
        # But still generate encode/decode helpers
        
        yield f'/*===========================================================================\n'
        yield f' * {name} Frame Format\n'
        yield f' *===========================================================================*/\n\n'
        
        # Generate constants
        yield f'/* {name} constants */\n'
        
        # Start bytes
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            yield f'#define {PREFIX}_START_BYTE{i + 1 if len(fmt.start_bytes) > 1 else ""}    0x{sb_value:02X}\n'
            
        yield f'#define {PREFIX}_HEADER_SIZE    {fmt.header_size}  /* '
        parts = []
        for sb_name, sb_value in fmt.start_bytes:
            parts.append(f'{sb_name}')
        parts.append('msg_id')
        if fmt.has_length:
            parts.append(f'length({fmt.length_bytes})')
        yield ' + '.join(parts) + ' */\n'
        
        yield f'#define {PREFIX}_FOOTER_SIZE    {fmt.footer_size}  /* '
        if fmt.has_crc:
            yield f'crc({fmt.crc_bytes} bytes)'
        else:
            yield 'no footer'
        yield ' */\n'
        
        yield f'#define {PREFIX}_OVERHEAD       ({PREFIX}_HEADER_SIZE + {PREFIX}_FOOTER_SIZE)\n\n'
        
        # Generate parser state enum
        yield f'/* {name} parser states */\n'
        yield f'typedef enum {prefix}_parser_state {{\n'
        
        # State machine states
        if fmt.start_bytes:
            for i in range(len(fmt.start_bytes)):
                yield f'    {PREFIX}_LOOKING_FOR_START{i + 1 if len(fmt.start_bytes) > 1 else ""} = {i},\n'
            state_idx = len(fmt.start_bytes)
        else:
            state_idx = 0
            
        yield f'    {PREFIX}_GETTING_MSG_ID = {state_idx},\n'
        state_idx += 1
        
        if fmt.has_length:
            yield f'    {PREFIX}_GETTING_LENGTH = {state_idx},\n'
            state_idx += 1
            
        yield f'    {PREFIX}_GETTING_PAYLOAD = {state_idx}\n'
        yield f'}} {prefix}_parser_state_t;\n\n'
        
        # Generate parser structure
        yield f'/* {name} parser state structure */\n'
        yield f'typedef struct {prefix}_parser {{\n'
        yield f'    {prefix}_parser_state_t state;\n'
        yield f'    uint8_t* buffer;\n'
        yield f'    size_t buffer_max_size;\n'
        yield f'    size_t buffer_index;\n'
        yield f'    size_t packet_size;\n'
        yield f'    uint8_t msg_id;\n'
        if fmt.has_length:
            yield f'    size_t msg_length;  /* From length field */\n'
            if fmt.length_bytes == 2:
                yield f'    uint8_t length_lo;  /* Low byte for 16-bit length */\n'
        yield f'    /* User-provided function to get message length from msg_id (for non-length frames) */\n'
        yield f'    bool (*get_msg_length)(uint8_t msg_id, size_t* length);\n'
        yield f'}} {prefix}_parser_t;\n\n'
        
        # Generate encode buffer structure
        yield f'/* {name} encode buffer structure */\n'
        yield f'typedef struct {prefix}_encode_buffer {{\n'
        yield f'    uint8_t* data;\n'
        yield f'    size_t max_size;\n'
        yield f'    size_t size;\n'
        yield f'    bool in_progress;\n'
        yield f'    size_t reserved_msg_size;\n'
        yield f'}} {prefix}_encode_buffer_t;\n\n'
        
        # Generate init function
        yield f'/**\n'
        yield f' * Initialize a {name} parser\n'
        yield f' */\n'
        yield f'static inline void {prefix}_parser_init({prefix}_parser_t* parser,\n'
        yield f'                                        uint8_t* buffer, size_t buffer_size,\n'
        yield f'                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {{\n'
        if fmt.start_bytes:
            yield f'    parser->state = {PREFIX}_LOOKING_FOR_START{"1" if len(fmt.start_bytes) > 1 else ""};\n'
        else:
            yield f'    parser->state = {PREFIX}_GETTING_MSG_ID;\n'
        yield f'    parser->buffer = buffer;\n'
        yield f'    parser->buffer_max_size = buffer_size;\n'
        yield f'    parser->buffer_index = 0;\n'
        yield f'    parser->packet_size = 0;\n'
        yield f'    parser->msg_id = 0;\n'
        if fmt.has_length:
            yield f'    parser->msg_length = 0;\n'
            if fmt.length_bytes == 2:
                yield f'    parser->length_lo = 0;\n'
        yield f'    parser->get_msg_length = get_msg_length;\n'
        yield f'}}\n\n'
        
        # Generate reset function
        yield f'/**\n'
        yield f' * Reset {name} parser state\n'
        yield f' */\n'
        yield f'static inline void {prefix}_parser_reset({prefix}_parser_t* parser) {{\n'
        if fmt.start_bytes:
            yield f'    parser->state = {PREFIX}_LOOKING_FOR_START{"1" if len(fmt.start_bytes) > 1 else ""};\n'
        else:
            yield f'    parser->state = {PREFIX}_GETTING_MSG_ID;\n'
        yield f'    parser->buffer_index = 0;\n'
        yield f'    parser->packet_size = 0;\n'
        yield f'    parser->msg_id = 0;\n'
        if fmt.has_length:
            yield f'    parser->msg_length = 0;\n'
        yield f'}}\n\n'
        
        # Generate parse_byte function
        yield f'/**\n'
        yield f' * Parse a single byte with {name} format\n'
        yield f' * Returns frame_msg_info_t with valid=true when a complete valid message is received\n'
        yield f' */\n'
        yield f'static inline frame_msg_info_t {prefix}_parse_byte({prefix}_parser_t* parser, uint8_t byte) {{\n'
        yield f'    frame_msg_info_t result = {{false, 0, 0, NULL}};\n\n'
        yield f'    switch (parser->state) {{\n'
        
        # Generate state machine cases
        if fmt.start_bytes:
            for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
                state_name = f'{PREFIX}_LOOKING_FOR_START{i + 1 if len(fmt.start_bytes) > 1 else ""}'
                yield f'        case {state_name}:\n'
                yield f'            if (byte == {PREFIX}_START_BYTE{i + 1 if len(fmt.start_bytes) > 1 else ""}) {{\n'
                yield f'                parser->buffer[{i}] = byte;\n'
                yield f'                parser->buffer_index = {i + 1};\n'
                
                if i + 1 < len(fmt.start_bytes):
                    next_state = f'{PREFIX}_LOOKING_FOR_START{i + 2}'
                else:
                    next_state = f'{PREFIX}_GETTING_MSG_ID'
                yield f'                parser->state = {next_state};\n'
                
                yield f'            }}'
                
                # Handle case where we see start byte 1 while looking for start byte 2
                # This code only runs when len(fmt.start_bytes) > 1 (i.e., i > 0 is only possible with 2+ start bytes)
                if i > 0:
                    yield f' else if (byte == {PREFIX}_START_BYTE1) {{\n'
                    yield f'                parser->buffer[0] = byte;\n'
                    yield f'                parser->buffer_index = 1;\n'
                    yield f'                parser->state = {PREFIX}_LOOKING_FOR_START2;\n'
                    yield f'            }} else {{\n'
                    yield f'                parser->state = {PREFIX}_LOOKING_FOR_START1;\n'
                    yield f'            }}\n'
                else:
                    yield '\n'
                yield f'            break;\n\n'
        
        # MSG_ID state
        yield f'        case {PREFIX}_GETTING_MSG_ID:\n'
        yield f'            parser->buffer[parser->buffer_index++] = byte;\n'
        yield f'            parser->msg_id = byte;\n'
        
        if fmt.has_length:
            yield f'            parser->state = {PREFIX}_GETTING_LENGTH;\n'
        else:
            yield f'            {{\n'
            yield f'                size_t msg_length = 0;\n'
            yield f'                if (parser->get_msg_length && parser->get_msg_length(byte, &msg_length)) {{\n'
            yield f'                    parser->packet_size = {PREFIX}_OVERHEAD + msg_length;\n'
            yield f'                    if (parser->packet_size <= parser->buffer_max_size) {{\n'
            yield f'                        parser->state = {PREFIX}_GETTING_PAYLOAD;\n'
            yield f'                    }} else {{\n'
            if fmt.start_bytes:
                yield f'                        parser->state = {PREFIX}_LOOKING_FOR_START{"1" if len(fmt.start_bytes) > 1 else ""};\n'
            else:
                yield f'                        parser->state = {PREFIX}_GETTING_MSG_ID;\n'
            yield f'                    }}\n'
            yield f'                }} else {{\n'
            if fmt.start_bytes:
                yield f'                    parser->state = {PREFIX}_LOOKING_FOR_START{"1" if len(fmt.start_bytes) > 1 else ""};\n'
            else:
                yield f'                    parser->state = {PREFIX}_GETTING_MSG_ID;\n'
            yield f'                }}\n'
            yield f'            }}\n'
        yield f'            break;\n\n'
        
        # LENGTH state (if applicable)
        if fmt.has_length:
            yield f'        case {PREFIX}_GETTING_LENGTH:\n'
            yield f'            parser->buffer[parser->buffer_index++] = byte;\n'
            if fmt.length_bytes == 1:
                yield f'            parser->msg_length = byte;\n'
                yield f'            parser->packet_size = {PREFIX}_OVERHEAD + parser->msg_length;\n'
                yield f'            if (parser->packet_size <= parser->buffer_max_size) {{\n'
                yield f'                parser->state = {PREFIX}_GETTING_PAYLOAD;\n'
                yield f'            }} else {{\n'
                if fmt.start_bytes:
                    yield f'                parser->state = {PREFIX}_LOOKING_FOR_START{"1" if len(fmt.start_bytes) > 1 else ""};\n'
                else:
                    yield f'                parser->state = {PREFIX}_GETTING_MSG_ID;\n'
                yield f'            }}\n'
            else:
                # 16-bit length
                yield f'            if (parser->buffer_index == {len(fmt.start_bytes) + 2}) {{\n'
                yield f'                parser->length_lo = byte;\n'
                yield f'            }} else {{\n'
                yield f'                parser->msg_length = parser->length_lo | ((size_t)byte << 8);\n'
                yield f'                parser->packet_size = {PREFIX}_OVERHEAD + parser->msg_length;\n'
                yield f'                if (parser->packet_size <= parser->buffer_max_size) {{\n'
                yield f'                    parser->state = {PREFIX}_GETTING_PAYLOAD;\n'
                yield f'                }} else {{\n'
                if fmt.start_bytes:
                    yield f'                    parser->state = {PREFIX}_LOOKING_FOR_START{"1" if len(fmt.start_bytes) > 1 else ""};\n'
                else:
                    yield f'                    parser->state = {PREFIX}_GETTING_MSG_ID;\n'
                yield f'                }}\n'
                yield f'            }}\n'
            yield f'            break;\n\n'
        
        # PAYLOAD state - uses shared payload validation
        yield f'        case {PREFIX}_GETTING_PAYLOAD:\n'
        yield f'            if (parser->buffer_index < parser->buffer_max_size) {{\n'
        yield f'                parser->buffer[parser->buffer_index++] = byte;\n'
        yield f'            }}\n\n'
        yield f'            if (parser->buffer_index >= parser->packet_size) {{\n'
        
        if fmt.has_crc:
            crc_start = len(fmt.start_bytes)
            yield f'                /* Use shared payload validation with CRC */\n'
            yield f'                result = frame_validate_payload_with_crc(\n'
            yield f'                    parser->buffer, parser->packet_size,\n'
            yield f'                    {PREFIX}_HEADER_SIZE, {fmt.length_bytes}, {crc_start});\n'
        else:
            yield f'                /* Use shared minimal payload validation */\n'
            yield f'                result = frame_validate_payload_minimal(\n'
            yield f'                    parser->buffer, parser->packet_size, {PREFIX}_HEADER_SIZE);\n'
        
        if fmt.start_bytes:
            yield f'                parser->state = {PREFIX}_LOOKING_FOR_START{"1" if len(fmt.start_bytes) > 1 else ""};\n'
        else:
            yield f'                parser->state = {PREFIX}_GETTING_MSG_ID;\n'
        yield f'            }}\n'
        yield f'            break;\n'
        
        yield f'    }}\n\n'
        yield f'    return result;\n'
        yield f'}}\n\n'
        
        # Generate encode function - uses shared payload encoding
        yield f'/**\n'
        yield f' * Encode a message with {name} format\n'
        yield f' * Returns the number of bytes written, or 0 on failure\n'
        yield f' */\n'
        yield f'static inline size_t {prefix}_encode(uint8_t* buffer, size_t buffer_size,\n'
        yield f'                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {{\n'
        yield f'    size_t total_size = {PREFIX}_OVERHEAD + msg_size;\n'
        yield f'    if (buffer_size < total_size) {{\n'
        yield f'        return 0;\n'
        yield f'    }}\n\n'
        
        # Write start bytes (frame-specific)
        idx = 0
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            yield f'    buffer[{idx}] = {PREFIX}_START_BYTE{i + 1 if len(fmt.start_bytes) > 1 else ""};\n'
            idx += 1
        
        # Use shared payload encoding function
        if fmt.has_crc:
            crc_start = len(fmt.start_bytes)
            yield f'\n    /* Use shared payload encoding with CRC */\n'
            yield f'    frame_encode_payload_with_crc(\n'
            yield f'        buffer + {len(fmt.start_bytes)}, msg_id, msg, msg_size,\n'
            yield f'        {fmt.length_bytes}, buffer + {crc_start});\n'
        else:
            yield f'\n    /* Use shared minimal payload encoding */\n'
            yield f'    frame_encode_payload_minimal(\n'
            yield f'        buffer + {len(fmt.start_bytes)}, msg_id, msg, msg_size);\n'
        
        yield f'\n    return total_size;\n'
        yield f'}}\n\n'
        
        # Generate validate_packet function - uses shared payload validation
        yield f'/**\n'
        yield f' * Validate a complete {name} packet in a buffer\n'
        yield f' */\n'
        yield f'static inline frame_msg_info_t {prefix}_validate_packet(const uint8_t* buffer, size_t length) {{\n'
        yield f'    if (length < {PREFIX}_OVERHEAD) {{\n'
        yield f'        return (frame_msg_info_t){{false, 0, 0, NULL}};\n'
        yield f'    }}\n\n'
        
        # Check start bytes
        if fmt.start_bytes:
            for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
                yield f'    if (buffer[{i}] != {PREFIX}_START_BYTE{i + 1 if len(fmt.start_bytes) > 1 else ""}) {{\n'
                yield f'        return (frame_msg_info_t){{false, 0, 0, NULL}};\n'
                yield f'    }}\n'
        
        yield f'\n'
        
        # Use shared payload validation function
        if fmt.has_crc:
            crc_start = len(fmt.start_bytes)
            yield f'    /* Use shared payload validation with CRC */\n'
            yield f'    return frame_validate_payload_with_crc(\n'
            yield f'        buffer, length, {PREFIX}_HEADER_SIZE, {fmt.length_bytes}, {crc_start});\n'
        else:
            yield f'    /* Use shared minimal payload validation */\n'
            yield f'    return frame_validate_payload_minimal(\n'
            yield f'        buffer, length, {PREFIX}_HEADER_SIZE);\n'
        
        yield f'}}\n\n'


def generate_c_frame_parsers(formats):
    """Generate C frame parser code from frame format definitions"""
    return ''.join(FrameParserCGen.generate_header(formats))


def generate_c_frame_parsers_multi(formats):
    """
    Generate multiple C header files for frame parsers.

    Returns a dictionary mapping filename to content:
    - frame_base.h: Base utilities (checksum, frame_msg_info_t, FrameFormatType)
    - {snake_name}.h: Individual frame format headers
    - frame_parsers.h: Main header that includes all frame formats
    """
    files = {}

    # Generate base file
    files['frame_base.h'] = ''.join(FrameParserCGen.generate_base(formats))

    # Generate individual frame format files
    for fmt in formats:
        snake_name = camel_to_snake(fmt.name)
        files[f'{snake_name}.h'] = ''.join(FrameParserCGen.generate_format_file(fmt))

    # Generate main header
    files['frame_parsers.h'] = ''.join(FrameParserCGen.generate_main_header(formats))

    return files
