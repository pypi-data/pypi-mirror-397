// Automatically generated frame parser for C#
// Generated by 0.0.1 at Fri Dec  5 01:14:49 2025.

using System;
using System.Collections.Generic;

namespace StructFrame
{
    /// <summary>
    /// TinyDefault - Frame format parser and encoder
    /// </summary>
    public class TinyDefault : FrameFormatBase
    {
        public enum ParserState
        {
            LookingForStart = 0,
            GettingMsgId = 1,
            GettingLength = 2,
            GettingPayload = 3
        }

        public const byte StartByte = 0x71;
        public const int HeaderSize = 3;
        public const int FooterSize = 2;
        public const int Overhead = 5;
        public const int LengthBytes = 1;

        private ParserState _state;
        private List<byte> _buffer;
        private int _packetSize;
        private int _msgId;
        private int _msgLength;
        private Func<int, int?> _getMsgLength;

        /// <summary>
        /// Initialize the TinyDefault parser
        /// </summary>
        /// <param name="getMsgLength">Callback function to get message length from msg_id</param>
        public TinyDefault(Func<int, int?> getMsgLength = null)
        {
            _getMsgLength = getMsgLength;
            _buffer = new List<byte>();
            Reset();
        }

        /// <summary>
        /// Reset parser state
        /// </summary>
        public override void Reset()
        {
            _state = ParserState.LookingForStart;
            _buffer.Clear();
            _packetSize = 0;
            _msgId = 0;
            _msgLength = 0;
        }

        /// <summary>
        /// Parse a single byte
        /// </summary>
        /// <param name="b">The byte to parse</param>
        /// <returns>FrameParseResult with Valid=true when a complete valid message is received</returns>
        public override FrameParseResult ParseByte(byte b)
        {
            var result = new FrameParseResult();

            switch (_state)
            {
                case ParserState.LookingForStart:
                    if (b == StartByte)
                    {
                        _buffer.Clear();
                        _buffer.Add(b);
                        _state = ParserState.GettingMsgId;
                    }
                    break;

                case ParserState.GettingMsgId:
                    _buffer.Add(b);
                    _msgId = b;
                    _state = ParserState.GettingLength;
                    break;

                case ParserState.GettingLength:
                    _buffer.Add(b);
                    _msgLength = b;
                    _packetSize = Overhead + _msgLength;
                    _state = ParserState.GettingPayload;
                    break;

                case ParserState.GettingPayload:
                    _buffer.Add(b);
                    if (_buffer.Count >= _packetSize)
                    {
                        result = ValidatePacket(_buffer.ToArray(), _buffer.Count);
                        _state = ParserState.LookingForStart;
                    }
                    break;
            }

            return result;
        }

        /// <summary>
        /// Encode a message with TinyDefault format
        /// </summary>
        /// <param name="msgId">Message ID</param>
        /// <param name="msgData">Message data bytes</param>
        /// <returns>Encoded frame as byte array</returns>
        public override byte[] Encode(int msgId, byte[] msgData)
        {
            var output = new List<byte>();
            output.Add(StartByte);
            output.Add((byte)(msgData.Length & 0xFF));
            output.Add((byte)msgId);
            output.AddRange(msgData);

            // Calculate Fletcher checksum
            var ck = FletcherChecksum(output.ToArray(), 1, output.Count);
            output.Add(ck.Item1);
            output.Add(ck.Item2);
            return output.ToArray();
        }

        /// <summary>
        /// Validate a complete TinyDefault packet in a buffer
        /// </summary>
        /// <param name="data">Buffer containing the complete packet</param>
        /// <param name="length">Length of the data in the buffer</param>
        /// <returns>FrameParseResult with Valid=true if packet is valid</returns>
        public override FrameParseResult ValidatePacket(byte[] data, int length)
        {
            var result = new FrameParseResult();

            if (length < Overhead)
                return result;

            if (data[0] != StartByte)
                return result;

            int msgLength = length - Overhead;
            int crcDataLen = msgLength + 1 + LengthBytes;
            var ck = FletcherChecksum(data, 1, 1 + crcDataLen);

            if (ck.Item1 == data[length - 2] && ck.Item2 == data[length - 1])
            {
                result.Valid = true;
                result.MsgId = data[HeaderSize - 1];
                result.MsgSize = msgLength;
                result.MsgData = new byte[msgLength];
                Array.Copy(data, HeaderSize, result.MsgData, 0, msgLength);
            }
            return result;
        }

        /// <summary>
        /// Calculate Fletcher-16 checksum
        /// </summary>
        private static (byte, byte) FletcherChecksum(byte[] buffer, int start, int end)
        {
            byte byte1 = 0;
            byte byte2 = 0;

            for (int i = start; i < end; i++)
            {
                byte1 = (byte)((byte1 + buffer[i]) % 256);
                byte2 = (byte)((byte2 + byte1) % 256);
            }

            return (byte1, byte2);
        }
    }
}
