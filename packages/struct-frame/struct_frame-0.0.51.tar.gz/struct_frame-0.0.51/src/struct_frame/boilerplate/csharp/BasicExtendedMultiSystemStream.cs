// Automatically generated frame parser for C#
// Generated by 0.0.1 at Fri Dec  5 01:14:49 2025.

using System;
using System.Collections.Generic;

namespace StructFrame
{
    /// <summary>
    /// BasicExtendedMultiSystemStream - Frame format parser and encoder
    /// </summary>
    public class BasicExtendedMultiSystemStream : FrameFormatBase
    {
        public enum ParserState
        {
            LookingForStart1 = 0,
            LookingForStart2 = 1,
            GettingMsgId = 2,
            GettingLength = 3,
            GettingPayload = 4
        }

        public const byte StartByte1 = 0x90;
        public const byte StartByte2 = 0x78;
        public const int HeaderSize = 9;
        public const int FooterSize = 2;
        public const int Overhead = 11;
        public const int LengthBytes = 2;

        private ParserState _state;
        private List<byte> _buffer;
        private int _packetSize;
        private int _msgId;
        private int _msgLength;
        private int _lengthLo;
        private Func<int, int?> _getMsgLength;

        /// <summary>
        /// Initialize the BasicExtendedMultiSystemStream parser
        /// </summary>
        /// <param name="getMsgLength">Callback function to get message length from msg_id</param>
        public BasicExtendedMultiSystemStream(Func<int, int?> getMsgLength = null)
        {
            _getMsgLength = getMsgLength;
            _buffer = new List<byte>();
            Reset();
        }

        /// <summary>
        /// Reset parser state
        /// </summary>
        public override void Reset()
        {
            _state = ParserState.LookingForStart1;
            _buffer.Clear();
            _packetSize = 0;
            _msgId = 0;
            _msgLength = 0;
            _lengthLo = 0;
        }

        /// <summary>
        /// Parse a single byte
        /// </summary>
        /// <param name="b">The byte to parse</param>
        /// <returns>FrameParseResult with Valid=true when a complete valid message is received</returns>
        public override FrameParseResult ParseByte(byte b)
        {
            var result = new FrameParseResult();

            switch (_state)
            {
                case ParserState.LookingForStart1:
                    if (b == StartByte1)
                    {
                        _buffer.Clear();
                        _buffer.Add(b);
                        _state = ParserState.LookingForStart2;
                    }
                    break;

                case ParserState.LookingForStart2:
                    if (b == StartByte2)
                    {
                        _buffer.Add(b);
                        _state = ParserState.GettingMsgId;
                    }
                    else if (b == StartByte1)
                    {
                        _buffer.Clear();
                        _buffer.Add(b);
                        _state = ParserState.LookingForStart2;
                    }
                    else
                    {
                        _state = ParserState.LookingForStart1;
                    }
                    break;

                case ParserState.GettingMsgId:
                    _buffer.Add(b);
                    _msgId = b;
                    _state = ParserState.GettingLength;
                    break;

                case ParserState.GettingLength:
                    _buffer.Add(b);
                    if (_buffer.Count == 4)
                    {
                        _lengthLo = b;
                    }
                    else
                    {
                        _msgLength = _lengthLo | (b << 8);
                        _packetSize = Overhead + _msgLength;
                        _state = ParserState.GettingPayload;
                    }
                    break;

                case ParserState.GettingPayload:
                    _buffer.Add(b);
                    if (_buffer.Count >= _packetSize)
                    {
                        result = ValidatePacket(_buffer.ToArray(), _buffer.Count);
                        _state = ParserState.LookingForStart1;
                    }
                    break;
            }

            return result;
        }

        /// <summary>
        /// Encode a message with BasicExtendedMultiSystemStream format
        /// </summary>
        /// <param name="msgId">Message ID</param>
        /// <param name="msgData">Message data bytes</param>
        /// <returns>Encoded frame as byte array</returns>
        public override byte[] Encode(int msgId, byte[] msgData)
        {
            var output = new List<byte>();
            output.Add(StartByte1);
            output.Add(StartByte2);
            output.Add((byte)(msgData.Length & 0xFF));
            output.Add((byte)((msgData.Length >> 8) & 0xFF));
            output.Add((byte)msgId);
            output.AddRange(msgData);

            // Calculate Fletcher checksum
            var ck = FletcherChecksum(output.ToArray(), 2, output.Count);
            output.Add(ck.Item1);
            output.Add(ck.Item2);
            return output.ToArray();
        }

        /// <summary>
        /// Validate a complete BasicExtendedMultiSystemStream packet in a buffer
        /// </summary>
        /// <param name="data">Buffer containing the complete packet</param>
        /// <param name="length">Length of the data in the buffer</param>
        /// <returns>FrameParseResult with Valid=true if packet is valid</returns>
        public override FrameParseResult ValidatePacket(byte[] data, int length)
        {
            var result = new FrameParseResult();

            if (length < Overhead)
                return result;

            if (data[0] != StartByte1)
                return result;
            if (data[1] != StartByte2)
                return result;

            int msgLength = length - Overhead;
            int crcDataLen = msgLength + 1 + LengthBytes;
            var ck = FletcherChecksum(data, 2, 2 + crcDataLen);

            if (ck.Item1 == data[length - 2] && ck.Item2 == data[length - 1])
            {
                result.Valid = true;
                result.MsgId = data[HeaderSize - 1];
                result.MsgSize = msgLength;
                result.MsgData = new byte[msgLength];
                Array.Copy(data, HeaderSize, result.MsgData, 0, msgLength);
            }
            return result;
        }

        /// <summary>
        /// Calculate Fletcher-16 checksum
        /// </summary>
        private static (byte, byte) FletcherChecksum(byte[] buffer, int start, int end)
        {
            byte byte1 = 0;
            byte byte2 = 0;

            for (int i = start; i < end; i++)
            {
                byte1 = (byte)((byte1 + buffer[i]) % 256);
                byte2 = (byte)((byte2 + byte1) % 256);
            }

            return (byte1, byte2);
        }
    }
}
