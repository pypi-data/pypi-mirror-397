// Automatically generated frame parser for C#
// Generated by 0.0.1 at Fri Dec  5 01:14:49 2025.

using System;
using System.Collections.Generic;

namespace StructFrame
{
    /// <summary>
    /// TinyMinimal - Frame format parser and encoder
    /// </summary>
    public class TinyMinimal : FrameFormatBase
    {
        public enum ParserState
        {
            LookingForStart = 0,
            GettingMsgId = 1,
            GettingPayload = 2
        }

        public const byte StartByte = 0x70;
        public const int HeaderSize = 2;
        public const int FooterSize = 0;
        public const int Overhead = 2;

        private ParserState _state;
        private List<byte> _buffer;
        private int _packetSize;
        private int _msgId;
        private Func<int, int?> _getMsgLength;

        /// <summary>
        /// Initialize the TinyMinimal parser
        /// </summary>
        /// <param name="getMsgLength">Callback function to get message length from msg_id</param>
        public TinyMinimal(Func<int, int?> getMsgLength = null)
        {
            _getMsgLength = getMsgLength;
            _buffer = new List<byte>();
            Reset();
        }

        /// <summary>
        /// Reset parser state
        /// </summary>
        public override void Reset()
        {
            _state = ParserState.LookingForStart;
            _buffer.Clear();
            _packetSize = 0;
            _msgId = 0;
        }

        /// <summary>
        /// Parse a single byte
        /// </summary>
        /// <param name="b">The byte to parse</param>
        /// <returns>FrameParseResult with Valid=true when a complete valid message is received</returns>
        public override FrameParseResult ParseByte(byte b)
        {
            var result = new FrameParseResult();

            switch (_state)
            {
                case ParserState.LookingForStart:
                    if (b == StartByte)
                    {
                        _buffer.Clear();
                        _buffer.Add(b);
                        _state = ParserState.GettingMsgId;
                    }
                    break;

                case ParserState.GettingMsgId:
                    _buffer.Add(b);
                    _msgId = b;
                    if (_getMsgLength != null)
                    {
                        int? msgLength = _getMsgLength(b);
                        if (msgLength.HasValue)
                        {
                            _packetSize = Overhead + msgLength.Value;
                            _state = ParserState.GettingPayload;
                        }
                        else
                        {
                            _state = ParserState.LookingForStart;
                        }
                    }
                    else
                    {
                        _state = ParserState.LookingForStart;
                    }
                    break;

                case ParserState.GettingPayload:
                    _buffer.Add(b);
                    if (_buffer.Count >= _packetSize)
                    {
                        result = ValidatePacket(_buffer.ToArray(), _buffer.Count);
                        _state = ParserState.LookingForStart;
                    }
                    break;
            }

            return result;
        }

        /// <summary>
        /// Encode a message with TinyMinimal format
        /// </summary>
        /// <param name="msgId">Message ID</param>
        /// <param name="msgData">Message data bytes</param>
        /// <returns>Encoded frame as byte array</returns>
        public override byte[] Encode(int msgId, byte[] msgData)
        {
            var output = new List<byte>();
            output.Add(StartByte);
            output.Add((byte)msgId);
            output.AddRange(msgData);
            return output.ToArray();
        }

        /// <summary>
        /// Validate a complete TinyMinimal packet in a buffer
        /// </summary>
        /// <param name="data">Buffer containing the complete packet</param>
        /// <param name="length">Length of the data in the buffer</param>
        /// <returns>FrameParseResult with Valid=true if packet is valid</returns>
        public override FrameParseResult ValidatePacket(byte[] data, int length)
        {
            var result = new FrameParseResult();

            if (length < Overhead)
                return result;

            if (data[0] != StartByte)
                return result;

            result.Valid = true;
            result.MsgId = data[HeaderSize - 1];
            result.MsgSize = length - HeaderSize;
            result.MsgData = new byte[result.MsgSize];
            Array.Copy(data, HeaderSize, result.MsgData, 0, result.MsgSize);
            return result;
        }

        /// <summary>
        /// Calculate Fletcher-16 checksum
        /// </summary>
        private static (byte, byte) FletcherChecksum(byte[] buffer, int start, int end)
        {
            byte byte1 = 0;
            byte byte2 = 0;

            for (int i = start; i < end; i++)
            {
                byte1 = (byte)((byte1 + buffer[i]) % 256);
                byte2 = (byte)((byte2 + byte1) % 256);
            }

            return (byte1, byte2);
        }
    }
}
