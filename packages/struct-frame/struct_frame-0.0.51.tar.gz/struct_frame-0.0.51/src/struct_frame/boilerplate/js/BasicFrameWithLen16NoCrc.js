// Automatically generated frame parser
// Generated by 0.0.1 at Wed Dec  3 17:57:16 2025.

const { createFrameMsgInfo, fletcher_checksum } = require('./frame_base');

// =============================================================================
// BasicFrameWithLen16NoCrc Frame Format
// =============================================================================

const BasicFrameWithLen16NoCrcParserState = {
    LOOKING_FOR_START1: 0,
    LOOKING_FOR_START2: 1,
    GETTING_MSG_ID: 2,
    GETTING_LENGTH: 3,
    GETTING_PAYLOAD: 4
};

/**
 * BasicFrameWithLen16NoCrc - Frame format parser and encoder
 */
class BasicFrameWithLen16NoCrc {
    static START_BYTE1 = 0x90;
    static START_BYTE2 = 0x97;
    static HEADER_SIZE = 5;
    static FOOTER_SIZE = 0;
    static OVERHEAD = 5;
    static LENGTH_BYTES = 2;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    reset() {
        this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1:
                if (byte === BasicFrameWithLen16NoCrc.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START2;
                }
                break;

            case BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START2:
                if (byte === BasicFrameWithLen16NoCrc.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = BasicFrameWithLen16NoCrcParserState.GETTING_MSG_ID;
                } else if (byte === BasicFrameWithLen16NoCrc.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START2;
                } else {
                    this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameWithLen16NoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = BasicFrameWithLen16NoCrcParserState.GETTING_LENGTH;
                break;

            case BasicFrameWithLen16NoCrcParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                if (this.buffer.length === 4) {
                    this.length_lo = byte;
                } else {
                    this.msg_length = this.length_lo | (byte << 8);
                    this.packet_size = BasicFrameWithLen16NoCrc.OVERHEAD + this.msg_length;
                    this.state = BasicFrameWithLen16NoCrcParserState.GETTING_PAYLOAD;
                }
                break;

            case BasicFrameWithLen16NoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - BasicFrameWithLen16NoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(BasicFrameWithLen16NoCrc.HEADER_SIZE));
                    this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(BasicFrameWithLen16NoCrc.START_BYTE1);
        output.push(BasicFrameWithLen16NoCrc.START_BYTE2);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < BasicFrameWithLen16NoCrc.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== BasicFrameWithLen16NoCrc.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== BasicFrameWithLen16NoCrc.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - BasicFrameWithLen16NoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, BasicFrameWithLen16NoCrc.HEADER_SIZE));

        return result;
    }
}

module.exports = {
    BasicFrameWithLen16NoCrc,
    BasicFrameWithLen16NoCrcParserState,
};
