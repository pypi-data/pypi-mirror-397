/* Automatically generated frame parser */
/* Generated by 0.0.1 at Fri Dec  5 01:14:49 2025. */

#pragma once

#include "frame_base.h"

/*===========================================================================
 * BasicExtendedMsgIds Frame Format
 *===========================================================================*/

/* BasicExtendedMsgIds constants */
#define BASIC_EXTENDED_MSG_IDS_START_BYTE1    0x90
#define BASIC_EXTENDED_MSG_IDS_START_BYTE2    0x72
#define BASIC_EXTENDED_MSG_IDS_HEADER_SIZE    5  /* start_byte1 + start_byte2 + msg_id + length(1) */
#define BASIC_EXTENDED_MSG_IDS_FOOTER_SIZE    2  /* crc(2 bytes) */
#define BASIC_EXTENDED_MSG_IDS_OVERHEAD       (BASIC_EXTENDED_MSG_IDS_HEADER_SIZE + BASIC_EXTENDED_MSG_IDS_FOOTER_SIZE)

/* BasicExtendedMsgIds parser states */
typedef enum basic_extended_msg_ids_parser_state {
    BASIC_EXTENDED_MSG_IDS_LOOKING_FOR_START1 = 0,
    BASIC_EXTENDED_MSG_IDS_LOOKING_FOR_START2 = 1,
    BASIC_EXTENDED_MSG_IDS_GETTING_MSG_ID = 2,
    BASIC_EXTENDED_MSG_IDS_GETTING_LENGTH = 3,
    BASIC_EXTENDED_MSG_IDS_GETTING_PAYLOAD = 4
} basic_extended_msg_ids_parser_state_t;

/* BasicExtendedMsgIds parser state structure */
typedef struct basic_extended_msg_ids_parser {
    basic_extended_msg_ids_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} basic_extended_msg_ids_parser_t;

/* BasicExtendedMsgIds encode buffer structure */
typedef struct basic_extended_msg_ids_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} basic_extended_msg_ids_encode_buffer_t;

/**
 * Initialize a BasicExtendedMsgIds parser
 */
static inline void basic_extended_msg_ids_parser_init(basic_extended_msg_ids_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = BASIC_EXTENDED_MSG_IDS_LOOKING_FOR_START1;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset BasicExtendedMsgIds parser state
 */
static inline void basic_extended_msg_ids_parser_reset(basic_extended_msg_ids_parser_t* parser) {
    parser->state = BASIC_EXTENDED_MSG_IDS_LOOKING_FOR_START1;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with BasicExtendedMsgIds format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t basic_extended_msg_ids_parse_byte(basic_extended_msg_ids_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case BASIC_EXTENDED_MSG_IDS_LOOKING_FOR_START1:
            if (byte == BASIC_EXTENDED_MSG_IDS_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = BASIC_EXTENDED_MSG_IDS_LOOKING_FOR_START2;
            }
            break;

        case BASIC_EXTENDED_MSG_IDS_LOOKING_FOR_START2:
            if (byte == BASIC_EXTENDED_MSG_IDS_START_BYTE2) {
                parser->buffer[1] = byte;
                parser->buffer_index = 2;
                parser->state = BASIC_EXTENDED_MSG_IDS_GETTING_MSG_ID;
            } else if (byte == BASIC_EXTENDED_MSG_IDS_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = BASIC_EXTENDED_MSG_IDS_LOOKING_FOR_START2;
            } else {
                parser->state = BASIC_EXTENDED_MSG_IDS_LOOKING_FOR_START1;
            }
            break;

        case BASIC_EXTENDED_MSG_IDS_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = BASIC_EXTENDED_MSG_IDS_GETTING_LENGTH;
            break;

        case BASIC_EXTENDED_MSG_IDS_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_length = byte;
            parser->packet_size = BASIC_EXTENDED_MSG_IDS_OVERHEAD + parser->msg_length;
            if (parser->packet_size <= parser->buffer_max_size) {
                parser->state = BASIC_EXTENDED_MSG_IDS_GETTING_PAYLOAD;
            } else {
                parser->state = BASIC_EXTENDED_MSG_IDS_LOOKING_FOR_START1;
            }
            break;

        case BASIC_EXTENDED_MSG_IDS_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                /* Use shared payload validation with CRC */
                result = frame_validate_payload_with_crc(
                    parser->buffer, parser->packet_size,
                    BASIC_EXTENDED_MSG_IDS_HEADER_SIZE, 1, 2);
                parser->state = BASIC_EXTENDED_MSG_IDS_LOOKING_FOR_START1;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with BasicExtendedMsgIds format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t basic_extended_msg_ids_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = BASIC_EXTENDED_MSG_IDS_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = BASIC_EXTENDED_MSG_IDS_START_BYTE1;
    buffer[1] = BASIC_EXTENDED_MSG_IDS_START_BYTE2;

    /* Use shared payload encoding with CRC */
    frame_encode_payload_with_crc(
        buffer + 2, msg_id, msg, msg_size,
        1, buffer + 2);

    return total_size;
}

/**
 * Validate a complete BasicExtendedMsgIds packet in a buffer
 */
static inline frame_msg_info_t basic_extended_msg_ids_validate_packet(const uint8_t* buffer, size_t length) {
    if (length < BASIC_EXTENDED_MSG_IDS_OVERHEAD) {
        return (frame_msg_info_t){false, 0, 0, NULL};
    }

    if (buffer[0] != BASIC_EXTENDED_MSG_IDS_START_BYTE1) {
        return (frame_msg_info_t){false, 0, 0, NULL};
    }
    if (buffer[1] != BASIC_EXTENDED_MSG_IDS_START_BYTE2) {
        return (frame_msg_info_t){false, 0, 0, NULL};
    }

    /* Use shared payload validation with CRC */
    return frame_validate_payload_with_crc(
        buffer, length, BASIC_EXTENDED_MSG_IDS_HEADER_SIZE, 1, 2);
}

