/* Automatically generated frame parser */
/* Generated by 0.0.1 at Wed Dec  3 17:57:16 2025. */

#pragma once

#include "frame_base.hpp"

namespace FrameParsers {

// =============================================================================
// TinyFrameWithLen16 Frame Format
// =============================================================================

enum class TinyFrameWithLen16ParserState : uint8_t {
    LookingForStart = 0,
    GettingMsgId = 1,
    GettingLength = 2,
    GettingPayload = 3
};

// TinyFrameWithLen16 constants
constexpr uint8_t TINY_FRAME_WITH_LEN16_START_BYTE = 0x74;
constexpr size_t TINY_FRAME_WITH_LEN16_HEADER_SIZE = 4;
constexpr size_t TINY_FRAME_WITH_LEN16_FOOTER_SIZE = 2;
constexpr size_t TINY_FRAME_WITH_LEN16_OVERHEAD = TINY_FRAME_WITH_LEN16_HEADER_SIZE + TINY_FRAME_WITH_LEN16_FOOTER_SIZE;
constexpr size_t TINY_FRAME_WITH_LEN16_LENGTH_BYTES = 2;

/**
 * TinyFrameWithLen16 Encode Buffer
 */
class TinyFrameWithLen16EncodeBuffer {
public:
    TinyFrameWithLen16EncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = TINY_FRAME_WITH_LEN16_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = TINY_FRAME_WITH_LEN16_START_BYTE;
        packet_start[1] = msg_id;
        packet_start[2] = static_cast<uint8_t>(msg_size & 0xFF);
        packet_start[3] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + TINY_FRAME_WITH_LEN16_HEADER_SIZE, msg, msg_size);
        }

        // Calculate checksum
        FrameChecksum ck = fletcher_checksum(packet_start + 1, msg_size + 1 + 2);
        packet_start[TINY_FRAME_WITH_LEN16_HEADER_SIZE + msg_size] = ck.byte1;
        packet_start[TINY_FRAME_WITH_LEN16_HEADER_SIZE + msg_size + 1] = ck.byte2;

        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * TinyFrameWithLen16 Frame Parser
 */
class TinyFrameWithLen16Parser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    TinyFrameWithLen16Parser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(TinyFrameWithLen16ParserState::LookingForStart),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          msg_length_(0),
          length_lo_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = TinyFrameWithLen16ParserState::LookingForStart;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
        msg_length_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case TinyFrameWithLen16ParserState::LookingForStart:
                if (byte == TINY_FRAME_WITH_LEN16_START_BYTE) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = TinyFrameWithLen16ParserState::GettingMsgId;
                }
                break;

            case TinyFrameWithLen16ParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                state_ = TinyFrameWithLen16ParserState::GettingLength;
                break;
            }

            case TinyFrameWithLen16ParserState::GettingLength:
                buffer_[buffer_index_++] = byte;
                if (buffer_index_ == 3) {
                    length_lo_ = byte;
                } else {
                    msg_length_ = length_lo_ | (static_cast<size_t>(byte) << 8);
                    packet_size_ = TINY_FRAME_WITH_LEN16_OVERHEAD + msg_length_;
                    if (packet_size_ <= buffer_max_size_) {
                        state_ = TinyFrameWithLen16ParserState::GettingPayload;
                    } else {
                        state_ = TinyFrameWithLen16ParserState::LookingForStart;
                    }
                }
                break;

            case TinyFrameWithLen16ParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    // Validate checksum
                    size_t msg_length = packet_size_ - TINY_FRAME_WITH_LEN16_OVERHEAD;
                    FrameChecksum ck = fletcher_checksum(buffer_ + 1, msg_length + 1 + 2);

                    if (ck.byte1 == buffer_[packet_size_ - 2] &&
                        ck.byte2 == buffer_[packet_size_ - 1]) {
                        result.valid = true;
                        result.msg_id = msg_id_;
                        result.msg_len = msg_length;
                        result.msg_data = buffer_ + TINY_FRAME_WITH_LEN16_HEADER_SIZE;
                    }
                    state_ = TinyFrameWithLen16ParserState::LookingForStart;
                }
                break;
        }

        return result;
    }

private:
    TinyFrameWithLen16ParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    size_t msg_length_;
    uint8_t length_lo_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with TinyFrameWithLen16 format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t tiny_frame_with_len16_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = TINY_FRAME_WITH_LEN16_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = TINY_FRAME_WITH_LEN16_START_BYTE;
    buffer[1] = msg_id;
    buffer[2] = static_cast<uint8_t>(msg_size & 0xFF);
    buffer[3] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + TINY_FRAME_WITH_LEN16_HEADER_SIZE, msg, msg_size);
    }

    FrameChecksum ck = fletcher_checksum(buffer + 1, msg_size + 1 + 2);
    buffer[TINY_FRAME_WITH_LEN16_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[TINY_FRAME_WITH_LEN16_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete TinyFrameWithLen16 packet in a buffer
 */
inline FrameMsgInfo tiny_frame_with_len16_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < TINY_FRAME_WITH_LEN16_OVERHEAD) return result;

    if (buffer[0] != TINY_FRAME_WITH_LEN16_START_BYTE) return result;

    size_t msg_length = length - TINY_FRAME_WITH_LEN16_OVERHEAD;

    FrameChecksum ck = fletcher_checksum(buffer + 1, msg_length + 1 + 2);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = const_cast<uint8_t*>(buffer + TINY_FRAME_WITH_LEN16_HEADER_SIZE);
    }

    return result;
}

}  // namespace FrameParsers
