// Automatically generated frame parser
// Generated by 0.0.1 at Wed Dec  3 17:57:16 2025.

import { FrameMsgInfo, createFrameMsgInfo, fletcher_checksum } from './frame_base';

// =============================================================================
// TinyFrameWithLen16NoCrc Frame Format
// =============================================================================

export enum TinyFrameWithLen16NoCrcParserState {
    LOOKING_FOR_START = 0,
    GETTING_MSG_ID = 1,
    GETTING_LENGTH = 2,
    GETTING_PAYLOAD = 3
}

/**
 * TinyFrameWithLen16NoCrc - Frame format parser and encoder
 * 
 * Format: [START_BYTE=0x75] [MSG_ID] [LEN16] [MSG...]
 */
export class TinyFrameWithLen16NoCrc {
    static readonly START_BYTE = 0x75;
    static readonly HEADER_SIZE = 4;
    static readonly FOOTER_SIZE = 0;
    static readonly OVERHEAD = 4;
    static readonly LENGTH_BYTES = 2;

    private state: TinyFrameWithLen16NoCrcParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private length_lo: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new TinyFrameWithLen16NoCrc parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = TinyFrameWithLen16NoCrcParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = TinyFrameWithLen16NoCrcParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case TinyFrameWithLen16NoCrcParserState.LOOKING_FOR_START:
                if (byte === TinyFrameWithLen16NoCrc.START_BYTE) {
                    this.buffer = [byte];
                    this.state = TinyFrameWithLen16NoCrcParserState.GETTING_MSG_ID;
                }
                break;

            case TinyFrameWithLen16NoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = TinyFrameWithLen16NoCrcParserState.GETTING_LENGTH;
                break;

            case TinyFrameWithLen16NoCrcParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                if (this.buffer.length === 3) {
                    this.length_lo = byte;
                } else {
                    this.msg_length = this.length_lo | (byte << 8);
                    this.packet_size = TinyFrameWithLen16NoCrc.OVERHEAD + this.msg_length;
                    this.state = TinyFrameWithLen16NoCrcParserState.GETTING_PAYLOAD;
                }
                break;

            case TinyFrameWithLen16NoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - TinyFrameWithLen16NoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(TinyFrameWithLen16NoCrc.HEADER_SIZE));
                    this.state = TinyFrameWithLen16NoCrcParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with TinyFrameWithLen16NoCrc format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(TinyFrameWithLen16NoCrc.START_BYTE);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    /**
     * Validate a complete TinyFrameWithLen16NoCrc packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < TinyFrameWithLen16NoCrc.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== TinyFrameWithLen16NoCrc.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - TinyFrameWithLen16NoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, TinyFrameWithLen16NoCrc.HEADER_SIZE));

        return result;
    }
}
