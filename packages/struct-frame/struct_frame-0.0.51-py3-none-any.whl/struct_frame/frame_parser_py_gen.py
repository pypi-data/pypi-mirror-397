#!/usr/bin/env python3
# kate: replace-tabs on; indent-width 4;

"""
Python Frame Parser Generator

Generates Python code for frame parsers based on frame format definitions.
"""

from struct_frame import version
import time


def camel_to_snake(name):
    """Convert CamelCase to snake_case"""
    import re
    name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', name)
    return name.lower()


def camel_to_upper_snake(name):
    """Convert CamelCase to UPPER_SNAKE_CASE"""
    return camel_to_snake(name).upper()


class FrameParserPyGen:
    """Generates Python code for frame parsers"""

    @staticmethod
    def generate_base(formats):
        """Generate the base Python file with common utilities"""
        yield '# Automatically generated frame parser base utilities\n'
        yield f'# Generated by {version} at {time.asctime()}.\n\n'
        yield 'from enum import Enum\n'
        yield 'from typing import Callable, List, Tuple, Union\n'
        yield 'from dataclasses import dataclass\n\n'

        # Generate frame format enum
        yield '# Frame format type enumeration\n'
        yield 'class FrameFormatType(Enum):\n'
        for i, fmt in enumerate(formats):
            enum_name = camel_to_upper_snake(fmt.name)
            yield f'    {enum_name} = {i}\n'
        yield '\n\n'

        # Generate checksum function
        yield '''def fletcher_checksum(buffer: Union[bytes, List[int]], start: int = 0, end: int = None) -> Tuple[int, int]:
    """Calculate Fletcher-16 checksum over the given data"""
    if end is None:
        end = len(buffer)

    byte1 = 0
    byte2 = 0

    for x in range(start, end):
        byte1 = (byte1 + buffer[x]) % 256
        byte2 = (byte2 + byte1) % 256

    return (byte1, byte2)


'''

        # Generate common result class
        yield '''@dataclass
class FrameMsgInfo:
    """Parse result containing message information"""
    valid: bool = False
    msg_id: int = 0
    msg_len: int = 0
    msg_data: bytes = b\'\'


'''

        # Generate shared payload validation functions
        yield '''# =============================================================================
# Shared Payload Parsing Functions
# =============================================================================
# These functions handle payload validation/encoding independent of framing.
# Frame formats (Tiny/Basic) use these for the common parsing logic.

def validate_payload_with_crc(buffer: Union[bytes, List[int]], header_size: int,
                              length_bytes: int, crc_start_offset: int = 0) -> FrameMsgInfo:
    """
    Validate a payload with CRC (shared by Default, Extended, etc. payload types).
    
    Args:
        buffer: Complete packet buffer (including any start bytes)
        header_size: Size of header (start_bytes + length + msg_id + extra fields)
        length_bytes: Number of length bytes (1 or 2)
        crc_start_offset: Offset from start of buffer where CRC calculation begins
        
    Returns:
        FrameMsgInfo with valid=True if checksum matches
    """
    result = FrameMsgInfo()
    footer_size = 2  # CRC is always 2 bytes
    overhead = header_size + footer_size
    
    if len(buffer) < overhead:
        return result
    
    msg_length = len(buffer) - overhead
    
    # Calculate expected CRC range: from crc_start_offset to before the CRC bytes
    crc_data_len = msg_length + 1 + length_bytes  # msg_id (1) + length_bytes + payload
    ck = fletcher_checksum(buffer, crc_start_offset, crc_start_offset + crc_data_len)
    
    if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
        result.valid = True
        result.msg_id = buffer[header_size - 1]  # msg_id is last byte of header
        result.msg_len = msg_length
        result.msg_data = bytes(buffer[header_size:len(buffer) - footer_size])
    
    return result


def validate_payload_minimal(buffer: Union[bytes, List[int]], header_size: int) -> FrameMsgInfo:
    """
    Validate a minimal payload (no CRC, no length field).
    
    Args:
        buffer: Complete packet buffer (including any start bytes)
        header_size: Size of header (start_bytes + msg_id)
        
    Returns:
        FrameMsgInfo with packet data
    """
    result = FrameMsgInfo()
    
    if len(buffer) < header_size:
        return result
    
    result.valid = True
    result.msg_id = buffer[header_size - 1]  # msg_id is last byte of header
    result.msg_len = len(buffer) - header_size
    result.msg_data = bytes(buffer[header_size:])
    
    return result


def encode_payload_with_crc(output: list, msg_id: int, msg: bytes,
                            length_bytes: int, crc_start_offset: int) -> None:
    """
    Encode payload with length and CRC (modifies output list in place).
    
    Args:
        output: Output list to append to (already contains start bytes)
        msg_id: Message ID
        msg: Message payload data
        length_bytes: Number of length bytes (1 or 2)
        crc_start_offset: Offset in output where CRC calculation begins
    """
    # Add length field
    if length_bytes == 1:
        output.append(len(msg) & 0xFF)
    else:
        output.append(len(msg) & 0xFF)
        output.append((len(msg) >> 8) & 0xFF)
    
    # Add msg_id
    output.append(msg_id)
    
    # Add payload
    output.extend(msg)
    
    # Calculate and add CRC
    crc_data_len = len(msg) + 1 + length_bytes
    ck = fletcher_checksum(output, crc_start_offset, crc_start_offset + crc_data_len)
    output.append(ck[0])
    output.append(ck[1])


def encode_payload_minimal(output: list, msg_id: int, msg: bytes) -> None:
    """
    Encode minimal payload (no length, no CRC).
    
    Args:
        output: Output list to append to (already contains start bytes)
        msg_id: Message ID
        msg: Message payload data
    """
    output.append(msg_id)
    output.extend(msg)


# =============================================================================
# Frame Parser Configuration
# =============================================================================

@dataclass
class FrameParserConfig:
    """
    Configuration interface for frame format parsers.
    This allows code reuse through configuration instead of code generation.
    """
    name: str
    start_bytes: Tuple[int, ...]
    header_size: int
    footer_size: int
    has_length: bool
    length_bytes: int
    has_crc: bool


# =============================================================================
# Generic Frame Parser
# =============================================================================
# This class provides a reusable frame parser that can be configured
# for different frame formats, reducing code duplication.

class GenericParserState(Enum):
    """Parser state enumeration"""
    LOOKING_FOR_START1 = 0
    LOOKING_FOR_START2 = 1
    GETTING_MSG_ID = 2
    GETTING_LENGTH = 3
    GETTING_PAYLOAD = 4


class GenericFrameParser:
    """
    Generic frame parser that works with any frame format configuration.
    This class eliminates the need for separate parser classes per format.
    """
    
    def __init__(self, config: FrameParserConfig, get_msg_length: Callable[[int], int] = None):
        self.config = config
        self.get_msg_length = get_msg_length
        self.reset()
    
    def _get_initial_state(self) -> GenericParserState:
        if len(self.config.start_bytes) == 0:
            return GenericParserState.GETTING_MSG_ID
        else:
            return GenericParserState.LOOKING_FOR_START1
    
    def reset(self):
        """Reset parser state"""
        self.state = self._get_initial_state()
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0
        self.length_lo = 0
    
    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()
        start_bytes = self.config.start_bytes
        overhead = self.config.header_size + self.config.footer_size

        if self.state == GenericParserState.LOOKING_FOR_START1:
            if byte == start_bytes[0]:
                self.buffer = [byte]
                if len(start_bytes) > 1:
                    self.state = GenericParserState.LOOKING_FOR_START2
                else:
                    self.state = GenericParserState.GETTING_MSG_ID
        
        elif self.state == GenericParserState.LOOKING_FOR_START2:
            if byte == start_bytes[1]:
                self.buffer.append(byte)
                self.state = GenericParserState.GETTING_MSG_ID
            elif byte == start_bytes[0]:
                self.buffer = [byte]
                # Stay in LOOKING_FOR_START2
            else:
                self.state = GenericParserState.LOOKING_FOR_START1
        
        elif self.state == GenericParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            if self.config.has_length:
                self.state = GenericParserState.GETTING_LENGTH
            elif self.get_msg_length:
                msg_len = self.get_msg_length(byte)
                if msg_len is not None:
                    self.packet_size = overhead + msg_len
                    self.state = GenericParserState.GETTING_PAYLOAD
                else:
                    self.state = self._get_initial_state()
            else:
                self.state = self._get_initial_state()
        
        elif self.state == GenericParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            if self.config.length_bytes == 1:
                self.msg_length = byte
                self.packet_size = overhead + self.msg_length
                self.state = GenericParserState.GETTING_PAYLOAD
            else:
                # 2-byte length
                if len(self.buffer) == len(start_bytes) + 2:
                    self.length_lo = byte
                else:
                    self.msg_length = self.length_lo | (byte << 8)
                    self.packet_size = overhead + self.msg_length
                    self.state = GenericParserState.GETTING_PAYLOAD
        
        elif self.state == GenericParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)
            if len(self.buffer) >= self.packet_size:
                if self.config.has_crc:
                    result = validate_payload_with_crc(
                        self.buffer, self.config.header_size, 
                        self.config.length_bytes, len(start_bytes))
                else:
                    result = validate_payload_minimal(self.buffer, self.config.header_size)
                self.state = self._get_initial_state()
        
        return result
    
    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message using this format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = list(self.config.start_bytes)
        
        if self.config.has_crc:
            encode_payload_with_crc(output, msg_id, msg, 
                                   self.config.length_bytes, len(self.config.start_bytes))
        else:
            encode_payload_minimal(output, msg_id, msg)
        
        return bytes(output)
    
    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())
    
    @staticmethod
    def validate_packet(config: FrameParserConfig, buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete packet in a buffer
        
        Args:
            config: Frame format configuration
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        overhead = config.header_size + config.footer_size
        
        if len(buffer) < overhead:
            return FrameMsgInfo()
        
        # Check start bytes
        for i, start_byte in enumerate(config.start_bytes):
            if buffer[i] != start_byte:
                return FrameMsgInfo()
        
        # Validate payload
        if config.has_crc:
            return validate_payload_with_crc(buffer, config.header_size, 
                                            config.length_bytes, len(config.start_bytes))
        else:
            return validate_payload_minimal(buffer, config.header_size)


def create_frame_parser_class(config: FrameParserConfig):
    """
    Create a frame parser class for a specific configuration.
    This factory function provides pre-configured parser classes.
    """
    class ConfiguredFrameParser(GenericFrameParser):
        # Class attributes from config
        CONFIG = config
        START_BYTES = config.start_bytes
        HEADER_SIZE = config.header_size
        FOOTER_SIZE = config.footer_size
        OVERHEAD = config.header_size + config.footer_size
        HAS_LENGTH = config.has_length
        LENGTH_BYTES = config.length_bytes
        HAS_CRC = config.has_crc
        
        def __init__(self, get_msg_length: Callable[[int], int] = None):
            super().__init__(config, get_msg_length)
        
        @staticmethod
        def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
            return GenericFrameParser.validate_packet(config, buffer)
    
    ConfiguredFrameParser.__name__ = config.name
    ConfiguredFrameParser.__qualname__ = config.name
    return ConfiguredFrameParser
'''

    @staticmethod
    def generate_format_file(fmt):
        """Generate a Python file for a single frame format using configuration-based approach"""
        name = fmt.name
        snake_name = camel_to_snake(name)
        
        yield '# Automatically generated frame parser\n'
        yield f'# Generated by {version} at {time.asctime()}.\n\n'
        yield 'from .frame_base import (\n'
        yield '    FrameParserConfig, create_frame_parser_class, GenericParserState,\n'
        yield ')\n\n'

        # Generate configuration object
        yield f'# =============================================================================\n'
        yield f'# {name} Frame Format Configuration\n'
        yield f'# =============================================================================\n\n'
        
        yield f'# Configuration for {name} frame format\n'
        
        # Start bytes tuple
        start_bytes_str = ', '.join([f'0x{sb[1]:02X}' for sb in fmt.start_bytes])
        if len(fmt.start_bytes) <= 1:
            start_bytes_str += ','  # Single element tuple needs trailing comma
        
        yield f'{name}Config = FrameParserConfig(\n'
        yield f'    name=\'{name}\',\n'
        yield f'    start_bytes=({start_bytes_str}),\n'
        yield f'    header_size={fmt.header_size},\n'
        yield f'    footer_size={fmt.footer_size},\n'
        yield f'    has_length={fmt.has_length},\n'
        yield f'    length_bytes={fmt.length_bytes},\n'
        yield f'    has_crc={fmt.has_crc},\n'
        yield ')\n\n'
        
        # Generate the class using the factory function
        yield f'\"\"\"\n'
        yield f'{name} - Frame format parser and encoder\n'
        yield f'\n'
        yield f'Format: '
        parts = []
        for sb_name, sb_value in fmt.start_bytes:
            parts.append(f'[{sb_name.upper()}=0x{sb_value:02X}]')
        parts.append('[MSG_ID]')
        if fmt.has_length:
            parts.append(f'[LEN{"16" if fmt.length_bytes == 2 else ""}]')
        parts.append('[MSG...]')
        if fmt.has_crc:
            parts.append('[CRC1] [CRC2]')
        yield ' '.join(parts)
        yield '\n\n'
        yield f'This class is generated using create_frame_parser_class() for code reuse.\n'
        yield f'\"\"\"\n'
        yield f'{name} = create_frame_parser_class({name}Config)\n\n'
        
        # Export parser state alias for backward compatibility
        yield f'# Parser state alias for backward compatibility\n'
        yield f'{name}ParserState = GenericParserState\n'

    @staticmethod
    def generate_init(formats):
        """Generate __init__.py that exports all frame formats"""
        yield '# Automatically generated frame parser package\n'
        yield f'# Generated by {version} at {time.asctime()}.\n\n'
        yield '# Base utilities and generic parser infrastructure\n'
        yield 'from .frame_base import (\n'
        yield '    FrameFormatType,\n'
        yield '    FrameMsgInfo,\n'
        yield '    fletcher_checksum,\n'
        yield '    # Configuration interface for code reuse\n'
        yield '    FrameParserConfig,\n'
        yield '    # Generic parser class (use create_frame_parser_class for type-safe wrappers)\n'
        yield '    GenericFrameParser,\n'
        yield '    GenericParserState,\n'
        yield '    create_frame_parser_class,\n'
        yield '    # Shared payload parsing functions\n'
        yield '    validate_payload_with_crc,\n'
        yield '    validate_payload_minimal,\n'
        yield '    encode_payload_with_crc,\n'
        yield '    encode_payload_minimal,\n'
        yield ')\n\n'

        yield '# Individual frame format parsers (configuration-based)\n'
        for fmt in formats:
            snake_name = camel_to_snake(fmt.name)
            yield f'from .{snake_name} import {fmt.name}, {fmt.name}Config, {fmt.name}ParserState\n'

        yield '\n# Re-export all frame formats\n'
        yield '__all__ = [\n'
        yield '    # Base utilities\n'
        yield '    "FrameFormatType",\n'
        yield '    "FrameMsgInfo",\n'
        yield '    "fletcher_checksum",\n'
        yield '    # Configuration and generic parser\n'
        yield '    "FrameParserConfig",\n'
        yield '    "GenericFrameParser",\n'
        yield '    "GenericParserState",\n'
        yield '    "create_frame_parser_class",\n'
        yield '    # Shared payload parsing functions\n'
        yield '    "validate_payload_with_crc",\n'
        yield '    "validate_payload_minimal",\n'
        yield '    "encode_payload_with_crc",\n'
        yield '    "encode_payload_minimal",\n'
        yield '    # Frame formats\n'
        for fmt in formats:
            yield f'    "{fmt.name}",\n'
            yield f'    "{fmt.name}Config",\n'
            yield f'    "{fmt.name}ParserState",\n'
        yield ']\n'

    @staticmethod
    def generate(formats):
        """Generate the complete frame parser Python file (single file, legacy mode)"""
        yield '# Automatically generated frame parser\n'
        yield f'# Generated by {version} at {time.asctime()}.\n\n'
        yield 'from enum import Enum\n'
        yield 'from typing import Optional, Callable, Dict, List, Tuple, Union\n'
        yield 'from dataclasses import dataclass\n\n'
        
        # Generate frame format enum
        yield '# Frame format type enumeration\n'
        yield 'class FrameFormatType(Enum):\n'
        for i, fmt in enumerate(formats):
            enum_name = camel_to_upper_snake(fmt.name)
            yield f'    {enum_name} = {i}\n'
        yield '\n\n'
        
        # Generate checksum function
        yield '''def fletcher_checksum(buffer: Union[bytes, List[int]], start: int = 0, end: int = None) -> Tuple[int, int]:
    """Calculate Fletcher-16 checksum over the given data"""
    if end is None:
        end = len(buffer)
    
    byte1 = 0
    byte2 = 0
    
    for x in range(start, end):
        byte1 = (byte1 + buffer[x]) % 256
        byte2 = (byte2 + byte1) % 256
    
    return (byte1, byte2)


'''
        
        # Generate common result class
        yield '''@dataclass
class FrameMsgInfo:
    """Parse result containing message information"""
    valid: bool = False
    msg_id: int = 0
    msg_len: int = 0
    msg_data: bytes = b''


'''

        # Generate shared payload parsing functions
        yield '''# =============================================================================
# Shared Payload Parsing Functions
# =============================================================================
# These functions handle payload validation/encoding independent of framing.
# Frame formats (Tiny/Basic) use these for the common parsing logic.

def validate_payload_with_crc(buffer: Union[bytes, List[int]], header_size: int,
                              length_bytes: int, crc_start_offset: int = 0) -> FrameMsgInfo:
    """
    Validate a payload with CRC (shared by Default, Extended, etc. payload types).
    
    Args:
        buffer: Complete packet buffer (including any start bytes)
        header_size: Size of header (start_bytes + length + msg_id + extra fields)
        length_bytes: Number of length bytes (1 or 2)
        crc_start_offset: Offset from start of buffer where CRC calculation begins
        
    Returns:
        FrameMsgInfo with valid=True if checksum matches
    """
    result = FrameMsgInfo()
    footer_size = 2  # CRC is always 2 bytes
    overhead = header_size + footer_size
    
    if len(buffer) < overhead:
        return result
    
    msg_length = len(buffer) - overhead
    
    # Calculate expected CRC range: from crc_start_offset to before the CRC bytes
    crc_data_len = msg_length + 1 + length_bytes  # msg_id (1) + length_bytes + payload
    ck = fletcher_checksum(buffer, crc_start_offset, crc_start_offset + crc_data_len)
    
    if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
        result.valid = True
        result.msg_id = buffer[header_size - 1]  # msg_id is last byte of header
        result.msg_len = msg_length
        result.msg_data = bytes(buffer[header_size:len(buffer) - footer_size])
    
    return result


def validate_payload_minimal(buffer: Union[bytes, List[int]], header_size: int) -> FrameMsgInfo:
    """
    Validate a minimal payload (no CRC, no length field).
    
    Args:
        buffer: Complete packet buffer (including any start bytes)
        header_size: Size of header (start_bytes + msg_id)
        
    Returns:
        FrameMsgInfo with packet data
    """
    result = FrameMsgInfo()
    
    if len(buffer) < header_size:
        return result
    
    result.valid = True
    result.msg_id = buffer[header_size - 1]  # msg_id is last byte of header
    result.msg_len = len(buffer) - header_size
    result.msg_data = bytes(buffer[header_size:])
    
    return result


def encode_payload_with_crc(output: list, msg_id: int, msg: bytes,
                            length_bytes: int, crc_start_offset: int) -> None:
    """
    Encode payload with length and CRC (modifies output list in place).
    
    Args:
        output: Output list to append to (already contains start bytes)
        msg_id: Message ID
        msg: Message payload data
        length_bytes: Number of length bytes (1 or 2)
        crc_start_offset: Offset in output where CRC calculation begins
    """
    # Add length field
    if length_bytes == 1:
        output.append(len(msg) & 0xFF)
    else:
        output.append(len(msg) & 0xFF)
        output.append((len(msg) >> 8) & 0xFF)
    
    # Add msg_id
    output.append(msg_id)
    
    # Add payload
    output.extend(msg)
    
    # Calculate and add CRC
    crc_data_len = len(msg) + 1 + length_bytes
    ck = fletcher_checksum(output, crc_start_offset, crc_start_offset + crc_data_len)
    output.append(ck[0])
    output.append(ck[1])


def encode_payload_minimal(output: list, msg_id: int, msg: bytes) -> None:
    """
    Encode minimal payload (no length, no CRC).
    
    Args:
        output: Output list to append to (already contains start bytes)
        msg_id: Message ID
        msg: Message payload data
    """
    output.append(msg_id)
    output.extend(msg)


'''
        
        # Generate individual frame format classes
        for fmt in formats:
            yield from FrameParserPyGen.generate_format(fmt)
            yield '\n\n'
            
    @staticmethod
    def generate_format(fmt):
        """Generate Python code for a single frame format"""
        name = fmt.name
        class_name = name
        prefix = camel_to_snake(name)
        PREFIX = camel_to_upper_snake(name)
        
        yield f'# =============================================================================\n'
        yield f'# {name} Frame Format\n'
        yield f'# =============================================================================\n\n'
        
        # Generate parser state enum
        yield f'class {class_name}ParserState(Enum):\n'
        state_idx = 0
        if fmt.start_bytes:
            for i in range(len(fmt.start_bytes)):
                state_name = f'LOOKING_FOR_START{i + 1}' if len(fmt.start_bytes) > 1 else 'LOOKING_FOR_START'
                yield f'    {state_name} = {state_idx}\n'
                state_idx += 1
        yield f'    GETTING_MSG_ID = {state_idx}\n'
        state_idx += 1
        if fmt.has_length:
            yield f'    GETTING_LENGTH = {state_idx}\n'
            state_idx += 1
        yield f'    GETTING_PAYLOAD = {state_idx}\n\n\n'
        
        # Generate frame format class
        yield f'class {class_name}:\n'
        yield f'    """\n'
        yield f'    {name} - Frame format parser and encoder\n'
        yield f'    \n'
        yield f'    Format: '
        parts = []
        for sb_name, sb_value in fmt.start_bytes:
            parts.append(f'[{sb_name.upper()}=0x{sb_value:02X}]')
        parts.append('[MSG_ID]')
        if fmt.has_length:
            parts.append(f'[LEN{"16" if fmt.length_bytes == 2 else ""}]')
        parts.append('[MSG...]')
        if fmt.has_crc:
            parts.append('[CRC1] [CRC2]')
        yield ' '.join(parts)
        yield '\n    """\n\n'
        
        # Constants
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            const_name = f'START_BYTE{i + 1}' if len(fmt.start_bytes) > 1 else 'START_BYTE'
            yield f'    {const_name} = 0x{sb_value:02X}\n'
        yield f'    HEADER_SIZE = {fmt.header_size}\n'
        yield f'    FOOTER_SIZE = {fmt.footer_size}\n'
        yield f'    OVERHEAD = {fmt.header_size + fmt.footer_size}\n'
        if fmt.has_length:
            yield f'    LENGTH_BYTES = {fmt.length_bytes}\n'
        yield '\n'
        
        # __init__
        yield f'    def __init__(self, get_msg_length: Callable[[int], int] = None):\n'
        yield f'        """\n'
        yield f'        Initialize the {name} parser\n'
        yield f'        \n'
        yield f'        Args:\n'
        yield f'            get_msg_length: Callback function to get message length from msg_id\n'
        yield f'                            Required for formats without a length field\n'
        yield f'        """\n'
        yield f'        self.get_msg_length = get_msg_length\n'
        yield f'        self.reset()\n\n'
        
        # reset method
        yield f'    def reset(self):\n'
        yield f'        """Reset parser state"""\n'
        if fmt.start_bytes:
            state_name = 'LOOKING_FOR_START1' if len(fmt.start_bytes) > 1 else 'LOOKING_FOR_START'
            yield f'        self.state = {class_name}ParserState.{state_name}\n'
        else:
            yield f'        self.state = {class_name}ParserState.GETTING_MSG_ID\n'
        yield f'        self.buffer = []\n'
        yield f'        self.packet_size = 0\n'
        yield f'        self.msg_id = 0\n'
        if fmt.has_length:
            yield f'        self.msg_length = 0\n'
            if fmt.length_bytes == 2:
                yield f'        self.length_lo = 0\n'
        yield '\n'
        
        # parse_byte method
        yield f'    def parse_byte(self, byte: int) -> FrameMsgInfo:\n'
        yield f'        """\n'
        yield f'        Parse a single byte\n'
        yield f'        \n'
        yield f'        Returns:\n'
        yield f'            FrameMsgInfo with valid=True when a complete valid message is received\n'
        yield f'        """\n'
        yield f'        result = FrameMsgInfo()\n\n'
        
        # State machine
        if fmt.start_bytes:
            for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
                state_name = f'LOOKING_FOR_START{i + 1}' if len(fmt.start_bytes) > 1 else 'LOOKING_FOR_START'
                const_name = f'self.START_BYTE{i + 1}' if len(fmt.start_bytes) > 1 else 'self.START_BYTE'
                
                # First state uses 'if', subsequent states use 'elif'
                keyword = 'if' if i == 0 else 'elif'
                yield f'        {keyword} self.state == {class_name}ParserState.{state_name}:\n'
                yield f'            if byte == {const_name}:\n'
                
                if i == 0:
                    yield f'                self.buffer = [byte]\n'
                else:
                    yield f'                self.buffer.append(byte)\n'
                    
                if i + 1 < len(fmt.start_bytes):
                    next_state = f'LOOKING_FOR_START{i + 2}'
                else:
                    next_state = 'GETTING_MSG_ID'
                yield f'                self.state = {class_name}ParserState.{next_state}\n'
                
                # Handle seeing start byte 1 while looking for later bytes
                # This code only runs when len(fmt.start_bytes) > 1 (i.e., i > 0 is only possible with 2+ start bytes)
                if i > 0:
                    yield f'            elif byte == self.START_BYTE1:\n'
                    yield f'                self.buffer = [byte]\n'
                    yield f'                self.state = {class_name}ParserState.LOOKING_FOR_START2\n'
                    yield f'            else:\n'
                    yield f'                self.state = {class_name}ParserState.LOOKING_FOR_START1\n'
                yield '\n'
        
        # GETTING_MSG_ID state
        if fmt.start_bytes:
            yield f'        elif self.state == {class_name}ParserState.GETTING_MSG_ID:\n'
        else:
            yield f'        if self.state == {class_name}ParserState.GETTING_MSG_ID:\n'
        yield f'            self.buffer.append(byte)\n'
        yield f'            self.msg_id = byte\n'
        
        if fmt.has_length:
            yield f'            self.state = {class_name}ParserState.GETTING_LENGTH\n'
        else:
            yield f'            if self.get_msg_length:\n'
            yield f'                msg_length = self.get_msg_length(byte)\n'
            yield f'                if msg_length is not None:\n'
            yield f'                    self.packet_size = self.OVERHEAD + msg_length\n'
            yield f'                    self.state = {class_name}ParserState.GETTING_PAYLOAD\n'
            yield f'                else:\n'
            reset_state = 'LOOKING_FOR_START1' if len(fmt.start_bytes) > 1 else ('LOOKING_FOR_START' if fmt.start_bytes else 'GETTING_MSG_ID')
            yield f'                    self.state = {class_name}ParserState.{reset_state}\n'
            yield f'            else:\n'
            yield f'                self.state = {class_name}ParserState.{reset_state}\n'
        yield '\n'
        
        # GETTING_LENGTH state (if applicable)
        if fmt.has_length:
            yield f'        elif self.state == {class_name}ParserState.GETTING_LENGTH:\n'
            yield f'            self.buffer.append(byte)\n'
            if fmt.length_bytes == 1:
                yield f'            self.msg_length = byte\n'
                yield f'            self.packet_size = self.OVERHEAD + self.msg_length\n'
                yield f'            self.state = {class_name}ParserState.GETTING_PAYLOAD\n'
            else:
                yield f'            if len(self.buffer) == {len(fmt.start_bytes) + 2}:\n'
                yield f'                self.length_lo = byte\n'
                yield f'            else:\n'
                yield f'                self.msg_length = self.length_lo | (byte << 8)\n'
                yield f'                self.packet_size = self.OVERHEAD + self.msg_length\n'
                yield f'                self.state = {class_name}ParserState.GETTING_PAYLOAD\n'
            yield '\n'
        
        # GETTING_PAYLOAD state - uses shared payload validation
        yield f'        elif self.state == {class_name}ParserState.GETTING_PAYLOAD:\n'
        yield f'            self.buffer.append(byte)\n\n'
        yield f'            if len(self.buffer) >= self.packet_size:\n'
        
        if fmt.has_crc:
            crc_start = len(fmt.start_bytes)
            yield f'                # Use shared payload validation with CRC\n'
            yield f'                result = validate_payload_with_crc(self.buffer, self.HEADER_SIZE, {fmt.length_bytes}, {crc_start})\n'
        else:
            yield f'                # Use shared minimal payload validation\n'
            yield f'                result = validate_payload_minimal(self.buffer, self.HEADER_SIZE)\n'
        
        reset_state = 'LOOKING_FOR_START1' if len(fmt.start_bytes) > 1 else ('LOOKING_FOR_START' if fmt.start_bytes else 'GETTING_MSG_ID')
        yield f'                self.state = {class_name}ParserState.{reset_state}\n'
        yield '\n'
        yield f'        return result\n\n'
        
        # encode method - uses shared payload encoding functions
        yield f'    def encode(self, msg_id: int, msg: bytes) -> bytes:\n'
        yield f'        """\n'
        yield f'        Encode a message with {name} format\n'
        yield f'        \n'
        yield f'        Args:\n'
        yield f'            msg_id: Message ID\n'
        yield f'            msg: Message data bytes\n'
        yield f'        \n'
        yield f'        Returns:\n'
        yield f'            Encoded frame as bytes\n'
        yield f'        """\n'
        yield f'        output = []\n'
        
        # Write start bytes (frame-specific)
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            const_name = f'self.START_BYTE{i + 1}' if len(fmt.start_bytes) > 1 else 'self.START_BYTE'
            yield f'        output.append({const_name})\n'
        
        # Use shared payload encoding function
        if fmt.has_crc:
            crc_start = len(fmt.start_bytes)
            yield f'        # Use shared payload encoding with CRC\n'
            yield f'        encode_payload_with_crc(output, msg_id, msg, {fmt.length_bytes}, {crc_start})\n'
        else:
            yield f'        # Use shared minimal payload encoding\n'
            yield f'        encode_payload_minimal(output, msg_id, msg)\n'
        
        yield f'        return bytes(output)\n\n'
        
        # encode_msg method (for message objects with msg_id and pack())
        yield f'    def encode_msg(self, msg) -> bytes:\n'
        yield f'        """Encode a message object (must have msg_id and pack() method)"""\n'
        yield f'        return self.encode(msg.msg_id, msg.pack())\n\n'
        
        # validate_packet method - uses shared payload validation functions
        yield f'    @staticmethod\n'
        yield f'    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:\n'
        yield f'        """\n'
        yield f'        Validate a complete {name} packet in a buffer\n'
        yield f'        \n'
        yield f'        Args:\n'
        yield f'            buffer: Buffer containing the complete packet\n'
        yield f'        \n'
        yield f'        Returns:\n'
        yield f'            FrameMsgInfo with valid=True if packet is valid\n'
        yield f'        """\n'
        yield f'        if len(buffer) < {class_name}.OVERHEAD:\n'
        yield f'            return FrameMsgInfo()\n\n'
        
        # Check start bytes
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            const_name = f'{class_name}.START_BYTE{i + 1}' if len(fmt.start_bytes) > 1 else f'{class_name}.START_BYTE'
            yield f'        if buffer[{i}] != {const_name}:\n'
            yield f'            return FrameMsgInfo()\n'
        
        yield f'\n'
        
        # Use shared payload validation function
        if fmt.has_crc:
            crc_start = len(fmt.start_bytes)
            yield f'        # Use shared payload validation with CRC\n'
            yield f'        return validate_payload_with_crc(buffer, {class_name}.HEADER_SIZE, {fmt.length_bytes}, {crc_start})\n'
        else:
            yield f'        # Use shared minimal payload validation\n'
            yield f'        return validate_payload_minimal(buffer, {class_name}.HEADER_SIZE)\n'


def generate_py_frame_parsers(formats):
    """Generate Python frame parser code from frame format definitions"""
    return ''.join(FrameParserPyGen.generate(formats))


def generate_py_frame_parsers_multi(formats):
    """
    Generate multiple Python files for frame parsers.

    Returns a dictionary mapping filename to content:
    - frame_base.py: Base utilities (checksum, FrameMsgInfo, FrameFormatType)
    - {snake_name}.py: Individual frame format files
    - __init__.py: Package init that exports all frame formats
    """
    files = {}

    # Generate base file
    files['frame_base.py'] = ''.join(FrameParserPyGen.generate_base(formats))

    # Generate individual frame format files
    for fmt in formats:
        snake_name = camel_to_snake(fmt.name)
        files[f'{snake_name}.py'] = ''.join(FrameParserPyGen.generate_format_file(fmt))

    # Generate __init__.py
    files['__init__.py'] = ''.join(FrameParserPyGen.generate_init(formats))

    return files
