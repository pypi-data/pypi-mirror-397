#!/usr/bin/env python3
# kate: replace-tabs on; indent-width 4;

"""
C# Frame Parser Generator

Generates C# code for frame parsers based on frame format definitions.
"""

from struct_frame import version
import time


def camel_to_snake(name):
    """Convert CamelCase to snake_case"""
    import re
    name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', name)
    return name.lower()


def camel_to_upper_snake(name):
    """Convert CamelCase to UPPER_SNAKE_CASE"""
    return camel_to_snake(name).upper()


class FrameParserCSharpGen:
    """Generates C# code for frame parsers"""

    @staticmethod
    def generate(formats):
        """Generate the complete frame parser C# file"""
        yield '// Automatically generated frame parser for C#\n'
        yield f'// Generated by {version} at {time.asctime()}.\n\n'
        yield 'using System;\n'
        yield 'using System.Collections.Generic;\n\n'
        yield 'namespace StructFrame\n'
        yield '{\n'

        # Generate frame format enum
        yield '    /// <summary>\n'
        yield '    /// Frame format type enumeration\n'
        yield '    /// </summary>\n'
        yield '    public enum FrameFormatType\n'
        yield '    {\n'
        for i, fmt in enumerate(formats):
            enum_name = camel_to_upper_snake(fmt.name)
            comma = ',' if i < len(formats) - 1 else ''
            yield f'        {enum_name} = {i}{comma}\n'
        yield '    }\n\n'

        # Generate individual frame format classes
        for fmt in formats:
            yield from FrameParserCSharpGen.generate_format(fmt)
            yield '\n'

        yield '}\n'

    @staticmethod
    def generate_format(fmt):
        """Generate C# code for a single frame format"""
        name = fmt.name
        class_name = name

        yield f'    /// <summary>\n'
        yield f'    /// {name} - Frame format parser and encoder\n'
        yield f'    /// </summary>\n'
        yield f'    public class {class_name} : FrameFormatBase\n'
        yield f'    {{\n'

        # Generate parser state enum
        yield f'        public enum ParserState\n'
        yield f'        {{\n'
        state_idx = 0
        if fmt.start_bytes:
            for i in range(len(fmt.start_bytes)):
                state_name = f'LookingForStart{i + 1}' if len(fmt.start_bytes) > 1 else 'LookingForStart'
                comma = ','
                yield f'            {state_name} = {state_idx}{comma}\n'
                state_idx += 1
        yield f'            GettingMsgId = {state_idx},\n'
        state_idx += 1
        if fmt.has_length:
            yield f'            GettingLength = {state_idx},\n'
            state_idx += 1
        yield f'            GettingPayload = {state_idx}\n'
        yield f'        }}\n\n'

        # Constants
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            const_name = f'StartByte{i + 1}' if len(fmt.start_bytes) > 1 else 'StartByte'
            yield f'        public const byte {const_name} = 0x{sb_value:02X};\n'
        yield f'        public const int HeaderSize = {fmt.header_size};\n'
        yield f'        public const int FooterSize = {fmt.footer_size};\n'
        yield f'        public const int Overhead = {fmt.header_size + fmt.footer_size};\n'
        if fmt.has_length:
            yield f'        public const int LengthBytes = {fmt.length_bytes};\n'
        yield '\n'

        # Instance variables
        yield f'        private ParserState _state;\n'
        yield f'        private List<byte> _buffer;\n'
        yield f'        private int _packetSize;\n'
        yield f'        private int _msgId;\n'
        if fmt.has_length:
            yield f'        private int _msgLength;\n'
            if fmt.length_bytes == 2:
                yield f'        private int _lengthLo;\n'
        yield f'        private Func<int, int?> _getMsgLength;\n\n'

        # Constructor
        yield f'        /// <summary>\n'
        yield f'        /// Initialize the {name} parser\n'
        yield f'        /// </summary>\n'
        yield f'        /// <param name="getMsgLength">Callback function to get message length from msg_id</param>\n'
        yield f'        public {class_name}(Func<int, int?> getMsgLength = null)\n'
        yield f'        {{\n'
        yield f'            _getMsgLength = getMsgLength;\n'
        yield f'            _buffer = new List<byte>();\n'
        yield f'            Reset();\n'
        yield f'        }}\n\n'

        # Reset method
        yield f'        /// <summary>\n'
        yield f'        /// Reset parser state\n'
        yield f'        /// </summary>\n'
        yield f'        public override void Reset()\n'
        yield f'        {{\n'
        if fmt.start_bytes:
            state_name = 'LookingForStart1' if len(fmt.start_bytes) > 1 else 'LookingForStart'
            yield f'            _state = ParserState.{state_name};\n'
        else:
            yield f'            _state = ParserState.GettingMsgId;\n'
        yield f'            _buffer.Clear();\n'
        yield f'            _packetSize = 0;\n'
        yield f'            _msgId = 0;\n'
        if fmt.has_length:
            yield f'            _msgLength = 0;\n'
            if fmt.length_bytes == 2:
                yield f'            _lengthLo = 0;\n'
        yield f'        }}\n\n'

        # ParseByte method
        yield f'        /// <summary>\n'
        yield f'        /// Parse a single byte\n'
        yield f'        /// </summary>\n'
        yield f'        /// <param name="b">The byte to parse</param>\n'
        yield f'        /// <returns>FrameParseResult with Valid=true when a complete valid message is received</returns>\n'
        yield f'        public override FrameParseResult ParseByte(byte b)\n'
        yield f'        {{\n'
        yield f'            var result = new FrameParseResult();\n\n'

        # State machine
        yield f'            switch (_state)\n'
        yield f'            {{\n'

        if fmt.start_bytes:
            for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
                state_name = f'LookingForStart{i + 1}' if len(fmt.start_bytes) > 1 else 'LookingForStart'
                const_name = f'StartByte{i + 1}' if len(fmt.start_bytes) > 1 else 'StartByte'

                yield f'                case ParserState.{state_name}:\n'
                yield f'                    if (b == {const_name})\n'
                yield f'                    {{\n'

                if i == 0:
                    yield f'                        _buffer.Clear();\n'
                    yield f'                        _buffer.Add(b);\n'
                else:
                    yield f'                        _buffer.Add(b);\n'

                if i + 1 < len(fmt.start_bytes):
                    next_state = f'LookingForStart{i + 2}'
                else:
                    next_state = 'GettingMsgId'
                yield f'                        _state = ParserState.{next_state};\n'
                yield f'                    }}\n'

                if i > 0:
                    yield f'                    else if (b == StartByte1)\n'
                    yield f'                    {{\n'
                    yield f'                        _buffer.Clear();\n'
                    yield f'                        _buffer.Add(b);\n'
                    yield f'                        _state = ParserState.LookingForStart2;\n'
                    yield f'                    }}\n'
                    yield f'                    else\n'
                    yield f'                    {{\n'
                    yield f'                        _state = ParserState.LookingForStart1;\n'
                    yield f'                    }}\n'
                yield f'                    break;\n\n'

        # GETTING_MSG_ID state
        yield f'                case ParserState.GettingMsgId:\n'
        yield f'                    _buffer.Add(b);\n'
        yield f'                    _msgId = b;\n'

        if fmt.has_length:
            yield f'                    _state = ParserState.GettingLength;\n'
        else:
            yield f'                    if (_getMsgLength != null)\n'
            yield f'                    {{\n'
            yield f'                        int? msgLength = _getMsgLength(b);\n'
            yield f'                        if (msgLength.HasValue)\n'
            yield f'                        {{\n'
            yield f'                            _packetSize = Overhead + msgLength.Value;\n'
            yield f'                            _state = ParserState.GettingPayload;\n'
            yield f'                        }}\n'
            yield f'                        else\n'
            yield f'                        {{\n'
            reset_state = 'LookingForStart1' if len(fmt.start_bytes) > 1 else ('LookingForStart' if fmt.start_bytes else 'GettingMsgId')
            yield f'                            _state = ParserState.{reset_state};\n'
            yield f'                        }}\n'
            yield f'                    }}\n'
            yield f'                    else\n'
            yield f'                    {{\n'
            yield f'                        _state = ParserState.{reset_state};\n'
            yield f'                    }}\n'
        yield f'                    break;\n\n'

        # GETTING_LENGTH state (if applicable)
        if fmt.has_length:
            yield f'                case ParserState.GettingLength:\n'
            yield f'                    _buffer.Add(b);\n'
            if fmt.length_bytes == 1:
                yield f'                    _msgLength = b;\n'
                yield f'                    _packetSize = Overhead + _msgLength;\n'
                yield f'                    _state = ParserState.GettingPayload;\n'
            else:
                yield f'                    if (_buffer.Count == {len(fmt.start_bytes) + 2})\n'
                yield f'                    {{\n'
                yield f'                        _lengthLo = b;\n'
                yield f'                    }}\n'
                yield f'                    else\n'
                yield f'                    {{\n'
                yield f'                        _msgLength = _lengthLo | (b << 8);\n'
                yield f'                        _packetSize = Overhead + _msgLength;\n'
                yield f'                        _state = ParserState.GettingPayload;\n'
                yield f'                    }}\n'
            yield f'                    break;\n\n'

        # GETTING_PAYLOAD state
        yield f'                case ParserState.GettingPayload:\n'
        yield f'                    _buffer.Add(b);\n'
        yield f'                    if (_buffer.Count >= _packetSize)\n'
        yield f'                    {{\n'
        yield f'                        result = ValidatePacket(_buffer.ToArray(), _buffer.Count);\n'
        reset_state = 'LookingForStart1' if len(fmt.start_bytes) > 1 else ('LookingForStart' if fmt.start_bytes else 'GettingMsgId')
        yield f'                        _state = ParserState.{reset_state};\n'
        yield f'                    }}\n'
        yield f'                    break;\n'

        yield f'            }}\n\n'
        yield f'            return result;\n'
        yield f'        }}\n\n'

        # Encode method
        yield f'        /// <summary>\n'
        yield f'        /// Encode a message with {name} format\n'
        yield f'        /// </summary>\n'
        yield f'        /// <param name="msgId">Message ID</param>\n'
        yield f'        /// <param name="msgData">Message data bytes</param>\n'
        yield f'        /// <returns>Encoded frame as byte array</returns>\n'
        yield f'        public override byte[] Encode(int msgId, byte[] msgData)\n'
        yield f'        {{\n'
        yield f'            var output = new List<byte>();\n'

        # Write start bytes
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            const_name = f'StartByte{i + 1}' if len(fmt.start_bytes) > 1 else 'StartByte'
            yield f'            output.Add({const_name});\n'

        if fmt.has_length and fmt.has_crc:
            # Default format with length and CRC
            if fmt.length_bytes == 1:
                yield f'            output.Add((byte)(msgData.Length & 0xFF));\n'
            else:
                yield f'            output.Add((byte)(msgData.Length & 0xFF));\n'
                yield f'            output.Add((byte)((msgData.Length >> 8) & 0xFF));\n'
            yield f'            output.Add((byte)msgId);\n'
            yield f'            output.AddRange(msgData);\n\n'
            yield f'            // Calculate Fletcher checksum\n'
            yield f'            var ck = FletcherChecksum(output.ToArray(), {len(fmt.start_bytes)}, output.Count);\n'
            yield f'            output.Add(ck.Item1);\n'
            yield f'            output.Add(ck.Item2);\n'
        elif not fmt.has_length and not fmt.has_crc:
            # Minimal format
            yield f'            output.Add((byte)msgId);\n'
            yield f'            output.AddRange(msgData);\n'
        else:
            # Other formats
            yield f'            output.Add((byte)msgId);\n'
            if fmt.has_length:
                if fmt.length_bytes == 1:
                    yield f'            output.Add((byte)(msgData.Length & 0xFF));\n'
                else:
                    yield f'            output.Add((byte)(msgData.Length & 0xFF));\n'
                    yield f'            output.Add((byte)((msgData.Length >> 8) & 0xFF));\n'
            yield f'            output.AddRange(msgData);\n'
            if fmt.has_crc:
                yield f'            var ck = FletcherChecksum(output.ToArray(), {len(fmt.start_bytes)}, output.Count);\n'
                yield f'            output.Add(ck.Item1);\n'
                yield f'            output.Add(ck.Item2);\n'

        yield f'            return output.ToArray();\n'
        yield f'        }}\n\n'

        # ValidatePacket method
        yield f'        /// <summary>\n'
        yield f'        /// Validate a complete {name} packet in a buffer\n'
        yield f'        /// </summary>\n'
        yield f'        /// <param name="data">Buffer containing the complete packet</param>\n'
        yield f'        /// <param name="length">Length of the data in the buffer</param>\n'
        yield f'        /// <returns>FrameParseResult with Valid=true if packet is valid</returns>\n'
        yield f'        public override FrameParseResult ValidatePacket(byte[] data, int length)\n'
        yield f'        {{\n'
        yield f'            var result = new FrameParseResult();\n\n'
        yield f'            if (length < Overhead)\n'
        yield f'                return result;\n\n'

        # Check start bytes
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            const_name = f'StartByte{i + 1}' if len(fmt.start_bytes) > 1 else 'StartByte'
            yield f'            if (data[{i}] != {const_name})\n'
            yield f'                return result;\n'

        yield f'\n'

        if fmt.has_crc:
            yield f'            int msgLength = length - Overhead;\n'
            if fmt.has_length:
                yield f'            int crcDataLen = msgLength + 1 + LengthBytes;\n'
            else:
                yield f'            int crcDataLen = msgLength + 1;\n'
            yield f'            var ck = FletcherChecksum(data, {len(fmt.start_bytes)}, {len(fmt.start_bytes)} + crcDataLen);\n\n'
            yield f'            if (ck.Item1 == data[length - 2] && ck.Item2 == data[length - 1])\n'
            yield f'            {{\n'
            yield f'                result.Valid = true;\n'
            yield f'                result.MsgId = data[HeaderSize - 1];\n'
            yield f'                result.MsgSize = msgLength;\n'
            yield f'                result.MsgData = new byte[msgLength];\n'
            yield f'                Array.Copy(data, HeaderSize, result.MsgData, 0, msgLength);\n'
            yield f'            }}\n'
        else:
            yield f'            result.Valid = true;\n'
            yield f'            result.MsgId = data[HeaderSize - 1];\n'
            yield f'            result.MsgSize = length - HeaderSize;\n'
            yield f'            result.MsgData = new byte[result.MsgSize];\n'
            yield f'            Array.Copy(data, HeaderSize, result.MsgData, 0, result.MsgSize);\n'

        yield f'            return result;\n'
        yield f'        }}\n\n'

        # Fletcher checksum helper
        yield f'        /// <summary>\n'
        yield f'        /// Calculate Fletcher-16 checksum\n'
        yield f'        /// </summary>\n'
        yield f'        private static (byte, byte) FletcherChecksum(byte[] buffer, int start, int end)\n'
        yield f'        {{\n'
        yield f'            byte byte1 = 0;\n'
        yield f'            byte byte2 = 0;\n\n'
        yield f'            for (int i = start; i < end; i++)\n'
        yield f'            {{\n'
        yield f'                byte1 = (byte)((byte1 + buffer[i]) % 256);\n'
        yield f'                byte2 = (byte)((byte2 + byte1) % 256);\n'
        yield f'            }}\n\n'
        yield f'            return (byte1, byte2);\n'
        yield f'        }}\n'

        yield f'    }}\n'

    @staticmethod
    def generate_base():
        """Generate the base C# file with FrameParseResult, FrameFormatBase, StructHelper"""
        yield '// Automatically generated frame base for C#\n'
        yield f'// Generated by {version} at {time.asctime()}.\n'
        yield '// This file provides base utilities for struct frame parsing and encoding\n\n'
        yield 'using System;\n'
        yield 'using System.Runtime.InteropServices;\n\n'
        yield 'namespace StructFrame\n'
        yield '{\n'

        # FrameParseResult struct
        yield '    /// <summary>\n'
        yield '    /// Represents the result of parsing a frame\n'
        yield '    /// </summary>\n'
        yield '    public struct FrameParseResult\n'
        yield '    {\n'
        yield '        public bool Valid;\n'
        yield '        public int MsgId;\n'
        yield '        public byte[] MsgData;\n'
        yield '        public int MsgSize;\n'
        yield '    }\n\n'

        # FrameFormatBase abstract class
        yield '    /// <summary>\n'
        yield '    /// Base class for frame format implementations\n'
        yield '    /// </summary>\n'
        yield '    public abstract class FrameFormatBase\n'
        yield '    {\n'
        yield '        /// <summary>\n'
        yield '        /// Encodes a message into a byte array\n'
        yield '        /// </summary>\n'
        yield '        public abstract byte[] Encode(int msgId, byte[] msgData);\n\n'
        yield '        /// <summary>\n'
        yield '        /// Validates and parses a packet\n'
        yield '        /// </summary>\n'
        yield '        public abstract FrameParseResult ValidatePacket(byte[] data, int length);\n\n'
        yield '        /// <summary>\n'
        yield '        /// Parses a single byte (for streaming parsers)\n'
        yield '        /// </summary>\n'
        yield '        public abstract FrameParseResult ParseByte(byte b);\n\n'
        yield '        /// <summary>\n'
        yield '        /// Resets the parser state\n'
        yield '        /// </summary>\n'
        yield '        public abstract void Reset();\n'
        yield '    }\n\n'

        # StructHelper static class
        yield '    /// <summary>\n'
        yield '    /// Helper methods for struct serialization\n'
        yield '    /// </summary>\n'
        yield '    public static class StructHelper\n'
        yield '    {\n'
        yield '        /// <summary>\n'
        yield '        /// Converts a struct to a byte array\n'
        yield '        /// </summary>\n'
        yield '        public static byte[] StructToBytes<T>(T structure) where T : struct\n'
        yield '        {\n'
        yield '            int size = Marshal.SizeOf(typeof(T));\n'
        yield '            byte[] buffer = new byte[size];\n'
        yield '            IntPtr ptr = Marshal.AllocHGlobal(size);\n'
        yield '            try\n'
        yield '            {\n'
        yield '                Marshal.StructureToPtr(structure, ptr, false);\n'
        yield '                Marshal.Copy(ptr, buffer, 0, size);\n'
        yield '            }\n'
        yield '            finally\n'
        yield '            {\n'
        yield '                Marshal.FreeHGlobal(ptr);\n'
        yield '            }\n'
        yield '            return buffer;\n'
        yield '        }\n\n'
        yield '        /// <summary>\n'
        yield '        /// Converts a byte array to a struct\n'
        yield '        /// </summary>\n'
        yield '        public static T BytesToStruct<T>(byte[] buffer) where T : struct\n'
        yield '        {\n'
        yield '            return BytesToStruct<T>(buffer, 0);\n'
        yield '        }\n\n'
        yield '        /// <summary>\n'
        yield '        /// Converts a byte array to a struct starting at an offset\n'
        yield '        /// </summary>\n'
        yield '        public static T BytesToStruct<T>(byte[] buffer, int offset) where T : struct\n'
        yield '        {\n'
        yield '            int size = Marshal.SizeOf(typeof(T));\n'
        yield '            IntPtr ptr = Marshal.AllocHGlobal(size);\n'
        yield '            try\n'
        yield '            {\n'
        yield '                Marshal.Copy(buffer, offset, ptr, size);\n'
        yield '                return Marshal.PtrToStructure<T>(ptr);\n'
        yield '            }\n'
        yield '            finally\n'
        yield '            {\n'
        yield '                Marshal.FreeHGlobal(ptr);\n'
        yield '            }\n'
        yield '        }\n'
        yield '    }\n'

        yield '}\n'

    @staticmethod
    def generate_format_file(fmt):
        """Generate a single frame format C# file"""
        yield '// Automatically generated frame parser for C#\n'
        yield f'// Generated by {version} at {time.asctime()}.\n\n'
        yield 'using System;\n'
        yield 'using System.Collections.Generic;\n\n'
        yield 'namespace StructFrame\n'
        yield '{\n'

        # Generate the frame format class
        yield from FrameParserCSharpGen.generate_format(fmt)

        yield '}\n'

    @staticmethod
    def generate_main(formats):
        """Generate the main FrameParsers.cs file with the frame format enum"""
        yield '// Automatically generated frame parsers for C#\n'
        yield f'// Generated by {version} at {time.asctime()}.\n\n'
        yield 'namespace StructFrame\n'
        yield '{\n'

        # Generate frame format enum
        yield '    /// <summary>\n'
        yield '    /// Frame format type enumeration\n'
        yield '    /// </summary>\n'
        yield '    public enum FrameFormatType\n'
        yield '    {\n'
        for i, fmt in enumerate(formats):
            enum_name = camel_to_upper_snake(fmt.name)
            comma = ',' if i < len(formats) - 1 else ''
            yield f'        {enum_name} = {i}{comma}\n'
        yield '    }\n'

        yield '}\n'


def generate_csharp_frame_parsers(formats):
    """Generate C# frame parser code from frame format definitions"""
    return ''.join(FrameParserCSharpGen.generate(formats))


def generate_csharp_frame_parsers_multi(formats):
    """
    Generate multiple C# files for frame parsers.

    Returns a dictionary mapping filename to content:
    - FrameBase.cs: Base utilities (FrameParseResult, FrameFormatBase, StructHelper)
    - {PascalName}.cs: Individual frame format files
    - FrameParsers.cs: Main file that includes all parsers
    """
    files = {}

    # Generate base file with FrameParseResult, FrameFormatBase, StructHelper
    files['FrameBase.cs'] = ''.join(FrameParserCSharpGen.generate_base())

    # Generate individual frame format files
    for fmt in formats:
        pascal_name = fmt.name  # Already PascalCase
        files[f'{pascal_name}.cs'] = ''.join(FrameParserCSharpGen.generate_format_file(fmt))

    # Generate main file that includes frame format enum
    files['FrameParsers.cs'] = ''.join(FrameParserCSharpGen.generate_main(formats))

    return files
