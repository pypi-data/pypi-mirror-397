// Automatically generated frame parser
// Generated by 0.0.1 at Wed Dec  3 17:57:16 2025.

const { createFrameMsgInfo, fletcher_checksum } = require('./frame_base');

// =============================================================================
// MinimalFrame Frame Format
// =============================================================================

const MinimalFrameParserState = {
    GETTING_MSG_ID: 0,
    GETTING_PAYLOAD: 1
};

/**
 * MinimalFrame - Frame format parser and encoder
 */
class MinimalFrame {
    static HEADER_SIZE = 1;
    static FOOTER_SIZE = 2;
    static OVERHEAD = 3;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = MinimalFrameParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    reset() {
        this.state = MinimalFrameParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case MinimalFrameParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.get_msg_length) {
                    const msg_length = this.get_msg_length(byte);
                    if (msg_length !== undefined) {
                        this.packet_size = MinimalFrame.OVERHEAD + msg_length;
                        this.state = MinimalFrameParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = MinimalFrameParserState.GETTING_MSG_ID;
                    }
                } else {
                    this.state = MinimalFrameParserState.GETTING_MSG_ID;
                }
                break;

            case MinimalFrameParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    const msg_length = this.packet_size - MinimalFrame.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 0, 0 + msg_length + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(MinimalFrame.HEADER_SIZE, this.packet_size - MinimalFrame.FOOTER_SIZE));
                    }
                    this.state = MinimalFrameParserState.GETTING_MSG_ID;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(msg_id);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 0, 0 + msg.length + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < MinimalFrame.OVERHEAD) {
            return result;
        }


        const msg_length = buffer.length - MinimalFrame.OVERHEAD;

        const ck = fletcher_checksum(buffer, 0, 0 + msg_length + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[0];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, MinimalFrame.HEADER_SIZE, buffer.length - MinimalFrame.FOOTER_SIZE));
        }

        return result;
    }
}

module.exports = {
    MinimalFrame,
    MinimalFrameParserState,
};
