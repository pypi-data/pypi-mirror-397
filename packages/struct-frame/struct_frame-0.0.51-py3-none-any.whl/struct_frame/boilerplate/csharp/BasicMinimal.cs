// Automatically generated frame parser for C#
// Generated by 0.0.1 at Fri Dec  5 01:14:49 2025.

using System;
using System.Collections.Generic;

namespace StructFrame
{
    /// <summary>
    /// BasicMinimal - Frame format parser and encoder
    /// </summary>
    public class BasicMinimal : FrameFormatBase
    {
        public enum ParserState
        {
            LookingForStart1 = 0,
            LookingForStart2 = 1,
            GettingMsgId = 2,
            GettingPayload = 3
        }

        public const byte StartByte1 = 0x90;
        public const byte StartByte2 = 0x70;
        public const int HeaderSize = 3;
        public const int FooterSize = 0;
        public const int Overhead = 3;

        private ParserState _state;
        private List<byte> _buffer;
        private int _packetSize;
        private int _msgId;
        private Func<int, int?> _getMsgLength;

        /// <summary>
        /// Initialize the BasicMinimal parser
        /// </summary>
        /// <param name="getMsgLength">Callback function to get message length from msg_id</param>
        public BasicMinimal(Func<int, int?> getMsgLength = null)
        {
            _getMsgLength = getMsgLength;
            _buffer = new List<byte>();
            Reset();
        }

        /// <summary>
        /// Reset parser state
        /// </summary>
        public override void Reset()
        {
            _state = ParserState.LookingForStart1;
            _buffer.Clear();
            _packetSize = 0;
            _msgId = 0;
        }

        /// <summary>
        /// Parse a single byte
        /// </summary>
        /// <param name="b">The byte to parse</param>
        /// <returns>FrameParseResult with Valid=true when a complete valid message is received</returns>
        public override FrameParseResult ParseByte(byte b)
        {
            var result = new FrameParseResult();

            switch (_state)
            {
                case ParserState.LookingForStart1:
                    if (b == StartByte1)
                    {
                        _buffer.Clear();
                        _buffer.Add(b);
                        _state = ParserState.LookingForStart2;
                    }
                    break;

                case ParserState.LookingForStart2:
                    if (b == StartByte2)
                    {
                        _buffer.Add(b);
                        _state = ParserState.GettingMsgId;
                    }
                    else if (b == StartByte1)
                    {
                        _buffer.Clear();
                        _buffer.Add(b);
                        _state = ParserState.LookingForStart2;
                    }
                    else
                    {
                        _state = ParserState.LookingForStart1;
                    }
                    break;

                case ParserState.GettingMsgId:
                    _buffer.Add(b);
                    _msgId = b;
                    if (_getMsgLength != null)
                    {
                        int? msgLength = _getMsgLength(b);
                        if (msgLength.HasValue)
                        {
                            _packetSize = Overhead + msgLength.Value;
                            _state = ParserState.GettingPayload;
                        }
                        else
                        {
                            _state = ParserState.LookingForStart1;
                        }
                    }
                    else
                    {
                        _state = ParserState.LookingForStart1;
                    }
                    break;

                case ParserState.GettingPayload:
                    _buffer.Add(b);
                    if (_buffer.Count >= _packetSize)
                    {
                        result = ValidatePacket(_buffer.ToArray(), _buffer.Count);
                        _state = ParserState.LookingForStart1;
                    }
                    break;
            }

            return result;
        }

        /// <summary>
        /// Encode a message with BasicMinimal format
        /// </summary>
        /// <param name="msgId">Message ID</param>
        /// <param name="msgData">Message data bytes</param>
        /// <returns>Encoded frame as byte array</returns>
        public override byte[] Encode(int msgId, byte[] msgData)
        {
            var output = new List<byte>();
            output.Add(StartByte1);
            output.Add(StartByte2);
            output.Add((byte)msgId);
            output.AddRange(msgData);
            return output.ToArray();
        }

        /// <summary>
        /// Validate a complete BasicMinimal packet in a buffer
        /// </summary>
        /// <param name="data">Buffer containing the complete packet</param>
        /// <param name="length">Length of the data in the buffer</param>
        /// <returns>FrameParseResult with Valid=true if packet is valid</returns>
        public override FrameParseResult ValidatePacket(byte[] data, int length)
        {
            var result = new FrameParseResult();

            if (length < Overhead)
                return result;

            if (data[0] != StartByte1)
                return result;
            if (data[1] != StartByte2)
                return result;

            result.Valid = true;
            result.MsgId = data[HeaderSize - 1];
            result.MsgSize = length - HeaderSize;
            result.MsgData = new byte[result.MsgSize];
            Array.Copy(data, HeaderSize, result.MsgData, 0, result.MsgSize);
            return result;
        }

        /// <summary>
        /// Calculate Fletcher-16 checksum
        /// </summary>
        private static (byte, byte) FletcherChecksum(byte[] buffer, int start, int end)
        {
            byte byte1 = 0;
            byte byte2 = 0;

            for (int i = start; i < end; i++)
            {
                byte1 = (byte)((byte1 + buffer[i]) % 256);
                byte2 = (byte)((byte2 + byte1) % 256);
            }

            return (byte1, byte2);
        }
    }
}
