# Automatically generated frame parser base utilities
# Generated by 0.0.1 at Fri Dec  5 01:14:49 2025.

from enum import Enum
from typing import Callable, List, Tuple, Union
from dataclasses import dataclass

# Frame format type enumeration
class FrameFormatType(Enum):
    TINY_MINIMAL = 0
    TINY_DEFAULT = 1
    TINY_EXTENDED_MSG_IDS = 2
    TINY_EXTENDED_LENGTH = 3
    TINY_EXTENDED = 4
    TINY_SYS_COMP = 5
    TINY_SEQ = 6
    TINY_MULTI_SYSTEM_STREAM = 7
    TINY_EXTENDED_MULTI_SYSTEM_STREAM = 8
    BASIC_MINIMAL = 9
    BASIC_DEFAULT = 10
    BASIC_EXTENDED_MSG_IDS = 11
    BASIC_EXTENDED_LENGTH = 12
    BASIC_EXTENDED = 13
    BASIC_SYS_COMP = 14
    BASIC_SEQ = 15
    BASIC_MULTI_SYSTEM_STREAM = 16
    BASIC_EXTENDED_MULTI_SYSTEM_STREAM = 17
    UBX_FRAME = 18
    MAVLINK_V1_FRAME = 19
    MAVLINK_V2_FRAME = 20
    FRAME_FORMAT_CONFIG = 21


def fletcher_checksum(buffer: Union[bytes, List[int]], start: int = 0, end: int = None) -> Tuple[int, int]:
    """Calculate Fletcher-16 checksum over the given data"""
    if end is None:
        end = len(buffer)

    byte1 = 0
    byte2 = 0

    for x in range(start, end):
        byte1 = (byte1 + buffer[x]) % 256
        byte2 = (byte2 + byte1) % 256

    return (byte1, byte2)


@dataclass
class FrameMsgInfo:
    """Parse result containing message information"""
    valid: bool = False
    msg_id: int = 0
    msg_len: int = 0
    msg_data: bytes = b''


# =============================================================================
# Shared Payload Parsing Functions
# =============================================================================
# These functions handle payload validation/encoding independent of framing.
# Frame formats (Tiny/Basic) use these for the common parsing logic.

def validate_payload_with_crc(buffer: Union[bytes, List[int]], header_size: int,
                              length_bytes: int, crc_start_offset: int = 0) -> FrameMsgInfo:
    """
    Validate a payload with CRC (shared by Default, Extended, etc. payload types).
    
    Args:
        buffer: Complete packet buffer (including any start bytes)
        header_size: Size of header (start_bytes + length + msg_id + extra fields)
        length_bytes: Number of length bytes (1 or 2)
        crc_start_offset: Offset from start of buffer where CRC calculation begins
        
    Returns:
        FrameMsgInfo with valid=True if checksum matches
    """
    result = FrameMsgInfo()
    footer_size = 2  # CRC is always 2 bytes
    overhead = header_size + footer_size
    
    if len(buffer) < overhead:
        return result
    
    msg_length = len(buffer) - overhead
    
    # Calculate expected CRC range: from crc_start_offset to before the CRC bytes
    crc_data_len = msg_length + 1 + length_bytes  # msg_id (1) + length_bytes + payload
    ck = fletcher_checksum(buffer, crc_start_offset, crc_start_offset + crc_data_len)
    
    if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
        result.valid = True
        result.msg_id = buffer[header_size - 1]  # msg_id is last byte of header
        result.msg_len = msg_length
        result.msg_data = bytes(buffer[header_size:len(buffer) - footer_size])
    
    return result


def validate_payload_minimal(buffer: Union[bytes, List[int]], header_size: int) -> FrameMsgInfo:
    """
    Validate a minimal payload (no CRC, no length field).
    
    Args:
        buffer: Complete packet buffer (including any start bytes)
        header_size: Size of header (start_bytes + msg_id)
        
    Returns:
        FrameMsgInfo with packet data
    """
    result = FrameMsgInfo()
    
    if len(buffer) < header_size:
        return result
    
    result.valid = True
    result.msg_id = buffer[header_size - 1]  # msg_id is last byte of header
    result.msg_len = len(buffer) - header_size
    result.msg_data = bytes(buffer[header_size:])
    
    return result


def encode_payload_with_crc(output: list, msg_id: int, msg: bytes,
                            length_bytes: int, crc_start_offset: int) -> None:
    """
    Encode payload with length and CRC (modifies output list in place).
    
    Args:
        output: Output list to append to (already contains start bytes)
        msg_id: Message ID
        msg: Message payload data
        length_bytes: Number of length bytes (1 or 2)
        crc_start_offset: Offset in output where CRC calculation begins
    """
    # Add length field
    if length_bytes == 1:
        output.append(len(msg) & 0xFF)
    else:
        output.append(len(msg) & 0xFF)
        output.append((len(msg) >> 8) & 0xFF)
    
    # Add msg_id
    output.append(msg_id)
    
    # Add payload
    output.extend(msg)
    
    # Calculate and add CRC
    crc_data_len = len(msg) + 1 + length_bytes
    ck = fletcher_checksum(output, crc_start_offset, crc_start_offset + crc_data_len)
    output.append(ck[0])
    output.append(ck[1])


def encode_payload_minimal(output: list, msg_id: int, msg: bytes) -> None:
    """
    Encode minimal payload (no length, no CRC).
    
    Args:
        output: Output list to append to (already contains start bytes)
        msg_id: Message ID
        msg: Message payload data
    """
    output.append(msg_id)
    output.extend(msg)


# =============================================================================
# Frame Parser Configuration
# =============================================================================

@dataclass
class FrameParserConfig:
    """
    Configuration interface for frame format parsers.
    This allows code reuse through configuration instead of code generation.
    """
    name: str
    start_bytes: Tuple[int, ...]
    header_size: int
    footer_size: int
    has_length: bool
    length_bytes: int
    has_crc: bool


# =============================================================================
# Generic Frame Parser
# =============================================================================
# This class provides a reusable frame parser that can be configured
# for different frame formats, reducing code duplication.

class GenericParserState(Enum):
    """Parser state enumeration"""
    LOOKING_FOR_START1 = 0
    LOOKING_FOR_START2 = 1
    GETTING_MSG_ID = 2
    GETTING_LENGTH = 3
    GETTING_PAYLOAD = 4


class GenericFrameParser:
    """
    Generic frame parser that works with any frame format configuration.
    This class eliminates the need for separate parser classes per format.
    """
    
    def __init__(self, config: FrameParserConfig, get_msg_length: Callable[[int], int] = None):
        self.config = config
        self.get_msg_length = get_msg_length
        self.reset()
    
    def _get_initial_state(self) -> GenericParserState:
        if len(self.config.start_bytes) == 0:
            return GenericParserState.GETTING_MSG_ID
        else:
            return GenericParserState.LOOKING_FOR_START1
    
    def reset(self):
        """Reset parser state"""
        self.state = self._get_initial_state()
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0
        self.length_lo = 0
    
    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()
        start_bytes = self.config.start_bytes
        overhead = self.config.header_size + self.config.footer_size

        if self.state == GenericParserState.LOOKING_FOR_START1:
            if byte == start_bytes[0]:
                self.buffer = [byte]
                if len(start_bytes) > 1:
                    self.state = GenericParserState.LOOKING_FOR_START2
                else:
                    self.state = GenericParserState.GETTING_MSG_ID
        
        elif self.state == GenericParserState.LOOKING_FOR_START2:
            if byte == start_bytes[1]:
                self.buffer.append(byte)
                self.state = GenericParserState.GETTING_MSG_ID
            elif byte == start_bytes[0]:
                self.buffer = [byte]
                # Stay in LOOKING_FOR_START2
            else:
                self.state = GenericParserState.LOOKING_FOR_START1
        
        elif self.state == GenericParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            if self.config.has_length:
                self.state = GenericParserState.GETTING_LENGTH
            elif self.get_msg_length:
                msg_len = self.get_msg_length(byte)
                if msg_len is not None:
                    self.packet_size = overhead + msg_len
                    self.state = GenericParserState.GETTING_PAYLOAD
                else:
                    self.state = self._get_initial_state()
            else:
                self.state = self._get_initial_state()
        
        elif self.state == GenericParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            if self.config.length_bytes == 1:
                self.msg_length = byte
                self.packet_size = overhead + self.msg_length
                self.state = GenericParserState.GETTING_PAYLOAD
            else:
                # 2-byte length
                if len(self.buffer) == len(start_bytes) + 2:
                    self.length_lo = byte
                else:
                    self.msg_length = self.length_lo | (byte << 8)
                    self.packet_size = overhead + self.msg_length
                    self.state = GenericParserState.GETTING_PAYLOAD
        
        elif self.state == GenericParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)
            if len(self.buffer) >= self.packet_size:
                if self.config.has_crc:
                    result = validate_payload_with_crc(
                        self.buffer, self.config.header_size, 
                        self.config.length_bytes, len(start_bytes))
                else:
                    result = validate_payload_minimal(self.buffer, self.config.header_size)
                self.state = self._get_initial_state()
        
        return result
    
    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message using this format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = list(self.config.start_bytes)
        
        if self.config.has_crc:
            encode_payload_with_crc(output, msg_id, msg, 
                                   self.config.length_bytes, len(self.config.start_bytes))
        else:
            encode_payload_minimal(output, msg_id, msg)
        
        return bytes(output)
    
    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())
    
    @staticmethod
    def validate_packet(config: FrameParserConfig, buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete packet in a buffer
        
        Args:
            config: Frame format configuration
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        overhead = config.header_size + config.footer_size
        
        if len(buffer) < overhead:
            return FrameMsgInfo()
        
        # Check start bytes
        for i, start_byte in enumerate(config.start_bytes):
            if buffer[i] != start_byte:
                return FrameMsgInfo()
        
        # Validate payload
        if config.has_crc:
            return validate_payload_with_crc(buffer, config.header_size, 
                                            config.length_bytes, len(config.start_bytes))
        else:
            return validate_payload_minimal(buffer, config.header_size)


def create_frame_parser_class(config: FrameParserConfig):
    """
    Create a frame parser class for a specific configuration.
    This factory function provides pre-configured parser classes.
    """
    class ConfiguredFrameParser(GenericFrameParser):
        # Class attributes from config
        CONFIG = config
        START_BYTES = config.start_bytes
        HEADER_SIZE = config.header_size
        FOOTER_SIZE = config.footer_size
        OVERHEAD = config.header_size + config.footer_size
        HAS_LENGTH = config.has_length
        LENGTH_BYTES = config.length_bytes
        HAS_CRC = config.has_crc
        
        def __init__(self, get_msg_length: Callable[[int], int] = None):
            super().__init__(config, get_msg_length)
        
        @staticmethod
        def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
            return GenericFrameParser.validate_packet(config, buffer)
    
    ConfiguredFrameParser.__name__ = config.name
    ConfiguredFrameParser.__qualname__ = config.name
    return ConfiguredFrameParser
