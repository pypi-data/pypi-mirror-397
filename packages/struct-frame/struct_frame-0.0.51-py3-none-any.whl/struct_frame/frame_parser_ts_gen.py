#!/usr/bin/env python3
# kate: replace-tabs on; indent-width 4;

"""
TypeScript Frame Parser Generator

Generates TypeScript code for frame parsers based on frame format definitions.
"""

from struct_frame import version
import time


def camel_to_snake(name):
    """Convert CamelCase to snake_case"""
    import re
    name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', name)
    return name.lower()


def camel_to_upper_snake(name):
    """Convert CamelCase to UPPER_SNAKE_CASE"""
    return camel_to_snake(name).upper()


class FrameParserTsGen:
    """Generates TypeScript code for frame parsers"""

    @staticmethod
    def generate_base(formats):
        """Generate the base TypeScript file with common utilities and generic parser"""
        yield '// Automatically generated frame parser base utilities\n'
        yield f'// Generated by {version} at {time.asctime()}.\n\n'

        # Generate frame format enum
        yield '// Frame format type enumeration\n'
        yield 'export enum FrameFormatType {\n'
        for i, fmt in enumerate(formats):
            enum_name = camel_to_upper_snake(fmt.name)
            yield f'    {enum_name} = {i},\n'
        yield '}\n\n'

        # Generate checksum function
        yield '''// Fletcher-16 checksum calculation
export function fletcher_checksum(buffer: Uint8Array | number[], start: number = 0, end?: number): [number, number] {
    if (end === undefined) {
        end = buffer.length;
    }

    let byte1 = 0;
    let byte2 = 0;

    for (let i = start; i < end; i++) {
        byte1 = (byte1 + buffer[i]) % 256;
        byte2 = (byte2 + byte1) % 256;
    }

    return [byte1, byte2];
}

'''

        # Generate common result interface
        yield '''// Parse result interface
export interface FrameMsgInfo {
    valid: boolean;
    msg_id: number;
    msg_len: number;
    msg_data: Uint8Array;
}

// Create default FrameMsgInfo
export function createFrameMsgInfo(): FrameMsgInfo {
    return {
        valid: false,
        msg_id: 0,
        msg_len: 0,
        msg_data: new Uint8Array(0)
    };
}

// =============================================================================
// Frame Format Configuration
// =============================================================================

/**
 * Configuration interface for frame format parsers.
 * This allows code reuse through configuration instead of code generation.
 */
export interface FrameParserConfig {
    /** Name of the frame format (e.g., 'BasicDefault', 'TinyMinimal') */
    readonly name: string;
    /** Start byte values (0, 1, or 2 bytes) */
    readonly startBytes: readonly number[];
    /** Total header size in bytes */
    readonly headerSize: number;
    /** Total footer size in bytes (usually 0 or 2 for CRC) */
    readonly footerSize: number;
    /** Whether this format includes a length field */
    readonly hasLength: boolean;
    /** Number of bytes for length field (1 or 2) */
    readonly lengthBytes: number;
    /** Whether this format includes CRC */
    readonly hasCrc: boolean;
}

// =============================================================================
// Shared Payload Parsing Functions
// =============================================================================
// These functions handle payload validation/encoding independent of framing.
// Frame formats (Tiny/Basic) use these for the common parsing logic.

/**
 * Validate a payload with CRC (shared by Default, Extended, etc. payload types).
 */
export function validate_payload_with_crc(
    buffer: Uint8Array | number[],
    headerSize: number,
    lengthBytes: number,
    crcStartOffset: number
): FrameMsgInfo {
    const result = createFrameMsgInfo();
    const footerSize = 2; // CRC is always 2 bytes
    const overhead = headerSize + footerSize;

    if (buffer.length < overhead) {
        return result;
    }

    const msgLength = buffer.length - overhead;

    // Calculate expected CRC range: from crcStartOffset to before the CRC bytes
    const crcDataLen = msgLength + 1 + lengthBytes; // msg_id (1) + lengthBytes + payload
    const ck = fletcher_checksum(buffer, crcStartOffset, crcStartOffset + crcDataLen);

    if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
        result.valid = true;
        result.msg_id = buffer[headerSize - 1]; // msg_id is last byte of header
        result.msg_len = msgLength;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, headerSize, buffer.length - footerSize));
    }

    return result;
}

/**
 * Validate a minimal payload (no CRC, no length field).
 */
export function validate_payload_minimal(
    buffer: Uint8Array | number[],
    headerSize: number
): FrameMsgInfo {
    const result = createFrameMsgInfo();

    if (buffer.length < headerSize) {
        return result;
    }

    result.valid = true;
    result.msg_id = buffer[headerSize - 1]; // msg_id is last byte of header
    result.msg_len = buffer.length - headerSize;
    result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, headerSize));

    return result;
}

/**
 * Encode payload with length and CRC (modifies output array in place).
 */
export function encode_payload_with_crc(
    output: number[],
    msgId: number,
    msg: Uint8Array | number[],
    lengthBytes: number,
    crcStartOffset: number
): void {
    // Add length field
    if (lengthBytes === 1) {
        output.push(msg.length & 0xFF);
    } else {
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
    }

    // Add msg_id
    output.push(msgId);

    // Add payload
    for (let i = 0; i < msg.length; i++) {
        output.push(msg[i]);
    }

    // Calculate and add CRC
    const crcDataLen = msg.length + 1 + lengthBytes;
    const ck = fletcher_checksum(output, crcStartOffset, crcStartOffset + crcDataLen);
    output.push(ck[0]);
    output.push(ck[1]);
}

/**
 * Encode minimal payload (no length, no CRC).
 */
export function encode_payload_minimal(
    output: number[],
    msgId: number,
    msg: Uint8Array | number[]
): void {
    output.push(msgId);
    for (let i = 0; i < msg.length; i++) {
        output.push(msg[i]);
    }
}

// =============================================================================
// Generic Frame Parser
// =============================================================================
// This class provides a reusable frame parser that can be configured
// for different frame formats, reducing code duplication.

/** Parser state enumeration */
export enum GenericParserState {
    LOOKING_FOR_START1 = 0,
    LOOKING_FOR_START2 = 1,
    GETTING_MSG_ID = 2,
    GETTING_LENGTH = 3,
    GETTING_PAYLOAD = 4
}

/**
 * Generic frame parser that works with any frame format configuration.
 * This class eliminates the need for separate parser classes per format.
 */
export class GenericFrameParser {
    readonly config: FrameParserConfig;
    
    private state: GenericParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private length_lo: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    constructor(config: FrameParserConfig, get_msg_length?: (msg_id: number) => number | undefined) {
        this.config = config;
        this.get_msg_length = get_msg_length;
        this.state = this.getInitialState();
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    private getInitialState(): GenericParserState {
        if (this.config.startBytes.length === 0) {
            return GenericParserState.GETTING_MSG_ID;
        } else if (this.config.startBytes.length === 1) {
            return GenericParserState.LOOKING_FOR_START1;
        } else {
            return GenericParserState.LOOKING_FOR_START1;
        }
    }

    reset(): void {
        this.state = this.getInitialState();
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();
        const startBytes = this.config.startBytes;
        const overhead = this.config.headerSize + this.config.footerSize;

        switch (this.state) {
            case GenericParserState.LOOKING_FOR_START1:
                if (byte === startBytes[0]) {
                    this.buffer = [byte];
                    if (startBytes.length > 1) {
                        this.state = GenericParserState.LOOKING_FOR_START2;
                    } else {
                        this.state = GenericParserState.GETTING_MSG_ID;
                    }
                }
                break;

            case GenericParserState.LOOKING_FOR_START2:
                if (byte === startBytes[1]) {
                    this.buffer.push(byte);
                    this.state = GenericParserState.GETTING_MSG_ID;
                } else if (byte === startBytes[0]) {
                    this.buffer = [byte];
                    // Stay in LOOKING_FOR_START2
                } else {
                    this.state = GenericParserState.LOOKING_FOR_START1;
                }
                break;

            case GenericParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.config.hasLength) {
                    this.state = GenericParserState.GETTING_LENGTH;
                } else if (this.get_msg_length) {
                    const msgLen = this.get_msg_length(byte);
                    if (msgLen !== undefined) {
                        this.packet_size = overhead + msgLen;
                        this.state = GenericParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = this.getInitialState();
                    }
                } else {
                    this.state = this.getInitialState();
                }
                break;

            case GenericParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                if (this.config.lengthBytes === 1) {
                    this.msg_length = byte;
                    this.packet_size = overhead + this.msg_length;
                    this.state = GenericParserState.GETTING_PAYLOAD;
                } else {
                    // 2-byte length
                    if (this.buffer.length === startBytes.length + 2) {
                        this.length_lo = byte;
                    } else {
                        this.msg_length = this.length_lo | (byte << 8);
                        this.packet_size = overhead + this.msg_length;
                        this.state = GenericParserState.GETTING_PAYLOAD;
                    }
                }
                break;

            case GenericParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);
                if (this.buffer.length >= this.packet_size) {
                    if (this.config.hasCrc) {
                        const validationResult = validate_payload_with_crc(
                            this.buffer, this.config.headerSize, this.config.lengthBytes, startBytes.length);
                        if (validationResult.valid) {
                            result.valid = validationResult.valid;
                            result.msg_id = validationResult.msg_id;
                            result.msg_len = validationResult.msg_len;
                            result.msg_data = validationResult.msg_data;
                        }
                    } else {
                        const validationResult = validate_payload_minimal(this.buffer, this.config.headerSize);
                        result.valid = validationResult.valid;
                        result.msg_id = validationResult.msg_id;
                        result.msg_len = validationResult.msg_len;
                        result.msg_data = validationResult.msg_data;
                    }
                    this.state = this.getInitialState();
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message using this format
     */
    static encode(config: FrameParserConfig, msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        
        // Add start bytes
        for (const startByte of config.startBytes) {
            output.push(startByte);
        }
        
        // Use appropriate payload encoding
        if (config.hasCrc) {
            encode_payload_with_crc(output, msg_id, msg, config.lengthBytes, config.startBytes.length);
        } else {
            encode_payload_minimal(output, msg_id, msg);
        }
        
        return new Uint8Array(output);
    }

    /**
     * Validate a complete packet buffer using this format
     */
    static validate_packet(config: FrameParserConfig, buffer: Uint8Array | number[]): FrameMsgInfo {
        const overhead = config.headerSize + config.footerSize;
        
        if (buffer.length < overhead) {
            return createFrameMsgInfo();
        }
        
        // Check start bytes
        for (let i = 0; i < config.startBytes.length; i++) {
            if (buffer[i] !== config.startBytes[i]) {
                return createFrameMsgInfo();
            }
        }
        
        // Validate payload
        if (config.hasCrc) {
            return validate_payload_with_crc(buffer, config.headerSize, config.lengthBytes, config.startBytes.length);
        } else {
            return validate_payload_minimal(buffer, config.headerSize);
        }
    }
}

/**
 * Create a typed frame parser class for a specific configuration.
 * This factory function provides type-safe wrappers around GenericFrameParser.
 */
export function createFrameParserClass(config: FrameParserConfig) {
    return class extends GenericFrameParser {
        // Static properties from config
        static readonly START_BYTES = config.startBytes;
        static readonly HEADER_SIZE = config.headerSize;
        static readonly FOOTER_SIZE = config.footerSize;
        static readonly OVERHEAD = config.headerSize + config.footerSize;
        static readonly HAS_LENGTH = config.hasLength;
        static readonly LENGTH_BYTES = config.lengthBytes;
        static readonly HAS_CRC = config.hasCrc;
        static readonly CONFIG = config;

        constructor(get_msg_length?: (msg_id: number) => number | undefined) {
            super(config, get_msg_length);
        }

        static encodeMsg(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
            return GenericFrameParser.encode(config, msg_id, msg);
        }

        static validatePacket(buffer: Uint8Array | number[]): FrameMsgInfo {
            return GenericFrameParser.validate_packet(config, buffer);
        }
    };
}
'''

    @staticmethod
    def generate_format_file(fmt):
        """Generate a TypeScript file for a single frame format using configuration-based approach"""
        name = fmt.name

        yield '// Automatically generated frame parser\n'
        yield f'// Generated by {version} at {time.asctime()}.\n\n'
        yield 'import {\n'
        yield '    FrameParserConfig, createFrameParserClass, GenericParserState,\n'
        yield '} from \'./frame_base\';\n\n'

        # Generate configuration object
        yield f'// =============================================================================\n'
        yield f'// {name} Frame Format Configuration\n'
        yield f'// =============================================================================\n\n'

        yield f'/** Configuration for {name} frame format */\n'
        yield f'export const {name}Config: FrameParserConfig = {{\n'
        yield f'    name: \'{name}\',\n'

        # Start bytes array
        start_bytes_str = ', '.join(
            [f'0x{sb[1]:02X}' for sb in fmt.start_bytes])
        yield f'    startBytes: [{start_bytes_str}],\n'

        yield f'    headerSize: {fmt.header_size},\n'
        yield f'    footerSize: {fmt.footer_size},\n'
        yield f'    hasLength: {str(fmt.has_length).lower()},\n'
        yield f'    lengthBytes: {fmt.length_bytes},\n'
        yield f'    hasCrc: {str(fmt.has_crc).lower()},\n'
        yield '};\n\n'

        # Generate the class using the factory function
        yield f'/**\n'
        yield f' * {name} - Frame format parser and encoder\n'
        yield f' * \n'
        yield f' * Format: '
        parts = []
        for sb_name, sb_value in fmt.start_bytes:
            parts.append(f'[{sb_name.upper()}=0x{sb_value:02X}]')
        parts.append('[MSG_ID]')
        if fmt.has_length:
            parts.append(f'[LEN{"16" if fmt.length_bytes == 2 else ""}]')
        parts.append('[MSG...]')
        if fmt.has_crc:
            parts.append('[CRC1] [CRC2]')
        yield ' '.join(parts)
        yield '\n *\n'
        yield f' * This class is generated using createFrameParserClass() for code reuse.\n'
        yield f' */\n'
        yield f'export const {name} = createFrameParserClass({name}Config);\n\n'

        # Export parser state type alias for backward compatibility
        yield f'/** Parser state type alias for backward compatibility */\n'
        yield f'export type {name}ParserState = GenericParserState;\n'
        yield f'export {{ GenericParserState as {name}ParserState_Enum }};\n'

    @staticmethod
    def generate_index(formats):
        """Generate index.ts that exports all frame formats"""
        yield '// Automatically generated frame parser package\n'
        yield f'// Generated by {version} at {time.asctime()}.\n\n'
        yield '// Base utilities and generic parser infrastructure\n'
        yield 'export {\n'
        yield '    FrameFormatType,\n'
        yield '    FrameMsgInfo,\n'
        yield '    createFrameMsgInfo,\n'
        yield '    fletcher_checksum,\n'
        yield '    // Configuration interface for code reuse\n'
        yield '    FrameParserConfig,\n'
        yield '    // Generic parser class (use createFrameParserClass for type-safe wrappers)\n'
        yield '    GenericFrameParser,\n'
        yield '    GenericParserState,\n'
        yield '    createFrameParserClass,\n'
        yield '    // Shared payload parsing functions\n'
        yield '    validate_payload_with_crc,\n'
        yield '    validate_payload_minimal,\n'
        yield '    encode_payload_with_crc,\n'
        yield '    encode_payload_minimal,\n'
        yield '} from \'./frame_base\';\n\n'

        yield '// Individual frame format parsers (configuration-based)\n'
        for fmt in formats:
            yield f'export {{ {fmt.name}, {fmt.name}Config, {fmt.name}ParserState }} from \'./{fmt.name}\';\n'

    @staticmethod
    def generate(formats):
        """Generate the complete frame parser TypeScript file (single file, legacy mode)"""
        yield '// Automatically generated frame parser\n'
        yield f'// Generated by {version} at {time.asctime()}.\n\n'

        # Generate frame format enum
        yield '// Frame format type enumeration\n'
        yield 'export enum FrameFormatType {\n'
        for i, fmt in enumerate(formats):
            enum_name = camel_to_upper_snake(fmt.name)
            yield f'    {enum_name} = {i},\n'
        yield '}\n\n'

        # Generate checksum function
        yield '''// Fletcher-16 checksum calculation
export function fletcher_checksum(buffer: Uint8Array | number[], start: number = 0, end?: number): [number, number] {
    if (end === undefined) {
        end = buffer.length;
    }
    
    let byte1 = 0;
    let byte2 = 0;
    
    for (let i = start; i < end; i++) {
        byte1 = (byte1 + buffer[i]) % 256;
        byte2 = (byte2 + byte1) % 256;
    }
    
    return [byte1, byte2];
}

'''

        # Generate common result interface
        yield '''// Parse result interface
export interface FrameMsgInfo {
    valid: boolean;
    msg_id: number;
    msg_len: number;
    msg_data: Uint8Array;
}

// Create default FrameMsgInfo
export function createFrameMsgInfo(): FrameMsgInfo {
    return {
        valid: false,
        msg_id: 0,
        msg_len: 0,
        msg_data: new Uint8Array(0)
    };
}

// =============================================================================
// Shared Payload Parsing Functions
// =============================================================================
// These functions handle payload validation/encoding independent of framing.
// Frame formats (Tiny/Basic) use these for the common parsing logic.

/**
 * Validate a payload with CRC (shared by Default, Extended, etc. payload types).
 */
export function validate_payload_with_crc(
    buffer: Uint8Array | number[],
    headerSize: number,
    lengthBytes: number,
    crcStartOffset: number
): FrameMsgInfo {
    const result = createFrameMsgInfo();
    const footerSize = 2; // CRC is always 2 bytes
    const overhead = headerSize + footerSize;

    if (buffer.length < overhead) {
        return result;
    }

    const msgLength = buffer.length - overhead;

    // Calculate expected CRC range: from crcStartOffset to before the CRC bytes
    const crcDataLen = msgLength + 1 + lengthBytes; // msg_id (1) + lengthBytes + payload
    const ck = fletcher_checksum(buffer, crcStartOffset, crcStartOffset + crcDataLen);

    if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
        result.valid = true;
        result.msg_id = buffer[headerSize - 1]; // msg_id is last byte of header
        result.msg_len = msgLength;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, headerSize, buffer.length - footerSize));
    }

    return result;
}

/**
 * Validate a minimal payload (no CRC, no length field).
 */
export function validate_payload_minimal(
    buffer: Uint8Array | number[],
    headerSize: number
): FrameMsgInfo {
    const result = createFrameMsgInfo();

    if (buffer.length < headerSize) {
        return result;
    }

    result.valid = true;
    result.msg_id = buffer[headerSize - 1]; // msg_id is last byte of header
    result.msg_len = buffer.length - headerSize;
    result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, headerSize));

    return result;
}

/**
 * Encode payload with length and CRC (modifies output array in place).
 */
export function encode_payload_with_crc(
    output: number[],
    msgId: number,
    msg: Uint8Array | number[],
    lengthBytes: number,
    crcStartOffset: number
): void {
    // Add length field
    if (lengthBytes === 1) {
        output.push(msg.length & 0xFF);
    } else {
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
    }

    // Add msg_id
    output.push(msgId);

    // Add payload
    for (let i = 0; i < msg.length; i++) {
        output.push(msg[i]);
    }

    // Calculate and add CRC
    const crcDataLen = msg.length + 1 + lengthBytes;
    const ck = fletcher_checksum(output, crcStartOffset, crcStartOffset + crcDataLen);
    output.push(ck[0]);
    output.push(ck[1]);
}

/**
 * Encode minimal payload (no length, no CRC).
 */
export function encode_payload_minimal(
    output: number[],
    msgId: number,
    msg: Uint8Array | number[]
): void {
    output.push(msgId);
    for (let i = 0; i < msg.length; i++) {
        output.push(msg[i]);
    }
}

'''

        # Generate individual frame format classes
        for fmt in formats:
            yield from FrameParserTsGen.generate_format(fmt)
            yield '\n\n'

    @staticmethod
    def generate_format(fmt):
        """Generate TypeScript code for a single frame format"""
        name = fmt.name
        class_name = name
        PREFIX = camel_to_upper_snake(name)

        yield f'// =============================================================================\n'
        yield f'// {name} Frame Format\n'
        yield f'// =============================================================================\n\n'

        # Generate parser state enum
        yield f'export enum {class_name}ParserState {{\n'
        state_idx = 0
        if fmt.start_bytes:
            for i in range(len(fmt.start_bytes)):
                state_name = f'LOOKING_FOR_START{i + 1}' if len(
                    fmt.start_bytes) > 1 else 'LOOKING_FOR_START'
                yield f'    {state_name} = {state_idx},\n'
                state_idx += 1
        yield f'    GETTING_MSG_ID = {state_idx},\n'
        state_idx += 1
        if fmt.has_length:
            yield f'    GETTING_LENGTH = {state_idx},\n'
            state_idx += 1
        yield f'    GETTING_PAYLOAD = {state_idx}\n'
        yield '}\n\n'

        # Generate frame format class
        yield f'/**\n'
        yield f' * {name} - Frame format parser and encoder\n'
        yield f' * \n'
        yield f' * Format: '
        parts = []
        for sb_name, sb_value in fmt.start_bytes:
            parts.append(f'[{sb_name.upper()}=0x{sb_value:02X}]')
        parts.append('[MSG_ID]')
        if fmt.has_length:
            parts.append(f'[LEN{"16" if fmt.length_bytes == 2 else ""}]')
        parts.append('[MSG...]')
        if fmt.has_crc:
            parts.append('[CRC1] [CRC2]')
        yield ' '.join(parts)
        yield '\n */\n'
        yield f'export class {class_name} {{\n'

        # Constants
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            const_name = f'START_BYTE{i + 1}' if len(
                fmt.start_bytes) > 1 else 'START_BYTE'
            yield f'    static readonly {const_name} = 0x{sb_value:02X};\n'
        yield f'    static readonly HEADER_SIZE = {fmt.header_size};\n'
        yield f'    static readonly FOOTER_SIZE = {fmt.footer_size};\n'
        yield f'    static readonly OVERHEAD = {fmt.header_size + fmt.footer_size};\n'
        if fmt.has_length:
            yield f'    static readonly LENGTH_BYTES = {fmt.length_bytes};\n'
        yield '\n'

        # Instance properties
        yield f'    private state: {class_name}ParserState;\n'
        yield f'    private buffer: number[];\n'
        yield f'    private packet_size: number;\n'
        yield f'    private msg_id: number;\n'
        if fmt.has_length:
            yield f'    private msg_length: number;\n'
            if fmt.length_bytes == 2:
                yield f'    private length_lo: number;\n'
        yield f'    private get_msg_length?: (msg_id: number) => number | undefined;\n\n'

        # Constructor
        yield f'    /**\n'
        yield f'     * Create a new {name} parser\n'
        yield f'     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)\n'
        yield f'     */\n'
        yield f'    constructor(get_msg_length?: (msg_id: number) => number | undefined) {{\n'
        yield f'        this.get_msg_length = get_msg_length;\n'
        if fmt.start_bytes:
            state_name = 'LOOKING_FOR_START1' if len(
                fmt.start_bytes) > 1 else 'LOOKING_FOR_START'
            yield f'        this.state = {class_name}ParserState.{state_name};\n'
        else:
            yield f'        this.state = {class_name}ParserState.GETTING_MSG_ID;\n'
        yield f'        this.buffer = [];\n'
        yield f'        this.packet_size = 0;\n'
        yield f'        this.msg_id = 0;\n'
        if fmt.has_length:
            yield f'        this.msg_length = 0;\n'
            if fmt.length_bytes == 2:
                yield f'        this.length_lo = 0;\n'
        yield f'    }}\n\n'

        # Reset method
        yield f'    /** Reset parser state */\n'
        yield f'    reset(): void {{\n'
        if fmt.start_bytes:
            state_name = 'LOOKING_FOR_START1' if len(
                fmt.start_bytes) > 1 else 'LOOKING_FOR_START'
            yield f'        this.state = {class_name}ParserState.{state_name};\n'
        else:
            yield f'        this.state = {class_name}ParserState.GETTING_MSG_ID;\n'
        yield f'        this.buffer = [];\n'
        yield f'        this.packet_size = 0;\n'
        yield f'        this.msg_id = 0;\n'
        if fmt.has_length:
            yield f'        this.msg_length = 0;\n'
        yield f'    }}\n\n'

        # parse_byte method
        yield f'    /**\n'
        yield f'     * Parse a single byte\n'
        yield f'     * @param byte The byte to parse\n'
        yield f'     * @returns FrameMsgInfo with valid=true when a complete valid message is received\n'
        yield f'     */\n'
        yield f'    parse_byte(byte: number): FrameMsgInfo {{\n'
        yield f'        const result = createFrameMsgInfo();\n\n'
        yield f'        switch (this.state) {{\n'

        # State machine cases
        if fmt.start_bytes:
            for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
                state_name = f'LOOKING_FOR_START{i + 1}' if len(
                    fmt.start_bytes) > 1 else 'LOOKING_FOR_START'
                const_name = f'{class_name}.START_BYTE{i + 1}' if len(
                    fmt.start_bytes) > 1 else f'{class_name}.START_BYTE'

                yield f'            case {class_name}ParserState.{state_name}:\n'
                yield f'                if (byte === {const_name}) {{\n'

                if i == 0:
                    yield f'                    this.buffer = [byte];\n'
                else:
                    yield f'                    this.buffer.push(byte);\n'

                if i + 1 < len(fmt.start_bytes):
                    next_state = f'LOOKING_FOR_START{i + 2}'
                else:
                    next_state = 'GETTING_MSG_ID'
                yield f'                    this.state = {class_name}ParserState.{next_state};\n'
                yield f'                }}'

                # Handle seeing start byte 1 while looking for later bytes
                # This code only runs when len(fmt.start_bytes) > 1 (i.e., i > 0 is only possible with 2+ start bytes)
                if i > 0:
                    yield f' else if (byte === {class_name}.START_BYTE1) {{\n'
                    yield f'                    this.buffer = [byte];\n'
                    yield f'                    this.state = {class_name}ParserState.LOOKING_FOR_START2;\n'
                    yield f'                }} else {{\n'
                    yield f'                    this.state = {class_name}ParserState.LOOKING_FOR_START1;\n'
                    yield f'                }}\n'
                else:
                    yield '\n'
                yield f'                break;\n\n'

        # GETTING_MSG_ID state
        yield f'            case {class_name}ParserState.GETTING_MSG_ID:\n'
        yield f'                this.buffer.push(byte);\n'
        yield f'                this.msg_id = byte;\n'

        if fmt.has_length:
            yield f'                this.state = {class_name}ParserState.GETTING_LENGTH;\n'
        else:
            yield f'                if (this.get_msg_length) {{\n'
            yield f'                    const msg_length = this.get_msg_length(byte);\n'
            yield f'                    if (msg_length !== undefined) {{\n'
            yield f'                        this.packet_size = {class_name}.OVERHEAD + msg_length;\n'
            yield f'                        this.state = {class_name}ParserState.GETTING_PAYLOAD;\n'
            yield f'                    }} else {{\n'
            reset_state = 'LOOKING_FOR_START1' if len(fmt.start_bytes) > 1 else (
                'LOOKING_FOR_START' if fmt.start_bytes else 'GETTING_MSG_ID')
            yield f'                        this.state = {class_name}ParserState.{reset_state};\n'
            yield f'                    }}\n'
            yield f'                }} else {{\n'
            yield f'                    this.state = {class_name}ParserState.{reset_state};\n'
            yield f'                }}\n'
        yield f'                break;\n\n'

        # GETTING_LENGTH state (if applicable)
        if fmt.has_length:
            yield f'            case {class_name}ParserState.GETTING_LENGTH:\n'
            yield f'                this.buffer.push(byte);\n'
            if fmt.length_bytes == 1:
                yield f'                this.msg_length = byte;\n'
                yield f'                this.packet_size = {class_name}.OVERHEAD + this.msg_length;\n'
                yield f'                this.state = {class_name}ParserState.GETTING_PAYLOAD;\n'
            else:
                yield f'                if (this.buffer.length === {len(fmt.start_bytes) + 2}) {{\n'
                yield f'                    this.length_lo = byte;\n'
                yield f'                }} else {{\n'
                yield f'                    this.msg_length = this.length_lo | (byte << 8);\n'
                yield f'                    this.packet_size = {class_name}.OVERHEAD + this.msg_length;\n'
                yield f'                    this.state = {class_name}ParserState.GETTING_PAYLOAD;\n'
                yield f'                }}\n'
            yield f'                break;\n\n'

        # GETTING_PAYLOAD state - uses shared payload validation
        yield f'            case {class_name}ParserState.GETTING_PAYLOAD:\n'
        yield f'                this.buffer.push(byte);\n\n'
        yield f'                if (this.buffer.length >= this.packet_size) {{\n'

        if fmt.has_crc:
            crc_start = len(fmt.start_bytes)
            yield f'                    // Use shared payload validation with CRC\n'
            yield f'                    const validationResult = validate_payload_with_crc(this.buffer, {class_name}.HEADER_SIZE, {fmt.length_bytes}, {crc_start});\n'
            yield f'                    if (validationResult.valid) {{\n'
            yield f'                        result.valid = validationResult.valid;\n'
            yield f'                        result.msg_id = validationResult.msg_id;\n'
            yield f'                        result.msg_len = validationResult.msg_len;\n'
            yield f'                        result.msg_data = validationResult.msg_data;\n'
            yield f'                    }}\n'
        else:
            yield f'                    // Use shared minimal payload validation\n'
            yield f'                    const validationResult = validate_payload_minimal(this.buffer, {class_name}.HEADER_SIZE);\n'
            yield f'                    result.valid = validationResult.valid;\n'
            yield f'                    result.msg_id = validationResult.msg_id;\n'
            yield f'                    result.msg_len = validationResult.msg_len;\n'
            yield f'                    result.msg_data = validationResult.msg_data;\n'

        reset_state = 'LOOKING_FOR_START1' if len(fmt.start_bytes) > 1 else (
            'LOOKING_FOR_START' if fmt.start_bytes else 'GETTING_MSG_ID')
        yield f'                    this.state = {class_name}ParserState.{reset_state};\n'
        yield f'                }}\n'
        yield f'                break;\n'

        yield f'        }}\n\n'
        yield f'        return result;\n'
        yield f'    }}\n\n'

        # encode method - uses shared payload encoding functions
        yield f'    /**\n'
        yield f'     * Encode a message with {name} format\n'
        yield f'     * @param msg_id Message ID\n'
        yield f'     * @param msg Message data\n'
        yield f'     * @returns Encoded frame as Uint8Array\n'
        yield f'     */\n'
        yield f'    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {{\n'
        yield f'        const output: number[] = [];\n'

        # Write start bytes (frame-specific)
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            const_name = f'{class_name}.START_BYTE{i + 1}' if len(
                fmt.start_bytes) > 1 else f'{class_name}.START_BYTE'
            yield f'        output.push({const_name});\n'

        # Use shared payload encoding function
        if fmt.has_crc:
            crc_start = len(fmt.start_bytes)
            yield f'        // Use shared payload encoding with CRC\n'
            yield f'        encode_payload_with_crc(output, msg_id, msg, {fmt.length_bytes}, {crc_start});\n'
        else:
            yield f'        // Use shared minimal payload encoding\n'
            yield f'        encode_payload_minimal(output, msg_id, msg);\n'

        yield f'        return new Uint8Array(output);\n'
        yield f'    }}\n\n'

        # validate_packet static method - uses shared payload validation functions
        yield f'    /**\n'
        yield f'     * Validate a complete {name} packet in a buffer\n'
        yield f'     * @param buffer Buffer containing the complete packet\n'
        yield f'     * @returns FrameMsgInfo with valid=true if packet is valid\n'
        yield f'     */\n'
        yield f'    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {{\n'
        yield f'        if (buffer.length < {class_name}.OVERHEAD) {{\n'
        yield f'            return createFrameMsgInfo();\n'
        yield f'        }}\n\n'

        # Check start bytes
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            const_name = f'{class_name}.START_BYTE{i + 1}' if len(
                fmt.start_bytes) > 1 else f'{class_name}.START_BYTE'
            yield f'        if (buffer[{i}] !== {const_name}) {{\n'
            yield f'            return createFrameMsgInfo();\n'
            yield f'        }}\n'

        yield f'\n'

        # Use shared payload validation function
        if fmt.has_crc:
            crc_start = len(fmt.start_bytes)
            yield f'        // Use shared payload validation with CRC\n'
            yield f'        return validate_payload_with_crc(buffer, {class_name}.HEADER_SIZE, {fmt.length_bytes}, {crc_start});\n'
        else:
            yield f'        // Use shared minimal payload validation\n'
            yield f'        return validate_payload_minimal(buffer, {class_name}.HEADER_SIZE);\n'

        yield f'    }}\n'
        yield f'}}\n'


def generate_ts_frame_parsers(formats):
    """Generate TypeScript frame parser code from frame format definitions"""
    return ''.join(FrameParserTsGen.generate(formats))


def generate_ts_frame_parsers_multi(formats):
    """
    Generate multiple TypeScript files for frame parsers.

    Returns a dictionary mapping filename to content:
    - frame_base.ts: Base utilities (checksum, FrameMsgInfo, FrameFormatType)
    - {ClassName}.ts: Individual frame format files
    - index.ts: Package index that exports all frame formats
    """
    files = {}

    # Generate base file
    files['frame_base.ts'] = ''.join(FrameParserTsGen.generate_base(formats))

    # Generate individual frame format files
    for fmt in formats:
        files[f'{fmt.name}.ts'] = ''.join(
            FrameParserTsGen.generate_format_file(fmt))

    # Generate index.ts
    files['index.ts'] = ''.join(FrameParserTsGen.generate_index(formats))

    return files


class FrameParserJsGen:
    """Generates JavaScript code for frame parsers (no TypeScript annotations)"""

    @staticmethod
    def generate_base(formats):
        """Generate the base JavaScript file with common utilities and generic parser"""
        yield '// Automatically generated frame parser base utilities\n'
        yield f'// Generated by {version} at {time.asctime()}.\n\n'

        # Generate frame format enum as object
        yield '// Frame format type enumeration\n'
        yield 'const FrameFormatType = {\n'
        for i, fmt in enumerate(formats):
            enum_name = camel_to_upper_snake(fmt.name)
            yield f'    {enum_name}: {i},\n'
        yield '};\n\n'

        # Generate checksum function and utilities
        yield '''// Fletcher-16 checksum calculation
function fletcher_checksum(buffer, start = 0, end = undefined) {
    if (end === undefined) {
        end = buffer.length;
    }

    let byte1 = 0;
    let byte2 = 0;

    for (let i = start; i < end; i++) {
        byte1 = (byte1 + buffer[i]) % 256;
        byte2 = (byte2 + byte1) % 256;
    }

    return [byte1, byte2];
}

// Create default FrameMsgInfo
function createFrameMsgInfo() {
    return {
        valid: false,
        msg_id: 0,
        msg_len: 0,
        msg_data: new Uint8Array(0)
    };
}

// =============================================================================
// Shared Payload Parsing Functions
// =============================================================================
// These functions handle payload validation/encoding independent of framing.
// Frame formats (Tiny/Basic) use these for the common parsing logic.

/**
 * Validate a payload with CRC (shared by Default, Extended, etc. payload types).
 */
function validate_payload_with_crc(buffer, headerSize, lengthBytes, crcStartOffset) {
    const result = createFrameMsgInfo();
    const footerSize = 2; // CRC is always 2 bytes
    const overhead = headerSize + footerSize;

    if (buffer.length < overhead) {
        return result;
    }

    const msgLength = buffer.length - overhead;

    // Calculate expected CRC range: from crcStartOffset to before the CRC bytes
    const crcDataLen = msgLength + 1 + lengthBytes; // msg_id (1) + lengthBytes + payload
    const ck = fletcher_checksum(buffer, crcStartOffset, crcStartOffset + crcDataLen);

    if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
        result.valid = true;
        result.msg_id = buffer[headerSize - 1]; // msg_id is last byte of header
        result.msg_len = msgLength;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, headerSize, buffer.length - footerSize));
    }

    return result;
}

/**
 * Validate a minimal payload (no CRC, no length field).
 */
function validate_payload_minimal(buffer, headerSize) {
    const result = createFrameMsgInfo();

    if (buffer.length < headerSize) {
        return result;
    }

    result.valid = true;
    result.msg_id = buffer[headerSize - 1]; // msg_id is last byte of header
    result.msg_len = buffer.length - headerSize;
    result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, headerSize));

    return result;
}

/**
 * Encode payload with length and CRC (modifies output array in place).
 */
function encode_payload_with_crc(output, msgId, msg, lengthBytes, crcStartOffset) {
    // Add length field
    if (lengthBytes === 1) {
        output.push(msg.length & 0xFF);
    } else {
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
    }

    // Add msg_id
    output.push(msgId);

    // Add payload
    for (let i = 0; i < msg.length; i++) {
        output.push(msg[i]);
    }

    // Calculate and add CRC
    const crcDataLen = msg.length + 1 + lengthBytes;
    const ck = fletcher_checksum(output, crcStartOffset, crcStartOffset + crcDataLen);
    output.push(ck[0]);
    output.push(ck[1]);
}

/**
 * Encode minimal payload (no length, no CRC).
 */
function encode_payload_minimal(output, msgId, msg) {
    output.push(msgId);
    for (let i = 0; i < msg.length; i++) {
        output.push(msg[i]);
    }
}

// =============================================================================
// Generic Frame Parser
// =============================================================================
// This class provides a reusable frame parser that can be configured
// for different frame formats, reducing code duplication.

/** Parser state enumeration */
const GenericParserState = {
    LOOKING_FOR_START1: 0,
    LOOKING_FOR_START2: 1,
    GETTING_MSG_ID: 2,
    GETTING_LENGTH: 3,
    GETTING_PAYLOAD: 4
};

/**
 * Generic frame parser that works with any frame format configuration.
 * This class eliminates the need for separate parser classes per format.
 */
class GenericFrameParser {
    constructor(config, get_msg_length = undefined) {
        this.config = config;
        this.get_msg_length = get_msg_length;
        this.state = this._getInitialState();
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    _getInitialState() {
        if (this.config.startBytes.length === 0) {
            return GenericParserState.GETTING_MSG_ID;
        } else {
            return GenericParserState.LOOKING_FOR_START1;
        }
    }

    reset() {
        this.state = this._getInitialState();
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();
        const startBytes = this.config.startBytes;
        const overhead = this.config.headerSize + this.config.footerSize;

        switch (this.state) {
            case GenericParserState.LOOKING_FOR_START1:
                if (byte === startBytes[0]) {
                    this.buffer = [byte];
                    if (startBytes.length > 1) {
                        this.state = GenericParserState.LOOKING_FOR_START2;
                    } else {
                        this.state = GenericParserState.GETTING_MSG_ID;
                    }
                }
                break;

            case GenericParserState.LOOKING_FOR_START2:
                if (byte === startBytes[1]) {
                    this.buffer.push(byte);
                    this.state = GenericParserState.GETTING_MSG_ID;
                } else if (byte === startBytes[0]) {
                    this.buffer = [byte];
                    // Stay in LOOKING_FOR_START2
                } else {
                    this.state = GenericParserState.LOOKING_FOR_START1;
                }
                break;

            case GenericParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.config.hasLength) {
                    this.state = GenericParserState.GETTING_LENGTH;
                } else if (this.get_msg_length) {
                    const msgLen = this.get_msg_length(byte);
                    if (msgLen !== undefined) {
                        this.packet_size = overhead + msgLen;
                        this.state = GenericParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = this._getInitialState();
                    }
                } else {
                    this.state = this._getInitialState();
                }
                break;

            case GenericParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                if (this.config.lengthBytes === 1) {
                    this.msg_length = byte;
                    this.packet_size = overhead + this.msg_length;
                    this.state = GenericParserState.GETTING_PAYLOAD;
                } else {
                    // 2-byte length
                    if (this.buffer.length === startBytes.length + 2) {
                        this.length_lo = byte;
                    } else {
                        this.msg_length = this.length_lo | (byte << 8);
                        this.packet_size = overhead + this.msg_length;
                        this.state = GenericParserState.GETTING_PAYLOAD;
                    }
                }
                break;

            case GenericParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);
                if (this.buffer.length >= this.packet_size) {
                    if (this.config.hasCrc) {
                        const validationResult = validate_payload_with_crc(
                            this.buffer, this.config.headerSize, this.config.lengthBytes, startBytes.length);
                        if (validationResult.valid) {
                            result.valid = validationResult.valid;
                            result.msg_id = validationResult.msg_id;
                            result.msg_len = validationResult.msg_len;
                            result.msg_data = validationResult.msg_data;
                        }
                    } else {
                        const validationResult = validate_payload_minimal(this.buffer, this.config.headerSize);
                        result.valid = validationResult.valid;
                        result.msg_id = validationResult.msg_id;
                        result.msg_len = validationResult.msg_len;
                        result.msg_data = validationResult.msg_data;
                    }
                    this.state = this._getInitialState();
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message using this format (static method)
     */
    static encode(config, msg_id, msg) {
        const output = [];
        
        // Add start bytes
        for (const startByte of config.startBytes) {
            output.push(startByte);
        }
        
        // Use appropriate payload encoding
        if (config.hasCrc) {
            encode_payload_with_crc(output, msg_id, msg, config.lengthBytes, config.startBytes.length);
        } else {
            encode_payload_minimal(output, msg_id, msg);
        }
        
        return new Uint8Array(output);
    }

    /**
     * Validate a complete packet buffer using this format (static method)
     */
    static validate_packet(config, buffer) {
        const overhead = config.headerSize + config.footerSize;
        
        if (buffer.length < overhead) {
            return createFrameMsgInfo();
        }
        
        // Check start bytes
        for (let i = 0; i < config.startBytes.length; i++) {
            if (buffer[i] !== config.startBytes[i]) {
                return createFrameMsgInfo();
            }
        }
        
        // Validate payload
        if (config.hasCrc) {
            return validate_payload_with_crc(buffer, config.headerSize, config.lengthBytes, config.startBytes.length);
        } else {
            return validate_payload_minimal(buffer, config.headerSize);
        }
    }
}

/**
 * Create a frame parser class for a specific configuration.
 * This factory function provides pre-configured parser classes.
 */
function createFrameParserClass(config) {
    // Create a class that extends GenericFrameParser with the config baked in
    class ConfiguredFrameParser extends GenericFrameParser {
        constructor(get_msg_length = undefined) {
            super(config, get_msg_length);
        }

        static encode(msg_id, msg) {
            return GenericFrameParser.encode(config, msg_id, msg);
        }

        static validate_packet(buffer) {
            return GenericFrameParser.validate_packet(config, buffer);
        }
    }
    
    // Add static properties from config
    ConfiguredFrameParser.START_BYTES = config.startBytes;
    ConfiguredFrameParser.HEADER_SIZE = config.headerSize;
    ConfiguredFrameParser.FOOTER_SIZE = config.footerSize;
    ConfiguredFrameParser.OVERHEAD = config.headerSize + config.footerSize;
    ConfiguredFrameParser.HAS_LENGTH = config.hasLength;
    ConfiguredFrameParser.LENGTH_BYTES = config.lengthBytes;
    ConfiguredFrameParser.HAS_CRC = config.hasCrc;
    ConfiguredFrameParser.CONFIG = config;
    
    return ConfiguredFrameParser;
}

module.exports = {
    FrameFormatType,
    fletcher_checksum,
    createFrameMsgInfo,
    validate_payload_with_crc,
    validate_payload_minimal,
    encode_payload_with_crc,
    encode_payload_minimal,
    GenericParserState,
    GenericFrameParser,
    createFrameParserClass,
};
'''

    @staticmethod
    def generate_format_file(fmt):
        """Generate a JavaScript file for a single frame format using configuration-based approach"""
        name = fmt.name

        yield '// Automatically generated frame parser\n'
        yield f'// Generated by {version} at {time.asctime()}.\n\n'
        yield 'const {\n'
        yield '    createFrameParserClass, GenericParserState,\n'
        yield '} = require(\'./frame_base\');\n\n'

        # Generate configuration object
        yield f'// =============================================================================\n'
        yield f'// {name} Frame Format Configuration\n'
        yield f'// =============================================================================\n\n'

        yield f'/** Configuration for {name} frame format */\n'
        yield f'const {name}Config = {{\n'
        yield f'    name: \'{name}\',\n'

        # Start bytes array
        start_bytes_str = ', '.join(
            [f'0x{sb[1]:02X}' for sb in fmt.start_bytes])
        yield f'    startBytes: [{start_bytes_str}],\n'

        yield f'    headerSize: {fmt.header_size},\n'
        yield f'    footerSize: {fmt.footer_size},\n'
        yield f'    hasLength: {str(fmt.has_length).lower()},\n'
        yield f'    lengthBytes: {fmt.length_bytes},\n'
        yield f'    hasCrc: {str(fmt.has_crc).lower()},\n'
        yield '};\n\n'

        # Generate the class using the factory function
        yield f'/**\n'
        yield f' * {name} - Frame format parser and encoder\n'
        yield f' * \n'
        yield f' * Format: '
        parts = []
        for sb_name, sb_value in fmt.start_bytes:
            parts.append(f'[{sb_name.upper()}=0x{sb_value:02X}]')
        parts.append('[MSG_ID]')
        if fmt.has_length:
            parts.append(f'[LEN{"16" if fmt.length_bytes == 2 else ""}]')
        parts.append('[MSG...]')
        if fmt.has_crc:
            parts.append('[CRC1] [CRC2]')
        yield ' '.join(parts)
        yield '\n *\n'
        yield f' * This class is generated using createFrameParserClass() for code reuse.\n'
        yield f' */\n'
        yield f'const {name} = createFrameParserClass({name}Config);\n\n'

        # Export parser state alias for backward compatibility
        yield f'/** Parser state alias for backward compatibility */\n'
        yield f'const {name}ParserState = GenericParserState;\n\n'

        yield 'module.exports = {\n'
        yield f'    {name},\n'
        yield f'    {name}Config,\n'
        yield f'    {name}ParserState,\n'
        yield '};\n'

    @staticmethod
    def generate_index(formats):
        """Generate index.js that exports all frame formats"""
        yield '// Automatically generated frame parser package\n'
        yield f'// Generated by {version} at {time.asctime()}.\n\n'
        yield '// Base utilities\n'
        yield 'const frameBase = require(\'./frame_base\');\n\n'

        yield '// Individual frame format parsers\n'
        for fmt in formats:
            yield f'const {camel_to_snake(fmt.name)} = require(\'./{fmt.name}\');\n'

        yield '\nmodule.exports = {\n'
        yield '    // Base utilities\n'
        yield '    ...frameBase,\n'
        yield '    // Frame formats\n'
        for fmt in formats:
            snake_name = camel_to_snake(fmt.name)
            yield f'    ...{snake_name},\n'
        yield '};\n'

    @staticmethod
    def generate(formats):
        """Generate the complete frame parser JavaScript file (single file, legacy mode)"""
        yield '// Automatically generated frame parser\n'
        yield f'// Generated by {version} at {time.asctime()}.\n\n'

        # Generate frame format enum as object
        yield '// Frame format type enumeration\n'
        yield 'const FrameFormatType = {\n'
        for i, fmt in enumerate(formats):
            enum_name = camel_to_upper_snake(fmt.name)
            yield f'    {enum_name}: {i},\n'
        yield '};\n\n'

        # Generate checksum function
        yield '''// Fletcher-16 checksum calculation
function fletcher_checksum(buffer, start = 0, end = undefined) {
    if (end === undefined) {
        end = buffer.length;
    }
    
    let byte1 = 0;
    let byte2 = 0;
    
    for (let i = start; i < end; i++) {
        byte1 = (byte1 + buffer[i]) % 256;
        byte2 = (byte2 + byte1) % 256;
    }
    
    return [byte1, byte2];
}

// Create default FrameMsgInfo
function createFrameMsgInfo() {
    return {
        valid: false,
        msg_id: 0,
        msg_len: 0,
        msg_data: new Uint8Array(0)
    };
}

// =============================================================================
// Shared Payload Parsing Functions
// =============================================================================
// These functions handle payload validation/encoding independent of framing.
// Frame formats (Tiny/Basic) use these for the common parsing logic.

/**
 * Validate a payload with CRC (shared by Default, Extended, etc. payload types).
 */
function validate_payload_with_crc(buffer, headerSize, lengthBytes, crcStartOffset) {
    const result = createFrameMsgInfo();
    const footerSize = 2; // CRC is always 2 bytes
    const overhead = headerSize + footerSize;

    if (buffer.length < overhead) {
        return result;
    }

    const msgLength = buffer.length - overhead;

    // Calculate expected CRC range: from crcStartOffset to before the CRC bytes
    const crcDataLen = msgLength + 1 + lengthBytes; // msg_id (1) + lengthBytes + payload
    const ck = fletcher_checksum(buffer, crcStartOffset, crcStartOffset + crcDataLen);

    if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
        result.valid = true;
        result.msg_id = buffer[headerSize - 1]; // msg_id is last byte of header
        result.msg_len = msgLength;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, headerSize, buffer.length - footerSize));
    }

    return result;
}

/**
 * Validate a minimal payload (no CRC, no length field).
 */
function validate_payload_minimal(buffer, headerSize) {
    const result = createFrameMsgInfo();

    if (buffer.length < headerSize) {
        return result;
    }

    result.valid = true;
    result.msg_id = buffer[headerSize - 1]; // msg_id is last byte of header
    result.msg_len = buffer.length - headerSize;
    result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, headerSize));

    return result;
}

/**
 * Encode payload with length and CRC (modifies output array in place).
 */
function encode_payload_with_crc(output, msgId, msg, lengthBytes, crcStartOffset) {
    // Add length field
    if (lengthBytes === 1) {
        output.push(msg.length & 0xFF);
    } else {
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
    }

    // Add msg_id
    output.push(msgId);

    // Add payload
    for (let i = 0; i < msg.length; i++) {
        output.push(msg[i]);
    }

    // Calculate and add CRC
    const crcDataLen = msg.length + 1 + lengthBytes;
    const ck = fletcher_checksum(output, crcStartOffset, crcStartOffset + crcDataLen);
    output.push(ck[0]);
    output.push(ck[1]);
}

/**
 * Encode minimal payload (no length, no CRC).
 */
function encode_payload_minimal(output, msgId, msg) {
    output.push(msgId);
    for (let i = 0; i < msg.length; i++) {
        output.push(msg[i]);
    }
}

'''

        # Generate individual frame format classes
        for fmt in formats:
            yield from FrameParserJsGen.generate_format(fmt)
            yield '\n\n'

        # Generate exports
        yield '// Exports\n'
        yield 'module.exports = {\n'
        yield '    FrameFormatType,\n'
        yield '    fletcher_checksum,\n'
        yield '    createFrameMsgInfo,\n'
        yield '    validate_payload_with_crc,\n'
        yield '    validate_payload_minimal,\n'
        yield '    encode_payload_with_crc,\n'
        yield '    encode_payload_minimal,\n'
        for fmt in formats:
            yield f'    {fmt.name},\n'
            yield f'    {fmt.name}ParserState,\n'
        yield '};\n'

    @staticmethod
    def generate_format(fmt):
        """Generate JavaScript code for a single frame format (same as TS but without types)"""
        name = fmt.name
        class_name = name
        PREFIX = camel_to_upper_snake(name)

        yield f'// =============================================================================\n'
        yield f'// {name} Frame Format\n'
        yield f'// =============================================================================\n\n'

        # Generate parser state enum as object
        yield f'const {class_name}ParserState = {{\n'
        state_idx = 0
        if fmt.start_bytes:
            for i in range(len(fmt.start_bytes)):
                state_name = f'LOOKING_FOR_START{i + 1}' if len(
                    fmt.start_bytes) > 1 else 'LOOKING_FOR_START'
                yield f'    {state_name}: {state_idx},\n'
                state_idx += 1
        yield f'    GETTING_MSG_ID: {state_idx},\n'
        state_idx += 1
        if fmt.has_length:
            yield f'    GETTING_LENGTH: {state_idx},\n'
            state_idx += 1
        yield f'    GETTING_PAYLOAD: {state_idx}\n'
        yield '};\n\n'

        # Generate frame format class
        yield f'/**\n'
        yield f' * {name} - Frame format parser and encoder\n'
        yield f' */\n'
        yield f'class {class_name} {{\n'

        # Static constants
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            const_name = f'START_BYTE{i + 1}' if len(
                fmt.start_bytes) > 1 else 'START_BYTE'
            yield f'    static {const_name} = 0x{sb_value:02X};\n'
        yield f'    static HEADER_SIZE = {fmt.header_size};\n'
        yield f'    static FOOTER_SIZE = {fmt.footer_size};\n'
        yield f'    static OVERHEAD = {fmt.header_size + fmt.footer_size};\n'
        if fmt.has_length:
            yield f'    static LENGTH_BYTES = {fmt.length_bytes};\n'
        yield '\n'

        # Constructor
        yield f'    constructor(get_msg_length) {{\n'
        yield f'        this.get_msg_length = get_msg_length;\n'
        if fmt.start_bytes:
            state_name = 'LOOKING_FOR_START1' if len(
                fmt.start_bytes) > 1 else 'LOOKING_FOR_START'
            yield f'        this.state = {class_name}ParserState.{state_name};\n'
        else:
            yield f'        this.state = {class_name}ParserState.GETTING_MSG_ID;\n'
        yield f'        this.buffer = [];\n'
        yield f'        this.packet_size = 0;\n'
        yield f'        this.msg_id = 0;\n'
        if fmt.has_length:
            yield f'        this.msg_length = 0;\n'
            if fmt.length_bytes == 2:
                yield f'        this.length_lo = 0;\n'
        yield f'    }}\n\n'

        # Reset method
        yield f'    reset() {{\n'
        if fmt.start_bytes:
            state_name = 'LOOKING_FOR_START1' if len(
                fmt.start_bytes) > 1 else 'LOOKING_FOR_START'
            yield f'        this.state = {class_name}ParserState.{state_name};\n'
        else:
            yield f'        this.state = {class_name}ParserState.GETTING_MSG_ID;\n'
        yield f'        this.buffer = [];\n'
        yield f'        this.packet_size = 0;\n'
        yield f'        this.msg_id = 0;\n'
        if fmt.has_length:
            yield f'        this.msg_length = 0;\n'
        yield f'    }}\n\n'

        # parse_byte method (simplified version - same logic as TypeScript)
        yield f'    parse_byte(byte) {{\n'
        yield f'        const result = createFrameMsgInfo();\n\n'
        yield f'        switch (this.state) {{\n'

        # State machine cases (same as TypeScript but without type annotations)
        if fmt.start_bytes:
            for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
                state_name = f'LOOKING_FOR_START{i + 1}' if len(
                    fmt.start_bytes) > 1 else 'LOOKING_FOR_START'
                const_name = f'{class_name}.START_BYTE{i + 1}' if len(
                    fmt.start_bytes) > 1 else f'{class_name}.START_BYTE'

                yield f'            case {class_name}ParserState.{state_name}:\n'
                yield f'                if (byte === {const_name}) {{\n'

                if i == 0:
                    yield f'                    this.buffer = [byte];\n'
                else:
                    yield f'                    this.buffer.push(byte);\n'

                if i + 1 < len(fmt.start_bytes):
                    next_state = f'LOOKING_FOR_START{i + 2}'
                else:
                    next_state = 'GETTING_MSG_ID'
                yield f'                    this.state = {class_name}ParserState.{next_state};\n'
                yield f'                }}'

                # This code only runs when len(fmt.start_bytes) > 1 (i.e., i > 0 is only possible with 2+ start bytes)
                if i > 0:
                    yield f' else if (byte === {class_name}.START_BYTE1) {{\n'
                    yield f'                    this.buffer = [byte];\n'
                    yield f'                    this.state = {class_name}ParserState.LOOKING_FOR_START2;\n'
                    yield f'                }} else {{\n'
                    yield f'                    this.state = {class_name}ParserState.LOOKING_FOR_START1;\n'
                    yield f'                }}\n'
                else:
                    yield '\n'
                yield f'                break;\n\n'

        # GETTING_MSG_ID state
        yield f'            case {class_name}ParserState.GETTING_MSG_ID:\n'
        yield f'                this.buffer.push(byte);\n'
        yield f'                this.msg_id = byte;\n'

        if fmt.has_length:
            yield f'                this.state = {class_name}ParserState.GETTING_LENGTH;\n'
        else:
            yield f'                if (this.get_msg_length) {{\n'
            yield f'                    const msg_length = this.get_msg_length(byte);\n'
            yield f'                    if (msg_length !== undefined) {{\n'
            yield f'                        this.packet_size = {class_name}.OVERHEAD + msg_length;\n'
            yield f'                        this.state = {class_name}ParserState.GETTING_PAYLOAD;\n'
            yield f'                    }} else {{\n'
            reset_state = 'LOOKING_FOR_START1' if len(fmt.start_bytes) > 1 else (
                'LOOKING_FOR_START' if fmt.start_bytes else 'GETTING_MSG_ID')
            yield f'                        this.state = {class_name}ParserState.{reset_state};\n'
            yield f'                    }}\n'
            yield f'                }} else {{\n'
            yield f'                    this.state = {class_name}ParserState.{reset_state};\n'
            yield f'                }}\n'
        yield f'                break;\n\n'

        # GETTING_LENGTH state (if applicable)
        if fmt.has_length:
            yield f'            case {class_name}ParserState.GETTING_LENGTH:\n'
            yield f'                this.buffer.push(byte);\n'
            if fmt.length_bytes == 1:
                yield f'                this.msg_length = byte;\n'
                yield f'                this.packet_size = {class_name}.OVERHEAD + this.msg_length;\n'
                yield f'                this.state = {class_name}ParserState.GETTING_PAYLOAD;\n'
            else:
                yield f'                if (this.buffer.length === {len(fmt.start_bytes) + 2}) {{\n'
                yield f'                    this.length_lo = byte;\n'
                yield f'                }} else {{\n'
                yield f'                    this.msg_length = this.length_lo | (byte << 8);\n'
                yield f'                    this.packet_size = {class_name}.OVERHEAD + this.msg_length;\n'
                yield f'                    this.state = {class_name}ParserState.GETTING_PAYLOAD;\n'
                yield f'                }}\n'
            yield f'                break;\n\n'

        # GETTING_PAYLOAD state - uses shared payload validation
        yield f'            case {class_name}ParserState.GETTING_PAYLOAD:\n'
        yield f'                this.buffer.push(byte);\n\n'
        yield f'                if (this.buffer.length >= this.packet_size) {{\n'

        if fmt.has_crc:
            crc_start = len(fmt.start_bytes)
            yield f'                    // Use shared payload validation with CRC\n'
            yield f'                    const validationResult = validate_payload_with_crc(this.buffer, {class_name}.HEADER_SIZE, {fmt.length_bytes}, {crc_start});\n'
            yield f'                    if (validationResult.valid) {{\n'
            yield f'                        result.valid = validationResult.valid;\n'
            yield f'                        result.msg_id = validationResult.msg_id;\n'
            yield f'                        result.msg_len = validationResult.msg_len;\n'
            yield f'                        result.msg_data = validationResult.msg_data;\n'
            yield f'                    }}\n'
        else:
            yield f'                    // Use shared minimal payload validation\n'
            yield f'                    const validationResult = validate_payload_minimal(this.buffer, {class_name}.HEADER_SIZE);\n'
            yield f'                    result.valid = validationResult.valid;\n'
            yield f'                    result.msg_id = validationResult.msg_id;\n'
            yield f'                    result.msg_len = validationResult.msg_len;\n'
            yield f'                    result.msg_data = validationResult.msg_data;\n'

        reset_state = 'LOOKING_FOR_START1' if len(fmt.start_bytes) > 1 else (
            'LOOKING_FOR_START' if fmt.start_bytes else 'GETTING_MSG_ID')
        yield f'                    this.state = {class_name}ParserState.{reset_state};\n'
        yield f'                }}\n'
        yield f'                break;\n'

        yield f'        }}\n\n'
        yield f'        return result;\n'
        yield f'    }}\n\n'

        # Static encode method - uses shared payload encoding functions
        yield f'    static encode(msg_id, msg) {{\n'
        yield f'        const output = [];\n'

        # Write start bytes (frame-specific)
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            const_name = f'{class_name}.START_BYTE{i + 1}' if len(
                fmt.start_bytes) > 1 else f'{class_name}.START_BYTE'
            yield f'        output.push({const_name});\n'

        # Use shared payload encoding function
        if fmt.has_crc:
            crc_start = len(fmt.start_bytes)
            yield f'        // Use shared payload encoding with CRC\n'
            yield f'        encode_payload_with_crc(output, msg_id, msg, {fmt.length_bytes}, {crc_start});\n'
        else:
            yield f'        // Use shared minimal payload encoding\n'
            yield f'        encode_payload_minimal(output, msg_id, msg);\n'

        yield f'        return new Uint8Array(output);\n'
        yield f'    }}\n\n'

        # Static validate_packet method - uses shared payload validation functions
        yield f'    static validate_packet(buffer) {{\n'
        yield f'        if (buffer.length < {class_name}.OVERHEAD) {{\n'
        yield f'            return createFrameMsgInfo();\n'
        yield f'        }}\n\n'

        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            const_name = f'{class_name}.START_BYTE{i + 1}' if len(
                fmt.start_bytes) > 1 else f'{class_name}.START_BYTE'
            yield f'        if (buffer[{i}] !== {const_name}) {{\n'
            yield f'            return createFrameMsgInfo();\n'
            yield f'        }}\n'

        yield f'\n'

        # Use shared payload validation function
        if fmt.has_crc:
            crc_start = len(fmt.start_bytes)
            yield f'        // Use shared payload validation with CRC\n'
            yield f'        return validate_payload_with_crc(buffer, {class_name}.HEADER_SIZE, {fmt.length_bytes}, {crc_start});\n'
        else:
            yield f'        // Use shared minimal payload validation\n'
            yield f'        return validate_payload_minimal(buffer, {class_name}.HEADER_SIZE);\n'

        yield f'    }}\n'
        yield f'}}\n'


def generate_js_frame_parsers(formats):
    """Generate JavaScript frame parser code from frame format definitions"""
    return ''.join(FrameParserJsGen.generate(formats))


def generate_js_frame_parsers_multi(formats):
    """
    Generate multiple JavaScript files for frame parsers.

    Returns a dictionary mapping filename to content:
    - frame_base.js: Base utilities (checksum, FrameMsgInfo, FrameFormatType)
    - {ClassName}.js: Individual frame format files
    - index.js: Package index that exports all frame formats
    """
    files = {}

    # Generate base file
    files['frame_base.js'] = ''.join(FrameParserJsGen.generate_base(formats))

    # Generate individual frame format files
    for fmt in formats:
        files[f'{fmt.name}.js'] = ''.join(
            FrameParserJsGen.generate_format_file(fmt))

    # Generate index.js
    files['index.js'] = ''.join(FrameParserJsGen.generate_index(formats))

    return files
