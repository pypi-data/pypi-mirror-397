#!/usr/bin/env python3
# kate: replace-tabs on; indent-width 4;

"""
C++ Frame Parser Generator

Generates C++ code for frame parsers based on frame format definitions.
"""

from struct_frame import version
import time


def camel_to_snake(name):
    """Convert CamelCase to snake_case"""
    import re
    name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', name)
    return name.lower()


def camel_to_upper_snake(name):
    """Convert CamelCase to UPPER_SNAKE_CASE"""
    return camel_to_snake(name).upper()


class FrameParserCppGen:
    """Generates C++ code for frame parsers"""

    @staticmethod
    def generate_base(formats):
        """Generate the base C++ header file with common utilities"""
        yield '/* Automatically generated frame parser base utilities */\n'
        yield f'/* Generated by {version} at {time.asctime()}. */\n\n'
        yield '#pragma once\n\n'
        yield '#include <cstddef>\n'
        yield '#include <cstdint>\n'
        yield '#include <cstring>\n'
        yield '#include <functional>\n\n'
        yield 'namespace FrameParsers {\n\n'

        # Generate frame format enum
        yield '// Frame format type enumeration\n'
        yield 'enum class FrameFormatType {\n'
        for i, fmt in enumerate(formats):
            enum_name = camel_to_upper_snake(fmt.name)
            yield f'    {enum_name} = {i},\n'
        yield '};\n\n'

        # Generate checksum struct and function
        yield '''// Checksum result
struct FrameChecksum {
    uint8_t byte1;
    uint8_t byte2;
};

// Fletcher-16 checksum calculation
inline FrameChecksum fletcher_checksum(const uint8_t* data, size_t length) {
    FrameChecksum ck{0, 0};
    for (size_t i = 0; i < length; i++) {
        ck.byte1 = static_cast<uint8_t>(ck.byte1 + data[i]);
        ck.byte2 = static_cast<uint8_t>(ck.byte2 + ck.byte1);
    }
    return ck;
}

'''

        # Generate common result struct
        yield '''// Parse result
struct FrameMsgInfo {
    bool valid;
    uint8_t msg_id;
    size_t msg_len;
    uint8_t* msg_data;

    FrameMsgInfo() : valid(false), msg_id(0), msg_len(0), msg_data(nullptr) {}
    FrameMsgInfo(bool v, uint8_t id, size_t len, uint8_t* data)
        : valid(v), msg_id(id), msg_len(len), msg_data(data) {}
};

// =============================================================================
// Shared Payload Parsing Functions
// =============================================================================
// These functions handle payload validation/encoding independent of framing.
// Frame formats (Tiny/Basic) use these for the common parsing logic.

/**
 * Validate a payload with CRC (shared by Default, Extended, etc. payload types).
 */
inline FrameMsgInfo validate_payload_with_crc(
    const uint8_t* buffer, size_t length,
    size_t header_size, size_t length_bytes, size_t crc_start_offset) {
    
    constexpr size_t footer_size = 2; // CRC is always 2 bytes
    const size_t overhead = header_size + footer_size;
    
    if (length < overhead) {
        return FrameMsgInfo();
    }
    
    size_t msg_length = length - overhead;
    
    // Calculate expected CRC range: from crc_start_offset to before the CRC bytes
    size_t crc_data_len = msg_length + 1 + length_bytes; // msg_id (1) + length_bytes + payload
    FrameChecksum ck = fletcher_checksum(buffer + crc_start_offset, crc_data_len);
    
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        return FrameMsgInfo(true, buffer[header_size - 1], msg_length,
                          const_cast<uint8_t*>(buffer + header_size));
    }
    
    return FrameMsgInfo();
}

/**
 * Validate a minimal payload (no CRC, no length field).
 */
inline FrameMsgInfo validate_payload_minimal(
    const uint8_t* buffer, size_t length, size_t header_size) {
    
    if (length < header_size) {
        return FrameMsgInfo();
    }
    
    return FrameMsgInfo(true, buffer[header_size - 1], length - header_size,
                       const_cast<uint8_t*>(buffer + header_size));
}

/**
 * Encode payload with length and CRC into output buffer.
 * Returns number of bytes written (length + msg_id + payload + CRC)
 */
inline size_t encode_payload_with_crc(
    uint8_t* output, uint8_t msg_id, const uint8_t* msg, size_t msg_size,
    size_t length_bytes, const uint8_t* crc_start) {
    
    size_t idx = 0;
    
    // Add length field
    if (length_bytes == 1) {
        output[idx++] = static_cast<uint8_t>(msg_size & 0xFF);
    } else {
        output[idx++] = static_cast<uint8_t>(msg_size & 0xFF);
        output[idx++] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);
    }
    
    // Add msg_id
    output[idx++] = msg_id;
    
    // Add payload
    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(output + idx, msg, msg_size);
        idx += msg_size;
    }
    
    // Calculate and add CRC
    size_t crc_data_len = msg_size + 1 + length_bytes;
    FrameChecksum ck = fletcher_checksum(crc_start, crc_data_len);
    output[idx++] = ck.byte1;
    output[idx++] = ck.byte2;
    
    return idx;
}

/**
 * Encode minimal payload (no length, no CRC) into output buffer.
 * Returns number of bytes written (msg_id + payload)
 */
inline size_t encode_payload_minimal(
    uint8_t* output, uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    
    size_t idx = 0;
    
    // Add msg_id
    output[idx++] = msg_id;
    
    // Add payload
    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(output + idx, msg, msg_size);
        idx += msg_size;
    }
    
    return idx;
}

}  // namespace FrameParsers
'''

    @staticmethod
    def generate_format_file(fmt):
        """Generate a C++ header file for a single frame format"""
        yield '/* Automatically generated frame parser */\n'
        yield f'/* Generated by {version} at {time.asctime()}. */\n\n'
        yield '#pragma once\n\n'
        yield '#include "frame_base.hpp"\n\n'
        yield 'namespace FrameParsers {\n\n'

        yield from FrameParserCppGen.generate_format(fmt)

        yield '}  // namespace FrameParsers\n'

    @staticmethod
    def generate_main_header(formats):
        """Generate main header that includes all frame format headers"""
        yield '/* Automatically generated frame parser main header */\n'
        yield f'/* Generated by {version} at {time.asctime()}. */\n\n'
        yield '#pragma once\n\n'
        yield '/* Base utilities */\n'
        yield '#include "frame_base.hpp"\n\n'
        yield '/* Individual frame format parsers */\n'
        for fmt in formats:
            yield f'#include "{fmt.name}.hpp"\n'

    @staticmethod
    def generate_header(formats):
        """Generate the complete frame parser header file (single file, legacy mode)"""
        yield '/* Automatically generated frame parser header */\n'
        yield f'/* Generated by {version} at {time.asctime()}. */\n\n'
        yield '#pragma once\n\n'
        yield '#include <cstddef>\n'
        yield '#include <cstdint>\n'
        yield '#include <cstring>\n'
        yield '#include <functional>\n\n'
        yield 'namespace FrameParsers {\n\n'
        
        # Generate frame format enum
        yield '// Frame format type enumeration\n'
        yield 'enum class FrameFormatType {\n'
        for i, fmt in enumerate(formats):
            enum_name = camel_to_upper_snake(fmt.name)
            yield f'    {enum_name} = {i},\n'
        yield '};\n\n'
        
        # Generate checksum struct and function
        yield '''// Checksum result
struct FrameChecksum {
    uint8_t byte1;
    uint8_t byte2;
};

// Fletcher-16 checksum calculation
inline FrameChecksum fletcher_checksum(const uint8_t* data, size_t length) {
    FrameChecksum ck{0, 0};
    for (size_t i = 0; i < length; i++) {
        ck.byte1 = static_cast<uint8_t>(ck.byte1 + data[i]);
        ck.byte2 = static_cast<uint8_t>(ck.byte2 + ck.byte1);
    }
    return ck;
}

'''
        
        # Generate common result struct
        yield '''// Parse result
struct FrameMsgInfo {
    bool valid;
    uint8_t msg_id;
    size_t msg_len;
    uint8_t* msg_data;
    
    FrameMsgInfo() : valid(false), msg_id(0), msg_len(0), msg_data(nullptr) {}
    FrameMsgInfo(bool v, uint8_t id, size_t len, uint8_t* data)
        : valid(v), msg_id(id), msg_len(len), msg_data(data) {}
};

// =============================================================================
// Shared Payload Parsing Functions
// =============================================================================
// These functions handle payload validation/encoding independent of framing.
// Frame formats (Tiny/Basic) use these for the common parsing logic.

inline FrameMsgInfo validate_payload_with_crc(
    const uint8_t* buffer, size_t length,
    size_t header_size, size_t length_bytes, size_t crc_start_offset) {
    
    constexpr size_t footer_size = 2;
    const size_t overhead = header_size + footer_size;
    
    if (length < overhead) {
        return FrameMsgInfo();
    }
    
    size_t msg_length = length - overhead;
    size_t crc_data_len = msg_length + 1 + length_bytes;
    FrameChecksum ck = fletcher_checksum(buffer + crc_start_offset, crc_data_len);
    
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        return FrameMsgInfo(true, buffer[header_size - 1], msg_length,
                          const_cast<uint8_t*>(buffer + header_size));
    }
    
    return FrameMsgInfo();
}

inline FrameMsgInfo validate_payload_minimal(
    const uint8_t* buffer, size_t length, size_t header_size) {
    
    if (length < header_size) {
        return FrameMsgInfo();
    }
    
    return FrameMsgInfo(true, buffer[header_size - 1], length - header_size,
                       const_cast<uint8_t*>(buffer + header_size));
}

inline size_t encode_payload_with_crc(
    uint8_t* output, uint8_t msg_id, const uint8_t* msg, size_t msg_size,
    size_t length_bytes, const uint8_t* crc_start) {
    
    size_t idx = 0;
    
    if (length_bytes == 1) {
        output[idx++] = static_cast<uint8_t>(msg_size & 0xFF);
    } else {
        output[idx++] = static_cast<uint8_t>(msg_size & 0xFF);
        output[idx++] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);
    }
    
    output[idx++] = msg_id;
    
    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(output + idx, msg, msg_size);
        idx += msg_size;
    }
    
    size_t crc_data_len = msg_size + 1 + length_bytes;
    FrameChecksum ck = fletcher_checksum(crc_start, crc_data_len);
    output[idx++] = ck.byte1;
    output[idx++] = ck.byte2;
    
    return idx;
}

inline size_t encode_payload_minimal(
    uint8_t* output, uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    
    size_t idx = 0;
    output[idx++] = msg_id;
    
    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(output + idx, msg, msg_size);
        idx += msg_size;
    }
    
    return idx;
}

'''
        
        # Generate individual frame format classes
        for fmt in formats:
            yield from FrameParserCppGen.generate_format(fmt)
            yield '\n'
            
        yield '}  // namespace FrameParsers\n'
            
    @staticmethod
    def generate_format(fmt):
        """Generate C++ code for a single frame format"""
        name = fmt.name
        class_name = name
        PREFIX = camel_to_upper_snake(name)
        
        yield f'// =============================================================================\n'
        yield f'// {name} Frame Format\n'
        yield f'// =============================================================================\n\n'
        
        # Generate parser state enum
        yield f'enum class {class_name}ParserState : uint8_t {{\n'
        state_idx = 0
        if fmt.start_bytes:
            for i in range(len(fmt.start_bytes)):
                state_name = f'LookingForStart{i + 1}' if len(fmt.start_bytes) > 1 else 'LookingForStart'
                yield f'    {state_name} = {state_idx},\n'
                state_idx += 1
        yield f'    GettingMsgId = {state_idx},\n'
        state_idx += 1
        if fmt.has_length:
            yield f'    GettingLength = {state_idx},\n'
            state_idx += 1
        yield f'    GettingPayload = {state_idx}\n'
        yield '};\n\n'
        
        # Generate constants
        yield f'// {name} constants\n'
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            const_name = f'{PREFIX}_START_BYTE{i + 1}' if len(fmt.start_bytes) > 1 else f'{PREFIX}_START_BYTE'
            yield f'constexpr uint8_t {const_name} = 0x{sb_value:02X};\n'
        yield f'constexpr size_t {PREFIX}_HEADER_SIZE = {fmt.header_size};\n'
        yield f'constexpr size_t {PREFIX}_FOOTER_SIZE = {fmt.footer_size};\n'
        yield f'constexpr size_t {PREFIX}_OVERHEAD = {PREFIX}_HEADER_SIZE + {PREFIX}_FOOTER_SIZE;\n'
        if fmt.has_length:
            yield f'constexpr size_t {PREFIX}_LENGTH_BYTES = {fmt.length_bytes};\n'
        yield '\n'
        
        # Generate encode buffer class
        yield f'/**\n'
        yield f' * {name} Encode Buffer\n'
        yield f' */\n'
        yield f'class {class_name}EncodeBuffer {{\n'
        yield f'public:\n'
        yield f'    {class_name}EncodeBuffer(uint8_t* data, size_t max_size)\n'
        yield f'        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {{}}\n\n'
        yield f'    void reset() {{\n'
        yield f'        size_ = 0;\n'
        yield f'        in_progress_ = false;\n'
        yield f'    }}\n\n'
        yield f'    uint8_t* data() {{ return data_; }}\n'
        yield f'    const uint8_t* data() const {{ return data_; }}\n'
        yield f'    size_t size() const {{ return size_; }}\n'
        yield f'    size_t max_size() const {{ return max_size_; }}\n'
        yield f'    bool in_progress() const {{ return in_progress_; }}\n\n'
        
        # encode method
        yield f'    /**\n'
        yield f'     * Encode a message into the buffer\n'
        yield f'     */\n'
        yield f'    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {{\n'
        yield f'        if (in_progress_) return false;\n\n'
        yield f'        size_t total_size = {PREFIX}_OVERHEAD + msg_size;\n'
        yield f'        if (size_ + total_size > max_size_) return false;\n\n'
        yield f'        uint8_t* packet_start = data_ + size_;\n\n'
        yield f'        // Write header\n'
        idx = 0
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            const_name = f'{PREFIX}_START_BYTE{i + 1}' if len(fmt.start_bytes) > 1 else f'{PREFIX}_START_BYTE'
            yield f'        packet_start[{idx}] = {const_name};\n'
            idx += 1
        yield f'        packet_start[{idx}] = msg_id;\n'
        idx += 1
        if fmt.has_length:
            if fmt.length_bytes == 1:
                yield f'        packet_start[{idx}] = static_cast<uint8_t>(msg_size);\n'
            else:
                yield f'        packet_start[{idx}] = static_cast<uint8_t>(msg_size & 0xFF);\n'
                yield f'        packet_start[{idx + 1}] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);\n'
            idx += fmt.length_bytes
        
        yield f'\n        // Write message data\n'
        yield f'        if (msg_size > 0 && msg != nullptr) {{\n'
        yield f'            std::memcpy(packet_start + {PREFIX}_HEADER_SIZE, msg, msg_size);\n'
        yield f'        }}\n\n'
        
        if fmt.has_crc:
            yield f'        // Calculate checksum\n'
            crc_data_start = len(fmt.start_bytes)
            crc_data_len = f'msg_size + 1'
            if fmt.has_length:
                crc_data_len += f' + {fmt.length_bytes}'
            yield f'        FrameChecksum ck = fletcher_checksum(packet_start + {crc_data_start}, {crc_data_len});\n'
            yield f'        packet_start[{PREFIX}_HEADER_SIZE + msg_size] = ck.byte1;\n'
            yield f'        packet_start[{PREFIX}_HEADER_SIZE + msg_size + 1] = ck.byte2;\n'
        
        yield f'\n        size_ += total_size;\n'
        yield f'        return true;\n'
        yield f'    }}\n\n'
        
        yield f'private:\n'
        yield f'    uint8_t* data_;\n'
        yield f'    size_t max_size_;\n'
        yield f'    size_t size_;\n'
        yield f'    bool in_progress_;\n'
        yield f'}};\n\n'
        
        # Generate parser class
        yield f'/**\n'
        yield f' * {name} Frame Parser\n'
        yield f' */\n'
        yield f'class {class_name}Parser {{\n'
        yield f'public:\n'
        yield f'    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;\n\n'
        yield f'    {class_name}Parser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)\n'
        yield f'        : state_({class_name}ParserState::'
        if fmt.start_bytes:
            yield f'LookingForStart{"1" if len(fmt.start_bytes) > 1 else ""}'
        else:
            yield 'GettingMsgId'
        yield f'),\n'
        yield f'          buffer_(buffer),\n'
        yield f'          buffer_max_size_(buffer_size),\n'
        yield f'          buffer_index_(0),\n'
        yield f'          packet_size_(0),\n'
        yield f'          msg_id_(0),\n'
        if fmt.has_length:
            yield f'          msg_length_(0),\n'
            if fmt.length_bytes == 2:
                yield f'          length_lo_(0),\n'
        yield f'          get_msg_length_(std::move(msg_length_cb)) {{}}\n\n'
        
        # reset method
        yield f'    void reset() {{\n'
        if fmt.start_bytes:
            yield f'        state_ = {class_name}ParserState::LookingForStart{"1" if len(fmt.start_bytes) > 1 else ""};\n'
        else:
            yield f'        state_ = {class_name}ParserState::GettingMsgId;\n'
        yield f'        buffer_index_ = 0;\n'
        yield f'        packet_size_ = 0;\n'
        yield f'        msg_id_ = 0;\n'
        if fmt.has_length:
            yield f'        msg_length_ = 0;\n'
        yield f'    }}\n\n'
        
        # parse_byte method
        yield f'    /**\n'
        yield f'     * Parse a single byte\n'
        yield f'     * Returns FrameMsgInfo with valid=true when a complete valid message is received\n'
        yield f'     */\n'
        yield f'    FrameMsgInfo parse_byte(uint8_t byte) {{\n'
        yield f'        FrameMsgInfo result;\n\n'
        yield f'        switch (state_) {{\n'
        
        # State machine cases
        if fmt.start_bytes:
            for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
                state_name = f'LookingForStart{i + 1}' if len(fmt.start_bytes) > 1 else 'LookingForStart'
                const_name = f'{PREFIX}_START_BYTE{i + 1}' if len(fmt.start_bytes) > 1 else f'{PREFIX}_START_BYTE'
                
                yield f'            case {class_name}ParserState::{state_name}:\n'
                yield f'                if (byte == {const_name}) {{\n'
                yield f'                    buffer_[{i}] = byte;\n'
                yield f'                    buffer_index_ = {i + 1};\n'
                
                if i + 1 < len(fmt.start_bytes):
                    next_state = f'LookingForStart{i + 2}'
                else:
                    next_state = 'GettingMsgId'
                yield f'                    state_ = {class_name}ParserState::{next_state};\n'
                yield f'                }}'
                
                # This code only runs when len(fmt.start_bytes) > 1 (i.e., i > 0 is only possible with 2+ start bytes)
                if i > 0:
                    yield f' else if (byte == {PREFIX}_START_BYTE1) {{\n'
                    yield f'                    buffer_[0] = byte;\n'
                    yield f'                    buffer_index_ = 1;\n'
                    yield f'                    state_ = {class_name}ParserState::LookingForStart2;\n'
                    yield f'                }} else {{\n'
                    yield f'                    state_ = {class_name}ParserState::LookingForStart1;\n'
                    yield f'                }}\n'
                else:
                    yield '\n'
                yield f'                break;\n\n'
        
        # GettingMsgId state
        yield f'            case {class_name}ParserState::GettingMsgId: {{\n'
        yield f'                buffer_[buffer_index_++] = byte;\n'
        yield f'                msg_id_ = byte;\n\n'
        
        if fmt.has_length:
            yield f'                state_ = {class_name}ParserState::GettingLength;\n'
        else:
            yield f'                size_t msg_length = 0;\n'
            yield f'                if (get_msg_length_ && get_msg_length_(byte, &msg_length)) {{\n'
            yield f'                    packet_size_ = {PREFIX}_OVERHEAD + msg_length;\n'
            yield f'                    if (packet_size_ <= buffer_max_size_) {{\n'
            yield f'                        state_ = {class_name}ParserState::GettingPayload;\n'
            yield f'                    }} else {{\n'
            reset_state = 'LookingForStart1' if len(fmt.start_bytes) > 1 else ('LookingForStart' if fmt.start_bytes else 'GettingMsgId')
            yield f'                        state_ = {class_name}ParserState::{reset_state};\n'
            yield f'                    }}\n'
            yield f'                }} else {{\n'
            yield f'                    state_ = {class_name}ParserState::{reset_state};\n'
            yield f'                }}\n'
        yield f'                break;\n'
        yield f'            }}\n\n'
        
        # GettingLength state (if applicable)
        if fmt.has_length:
            yield f'            case {class_name}ParserState::GettingLength:\n'
            yield f'                buffer_[buffer_index_++] = byte;\n'
            if fmt.length_bytes == 1:
                yield f'                msg_length_ = byte;\n'
                yield f'                packet_size_ = {PREFIX}_OVERHEAD + msg_length_;\n'
                yield f'                if (packet_size_ <= buffer_max_size_) {{\n'
                yield f'                    state_ = {class_name}ParserState::GettingPayload;\n'
                yield f'                }} else {{\n'
                reset_state = 'LookingForStart1' if len(fmt.start_bytes) > 1 else ('LookingForStart' if fmt.start_bytes else 'GettingMsgId')
                yield f'                    state_ = {class_name}ParserState::{reset_state};\n'
                yield f'                }}\n'
            else:
                yield f'                if (buffer_index_ == {len(fmt.start_bytes) + 2}) {{\n'
                yield f'                    length_lo_ = byte;\n'
                yield f'                }} else {{\n'
                yield f'                    msg_length_ = length_lo_ | (static_cast<size_t>(byte) << 8);\n'
                yield f'                    packet_size_ = {PREFIX}_OVERHEAD + msg_length_;\n'
                yield f'                    if (packet_size_ <= buffer_max_size_) {{\n'
                yield f'                        state_ = {class_name}ParserState::GettingPayload;\n'
                yield f'                    }} else {{\n'
                reset_state = 'LookingForStart1' if len(fmt.start_bytes) > 1 else ('LookingForStart' if fmt.start_bytes else 'GettingMsgId')
                yield f'                        state_ = {class_name}ParserState::{reset_state};\n'
                yield f'                    }}\n'
                yield f'                }}\n'
            yield f'                break;\n\n'
        
        # GettingPayload state - uses shared payload validation
        yield f'            case {class_name}ParserState::GettingPayload:\n'
        yield f'                if (buffer_index_ < buffer_max_size_) {{\n'
        yield f'                    buffer_[buffer_index_++] = byte;\n'
        yield f'                }}\n\n'
        yield f'                if (buffer_index_ >= packet_size_) {{\n'
        
        if fmt.has_crc:
            crc_start = len(fmt.start_bytes)
            yield f'                    // Use shared payload validation with CRC\n'
            yield f'                    result = validate_payload_with_crc(\n'
            yield f'                        buffer_, packet_size_,\n'
            yield f'                        {PREFIX}_HEADER_SIZE, {fmt.length_bytes}, {crc_start});\n'
        else:
            yield f'                    // Use shared minimal payload validation\n'
            yield f'                    result = validate_payload_minimal(\n'
            yield f'                        buffer_, packet_size_, {PREFIX}_HEADER_SIZE);\n'
        
        reset_state = 'LookingForStart1' if len(fmt.start_bytes) > 1 else ('LookingForStart' if fmt.start_bytes else 'GettingMsgId')
        yield f'                    state_ = {class_name}ParserState::{reset_state};\n'
        yield f'                }}\n'
        yield f'                break;\n'
        
        yield f'        }}\n\n'
        yield f'        return result;\n'
        yield f'    }}\n\n'
        
        yield f'private:\n'
        yield f'    {class_name}ParserState state_;\n'
        yield f'    uint8_t* buffer_;\n'
        yield f'    size_t buffer_max_size_;\n'
        yield f'    size_t buffer_index_;\n'
        yield f'    size_t packet_size_;\n'
        yield f'    uint8_t msg_id_;\n'
        if fmt.has_length:
            yield f'    size_t msg_length_;\n'
            if fmt.length_bytes == 2:
                yield f'    uint8_t length_lo_;\n'
        yield f'    MsgLengthCallback get_msg_length_;\n'
        yield f'}};\n\n'
        
        # Static encode function - uses shared payload encoding
        yield f'/**\n'
        yield f' * Encode a message with {name} format\n'
        yield f' * Returns the number of bytes written, or 0 on failure\n'
        yield f' */\n'
        yield f'inline size_t {camel_to_snake(name)}_encode(uint8_t* buffer, size_t buffer_size,\n'
        yield f'                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {{\n'
        yield f'    size_t total_size = {PREFIX}_OVERHEAD + msg_size;\n'
        yield f'    if (buffer_size < total_size) return 0;\n\n'
        
        # Write start bytes (frame-specific)
        idx = 0
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            const_name = f'{PREFIX}_START_BYTE{i + 1}' if len(fmt.start_bytes) > 1 else f'{PREFIX}_START_BYTE'
            yield f'    buffer[{idx}] = {const_name};\n'
            idx += 1
        
        # Use shared payload encoding function
        if fmt.has_crc:
            crc_start = len(fmt.start_bytes)
            yield f'\n    // Use shared payload encoding with CRC\n'
            yield f'    encode_payload_with_crc(\n'
            yield f'        buffer + {len(fmt.start_bytes)}, msg_id, msg, msg_size,\n'
            yield f'        {fmt.length_bytes}, buffer + {crc_start});\n'
        else:
            yield f'\n    // Use shared minimal payload encoding\n'
            yield f'    encode_payload_minimal(\n'
            yield f'        buffer + {len(fmt.start_bytes)}, msg_id, msg, msg_size);\n'
        
        yield f'\n    return total_size;\n'
        yield f'}}\n\n'
        
        # Static validate_packet function - uses shared payload validation
        yield f'/**\n'
        yield f' * Validate a complete {name} packet in a buffer\n'
        yield f' */\n'
        yield f'inline FrameMsgInfo {camel_to_snake(name)}_validate_packet(const uint8_t* buffer, size_t length) {{\n'
        yield f'    if (length < {PREFIX}_OVERHEAD) return FrameMsgInfo();\n\n'
        
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            const_name = f'{PREFIX}_START_BYTE{i + 1}' if len(fmt.start_bytes) > 1 else f'{PREFIX}_START_BYTE'
            yield f'    if (buffer[{i}] != {const_name}) return FrameMsgInfo();\n'
        
        yield f'\n'
        
        # Use shared payload validation function
        if fmt.has_crc:
            crc_start = len(fmt.start_bytes)
            yield f'    // Use shared payload validation with CRC\n'
            yield f'    return validate_payload_with_crc(\n'
            yield f'        buffer, length, {PREFIX}_HEADER_SIZE, {fmt.length_bytes}, {crc_start});\n'
        else:
            yield f'    // Use shared minimal payload validation\n'
            yield f'    return validate_payload_minimal(\n'
            yield f'        buffer, length, {PREFIX}_HEADER_SIZE);\n'
        
        yield f'}}\n\n'


def generate_cpp_frame_parsers(formats):
    """Generate C++ frame parser code from frame format definitions"""
    return ''.join(FrameParserCppGen.generate_header(formats))


def generate_cpp_frame_parsers_multi(formats):
    """
    Generate multiple C++ header files for frame parsers.

    Returns a dictionary mapping filename to content:
    - frame_base.hpp: Base utilities (checksum, FrameMsgInfo, FrameFormatType)
    - {ClassName}.hpp: Individual frame format headers
    - frame_parsers.hpp: Main header that includes all frame formats
    """
    files = {}

    # Generate base file
    files['frame_base.hpp'] = ''.join(FrameParserCppGen.generate_base(formats))

    # Generate individual frame format files
    for fmt in formats:
        files[f'{fmt.name}.hpp'] = ''.join(FrameParserCppGen.generate_format_file(fmt))

    # Generate main header
    files['frame_parsers.hpp'] = ''.join(FrameParserCppGen.generate_main_header(formats))

    return files
