"""
NuExtract Platform

 NB: you can also interact with this API via the [Python SDK](https://github.com/numindai/nuextract-platform-sdk).  ## Extracting Information from Documents  Once your project is ready, you can use it to extract information from documents in real time via this RESTful API.  Each project has its own extraction endpoint:  `https://nuextract.ai/api/projects/{projectId}/extract`  You provide it a document and it returns the extracted information according to the task defined in the project. To use it, you need:  - To create an API key in the [Account section](https://nuextract.ai/app/user?content=api) - To replace `{projectId}` by the project ID found in the API tab of the project  You can test your extraction endpoint in your terminal using this command-line example with curl (make sure that you replace values of `PROJECT_ID` and `NUEXTRACT_API_KEY`):  ```bash NUEXTRACT_API_KEY=\"_your_api_key_here_\"; \\ PROJECT_ID=\"a24fd84a-44ab-4fd4-95a9-bebd46e4768b\"; \\ curl \"https://nuextract.ai/api/projects/${PROJECT_ID}/extract\" \\   -X POST \\   -H \"Authorization: Bearer ${NUEXTRACT_API_KEY}\" \\   -H \"Content-Type: application/octet-stream\" \\   --data-binary @\"${FILE_NAME}\" ```  You can also use the [Python SDK](https://github.com/numindai/nuextract-platform-sdk#documentation), by replacing the `project_id`, `api_key` and `file_path` variables in the following code:  ```python from numind import NuMind from pathlib import Path  client = NuMind(api_key=api_key) file_path = Path(\"path\", \"to\", \"document.odt\") with file_path.open(\"rb\") as file:     input_file = file.read() output_schema = client.post_api_projects_projectid_extract(project_id, input_file) ```  ## Using the Platform via API  Everything you can do on the web platform can be done via API -  check the [user guide](https://www.notion.so/User-Guide-17c16b1df8c580d3a579ebfb24ddbea7?pvs=21) to learn about how the platform works.  This can be useful to create projects automatically, or to make your production more robust for example.  ### Main resources  - **Project** - user project, identified by `projectId` - **File** - uploaded file,  identified by `fileId`, stored up to two weeks if not tied to an **Example** - **Document** - internal representation of a document, identified by `documentId`, created from a File or a text, stored up to two weeks if not tied to an Example - **Example** - document-extraction pair given to teach NuExtract, identified by `exampleId`, created from a Document  ### Most common API operations  - Creating a **Project** via `POST /api/projects` - Changing the template of a **Project** via `PATCH /api/projects/{projectId}` - Uploading a file to a **File** via `POST /api/files` (up to 2 weeks storage) - Creating a **Document** via `POST /api/documents/text` and `POST /api/files/{fileID}/convert-to-document` from a text or a **File** - Adding an **Example** to a **Project** via `POST /api/projects/{projectId}/examples` - Changing Project settings via `POST /api/projects/{projectId}/settings` - Locking a **Project** via `POST /api/projects/{projectId}/lock`  ## Testing with a temporary authorization  This documentation allows to directly test the API. You first need to select `oauth2uth` in the \"Authentication\" box, set the `Client ID` value to `user`, and click on \"Authorize\". You can then go to an API endpoint, e.g.  `POST /api/{projectID}/extract`, press “Test Request”, fill out the body (you can upload a document in this case), and press “Send” to get the output.

The version of the OpenAPI document:
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations

import json
import pprint
import re  # noqa: F401
from typing import Any, ClassVar, Dict, List, Optional, Set

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing_extensions import Self

from numind.models.project_settings_response import ProjectSettingsResponse


class ProjectResponse(BaseModel):
    """
    ProjectResponse
    """

    id: StrictStr = Field(description="Unique project identifier.")
    name: StrictStr = Field(description="Project name.")
    description: StrictStr = Field(description="A brief explanation of the project.")
    template: Dict[str, Any] = Field(
        description="Extraction template (NuExtract format)."
    )
    owner_user: StrictStr = Field(description="Project owner.", alias="ownerUser")
    owner_organization: Optional[StrictStr] = Field(
        default=None,
        description="Project owning organization (if any).",
        alias="ownerOrganization",
    )
    created_at: StrictStr = Field(
        description="Project creation date.", alias="createdAt"
    )
    updated_at: StrictStr = Field(
        description="Project last update date.", alias="updatedAt"
    )
    lock_state: StrictBool = Field(
        description="The lock state of the project.", alias="lockState"
    )
    shared: StrictBool = Field(
        description="The shared (reference) state of the project."
    )
    settings: ProjectSettingsResponse
    __properties: ClassVar[List[str]] = [
        "id",
        "name",
        "description",
        "template",
        "ownerUser",
        "ownerOrganization",
        "createdAt",
        "updatedAt",
        "lockState",
        "shared",
        "settings",
    ]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ProjectResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """
        Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of settings
        if self.settings:
            _dict["settings"] = self.settings.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ProjectResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "id": obj.get("id"),
                "name": obj.get("name"),
                "description": obj.get("description"),
                "template": obj.get("template"),
                "ownerUser": obj.get("ownerUser"),
                "ownerOrganization": obj.get("ownerOrganization"),
                "createdAt": obj.get("createdAt"),
                "updatedAt": obj.get("updatedAt"),
                "lockState": obj.get("lockState"),
                "shared": obj.get("shared"),
                "settings": ProjectSettingsResponse.from_dict(obj["settings"])
                if obj.get("settings") is not None
                else None,
            }
        )
        return _obj
