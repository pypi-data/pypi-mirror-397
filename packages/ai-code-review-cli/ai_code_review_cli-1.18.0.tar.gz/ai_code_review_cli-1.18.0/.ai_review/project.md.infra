The `infrastructure` repository is the **centralized codebase for defining, provisioning, and managing all cloud and on-premises infrastructure**. It adheres to **Infrastructure as Code (IaC) principles**, ensuring environments are automated, consistent, and version-controlled. The primary goal is to manage "everything through code," meaning that if an entire environment were to be deleted, the configuration defined in this repository would allow it to be fully recreated to a working state.

The repository is used for:
*   Automating the provisioning and management of AWS cloud resources.
*   Deploying and managing applications on OpenShift container platforms.
*   Standardizing GitLab CI/CD pipelines.
*   Automating the management of the Quay.io container image registry.
*   Managing software project dependencies through automation.

The management process relies on **Terraform** for defining cloud resource state and GitLab configurations, **Ansible** for automation and deployments on OpenShift and Quay, and **GitLab CI/CD** for orchestrating and automating these processes.

### Repository Organization and Components

The `infrastructure` repository is structured into several top-level directories, each dedicated to a specific part of the infrastructure:

*   **`aws/` and `aws-internal/`**: These directories contain **Terraform and script-based configurations for AWS environments**.
    *   **`aws/`** focuses on **public-facing AWS infrastructure** and services. This includes core Terraform configurations for modules like a **secure, read-only S3 bucket browser** (`bucket-browser/`) for viewing files without direct AWS console access. It also provisions an **auto-scaling fleet of EC2 instances for GitLab Runners** (`gitlab-docker-runner-pool/`) to execute CI/CD jobs in isolated Docker containers, and configurations for a dedicated **EC2-based artifact download server** (`download-server/`) for large release files.
    *   **`aws-internal/`** holds modules and scripts for **private and core internal AWS resources** that are not publicly exposed. This includes shared instance setup scripts for installing agents like **Qualys Cloud Agent** for vulnerability management and **Splunk Universal Forwarder** for log collection, as well as a variant of the **GitLab Docker runner pool** for internal projects needing private network access.
    *   **AWS Account Structure and Purposes**:
        *   **Production Account (e.g., ID 281...)**: This is the primary account for **production workloads**. It hosts the **OpenShift cluster (ROSA)**, and **S3 buckets for artifact storage** (e.g., "auto product build" and "gitlab CI workspaces"). IAM policies are set up with **minimum privilege access** for automation.
        *   **Staging Account (e.g., ID 203...)**: This account serves primarily as a **test account** where team members generally have **admin access** to create and tear down resources for testing without impacting production.
        *   **Cyborg Account**: Not intended for general team use, it hosts the derivus Web server, with administrative access limited to a few specific individuals.
        *   **Testing Firm Account**: An external AWS account used by a "testing firm" to run tests on product builds. Images (AMIs) are created on Red Hat's account and permissions are granted to the testing firm's AWS account to use them.
        *   **Access Management**: Access to AWS accounts is managed through **Rover groups**, which are LDAP-based and sync with AWS, determining access levels (admin, read-only, power user). The goal is to manage everything through IaC, reducing the need for direct manual access to production accounts.
        *   **Cost Management**: **Cloudability** is used for cross-cost-center spend traceability and tracking infrastructure costs. Tagging resources is essential for cost management.

*   **`openshift/`**: This directory contains **Ansible playbooks and Kubernetes/OpenShift resource manifests (.yaml files)** for deploying applications to the container platforms.
    *   **`openshift/setup-resources/`**: Defines **cluster-level resources** like namespaces, service accounts, roles, and resource quotas using raw YAML manifests. These resources often **need to be created manually** initially, as a lower-privileged service account cannot grant higher privileges.
    *   **`openshift/managed-platform+/`**: Houses **Ansible playbooks for automating deployment and lifecycle management of applications and tenants** on managed OpenShift clusters. Key application playbooks include `contcert/` for Continuous Certification, `gitlab-runners/` for deploying GitLab Runners as pods within OpenShift, `autosd-webserver/` which serves content from S3 buckets via an `s3_indexer.py` script, and `test-console/` for debugging tools.
    *   **`openshift/bos2/`**: Contains configurations specific to the Boston data center, such as the `flasher/` application.
    *   **ROSA to MP+ Migration**: There is an ongoing strategic effort to **migrate away from using ROSA on AWS** (which costs around $5,000 to $6,000 per month) to **Managed Platform Plus (MP+)**, Red Hat's internal managed OpenShift offering. The primary goals are to **lower pipeline execution costs** and leverage full support from Red Hat IT, significantly reducing direct AWS spending. Challenges include the rule that **"Application containers may not run as root"** on MP+, requiring image modifications outside the platform, latency issues when communicating with AWS S3 buckets if the MP+ tenant is in a different region, and storage requirements exceeding allocated free space.
    *   **Local Testing**: Developers use **MiniCube or OpenShift Local (CRC)** to run single-node OpenShift clusters locally for **sanity checking Ansible playbooks and Kubernetes/OpenShift resources** before submitting changes.

*   **`gitlab/`**: This directory holds **reusable modules for GitLab CI/CD pipelines** and Terraform configurations for managing GitLab resources.
    *   **`gitlab/cee/modules/`**: A collection of shared GitLab CI/CD module definitions (`.yml` files) to abstract common pipeline logic into reusable components, promoting cleaner, more maintainable configurations. Subdirectories include `template/` (boilerplate), `toolchain/` (interaction with developer toolchain), and `foa/` (application-specific modules).
    *   **Terraform for GitLab (`gitlab/cee/`)**: Terraform is used to **manage GitLab groups, projects, and their settings as code**. This defines a standardized way to set up access control, merge policies (e.g., fast forward), branch protection, and approval rules across GitLab projects. The configuration is stored in Terraform plans, and a **remote state file (on S3)** tracks the actual state of resources on the GitLab API, ensuring **consistency, visibility, and trackability of changes**.

*   **`quay/`**: This directory contains **Ansible automation for managing the Quay.io container registry**. Quay serves as the central repository for storing, distributing, and scanning Docker and OCI-compliant container images built by CI/CD pipelines. The `quay/auto-fusa/` Ansible playbook automates tasks such as creating new repositories, setting visibility, configuring robot accounts with specific permissions, and setting up automated security vulnerability scanning.

*   **`renovate/`**: This directory holds **configuration for the Renovate bot**. Renovate is a **critical tool for automated dependency management**, scanning source code repositories to detect outdated dependencies (e.g., npm packages, Maven artifacts, Docker base images) and proactively creating pull/merge requests to update them, thus helping to stay on top of security vulnerabilities and benefit from latest features. The primary configuration is defined in `renovate.json` at the repository root.

### Useful Information for Code Review

*   **IaC Principles and Workflow**: All infrastructure changes should originate from this repository through **version-controlled code**. Review proposed changes in **merge requests**, where GitLab CI generates a Terraform plan report or Ansible dry-run output to show the exact modifications (additions, deletions, updates) to the infrastructure before they are applied.
*   **Terraform State Management**: Terraform utilizes a **remote state file (e.g., in an S3 bucket)** to maintain a single source of truth for the infrastructure's current configuration. Understanding the `terraform plan` output is crucial for reviewing changes, as it compares the desired state in the plans with the actual state tracked remotely.
*   **Secrets Management**: For **automation access**, **Vault.corp.redhat.com** is the Red Hat Project-approved, SOA-approved solution. While GitLab CI/CD secret variables are currently used, they are not SOA-approved and will eventually migrate to Vault. **Bitwarden** is used for **human user access** secrets, such as bot account passwords shared among developers. IAM roles are used to grant **minimum privilege access** to AWS resources for pipelines, scoping permissions only to necessary actions.
*   **Credential Leak Mitigation**: The infrastructure repository is kept **downstream (internal)** to mitigate the impact of credential leaks, making them easier to manage from an Infosec perspective compared to upstream (public) leaks.
*   **Local Testing**: Developers are encouraged to use **OpenShift Local (CRC) or MiniKube** to run a single-node OpenShift cluster locally. This allows for **sanity checking Ansible playbooks and Kubernetes/OpenShift resources**, or testing changes to runner configurations, before submitting merge requests to the main repository.
*   **Modularity and Naming Conventions**: Terraform code is highly modular for reusability. Resource types are prefaced with an underscore (e.g., `Group_archaX`) to clearly indicate the resource being managed, which aids readability.
*   **File Structure and Purpose**: Familiarize yourself with the top-level directories (`aws/`, `openshift/`, `gitlab/`, `quay/`, `renovate/`) and their subdirectories to quickly locate relevant code and understand its context. Core files like `renovate.json`, `md_style.rb`, and `requirements.txt` also provide important context.
