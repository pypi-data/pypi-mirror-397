import importlib.metadata
import pathlib
import sys

import art
import cyclopts
import fspathtree
import rich.console
from typing_extensions import Annotated, List

from compudoc import document
from compudoc.examples import Examples
from compudoc.execution_engines import *
from compudoc.parsing import parse_code_split_file
from compudoc.template_engines import *

__version__ = importlib.metadata.version("compudoc")

app = cyclopts.App(
    name="compudoc",
    version=__version__,
)


known_filetypes = {
    "latex": {
        "file extensions": [".tex"],
        "comment line pattern": "%{{CODE}}",
    },
    "markdown": {
        "file extensions": [".md", ".markdown"],
        "comment line pattern": "<!--{{CODE}-->",
    },
    "gnuplot": {
        "file extensions": [".gp", ".gnuplot"],
        "comment line pattern": "#{{CODE}}",
    },
    "typst": {
        "file extensions": [".typ"],
        "comment line pattern": "//{{CODE}}",
    },
}


def detect_filetype(filename):
    filepath = pathlib.Path(filename)
    if filepath.suffix in [".mgd", ".merged"]:
        filepath = pathlib.Path(filepath.stem)

    if filepath.suffix in [".cd", ".compudoc"]:
        filepath = pathlib.Path(filepath.stem)

    for ft in known_filetypes:
        if filepath.suffix in known_filetypes[ft]["file extensions"]:
            return ft

    return None


@app.default
def main(
    input_file: pathlib.Path,
    output_file: pathlib.Path = None,
    /,
    filetype: str = None,
    strip_comment_blocks: bool = False,
    comment_line_pattern: str = None,
    comment_line_str: str = None,
    python: str = sys.executable,
    quiet: bool = False,
):
    """
    Compudoc lets you write python code in you documents to perform calculations and insert the results.
    It is very handy for creating technical write-ups that need to record/report the result of some numerical calculations.

    Parameters
    ----------

    output-file
        Output filename template. The output filename will be generated by
        rendering this template. Use --show-output-filename-render-context to see a
        list of variables available in the template.
    filetype
        Set input filetype.
    strip_comment_blocks
        Remove comment blocks from document when rendering.
    comment_line_pattern
        Specify the pattern used to identify comment lines and extract code.

        Examples:

        '%{{CODE}}' - match lines starting with a % (LaTeX comments) and take all text until the end of the line as code

        '% {{CODE}}' - match lines starting with a '% '. Lines that do not contain a space after '%' will not match.

        '<!---{{CODE}}--->' - match code in HTML comments
    comment_line_str
        Specify the string that comment lines will begin with. This just creates a comment line pattern with the given string at the front.
    python
        Specify interpreter to use for evaluating code blocks.
    quiet
        Don't print status info while rendering.
    """

    console = rich.console.Console(stderr=False, quiet=quiet)
    econsole = rich.console.Console(stderr=True)
    if output_file is None:
        base = input_file
        if base.suffix in [".mgd", ".merged"]:
            base = pathlib.Path(base.stem)

        if base.suffix in [".cd", ".compudoc"]:
            output_file = pathlib.Path(base.stem)
        else:
            output_file = pathlib.Path(input_file.stem + "-rendered" + base.suffix)

    font = "poinson"
    banner = art.text2art(f"CompuDoc", font=font)
    console.print(banner)
    console.print(f"version: {__version__}\n\n")

    if filetype is None:
        filetype = detect_filetype(input_file)

    # we need a comment line pattern.
    # if it is given, great...
    if comment_line_pattern is not None:
        pass
    else:
        # if its not given, but the comment line string is given, great...
        if comment_line_str is not None:
            comment_line_pattern = comment_line_str + "{{CODE}}"
        else:
            # if it is not, we need to look it up.
            if filetype is not None:
                comment_line_pattern = known_filetypes[filetype]["comment line pattern"]
            else:
                econsole.print(f"Could not determine filetype for {input_file}")
                return 1

    console.print(f"Detected filetype: {filetype}")
    console.print(rich.markup.escape(f"Comment line pattern: {comment_line_pattern}"))

    console.print(f"Rendering document {input_file} -> {output_file}")
    input_text = input_file.read_text()

    doc = document.Document(
        comment_line_pattern=comment_line_pattern,
        template_engine=Jinja2(),
        execution_engine=Python(python),
    )
    try:
        doc.parse(input_text)
    except RuntimeError as e:
        econsole.print("There was a problem parsing document.")
        return 2

    try:
        output_text = doc.render(strip_comment_blocks=strip_comment_blocks, quiet=quiet)
    except RuntimeError as e:
        econsole.print("There was a problem rendering document.")
        return 2

    output_file.write_text(output_text)


@app.command
def example(filetype: str = "latex", /):
    """
    Print examples for varous filetypes.

    Parameters
    ==========

    filetype
        The example filtype. Currently supported example filetypes:
            - latex
            - markdown
            - gnuplot
            - typst
    """

    console = rich.console.Console()
    econsole = rich.console.Console(stderr=True)

    for ft in known_filetypes:
        identifiers = [ft] + list(
            map(lambda e: e[1:], known_filetypes[ft]["file extensions"])
        )
        if filetype.lower() in identifiers:
            fn = getattr(Examples, ft)
            print(fn())
            print("HUH")
            return 0

    econsole.print(f"[red]ERROR: Unrecognized file type '{filetype}'.[/red]")


@app.command
def split(
    input_file: pathlib.Path,
    /,
    filetype: str = None,
    text_suffix: str = ".text",
    code_suffix: str = ".code",
    strip: bool = False,
    comment_line_pattern: str = None,
    comment_line_str: str = None,
    quiet: bool = False,
    overwrite: bool = False,
):
    """
    Split a compudoc into its text and code. This creates two files, one with the document text and one with the document code.
    This is useful for testing/debuggging code blocks.

    Parameters
    ----------

    filetype
        Specify input filetype.
    text_suffix
        Suffix to append to input filename for generating output file name containting document text.
    code_suffix
        Suffix to append to input filename for generating output file name containting document code.
    strip
        Remove _all_ compudoc markdup. By default, only comment code blocks are striped. This will
    comment_line_pattern
        Specify the pattern used to identify comment lines and extract code.
        also remove template markup.
    comment_line_str
        Specify the string that comment lines will begin with.
    overwrite
        Overwrite output files if they exists.
    quiet
        Don't print status info while rendering.
    """
    console = rich.console.Console(stderr=True, quiet=quiet)
    econsole = rich.console.Console(stderr=True)

    font = "poinson"
    banner = art.text2art(f"CompuDoc", font=font)
    console.print(banner)
    console.print(f"version: {__version__}\n\n")

    if filetype is None:
        filetype = detect_filetype(input_file)

    # we need a comment line pattern.
    # if it is given, great...
    if comment_line_pattern is not None:
        pass
    else:
        # if its not given, but the comment line string is given, great...
        if comment_line_str is not None:
            comment_line_pattern = comment_line_str + "{{CODE}}"
        else:
            # if it is not, we need to look it up.
            if filetype is not None:
                comment_line_pattern = known_filetypes[filetype]["comment line pattern"]
            else:
                econsole.print(
                    f"Could not determine filetype for {input_file} and no comment line pattern was given."
                )
                return 1

    text_output = pathlib.Path(str(input_file) + text_suffix)
    code_output = pathlib.Path(str(input_file) + code_suffix)

    console.print(f"Detected filetype: {filetype}")
    console.print(rich.markup.escape(f"Comment pattern: {comment_line_pattern}"))
    console.print(
        f"Splitting '{input_file}' into text: '{text_output}' and code: '{code_output}'."
    )

    if not overwrite:
        output_exists = False
        for file in [text_output, code_output]:
            if file.exists():
                econsole.print(
                    f"[red]Error: {file} already exists. Give --overwrite to overwrite.[/red]"
                )
                output_exists = True
        if output_exists:
            econsole.print(
                f"[red]One or more output files exists and --overwrite was not given. Exiting.[/red]"
            )
            return 2

    input_text = input_file.read_text()
    doc = document.Document(comment_line_pattern=comment_line_pattern)
    doc.parse(input_text)

    with text_output.open("w") as f:
        for i, block in doc.enumerate_blocks():
            if block.is_code_block():
                f.write(f"COMMENTED-CODE-BLOCK-{i}\n")
                continue
            if strip:
                text = doc.template_engine.strip_text(block.text)
            else:
                text = block.text
            f.write(text)

    with code_output.open("w") as f:
        f.write(doc.execution_engine.get_line_comment_str())
        f.write("SETUP\n")
        f.write(doc.template_engine.get_setup_code())
        for i, block in doc.enumerate_code_blocks():
            f.write(doc.execution_engine.get_line_comment_str())
            f.write("COMMENTED-CODE-BLOCK-")
            f.write(f"{i}")
            f.write("\n")
            f.write(doc.comment_block.extract_code(block.text))

    return 0


@app.command
def merge(
    input_file: pathlib.Path,
    /,
    filetype: str = None,
    text_suffix: str = ".text",
    code_suffix: str = ".code",
    merged_suffix: str = ".merged",
    comment_line_pattern: str = None,
    comment_line_str: str = None,
    code_indent: int = 1,
    quiet: bool = False,
    overwrite: bool = False,
):
    """
    Merge text and code into a compudoc.

    This command works on text and code files that were previously generated with the `split` comment.
    The INPUT_FILE argument should be the compudoc that was _originally_ split. The INPUT_FIlE will
    not be overwritten, a new .merged file is created instead.
    created

    > compudoc split main.tex.cd
    > ls
    main.tex.cd
    main.tex.cd.code
    main.tex.cd.text
    > compudoc merge main.tex.cd
    > ls
    main.tex.cd
    main.tex.cd.code
    main.tex.cd.text
    main.tex.cd.merged <<<< new merged file

    Parameters
    ----------

    filetype
        Specify input filetype.
    text_suffix
        Suffix to append to input filename for generating name for file containing document text.
    code_suffix
        Suffix to append to input filename for generating name for file containing document code.
    code_suffix
        Suffix to append to input filename for generating output filename for merged document.
    comment_line_pattern
        Specify the pattern used to identify comment lines and extract code.
        also remove template markup.
    comment_line_str
        Specify the string that comment lines will begin with.
    code_indent
        Number of spaces to indent code blocks.
    overwrite
        Overwrite output files if they exists.
    quiet
        Don't print status info while rendering.
    """
    console = rich.console.Console(stderr=True, quiet=quiet)
    econsole = rich.console.Console(stderr=True)

    font = "poinson"
    banner = art.text2art(f"CompuDoc", font=font)
    console.print(banner)
    console.print(f"version: {__version__}\n\n")

    if filetype is None:
        filetype = detect_filetype(input_file)

    # we need a comment line pattern.
    # if it is given, great...
    if comment_line_pattern is not None:
        pass
    else:
        # if its not given, but the comment line string is given, great...
        if comment_line_str is not None:
            comment_line_pattern = comment_line_str + "{{CODE}}"
        else:
            # if it is not, we need to look it up.
            if filetype is not None:
                comment_line_pattern = known_filetypes[filetype]["comment line pattern"]
            else:
                econsole.print(
                    f"Could not determine filetype for {input_file} and no comment line pattern was given."
                )
                return 1

    text_file = pathlib.Path(str(input_file) + text_suffix)
    code_file = pathlib.Path(str(input_file) + code_suffix)
    merged_file = pathlib.Path(str(input_file) + merged_suffix)

    console.print(f"Detected filetype: {filetype}")
    console.print(rich.markup.escape(f"Comment pattern: {comment_line_pattern}"))
    console.print(
        f"Merging '{text_file}' (text file) and '{code_file}' (code file) into '{merged_file}'."
    )

    if not overwrite:
        output_exists = False
        for file in [merged_file]:
            if file.exists():
                econsole.print(
                    f"[red]Error: {file} already exists. Give --overwrite to overwrite.[/red]"
                )
                output_exists = True
        if output_exists:
            econsole.print(
                f"[red]One or more output files exists and --overwrite was not given. Exiting.[/red]"
            )
            return 2

    doc = document.Document(comment_line_pattern=comment_line_pattern)

    block_map = parse_code_split_file(code_file)
    for k in block_map:
        block_map[k] = doc.comment_block.comment_code(
            block_map[k], prefix=" " * code_indent
        )
    merged_text = document.render_merged_document(text_file.read_text(), block_map)

    merged_file.write_text(merged_text)

    return 0
