// Orchestral Web UI - WebSocket Client

class OrchestralUI {
    constructor() {
        this.isProcessing = false;
        this.userHasScrolled = false;
        this.currentConversationId = null;
        this.conversations = [];
        this.activeDropdown = null;
        this.renameConversationId = null;
        this.isInterrupted = false;  // Track if current message was interrupted

        // Model name mappings: technical name -> friendly display name
        this.modelDisplayNames = {
            // OpenAI models
            'gpt-4o-mini': 'GPT-4o-mini',
            'gpt-4o-mini-2024-07-18': 'GPT-4o-mini',
            'gpt-4o': 'GPT-4o',
            'gpt-4o-2024-08-06': 'GPT-4o',
            'gpt-4.1-mini': 'GPT-4.1-mini',
            'gpt-4.1-mini-2025-04-14': 'GPT-4.1-mini',
            'gpt-4.1': 'GPT-4.1',
            'gpt-4.1-2025-04-14': 'GPT-4.1',
            'gpt-5-mini': 'GPT-5-mini',
            'gpt-5': 'GPT-5',

            // Anthropic models
            'claude-3-5-haiku-latest': 'Claude Haiku 3.5',
            'claude-3-5-haiku-20241022': 'Claude Haiku 3.5',
            'claude-3-haiku-20240307': 'Claude Haiku 3.0',
            'claude-sonnet-4-0': 'Claude Sonnet 4',
            'claude-sonnet-4-20250514': 'Claude Sonnet 4',
            'claude-3-7-sonnet-20250219': 'Claude Sonnet 3.7',
            'claude-opus-4-0': 'Claude Opus 4',
            'claude-opus-4-20250514': 'Claude Opus 4',
            'claude-opus-4-1': 'Claude Opus 4.1',

            // Google models
            'gemini-2.0-flash-exp': 'Gemini 2.0 Flash',
            'gemini-1.5-pro': 'Gemini 1.5 Pro',
            'gemini-1.5-flash': 'Gemini 1.5 Flash',
            'gemini-1.5-flash-8b': 'Gemini 1.5 Flash-8B',
            'gemini-1.0-pro': 'Gemini 1.0 Pro',

            // Groq models
            'llama-3.3-70b-versatile': 'Llama 3.3 70B',
            'llama-3.1-8b-instant': 'Llama 3.1 8B',
            'meta-llama/llama-4-scout-17b-16e-instruct': 'Llama 4 Scout 17B',
            'meta-llama/llama-4-maverick-17b-128e-instruct': 'Llama 4 Maverick 17B',
            'openai/gpt-oss-20b': 'GPT-OSS 20B',
            'openai/gpt-oss-120b': 'GPT-OSS 120B',
            'qwen/qwen3-32b': 'Qwen 3 32B'
        };

        // DOM elements
        this.chatContainer = document.getElementById('chat-container');
        this.userInput = document.getElementById('user-input');
        this.sendBtn = document.getElementById('send-btn');
        this.undoBtn = document.getElementById('undo-btn');
        this.costBtn = document.getElementById('cost-btn');
        this.status = document.getElementById('status');
        this.statusText = this.status.querySelector('.status-text');
        this.sidebar = document.getElementById('sidebar');
        this.toggleSidebarBtn = document.getElementById('toggle-sidebar-btn');
        this.newConversationBtn = document.getElementById('new-conversation-btn');
        this.conversationsList = document.getElementById('conversations-list');
        this.settingsSidebar = document.getElementById('settings-sidebar');
        this.toggleSettingsBtn = document.getElementById('toggle-settings-btn');
        this.renameModal = document.getElementById('rename-modal');
        this.renameInput = document.getElementById('rename-input');
        this.renameCancelBtn = document.getElementById('rename-cancel-btn');
        this.renameConfirmBtn = document.getElementById('rename-confirm-btn');
        this.workspaceModal = document.getElementById('workspace-modal');
        this.workspaceInput = document.getElementById('workspace-input');
        this.workspaceDisplay = document.getElementById('workspace-display');
        this.editWorkspaceBtn = document.getElementById('edit-workspace-btn');
        this.workspaceCancelBtn = document.getElementById('workspace-cancel-btn');
        this.workspaceConfirmBtn = document.getElementById('workspace-confirm-btn');
        this.systemPromptModal = document.getElementById('system-prompt-modal');
        this.systemPromptInput = document.getElementById('system-prompt-input');
        this.editSystemPromptBtn = document.getElementById('edit-system-prompt-btn');
        this.systemPromptCancelBtn = document.getElementById('system-prompt-cancel-btn');
        this.systemPromptConfirmBtn = document.getElementById('system-prompt-confirm-btn');
        this.modelBtn = document.getElementById('model-btn');
        this.modelDisplay = document.getElementById('model-display');
        this.modelDropdown = document.getElementById('model-dropdown');
        this.toggleModelNamesBtn = document.getElementById('toggle-model-names-btn');
        this.toggleModelNamesCheckbox = document.getElementById('toggle-model-names-checkbox');
        this.showModelNames = false;
        this.streamToggle = document.getElementById('stream-toggle');
        this.streamEnabled = true; // Default to streaming enabled
        this.systemPromptToggle = document.getElementById('system-prompt-toggle');
        this.showSystemPrompt = false; // Default to hiding system prompt
        this.currentBaseDirectory = null;
        this.refreshSettingsBtn = document.getElementById('refresh-settings-btn');
        this.clearSettingsBtn = document.getElementById('clear-settings-btn');
        // resetStreamingBtn removed - auto-reset on model change handles this

        // Initialize feature modules
        this.latexRenderer = new window.LatexRenderer();
        this.wsManager = new window.WebSocketManager();

        // Initialize modular panel actions system
        this.panelActions = new window.PanelActionsManager(this);

        // Define which actions to apply to which panel types
        this.panelActionRules = [
            // System prompts: copy + edit
            { panelType: 'system-prompt', actions: ['copy', 'edit-system-prompt'] },

            // User messages: copy
            { panelType: 'user-message', actions: ['copy'] },

            // Agent messages: copy (+ regenerate in future)
            { panelType: 'agent-message', actions: ['copy'] },

            // Code blocks: copy code only
            { panelType: 'code-block', actions: ['copy-code'] },

            // Any panel: copy (fallback)
            { panelType: 'any-panel', actions: ['copy'] },
        ];

        this.init();
    }

    init() {
        // Set up WebSocket connection and handlers
        this.setupWebSocket();

        // Set up event listeners
        this.userInput.addEventListener('keydown', (e) => this.handleKeydown(e));
        this.sendBtn.addEventListener('click', () => this.sendMessage());
        this.undoBtn.addEventListener('click', () => this.undoLastMessage());
        this.costBtn.addEventListener('click', () => this.showCost());
        this.toggleSidebarBtn.addEventListener('click', () => this.toggleSidebar());
        this.toggleSettingsBtn.addEventListener('click', () => this.toggleSettings());
        this.newConversationBtn.addEventListener('click', () => this.newConversation());
        this.renameCancelBtn.addEventListener('click', () => this.closeRenameModal());
        this.renameConfirmBtn.addEventListener('click', () => this.confirmRename());
        this.editWorkspaceBtn.addEventListener('click', () => this.showWorkspaceModal());
        this.workspaceDisplay.addEventListener('click', () => this.showWorkspaceModal());
        this.workspaceCancelBtn.addEventListener('click', () => this.closeWorkspaceModal());
        this.workspaceConfirmBtn.addEventListener('click', () => this.confirmWorkspace());
        this.editSystemPromptBtn.addEventListener('click', () => this.showSystemPromptModal());
        this.systemPromptCancelBtn.addEventListener('click', () => this.closeSystemPromptModal());
        this.systemPromptConfirmBtn.addEventListener('click', () => this.confirmSystemPrompt());

        // Close rename modal on Escape
        this.renameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.confirmRename();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                this.closeRenameModal();
            }
        });

        // Workspace modal keyboard handlers
        this.workspaceInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.confirmWorkspace();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                this.closeWorkspaceModal();
            }
        });

        // System prompt modal keyboard handlers
        this.systemPromptInput.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                e.preventDefault();
                this.closeSystemPromptModal();
            }
            // Ctrl/Cmd + Enter to save
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                this.confirmSystemPrompt();
            }
        });

        // Settings controls
        this.toggleModelNamesCheckbox.addEventListener('change', () => this.toggleModelNames());
        this.streamToggle.addEventListener('change', () => this.toggleStreaming());
        this.systemPromptToggle.addEventListener('change', () => this.toggleSystemPrompt());
        this.refreshSettingsBtn.addEventListener('click', () => this.refreshConnection());
        this.clearSettingsBtn.addEventListener('click', () => this.clearConversation());
        // resetStreamingBtn event listener removed - auto-reset on model change handles this

        // Model selector
        this.modelBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleModelDropdown();
        });

        // Model selection
        document.querySelectorAll('.model-item').forEach(item => {
            item.addEventListener('click', () => {
                const provider = item.dataset.provider;
                const model = item.dataset.model;
                const displayName = item.textContent;
                this.selectModel(provider, model, displayName);
            });
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (this.activeDropdown && !e.target.closest('.conversation-actions')) {
                this.closeDropdown();
            }
            if (!this.modelDropdown.classList.contains('hidden') && !e.target.closest('.model-selector-container')) {
                this.modelDropdown.classList.add('hidden');
            }
        });

        // Track user scroll behavior
        this.chatContainer.addEventListener('scroll', () => {
            const threshold = 100; // pixels from bottom
            const atBottom = this.chatContainer.scrollHeight - this.chatContainer.scrollTop - this.chatContainer.clientHeight < threshold;
            this.userHasScrolled = !atBottom;
        });

        // Global Esc key listener for interrupts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.isProcessing) {
                e.preventDefault();
                this.sendInterrupt();
            }
        });

        // Focus input on load
        this.userInput.focus();
    }

    setupWebSocket() {
        // Set up connection state callbacks
        this.wsManager.onConnect = () => {
            this.updateStatus('connected', 'Connected');
            // Request conversation history and list
            this.requestHistory();
            this.requestConversationsList();
            // Request available Ollama models
            this.requestOllamaModels();
        };

        this.wsManager.onDisconnect = () => {
            this.updateStatus('error', 'Disconnected');
            this.isProcessing = false;
            this.updateInputState();
        };

        this.wsManager.onError = () => {
            this.updateStatus('error', 'Connection error');
        };

        // Set up message routing
        this.wsManager.onMessage = (data) => {
            this.handleMessage(data);
        };

        // Update status and connect
        this.updateStatus('connecting', 'Connecting...');
        this.wsManager.connect();
    }

    handleKeydown(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            // Enter without Shift: send message
            e.preventDefault();
            this.sendMessage();
        } else if (e.key === 'Escape') {
            // Esc: interrupt
            e.preventDefault();
            this.sendInterrupt();
        }
        // Shift+Enter: natural newline (browser default)
    }

    sendMessage() {
        const message = this.userInput.value.trim();

        if (!message || !this.wsManager.getConnectionStatus() || this.isProcessing) {
            return;
        }

        // Send to server
        this.wsManager.send('chat', { message });

        // Clear input
        this.userInput.value = '';

        // Update state
        this.isProcessing = true;
        this.isInterrupted = false;  // Reset interrupt flag for new message
        this.userHasScrolled = false; // Reset scroll tracking on new message
        this.updateInputState();
    }

    sendInterrupt() {
        console.log('[DEBUG] sendInterrupt called, isConnected:', this.wsManager.getConnectionStatus(), 'isProcessing:', this.isProcessing);

        if (!this.wsManager.getConnectionStatus() || !this.isProcessing) {
            console.log('[DEBUG] Interrupt blocked - not connected or not processing');
            return;
        }

        // Set interrupt flag BEFORE sending to prevent race conditions
        this.isInterrupted = true;

        // Send interrupt signal
        console.log('[DEBUG] Sending interrupt message');
        this.wsManager.send('interrupt');

        this.showStatus('Interrupting...', 'interrupted');
    }

    clearConversation() {
        if (!this.wsManager.getConnectionStatus() || this.isProcessing) {
            return;
        }

        if (confirm('Clear conversation history?')) {
            this.wsManager.send('clear');

            // Clear chat display
            this.chatContainer.innerHTML = '';
        }
    }

    refreshConnection() {
        // Clear display and request history from server
        this.chatContainer.innerHTML = '';
        if (this.wsManager.getConnectionStatus()) {
            this.requestHistory();
        }
    }

    requestHistory() {
        if (!this.wsManager.getConnectionStatus()) {
            return;
        }
        // Request conversation history from server
        this.wsManager.send('get_history');
    }

    handleMessage(data) {
        switch (data.type) {
            case 'user_message':
                this.appendMessage(data.content, true);  // Mark as user message
                break;

            case 'agent_update':
            case 'stream_chunk':
                // Ignore updates if we've interrupted - prevents duplicate panels
                if (this.isInterrupted) {
                    console.log('[DEBUG] Ignoring agent update after interrupt');
                    break;
                }
                // Clean up any streaming tool containers before updating with final Rich HTML
                this.cleanupStreamingToolContainers();
                this.updateOrAppendAgentMessage(data.content);
                break;

            case 'interrupted':
                this.showStatus(data.message || 'Interrupted by user', 'interrupted');
                break;

            case 'complete':
                this.isProcessing = false;
                this.updateInputState();
                this.userInput.focus();
                // Refresh conversations list after completion (to update timestamps)
                this.requestConversationsList();
                break;

            case 'error':
                this.showStatus(data.message || 'Error occurred', 'error');
                this.isProcessing = false;
                this.updateInputState();
                break;

            case 'warning':
                this.showStatus(data.message, 'warning');
                break;

            case 'info':
                this.showStatus(data.message, 'info');
                break;

            case 'conversations_list':
                this.updateConversationsList(data.conversations);
                break;

            case 'cost_info':
                console.log('[DEBUG] Cost info received:', data.cost);
                const costStr = typeof data.cost === 'number' ? data.cost.toFixed(4) : '0.0000';
                this.showStatus(`Current conversation cost: $${costStr}`, 'info');
                break;

            case 'model_changed':
                // Backend changed the model (e.g., when loading a conversation)
                this.updateModelDisplay(data.provider, data.model);
                break;

            case 'base_directory_info':
                // Backend sends base directory (e.g., on connection or load)
                this.setBaseDirectory(data.base_directory);
                break;

            case 'system_prompt_info':
                // Backend sends system prompt (when requested)
                this.receiveSystemPrompt(data.system_prompt);
                break;

            case 'ollama_models':
                // Backend sends available Ollama models
                this.handleOllamaModels(data.models);
                this.updateToolOutput(data);
                break;
        }

        // Auto-scroll to bottom only if user hasn't manually scrolled up
        if (!this.userHasScrolled) {
            this.scrollToBottom();
        }
    }

    appendMessage(htmlContent, isUser = false) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message rich-content';
        if (isUser) {
            messageDiv.dataset.isUser = 'true';
        }

        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        contentDiv.innerHTML = htmlContent;

        messageDiv.appendChild(contentDiv);
        this.chatContainer.appendChild(messageDiv);

        // Render LaTeX in the new content
        this.latexRenderer.render(contentDiv);

        // Apply panel actions (modular system handles all copy buttons)
        this.panelActions.applyActions(contentDiv, this.panelActionRules);
    }

    updateOrAppendAgentMessage(htmlContent) {
        // Check if last message is an agent message (for streaming updates)
        const lastMessage = this.chatContainer.lastElementChild;

        // Only update if it's a message div AND not preceded by a status message
        // (which would indicate it's an existing agent message we're streaming to)
        if (lastMessage && lastMessage.classList.contains('message') &&
            !lastMessage.dataset.isUser) {
            // Update existing agent message content
            const contentDiv = lastMessage.querySelector('.message-content');
            if (contentDiv) {
                contentDiv.innerHTML = htmlContent;
                // Render LaTeX in the updated content
                this.latexRenderer.render(contentDiv);

                // Apply panel actions (modular system handles all copy buttons)
                this.panelActions.applyActions(contentDiv, this.panelActionRules);
                return;
            }
        }

        // Otherwise, append new message and mark it as agent message
        // All messages use Rich HTML now
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message rich-content';
        messageDiv.dataset.isAgent = 'true';

        const contentDiv = document.createElement('div');
        contentDiv.className = 'message-content';
        contentDiv.innerHTML = htmlContent;

        messageDiv.appendChild(contentDiv);
        this.chatContainer.appendChild(messageDiv);

        // Render LaTeX in the new content
        this.latexRenderer.render(contentDiv);

        // Apply panel actions (new modular system)
        this.panelActions.applyActions(contentDiv, this.panelActionRules);

        // Legacy managers are now disabled - panel actions handles everything
    }

    showStatus(message, type = 'info') {
        const statusDiv = document.createElement('div');
        statusDiv.className = `status-message ${type}`;
        statusDiv.textContent = message;
        this.chatContainer.appendChild(statusDiv);

        // Auto-remove after 5 seconds
        setTimeout(() => {
            statusDiv.style.opacity = '0';
            statusDiv.style.transition = 'opacity 0.3s';
            setTimeout(() => statusDiv.remove(), 300);
        }, 5000);
    }

    updateStatus(state, text) {
        this.status.className = `status ${state}`;
        this.statusText.textContent = text;
    }

    updateInputState() {
        const isDisabled = !this.wsManager.getConnectionStatus() || this.isProcessing;

        this.userInput.disabled = isDisabled;
        this.sendBtn.disabled = isDisabled;
        this.undoBtn.disabled = isDisabled || this.isProcessing;
        this.costBtn.disabled = isDisabled;

        // Update settings sidebar buttons if they exist
        if (this.refreshSettingsBtn) {
            this.refreshSettingsBtn.disabled = this.isProcessing;
        }
        if (this.clearSettingsBtn) {
            this.clearSettingsBtn.disabled = isDisabled || this.isProcessing;
        }

        // Update placeholder
        if (this.isProcessing) {
            this.userInput.placeholder = 'Agent is responding... (Press Esc to interrupt)';
        } else if (!this.wsManager.getConnectionStatus()) {
            this.userInput.placeholder = 'Disconnected...';
        } else {
            this.userInput.placeholder = 'Type your message... (Enter to send, Shift+Enter for new line, Esc to interrupt)';
        }
    }

    scrollToBottom() {
        this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
    }

    // Undo functionality
    undoLastMessage() {
        if (!this.wsManager.getConnectionStatus() || this.isProcessing) {
            return;
        }

        this.wsManager.send('undo');

        // Refresh to show updated history
        this.refreshConnection();
    }

    // Sidebar functionality
    toggleSidebar() {
        this.sidebar.classList.toggle('hidden');
    }

    toggleSettings() {
        this.settingsSidebar.classList.toggle('hidden');
        // Push main content when settings open
        const mainContent = document.querySelector('.main-content');
        if (!this.settingsSidebar.classList.contains('hidden')) {
            mainContent.classList.add('settings-open');
        } else {
            mainContent.classList.remove('settings-open');
        }
    }

    newConversation() {
        if (!this.wsManager.getConnectionStatus() || this.isProcessing) {
            return;
        }

        // Clear without confirmation
        this.wsManager.send('clear');

        // Clear chat display and reset conversation ID
        this.chatContainer.innerHTML = '';
        this.currentConversationId = null;
    }

    requestConversationsList() {
        if (!this.wsManager.getConnectionStatus()) {
            return;
        }

        this.wsManager.send('list_conversations');
    }

    updateConversationsList(conversations) {
        this.conversations = conversations;
        this.conversationsList.innerHTML = '';

        if (conversations.length === 0) {
            const emptyDiv = document.createElement('div');
            emptyDiv.className = 'conversation-item';
            emptyDiv.style.textAlign = 'center';
            emptyDiv.style.color = '#888';
            emptyDiv.textContent = 'No conversations yet';
            this.conversationsList.appendChild(emptyDiv);
            return;
        }

        conversations.forEach(conv => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'conversation-item';
            if (conv.id === this.currentConversationId) {
                itemDiv.classList.add('active');
            }

            // Conversation info (clickable)
            const infoDiv = document.createElement('div');
            infoDiv.className = 'conversation-info';
            infoDiv.addEventListener('click', () => this.loadConversation(conv.id));

            const nameDiv = document.createElement('div');
            nameDiv.className = 'conversation-name';
            nameDiv.textContent = conv.name || 'Untitled';

            const timeDiv = document.createElement('div');
            timeDiv.className = 'conversation-time';
            timeDiv.textContent = conv.relative_time || '';

            infoDiv.appendChild(nameDiv);
            infoDiv.appendChild(timeDiv);

            // Actions menu (ellipsis button)
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'conversation-actions';

            const menuBtn = document.createElement('button');
            menuBtn.className = 'conversation-menu-btn';
            menuBtn.textContent = '⋯';
            menuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.toggleDropdown(conv.id, actionsDiv);
            });

            // Dropdown menu
            const dropdownDiv = document.createElement('div');
            dropdownDiv.className = 'conversation-dropdown hidden';
            dropdownDiv.dataset.conversationId = conv.id;

            const renameItem = document.createElement('div');
            renameItem.className = 'conversation-dropdown-item';
            renameItem.textContent = 'Rename';
            renameItem.addEventListener('click', (e) => {
                e.stopPropagation();
                this.showRenameModal(conv.id, conv.name);
            });

            const duplicateItem = document.createElement('div');
            duplicateItem.className = 'conversation-dropdown-item';
            duplicateItem.textContent = 'Duplicate';
            duplicateItem.addEventListener('click', (e) => {
                e.stopPropagation();
                this.duplicateConversation(conv.id);
            });

            const deleteItem = document.createElement('div');
            deleteItem.className = 'conversation-dropdown-item danger';
            deleteItem.textContent = 'Delete';
            deleteItem.addEventListener('click', (e) => {
                e.stopPropagation();
                this.deleteConversation(conv.id);
            });

            dropdownDiv.appendChild(renameItem);
            dropdownDiv.appendChild(duplicateItem);
            dropdownDiv.appendChild(deleteItem);

            actionsDiv.appendChild(menuBtn);
            actionsDiv.appendChild(dropdownDiv);

            itemDiv.appendChild(infoDiv);
            itemDiv.appendChild(actionsDiv);

            this.conversationsList.appendChild(itemDiv);
        });
    }

    loadConversation(conversationId) {
        if (!this.wsManager.getConnectionStatus() || this.isProcessing) {
            return;
        }

        this.wsManager.send('load_conversation', { conversation_id: conversationId });

        this.currentConversationId = conversationId;
        this.refreshConnection();
        this.requestConversationsList();
    }

    // Show cost
    showCost() {
        if (!this.wsManager.getConnectionStatus()) {
            return;
        }

        this.wsManager.send('get_cost');
    }

    // Model selection
    toggleModelDropdown() {
        const isOpening = this.modelDropdown.classList.contains('hidden');

        this.modelDropdown.classList.toggle('hidden');

        // Refresh Ollama models list when opening the dropdown
        if (isOpening) {
            this.requestOllamaModels();
        }
    }

    selectModel(provider, model, displayName) {
        if (!this.wsManager.getConnectionStatus() || this.isProcessing) {
            return;
        }

        // Update display
        this.updateModelDisplay(provider, model, displayName);

        // Close dropdown
        this.modelDropdown.classList.add('hidden');

        // Send to backend
        this.wsManager.send('change_model', {
            provider: provider,
            model: model
        });

        console.log(`Model changed to: ${provider}/${model}`);
    }

    getFriendlyModelName(model) {
        console.log('[getFriendlyModelName] Input:', model);

        // First try exact match in mapping
        if (this.modelDisplayNames[model]) {
            console.log('[getFriendlyModelName] Exact match found:', this.modelDisplayNames[model]);
            return this.modelDisplayNames[model];
        }

        // Try general transformations for common patterns
        let friendlyName = model;

        // Remove date suffixes (e.g., -2024-07-18, -20241022)
        friendlyName = friendlyName.replace(/-\d{4}-\d{2}-\d{2}$/, '');  // YYYY-MM-DD
        friendlyName = friendlyName.replace(/-\d{8}$/, '');  // YYYYMMDD

        // Remove "latest" suffix
        friendlyName = friendlyName.replace(/-latest$/, '');

        console.log('[getFriendlyModelName] After cleanup:', friendlyName);

        // Try mapping again with cleaned name
        if (this.modelDisplayNames[friendlyName]) {
            console.log('[getFriendlyModelName] Cleaned match found:', this.modelDisplayNames[friendlyName]);
            return this.modelDisplayNames[friendlyName];
        }

        // Format the name nicely if no mapping exists
        // Replace hyphens with spaces and capitalize words
        friendlyName = friendlyName
            .split('-')
            .map(word => {
                // Keep version numbers lowercase (gpt-4o, not GPT-4O)
                if (/^\d/.test(word) || word.match(/^\d+[a-z]$/)) {
                    return word;
                }
                // Uppercase known abbreviations
                if (word === 'gpt' || word === 'llm') {
                    return word.toUpperCase();
                }
                // Capitalize first letter
                return word.charAt(0).toUpperCase() + word.slice(1);
            })
            .join(' ');

        console.log('[getFriendlyModelName] Formatted fallback:', friendlyName);
        return friendlyName;
    }

    updateModelDisplay(provider, model, displayName = null) {
        // Get friendly display name
        if (!displayName) {
            // First try the mapping for the exact model name
            displayName = this.getFriendlyModelName(model);

            // If not in mapping, try to find it in the dropdown
            if (displayName === model) {
                const modelItem = document.querySelector(`.model-item[data-provider="${provider}"][data-model="${model}"]`);
                if (modelItem) {
                    displayName = modelItem.textContent;
                }
            }
        }

        // Update display
        this.modelDisplay.textContent = displayName;

        // Update active state in dropdown
        document.querySelectorAll('.model-item').forEach(item => {
            item.classList.remove('active');
            if (item.dataset.provider === provider && item.dataset.model === model) {
                item.classList.add('active');
            }
        });
    }

    // Toggle model names display
    toggleModelNames() {
        if (!this.wsManager.getConnectionStatus()) {
            return;
        }

        this.showModelNames = !this.showModelNames;

        // Update checkbox state
        this.toggleModelNamesCheckbox.checked = this.showModelNames;

        // Send to backend
        this.wsManager.send('toggle_model_names', {
            enabled: this.showModelNames
        });

        console.log(`Model names display: ${this.showModelNames ? 'enabled' : 'disabled'}`);

        // Refresh to apply the change to existing messages
        this.refreshConnection();
    }

    // Toggle streaming mode
    toggleStreaming() {
        if (!this.wsManager.getConnectionStatus()) {
            return;
        }

        this.streamEnabled = !this.streamEnabled;

        // Update checkbox state
        this.streamToggle.checked = this.streamEnabled;

        // Send to backend
        this.wsManager.send('toggle_streaming', {
            enabled: this.streamEnabled
        });

        console.log(`Streaming: ${this.streamEnabled ? 'enabled' : 'disabled'}`);
    }

    // Toggle system prompt display
    toggleSystemPrompt() {
        if (!this.wsManager.getConnectionStatus()) {
            return;
        }

        this.showSystemPrompt = !this.showSystemPrompt;

        // Update checkbox state
        this.systemPromptToggle.checked = this.showSystemPrompt;

        // Send to backend
        this.wsManager.send('toggle_system_prompt', {
            enabled: this.showSystemPrompt
        });

        console.log(`System prompt display: ${this.showSystemPrompt ? 'enabled' : 'disabled'}`);

        // Refresh to apply the change to existing messages
        this.refreshConnection();
    }

    // resetStreamingBlocklist() method removed - auto-reset on model change handles this
    // If manual reset is needed in the future, the backend endpoint still exists

    // Dropdown management
    toggleDropdown(conversationId, actionsDiv) {
        const dropdown = actionsDiv.querySelector('.conversation-dropdown');

        // Close any existing dropdown
        if (this.activeDropdown && this.activeDropdown !== dropdown) {
            this.closeDropdown();
        }

        // Toggle current dropdown
        dropdown.classList.toggle('hidden');
        this.activeDropdown = dropdown.classList.contains('hidden') ? null : dropdown;
    }

    closeDropdown() {
        if (this.activeDropdown) {
            this.activeDropdown.classList.add('hidden');
            this.activeDropdown = null;
        }
    }

    // Rename conversation
    showRenameModal(conversationId, currentName) {
        this.renameConversationId = conversationId;
        this.renameInput.value = currentName;
        this.renameModal.classList.remove('hidden');
        this.renameInput.focus();
        this.renameInput.select();
        this.closeDropdown();
    }

    closeRenameModal() {
        this.renameModal.classList.add('hidden');
        this.renameConversationId = null;
        this.renameInput.value = '';
    }

    confirmRename() {
        const newName = this.renameInput.value.trim();
        if (!newName || !this.renameConversationId) {
            return;
        }

        this.wsManager.send('rename_conversation', {
            conversation_id: this.renameConversationId,
            new_name: newName
        });

        this.closeRenameModal();
    }

    // Duplicate conversation
    duplicateConversation(conversationId) {
        if (!this.wsManager.getConnectionStatus()) {
            return;
        }

        this.wsManager.send('duplicate_conversation', { conversation_id: conversationId });

        this.closeDropdown();
    }

    // Delete conversation
    deleteConversation(conversationId) {
        if (!this.wsManager.getConnectionStatus()) {
            return;
        }

        if (confirm('Are you sure you want to delete this conversation?')) {
            this.wsManager.send('delete_conversation', { conversation_id: conversationId });

            this.closeDropdown();
        }
    }

    // Workspace modal management
    showWorkspaceModal() {
        this.workspaceInput.value = this.currentBaseDirectory || '';
        this.workspaceModal.classList.remove('hidden');
        this.workspaceInput.focus();
        this.workspaceInput.select();
    }

    closeWorkspaceModal() {
        this.workspaceModal.classList.add('hidden');
        this.workspaceInput.value = '';
    }

    confirmWorkspace() {
        const newBaseDirectory = this.workspaceInput.value.trim();

        if (!newBaseDirectory) {
            this.showStatus('Workspace path cannot be empty', 'error');
            return;
        }

        // Only update if it changed
        if (newBaseDirectory !== this.currentBaseDirectory) {
            // Send to server
            if (this.wsManager.getConnectionStatus()) {
                this.wsManager.send('update_base_directory', { base_directory: newBaseDirectory });
                this.currentBaseDirectory = newBaseDirectory;
                this.updateWorkspaceDisplay(newBaseDirectory);
                this.showStatus('Workspace updated', 'info');
            }
        }

        this.closeWorkspaceModal();
    }

    // Update workspace display with truncated path
    updateWorkspaceDisplay(path) {
        if (!path) {
            this.workspaceDisplay.textContent = '...';
            return;
        }

        // Display full path but let CSS handle truncation from the left
        this.workspaceDisplay.textContent = path;
        this.workspaceDisplay.title = path;
    }

    // Set base directory (when loading conversation or connecting)
    setBaseDirectory(baseDirectory) {
        this.currentBaseDirectory = baseDirectory;
        this.updateWorkspaceDisplay(baseDirectory);
    }

    // System prompt modal management
    showSystemPromptModal() {
        if (!this.wsManager.getConnectionStatus()) {
            this.showStatus('Not connected', 'error');
            return;
        }

        // Request current system prompt from server
        this.wsManager.send('get_system_prompt');
    }

    receiveSystemPrompt(systemPrompt) {
        // Populate the modal and show it
        this.systemPromptInput.value = systemPrompt || '';
        this.systemPromptModal.classList.remove('hidden');
        this.systemPromptInput.focus();
    }

    closeSystemPromptModal() {
        this.systemPromptModal.classList.add('hidden');
        this.systemPromptInput.value = '';
    }

    confirmSystemPrompt() {
        const newSystemPrompt = this.systemPromptInput.value.trim();

        if (!newSystemPrompt) {
            this.showStatus('System prompt cannot be empty', 'error');
            return;
        }

        // Send to server
        if (this.wsManager.getConnectionStatus()) {
            this.wsManager.send('set_system_prompt', { system_prompt: newSystemPrompt });
            this.showStatus('System prompt updated', 'info');
        }

        this.closeSystemPromptModal();
    }

    // Tool streaming support
    updateToolOutput(data) {
        const { tool_call_id, tool_name, accumulated } = data;

        // Find the agent message panel containing this tool
        const agentMessages = this.chatContainer.querySelectorAll('.message:not([data-is-user])');
        const lastAgentMessage = agentMessages[agentMessages.length - 1];

        if (!lastAgentMessage) return;

        // Find or create the tool output element
        let toolElement = lastAgentMessage.querySelector(`[data-tool-id="${tool_call_id}"]`);

        if (!toolElement) {
            // Create placeholder tool element
            toolElement = this.createToolOutputElement(tool_call_id, tool_name);

            // Insert at the end of the message content (not the message itself)
            const contentDiv = lastAgentMessage.querySelector('.message-content');
            if (contentDiv) {
                contentDiv.appendChild(toolElement);
            } else {
                lastAgentMessage.appendChild(toolElement);
            }
        }

        // Update the output text
        const outputDiv = toolElement.querySelector('.tool-output');
        if (outputDiv) {
            outputDiv.textContent = accumulated;

            // Auto-scroll the tool output if it's long
            if (outputDiv.scrollHeight > outputDiv.clientHeight) {
                outputDiv.scrollTop = outputDiv.scrollHeight;
            }
        }

        // Add streaming indicator
        toolElement.classList.add('streaming');
    }

    cleanupStreamingToolContainers() {
        // Remove all streaming tool containers when Rich HTML arrives
        const streamingContainers = document.querySelectorAll('.tool-output-container');
        streamingContainers.forEach(container => container.remove());
    }

    createToolOutputElement(toolCallId, toolName) {
        const div = document.createElement('div');
        div.className = 'tool-output-container';
        div.dataset.toolId = toolCallId;

        div.innerHTML = `
            <div class="tool-header">
                <span class="tool-name">${this.escapeHtml(toolName)}</span>
                <span class="streaming-indicator">●</span>
            </div>
            <div class="tool-output"></div>
        `;

        return div;
    }

    escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, m => map[m]);
    }

    // Ollama models management
    requestOllamaModels() {
        if (!this.wsManager.getConnectionStatus()) {
            return;
        }

        this.wsManager.send('get_ollama_models');
    }

    handleOllamaModels(models) {
        console.log('[Ollama] Received models:', models);

        // Add Ollama models to the dropdown
        const modelDropdown = document.getElementById('model-dropdown');

        // Check if we already have an Ollama section
        let ollamaSection = modelDropdown.querySelector('.model-group.ollama-models');
        let ollamaDivider = modelDropdown.querySelector('.model-divider.ollama-divider');

        // Create section if it doesn't exist
        if (!ollamaSection) {
            // Create divider
            ollamaDivider = document.createElement('div');
            ollamaDivider.className = 'model-divider ollama-divider';
            modelDropdown.appendChild(ollamaDivider);

            // Create section
            ollamaSection = document.createElement('div');
            ollamaSection.className = 'model-group ollama-models';
            modelDropdown.appendChild(ollamaSection);
        } else {
            // Clear existing content
            ollamaSection.innerHTML = '';
        }

        if (!models || models.length === 0) {
            // No models available - show placeholder message
            const noModelsItem = document.createElement('div');
            noModelsItem.className = 'model-item disabled';
            noModelsItem.style.color = '#888';
            noModelsItem.style.fontStyle = 'italic';
            noModelsItem.style.cursor = 'default';
            noModelsItem.textContent = '(no local models available)';
            ollamaSection.appendChild(noModelsItem);

            console.log('[Ollama] No Ollama models available');
            return;
        }

        console.log('[Ollama] Found models:', models);

        // Add each Ollama model
        models.forEach(modelName => {
            const modelItem = document.createElement('div');
            modelItem.className = 'model-item';
            modelItem.dataset.provider = 'ollama';
            modelItem.dataset.model = modelName;

            // Create display name (e.g., "gpt-oss:20b" -> "GPT-OSS 20B")
            const displayName = this.formatOllamaModelName(modelName);
            modelItem.textContent = displayName;

            // Add click handler
            modelItem.addEventListener('click', () => {
                this.selectModel('ollama', modelName, displayName);
            });

            ollamaSection.appendChild(modelItem);
        });
    }

    formatOllamaModelName(modelName) {
        // Format Ollama model names for display
        // e.g., "gpt-oss:20b" -> "GPT-OSS 20B"
        //       "llama3.2" -> "Llama3.2"
        //       "mistral:7b-instruct" -> "Mistral 7B Instruct"

        // Split by colon for tags
        const [name, tag] = modelName.split(':');

        // Capitalize and format name
        let formatted = name
            .split(/[-_]/)
            .map(part => part.charAt(0).toUpperCase() + part.slice(1))
            .join(' ');

        // Add tag if present
        if (tag) {
            // Format tag (e.g., "20b" -> "20B", "7b-instruct" -> "7B Instruct")
            const formattedTag = tag
                .split('-')
                .map(part => {
                    // Uppercase "b" in sizes
                    if (part.match(/^\d+b$/i)) {
                        return part.toUpperCase();
                    }
                    return part.charAt(0).toUpperCase() + part.slice(1);
                })
                .join(' ');

            formatted += ` ${formattedTag}`;
        }

        return formatted;
    }

}

// Initialize UI when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    new OrchestralUI();
});
