# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""
IDS peak IPL (Image Processing Library) is an object-oriented library that provides special functionality for processing image data.
The IDS peak IPL can be used, for example, to convert raw bayer images from the camera that were captured via the IDS peak genericAPI into color (debayering).
"""


from typing import Any, Sequence
import numpy
import ids_peak_common.exceptions
from .exceptions import *
from ids_peak_common.datatypes.metadata_key import MetadataKey
from ids_peak_common.datatypes.iimageview import IImageView



from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _ids_peak_ipl_python_interface
else:
    import _ids_peak_ipl_python_interface

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_SwigPyIterator

    def value(self) -> "Any":
        return _ids_peak_ipl_python_interface.SwigPyIterator_value(self)

    def incr(self, n: "int"=1) -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.SwigPyIterator_incr(self, n)

    def decr(self, n: "int"=1) -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "int":
        return _ids_peak_ipl_python_interface.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _ids_peak_ipl_python_interface.SwigPyIterator_equal(self, x)

    def copy(self) -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.SwigPyIterator_copy(self)

    def next(self) -> "Any":
        return _ids_peak_ipl_python_interface.SwigPyIterator_next(self)

    def __next__(self) -> "Any":
        return _ids_peak_ipl_python_interface.SwigPyIterator___next__(self)

    def previous(self) -> "Any":
        return _ids_peak_ipl_python_interface.SwigPyIterator_previous(self)

    def advance(self, n: "int") -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _ids_peak_ipl_python_interface.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _ids_peak_ipl_python_interface.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "int") -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "int") -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "int") -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "int":
        return _ids_peak_ipl_python_interface.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.SwigPyIterator_swigregister(SwigPyIterator)
SHARED_PTR_DISOWN = _ids_peak_ipl_python_interface.SHARED_PTR_DISOWN
class HistogramChannel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PixelSum: "int" = property(_ids_peak_ipl_python_interface.HistogramChannel_PixelSum_get, _ids_peak_ipl_python_interface.HistogramChannel_PixelSum_set)
    PixelCount: "int" = property(_ids_peak_ipl_python_interface.HistogramChannel_PixelCount_get, _ids_peak_ipl_python_interface.HistogramChannel_PixelCount_set)
    Bins: "Sequence[int]" = property(_ids_peak_ipl_python_interface.HistogramChannel_Bins_get, _ids_peak_ipl_python_interface.HistogramChannel_Bins_set)

    def __init__(self):
        _ids_peak_ipl_python_interface.HistogramChannel_swiginit(self, _ids_peak_ipl_python_interface.new_HistogramChannel())
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_HistogramChannel

# Register HistogramChannel in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.HistogramChannel_swigregister(HistogramChannel)
class ImageWriterPNGParameter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Quality: "int" = property(_ids_peak_ipl_python_interface.ImageWriterPNGParameter_Quality_get, _ids_peak_ipl_python_interface.ImageWriterPNGParameter_Quality_set)

    def __init__(self):
        _ids_peak_ipl_python_interface.ImageWriterPNGParameter_swiginit(self, _ids_peak_ipl_python_interface.new_ImageWriterPNGParameter())
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_ImageWriterPNGParameter

# Register ImageWriterPNGParameter in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.ImageWriterPNGParameter_swigregister(ImageWriterPNGParameter)
class ImageWriterJPEGParameter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Quality: "int" = property(_ids_peak_ipl_python_interface.ImageWriterJPEGParameter_Quality_get, _ids_peak_ipl_python_interface.ImageWriterJPEGParameter_Quality_set)

    def __init__(self):
        _ids_peak_ipl_python_interface.ImageWriterJPEGParameter_swiginit(self, _ids_peak_ipl_python_interface.new_ImageWriterJPEGParameter())
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_ImageWriterJPEGParameter

# Register ImageWriterJPEGParameter in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.ImageWriterJPEGParameter_swigregister(ImageWriterJPEGParameter)
PEAK_IPL_VIDEO_CONTAINER_AVI = _ids_peak_ipl_python_interface.PEAK_IPL_VIDEO_CONTAINER_AVI
PEAK_IPL_VIDEO_ENCODER_RAW = _ids_peak_ipl_python_interface.PEAK_IPL_VIDEO_ENCODER_RAW
PEAK_IPL_VIDEO_ENCODER_MJPEG = _ids_peak_ipl_python_interface.PEAK_IPL_VIDEO_ENCODER_MJPEG
PEAK_IPL_VIDEO_ENCODER_OPTION_QUALITY = _ids_peak_ipl_python_interface.PEAK_IPL_VIDEO_ENCODER_OPTION_QUALITY
PEAK_IPL_VIDEO_CONTAINER_OPTION_FRAMERATE = _ids_peak_ipl_python_interface.PEAK_IPL_VIDEO_CONTAINER_OPTION_FRAMERATE

def CreateEncoder(encoder: "int") -> "IEncoder":
    r"""
    Factory to create an encoder.
    :type encoder: int, in
    :param encoder: Create an encoder of this type.
    :rtype: :py:class:`IEncoder`
    :return: Unique instance of the created encoder.

    :raises: InvalidArgumentException         Arguments passed are invalid

    Since: 1.5
    """
    return _ids_peak_ipl_python_interface.CreateEncoder(encoder)

def CreateContainer(container: "int") -> "IContainer":
    r"""
    Factory to create a container.
    :type container: int, in
    :param container: Create a container of this type.
    :rtype: :py:class:`IContainer`
    :return: Unique instance of the created container.

    :raises: InvalidArgumentException         Arguments passed are invalid

    Since: 1.5
    """
    return _ids_peak_ipl_python_interface.CreateContainer(container)
class PixelLineChannel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Values: "Sequence[int]" = property(_ids_peak_ipl_python_interface.PixelLineChannel_Values_get, _ids_peak_ipl_python_interface.PixelLineChannel_Values_set)

    def __init__(self):
        _ids_peak_ipl_python_interface.PixelLineChannel_swiginit(self, _ids_peak_ipl_python_interface.new_PixelLineChannel())
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_PixelLineChannel

# Register PixelLineChannel in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.PixelLineChannel_swigregister(PixelLineChannel)

def ConversionModeEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert a ConversionMode to a str
    :type entry: int
    :param entry: ConversionMode to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_ipl_python_interface.ConversionModeEnumEntryToString(entry)

def EndiannessEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an Endianness to a str
    :type entry: int
    :param entry: Endianness to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_ipl_python_interface.EndiannessEnumEntryToString(entry)

def OrientationEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert an Orientation to a str
    :type entry: int
    :param entry: Orientation to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_ipl_python_interface.OrientationEnumEntryToString(entry)

def PixelFormatNameEnumEntryToString(entry: "int") -> "str":
    r"""
    Convert a PixelFormatName to a str
    :type entry: int
    :param entry: PixelFormatName to convert.
    :rtype: str
    :return: String representation of ``entry``.
    """
    return _ids_peak_ipl_python_interface.PixelFormatNameEnumEntryToString(entry)
class SharpnessROI(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ids_peak_ipl_python_interface.SharpnessROI_swiginit(self, _ids_peak_ipl_python_interface.new_SharpnessROI(*args))
    rect: "Rect2D" = property(_ids_peak_ipl_python_interface.SharpnessROI_rect_get, _ids_peak_ipl_python_interface.SharpnessROI_rect_set)
    xSamplingInterval: "int" = property(_ids_peak_ipl_python_interface.SharpnessROI_xSamplingInterval_get, _ids_peak_ipl_python_interface.SharpnessROI_xSamplingInterval_set)
    ySamplingInterval: "int" = property(_ids_peak_ipl_python_interface.SharpnessROI_ySamplingInterval_get, _ids_peak_ipl_python_interface.SharpnessROI_ySamplingInterval_set)
    weight: "int" = property(_ids_peak_ipl_python_interface.SharpnessROI_weight_get, _ids_peak_ipl_python_interface.SharpnessROI_weight_set)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_SharpnessROI

# Register SharpnessROI in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.SharpnessROI_swigregister(SharpnessROI)
ConversionMode_Fast = _ids_peak_ipl_python_interface.ConversionMode_Fast
r"""Fast conversion mode"""
ConversionMode_HighQuality = _ids_peak_ipl_python_interface.ConversionMode_HighQuality
r"""High-Quality conversion mode"""
ConversionMode_Classic = _ids_peak_ipl_python_interface.ConversionMode_Classic
r"""Classic conversion mode"""
PixelFormatName_Invalid = _ids_peak_ipl_python_interface.PixelFormatName_Invalid
r"""Invalid Pixel Format"""
PixelFormatName_BayerGR8 = _ids_peak_ipl_python_interface.PixelFormatName_BayerGR8
r"""BayerGR 8-Bit pixel format"""
PixelFormatName_BayerGR10 = _ids_peak_ipl_python_interface.PixelFormatName_BayerGR10
r"""BayerGR 10-Bit pixel format"""
PixelFormatName_BayerGR12 = _ids_peak_ipl_python_interface.PixelFormatName_BayerGR12
r"""BayerGR 12-Bit pixel format"""
PixelFormatName_BayerRG8 = _ids_peak_ipl_python_interface.PixelFormatName_BayerRG8
r"""BayerRG 8-Bit pixel format"""
PixelFormatName_BayerRG10 = _ids_peak_ipl_python_interface.PixelFormatName_BayerRG10
r"""BayerRG 10-Bit pixel format"""
PixelFormatName_BayerRG12 = _ids_peak_ipl_python_interface.PixelFormatName_BayerRG12
r"""BayerRG 12-Bit pixel format"""
PixelFormatName_BayerGB8 = _ids_peak_ipl_python_interface.PixelFormatName_BayerGB8
r"""BayerGB 8-Bit pixel format"""
PixelFormatName_BayerGB10 = _ids_peak_ipl_python_interface.PixelFormatName_BayerGB10
r"""BayerGB 10-Bit pixel format"""
PixelFormatName_BayerGB12 = _ids_peak_ipl_python_interface.PixelFormatName_BayerGB12
r"""BayerGB 12-Bit pixel format"""
PixelFormatName_BayerBG8 = _ids_peak_ipl_python_interface.PixelFormatName_BayerBG8
r"""BayerBG 8-Bit pixel format"""
PixelFormatName_BayerBG10 = _ids_peak_ipl_python_interface.PixelFormatName_BayerBG10
r"""BayerBG 10-Bit pixel format"""
PixelFormatName_BayerBG12 = _ids_peak_ipl_python_interface.PixelFormatName_BayerBG12
r"""BayerBG 12-Bit pixel format"""
PixelFormatName_Mono8 = _ids_peak_ipl_python_interface.PixelFormatName_Mono8
r"""Mono 8-Bit pixel format"""
PixelFormatName_Mono10 = _ids_peak_ipl_python_interface.PixelFormatName_Mono10
r"""Mono 10-Bit pixel format"""
PixelFormatName_Mono12 = _ids_peak_ipl_python_interface.PixelFormatName_Mono12
r"""Mono 12-Bit pixel format"""
PixelFormatName_Mono16 = _ids_peak_ipl_python_interface.PixelFormatName_Mono16
r"""Mono 12-Bit pixel format"""
PixelFormatName_Confidence8 = _ids_peak_ipl_python_interface.PixelFormatName_Confidence8
r"""Confidence 8-Bit"""
PixelFormatName_Confidence16 = _ids_peak_ipl_python_interface.PixelFormatName_Confidence16
r"""Confidence 16-Bit"""
PixelFormatName_Coord3D_C8 = _ids_peak_ipl_python_interface.PixelFormatName_Coord3D_C8
r"""3D coordinate C 8-Bit"""
PixelFormatName_Coord3D_C16 = _ids_peak_ipl_python_interface.PixelFormatName_Coord3D_C16
r"""3D coordinate C 16-Bit"""
PixelFormatName_Coord3D_C32f = _ids_peak_ipl_python_interface.PixelFormatName_Coord3D_C32f
r"""3D coordinate C 32-Bit floating point"""
PixelFormatName_Coord3D_ABC32f = _ids_peak_ipl_python_interface.PixelFormatName_Coord3D_ABC32f
r"""3D coordinates A, B and C 32-Bit floating point"""
PixelFormatName_YUV420_8_YY_UV_SemiplanarIDS = _ids_peak_ipl_python_interface.PixelFormatName_YUV420_8_YY_UV_SemiplanarIDS
r"""YUV 4:2:0 8-bit YY/UV Semiplanar"""
PixelFormatName_YUV420_8_YY_VU_SemiplanarIDS = _ids_peak_ipl_python_interface.PixelFormatName_YUV420_8_YY_VU_SemiplanarIDS
r"""YUV 4:2:0 8-bit YY/VU Semiplanar"""
PixelFormatName_YUV422_8_UYVY = _ids_peak_ipl_python_interface.PixelFormatName_YUV422_8_UYVY
r"""UYVY 4:2:2 8-bit"""
PixelFormatName_RGB8 = _ids_peak_ipl_python_interface.PixelFormatName_RGB8
r"""RGB 8-Bit pixel format"""
PixelFormatName_RGB10 = _ids_peak_ipl_python_interface.PixelFormatName_RGB10
r"""RGB 10-Bit pixel format"""
PixelFormatName_RGB12 = _ids_peak_ipl_python_interface.PixelFormatName_RGB12
r"""RGB 12-Bit pixel format"""
PixelFormatName_BGR8 = _ids_peak_ipl_python_interface.PixelFormatName_BGR8
r"""BGR 8-Bit pixel format"""
PixelFormatName_BGR10 = _ids_peak_ipl_python_interface.PixelFormatName_BGR10
r"""BGR 10-Bit pixel format"""
PixelFormatName_BGR12 = _ids_peak_ipl_python_interface.PixelFormatName_BGR12
r"""BGR 12-Bit pixel format"""
PixelFormatName_RGBa8 = _ids_peak_ipl_python_interface.PixelFormatName_RGBa8
r"""RGBa 8-Bit pixel format"""
PixelFormatName_RGBa10 = _ids_peak_ipl_python_interface.PixelFormatName_RGBa10
r"""RGBa 10-Bit pixel format"""
PixelFormatName_RGBa12 = _ids_peak_ipl_python_interface.PixelFormatName_RGBa12
r"""RGBa 12-Bit pixel format"""
PixelFormatName_BGRa8 = _ids_peak_ipl_python_interface.PixelFormatName_BGRa8
r"""BGRa 8-Bit pixel format"""
PixelFormatName_BGRa10 = _ids_peak_ipl_python_interface.PixelFormatName_BGRa10
r"""BGRa 10-Bit pixel format"""
PixelFormatName_BGRa12 = _ids_peak_ipl_python_interface.PixelFormatName_BGRa12
r"""BGRa 12-Bit pixel format"""
PixelFormatName_BayerBG10p = _ids_peak_ipl_python_interface.PixelFormatName_BayerBG10p
r"""BayerBG 10-Bit packed pixel format"""
PixelFormatName_BayerBG12p = _ids_peak_ipl_python_interface.PixelFormatName_BayerBG12p
r"""BayerBG 12-Bit packed pixel format"""
PixelFormatName_BayerGB10p = _ids_peak_ipl_python_interface.PixelFormatName_BayerGB10p
r"""BayerGB 10-Bit packed pixel format"""
PixelFormatName_BayerGB12p = _ids_peak_ipl_python_interface.PixelFormatName_BayerGB12p
r"""BayerGB 12-Bit packed pixel format"""
PixelFormatName_BayerGR10p = _ids_peak_ipl_python_interface.PixelFormatName_BayerGR10p
r"""BayerGR 10-Bit packed pixel format"""
PixelFormatName_BayerGR12p = _ids_peak_ipl_python_interface.PixelFormatName_BayerGR12p
r"""BayerGR 12-Bit packed pixel format"""
PixelFormatName_BayerRG10p = _ids_peak_ipl_python_interface.PixelFormatName_BayerRG10p
r"""BayerRG 10-Bit packed pixel format"""
PixelFormatName_BayerRG12p = _ids_peak_ipl_python_interface.PixelFormatName_BayerRG12p
r"""BayerRG 12-Bit packed pixel format"""
PixelFormatName_Mono10p = _ids_peak_ipl_python_interface.PixelFormatName_Mono10p
r"""Mono 10-Bit packed pixel format"""
PixelFormatName_Mono12p = _ids_peak_ipl_python_interface.PixelFormatName_Mono12p
r"""Mono 10-Bit packed pixel format"""
PixelFormatName_RGB10p32 = _ids_peak_ipl_python_interface.PixelFormatName_RGB10p32
r"""BayerBG 10-Bit packed pixel format"""
PixelFormatName_BGR10p32 = _ids_peak_ipl_python_interface.PixelFormatName_BGR10p32
r"""BayerBG 10-Bit packed pixel format"""
PixelFormatName_BayerRG10g40IDS = _ids_peak_ipl_python_interface.PixelFormatName_BayerRG10g40IDS
r"""
    BayerRG 10-Bit packed 40bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_BayerGB10g40IDS = _ids_peak_ipl_python_interface.PixelFormatName_BayerGB10g40IDS
r"""
    BayerGB 10-Bit packed 40bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_BayerGR10g40IDS = _ids_peak_ipl_python_interface.PixelFormatName_BayerGR10g40IDS
r"""
    BayerGR 10-Bit packed 40bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_BayerBG10g40IDS = _ids_peak_ipl_python_interface.PixelFormatName_BayerBG10g40IDS
r"""
    BayerBG 10-Bit packed 40bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_BayerRG12g24IDS = _ids_peak_ipl_python_interface.PixelFormatName_BayerRG12g24IDS
r"""
    BayerRG 12-Bit packed 24bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_BayerGB12g24IDS = _ids_peak_ipl_python_interface.PixelFormatName_BayerGB12g24IDS
r"""
    BayerGB 12-Bit packed 24bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_BayerGR12g24IDS = _ids_peak_ipl_python_interface.PixelFormatName_BayerGR12g24IDS
r"""
    BayerGR 12-Bit packed 24bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_BayerBG12g24IDS = _ids_peak_ipl_python_interface.PixelFormatName_BayerBG12g24IDS
r"""
    BayerBG 12-Bit packed 24bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_Mono10g40IDS = _ids_peak_ipl_python_interface.PixelFormatName_Mono10g40IDS
r"""
    Mono 10-Bit packed 40bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
PixelFormatName_Mono12g24IDS = _ids_peak_ipl_python_interface.PixelFormatName_Mono12g24IDS
r"""
    Mono 12-Bit packed 24bit grouped pixel format
    This pixel format is preliminary, and its name and value may change in a future product version.
    """
BayerPattern_Unknown = _ids_peak_ipl_python_interface.BayerPattern_Unknown
r"""Unknown pattern"""
BayerPattern__None = _ids_peak_ipl_python_interface.BayerPattern__None
r"""No pattern"""
BayerPattern_Bayer_GR = _ids_peak_ipl_python_interface.BayerPattern_Bayer_GR
r"""BayerGR pattern"""
BayerPattern_Bayer_RG = _ids_peak_ipl_python_interface.BayerPattern_Bayer_RG
r"""BayerRG pattern"""
BayerPattern_Bayer_GB = _ids_peak_ipl_python_interface.BayerPattern_Bayer_GB
r"""BayerGB pattern"""
BayerPattern_Bayer_BG = _ids_peak_ipl_python_interface.BayerPattern_Bayer_BG
r"""BayerBG pattern"""
Endianness_Unknown = _ids_peak_ipl_python_interface.Endianness_Unknown
r"""Unknown endianness"""
Endianness_LittleEndian = _ids_peak_ipl_python_interface.Endianness_LittleEndian
r"""Little endian (lower bytes first)"""
Endianness_BigEndian = _ids_peak_ipl_python_interface.Endianness_BigEndian
r"""Big endian (higher bytes first)"""
Orientation_Horizontal = _ids_peak_ipl_python_interface.Orientation_Horizontal
r"""Horizontal orientation"""
Orientation_Vertical = _ids_peak_ipl_python_interface.Orientation_Vertical
r"""Vertical orientation"""
InterpolationAlgorithm_nearest = _ids_peak_ipl_python_interface.InterpolationAlgorithm_nearest
r"""nearest neighbor interpolation"""
InterpolationAlgorithm_linear = _ids_peak_ipl_python_interface.InterpolationAlgorithm_linear
r"""bilinear interpolation"""
InterpolationAlgorithm_cubic = _ids_peak_ipl_python_interface.InterpolationAlgorithm_cubic
r"""bicubic interpolation"""
InterpolationAlgorithm_area = _ids_peak_ipl_python_interface.InterpolationAlgorithm_area
r"""resampling using pixel area relation"""
InterpolationAlgorithm_lanczos4 = _ids_peak_ipl_python_interface.InterpolationAlgorithm_lanczos4
r"""Lanczos interpolation over 8x8 neighborhood"""
InterpolationAlgorithm_linear_exact = _ids_peak_ipl_python_interface.InterpolationAlgorithm_linear_exact
r"""Bit-exact bilinear interpolation"""
InterpolationAlgorithm_nearest_exact = _ids_peak_ipl_python_interface.InterpolationAlgorithm_nearest_exact
r"""Bit-exact bicubic interpolation"""
class Size2D(object):
    r"""2D size of an image."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    width: "int" = property(_ids_peak_ipl_python_interface.Size2D_width_get, _ids_peak_ipl_python_interface.Size2D_width_set)
    height: "int" = property(_ids_peak_ipl_python_interface.Size2D_height_get, _ids_peak_ipl_python_interface.Size2D_height_set)

    @staticmethod
    def New(width: "int", height: "int") -> "Size2D":
        r"""
        Create a new Size2D instance

        :type width: int, in
        :param width: Width to set
        :type height: int, in
        :param height: Height to set

        :rtype: :py:class:`Size2D`
        :return: The initialized Size2D
        """
        return _ids_peak_ipl_python_interface.Size2D_New(width, height)

    def __init__(self):
        _ids_peak_ipl_python_interface.Size2D_swiginit(self, _ids_peak_ipl_python_interface.new_Size2D())
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_Size2D

# Register Size2D in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.Size2D_swigregister(Size2D)
class Point2D(object):
    r"""2D position in an image."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x: "int" = property(_ids_peak_ipl_python_interface.Point2D_x_get, _ids_peak_ipl_python_interface.Point2D_x_set)
    y: "int" = property(_ids_peak_ipl_python_interface.Point2D_y_get, _ids_peak_ipl_python_interface.Point2D_y_set)

    @staticmethod
    def New(x: "int", y: "int") -> "Point2D":
        r"""
        Create a new Point2D instance

        :type x: int, in
        :param x: Pos x to set
        :type y: int, in
        :param y: Pos y to set

        :rtype: :py:class:`Point2D`
        :return: The initialized Point2D
        """
        return _ids_peak_ipl_python_interface.Point2D_New(x, y)

    def __init__(self):
        _ids_peak_ipl_python_interface.Point2D_swiginit(self, _ids_peak_ipl_python_interface.new_Point2D())
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_Point2D

# Register Point2D in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.Point2D_swigregister(Point2D)
class ScaleFactor(object):
    r"""Scale Factors of an image"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x: "float" = property(_ids_peak_ipl_python_interface.ScaleFactor_x_get, _ids_peak_ipl_python_interface.ScaleFactor_x_set)
    y: "float" = property(_ids_peak_ipl_python_interface.ScaleFactor_y_get, _ids_peak_ipl_python_interface.ScaleFactor_y_set)

    @staticmethod
    def New(x: "float", y: "float") -> "ScaleFactor":
        r"""
        Create a new ScaleFactor instance

        :type x: float, in
        :param x: Pos x to set
        :type y: float, in
        :param y: Pos y to set

        :rtype: :py:class:`ScaleFactor`
        :return: The initialized Point2D
        """
        return _ids_peak_ipl_python_interface.ScaleFactor_New(x, y)

    def __init__(self):
        _ids_peak_ipl_python_interface.ScaleFactor_swiginit(self, _ids_peak_ipl_python_interface.new_ScaleFactor())
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_ScaleFactor

# Register ScaleFactor in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.ScaleFactor_swigregister(ScaleFactor)
class Version_t(object):
    r"""Version information for ids_peak_ipl"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    major: "int" = property(_ids_peak_ipl_python_interface.Version_t_major_get, _ids_peak_ipl_python_interface.Version_t_major_set)
    minor: "int" = property(_ids_peak_ipl_python_interface.Version_t_minor_get, _ids_peak_ipl_python_interface.Version_t_minor_set, doc=r"""Major""")
    subminor: "int" = property(_ids_peak_ipl_python_interface.Version_t_subminor_get, _ids_peak_ipl_python_interface.Version_t_subminor_set, doc=r"""Minor""")

    def ToString(self) -> "str":
        r"""
         Subminor
        The String representation for the ids_peak_ipl version
        :rtype: str
        :return: the str representation
        """
        return _ids_peak_ipl_python_interface.Version_t_ToString(self)

    def __str__(self) -> "str":
        """
        Returns the str representation of the version
        """

        return self.ToString()


    def __init__(self):
        _ids_peak_ipl_python_interface.Version_t_swiginit(self, _ids_peak_ipl_python_interface.new_Version_t())
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_Version_t

# Register Version_t in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.Version_t_swigregister(Version_t)
class Library(object):
    r"""Library related functions"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def Version() -> "Version_t":
        r"""
        Queries the library version.

        :rtype: :py:class:`Version_t`
        :return: The library version as Version_t

        :raises: Exception An internal error has occurred.

        Since: 1.9.2
        """
        return _ids_peak_ipl_python_interface.Library_Version()

    @staticmethod
    def MaxConcurrentThreads() -> "int":
        r"""
        Queries the maximum number of concurrent threads used by the library.

        :rtype: int
        :return: The number of concurrent threads used by the library. Or 0 to let the library decide.

        :raises: Exception An internal error has occurred.

        Since: 1.9.2
        """
        return _ids_peak_ipl_python_interface.Library_MaxConcurrentThreads()

    @staticmethod
    def SetMaxConcurrentThreads(concurrentThreads: "int") -> "None":
        r"""
        Sets the maximum number of concurrent threads used by the library.

        Set the number of threads to 0, to let the library decide the amount. Select any other number to set the amount
        manually.

        :type concurrentThreads: int, in
        :param concurrentThreads: The number of concurrent threads used by the library.

        :raises: Exception An internal error has occurred.

        Since: 1.9.2
        """
        return _ids_peak_ipl_python_interface.Library_SetMaxConcurrentThreads(concurrentThreads)

    @staticmethod
    def MultiThreadingEnabled() -> "bool":
        r"""
        Get if multithreading is enabled in the library

        :rtype: boolean
        :return: true if multithreading is enabled, false otherwise.

        :raises: Exception An internal error has occurred.

        Since: 1.9.2
        """
        return _ids_peak_ipl_python_interface.Library_MultiThreadingEnabled()

    @staticmethod
    def SetMultiThreadingEnabled(enabled: "bool") -> "None":
        r"""
        Disables/Enables multithreading in the library

        :type enabled: boolean, in
        :param enabled: set to true to enable multithreading, false to disable it

        :raises: Exception An internal error has occurred.

        Since: 1.9.2
        """
        return _ids_peak_ipl_python_interface.Library_SetMultiThreadingEnabled(enabled)

    @staticmethod
    def SIMDEnabled() -> "bool":
        r"""
        Get if SIMD is enabled in the library

        :rtype: boolean
        :return: True, if SIMD optimized versions are used, otherwise they're not used.

        :raises: Exception An internal error has occurred.

        Since: 1.9.2
        """
        return _ids_peak_ipl_python_interface.Library_SIMDEnabled()

    @staticmethod
    def SetSIMDEnabled(enabled: "bool") -> "None":
        r"""
        Disables/Enables SIMD in the library

        :type enabled: boolean, in
        :param enabled: set to true to use the SIMD optimized functions, false to disable them

        Notes: This is normally true

        :raises: Exception An internal error has occurred.

        Since: 1.9.2
        """
        return _ids_peak_ipl_python_interface.Library_SetSIMDEnabled(enabled)

# Register Library in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.Library_swigregister(Library)
class Image(object):
    r"""Stores the pixel format, width and height of an image and the pointer to the image buffer."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_Image

    def Width(self) -> "int":
        r"""
        Returns the width.

        :rtype: int
        :return: Width

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.Image_Width(self)

    def Height(self) -> "int":
        r"""
        Returns the height.

        :rtype: int
        :return: Height

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.Image_Height(self)

    def Size(self) -> "Size2D":
        r"""
        Returns the Size.

        :rtype: :py:class:`Size2D`
        :return: Size

        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _ids_peak_ipl_python_interface.Image_Size(self)

    def ByteCount(self) -> "int":
        r"""
        Returns the size of the given image in number of bytes.

        :rtype: int
        :return: ByteCount

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.Image_ByteCount(self)

    def PixelFormat(self) -> "PixelFormat":
        r"""
        Returns the pixel format.

        :rtype: :py:class:`PixelFormat`
        :return: Pixel format

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.Image_PixelFormat(self)

    def ConvertTo(self, *args) -> "Image":
        r"""
        *Overload 1:*

        Converts the image to the specified ``outputPixelFormat``.

        Notes: This function allocates memory on every use. For faster processing, consider using Convert instead.

        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat: The desired pixel format for the output image.
        :type conversionMode: int, in, optional
        :param conversionMode:    The conversion mode.

        :rtype: :py:class:`Image`
        :return: A new Image containing the content of the image in the specified
                     ``outputPixelFormat``.

        :raises: Exception An internal error has occurred.

        Since: 1.0

        |

        *Overload 2:*
         Converts the image to the specified ``outputPixelFormat`` into an existing
                ``outputImageBuffer``.

        Notes: This function allocates memory on every use. For faster processing, consider using Convert instead.

        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat:     The desired pixel format for the output image.
        :type outputImageBuffer: int, in
        :param outputImageBuffer:     Pointer to the output buffer.
        :type outputImageBufferSize: int, in
        :param outputImageBufferSize: Size of the output buffer.
        :type conversionMode: int, in, optional
        :param conversionMode:        The conversion mode.

        :rtype: :py:class:`Image`
        :return: A Image object representing the converted image. The returned Image object encapsulates
                     the ``outputImageBuffer``. Note that the memory is not owned by the image object. Ensure the buffer is
                     not deleted until you have finished working with the image.

        :raises: BufferTooSmallException  The provided output buffer is too small for the output image.
        :raises: InvalidArgumentException The provided output buffer pointer is invalid.
        :raises: Exception                An internal error has occurred.

        Since: 1.1

        |

        *Overload 3:*
         Converts the image to the specified ``outputPixelFormat`` into an existing
                ``outputImageBuffer``.

        Notes: This function allocates memory on every use. For faster processing, consider using Convert instead.

        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat:     The desired pixel format for the output image.
        :type outputImageBuffer: int, in
        :param outputImageBuffer:     Pointer to the output buffer.
        :type outputImageBufferSize: int, in
        :param outputImageBufferSize: Size of the output buffer.
        :param conversionMode:        The conversion mode.

        :rtype: :py:class:`Image`
        :return: A Image object representing the converted image. The returned Image object encapsulates
                     the ``outputImageBuffer``. Note that the memory is not owned by the image object. Ensure the buffer is
                     not deleted until you have finished working with the image.

        :raises: BufferTooSmallException  The provided output buffer is too small for the output image.
        :raises: InvalidArgumentException The provided output buffer pointer is invalid.
        :raises: Exception                An internal error has occurred.

        Since: 1.1
        """
        return _ids_peak_ipl_python_interface.Image_ConvertTo(self, *args)

    def ConvertToWithFactor(self, *args) -> "Image":
        r"""
        *Overload 1:*

        Converts the image to the specified ``outputPixelFormat`` and scales the pixel values
               by the ``factor``.

        Notes: This function allocates memory on every use. For faster processing, consider using Convert instead.

        The ``outputPixelFormat`` must be a float pixel format.
        This function allocates memory on every use. For faster processing, consider using Convert instead.

        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat: The desired pixel format for the output image.
        :type factor: float, in
        :param factor:            Scale factor that is applied to each pixel value.
        :type offset: float, in, optional
        :param offset:            Offset that is applied to each pixel value.
        :type conversionMode: int, in, optional
        :param conversionMode:    The conversion mode.

        :rtype: :py:class:`Image`
        :return: A new Image containing the content of the image in the specified
                     ``outputPixelFormat`` with pixel values scaled by ``factor`` (*m)* and ``offset`` (*c)* added
                     according to **y = m 路 x + c**.

        :raises: ImageFormatNotSupportedException The given input or output pixel format is not supported.
        :raises: Exception An internal error has occurred.

        Since: 1.12

        |

        *Overload 2:*

        Converts the image to the specified ``outputPixelFormat`` into an existing
               ``outputImageBuffer`` and scales the pixel values by the ``factor``.

        Notes: This function allocates memory on every use. For faster processing, consider using Convert instead.

        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat:      The desired pixel format for the output image.
        :type outputImageBuffer: int, in
        :param outputImageBuffer:      Pointer to the output buffer.
        :type outputImageBufferSize: int, in
        :param outputImageBufferSize:  Size of the output buffer.
        :type factor: float, in
        :param factor:                 Scale factor that is applied to each pixel value.
        :type offset: float, in, optional
        :param offset:                 Offset that is applied to each pixel value.
        :type conversionMode: int, in, optional
        :param conversionMode:         The conversion mode.

        :rtype: :py:class:`Image`
        :return: A Image object representing the converted image. The returned Image object encapsulates
                     the ``outputImageBuffer`` with pixel values scaled by ``factor`` (*m)* and ``offset`` (*c)* added
                     according to **y = m 路 x + c**. Note that the memory is not owned by the image object. Ensure the
                     buffer is not deleted until you have finished working with the image.

        :raises: ImageFormatNotSupportedException The given input or output pixel format is not supported.
        :raises: BufferTooSmallException The provided buffer is too small for the output image.
        :raises: InvalidArgumentException The given output buffer pointer is invalid.
        :raises: Exception An internal error has occurred.

        Since: 1.15

        |

        *Overload 3:*

        Converts the image to the specified ``outputPixelFormat`` into an existing
               ``outputImageBuffer`` and scales the pixel values by the ``factor``.

        Notes: This function allocates memory on every use. For faster processing, consider using Convert instead.

        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat:      The desired pixel format for the output image.
        :type outputImageBuffer: int, in
        :param outputImageBuffer:      Pointer to the output buffer.
        :type outputImageBufferSize: int, in
        :param outputImageBufferSize:  Size of the output buffer.
        :type factor: float, in
        :param factor:                 Scale factor that is applied to each pixel value.
        :type offset: float, in, optional
        :param offset:                 Offset that is applied to each pixel value.
        :param conversionMode:         The conversion mode.

        :rtype: :py:class:`Image`
        :return: A Image object representing the converted image. The returned Image object encapsulates
                     the ``outputImageBuffer`` with pixel values scaled by ``factor`` (*m)* and ``offset`` (*c)* added
                     according to **y = m 路 x + c**. Note that the memory is not owned by the image object. Ensure the
                     buffer is not deleted until you have finished working with the image.

        :raises: ImageFormatNotSupportedException The given input or output pixel format is not supported.
        :raises: BufferTooSmallException The provided buffer is too small for the output image.
        :raises: InvalidArgumentException The given output buffer pointer is invalid.
        :raises: Exception An internal error has occurred.

        Since: 1.15

        |

        *Overload 4:*

        Converts the image to the specified ``outputPixelFormat`` into an existing
               ``outputImageBuffer`` and scales the pixel values by the ``factor``.

        Notes: This function allocates memory on every use. For faster processing, consider using Convert instead.

        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat:      The desired pixel format for the output image.
        :type outputImageBuffer: int, in
        :param outputImageBuffer:      Pointer to the output buffer.
        :type outputImageBufferSize: int, in
        :param outputImageBufferSize:  Size of the output buffer.
        :type factor: float, in
        :param factor:                 Scale factor that is applied to each pixel value.
        :param offset:                 Offset that is applied to each pixel value.
        :param conversionMode:         The conversion mode.

        :rtype: :py:class:`Image`
        :return: A Image object representing the converted image. The returned Image object encapsulates
                     the ``outputImageBuffer`` with pixel values scaled by ``factor`` (*m)* and ``offset`` (*c)* added
                     according to **y = m 路 x + c**. Note that the memory is not owned by the image object. Ensure the
                     buffer is not deleted until you have finished working with the image.

        :raises: ImageFormatNotSupportedException The given input or output pixel format is not supported.
        :raises: BufferTooSmallException The provided buffer is too small for the output image.
        :raises: InvalidArgumentException The given output buffer pointer is invalid.
        :raises: Exception An internal error has occurred.

        Since: 1.15
        """
        return _ids_peak_ipl_python_interface.Image_ConvertToWithFactor(self, *args)

    def ConvertToFromInterval(self, *args) -> "Image":
        r"""
        *Overload 1:*

        Converts the image to the specified ``outputPixelFormat``. The pixel values are mapped from ``interval`` to
               the value range of the ``outputPixelFormat``. All pixel values outside the interval will be clamped.

        Notes: This function allocates memory on every use. For faster processing, consider using Convert instead.
        The pixel format of the image must be a float pixel format.

        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat: The desired pixel format for the output image.
        :type interval: Interval< double >, in
        :param interval:          The interval of the input range.
        :type conversionMode: int, in, optional
        :param conversionMode:    The conversion mode.

        :rtype: :py:class:`Image`
        :return: A new Image containing the content of the image in the specified
                     ``outputPixelFormat`` with mapped pixel values.

        :raises: ImageFormatNotSupportedException The given input or output pixel format is not supported.
        :raises: Exception An internal error has occurred.

        Since: 1.15

        |

        *Overload 2:*

        Converts the image to the specified ``outputPixelFormat`` into an existing
               ``outputImageBuffer``. The pixel values are mapped from ``interval`` to the value range of the
               ``outputPixelFormat``. All pixel values outside the interval will be clamped.

        Notes: This function allocates memory on every use. For faster processing, consider using Convert instead.
        The pixel format of the image must be a float pixel format.

        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat:      The desired pixel format for the output image.
        :type outputImageBuffer: int, in
        :param outputImageBuffer:      Pointer to the output buffer.
        :type outputImageBufferSize: int, in
        :param outputImageBufferSize:  Size of the output buffer.
        :type interval: Interval< double >, in
        :param interval:               The interval of the input range.
        :type conversionMode: int, in, optional
        :param conversionMode:         The conversion mode.

        :rtype: :py:class:`Image`
        :return: A Image object representing the converted image. The returned Image object encapsulates
                     the ``outputImageBuffer`` with mapped pixel values. Note that the memory is not owned by the
                     image object. Ensure the buffer is not deleted until you have finished working with the image.

        :raises: ImageFormatNotSupportedException The given input or output pixel format is not supported.
        :raises: BufferTooSmallException The provided buffer is too small for the output image.
        :raises: InvalidArgumentException The given output buffer pointer is invalid.
        :raises: Exception An internal error has occurred.

        Since: 1.15

        |

        *Overload 3:*

        Converts the image to the specified ``outputPixelFormat`` into an existing
               ``outputImageBuffer``. The pixel values are mapped from ``interval`` to the value range of the
               ``outputPixelFormat``. All pixel values outside the interval will be clamped.

        Notes: This function allocates memory on every use. For faster processing, consider using Convert instead.
        The pixel format of the image must be a float pixel format.

        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat:      The desired pixel format for the output image.
        :type outputImageBuffer: int, in
        :param outputImageBuffer:      Pointer to the output buffer.
        :type outputImageBufferSize: int, in
        :param outputImageBufferSize:  Size of the output buffer.
        :type interval: Interval< double >, in
        :param interval:               The interval of the input range.
        :param conversionMode:         The conversion mode.

        :rtype: :py:class:`Image`
        :return: A Image object representing the converted image. The returned Image object encapsulates
                     the ``outputImageBuffer`` with mapped pixel values. Note that the memory is not owned by the
                     image object. Ensure the buffer is not deleted until you have finished working with the image.

        :raises: ImageFormatNotSupportedException The given input or output pixel format is not supported.
        :raises: BufferTooSmallException The provided buffer is too small for the output image.
        :raises: InvalidArgumentException The given output buffer pointer is invalid.
        :raises: Exception An internal error has occurred.

        Since: 1.15
        """
        return _ids_peak_ipl_python_interface.Image_ConvertToFromInterval(self, *args)

    def Scale(self, *args) -> "Image":
        r"""
        *Overload 1:*

        Scale the image to the supplied width and height using the supplied ``algorithm``

        :type size: :py:class:`Size2D`, in
        :param size:          output size of the image
        :type algorithm: int, in, optional
        :param algorithm:     the used interpolation algorithm

        :rtype: :py:class:`Image`
        :return: The scaled image

        :raises: Exception        An internal error has occurred.

        Since: 1.7

        |

        *Overload 2:*

        Scale the image to the supplied scale factors ``factor`` using the supplied ``algorithm``

        :type factor: :py:class:`ScaleFactor`, in
        :param factor:        output image scale factors
        :type algorithm: int, in, optional
        :param algorithm:     the used interpolation algorithm

        :rtype: :py:class:`Image`
        :return: The scaled image

        Notes: the image size is { input_image.width * factor.X, input_image.height * factor.Y }

        :raises: Exception        An internal error has occurred.

        Since: 1.7

        |

        *Overload 3:*

        Scale the image to the supplied scale factors ``factor`` using the supplied ``algorithm``

        :type factor: :py:class:`ScaleFactor`, in
        :param factor:        output image scale factors
        :param algorithm:     the used interpolation algorithm

        :rtype: :py:class:`Image`
        :return: The scaled image

        Notes: the image size is { input_image.width * factor.X, input_image.height * factor.Y }

        :raises: Exception        An internal error has occurred.

        Since: 1.7
        """
        return _ids_peak_ipl_python_interface.Image_Scale(self, *args)

    def ScaleInto(self, *args) -> "None":
        r"""
        Scale the image to the supplied width and height using the supplied ``algorithm`` and save it into the supplied buffer

        :type size: :py:class:`Size2D`, in
        :param size:          output size of the image
        :type buffer: int, in
        :param buffer:        the used interpolation algorithm
        :type bufferSize: int, in
        :param bufferSize:    the used interpolation algorithm
        :type algorithm: int, in, optional
        :param algorithm:     the used interpolation algorithm

        :raises: Exception        An internal error has occurred.

        Since: 1.7
        """
        return _ids_peak_ipl_python_interface.Image_ScaleInto(self, *args)

    def Crop(self, *args) -> "Image":
        r"""
        *Overload 1:*

        Crop the image to the ``size`` starting at ``pos``.

        :type pos: :py:class:`Point2D`, in
        :param pos:        The starting position of the cropped image
        :type size: :py:class:`Size2D`, in
        :param size:       The image size used for the cropped image

        :rtype: :py:class:`Image`
        :return: The cropped image
                *
        :raises: Exception        An internal error has occurred.

        Since: 1.7

        |

        *Overload 2:*

        Crop the image to the supplied size. Position is set to (0, 0)

        :type size: :py:class:`Size2D`, in
        :param size:     The output size.

        :rtype: :py:class:`Image`
        :return: The cropped image
                *
        :raises: Exception    An internal error has occurred.

        Since: 1.7
        """
        return _ids_peak_ipl_python_interface.Image_Crop(self, *args)

    def Clone(self) -> "Image":
        r"""
        Returns a new created image containing the data of the current image as `deep copy`.

        :rtype: :py:class:`Image`
        :return: The copied image

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.Image_Clone(self)

    def Empty(self) -> "bool":
        r"""
        Checks whether the image is empty.

        An image can be empty if its data have been moved.

        :rtype: boolean
        :return: True if the image is empty

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.Image_Empty(self)

    def Timestamp(self) -> "int":
        r"""
         The timestamp in nanoseconds

        The point in camera time at which the image was exposed.

        :rtype: int
        :return: Timestamp in nanoseconds

        Since: 1.6
        """
        return _ids_peak_ipl_python_interface.Image_Timestamp(self)

    def __eq__(self, img: "Image") -> "bool":
        r"""
        Checks whether the image is data-wise the same.
        :rtype: boolean
        :return: True if image is data-wise the same, false if not.
        """
        return _ids_peak_ipl_python_interface.Image___eq__(self, img)

    def __ne__(self, img: "Image") -> "bool":
        r"""
        Checks whether the image is data-wise different.
        :rtype: boolean
        :return: True if image is data-wise different, false if not.
        """
        return _ids_peak_ipl_python_interface.Image___ne__(self, img)

    def GetBackendHandle(self) -> "Any":
        r"""
        Get the backend handle of the underlying Image instance

        Notes: The handle might be invalid in the meantime, because no lifetime tracking is enabled by the handle itself.

        :rtype: void
        :return: The handle
        """
        return _ids_peak_ipl_python_interface.Image_GetBackendHandle(self)

    _handle = property(GetBackendHandle)

    def __deepcopy__(self, memo):
        """
        Copies the image
        """
        return self.Clone()

    def get_numpy(self) -> "numpy.ndarray":
        """
        Convenience function to get a numpy array with the correct dimensions for the pixelformat e.g. RGB8 has 3 channels
        with 8Bit Data so this will return a ndarry with size 8 and 3 dimensions.

        :returns: the numpy array (dimension depends on pixel format)
        """

        info = self.PixelFormat()
        is_float = info.IsFloat()
        pixel_size = info.CalculateStorageSizeOfPixels(1)
        channel_count = info.NumChannels()
        channel_size = pixel_size / channel_count

        if info.IsPacked():
            return self.get_numpy_1D()
        elif is_float:
            if channel_count == 1:
                return self.get_numpy_2D().view(dtype=numpy.float32)
            else:
                return self.get_numpy_3D().view(dtype=numpy.float32)
        else:
            if channel_count == 1:
                if channel_size == 1:
                    return self.get_numpy_2D()
                elif channel_size == 2:
                    return self.get_numpy_2D_16()
                else:
                    return self.get_numpy_1D()
            else:
                if channel_size == 1:
                    return self.get_numpy_3D()
                elif channel_size == 2:
                    return self.get_numpy_3D_16()
                else:
                    return self.get_numpy_1D()

    @staticmethod
    def from_image_view(view: ids_peak_common.IImageView):
        return Image.CreateFromSizeAndPythonBufferWithTimestamp(view.pixel_format.value, view.to_memoryview(), view.width, view.height, view.metadata.get_value_by_key(ids_peak_common.MetadataKey.DEVICE_TIMESTAMP));



    @staticmethod
    def CreateFromSize(pixelFormatName: "int", width: "int", height: "int") -> "Image":
        r"""
        Creates a new Image with the supplied pixel format and dimensions
        :type pixelFormatName: int, in
        :param pixelFormatName: The pixel format the image should be created for
        :type width: int, in
        :param width: The width of the new Image
        :type height: int, in
        :param height: The height of the new Image
        :rtype: :py:class:`Image`
        :return: The created Image instance
        """
        return _ids_peak_ipl_python_interface.Image_CreateFromSize(pixelFormatName, width, height)

    @staticmethod
    def CreateFromSizeAndBuffer(pixelFormatName: "int", buffer: "Any", bufferSize_bytes: "int", width: "int", height: "int") -> "Image":
        r"""
        Creates a new Image with the supplied pixel format and dimensions from the supplied buffer
        :type pixelFormatName: int, in
        :param pixelFormatName: The pixel format the image should be created for
        :type buffer: void, in
        :param buffer: The supplied buffer pointer
        :type bufferSize_bytes: int, in
        :param bufferSize_bytes: The size of the supplied buffer
        :type width: int, in
        :param width: The width of the new Image
        :type height: int, in
        :param height: The height of the new Image
        :rtype: :py:class:`Image`
        :return: The created Image instance
        """
        return _ids_peak_ipl_python_interface.Image_CreateFromSizeAndBuffer(pixelFormatName, buffer, bufferSize_bytes, width, height)

    @staticmethod
    def CreateFromSizeAndPythonBuffer(pixelFormatName: "int", buffer: "bytes", width: "int", height: "int") -> "Image":
        r"""
        Creates a new Image with the supplied pixel format and dimensions from the supplied buffer
        :type pixelFormatName: int, in
        :param pixelFormatName: The pixel format the image should be created for
        :type buffer: int, in
        :param buffer: The supplied buffer
        :type width: int, in
        :param width: The width of the new Image
        :type height: int, in
        :param height: The height of the new Image
        :rtype: :py:class:`Image`
        :return: The created Image instance
        """
        return _ids_peak_ipl_python_interface.Image_CreateFromSizeAndPythonBuffer(pixelFormatName, buffer, width, height)

    @staticmethod
    def CreateFromSizeAndPythonBufferWithTimestamp(pixelFormatName: "int", buffer: "bytes", width: "int", height: "int", timestamp_ns: "int") -> "Image":
        r"""
        Creates a new Image with the supplied pixel format and dimensions from the supplied buffer
        :type pixelFormatName: int, in
        :param pixelFormatName: The pixel format the image should be created for
        :type buffer: int, in
        :param buffer: The supplied buffer
        :type width: int, in
        :param width: The width of the new Image
        :type height: int, in
        :param height: The height of the new Image
        :type timestamp_ns: int, in
        :param timestamp_ns: The timestamp of the Image in nanoseconds
        :rtype: :py:class:`Image`
        :return: The created Image instance
        """
        return _ids_peak_ipl_python_interface.Image_CreateFromSizeAndPythonBufferWithTimestamp(pixelFormatName, buffer, width, height, timestamp_ns)

    def get_numpy_1D(self) -> "numpy.ndarray":
        r"""
        Get the numpy 1D / 8Bit representation of the buffer
        Notes: No checks are done, if this is the "correct" format. Use 'get_numpy' for a convenience function.
        Remarks: Take care to hold a reference of the image at all times. Otherwise deepcopy it.
        :rtype: void
        :return: The buffer representation as a numpy array
        """
        return _ids_peak_ipl_python_interface.Image_get_numpy_1D(self)

    def get_numpy_2D(self) -> "numpy.ndarray":
        r"""
        Get the numpy 2D / 8Bit representation of the buffer
        Notes: No checks are done, if this is the "correct" format. Use 'get_numpy' for a convenience function.
        Remarks: Take care to hold a reference of the image at all times. Otherwise deepcopy it.
        :rtype: void
        :return: The buffer representation as a numpy array
        """
        return _ids_peak_ipl_python_interface.Image_get_numpy_2D(self)

    def get_numpy_3D(self) -> "numpy.ndarray":
        r"""
        Get the numpy 3D / 8Bit representation of the buffer
        Notes: No checks are done, if this is the "correct" format. Use 'get_numpy' for a convenience function.
        Remarks: Take care to hold a reference of the image at all times. Otherwise deepcopy it.
        :rtype: void
        :return: The buffer representation as a numpy array
        """
        return _ids_peak_ipl_python_interface.Image_get_numpy_3D(self)

    def get_numpy_1D_16(self) -> "numpy.ndarray":
        r"""
        Get the numpy 1D / 16Bit representation of the buffer
        Notes: No checks are done, if this is the "correct" format. Use 'get_numpy' for a convenience function.
        Remarks: Take care to hold a reference of the image at all times. Otherwise deepcopy it.
        :rtype: void
        :return: The buffer representation as a numpy array
        """
        return _ids_peak_ipl_python_interface.Image_get_numpy_1D_16(self)

    def get_numpy_2D_16(self) -> "numpy.ndarray":
        r"""
        Get the numpy 2D / 16Bit representation of the buffer
        Notes: No checks are done, if this is the "correct" format. Use 'get_numpy' for a convenience function.
        Remarks: Take care to hold a reference of the image at all times. Otherwise deepcopy it.
        :rtype: void
        :return: The buffer representation as a numpy array
        """
        return _ids_peak_ipl_python_interface.Image_get_numpy_2D_16(self)

    def get_numpy_3D_16(self) -> "numpy.ndarray":
        r"""
        Get the numpy 3D / 16Bit representation of the buffer
        Notes: No checks are done, if this is the "correct" format. Use 'get_numpy' for a convenience function.
        Remarks: Take care to hold a reference of the image at all times. Otherwise deepcopy it.
        :rtype: void
        :return: The buffer representation as a numpy array
        """
        return _ids_peak_ipl_python_interface.Image_get_numpy_3D_16(self)

    def DataView(self) -> "bytes":
        r"""
        Get the buffer protocol view of the image buffer.
        :rtype: bytes
        :return: The buffer representation as a buffer protocol interface type
        """
        return _ids_peak_ipl_python_interface.Image_DataView(self)

# Register Image in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.Image_swigregister(Image)
class Rect2D(object):
    r"""Rectangle type"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _ids_peak_ipl_python_interface.Rect2D_swiginit(self, _ids_peak_ipl_python_interface.new_Rect2D(*args))

    def topLeft(self) -> "Point2D":
        r"""Returns the position of the top-left corner of the rectangle"""
        return _ids_peak_ipl_python_interface.Rect2D_topLeft(self)

    def size(self) -> "Size2D":
        r"""Returns the size of the rectancle"""
        return _ids_peak_ipl_python_interface.Rect2D_size(self)

    def left(self) -> "int":
        r"""Returns the left position of the rectangle"""
        return _ids_peak_ipl_python_interface.Rect2D_left(self)

    def right(self) -> "int":
        r"""Returns the right position of the rectangle"""
        return _ids_peak_ipl_python_interface.Rect2D_right(self)

    def top(self) -> "int":
        r"""Returns the top position of the rectangle"""
        return _ids_peak_ipl_python_interface.Rect2D_top(self)

    def bottom(self) -> "int":
        r"""Returns the bottom position of the rectangle"""
        return _ids_peak_ipl_python_interface.Rect2D_bottom(self)

    def setSize(self, size: "Size2D") -> "None":
        r"""Sets a new size for the rectangle"""
        return _ids_peak_ipl_python_interface.Rect2D_setSize(self, size)

    def setWidth(self, width: "int") -> "None":
        r"""Sets the rectangle width"""
        return _ids_peak_ipl_python_interface.Rect2D_setWidth(self, width)

    def setHeight(self, height: "int") -> "None":
        r"""Sets the rectangle height"""
        return _ids_peak_ipl_python_interface.Rect2D_setHeight(self, height)

    def setX(self, x: "int") -> "None":
        r"""Sets the left position of the rectangle"""
        return _ids_peak_ipl_python_interface.Rect2D_setX(self, x)

    def setY(self, y: "int") -> "None":
        r"""Sets the top position of the rectangle"""
        return _ids_peak_ipl_python_interface.Rect2D_setY(self, y)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_Rect2D

# Register Rect2D in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.Rect2D_swigregister(Rect2D)
class ColorCorrectionFactors(object):
    r"""The Factors of the Color Correction Matrix."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_ColorCorrectionFactors

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new ColorCorrectionFactors instance

        Creates a new ColorCorrectionFactors instance.

        The matrix is row-wise sorted:

        |    |    |    |
        | -- | -- | -- |
        | RR | GR | BR |
        | RG | GG | BG |
        | RB | GB | BB |

        :type facRR: float, in
        :param facRR: Red-Red Factor.
        :type facGR: float, in
        :param facGR: Green-Red Factor.
        :type facBR: float, in
        :param facBR: Blue-Red Factor.
        :type facRG: float, in
        :param facRG: Red-Green Factor.
        :type facGG: float, in
        :param facGG: Green-Green Factor.
        :type facBG: float, in
        :param facBG: Blue-Green Factor.
        :type facRB: float, in
        :param facRB: Red-Blue Factor.
        :type facGB: float, in
        :param facGB: Green-Blue Factor.
        :type facBB: float, in
        :param facBB: Blue-Blue Factor.

        Since: 1.0

        |

        *Overload 2:*
         Constructor for a new ColorCorrectionFactors instance

        Creates a new ColorCorrectionFactors instance with an array.
        The values are expected left to right and top to bottom.

        The matrix is row-wise sorted:

        |        |        |        |
        | ------ | ------ | ------ |
        | RR (0) | GR (1) | BR (2) |
        | RG (3) | GG (4) | BG (5) |
        | RB (6) | GB (7) | BB (8) |

        :type factors: array< float,9 >, in
        :param factors: The factors.

        Since: 1.16

        |

        *Overload 3:*
         Constructor for a new ColorCorrectionFactors instance

        Creates a new ColorCorrectionFactors instance. The Factors are initialized to zero.

        Since: 1.0

        |

        *Overload 4:*
         Move constructor for ColorCorrectionFactors instance

        Moves the instance from ``other`` to this. Afterward ``other`` is invalid.

        :type o: :py:class:`ColorCorrectionFactors`, in
        :param o: The other instance to move the factors from.

        Since: 1.0
        """
        _ids_peak_ipl_python_interface.ColorCorrectionFactors_swiginit(self, _ids_peak_ipl_python_interface.new_ColorCorrectionFactors(*args))

    def __eq__(self, other: "ColorCorrectionFactors") -> "bool":
        r"""
         Compare ColorCorrectionFactors

        Compares the factors from ``other`` to this instance

        :type other: :py:class:`ColorCorrectionFactors`, in
        :param other: The other instance to compare.

        :rtype: boolean
        :return: True if equal, false otherwise.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.ColorCorrectionFactors___eq__(self, other)

    @staticmethod
    def Identity() -> "ColorCorrectionFactors":
        r"""
         Create an identity matrix

        This will return a ColorCorrectionFactors matrix with diagonal all 1 and all other 0.

        :rtype: :py:class:`ColorCorrectionFactors`
        :return: The identity matrix.

        Since: 1.16
        """
        return _ids_peak_ipl_python_interface.ColorCorrectionFactors_Identity()

    def AsArray(self) -> "Any":
        r"""
         Returns the ColorCorrectionFactors as an array

        :rtype: array< float,9 >
        :return: The factors as a array.

        Since: 1.16
        """
        return _ids_peak_ipl_python_interface.ColorCorrectionFactors_AsArray(self)
    factorRR: "float" = property(_ids_peak_ipl_python_interface.ColorCorrectionFactors_factorRR_get, _ids_peak_ipl_python_interface.ColorCorrectionFactors_factorRR_set)
    factorGR: "float" = property(_ids_peak_ipl_python_interface.ColorCorrectionFactors_factorGR_get, _ids_peak_ipl_python_interface.ColorCorrectionFactors_factorGR_set)
    factorBR: "float" = property(_ids_peak_ipl_python_interface.ColorCorrectionFactors_factorBR_get, _ids_peak_ipl_python_interface.ColorCorrectionFactors_factorBR_set)
    factorRG: "float" = property(_ids_peak_ipl_python_interface.ColorCorrectionFactors_factorRG_get, _ids_peak_ipl_python_interface.ColorCorrectionFactors_factorRG_set)
    factorGG: "float" = property(_ids_peak_ipl_python_interface.ColorCorrectionFactors_factorGG_get, _ids_peak_ipl_python_interface.ColorCorrectionFactors_factorGG_set)
    factorBG: "float" = property(_ids_peak_ipl_python_interface.ColorCorrectionFactors_factorBG_get, _ids_peak_ipl_python_interface.ColorCorrectionFactors_factorBG_set)
    factorRB: "float" = property(_ids_peak_ipl_python_interface.ColorCorrectionFactors_factorRB_get, _ids_peak_ipl_python_interface.ColorCorrectionFactors_factorRB_set)
    factorGB: "float" = property(_ids_peak_ipl_python_interface.ColorCorrectionFactors_factorGB_get, _ids_peak_ipl_python_interface.ColorCorrectionFactors_factorGB_set)
    factorBB: "float" = property(_ids_peak_ipl_python_interface.ColorCorrectionFactors_factorBB_get, _ids_peak_ipl_python_interface.ColorCorrectionFactors_factorBB_set)

# Register ColorCorrectionFactors in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.ColorCorrectionFactors_swigregister(ColorCorrectionFactors)
class ChromaticAdapter(object):
    r"""
    Adjust to changes in lighting conditions to maintain consistent color perception despite variations in light sources.

    In industrial imaging, white balance can fail due to the lack of a neutral reference in the image, such as when the
    scene contains no gray or white areas, or when the colors are unevenly distributed (as in images dominated by a single color).
    In these cases, traditional white balance algorithms, like the gray world method, may fail to produce accurate color corrections.

    Chromatic adaptation provides an alternative solution by adjusting the images colors based on the known or
    estimated correlated color temperature of the light source.

    Notes:
    If chromatic adaption is used in combination with white balance, the result is indefinite.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ColorSpace_SRGB_D50 = _ids_peak_ipl_python_interface.ChromaticAdapter_ColorSpace_SRGB_D50
    r"""sRGB (standard RGB): standard illuminant D50 (5000 K), gamma 2.2."""
    ColorSpace_SRGB_D65 = _ids_peak_ipl_python_interface.ChromaticAdapter_ColorSpace_SRGB_D65
    r"""sRGB (standard RGB): standard illuminant D65 (6500 K), gamma 2.2."""
    ColorSpace_CIE_RGB_E = _ids_peak_ipl_python_interface.ChromaticAdapter_ColorSpace_CIE_RGB_E
    r"""CIE-RGB: standard illuminant E (equal energy distribution), gamma 2.2."""
    ColorSpace_ECI_RGB_D50 = _ids_peak_ipl_python_interface.ChromaticAdapter_ColorSpace_ECI_RGB_D50
    r"""ECI-RGB: standard illuminant D50 (5000 K), gamma 1.8."""
    ColorSpace_Adobe_RGB_D65 = _ids_peak_ipl_python_interface.ChromaticAdapter_ColorSpace_Adobe_RGB_D65
    r"""Adobe RGB: standard illuminant D65 (6500 K), gamma 2.2."""
    Algorithm_Legacy = _ids_peak_ipl_python_interface.ChromaticAdapter_Algorithm_Legacy
    r"""The legacy algorithm"""
    Algorithm_Bradford = _ids_peak_ipl_python_interface.ChromaticAdapter_Algorithm_Bradford
    r"""The Bradford CAT matrix algorithm. This is the default."""
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_ChromaticAdapter

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new Chromatic Adapter instance

        Since: 1.16

        |

        *Overload 2:*
         Copy Constructor for a new Chromatic Adapter instance

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`ChromaticAdapter`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.16

        |

        *Overload 3:*
         Move constructor for Chromatic Adapter instance

        Moves the instance from ``other`` to this, leaving ``other`` in an invalid state.

        :type other: :py:class:`ChromaticAdapter`, in
        :param other: The other instance to move.

        Since: 1.16
        """
        _ids_peak_ipl_python_interface.ChromaticAdapter_swiginit(self, _ids_peak_ipl_python_interface.new_ChromaticAdapter(*args))

    def TargetColorSpace(self) -> "ColorSpace":
        r"""
        Get the target color space

        There are many available color spaces.
        The implemented color spaces are listed in the enum 'ColorSpace'.

        :rtype: int
        :return: The currently set color space.

        Since: 1.16
        """
        return _ids_peak_ipl_python_interface.ChromaticAdapter_TargetColorSpace(self)

    def SetTargetColorSpace(self, colorSpace: "ColorSpace") -> "None":
        r"""
        Set the target color space

        The available color spaces are listed in the enum 'ColorSpace'.

        :type colorSpace: int, in
        :param colorSpace: The color space to set.

        Since: 1.16
        """
        return _ids_peak_ipl_python_interface.ChromaticAdapter_SetTargetColorSpace(self, colorSpace)

    def AdaptionAlgorithm(self) -> "Algorithm":
        r"""
        Get the current algorithm used for chromatic adaption

        The implemented algorithms are listed in the enum 'Algorithm'.

        :rtype: int
        :return: The currently set algorithm.

        Since: 1.16
        """
        return _ids_peak_ipl_python_interface.ChromaticAdapter_AdaptionAlgorithm(self)

    def SetAdaptionAlgorithm(self, algorithm: "Algorithm") -> "None":
        r"""
        Set the algorithm used for chromatic adaption

        The available algorithms are listed in the enum 'Algorithm'.

        :type algorithm: int, in
        :param algorithm: The algorithm to set.

        Since: 1.16
        """
        return _ids_peak_ipl_python_interface.ChromaticAdapter_SetAdaptionAlgorithm(self, algorithm)

    def TemperatureRange(self) -> "RangeInt32":
        r"""
        Returns the allowed temperature range for the current combination of color space and algorithm.

        :rtype: Range< int >
        :return: The allowed temperature range in Kelvin.

        Since: 1.16
        """
        return _ids_peak_ipl_python_interface.ChromaticAdapter_TemperatureRange(self)

    def CalculateColorCorrectionMatrix(self, *args) -> "ColorCorrectionFactors":
        r"""
        Calculate the color correction factors for colorTemperature using the current algorithm and color space.

        The optional parameter ``correctionFactors`` can be used if the chromatic adaption is to be applied in parallel
        with another color correction, e.g. the HQ matrix for the camera filter glass. The result will be a
        matrix multiplication of the initial CCM and the chromatic adaption. It can directly be used.
        When using the 'ColorCorrector' module, it might be advantageous to adjust an already set CCM using the comfort function
        'ApplyChromaticAdaption'

        :type colorTemperature: int, in
        :param colorTemperature:  The color temperature in Kelvin for which the factors are be.
        :type correctionFactors: :py:class:`ColorCorrectionFactors`, in, optional
        :param correctionFactors: The input color correction matrix. Default is the identity matrix.

        :rtype: :py:class:`ColorCorrectionFactors`
        :return: The calculated color correction factors.

        Since: 1.16
        """
        return _ids_peak_ipl_python_interface.ChromaticAdapter_CalculateColorCorrectionMatrix(self, *args)

# Register ChromaticAdapter in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.ChromaticAdapter_swigregister(ChromaticAdapter)
class ColorCorrector(object):
    r"""Applies a 3x3 color correction matrix to the data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_ColorCorrector

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new ColorCorrector instance

        Creates a new ColorCorrector instance.

        Since: 1.0

        |

        *Overload 2:*
         Copy Constructor for a new ColorCorrector instance

        Creates a new ColorCorrector instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`ColorCorrector`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.0 Deleted.
        1.8 Implemented as shallow copy.

        |

        *Overload 3:*
         Move constructor for ColorCorrector instance

        Moves the instance from ``other`` to this.
        Afterward, ``other`` is invalid.

        :type other: :py:class:`ColorCorrector`, in
        :param other: The other instance to move.

        Since: 1.0
        """
        _ids_peak_ipl_python_interface.ColorCorrector_swiginit(self, _ids_peak_ipl_python_interface.new_ColorCorrector(*args))

    def SetColorCorrectionFactors(self, colorCorrectorFactors: "ColorCorrectionFactors") -> "None":
        r"""
        Sets the values of the color correction matrix.

        The matrix is row-wise sorted:
        |    |    |    |
        | -- | -- | -- |
        | RR | GR | BR |
        | RG | GG | BG |
        | RB | GB | BB |

        :type colorCorrectorFactors: :py:class:`ColorCorrectionFactors`, in
        :param colorCorrectorFactors: The factors of the color correction matrix.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.ColorCorrector_SetColorCorrectionFactors(self, colorCorrectorFactors)

    def ColorCorrectionFactors(self, *args) -> "ColorCorrectionFactors":
        r"""
        *Overload 1:*

        Returns the factors of the color correction matrix.

        :rtype: :py:class:`ColorCorrectionFactors`
        :return: colorCorrectorFactors The factors of the color correction matrix

        Since: 1.0

        |

        *Overload 2:*

        Returns the factors of the color correction matrix.

        :rtype: :py:class:`ColorCorrectionFactors`
        :return: colorCorrectorFactors The factors of the color correction matrix

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.ColorCorrector_ColorCorrectionFactors(self, *args)

    def Saturation(self) -> "float":
        r"""
        Returns the color saturation value.

        :rtype: float
        :return: The color saturation value

        Since: 1.6
        """
        return _ids_peak_ipl_python_interface.ColorCorrector_Saturation(self)

    def SaturationMin(self) -> "float":
        r"""
        Returns the minimum color saturation value.

        :rtype: float
        :return: The minimum color saturation value

        Since: 1.6
        """
        return _ids_peak_ipl_python_interface.ColorCorrector_SaturationMin(self)

    def SaturationMax(self) -> "float":
        r"""
        Returns the maximum color saturation value.

        :rtype: float
        :return: The maximum color saturation value

        Since: 1.6
        """
        return _ids_peak_ipl_python_interface.ColorCorrector_SaturationMax(self)

    def SetSaturation(self, saturation: "float") -> "None":
        r"""
        Sets the color saturation value.

        :type saturation: float, in
        :param saturation: The color saturation value.

        Since: 1.6
        """
        return _ids_peak_ipl_python_interface.ColorCorrector_SetSaturation(self, saturation)

    def ApplyChromaticAdaption(self, chromaticAdapter: "ChromaticAdapter", colorTemperature: "int") -> "None":
        r"""
        Applies the chromatic adaption matrix to the color corrector matrix.

        This calculates and applies the chromatic adaption matrix to the existing color corrector matrix.

        Notes: The existing matrix will be overwritten and cannot be restored.
        If this is not the intended behavior, it is advised to store the factors beforehand.

        :type chromaticAdapter: :py:class:`ChromaticAdapter`, in
        :param chromaticAdapter: The chromatic adapter instance.
        :type colorTemperature: int, in
        :param colorTemperature: The color temperature to set in Kelvin.

        Since: 1.16
        """
        return _ids_peak_ipl_python_interface.ColorCorrector_ApplyChromaticAdaption(self, chromaticAdapter, colorTemperature)

    def IsPixelFormatSupported(self, pixelFormatName: "int") -> "bool":
        r"""
        Returns whether the color corrector supports the given pixel format.

        :rtype: boolean
        :return: Flag whether the given pixel format is supported.

        :type pixelFormatName: int, in
        :param pixelFormatName: The pixel format of interest.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.ColorCorrector_IsPixelFormatSupported(self, pixelFormatName)

    def ProcessInPlace(self, image: "Image") -> "None":
        r"""
        Corrects the colors of the given image by applying a 3x3 color correction matrix to the data
               in place that is it will change the input image.

        :type image: :py:class:`Image`, in
        :param image: Image to process.

        Notes: Will not work with packed pixel formats. See 'unpackPixelformat' for the correct handling of this.

        :raises: ImageFormatNotSupportedException image has unsupported pixel format (for example packed pixel format)

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if image has packed a pixel format
        """
        return _ids_peak_ipl_python_interface.ColorCorrector_ProcessInPlace(self, image)

    def Process(self, inputImage: "Image") -> "Image":
        r"""
         Corrects the colors of the given image by applying a 3x3 color correction matrix to the data.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: Image to process.

        Notes: Will not work with packed pixel formats. See 'unpackPixelformat' for the correct handling of this.

        :rtype: :py:class:`Image`
        :return: A new created image containing the color corrected pixels

        :raises: ImageFormatNotSupportedException image has unsupported pixel format (for example packed pixel format)

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if inputImage has a packed pixel format
        """
        return _ids_peak_ipl_python_interface.ColorCorrector_Process(self, inputImage)

# Register ColorCorrector in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.ColorCorrector_swigregister(ColorCorrector)
class GammaCorrector(object):
    r"""Applies digital black and gamma correction to the image data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_GammaCorrector

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new GammaCorrector instance

        Creates a new GammaCorrector instance.

        Since: 1.2.2

        |

        *Overload 2:*
         Copy Constructor for a new GammaCorrector instance

        Creates a new GammaCorrector instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`GammaCorrector`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.2.2 Deleted
        1.8   Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for GammaCorrector instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`GammaCorrector`, in
        :param other: The other instance to move.

        Since: 1.2.2
        """
        _ids_peak_ipl_python_interface.GammaCorrector_swiginit(self, _ids_peak_ipl_python_interface.new_GammaCorrector(*args))

    def SetGammaCorrectionValue(self, gammaValue: "float") -> "None":
        r"""
        Sets the gamma value of the gamma correction.

        The gamma correction adjusts the camera characteristic curve to a typical display characteristic curve
        by raising the gray values to the power of the inverse gamma value.
        Usually, sRGB colors with a gamma of 2.2 are assumed. A gamma setting of 1.0 preserves linear gray values.

        The human eye perceives differences in brightness with a logarithmic characteristic curve,
        which is often approximated in practice with a gamma characteristic curve.
        The brightness perceived by humans increases more steeply in dark areas and less steeply in bright areas.

        :type gammaValue: float, in
        :param gammaValue: The value of the gamma correction.

        :raises: InvalidArgument gammaValue isn't supported.

        Since: 1.2.2
        """
        return _ids_peak_ipl_python_interface.GammaCorrector_SetGammaCorrectionValue(self, gammaValue)

    def GammaCorrectionValue(self) -> "float":
        r"""
        Returns the value of the gamma correction.

        :rtype: float
        :return: gammaValue The value of the gamma correction.

        Since: 1.2.2
        """
        return _ids_peak_ipl_python_interface.GammaCorrector_GammaCorrectionValue(self)

    def GammaCorrectionMin(self) -> "float":
        r"""
        Returns the minimum value of the gamma correction.

        :rtype: float
        :return: gammaMin The minimum value of the gamma correction.

        Since: 1.2.2
        """
        return _ids_peak_ipl_python_interface.GammaCorrector_GammaCorrectionMin(self)

    def GammaCorrectionMax(self) -> "float":
        r"""
        Returns the maximum value of the gamma correction.

        :rtype: float
        :return: gammaMax The maximum value of the gamma correction.

        Since: 1.2.2
        """
        return _ids_peak_ipl_python_interface.GammaCorrector_GammaCorrectionMax(self)

    def SetDigitalBlack(self, digitalBlackValue: "float") -> "None":
        r"""
        Configures the digital black correction value to adjust RGB master black.

        This function sets the digital black, which shifts the darkest parts of an image towards zero.
        The value you set determines what intensity is treated as black, without changing the brightest parts (white level).
        This helps in the following ways:

        - **Improves contrast**: Reduces stray light effects and makes dark areas truly black.
        - **Focuses on specific brightness ranges**: Allows you to visualize a certain range of brightness in the image.

        The value is supplied as a fraction of the maximum possible pixel value.

        Note that gamma correction is applied after the digital black correction.
        Digital black is distinct from sensor electrical black adjustments, which can be set using the device black level.
        Digital black correction cannot address offsets in Bayer raw data.

        :type digitalBlackValue: float, in
        :param digitalBlackValue: The value of the digital black correction as decimal fraction of the maximum range of the corresponding bit depth.

        :raises: InvalidArgument digitalBlackValue is not supported.

        Since: 1.15
        """
        return _ids_peak_ipl_python_interface.GammaCorrector_SetDigitalBlack(self, digitalBlackValue)

    def DigitalBlack(self) -> "float":
        r"""
        Returns the value of the digital black correction.

        :rtype: float
        :return: the value of the digital black correction as decimal fraction of the maximum range of the corresponding bit depth.

        Since: 1.15
        """
        return _ids_peak_ipl_python_interface.GammaCorrector_DigitalBlack(self)

    def DigitalBlackMin(self) -> "float":
        r"""
        Returns the minimum value of the digital black correction.

        :rtype: float
        :return: the minimum value of the digital black correction (0.0f)
            0.0f means that digital black correction is disabled.

        Since: 1.15
        """
        return _ids_peak_ipl_python_interface.GammaCorrector_DigitalBlackMin(self)

    def DigitalBlackMax(self) -> "float":
        r"""
        Returns the maximum value of the digital black correction.

        :rtype: float
        :return: the maximum value of the digital black correction (1.0f).
            1.0f corresponds to the maximum range of the corresponding bit depth.

        Since: 1.15
        """
        return _ids_peak_ipl_python_interface.GammaCorrector_DigitalBlackMax(self)

    def IsPixelFormatSupported(self, pixelFormatName: "int") -> "bool":
        r"""
        Returns whether the gamma corrector supports the given pixel format.

        :rtype: boolean
        :return: Flag whether the given pixel format is supported.

        :type pixelFormatName: int, in
        :param pixelFormatName: The pixel format of interest.

        Since: 1.2.2
        """
        return _ids_peak_ipl_python_interface.GammaCorrector_IsPixelFormatSupported(self, pixelFormatName)

    def ProcessInPlace(self, image: "Image") -> "None":
        r"""
        Corrects the gammas of the given image in place that is, it will change the input image.

        :type image: :py:class:`Image`, in
        :param image: Image to process.

        Notes: Will not work with packed pixel formats. See 'unpackPixelformat' for the correct handling of this.

        :raises: ImageFormatNotSupportedException image has unsupported pixel format.

        Since: 1.2.2
        """
        return _ids_peak_ipl_python_interface.GammaCorrector_ProcessInPlace(self, image)

    def Process(self, inputImage: "Image") -> "Image":
        r"""
         Corrects the gammas of the given image.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: Image to process.

        Notes: Will not work with packed pixel formats. See 'unpackPixelformat' for the correct handling of this.

        :rtype: :py:class:`Image`
        :return: A new created image containing the gamma-corrected pixels.

        :raises: ImageFormatNotSupportedException image has unsupported pixel format.

        Since: 1.2.2
        """
        return _ids_peak_ipl_python_interface.GammaCorrector_Process(self, inputImage)

# Register GammaCorrector in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.GammaCorrector_swigregister(GammaCorrector)
class Histogram(object):
    r"""Stores the histogram values."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_Histogram

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Constructor.

        :type image: :py:class:`Image`, in
        :param image: Image to process.

        Notes: Will not work with packed pixel formats. See 'unpackPixelformat' for the correct handling of this.

        :raises: ImageFormatNotSupportedException image has a packed pixel format

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if image has a packed pixel format

        |

        *Overload 2:*
         Copy Constructor for a new Histogram instance

        Creates a new Histogram instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`Histogram`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.0 Deleted
        1.8 Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for Histogram instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`Histogram`, in
        :param other: The other instance to move.

        Since: 1.0
        """
        _ids_peak_ipl_python_interface.Histogram_swiginit(self, _ids_peak_ipl_python_interface.new_Histogram(*args))

    def PixelFormat(self) -> "PixelFormat":
        r"""
        Returns the pixel format of the histogram.

        :rtype: :py:class:`PixelFormat`
        :return: PixelFormat

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.Histogram_PixelFormat(self)

    def Channels(self) -> "Sequence[HistogramChannel]":
        r"""
        Returns a vector containing the bin list of each channel.

        :rtype: Sequence[HistogramChannel]
        :return: The channel array of the histogram

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.Histogram_Channels(self)

# Register Histogram in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.Histogram_swigregister(Histogram)
class HotpixelCorrection(object):
    r"""
    Algorithm for (adaptive) hotpixel detection and correction.

    This algorithm corrects hotpixels either manually by correcting a predefined list of pixels or adaptively by
    automatically updating the list of pixels to correct. In manual mode, pass a list of hotpixels to Correct(). The
    hotpixels can be obtained using Detect(), or from a different source, e.g. retrieved directly from the camera from an
    initial hotpixel calibration. In adaptive mode, just keep passing new images to CorrectAdaptive(). Hotpixels are then
    detected and corrected automatically.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    SensitivityLevel_Invalid = _ids_peak_ipl_python_interface.HotpixelCorrection_SensitivityLevel_Invalid
    SensitivityLevel_SensitivityLevel1 = _ids_peak_ipl_python_interface.HotpixelCorrection_SensitivityLevel_SensitivityLevel1
    SensitivityLevel_SensitivityLevel2 = _ids_peak_ipl_python_interface.HotpixelCorrection_SensitivityLevel_SensitivityLevel2
    SensitivityLevel_SensitivityLevel3 = _ids_peak_ipl_python_interface.HotpixelCorrection_SensitivityLevel_SensitivityLevel3
    r"""default"""
    SensitivityLevel_SensitivityLevel4 = _ids_peak_ipl_python_interface.HotpixelCorrection_SensitivityLevel_SensitivityLevel4
    SensitivityLevel_SensitivityLevel5 = _ids_peak_ipl_python_interface.HotpixelCorrection_SensitivityLevel_SensitivityLevel5
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_HotpixelCorrection

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new HotpixelCorrection instance

        Creates a new HotpixelCorrection instance.

        Since: 1.0

        |

        *Overload 2:*
         Copy Constructor for a new HotpixelCorrection instance

        Creates a new HotpixelCorrection instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`HotpixelCorrection`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.0 Deleted
        1.8 Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for HotpixelCorrection instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`HotpixelCorrection`, in
        :param other: The other instance to move.

        Since: 1.0
        """
        _ids_peak_ipl_python_interface.HotpixelCorrection_swiginit(self, _ids_peak_ipl_python_interface.new_HotpixelCorrection(*args))

    def SetSensitivity(self, *args) -> "None":
        r"""
        Sets the sensitivity of the hotpixel detection.

        :type sensitivityLevel: int, in, optional
        :param sensitivityLevel: The sensitivity level to set.

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.HotpixelCorrection_SetSensitivity(self, *args)

    def Sensitivity(self) -> "int":
        r"""
        Returns the current sensitivity.

        :rtype: int
        :return: SensitivityLevel

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.HotpixelCorrection_Sensitivity(self)

    def SetGainFactorPercent(self, gainFactorPercent: "int"=100) -> "None":
        r"""
        Sets the gain factor in percent.

        :type gainFactorPercent: int, in, optional
        :param gainFactorPercent: The gain factor in percent to set.

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.HotpixelCorrection_SetGainFactorPercent(self, gainFactorPercent)

    def GainFactorPercent(self) -> "int":
        r"""
        Returns the current gain factor in percent.

        :rtype: int
        :return: the Gain factor in percent

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.HotpixelCorrection_GainFactorPercent(self)

    def Detect(self, inputImage: "Image") -> "Sequence[Point2D]":
        r"""
        Detects hotpixels in the given image.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: The input image.

        :rtype: Sequence[Point2D]
        :return: List of detected hotpixels

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: OutOfRangeException inputImage is too small to process correctly
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if inputImage has a packed pixel format
        1.6 Will throw OutOfRangeException if inputImage is too small to be processed correctly
        """
        return _ids_peak_ipl_python_interface.HotpixelCorrection_Detect(self, inputImage)

    def Correct(self, inputImage: "Image", hotpixels: "VectorPoint2D") -> "Image":
        r"""
        Corrects the given hotpixels in the given image.

        Pass a list of hotpixels, either returned by Detect(), or from a different source (e.g. retrieved directly from
        the camera from an initial hotpixel calibration).

        :type inputImage: :py:class:`Image`, in
        :param inputImage: The input image.
        :type hotpixels: Sequence[Point2D]
        :param hotpixels:  The list of hotpixels to be corrected.

        Notes: Will not work with packed pixel formats. See 'unpackPixelformat' for the correct handling of this.

        :rtype: :py:class:`Image`
        :return: Corrected image

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: OutOfRangeException inputImage is too small to process correctly
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if inputImage has a packed pixel format
        1.6 Will throw OutOfRangeException if inputImage is too small to be processed correctly
        """
        return _ids_peak_ipl_python_interface.HotpixelCorrection_Correct(self, inputImage, hotpixels)

    def CorrectInPlace(self, inputImage: "Image", hotpixels: "VectorPoint2D") -> "Image":
        r"""
        Corrects the given hotpixels inplace in the given image.

        Pass a list of hotpixels, either returned by Detect(), or from a different source (e.g. retrieved directly from
        the camera from an initial hotpixel calibration). The image won't be copied and the hotpixel will be
        corrected within the given image.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: The input image.
        :type hotpixels: Sequence[Point2D]
        :param hotpixels:  The list of hotpixels to be corrected.

        Notes: Will not work with packed pixel formats. See 'unpackPixelformat' for the correct handling of this.

        :rtype: :py:class:`Image`
        :return: Corrected image

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: OutOfRangeException inputImage is too small to process correctly
        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _ids_peak_ipl_python_interface.HotpixelCorrection_CorrectInPlace(self, inputImage, hotpixels)

    def CorrectAdaptive(self, inputImage: "Image") -> "Image":
        r"""
        Corrects the given image adaptively.

        For each new passed to this method, first the list of hotpixels is adapted, then all pixels in the adapted
        hotpixel list are corrected.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: The input image.

        Notes: Will not work with packed pixel formats. See 'unpackPixelformat' for the correct handling of this.

        :rtype: :py:class:`Image`
        :return: Corrected image

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: OutOfRangeException inputImage is too small to process correctly
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if inputImage has a packed pixel format
        1.6 Will throw OutOfRangeException if inputImage is too small to be processed correctly
        """
        return _ids_peak_ipl_python_interface.HotpixelCorrection_CorrectAdaptive(self, inputImage)

    def CorrectAdaptiveInPlace(self, inputImage: "Image") -> "Image":
        r"""
        Corrects the given image inplace adaptively.

        For each new passed to this method, first the list of hotpixels is adapted, then all pixels in the adapted
        hotpixel list are corrected. The image won't be copied.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: The input image.

        Notes: Will not work with packed pixel formats. See 'unpackPixelformat' for the correct handling of this.

        :rtype: :py:class:`Image`
        :return: Corrected image

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: OutOfRangeException inputImage is too small to process correctly
        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _ids_peak_ipl_python_interface.HotpixelCorrection_CorrectAdaptiveInPlace(self, inputImage)

# Register HotpixelCorrection in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.HotpixelCorrection_swigregister(HotpixelCorrection)
class ImageConverter(object):
    r"""
    Converts images from one PixelFormat to another.

    Notes: In order to speed up processing, instances of this class maintain internal memory pools,
    which allows reuse of memory instead of allocating new memory on each conversion.

    The memory is freed when the instance is destroyed. There is one pool for every needed byte count, therefore, a new
    pool will be allocated if an image with a new size or format needs to be processed.

    One may select to create a new instance of this class when changing image settings in order to free old pools.
    If a new pool or buffer is needed, they will get allocated automatically during the conversion, which
    results in the first conversion taking more time.

    This can be prevented by using the function #PreAllocateConversion before the conversion.
    Buffers can be reused once a converted image gets freed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_ImageConverter

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new ImageConverter instance

        Creates a new ImageConverter instance.

        Since: 1.0

        |

        *Overload 2:*
         Copy Constructor for a new ImageConverter instance

        Creates a new ImageConverter instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`ImageConverter`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.0 Deleted
        1.8 Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for ImageConverter instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`ImageConverter`, in
        :param other: The other instance to move.

        Since: 1.0

        |

        *Overload 4:*

        Convenience constructor to directly pre-allocate an internal buffer pool.
        This calls [PreAllocateConversion]('PreAllocateConversion)' internally.

        :type inputPixelFormat: :py:class:`PixelFormat`, in
        :param inputPixelFormat: The pixelformat of the source image
        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat: The pixelformat of the converted image
        :type width: int, in
        :param width: Width of the source image
        :type height: int, in
        :param height: Height of the source image
        :type imageCount: int, in, optional
        :param imageCount: Maximum number of converted images held at one time

        :raises: Exception An internal error has occurred.

        Since: 1.4

        |

        *Overload 5:*

        Convenience constructor to directly pre-allocate an internal buffer pool.
        This calls [PreAllocateConversion]('PreAllocateConversion)' internally.

        :type inputPixelFormat: :py:class:`PixelFormat`, in
        :param inputPixelFormat: The pixelformat of the source image
        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat: The pixelformat of the converted image
        :type width: int, in
        :param width: Width of the source image
        :type height: int, in
        :param height: Height of the source image
        :param imageCount: Maximum number of converted images held at one time

        :raises: Exception An internal error has occurred.

        Since: 1.4
        """
        _ids_peak_ipl_python_interface.ImageConverter_swiginit(self, _ids_peak_ipl_python_interface.new_ImageConverter(*args))

    def PreAllocateConversion(self, inputPixelFormat: "PixelFormat", outputPixelFormat: "PixelFormat", width: "int", height: "int", imageCount: "int"=5) -> "None":
        r"""
        Pre-allocate buffer pools needed for the specified conversion.

        :type inputPixelFormat: :py:class:`PixelFormat`, in
        :param inputPixelFormat: The pixelformat of the source image
        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat: The pixelformat of the converted image
        :type width: int, in
        :param width: Width of the source image
        :type height: int, in
        :param height: Height of the source image
        :type imageCount: int, in, optional
        :param imageCount: Maximum number of converted images held at one time

        :raises: Exception An internal error has occurred.

        Since: 1.4
        """
        return _ids_peak_ipl_python_interface.ImageConverter_PreAllocateConversion(self, inputPixelFormat, outputPixelFormat, width, height, imageCount)

    def ConversionMode(self) -> "int":
        r"""
        Returns the current conversion mode.

        :rtype: int
        :return: The current conversion mode

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.ImageConverter_ConversionMode(self)

    def SetConversionMode(self, conversionMode: "int") -> "None":
        r"""
        Set conversion mode.

        :type conversionMode: int, in
        :param conversionMode: The conversion mode to set.

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.ImageConverter_SetConversionMode(self, conversionMode)

    def Convert(self, *args) -> "Image":
        r"""
        *Overload 1:*

        Converts the given ``inputImage`` to the specified ``outputPixelFormat``.

        :type inputImage: :py:class:`Image`, in
        :param inputImage:        The source image to be converted.
        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat: The desired pixel format for the output image.

        :rtype: :py:class:`Image`
        :return: A new Image containing the content of ``inputImage`` in the specified
                     ``outputPixelFormat``.

        :raises: Exception An internal error has occurred.

        Since: 1.0

        |

        *Overload 2:*
         Converts the given ``inputImage`` to the specified ``outputPixelFormat`` into an existing
                ``outputImageBuffer``.

        :type inputImage: :py:class:`Image`, in
        :param inputImage:            The source image to be converted.
        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat:     The desired pixel format for the output image.
        :type outputImageBuffer: int, in
        :param outputImageBuffer:     Pointer to the output buffer.
        :type outputImageBufferSize: int, in
        :param outputImageBufferSize: Size of the output buffer.

        :rtype: :py:class:`Image`
        :return: A Image object representing the converted image. The returned Image object encapsulates
                     the ``outputImageBuffer``. Note that the memory is not owned by the image object. Ensure the buffer is
                     not deleted until you have finished working with the image.

        :raises: BufferTooSmallException  The provided output buffer is too small for the output image.
        :raises: InvalidArgumentException The provided output buffer pointer is invalid.
        :raises: Exception                An internal error has occurred.

        Since: 1.1

        |

        *Overload 3:*

        Converts the given ``inputImage`` to the specified ``outputPixelFormat`` and scales the pixel values
               by the ``factor``.

        Notes: The ``outputPixelFormat`` must be a float pixel format.

        :type inputImage: :py:class:`Image`, in
        :param inputImage:        The source image to be converted.
        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat: The desired pixel format for the output image.
        :type factor: float, in
        :param factor:            Scale factor that is applied to each pixel value.
        :type offset: float, in, optional
        :param offset:            The offset to apply to all output pixels.

        :rtype: :py:class:`Image`
        :return: A new Image containing the content of ``inputImage`` in the specified
                     ``outputPixelFormat`` with pixel values scaled by ``factor`` (*m)* and ``offset`` (*c)* added
                     according to **y = m 路 x + c**.

        :raises: ImageFormatNotSupportedException The given input or output pixel format is not supported.
        :raises: Exception An internal error has occurred.

        Since: 1.15

        |

        *Overload 4:*

        Converts the given ``inputImage`` to the specified ``outputPixelFormat`` and scales the pixel values
               by the ``factor``.

        Notes: The ``outputPixelFormat`` must be a float pixel format.

        :type inputImage: :py:class:`Image`, in
        :param inputImage:        The source image to be converted.
        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat: The desired pixel format for the output image.
        :type factor: float, in
        :param factor:            Scale factor that is applied to each pixel value.
        :param offset:            The offset to apply to all output pixels.

        :rtype: :py:class:`Image`
        :return: A new Image containing the content of ``inputImage`` in the specified
                     ``outputPixelFormat`` with pixel values scaled by ``factor`` (*m)* and ``offset`` (*c)* added
                     according to **y = m 路 x + c**.

        :raises: ImageFormatNotSupportedException The given input or output pixel format is not supported.
        :raises: Exception An internal error has occurred.

        Since: 1.15

        |

        *Overload 5:*

        Converts the given ``inputImage`` to the specified ``outputPixelFormat`` into an existing
               ``outputImageBuffer`` and scales the pixel values by the ``factor``.

        :type inputImage: :py:class:`Image`, in
        :param inputImage:             The source image to be converted.
        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat:      The desired pixel format for the output image.
        :type outputImageBuffer: int, in
        :param outputImageBuffer:      Pointer to the output buffer.
        :type outputImageBufferSize: int, in
        :param outputImageBufferSize:  Size of the output buffer.
        :type factor: float, in
        :param factor:                 Scale factor that is applied to each pixel value.
        :type offset: float, in, optional
        :param offset:                 The offset to apply to all output pixels.

        :rtype: :py:class:`Image`
        :return: A Image object representing the converted image. The returned Image object encapsulates
                     the ``outputImageBuffer`` with pixel values scaled by ``factor`` (*m)* and ``offset`` (*c)* added
                     according to **y = m 路 x + c**. Note that the memory is not owned by the image object. Ensure the
                     buffer is not deleted until you have finished working with the image.

        :raises: ImageFormatNotSupportedException The given input or output pixel format is not supported.
        :raises: BufferTooSmallException The provided buffer is too small for the output image.
        :raises: InvalidArgumentException The given output buffer pointer is invalid.
        :raises: Exception An internal error has occurred.

        Since: 1.15

        |

        *Overload 6:*

        Converts the given ``inputImage`` to the specified ``outputPixelFormat`` into an existing
               ``outputImageBuffer`` and scales the pixel values by the ``factor``.

        :type inputImage: :py:class:`Image`, in
        :param inputImage:             The source image to be converted.
        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat:      The desired pixel format for the output image.
        :type outputImageBuffer: int, in
        :param outputImageBuffer:      Pointer to the output buffer.
        :type outputImageBufferSize: int, in
        :param outputImageBufferSize:  Size of the output buffer.
        :type factor: float, in
        :param factor:                 Scale factor that is applied to each pixel value.
        :param offset:                 The offset to apply to all output pixels.

        :rtype: :py:class:`Image`
        :return: A Image object representing the converted image. The returned Image object encapsulates
                     the ``outputImageBuffer`` with pixel values scaled by ``factor`` (*m)* and ``offset`` (*c)* added
                     according to **y = m 路 x + c**. Note that the memory is not owned by the image object. Ensure the
                     buffer is not deleted until you have finished working with the image.

        :raises: ImageFormatNotSupportedException The given input or output pixel format is not supported.
        :raises: BufferTooSmallException The provided buffer is too small for the output image.
        :raises: InvalidArgumentException The given output buffer pointer is invalid.
        :raises: Exception An internal error has occurred.

        Since: 1.15

        |

        *Overload 7:*

        Converts the given ``inputImage`` to the specified ``outputPixelFormat``. The pixel values are mapped from
               ``interval`` to the value range of the ``outputPixelFormat``. All pixel values outside the interval will be
               clamped.

        Notes: The pixel format of the ``inputImage`` must be a float pixel format.

        :type inputImage: :py:class:`Image`, in
        :param inputImage:        The source image to be converted.
        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat: The desired pixel format for the output image.
        :type interval: Interval< double >, in
        :param interval:          The interval of the input range.

        :rtype: :py:class:`Image`
        :return: A new Image containing the content of ``inputImage`` in the specified
                     ``outputPixelFormat`` with mapped pixel values.

        :raises: ImageFormatNotSupportedException The given input or output pixel format is not supported.
        :raises: Exception An internal error has occurred.

        Since: 1.15

        |

        *Overload 8:*

        Converts the given ``inputImage`` to the specified ``outputPixelFormat`` into an existing
               ``outputImageBuffer``. The pixel values are mapped from ``interval`` to the value range of the
               ``outputPixelFormat``. All pixel values outside the interval will be clamped.

        Notes: The pixel format of the ``inputImage`` must be a float pixel format.

        :type inputImage: :py:class:`Image`, in
        :param inputImage:             The source image to be converted.
        :type outputPixelFormat: :py:class:`PixelFormat`, in
        :param outputPixelFormat:      The desired pixel format for the output image.
        :type outputImageBuffer: int, in
        :param outputImageBuffer:      Pointer to the output buffer.
        :type outputImageBufferSize: int, in
        :param outputImageBufferSize:  Size of the output buffer.
        :type interval: Interval< double >, in
        :param interval:               The interval of the input range.

        :rtype: :py:class:`Image`
        :return: A Image object representing the converted image. The returned Image object encapsulates
                     the ``outputImageBuffer`` with mapped pixel values. Note that the memory is not owned by the
                     image object. Ensure the buffer is not deleted until you have finished working with the image.

        :raises: ImageFormatNotSupportedException The given input or output pixel format is not supported.
        :raises: BufferTooSmallException The provided buffer is too small for the output image.
        :raises: InvalidArgumentException The given output buffer pointer is invalid.
        :raises: Exception An internal error has occurred.

        Since: 1.15
        """
        return _ids_peak_ipl_python_interface.ImageConverter_Convert(self, *args)

    def SupportedOutputPixelFormatNames(self, inputPixelFormat: "PixelFormat") -> "Sequence[int]":
        r"""
        Returns the supported output pixel formats for a given input pixel format.

        :type inputPixelFormat: :py:class:`PixelFormat`, in
        :param inputPixelFormat: The input pixel format.

        :rtype: Sequence[int]
        :return: A vector of supported pixel formats for the given input pixel format

        :raises: Exception An internal error has occurred.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.ImageConverter_SupportedOutputPixelFormatNames(self, inputPixelFormat)

# Register ImageConverter in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.ImageConverter_swigregister(ImageConverter)
class ImageTransformer(object):
    r"""
    Performs transformations like mirror and rotate on images.

    Notes: To speed up processing instances of this class, maintain internal memory pools to reuse
    memory instead of allocating new memory for each transformation. The memory is freed when the
    instance is destroyed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    RotationAngle_Degree90Counterclockwise = _ids_peak_ipl_python_interface.ImageTransformer_RotationAngle_Degree90Counterclockwise
    RotationAngle_Degree90Clockwise = _ids_peak_ipl_python_interface.ImageTransformer_RotationAngle_Degree90Clockwise
    RotationAngle_Degree180 = _ids_peak_ipl_python_interface.ImageTransformer_RotationAngle_Degree180
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_ImageTransformer

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new ImageTransformer instance

        Creates a new ImageTransformer instance.

        Since: 1.0

        |

        *Overload 2:*
         Copy Constructor for a new ImageTransformer instance

        Creates a new ImageTransformer instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`ImageTransformer`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.0 Deleted
        1.8 Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for ImageTransformer instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`ImageTransformer`, in
        :param other: The other instance to move.

        Since: 1.0
        """
        _ids_peak_ipl_python_interface.ImageTransformer_swiginit(self, _ids_peak_ipl_python_interface.new_ImageTransformer(*args))

    def MirrorUpDown(self, inputImage: "Image") -> "Image":
        r"""
        Mirrors the input image in up-down direction.

        If the transformed image is a bayer-format image and the number of rows is even,
        the format will change. (e.g. BayerBG8 -> BayerGR8)

        :type inputImage: :py:class:`Image`, in
        :param inputImage:           The handle to the created image.

        :rtype: :py:class:`Image`
        :return: A new created image containing the data of the input image mirrored in up-down direction

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if inputImage has a packed pixel format
        """
        return _ids_peak_ipl_python_interface.ImageTransformer_MirrorUpDown(self, inputImage)

    def MirrorLeftRight(self, inputImage: "Image") -> "Image":
        r"""
        Mirrors the input image in the left-right direction.

        If the transformed image is a bayer-format image and the number of columns is even,
        the format will change. (e.g. BayerBG8 -> BayerGB8)

        :type inputImage: :py:class:`Image`, in
        :param inputImage:           The handle to the created image.

        :rtype: :py:class:`Image`
        :return: A new created image containing the data of the input image mirrored in the left-right direction

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if inputImage has a packed pixel format
        """
        return _ids_peak_ipl_python_interface.ImageTransformer_MirrorLeftRight(self, inputImage)

    def MirrorUpDownLeftRight(self, inputImage: "Image") -> "Image":
        r"""
        Mirrors the input image in up-down and left-right direction.

        If the transformed image is a bayer-format image and the number of rows or columns are even,
        the format will change. (e.g. BayerBG8 -> BayerRG8)

        :type inputImage: :py:class:`Image`, in
        :param inputImage:           The handle to the created image.

        :rtype: :py:class:`Image`
        :return: A new created image containing the data of the input image mirrored in up-down and left-right direction

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if inputImage has a packed pixel format
        """
        return _ids_peak_ipl_python_interface.ImageTransformer_MirrorUpDownLeftRight(self, inputImage)

    def MirrorUpDownInPlace(self, image: "Image") -> "None":
        r"""
        Mirrors the given image in up-down direction in place i.e. it will change the input image itself.

        If the transformed image is a bayer-format image and the number of rows is even,
        the format will change. (e.g. BayerBG8 -> BayerGR8)

        :type image: :py:class:`Image`, in/out
        :param image:           The handle to the image to mirror

        :raises: ImageFormatNotSupportedException image has a packed pixel format
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if image has packed a pixel format
        """
        return _ids_peak_ipl_python_interface.ImageTransformer_MirrorUpDownInPlace(self, image)

    def MirrorLeftRightInPlace(self, image: "Image") -> "None":
        r"""
        Mirrors the given image in the left-right direction in place i.e. it will change the input image itself.

        If the transformed image is a bayer-format image and the number of columns is even,
        the format will change. (e.g. BayerBG8 -> BayerGB8)

        :type image: :py:class:`Image`, in/out
        :param image:           The handle to the image to mirror

        :raises: ImageFormatNotSupportedException image has a packed pixel format
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if image has packed a pixel format
        """
        return _ids_peak_ipl_python_interface.ImageTransformer_MirrorLeftRightInPlace(self, image)

    def MirrorUpDownLeftRightInPlace(self, image: "Image") -> "None":
        r"""
        Mirrors the given image in up-down and left-right direction in place i.e. it will change the input
                image itself.

        If the transformed image is a bayer-format image and the number of rows or columns are even,
        the format will change. (e.g. BayerBG8 -> BayerRG8)

        :type image: :py:class:`Image`, in/out
        :param image:           The handle to the image to mirror

        :raises: ImageFormatNotSupportedException image has a packed pixel format
        :raises: Exception An internal error has occurred.

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if image has a packed pixel format
        """
        return _ids_peak_ipl_python_interface.ImageTransformer_MirrorUpDownLeftRightInPlace(self, image)

    def Rotate(self, inputImage: "Image", rotationAngle: "int") -> "Image":
        r"""
        Rotate the input image with the given rotationAngle

        If the transformed image is a bayer-format image and the number of rows or columns are even,
        the format will change. (e.g. BayerBG8 -> BayerRG8)

        :type inputImage: :py:class:`Image`, in
        :param inputImage:           The handle to the created image.

        :type rotationAngle: int, in
        :param rotationAngle:        The rotation angle.

        :rtype: :py:class:`Image`
        :return: A new created image containing the data of the input image rotated with the given rotationAngle

        :raises: ImageFormatNotSupportedException inputImage has a packed pixel format
        :raises: Exception An internal error has occurred.

        Since: 1.2
        """
        return _ids_peak_ipl_python_interface.ImageTransformer_Rotate(self, inputImage, rotationAngle)

    def RotateInPlace(self, image: "Image", rotationAngle: "int") -> "None":
        r"""
        Rotate the input image with the given rotationAngle

        If the transformed image is a bayer-format image and the number of rows or columns are even,
        the format will change. (e.g. BayerBG8 -> BayerRG8)

        :type image: :py:class:`Image`, in/out
        :param image:           The handle to the created image.

        :type rotationAngle: int, in
        :param rotationAngle:        The rotation angle.

        :raises: ImageFormatNotSupportedException image has a packed pixel format
        :raises: Exception An internal error has occurred.

        Since: 1.2
        """
        return _ids_peak_ipl_python_interface.ImageTransformer_RotateInPlace(self, image, rotationAngle)

# Register ImageTransformer in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.ImageTransformer_swigregister(ImageTransformer)
class ImageReader(object):
    r"""
    Reads an image from a file.

    Supported Formats are currently:
    JPEG, PNG and BMP
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def Read(*args) -> "Image":
        r"""
        *Overload 1:*

        Returns a new created image which is read from the file with the given file path.

        The format is specified by the file ending.

        :type filePath: str, in
        :param filePath: The path to the file to read as an UTF-8 encoded str.

        :raises: ImageFormatNotSupportedException An image format of this file isn't supported
        :raises: IOException                      Errors during file access e.g. no permissions on this file
        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.0
        1.6 Defined character encoding UTF-8

        |

        *Overload 2:*

        Returns a new created image which is read from the file with the given file path.

        The Pixel format to use is specified manually here. The function tries to interpret the file with the given
        format. If this isn't possible, an exception is thrown. Explicit conversion of image formats must be done
        manually.

        :type filePath: str, in
        :param filePath:    The path to the file to read as an UTF-8 encoded str.
        :type pixelFormat: :py:class:`PixelFormat`, in
        :param pixelFormat: The Pixel format the retrieved image should have afterwards.

        :raises: ImageFormatInterpretationException Can't interpret this file with the given pixel format
        :raises: ImageFormatNotSupportedException   An image format of this file isn't supported
        :raises: IOException                        Errors during file access e.g. no permissions on this file
        :raises: InvalidArgumentException           Arguments passed are invalid
        :raises: Exception                          An internal error has occurred

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if pixelFormat is a packed pixel format
        1.6 Defined character encoding UTF-8
        """
        return _ids_peak_ipl_python_interface.ImageReader_Read(*args)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_ImageReader

# Register ImageReader in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.ImageReader_swigregister(ImageReader)
class ImageWriter(object):
    r"""
    Writes an image to a file.

    Supported Formats are currently:
    JPEG, PNG and BMP and a simple RAW format
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def WriteAsBMP(filePath: "str", imageToSave: "Image") -> "None":
        r"""
        Writes the specified image to the filesystem as BMP image.

        Not all image formats can be written to a BMP file.
        Currently supported for:
        Mono8, Mono10, Mono12, RGB8, BGR8, RGBa8, BGRa8
        Written as Mono:
        BayerGR8, BayerRG8, BayerGB8, BayerBG8, BayerGR10, BayerRG10, BayerGB10, BayerBG10, BayerGR12, BayerRG12,
        BayerGB12, BayerBG12
        For all other formats an exception is thrown.

        :type filePath: str, in
        :param filePath:    The path of the file to store the image to as an UTF-8 encoded str.
        :type imageToSave: :py:class:`Image`, in
        :param imageToSave: The image to save.

        :raises: ImageFormatNotSupportedException A file type isn't supported for this image pixel format
        :raises: IOException                      Errors during file access e.g. no permissions on this file
        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if imageToSave has a packed pixel format
        1.6 Defined character encoding UTF-8
        """
        return _ids_peak_ipl_python_interface.ImageWriter_WriteAsBMP(filePath, imageToSave)

    @staticmethod
    def WriteAsRAW(filePath: "str", imageToSave: "Image") -> "None":
        r"""
        Writes the specified image to the filesystem as a raw binary image.

        This is supported for all non-packed pixel formats.

        :type filePath: str, in
        :param filePath:    The path of the file to store the image to as an UTF-8 encoded str.
        :type imageToSave: :py:class:`Image`, in
        :param imageToSave: The image to save.

        :raises: ImageFormatNotSupportedException A file type isn't supported for this image pixel format
        :raises: IOException                      Errors during file access e.g. no permissions on this file
        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if imageToSave has a packed pixel format
        1.6 Defined character encoding UTF-8
        """
        return _ids_peak_ipl_python_interface.ImageWriter_WriteAsRAW(filePath, imageToSave)

    @staticmethod
    def Write(filePath: "str", imageToSave: "Image") -> "None":
        r"""
         Writes the specified image to the filesystem. The type is specified by the given file ending in file
                name.

        :type filePath: str, in
        :param filePath:    The path of the file to store the image to as an UTF-8 encoded str.
        :type imageToSave: :py:class:`Image`, in
        :param imageToSave: The image to save.

        :raises: ImageFormatNotSupportedException A file type is not supported for this image pixel format
        :raises: IOException                      Errors during file access e.g. no permissions on this file
        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.0
        1.6 Defined character encoding UTF-8
        """
        return _ids_peak_ipl_python_interface.ImageWriter_Write(filePath, imageToSave)

    @staticmethod
    def WriteAsPNG(*args) -> "None":
        r"""
        Writes the specified image to the filesystem as PNG image

        Not all image formats can be written to a PNG file.
        Currently supported for:
        Mono8, Mono10, Mono12, RGB8, RGB10, RGB12, RGBa8, RGBa10, RGBa12
        Written as Mono:
        BayerGR8, BayerRG8, BayerGB8, BayerBG8, BayerGR10, BayerRG10, BayerGB10, BayerBG10, BayerGR12, BayerRG12,
        BayerGB12, BayerBG12
        Written as RGB:
        BGR8, BGR10, BGR12, BGRa8, BGRa10, RGBa12
        For all other formats an exception is thrown.

        :type filePath: str, in
        :param filePath:    The path of the file to store the image to as an UTF-8 encoded str.
        :type imageToSave: :py:class:`Image`, in
        :param imageToSave: The image to save.
        :type parameter: :py:class:`ImageWriterPNGParameter`, in, optional
        :param parameter:   The parameter for the PNG image e.g. compression.

        :raises: ImageFormatNotSupportedException A file type isn't supported for this image pixel format
        :raises: IOException                      Errors during file access e.g. no permissions on this file
        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.0
        1.6 Defined character encoding UTF-8
        """
        return _ids_peak_ipl_python_interface.ImageWriter_WriteAsPNG(*args)

    @staticmethod
    def WriteAsJPG(*args) -> "None":
        r"""
        Writes the specified image to the filesystem as JPEG image

        Not all image formats can be written to a JPEG file.
        Currently supported for:
        Mono8, RGB8, BGR8, RGBa8, BGRa8
        Written as Mono: BayerGR8, BayerRG8, BayerGB8, BayerBG8
        For all other formats an exception is thrown.

        :type filePath: str, in
        :param filePath:    The path of the file to store the image to as an UTF-8 encoded str.
        :type imageToSave: :py:class:`Image`, in
        :param imageToSave: The image to save.
        :type parameter: :py:class:`ImageWriterJPEGParameter`, in, optional
        :param parameter:   The parameter for the JPEG image e.g. compression.

        :raises: ImageFormatNotSupportedException A file type isn't supported for this image pixel format
        :raises: IOException                      Errors during file access e.g. no permissions on this file
        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.0
        1.6 Defined character encoding UTF-8
        """
        return _ids_peak_ipl_python_interface.ImageWriter_WriteAsJPG(*args)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_ImageWriter

# Register ImageWriter in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.ImageWriter_swigregister(ImageWriter)
class IEncoder(object):
    r"""Encoder Interface Class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_IEncoder

    def Id(self) -> "int":
        return _ids_peak_ipl_python_interface.IEncoder_Id(self)

    def SetOption(self, option: "int", value: "Any", count: "int") -> "None":
        r"""
        Sets an option on the encoder.
        :type option: int, in
        :param option: The encoder option to set.
        :type value: void, in
        :param value:  The value for the encoder option.
        :type count: int, in
        :param count:  The size of the value.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _ids_peak_ipl_python_interface.IEncoder_SetOption(self, option, value, count)

    def GetOption(self, option: "int", value: "Any", count: "int", outCount: "bytes") -> "None":
        r"""
        Gets an option of the encoder.
        :type option: int, in
        :param option:   The encoder option to get.
        :type value: void, out
        :param value:    The value for the encoder option.
        :type count: int, in
        :param count:    The size of the value.
        :type outCount: int, out
        :param outCount: The resulting size of the value.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _ids_peak_ipl_python_interface.IEncoder_GetOption(self, option, value, count, outCount)

    def OptionRange(self, option: "int", min: "Any", max: "Any", inc: "Any") -> "None":
        r"""
        Receive the range for an option of the encoder.
        :type option: int, in
        :param option: The encoder option to receive the range from.
        :type min: void, out
        :param min:    The minimum value for the encoder option.
        :type max: void, out
        :param max:    The maximum value for the encoder option.
        :type inc: void, out
        :param inc:    The increment value for the encoder option.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _ids_peak_ipl_python_interface.IEncoder_OptionRange(self, option, min, max, inc)

# Register IEncoder in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.IEncoder_swigregister(IEncoder)
class MJPEGEncoder(IEncoder):
    r"""
    JPEG encoder specialization of 'IEncoder'.
    Create the encoder with the according Create function.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "MJPEGEncoder"):
        _ids_peak_ipl_python_interface.MJPEGEncoder_swiginit(self, _ids_peak_ipl_python_interface.new_MJPEGEncoder(arg2))

    def Id(self) -> "int":
        r"""
        Get the current type of the encoder.
        :rtype: int
        :return: Encoder type
        """
        return _ids_peak_ipl_python_interface.MJPEGEncoder_Id(self)

    def SetQuality(self, quality: "int") -> "None":
        r"""
        Sets the quality for the jpeg encoder.
        :type quality: int, in
        :param quality: Quality to set.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _ids_peak_ipl_python_interface.MJPEGEncoder_SetQuality(self, quality)

    def GetQuality(self) -> "int":
        r"""
        Gets the quality for the jpeg encoder.

        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _ids_peak_ipl_python_interface.MJPEGEncoder_GetQuality(self)

    def QualityRange(self) -> "Any":
        r"""
        Gets the quality range for the jpeg encoder.

        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _ids_peak_ipl_python_interface.MJPEGEncoder_QualityRange(self)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_MJPEGEncoder

# Register MJPEGEncoder in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.MJPEGEncoder_swigregister(MJPEGEncoder)

def GetSupportedEncodersForAContainer(container: "int") -> "Sequence[int]":
    r"""
    Get the supported encoders
    :rtype: Sequence[int]
    :return: List of supported encoders

    :raises: Exception                        An internal error has occurred

    Since: 1.5
    """
    return _ids_peak_ipl_python_interface.GetSupportedEncodersForAContainer(container)

def GetSupportedPixelFormats(encoder: "int") -> "Sequence[PixelFormatName]":
    r"""
    Get the supported pixel formats for an encoder.
    :rtype: Sequence[PixelFormatName]
    :return: List of supported pixel formats

    :raises: Exception                        An internal error has occurred

    Since: 1.5
    """
    return _ids_peak_ipl_python_interface.GetSupportedPixelFormats(encoder)
class IContainer(object):
    r"""Container Interface Class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_IContainer

    def Id(self) -> "int":
        return _ids_peak_ipl_python_interface.IContainer_Id(self)

    def SetOption(self, option: "int", value: "Any", count: "int") -> "None":
        r"""
        Sets an option on the container.
        :type option: int, in
        :param option: The container option to set.
        :type value: void, in
        :param value:  The value for the container option.
        :type count: int, in
        :param count:  The size of the value.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _ids_peak_ipl_python_interface.IContainer_SetOption(self, option, value, count)

    def GetOption(self, option: "int", value: "Any", count: "int", outCount: "bytes") -> "None":
        r"""
        Gets an option of the container.
        :type option: int, in
        :param option:   The container option to get.
        :type value: void, out
        :param value:    The value for the container option.
        :type count: int, in
        :param count:    The size of the value.
        :type outCount: int, out
        :param outCount: The resulting size of the value.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _ids_peak_ipl_python_interface.IContainer_GetOption(self, option, value, count, outCount)

    def OptionRange(self, option: "int", min: "Any", max: "Any", inc: "Any") -> "None":
        r"""
        Receive the range for an option of the container.

        :type option: int, in
        :param option: The container option to receive the range from.
        :type min: void, out
        :param min:    The minimum value for the container option.
        :type max: void, out
        :param max:    The maximum value for the container option.
        :type inc: void, out
        :param inc:    The increment value for the container option.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _ids_peak_ipl_python_interface.IContainer_OptionRange(self, option, min, max, inc)

# Register IContainer in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.IContainer_swigregister(IContainer)
class AVIContainer(IContainer):
    r"""
    AVI container specialization of 'IContainer'.
    Create the container with the according Create function.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, arg2: "AVIContainer"):
        _ids_peak_ipl_python_interface.AVIContainer_swiginit(self, _ids_peak_ipl_python_interface.new_AVIContainer(arg2))

    def Id(self) -> "int":
        r"""
        Get the current type of the container.
        :rtype: int
        :return: Container type
        """
        return _ids_peak_ipl_python_interface.AVIContainer_Id(self)

    def SetFramerate(self, fps: "float") -> "None":
        r"""
        Set the frame rate for the opened video.
        :type fps: float, in
        :param fps: The frame rate to set.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _ids_peak_ipl_python_interface.AVIContainer_SetFramerate(self, fps)

    def GetFramerate(self) -> "float":
        r"""
        Get the frame rate for the opened video.

        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _ids_peak_ipl_python_interface.AVIContainer_GetFramerate(self)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_AVIContainer

# Register AVIContainer in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.AVIContainer_swigregister(AVIContainer)

def GetSupportedContainersForAnEncoder(encoder: "int") -> "Sequence[int]":
    r"""
    Get the supported containers.
    :rtype: Sequence[int]
    :return: List of the supported containers.
    """
    return _ids_peak_ipl_python_interface.GetSupportedContainersForAnEncoder(encoder)
class VideoWriter(object):
    r"""Writes images to a file in the form of a video."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_VideoWriter

    def __init__(self, *args):
        _ids_peak_ipl_python_interface.VideoWriter_swiginit(self, _ids_peak_ipl_python_interface.new_VideoWriter(*args))

    def Open(self, *args) -> "None":
        r"""
        *Overload 1:*

        Open the VideoWriter and sets up a container and an encoder. The file is created upon receiving the first
        image with 'Append'.

        :type fileName: str, in
        :param fileName: The filename of the video as an utf-8 encoded str (u8str)
        :type container: :py:class:`IContainer`, in
        :param container: The container of the video.
        :type encoder: :py:class:`IEncoder`, in
        :param encoder: The encoder of the video.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5

        |

        *Overload 2:*

        Open the VideoWriter with AVI container and mjpeg encoder.
        The file is created upon receiving the first image with 'Append'.
        :type fileName: str, in
        :param fileName: The filename of the video as an utf-8 encoded str (u8str)

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _ids_peak_ipl_python_interface.VideoWriter_Open(self, *args)

    def IsOpen(self) -> "bool":
        r"""
        Check if the VideoWriter is already open.
        :rtype: boolean
        :return: Boolean if the VideoWriter is already open.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _ids_peak_ipl_python_interface.VideoWriter_IsOpen(self)

    def Close(self) -> "None":
        r"""
        Close the opened VideoWriter.

        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _ids_peak_ipl_python_interface.VideoWriter_Close(self)

    def Append(self, image: "Image") -> "None":
        r"""
        Append an image to the opened video.
        Remarks: Note that the image dimensions must be divisible by 8 (May be lifted by a later version)
        :type image: :py:class:`Image`, in
        :param image: The image to append.

        :raises: InvalidArgumentException         Arguments passed are invalid
        :raises: ImageFormatNotSupportedException image has unsupported pixel format.
        :raises: BusyException                    The internal queue is full. The image won't be added to the video
                                                     stream.
        :raises: Exception                        An internal error has occurred

        Since: 1.5
        """
        return _ids_peak_ipl_python_interface.VideoWriter_Append(self, image)

    def __lshift__(self, image: "Image") -> "VideoWriter":

        return _ids_peak_ipl_python_interface.VideoWriter___lshift__(self, image)

    def Encoder(self) -> "IEncoder":
        r"""
        Get the used encoder.
        :rtype: :py:class:`IEncoder`
        :return: Instance of the encoder.
        """
        return _ids_peak_ipl_python_interface.VideoWriter_Encoder(self)

    def Container(self) -> "IContainer":
        r"""
        Get the used container.
        :rtype: :py:class:`IContainer`
        :return: Instance of the container.
        """
        return _ids_peak_ipl_python_interface.VideoWriter_Container(self)

    def NumFramesEncoded(self) -> "int":
        r"""
        Get the encoded frames in the video stream.
        :rtype: int
        :return: Number of encoded frames in the video stream.
        """
        return _ids_peak_ipl_python_interface.VideoWriter_NumFramesEncoded(self)

    def NumFramesDropped(self) -> "int":
        r"""
        Get the dropped frames in the video stream.
        :rtype: int
        :return: Number of dropped frames in the video stream.
        """
        return _ids_peak_ipl_python_interface.VideoWriter_NumFramesDropped(self)

    def FileSize(self) -> "int":
        r"""
        Get the file size of the video in bytes.
        :rtype: int
        :return: File size of the video.
        """
        return _ids_peak_ipl_python_interface.VideoWriter_FileSize(self)

    def ResetFrameCounters(self) -> "None":
        r"""Reset compressed and dropped frame counters."""
        return _ids_peak_ipl_python_interface.VideoWriter_ResetFrameCounters(self)

    def SetQueueSize(self, queueSize: "int") -> "None":
        r"""
        Set the internal queue size of the video writer
        :type queueSize: int
        :param queueSize: internal queue size to set. See 'QueueSizeRange()' for a range of valid values
        """
        return _ids_peak_ipl_python_interface.VideoWriter_SetQueueSize(self, queueSize)

    def QueueSize(self) -> "int":
        r"""
        Get the internal queue size of the video writer
        :rtype: int
        :return: the internal queue size
        """
        return _ids_peak_ipl_python_interface.VideoWriter_QueueSize(self)

    def QueueSizeRange(self) -> "RangeInt32":
        r"""
        Get the range of the queue size
        :rtype: Range< int >
        :return: Range<int> with valid values
        """
        return _ids_peak_ipl_python_interface.VideoWriter_QueueSizeRange(self)

    def NumBuffersQueued(self) -> "int":
        r"""
        Get the count of the currently queued buffers, which are waiting to be processed
        :rtype: int
        :return: the count of the queued buffers
        """
        return _ids_peak_ipl_python_interface.VideoWriter_NumBuffersQueued(self)

    def WaitUntilFrameDone(self, timeout_ms: "int") -> "None":
        r"""
        Wait until frame processing is done.
        :type timeout_ms: int
        :param timeout_ms: The timeout in milliseconds.
        """
        return _ids_peak_ipl_python_interface.VideoWriter_WaitUntilFrameDone(self, timeout_ms)

    def WaitUntilQueueEmpty(self, timeout_ms: "int") -> "None":
        r"""
        Wait until the queue is empty.
        :type timeout_ms: int
        :param timeout_ms: The timeout in milliseconds.
        """
        return _ids_peak_ipl_python_interface.VideoWriter_WaitUntilQueueEmpty(self, timeout_ms)

# Register VideoWriter in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.VideoWriter_swigregister(VideoWriter)
class PixelFormat(object):
    r"""Represents a pixel format and its specific properties."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_PixelFormat

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new PixelFormat instance

        Creates a new PixelFormat instance. The PixelFormatName is initialized to #Invalid.

        Since: 1.0

        |

        *Overload 2:*
         Constructor for a new PixelFormat instance

        Creates a new PixelFormat instance. The PixelFormatName is initialized to ``name``.

        :type name: int, in
        :param name: Used Pixel Format Name.

        Since: 1.0

        |

        *Overload 3:*
         Move constructor for PixelFormat instance

        Moves the PixelFormatName from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`PixelFormat`, in
        :param other: The other instance to move the PixelFormatName from.

        Since: 1.0
        """
        _ids_peak_ipl_python_interface.PixelFormat_swiginit(self, _ids_peak_ipl_python_interface.new_PixelFormat(*args))

    def Name(self) -> "str":
        r"""
        Returns the name of the pixel format as String.

        :rtype: str
        :return: Name

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.PixelFormat_Name(self)

    def PixelFormatName(self) -> "int":
        r"""
        Returns the name of the pixel format as enum value.

        :rtype: int
        :return: PixelFormatName

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.PixelFormat_PixelFormatName(self)

    def __eq__(self, other: "PixelFormat") -> "bool":
        r"""
         Compare PixelFormat

        Compares the PixelFormatName from ``other`` to this instance

        :type other: :py:class:`PixelFormat`, in
        :param other: The other instance to compare.

        :rtype: boolean
        :return: True if equal, false otherwise.

        Since: 1.0
        """
        return _ids_peak_ipl_python_interface.PixelFormat___eq__(self, other)

    def NumSignificantBitsPerChannel(self) -> "int":
        r"""
         Returns the number of significant bits per pixel per channel of the given pixel format.

        :rtype: int
        :return: Number of significant bits per pixel per channel.

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelFormat_NumSignificantBitsPerChannel(self)

    def NumStorageBitsPerChannel(self) -> "int":
        r"""
         Returns the number of storage bits per pixel per channel of the given pixel format.

        :rtype: int
        :return: Number of storage bits per pixel per channel.

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelFormat_NumStorageBitsPerChannel(self)

    def NumChannels(self) -> "int":
        r"""
         Returns the number of channels the given pixel format has.

        :rtype: int
        :return: Number of channels for pixel format.

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelFormat_NumChannels(self)

    def MaximumValuePerChannel(self) -> "int":
        r"""
        Returns the maximum value of one pixel channel the given pixel format has.

        Notes: Returns 0 if the underlying pixel format has floating point values.

        :rtype: int
        :return: Maximum value of one pixel channel.

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelFormat_MaximumValuePerChannel(self)

    def NumSignificantBitsPerPixel(self) -> "int":
        r"""
        Returns the number of significant bits per pixel the given pixel format has.

        :rtype: int
        :return: Number of significant bits used.

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelFormat_NumSignificantBitsPerPixel(self)

    def NumStorageBitsPerPixel(self) -> "int":
        r"""
        Returns the number of storage bits per pixel the given pixel format has.

        For unpacked formats, this is normally a multiple of 8.
        For packed formats, this is normally the same as #NumSignificantBitsPerPixel.

        :rtype: int
        :return: Number of storage bits used.

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelFormat_NumStorageBitsPerPixel(self)

    def Endianness(self) -> "int":
        r"""
         Returns the endianness of the given pixel format.

        :rtype: int
        :return: The endianness of the pixel format.

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelFormat_Endianness(self)

    def CalculateStorageSizeOfPixels(self, numPixels: "int") -> "int":
        r"""
         Returns the storage size the given number pixels of the given pixel format in bytes.

        For example, the calculation of the required buffer size, supply width multiplied by height here.

        :type numPixels: int, in
        :param numPixels:   The number of pixels.

        :rtype: int
        :return: The calculated storage size for the number of pixels.

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelFormat_CalculateStorageSizeOfPixels(self, numPixels)

    def IsPacked(self) -> "bool":
        r"""
         Returns whether the pixel format is packed.

        :rtype: boolean
        :return: Whether the pixel format is packed. True for packed, false for unpacked.

        Since: 1.7

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelFormat_IsPacked(self)

    def IsBayered(self) -> "bool":
        r"""
         Returns whether the pixel format is a bayer format.

        :rtype: boolean
        :return: Whether the pixel format is a bayer format. True for Bayer, false for all else.

        Since: 1.7

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelFormat_IsBayered(self)

    def IsYUV(self) -> "bool":
        r"""
         Returns whether the pixel format is a yuv format.

        :rtype: boolean
        :return: Whether the pixel format is a yuv format. True for yuv, false for all else.

        Since: 1.9

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelFormat_IsYUV(self)

    def IsCoord3D(self) -> "bool":
        r"""
         Returns whether the pixel format is a 3D coordinate format.

        :rtype: boolean
        :return: Whether the pixel format is a 3D coordinate format.

        Since: 1.10

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelFormat_IsCoord3D(self)

    def IsFloat(self) -> "bool":
        r"""
         Returns whether the pixel format is a float format.

        :rtype: boolean
        :return: Whether the pixel format is a float format.

        Since: 1.12

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelFormat_IsFloat(self)

    def BayerPattern(self) -> "int":
        r"""
         Queries the bayer pattern of the given pixel format.

        :rtype: int
        :return: The bayer pattern if the format is a bayer format. Or #None if the format has no Bayer pattern.

        Since: 1.8

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelFormat_BayerPattern(self)

# Register PixelFormat in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.PixelFormat_swigregister(PixelFormat)
class PixelLine(object):
    r"""Represents the values of a horizontal or vertical line of pixels in an image."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_PixelLine

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor.

        :type image: :py:class:`Image`, in
        :param image: The image to process.
        :type orientation: int, in
        :param orientation: The orientation of the pixel line.
        :type offset: int, in
        :param offset: Y offset if orientation = Horizontal; X offset if orientation = Vertical

        :raises: ImageFormatNotSupportedException image has a packed pixel format

        Since: 1.0
        1.2 Will throw ImageFormatNotSupportedException if image has a packed pixel format

        |

        *Overload 2:*
         Copy Constructor for a new PixelLine instance

        Creates a new PixelLine instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`PixelLine`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.0 Deleted
        1.8 Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for PixelLine instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`PixelLine`, in
        :param other: The other instance to move.

        Since: 1.0
        """
        _ids_peak_ipl_python_interface.PixelLine_swiginit(self, _ids_peak_ipl_python_interface.new_PixelLine(*args))

    def PixelFormatName(self) -> "int":
        r"""
         Returns the pixel format of the given pixel line.

        :rtype: int
        :return: PixelFormatName

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelLine_PixelFormatName(self)

    def Orientation(self) -> "int":
        r"""
         Returns the orientation of the given pixel line.

        :rtype: int
        :return: Orientation

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelLine_Orientation(self)

    def Offset(self) -> "int":
        r"""
         Returns the offset of the given pixel line.
        (Vertical: Left - Horizontal: Top).

        :rtype: int
        :return: Offset

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelLine_Offset(self)

    def Channels(self) -> "Sequence[PixelLineChannel]":
        r"""
         Returns the number of the given pixel line's channels.

        :rtype: Sequence[PixelLineChannel]
        :return: Channels

        Since: 1.0

        :raises: Exception An internal error has occurred.
        """
        return _ids_peak_ipl_python_interface.PixelLine_Channels(self)

# Register PixelLine in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.PixelLine_swigregister(PixelLine)
class PixelRow(PixelLine):
    r"""Represents the values for a horizontal line of pixels in an image."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_PixelRow

    def __init__(self, *args):
        _ids_peak_ipl_python_interface.PixelRow_swiginit(self, _ids_peak_ipl_python_interface.new_PixelRow(*args))

# Register PixelRow in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.PixelRow_swigregister(PixelRow)
class PixelColumn(PixelLine):
    r"""Represents the values for a vertical line of pixels in an image."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_PixelColumn

    def __init__(self, *args):
        _ids_peak_ipl_python_interface.PixelColumn_swiginit(self, _ids_peak_ipl_python_interface.new_PixelColumn(*args))

# Register PixelColumn in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.PixelColumn_swigregister(PixelColumn)
class Sharpness(object):
    r"""
    Configure and measure the sharpness of a given image.

    The class allows the measurement of the sharpness in a defined ROI of the given image. To get a sharpness value, the
    edges in the image are evaluated. The sharpness can only be indicated as a relative value, as it depends on the edges
    in the current image. An image with fewer edges won't reach the sharpness value of an image with a lot of edges.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_Sharpness

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new Sharpness instance

        Creates a new Sharpness instance.

        Since: 1.6

        |

        *Overload 2:*
         Copy Constructor for a new Sharpness instance

        Creates a new Sharpness instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`Sharpness`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.6 Deleted
        1.8 Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for Sharpness instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`Sharpness`, in
        :param other: The other instance to move.

        Since: 1.6
        """
        _ids_peak_ipl_python_interface.Sharpness_swiginit(self, _ids_peak_ipl_python_interface.new_Sharpness(*args))
    SharpnessAlgorithm_Tenengrad = _ids_peak_ipl_python_interface.Sharpness_SharpnessAlgorithm_Tenengrad
    r"""contrast-based sharpness algorithm (convolution)"""
    SharpnessAlgorithm_MeanScore = _ids_peak_ipl_python_interface.Sharpness_SharpnessAlgorithm_MeanScore
    r"""contrast-based sharpness algorithm (mean value)"""
    SharpnessAlgorithm_HistogramVariance = _ids_peak_ipl_python_interface.Sharpness_SharpnessAlgorithm_HistogramVariance
    r"""statistics-based sharpness algorithm"""
    SharpnessAlgorithm_Sobel = _ids_peak_ipl_python_interface.Sharpness_SharpnessAlgorithm_Sobel
    r"""contrast-based sharpness algorithm (convolution)"""
    SharpnessROIWeight_Weak = _ids_peak_ipl_python_interface.Sharpness_SharpnessROIWeight_Weak
    r"""Weak use of roi for the measurement"""
    SharpnessROIWeight_Medium = _ids_peak_ipl_python_interface.Sharpness_SharpnessROIWeight_Medium
    r"""Normal use of roi for the measurement"""
    SharpnessROIWeight_Strong = _ids_peak_ipl_python_interface.Sharpness_SharpnessROIWeight_Strong
    r"""Strong use of roi for the measurement"""

    def Measure(self, image: "Image") -> "float":
        r"""
        Measures the sharpness of the given image. The higher the value, the better the sharpness.

        :type image: :py:class:`Image`, in
        :param image: The image to measure the relative sharpness.

        Notes: Will not work with packed pixel formats. See 'unpackPixelformat' for the correct handling of this.

        :rtype: float
        :return: Relative sharpness value

        :raises: InvalidPixelFormat pixel format isn't supported.

        Since: 1.6
        """
        return _ids_peak_ipl_python_interface.Sharpness_Measure(self, image)

    def IsPixelFormatSupported(self, pixelFormatName: "int") -> "bool":
        r"""
        Checks if the given pixel format can be used for sharpness measurement.

        :rtype: boolean
        :return: Flag whether the given pixel format is supported.
        :type pixelFormatName: int, in
        :param pixelFormatName: The pixelFormat of the input image.

        Since: 1.6
        """
        return _ids_peak_ipl_python_interface.Sharpness_IsPixelFormatSupported(self, pixelFormatName)

    def SupportedPixelFormats(self) -> "Sequence[PixelFormatName]":
        r"""
        Returns a list of supported pixel formats which can be used for sharpness measurement.
        :rtype: Sequence[PixelFormatName]
        :return: List of supported pixel formats.

        Since: 1.6
        """
        return _ids_peak_ipl_python_interface.Sharpness_SupportedPixelFormats(self)

    def SetAlgorithm(self, algorithm: "int") -> "None":
        r"""
        Sets the algorithm used for measurement calculation.

        Since: 1.6
        """
        return _ids_peak_ipl_python_interface.Sharpness_SetAlgorithm(self, algorithm)

    def Algorithm(self) -> "int":
        r"""
        Returns the used algorithm for the sharpness measurement.
        :rtype: int
        :return: Current algorithm

        Since: 1.6
        """
        return _ids_peak_ipl_python_interface.Sharpness_Algorithm(self)

    def ROIMinSize(self) -> "Size2D":
        r"""
        Gets the minimum size of a ROI, in which the sharpness is measured.
        :rtype: :py:class:`Size2D`
        :return: Required minimum size of a roi

        Since: 1.6
        """
        return _ids_peak_ipl_python_interface.Sharpness_ROIMinSize(self)

    def SetROI(self, *args) -> "None":
        r"""
        *Overload 1:*

        Set ROI in which the sharpness is measured.
        :type roi: SharpnessROI, in
        :param roi: SharpnessROI to set.

        Since: 1.6

        |

        *Overload 2:*

        Set ROI in which the sharpness is measured.
        :type roi: :py:class:`Rect2D`, in
        :param roi: Rect2D to set.

        Since: 1.6

        |

        *Overload 3:*

        Set ROI in which the sharpness is measured.
        :param roi: SharpnessROI to set.

        Since: 1.6
        """
        return _ids_peak_ipl_python_interface.Sharpness_SetROI(self, *args)

    def SetROIs(self, srois: "SharpnessROIList") -> "None":
        r"""
        Sets the region of interests in which the sharpness is measured.
        :param rois: SharpnessROIList to set.

        Since: 1.6
        """
        return _ids_peak_ipl_python_interface.Sharpness_SetROIs(self, srois)

    def GetROIs(self) -> "Sequence[SharpnessROI]":
        r"""
        Gets ROIs in which the sharpness is measured.
        :rtype: Sequence[SharpnessROI]
        :return: Active measurement rois

        Since: 1.6
        """
        return _ids_peak_ipl_python_interface.Sharpness_GetROIs(self)

# Register Sharpness in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.Sharpness_swigregister(Sharpness)

def __eq__(*args) -> "bool":
    r"""
    *Overload 1:*

    Compare two Size2D for equality

    |

    *Overload 2:*

    Compare two Point2D for equality
    """
    return _ids_peak_ipl_python_interface.__eq__(*args)

def __ne__(*args) -> "bool":
    r"""
    *Overload 1:*

    Compare two Size2D for inequality

    |

    *Overload 2:*

    Compare two Point2D for inequality
    """
    return _ids_peak_ipl_python_interface.__ne__(*args)
class Gain(object):
    r"""Applies gain to the data."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_Gain

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new Gain instance

        Creates a new Gain instance.

        Since: 1.2.2

        |

        *Overload 2:*
         Copy Constructor for a new Gain instance

        Creates a new Gain instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`Gain`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.2.2 Deleted
        1.8   Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for Gain instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`Gain`, in
        :param other: The other instance to move.

        Since: 1.2.2
        """
        _ids_peak_ipl_python_interface.Gain_swiginit(self, _ids_peak_ipl_python_interface.new_Gain(*args))

    def SetMasterGainValue(self, masterGainValue: "float") -> "None":
        r"""
        Sets the values of the master Gain.

        :type masterGainValue: float, in
        :param masterGainValue: The value of the master gain.

        :raises: InvalidArgument masterGainValue isn't supported.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_SetMasterGainValue(self, masterGainValue)

    def MasterGainValue(self) -> "float":
        r"""
        Returns the value of the master gain.

        :rtype: float
        :return: masterGainValue The value of the master gain.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_MasterGainValue(self)

    def MasterGainMin(self) -> "float":
        r"""
        Returns the minimum value of the master gain.

        :rtype: float
        :return: masterGainMin The minimum value of the master gain.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_MasterGainMin(self)

    def MasterGainMax(self) -> "float":
        r"""
        Returns the maximum value of the master gain.

        :rtype: float
        :return: masterGainMax The maximum value of the master gain.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_MasterGainMax(self)

    def SetRedGainValue(self, redGainValue: "float") -> "None":
        r"""
        Sets the values of the red Gain.

        :type redGainValue: float, in
        :param redGainValue: The value of the red gain.

        :raises: InvalidArgument redGainValue isn't supported.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_SetRedGainValue(self, redGainValue)

    def RedGainValue(self) -> "float":
        r"""
        Returns the value of the red gain.

        :rtype: float
        :return: redGainValue The value of the red gain.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_RedGainValue(self)

    def RedGainMin(self) -> "float":
        r"""
        Returns the minimum value of the red gain.

        :rtype: float
        :return: redGainMin The minimum value of the red gain.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_RedGainMin(self)

    def RedGainMax(self) -> "float":
        r"""
        Returns the maximum value of the red gain.

        :rtype: float
        :return: redGainMax The maximum value of the red gain.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_RedGainMax(self)

    def SetGreenGainValue(self, greenGainValue: "float") -> "None":
        r"""
        Sets the values of the green Gain.

        :type greenGainValue: float, in
        :param greenGainValue: The value of the green gain.

        :raises: InvalidArgument greenGainValue isn't supported.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_SetGreenGainValue(self, greenGainValue)

    def GreenGainValue(self) -> "float":
        r"""
        Returns the value of the green gain.

        :rtype: float
        :return: greenGainValue The value of the green gain.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_GreenGainValue(self)

    def GreenGainMin(self) -> "float":
        r"""
        Returns the minimum value of the green gain.

        :rtype: float
        :return: greenGainMin The minimum value of the green gain.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_GreenGainMin(self)

    def GreenGainMax(self) -> "float":
        r"""
        Returns the maximum value of the green gain.

        :rtype: float
        :return: greenGainMax The maximum value of the green gain.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_GreenGainMax(self)

    def SetBlueGainValue(self, blueGainValue: "float") -> "None":
        r"""
        Sets the values of the blue Gain.

        :type blueGainValue: float, in
        :param blueGainValue: The value of the blue gain.

        :raises: InvalidArgument blueGainValue isn't supported.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_SetBlueGainValue(self, blueGainValue)

    def BlueGainValue(self) -> "float":
        r"""
        Returns the value of the blue gain.

        :rtype: float
        :return: blueGainValue The value of the blue gain.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_BlueGainValue(self)

    def BlueGainMin(self) -> "float":
        r"""
        Returns the minimum value of the blue gain.

        :rtype: float
        :return: blueGainMin The minimum value of the blue gain.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_BlueGainMin(self)

    def BlueGainMax(self) -> "float":
        r"""
        Returns the maximum value of the blue gain.

        :rtype: float
        :return: blueGainMax The maximum value of the blue gain.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_BlueGainMax(self)

    def IsPixelFormatSupported(self, pixelFormatName: "int") -> "bool":
        r"""
        Returns whether the gain supports the given pixel format.

        :rtype: boolean
        :return: Flag whether the given pixel format is supported.

        :type pixelFormatName: int, in
        :param pixelFormatName: The pixel format of interest.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_IsPixelFormatSupported(self, pixelFormatName)

    def ProcessInPlace(self, image: "Image") -> "None":
        r"""
        Applies the gain on the given image in place that is, it will change the input image.

        :type image: :py:class:`Image`, in
        :param image: Image to process.

        Notes: Will not work with packed pixel formats. See 'unpackPixelformat' for the correct handling of this.

        Will currently only work with unpacked Bayer and Mono Pixel Formats. Call ``IsPixelFormatSupported`` to check for support if in doubt.

        :raises: ImageFormatNotSupportedException image has unsupported pixel format.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_ProcessInPlace(self, image)

    def Process(self, inputImage: "Image") -> "Image":
        r"""
         Applies the gain on the given image.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: Image to process.

        Notes: Will not work with packed pixel formats. See 'unpackPixelformat' for the correct handling of this.

        Will currently only work with unpacked Bayer and Mono Pixel Formats. Call ``IsPixelFormatSupported`` to check for support if in doubt.

        :rtype: :py:class:`Image`
        :return: A new created image containing the gamma-corrected pixels.

        :raises: ImageFormatNotSupportedException image has unsupported pixel format.

        Since: 1.3.2
        """
        return _ids_peak_ipl_python_interface.Gain_Process(self, inputImage)

# Register Gain in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.Gain_swigregister(Gain)
class Binning(object):
    r"""
    Performs spatial binning on 2D images.

    The Binning class provides a configurable image-processing operation that
    reduces image resolution by aggregating pixel blocks in the horizontal and/or
    vertical direction. The aggregation can be performed either by summation or
    averaging, depending on the selected binning mode. Binning is used to
    increase signal-to-noise ratio (SNR), improve memory footprint or accelerate
    downstream image processing steps.

    Since: 1.3.3
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    BinningMode_Average = _ids_peak_ipl_python_interface.Binning_BinningMode_Average
    r"""Average (mean) of pixels"""
    BinningMode_Sum = _ids_peak_ipl_python_interface.Binning_BinningMode_Sum
    r"""Sum of pixels"""
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_Binning

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new Binning instance

        Creates a new Binning instance.

        Since: 1.3.3

        |

        *Overload 2:*
         Copy Constructor for a new Binning instance

        Creates a new Binning instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`Binning`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.3.3 Deleted
        1.8   Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for Binning instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`Binning`, in
        :param other: The other instance to move.

        Since: 1.3.3
        """
        _ids_peak_ipl_python_interface.Binning_swiginit(self, _ids_peak_ipl_python_interface.new_Binning(*args))

    def SetBinningX(self, value: "int") -> "None":
        r"""
        Sets the values of the binning in horizontal direction.

        :type value: int, in
        :param value: The value of the binning in horizontal direction.

        :raises: InvalidArgument value isn't supported.

        Since: 1.3.3
        """
        return _ids_peak_ipl_python_interface.Binning_SetBinningX(self, value)

    def BinningX(self) -> "int":
        r"""
        Returns the value of the binning in horizontal direction.

        :rtype: int
        :return: The value of the binning in horizontal direction.

        Since: 1.3.3
        """
        return _ids_peak_ipl_python_interface.Binning_BinningX(self)

    def SetBinningY(self, value: "int") -> "None":
        r"""
        Sets the values of the binning in vertical direction.

        :type value: int, in
        :param value: The value of the binning in vertical direction.

        :raises: InvalidArgument value isn't supported.

        Since: 1.3.3
        """
        return _ids_peak_ipl_python_interface.Binning_SetBinningY(self, value)

    def BinningY(self) -> "int":
        r"""
        Returns the value of the binning in vertical direction.

        :rtype: int
        :return: The value of the binning in vertical direction.

        Since: 1.3.3
        """
        return _ids_peak_ipl_python_interface.Binning_BinningY(self)

    def BinningMin(self) -> "int":
        r"""
        Returns the minimum value for the binning.

        :rtype: int
        :return: The minimum value for the binning.

        Since: 1.3.3
        """
        return _ids_peak_ipl_python_interface.Binning_BinningMin(self)

    def BinningMax(self) -> "int":
        r"""
        Returns the maximum value for the binning.

        :rtype: int
        :return: The maximum value for the binning.

        Since: 1.3.3
        """
        return _ids_peak_ipl_python_interface.Binning_BinningMax(self)

    def ExpectedOutputSize(self, inputSize: "Size2D", pixelFormat: "int") -> "Size2D":
        r"""
        Returns the size of a binned image given the input size and pixelformat.

        :type inputSize: :py:class:`Size2D`, in
        :param inputSize:                         The size of the input image.
        :type pixelFormat: int, in
        :param pixelFormat:                       The pixelFormat of the input image.

        :rtype: :py:class:`Size2D`
        :return: The size of a binned image

        :raises: InvalidArgument pixelFormat isn't supported.

        Since: 1.3.4
        """
        return _ids_peak_ipl_python_interface.Binning_ExpectedOutputSize(self, inputSize, pixelFormat)

    def SetMode(self, mode: "int") -> "None":
        r"""
        Sets the values of the binning mode.

        :type mode: int, in
        :param mode: The value of the binning mode.

        :raises: InvalidArgument value isn't supported.

        Since: 1.3.3
        """
        return _ids_peak_ipl_python_interface.Binning_SetMode(self, mode)

    def Mode(self) -> "int":
        r"""
        Returns the value of the binning mode.

        :rtype: int
        :return: The value of the binning mode.

        Since: 1.3.3
        """
        return _ids_peak_ipl_python_interface.Binning_Mode(self)

    def IsPixelFormatSupported(self, pixelFormatName: "int") -> "bool":
        r"""
        Returns whether the binning supports the given pixel format.

        :rtype: boolean
        :return: Flag whether the given pixel format is supported.

        :type pixelFormatName: int, in
        :param pixelFormatName: The pixel format of interest.

        Since: 1.3.3
        """
        return _ids_peak_ipl_python_interface.Binning_IsPixelFormatSupported(self, pixelFormatName)

    def Process(self, inputImage: "Image") -> "Image":
        r"""
         Applies the binning on the given image.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: Image to process.

        :rtype: :py:class:`Image`
        :return: A new created image containing the gamma-corrected pixels.

        Notes: Will not work with packed pixel formats. See 'unpackPixelformat' for the correct handling of this.

        :raises: ImageFormatNotSupportedException image has unsupported pixel format.
        :raises: InvalidArgument the image is too small.

        Since: 1.3.3
        """
        return _ids_peak_ipl_python_interface.Binning_Process(self, inputImage)

# Register Binning in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.Binning_swigregister(Binning)
class Decimation(object):
    r"""
    Performs spatial decimation on 2D images.

    The Decimation class provides a configurable image-processing operation that
    reduces image resolution by skipping pixel blocks in the horizontal and/or
    vertical direction. Decimation is used to improve memory footprint
    or accelerate downstream image processing steps.

    Since: 1.6.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_Decimation

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new Decimation instance

        Creates a new Decimation instance.

        Since: 1.6.0

        |

        *Overload 2:*
         Copy Constructor for a new Decimation instance

        Creates a new Decimation instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`Decimation`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.6.0 Deleted
        1.8   Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for Decimation instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`Decimation`, in
        :param other: The other instance to move.

        Since: 1.6.0
        """
        _ids_peak_ipl_python_interface.Decimation_swiginit(self, _ids_peak_ipl_python_interface.new_Decimation(*args))

    def SetDecimationX(self, value: "int") -> "None":
        r"""
        Sets the values of the decimation in horizontal direction.

        :type value: int, in
        :param value: The value of the decimation in horizontal direction.

        :raises: InvalidArgument value isn't supported.

        Since: 1.6.0
        """
        return _ids_peak_ipl_python_interface.Decimation_SetDecimationX(self, value)

    def DecimationX(self) -> "int":
        r"""
        Returns the value of the decimation in horizontal direction.

        :rtype: int
        :return: The value of the decimation in horizontal direction.

        Since: 1.6.0
        """
        return _ids_peak_ipl_python_interface.Decimation_DecimationX(self)

    def SetDecimationY(self, value: "int") -> "None":
        r"""
        Sets the values of the decimation in vertical direction.

        :type value: int, in
        :param value: The value of the decimation in vertical direction.

        :raises: InvalidArgument value isn't supported.

        Since: 1.6.0
        """
        return _ids_peak_ipl_python_interface.Decimation_SetDecimationY(self, value)

    def DecimationY(self) -> "int":
        r"""
        Returns the value of the decimation in vertical direction.

        :rtype: int
        :return: The value of the decimation in vertical direction.

        Since: 1.6.0
        """
        return _ids_peak_ipl_python_interface.Decimation_DecimationY(self)

    def DecimationMin(self) -> "int":
        r"""
        Returns the minimum value for the decimation.

        :rtype: int
        :return: The minimum value for the decimation.

        Since: 1.6.0
        """
        return _ids_peak_ipl_python_interface.Decimation_DecimationMin(self)

    def DecimationMax(self) -> "int":
        r"""
        Returns the maximum value for the decimation.

        :rtype: int
        :return: The maximum value for the decimation.

        Since: 1.6.0
        """
        return _ids_peak_ipl_python_interface.Decimation_DecimationMax(self)

    def ExpectedOutputSize(self, inputSize: "Size2D", pixelFormat: "int") -> "Size2D":
        r"""
        Returns the size of a decimated image given the input size and pixelformat.

        :type inputSize: :py:class:`Size2D`, in
        :param inputSize:                         The size of the input image.
        :type pixelFormat: int, in
        :param pixelFormat:                       The pixelFormat of the input image.

        :rtype: :py:class:`Size2D`
        :return: The size of a decimated image

        :raises: InvalidArgument pixelFormat isn't supported.

        Since: 1.6.0
        """
        return _ids_peak_ipl_python_interface.Decimation_ExpectedOutputSize(self, inputSize, pixelFormat)

    def IsPixelFormatSupported(self, pixelFormatName: "int") -> "bool":
        r"""
        Returns whether the decimation supports the given pixel format.

        :rtype: boolean
        :return: Flag whether the given pixel format is supported.

        :type pixelFormatName: int, in
        :param pixelFormatName: The pixel format of interest.

        Since: 1.6.0
        """
        return _ids_peak_ipl_python_interface.Decimation_IsPixelFormatSupported(self, pixelFormatName)

    def Process(self, inputImage: "Image") -> "Image":
        r"""
         Applies the decimation on the given image.

        :type inputImage: :py:class:`Image`, in
        :param inputImage: Image to process.

        Notes: Will not work with packed pixel formats. See 'unpackPixelformat' for the correct handling of this.

        :rtype: :py:class:`Image`
        :return: A new created image containing the decimated pixels.

        :raises: ImageFormatNotSupportedException image has unsupported pixel format.
        :raises: InvalidArgument the image is too small.

        Since: 1.6.0
        """
        return _ids_peak_ipl_python_interface.Decimation_Process(self, inputImage)

# Register Decimation in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.Decimation_swigregister(Decimation)
class EdgeEnhancement(object):
    r"""
    Edge Enhancement for a given image.

    This class uses a software filter that emphasizes the edges in the image. The enhancement factor is configurable.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_EdgeEnhancement

    def __init__(self, *args):
        r"""
        *Overload 1:*
         Constructor for a new EdgeEnhancement instance

        Creates a new EdgeEnhancement instance.

        Since: 1.7

        |

        *Overload 2:*
         Copy Constructor for a new EdgeEnhancement instance

        Creates a new EdgeEnhancement instance.

        Notes: This only creates a shallow copy. See 'shallowCopy' for a detailed explanation.

        :type other: :py:class:`EdgeEnhancement`, in
        :param other: The other instance to acquire a reference for.

        Since: 1.7 Deleted
        1.8   Implemented as shallow copy

        |

        *Overload 3:*
         Move constructor for EdgeEnhancement instance

        Moves the instance from ``other`` to this. Afterwards ``other`` is invalid.

        :type other: :py:class:`EdgeEnhancement`, in
        :param other: The other instance to move.

        Since: 1.7
        """
        _ids_peak_ipl_python_interface.EdgeEnhancement_swiginit(self, _ids_peak_ipl_python_interface.new_EdgeEnhancement(*args))

    def ProcessInPlace(self, image: "Image") -> "None":
        r"""
        Process an image

        To check if it is supported, call #IsPixelFormatSupported first
        This function causes a higher CPU load.

        :type image: :py:class:`Image`, in
        :param image: Image to process.

        :raises: InvalidPixelFormat pixel format isn't supported.
        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _ids_peak_ipl_python_interface.EdgeEnhancement_ProcessInPlace(self, image)

    def Process(self, image: "Image") -> "Image":
        r"""
        Process an image

        To check if it is supported, call #IsPixelFormatSupported first
        This function causes a higher CPU load.

        :type image: :py:class:`Image`, in
        :param image: Image to process.

        Notes: Will not work with packed pixel formats. See 'unpackPixelformat' for the correct handling of this.

        :rtype: :py:class:`Image`
        :return: the sharpened image

        :raises: InvalidPixelFormat pixel format isn't supported.
        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _ids_peak_ipl_python_interface.EdgeEnhancement_Process(self, image)

    def IsPixelFormatSupported(self, pixelFormatName: "int") -> "bool":
        r"""
        Check if the pixel format is supported

        Notes: Is currently only implemented for not packed and not raw pixel formats

        :type pixelFormatName: int, in
        :param pixelFormatName: The PixelFormatName to check support for.

        :rtype: boolean
        :return: true if pixelformat is supported, else false

        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _ids_peak_ipl_python_interface.EdgeEnhancement_IsPixelFormatSupported(self, pixelFormatName)

    def SetFactor(self, factor: "int") -> "None":
        r"""
        Set the edge enhancement factor

        :type factor: int, in
        :param factor: The factor to set.

        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _ids_peak_ipl_python_interface.EdgeEnhancement_SetFactor(self, factor)

    def Factor(self) -> "int":
        r"""
        Get the edge enhancement factor

        :rtype: int
        :return: the current edge enhancement factor

        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _ids_peak_ipl_python_interface.EdgeEnhancement_Factor(self)

    def DefaultFactor(self) -> "int":
        r"""
        Get the default edge enhancement factor

        :rtype: int
        :return: the default edge enhancement factor

        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _ids_peak_ipl_python_interface.EdgeEnhancement_DefaultFactor(self)

    def Range(self) -> "RangeInt32":
        r"""
        Get the range for the edge enhancement factor

        :rtype: Range< int >
        :return: the range for the edge enhancement factor

        :raises: Exception An internal error has occurred.

        Since: 1.7
        """
        return _ids_peak_ipl_python_interface.EdgeEnhancement_Range(self)

# Register EdgeEnhancement in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.EdgeEnhancement_swigregister(EdgeEnhancement)
class VectorInt32(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.VectorInt32_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorInt32___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorInt32___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorInt32___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[int]":
        return _ids_peak_ipl_python_interface.VectorInt32___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorInt32___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorInt32___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorInt32___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.VectorInt32___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorInt32___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorInt32_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorInt32_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorInt32_empty(self)

    def size(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorInt32_size(self)

    def swap(self, v: "VectorInt32") -> "None":
        return _ids_peak_ipl_python_interface.VectorInt32_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorInt32_begin(self)

    def end(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorInt32_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorInt32_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorInt32_rend(self)

    def clear(self) -> "None":
        return _ids_peak_ipl_python_interface.VectorInt32_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorInt32_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_ipl_python_interface.VectorInt32_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.VectorInt32_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_ipl_python_interface.VectorInt32_swiginit(self, _ids_peak_ipl_python_interface.new_VectorInt32(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorInt32_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorInt32_front(self)

    def back(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorInt32_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorInt32_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorInt32_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorInt32_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorInt32_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorInt32_capacity(self)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_VectorInt32

# Register VectorInt32 in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.VectorInt32_swigregister(VectorInt32)
class VectorUInt32(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.VectorUInt32_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorUInt32___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorUInt32___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt32___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt32___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt32___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt32___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt32___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt32___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt32___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt32_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt32_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorUInt32_empty(self)

    def size(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt32_size(self)

    def swap(self, v: "VectorUInt32") -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt32_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt32_begin(self)

    def end(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt32_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt32_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt32_rend(self)

    def clear(self) -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt32_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt32_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt32_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt32_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_ipl_python_interface.VectorUInt32_swiginit(self, _ids_peak_ipl_python_interface.new_VectorUInt32(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt32_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt32_front(self)

    def back(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt32_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt32_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt32_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt32_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt32_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt32_capacity(self)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_VectorUInt32

# Register VectorUInt32 in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.VectorUInt32_swigregister(VectorUInt32)
class VectorUInt64(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.VectorUInt64_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorUInt64___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorUInt64___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt64___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt64___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt64___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt64___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt64___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt64___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt64___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt64_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt64_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorUInt64_empty(self)

    def size(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt64_size(self)

    def swap(self, v: "VectorUInt64") -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt64_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt64_begin(self)

    def end(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt64_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt64_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt64_rend(self)

    def clear(self) -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt64_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt64_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt64_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt64_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_ipl_python_interface.VectorUInt64_swiginit(self, _ids_peak_ipl_python_interface.new_VectorUInt64(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt64_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt64_front(self)

    def back(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt64_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt64_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt64_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt64_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorUInt64_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorUInt64_capacity(self)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_VectorUInt64

# Register VectorUInt64 in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.VectorUInt64_swigregister(VectorUInt64)
class VectorPixelLineChannel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[PixelLineChannel]":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_pop(self)

    def append(self, x: "PixelLineChannel") -> "None":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_empty(self)

    def size(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_size(self)

    def swap(self, v: "VectorPixelLineChannel") -> "None":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_begin(self)

    def end(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_rend(self)

    def clear(self) -> "None":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_ipl_python_interface.VectorPixelLineChannel_swiginit(self, _ids_peak_ipl_python_interface.new_VectorPixelLineChannel(*args))

    def push_back(self, x: "PixelLineChannel") -> "None":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_front(self)

    def back(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_back(self)

    def assign(self, n: "Any", x: "PixelLineChannel") -> "None":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPixelLineChannel_capacity(self)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_VectorPixelLineChannel

# Register VectorPixelLineChannel in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.VectorPixelLineChannel_swigregister(VectorPixelLineChannel)
class VectorHistogramChannel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[HistogramChannel]":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_pop(self)

    def append(self, x: "HistogramChannel") -> "None":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_empty(self)

    def size(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_size(self)

    def swap(self, v: "VectorHistogramChannel") -> "None":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_begin(self)

    def end(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_rend(self)

    def clear(self) -> "None":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_ipl_python_interface.VectorHistogramChannel_swiginit(self, _ids_peak_ipl_python_interface.new_VectorHistogramChannel(*args))

    def push_back(self, x: "HistogramChannel") -> "None":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_front(self)

    def back(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_back(self)

    def assign(self, n: "Any", x: "HistogramChannel") -> "None":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorHistogramChannel_capacity(self)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_VectorHistogramChannel

# Register VectorHistogramChannel in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.VectorHistogramChannel_swigregister(VectorHistogramChannel)
class VectorPoint2D(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.VectorPoint2D_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorPoint2D___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorPoint2D___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPoint2D___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[Point2D]":
        return _ids_peak_ipl_python_interface.VectorPoint2D___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorPoint2D___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorPoint2D___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorPoint2D___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPoint2D___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorPoint2D___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPoint2D_pop(self)

    def append(self, x: "Point2D") -> "None":
        return _ids_peak_ipl_python_interface.VectorPoint2D_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorPoint2D_empty(self)

    def size(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPoint2D_size(self)

    def swap(self, v: "VectorPoint2D") -> "None":
        return _ids_peak_ipl_python_interface.VectorPoint2D_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPoint2D_begin(self)

    def end(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPoint2D_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPoint2D_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPoint2D_rend(self)

    def clear(self) -> "None":
        return _ids_peak_ipl_python_interface.VectorPoint2D_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPoint2D_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_ipl_python_interface.VectorPoint2D_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPoint2D_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_ipl_python_interface.VectorPoint2D_swiginit(self, _ids_peak_ipl_python_interface.new_VectorPoint2D(*args))

    def push_back(self, x: "Point2D") -> "None":
        return _ids_peak_ipl_python_interface.VectorPoint2D_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPoint2D_front(self)

    def back(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPoint2D_back(self)

    def assign(self, n: "Any", x: "Point2D") -> "None":
        return _ids_peak_ipl_python_interface.VectorPoint2D_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorPoint2D_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorPoint2D_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorPoint2D_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorPoint2D_capacity(self)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_VectorPoint2D

# Register VectorPoint2D in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.VectorPoint2D_swigregister(VectorPoint2D)
class SharpnessROIList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.SharpnessROIList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_ipl_python_interface.SharpnessROIList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_ipl_python_interface.SharpnessROIList___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_ipl_python_interface.SharpnessROIList___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[SharpnessROI]":
        return _ids_peak_ipl_python_interface.SharpnessROIList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.SharpnessROIList___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_ipl_python_interface.SharpnessROIList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.SharpnessROIList___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.SharpnessROIList___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.SharpnessROIList___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_ipl_python_interface.SharpnessROIList_pop(self)

    def append(self, x: "SharpnessROI") -> "None":
        return _ids_peak_ipl_python_interface.SharpnessROIList_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_ipl_python_interface.SharpnessROIList_empty(self)

    def size(self) -> "Any":
        return _ids_peak_ipl_python_interface.SharpnessROIList_size(self)

    def swap(self, v: "SharpnessROIList") -> "None":
        return _ids_peak_ipl_python_interface.SharpnessROIList_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_ipl_python_interface.SharpnessROIList_begin(self)

    def end(self) -> "Any":
        return _ids_peak_ipl_python_interface.SharpnessROIList_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_ipl_python_interface.SharpnessROIList_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_ipl_python_interface.SharpnessROIList_rend(self)

    def clear(self) -> "None":
        return _ids_peak_ipl_python_interface.SharpnessROIList_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_ipl_python_interface.SharpnessROIList_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_ipl_python_interface.SharpnessROIList_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.SharpnessROIList_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_ipl_python_interface.SharpnessROIList_swiginit(self, _ids_peak_ipl_python_interface.new_SharpnessROIList(*args))

    def push_back(self, x: "SharpnessROI") -> "None":
        return _ids_peak_ipl_python_interface.SharpnessROIList_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_ipl_python_interface.SharpnessROIList_front(self)

    def back(self) -> "Any":
        return _ids_peak_ipl_python_interface.SharpnessROIList_back(self)

    def assign(self, n: "Any", x: "SharpnessROI") -> "None":
        return _ids_peak_ipl_python_interface.SharpnessROIList_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.SharpnessROIList_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.SharpnessROIList_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_ipl_python_interface.SharpnessROIList_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_ipl_python_interface.SharpnessROIList_capacity(self)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_SharpnessROIList

# Register SharpnessROIList in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.SharpnessROIList_swigregister(SharpnessROIList)
class VectorVideo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.VectorVideo_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorVideo___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorVideo___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorVideo___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Any":
        return _ids_peak_ipl_python_interface.VectorVideo___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorVideo___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorVideo___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorVideo___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.VectorVideo___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorVideo___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorVideo_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorVideo_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_ipl_python_interface.VectorVideo_empty(self)

    def size(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorVideo_size(self)

    def swap(self, v: "VectorVideo") -> "None":
        return _ids_peak_ipl_python_interface.VectorVideo_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorVideo_begin(self)

    def end(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorVideo_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorVideo_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorVideo_rend(self)

    def clear(self) -> "None":
        return _ids_peak_ipl_python_interface.VectorVideo_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorVideo_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_ipl_python_interface.VectorVideo_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.VectorVideo_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_ipl_python_interface.VectorVideo_swiginit(self, _ids_peak_ipl_python_interface.new_VectorVideo(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorVideo_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorVideo_front(self)

    def back(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorVideo_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorVideo_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorVideo_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.VectorVideo_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_ipl_python_interface.VectorVideo_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_ipl_python_interface.VectorVideo_capacity(self)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_VectorVideo

# Register VectorVideo in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.VectorVideo_swigregister(VectorVideo)
class RangeDouble(object):
    r"""Range support and convenience class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, min: "float", max: "float", inc: "float"):
        r"""
        Constructor for the Range

        :type min: float
        :param min:  The minimum value for the range.
        :type max: float
        :param max:  The maximum value for the range.
        :type inc: float
        :param inc:  The increment value for the range.

        :raises: InvalidArgumentException for invalid input values.
        """
        _ids_peak_ipl_python_interface.RangeDouble_swiginit(self, _ids_peak_ipl_python_interface.new_RangeDouble(min, max, inc))

    def Minimum(self) -> "float":
        r"""
        Get the minimum value for the range

        :rtype: float
        :return: the minimum value.
        """
        return _ids_peak_ipl_python_interface.RangeDouble_Minimum(self)

    def Maximum(self) -> "float":
        r"""
        Get the maximum value for the range

        :rtype: float
        :return: the maximum value.
        """
        return _ids_peak_ipl_python_interface.RangeDouble_Maximum(self)

    def Increment(self) -> "float":
        r"""
        Get the increment value for the range

        :rtype: float
        :return: the increment value.
        """
        return _ids_peak_ipl_python_interface.RangeDouble_Increment(self)

    def InRange(self, value: "float") -> "bool":
        r"""
        Check if the value is in range

        :type value: float
        :param value: The value to check.

        :rtype: boolean
        :return: true if in range, false otherwise.
        """
        return _ids_peak_ipl_python_interface.RangeDouble_InRange(self, value)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_RangeDouble

# Register RangeDouble in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.RangeDouble_swigregister(RangeDouble)
class RangeUint32(object):
    r"""Range support and convenience class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, min: "unsigned int", max: "unsigned int", inc: "unsigned int"):
        r"""
        Constructor for the Range

        :type min: int
        :param min:  The minimum value for the range.
        :type max: int
        :param max:  The maximum value for the range.
        :type inc: int
        :param inc:  The increment value for the range.

        :raises: InvalidArgumentException for invalid input values.
        """
        _ids_peak_ipl_python_interface.RangeUint32_swiginit(self, _ids_peak_ipl_python_interface.new_RangeUint32(min, max, inc))

    def Minimum(self) -> "unsigned int":
        r"""
        Get the minimum value for the range

        :rtype: int
        :return: the minimum value.
        """
        return _ids_peak_ipl_python_interface.RangeUint32_Minimum(self)

    def Maximum(self) -> "unsigned int":
        r"""
        Get the maximum value for the range

        :rtype: int
        :return: the maximum value.
        """
        return _ids_peak_ipl_python_interface.RangeUint32_Maximum(self)

    def Increment(self) -> "unsigned int":
        r"""
        Get the increment value for the range

        :rtype: int
        :return: the increment value.
        """
        return _ids_peak_ipl_python_interface.RangeUint32_Increment(self)

    def InRange(self, value: "unsigned int") -> "bool":
        r"""
        Check if the value is in range

        :type value: int
        :param value: The value to check.

        :rtype: boolean
        :return: true if in range, false otherwise.
        """
        return _ids_peak_ipl_python_interface.RangeUint32_InRange(self, value)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_RangeUint32

# Register RangeUint32 in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.RangeUint32_swigregister(RangeUint32)
class RangeInt32(object):
    r"""Range support and convenience class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, min: "int", max: "int", inc: "int"):
        r"""
        Constructor for the Range

        :type min: int
        :param min:  The minimum value for the range.
        :type max: int
        :param max:  The maximum value for the range.
        :type inc: int
        :param inc:  The increment value for the range.

        :raises: InvalidArgumentException for invalid input values.
        """
        _ids_peak_ipl_python_interface.RangeInt32_swiginit(self, _ids_peak_ipl_python_interface.new_RangeInt32(min, max, inc))

    def Minimum(self) -> "int":
        r"""
        Get the minimum value for the range

        :rtype: int
        :return: the minimum value.
        """
        return _ids_peak_ipl_python_interface.RangeInt32_Minimum(self)

    def Maximum(self) -> "int":
        r"""
        Get the maximum value for the range

        :rtype: int
        :return: the maximum value.
        """
        return _ids_peak_ipl_python_interface.RangeInt32_Maximum(self)

    def Increment(self) -> "int":
        r"""
        Get the increment value for the range

        :rtype: int
        :return: the increment value.
        """
        return _ids_peak_ipl_python_interface.RangeInt32_Increment(self)

    def InRange(self, value: "int") -> "bool":
        r"""
        Check if the value is in range

        :type value: int
        :param value: The value to check.

        :rtype: boolean
        :return: true if in range, false otherwise.
        """
        return _ids_peak_ipl_python_interface.RangeInt32_InRange(self, value)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_RangeInt32

# Register RangeInt32 in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.RangeInt32_swigregister(RangeInt32)
class RangeUInt8(object):
    r"""Range support and convenience class"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, min: "unsigned char", max: "unsigned char", inc: "unsigned char"):
        r"""
        Constructor for the Range

        :type min: unsigned char
        :param min:  The minimum value for the range.
        :type max: unsigned char
        :param max:  The maximum value for the range.
        :type inc: unsigned char
        :param inc:  The increment value for the range.

        :raises: InvalidArgumentException for invalid input values.
        """
        _ids_peak_ipl_python_interface.RangeUInt8_swiginit(self, _ids_peak_ipl_python_interface.new_RangeUInt8(min, max, inc))

    def Minimum(self) -> "unsigned char":
        r"""
        Get the minimum value for the range

        :rtype: unsigned char
        :return: the minimum value.
        """
        return _ids_peak_ipl_python_interface.RangeUInt8_Minimum(self)

    def Maximum(self) -> "unsigned char":
        r"""
        Get the maximum value for the range

        :rtype: unsigned char
        :return: the maximum value.
        """
        return _ids_peak_ipl_python_interface.RangeUInt8_Maximum(self)

    def Increment(self) -> "unsigned char":
        r"""
        Get the increment value for the range

        :rtype: unsigned char
        :return: the increment value.
        """
        return _ids_peak_ipl_python_interface.RangeUInt8_Increment(self)

    def InRange(self, value: "unsigned char") -> "bool":
        r"""
        Check if the value is in range

        :type value: unsigned char
        :param value: The value to check.

        :rtype: boolean
        :return: true if in range, false otherwise.
        """
        return _ids_peak_ipl_python_interface.RangeUInt8_InRange(self, value)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_RangeUInt8

# Register RangeUInt8 in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.RangeUInt8_swigregister(RangeUInt8)
class PixelFormatList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.PixelFormatList_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_ipl_python_interface.PixelFormatList___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_ipl_python_interface.PixelFormatList___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_ipl_python_interface.PixelFormatList___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Sequence[PixelFormatName]":
        return _ids_peak_ipl_python_interface.PixelFormatList___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.PixelFormatList___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_ipl_python_interface.PixelFormatList___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.PixelFormatList___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.PixelFormatList___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.PixelFormatList___setitem__(self, *args)

    def pop(self) -> "Any":
        return _ids_peak_ipl_python_interface.PixelFormatList_pop(self)

    def append(self, x: "Any") -> "None":
        return _ids_peak_ipl_python_interface.PixelFormatList_append(self, x)

    def empty(self) -> "bool":
        return _ids_peak_ipl_python_interface.PixelFormatList_empty(self)

    def size(self) -> "Any":
        return _ids_peak_ipl_python_interface.PixelFormatList_size(self)

    def swap(self, v: "PixelFormatList") -> "None":
        return _ids_peak_ipl_python_interface.PixelFormatList_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_ipl_python_interface.PixelFormatList_begin(self)

    def end(self) -> "Any":
        return _ids_peak_ipl_python_interface.PixelFormatList_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_ipl_python_interface.PixelFormatList_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_ipl_python_interface.PixelFormatList_rend(self)

    def clear(self) -> "None":
        return _ids_peak_ipl_python_interface.PixelFormatList_clear(self)

    def get_allocator(self) -> "Any":
        return _ids_peak_ipl_python_interface.PixelFormatList_get_allocator(self)

    def pop_back(self) -> "None":
        return _ids_peak_ipl_python_interface.PixelFormatList_pop_back(self)

    def erase(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.PixelFormatList_erase(self, *args)

    def __init__(self, *args):
        _ids_peak_ipl_python_interface.PixelFormatList_swiginit(self, _ids_peak_ipl_python_interface.new_PixelFormatList(*args))

    def push_back(self, x: "Any") -> "None":
        return _ids_peak_ipl_python_interface.PixelFormatList_push_back(self, x)

    def front(self) -> "Any":
        return _ids_peak_ipl_python_interface.PixelFormatList_front(self)

    def back(self) -> "Any":
        return _ids_peak_ipl_python_interface.PixelFormatList_back(self)

    def assign(self, n: "Any", x: "Any") -> "None":
        return _ids_peak_ipl_python_interface.PixelFormatList_assign(self, n, x)

    def resize(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.PixelFormatList_resize(self, *args)

    def insert(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.PixelFormatList_insert(self, *args)

    def reserve(self, n: "Any") -> "None":
        return _ids_peak_ipl_python_interface.PixelFormatList_reserve(self, n)

    def capacity(self) -> "Any":
        return _ids_peak_ipl_python_interface.PixelFormatList_capacity(self)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_PixelFormatList

# Register PixelFormatList in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.PixelFormatList_swigregister(PixelFormatList)
class IntervalDouble(object):
    r"""
    Interval support and convenience class

    Since: 1.15
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, start: "float", end: "float"):
        r"""
        Constructor for the interval

        :type start: float
        :param start:  The start value (inclusive) for the interval.
        :type end: float
        :param end:  The end value (inclusive) for the interval.

        :raises: InvalidArgumentException The end must be greater than start
        """
        _ids_peak_ipl_python_interface.IntervalDouble_swiginit(self, _ids_peak_ipl_python_interface.new_IntervalDouble(start, end))

    def Start(self) -> "float":
        r"""
        Get the start value (inclusive) for the interval

        :rtype: float
        :return: the start value.

        Since: 1.15
        """
        return _ids_peak_ipl_python_interface.IntervalDouble_Start(self)

    def End(self) -> "float":
        r"""
        Get the end value (inclusive) for the interval

        :rtype: float
        :return: the end value.

        Since: 1.15
        """
        return _ids_peak_ipl_python_interface.IntervalDouble_End(self)

    def InInterval(self, value: "float") -> "bool":
        r"""
        Check if the value is in the interval

        :type value: float
        :param value: The value to check.

        :rtype: boolean
        :return: true if in the interval, false otherwise.

        Since: 1.15
        """
        return _ids_peak_ipl_python_interface.IntervalDouble_InInterval(self, value)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_IntervalDouble

# Register IntervalDouble in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.IntervalDouble_swigregister(IntervalDouble)
class FloatArray9(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "SwigPyIterator":
        return _ids_peak_ipl_python_interface.FloatArray9_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _ids_peak_ipl_python_interface.FloatArray9___nonzero__(self)

    def __bool__(self) -> "bool":
        return _ids_peak_ipl_python_interface.FloatArray9___bool__(self)

    def __len__(self) -> "Any":
        return _ids_peak_ipl_python_interface.FloatArray9___len__(self)

    def __getslice__(self, i: "Any", j: "Any") -> "Any":
        return _ids_peak_ipl_python_interface.FloatArray9___getslice__(self, i, j)

    def __setslice__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.FloatArray9___setslice__(self, *args)

    def __delslice__(self, i: "Any", j: "Any") -> "None":
        return _ids_peak_ipl_python_interface.FloatArray9___delslice__(self, i, j)

    def __delitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.FloatArray9___delitem__(self, *args)

    def __getitem__(self, *args) -> "Any":
        return _ids_peak_ipl_python_interface.FloatArray9___getitem__(self, *args)

    def __setitem__(self, *args) -> "None":
        return _ids_peak_ipl_python_interface.FloatArray9___setitem__(self, *args)

    def __init__(self, *args):
        _ids_peak_ipl_python_interface.FloatArray9_swiginit(self, _ids_peak_ipl_python_interface.new_FloatArray9(*args))

    def empty(self) -> "bool":
        return _ids_peak_ipl_python_interface.FloatArray9_empty(self)

    def size(self) -> "Any":
        return _ids_peak_ipl_python_interface.FloatArray9_size(self)

    def swap(self, v: "FloatArray9") -> "None":
        return _ids_peak_ipl_python_interface.FloatArray9_swap(self, v)

    def begin(self) -> "Any":
        return _ids_peak_ipl_python_interface.FloatArray9_begin(self)

    def end(self) -> "Any":
        return _ids_peak_ipl_python_interface.FloatArray9_end(self)

    def rbegin(self) -> "Any":
        return _ids_peak_ipl_python_interface.FloatArray9_rbegin(self)

    def rend(self) -> "Any":
        return _ids_peak_ipl_python_interface.FloatArray9_rend(self)

    def front(self) -> "Any":
        return _ids_peak_ipl_python_interface.FloatArray9_front(self)

    def back(self) -> "Any":
        return _ids_peak_ipl_python_interface.FloatArray9_back(self)

    def fill(self, u: "Any") -> "None":
        return _ids_peak_ipl_python_interface.FloatArray9_fill(self, u)
    __swig_destroy__ = _ids_peak_ipl_python_interface.delete_FloatArray9

# Register FloatArray9 in _ids_peak_ipl_python_interface:
_ids_peak_ipl_python_interface.FloatArray9_swigregister(FloatArray9)

