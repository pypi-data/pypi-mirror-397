# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
import os
import shutil
from datetime import datetime
from typing import Any

from hatchling.builders.hooks.plugin.interface import BuildHookInterface


class HatchCustomBuildHook(BuildHookInterface):
    """
    This class implements Hatch's [custom build hook] (https://hatch.pypa.io/1.6/plugins/build-hook/custom/)
    for a copy_version_py operation that copies the _version.py file generated by the hatch-vcs build hook into
    specified destination directories. See the `[[tool.hatch.build.hooks.custom]]` section in `pyproject.toml`.
    """

    def _validate_config(self):
        if sorted(self.config) != ["copy_version_py", "path"] or list(
            self.config["copy_version_py"]
        ) != ["destinations"]:
            raise RuntimeError(
                "Configuration of the custom build hook must be like { 'copy_version_py': {'destinations': ['path1', ...]}}."
                + f" Received:\n{self.config}"
            )

    def initialize(self, version: str, build_data: dict[str, Any]) -> None:
        self._validate_config()

        # Append release_date to _version.py after hatch-vcs generates it
        version_file = os.path.join(self.root, "_version.py")
        with open(version_file, "a", encoding="utf-8") as f:
            release_date = datetime.today().strftime("%B %d, %Y")
            f.write(f"\n__release_date__ = release_date = '{release_date}'\n")

        for destination in self.config["copy_version_py"]["destinations"]:
            print(f"Copying _version.py to {destination}")
            shutil.copy(
                os.path.join(self.root, "_version.py"),
                os.path.join(self.root, destination),
            )

    def clean(self, versions: list[str]) -> None:
        self._validate_config()

        cleaned_count = 0
        for destination in self.config["copy_version_py"]["destinations"]:
            print(f"Cleaning _version.py from {destination}")
            clean_path = os.path.join(self.root, destination, "_version.py")
            try:
                os.remove(clean_path)
                cleaned_count += 1
            except FileNotFoundError:
                pass
        print(f"Cleaned {cleaned_count} items")
