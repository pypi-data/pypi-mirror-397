{
  "json_schema_major_version": "1",
  "json_schema_minor_version": "2",
  "json_content_version": "1",
  "function_name": "TD_GLM",
  "function_version": "1.0",
  "function_type": "fastpath",
  "function_category": "Model Training",
  "function_alias_name": "TD_GLM",
  "function_r_name": "aa.td_glm",
  "ref_function_r_name": "aa.td_glm",
  "short_description": "This function generates one or more generalized linear models.",
  "long_description": "This function generates one or more generalized linear models.",
  "input_tables": [
    {
      "requiredInputKind": [
        "PartitionByAny",
        "PartitionByKey"
      ],
      "isOrdered": false,
      "partitionByOne": false,
      "name": "inputtable",
      "alternateNames": [],
      "isRequired": true,
      "rDescription": "Specifies the table containing the input data.",
      "description": "Specifies the table containing the input data.",
      "datatype": "TABLE_ALIAS",
      "allowsLists": false,
      "rName": "data",
      "useInR": true,
      "rOrderNum": 1
    },
    {
      "requiredInputKind": [
        "PartitionByKey"
      ],
      "isOrdered": false,
      "partitionByOne": false,
      "name": "AttributeTable",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specifies the name of the attribute table. This is valid when InputTable is partition by key. ",
      "description": "Specifies the name of the attribute table. This is valid when InputTable is partition by key. ",
      "datatype": "TABLE_ALIAS",
      "allowsLists": false,
      "rName": "attribute.table",
      "useInR": true,
      "rOrderNum": 2
    },
    {
      "requiredInputKind": [
        "PartitionByKey"
      ],
      "isOrdered": false,
      "partitionByOne": false,
      "name": "ParameterTable",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specifies the name of the parameter table. This is valid when InputTable is partition by key. ",
      "description": "Specifies the name of the parameter table. This is valid when InputTable is partition by key. ",
      "datatype": "TABLE_ALIAS",
      "allowsLists": false,
      "rName": "parameter.table",
      "useInR": true,
      "rOrderNum": 3
    }
  ],
  "output_tables": [
    {
      "isOutputTable": true,
      "omitPossible": false,
      "name": "MetaInformationTable",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specifies the name of the table in which the training progress information per iteration is stored. This is valid when InputTable is partition by any. ",
      "description": "Specifies the name of the table in which the training progress information per iteration is stored. This is valid when InputTable is partition by any. ",
      "datatype": "TABLE_NAME",
      "allowsLists": false,
      "rName": "output.table",
      "useInR": true,
      "rOrderNum": 2
    }
  ],
  "argument_clauses": [
    {
      "targetTable": [
        "inputtable"
      ],
      "checkDuplicate": true,
      "allowedTypes": [],
      "allowedTypeGroups": [
        "NUMERIC"
      ],
      "matchLengthOfArgument": "",
      "allowPadding": false,
      "name": "InputColumns",
      "alternateNames": [],
      "isRequired": true,
      "rDescription": "Specify the names of the input table columns that need to be used for training the model (predictors, features or independent variables).",
      "description": "Specify the names of the input table columns that need to be used for training the model (predictors, features or independent variables).",
      "datatype": "COLUMNS",
      "allowsLists": true,
      "rName": "input.columns",
      "useInR": true,
      "rFormulaUsage": true,
      "rOrderNum": -1
    },
    {
      "targetTable": [
        "inputtable"
      ],
      "checkDuplicate": true,
      "allowedTypes": [],
      "allowedTypeGroups": [
        "NUMERIC"
      ],
      "matchLengthOfArgument": "",
      "allowPadding": false,
      "name": "ResponseColumn",
      "alternateNames": [],
      "isRequired": true,
      "rDescription": "Specify the name of the column that contains the class label for classification or target value (dependent variable) for regression.",
      "description": "Specify the name of the column that contains the class label for classification or target value (dependent variable) for regression.",
      "datatype": "COLUMNS",
      "allowsLists": false,
      "rName": "response.column",
      "useInR": true,
      "rFormulaUsage": true,
      "rOrderNum": 0
    },
    {
      "defaultValue": "GAUSSIAN",
      "permittedValues": [
        "BINOMIAL",
        "GAUSSIAN"
      ],
      "isOutputColumn": false,
      "name": "Family",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the distribution exponential family. Acceptable values are Gaussian, Binomial.",
      "description": "Specify the distribution exponential family. Acceptable values are Gaussian, Binomial.",
      "datatype": "STRING",
      "allowsLists": false,
      "rName": "family",
      "useInR": true,
      "rOrderNum": 3
    },
    {
      "defaultValue": 300,
      "lowerBound": 1,
      "upperBound": 10000000,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "MaxIterNum",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the maximum number of iterations over the training data batches. If the batch size is 0, MaxIterNum equals the number of epochs (an epoch is a single pass over entire training data). If there are 1000 rows in an AMP, and batch size is 10, then 100 iterations will result into one epoch and 500 iterations will result into 5 epochs over this AMP’s data. Because it is not guaranteed that the data will be equally distributed on all AMPs, this may result into different number of epochs for other AMPs. Must be a positive value less than 10,000,000.",
      "description": "Specify the maximum number of iterations over the training data batches. If the batch size is 0, MaxIterNum equals the number of epochs (an epoch is a single pass over entire training data). If there are 1000 rows in an AMP, and batch size is 10, then 100 iterations will result into one epoch and 500 iterations will result into 5 epochs over this AMP’s data. Because it is not guaranteed that the data will be equally distributed on all AMPs, this may result into different number of epochs for other AMPs. Must be a positive value less than 10,000,000.",
      "datatype": "INTEGER",
      "allowsLists": false,
      "rName": "iter.max",
      "useInR": true,
      "rOrderNum": 4
    },
    {
      "defaultValue": 10,
      "lowerBound": 0,
      "upperBound": 2147483647,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "BatchSize",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the number of observations ( training samples ) to be parsed in one mini-batch. Must be a non-negative integer value. A value of 0 indicates no mini-batches, the entire dataset is processed in each iteration, and the algorithm becomes Gradient Descent. A value higher than the number of rows on any AMP will also default to Gradient Descent.",
      "description": "Specify the number of observations ( training samples ) to be parsed in one mini-batch. Must be a non-negative integer value. A value of 0 indicates no mini-batches, the entire dataset is processed in each iteration, and the algorithm becomes Gradient Descent. A value higher than the number of rows on any AMP will also default to Gradient Descent.",
      "datatype": "INTEGER",
      "allowsLists": false,
      "rName": "batch.size",
      "useInR": true,
      "rOrderNum": 5
    },
    {
      "defaultValue": 0.02,
      "lowerBound": 0,
      "upperBound": 1e7,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "RegularizationLambda",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the amount of regularization to be added. The higher the value, the stronger the regularization. It is also used to compute the learning rate when the learning rate is set to ‘optimal’. Must be a non-negative float value. A value of 0 means no regularization.",
      "description": "Specify the amount of regularization to be added. The higher the value, the stronger the regularization. It is also used to compute the learning rate when the learning rate is set to ‘optimal’. Must be a non-negative float value. A value of 0 means no regularization.",
      "datatype": "DOUBLE",
      "allowsLists": false,
      "rName": "lambda1",
      "useInR": true,
      "rOrderNum": 6
    },
    {
      "defaultValue": 0.15,
      "lowerBound": 0,
      "upperBound": 1,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "Alpha",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the Elasticnet parameter for penalty computation. It only becomes effective if RegularizationLambda > 0. The value represents the contribution ratio of L1 in the penalty. A value of 1.0 indicates L1 (LASSO) only, a value of 0 indicates L2 (Ridge) only, and a value in between is a combination of L1 and L2. Default: 0.15 (15% L1, 85% L2). Must be a float value between 0 and 1.",
      "description": "Specify the Elasticnet parameter for penalty computation. It only becomes effective if RegularizationLambda > 0. The value represents the contribution ratio of L1 in the penalty. A value of 1.0 indicates L1 (LASSO) only, a value of 0 indicates L2 (Ridge) only, and a value in between is a combination of L1 and L2. Default: 0.15 (15% L1, 85% L2). Must be a float value between 0 and 1.",
      "datatype": "DOUBLE",
      "allowsLists": false,
      "rName": "alpha",
      "useInR": true,
      "rOrderNum": 7
    },
    {
      "defaultValue": 50,
      "lowerBound": 0,
      "upperBound": 2147483647,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "IterNumNoChange",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the number of iterations (batches) with no improvement in loss (including the tolerance) to stop training (early stopping). Must be a non-negative integer. A value of 0 indicates no early stopping and the algorithm will continue till MaxIterNum iterations are reached.",
      "description": "Specify the number of iterations (batches) with no improvement in loss (including the tolerance) to stop training (early stopping). Must be a non-negative integer. A value of 0 indicates no early stopping and the algorithm will continue till MaxIterNum iterations are reached.",
      "datatype": "INTEGER",
      "allowsLists": false,
      "rName": "iter.num.no.change",
      "useInR": true,
      "rOrderNum": 8
    },
    {
      "defaultValue": 0.001,
      "lowerBound": 1e-7,
      "upperBound": 1e7,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "Tolerance",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the stopping criteria in terms of loss function improvement. Only applicable when IterNumNoChange > 0. Training stops when loss > best_loss – tolerance for IterNumNoChange times. Must be a non-negative value.",
      "description": "Specify the stopping criteria in terms of loss function improvement. Only applicable when IterNumNoChange > 0. Training stops when loss > best_loss – tolerance for IterNumNoChange times. Must be a non-negative value.",
      "datatype": "DOUBLE",
      "allowsLists": false,
      "rName": "tolerance",
      "useInR": true,
      "rOrderNum": 9
    },
    {
      "defaultValue": true,
      "name": "Intercept",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify whether intercept should be estimated or not (based on whether data is already centered or not).",
      "description": "Specify whether intercept should be estimated or not (based on whether data is already centered or not).",
      "datatype": "BOOLEAN",
      "allowsLists": false,
      "rName": "intercept",
      "useInR": true,
      "rOrderNum": 10
    },
    {
      "defaultValue": "0:1.0, 1:1.0",
      "isOutputColumn": false,
      "name": "ClassWeights",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify weights associated with classes. Only applicable for Binomial Family. The format is ‘0:weight,1:weight’. For example, ‘0:1.0,1:0.5’ will give twice the weight to each observation in class 0. If the weight of a class is omitted, it is assumed to be 1.0.",
      "description": "Specify weights associated with classes. Only applicable for Binomial Family. The format is ‘0:weight,1:weight’. For example, ‘0:1.0,1:0.5’ will give twice the weight to each observation in class 0. If the weight of a class is omitted, it is assumed to be 1.0.",
      "datatype": "STRING",
      "allowsLists": false,
      "rName": "class.weights",
      "useInR": true,
      "rOrderNum": 11
    },
    {
      "permittedValues": [
        "CONSTANT", 
        "OPTIMAL", 
        "INVTIME", 
        "ADAPTIVE"
      ],
      "isOutputColumn": false,
      "name": "LearningRate",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the learning rate algorithm for SGD iterations.",
      "description": "Specify the learning rate algorithm for SGD iterations.",
      "datatype": "STRING",
      "allowsLists": false,
      "rName": "learning.rate",
      "useInR": true,
      "rOrderNum": 12
    },
    {
      "defaultValue": 0.05,
      "lowerBound": 1e-7,
      "upperBound": 1e7,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "InitialEta",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the initial value of eta for the learning rate. For ‘constant’, this value is the learning rate for all iterations. ",
      "description": "Specify the initial value of eta for the learning rate. For ‘constant’, this value is the learning rate for all iterations. ",
      "datatype": "DOUBLE",
      "allowsLists": false,
      "rName": "initial.eta",
      "useInR": true,
      "rOrderNum": 13
    },
    {
      "defaultValue": 0.25,
      "lowerBound": 1e-7,
      "upperBound": 1e7,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "DecayRate",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the decay rate for the learning rate (invtime and adaptive).",
      "description": "Specify the decay rate for the learning rate (invtime and adaptive).",
      "datatype": "DOUBLE",
      "allowsLists": false,
      "rName": "decay.rate",
      "useInR": true,
      "rOrderNum": 14
    },
    {
      "defaultValue": 5,
      "lowerBound": 1,
      "upperBound": 2147483647,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "DecaySteps",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the decay steps (number of iterations) for the ‘adaptive’ learning rate. The learning rate changes by decay rate after this many number of iterations.",
      "description": "Specify the decay steps (number of iterations) for the ‘adaptive’ learning rate. The learning rate changes by decay rate after this many number of iterations.",
      "datatype": "INTEGER",
      "allowsLists": false,
      "rName": "decay.steps",
      "useInR": true,
      "rOrderNum": 15
    },
    {
      "defaultValue": 0.0,
      "lowerBound": 0,
      "upperBound": 1,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "Momentum",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the value to use for the momentum learning rate optimizer. Must be a non-negative float value between 0 and 1. A larger value indicates a higher momentum contribution. A value of 0 means the momentum optimizer is disabled.  For a good momentum contribution, a value between 0.6-0.95 is recommended.",
      "description": "Specify the value to use for the momentum learning rate optimizer. Must be a non-negative float value between 0 and 1. A larger value indicates a higher momentum contribution. A value of 0 means the momentum optimizer is disabled.  For a good momentum contribution, a value between 0.6-0.95 is recommended.",
      "datatype": "DOUBLE",
      "allowsLists": false,
      "rName": "momentum",
      "useInR": true,
      "rOrderNum": 16
    },
    {
      "defaultValue": true,
      "name": "Nesterov",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify whether Nesterov optimization should be applied to the momentum optimizer or not. Only applicable when momentum > 0.",
      "description": "Specify whether Nesterov optimization should be applied to the momentum optimizer or not. Only applicable when momentum > 0.",
      "datatype": "BOOLEAN",
      "allowsLists": false,
      "rName": "nesterov",
      "useInR": true,
      "rOrderNum": 17
    },
    {
      "defaultValue": 0,
      "lowerBound": 0,
      "upperBound": 1e7,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "LocalSGDIterations",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the number of local iterations to be used for Local SGD algorithm. Must be a positive integer value. A value of 0 implies Local SGD is disabled. A value higher than 0 enables Local SGD and that many local iterations are performed before updating the weights for the global model. With Local SGD algorithm, recommended values for arguments are as follows: LocalSGDIterations: 10, MaxIterNum: 100, BatchSize: 50, IterNumNoChange: 5. This is valid when InputTable is partition by any. ",
      "description": "Specify the number of local iterations to be used for Local SGD algorithm. Must be a positive integer value. A value of 0 implies Local SGD is disabled. A value higher than 0 enables Local SGD and that many local iterations are performed before updating the weights for the global model. With Local SGD algorithm, recommended values for arguments are as follows: LocalSGDIterations: 10, MaxIterNum: 100, BatchSize: 50, IterNumNoChange: 5. This is valid when InputTable is partition by any. ",
      "datatype": "INTEGER",
      "allowsLists": false,
      "rName": "local.sgd.iterations",
      "useInR": true,
      "rOrderNum": 18
    },
    {
      "permittedValues": [
        "FORWARD",
        "BACKWARD",
        "BOTH",
        "BIDIRECTIONAL"
      ],
      "isOutputColumn": false,
      "name": "StepwiseDirection",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the type of algorithm to be used. Acceptable values are 'forward', 'backward', 'both', and 'bidirectional'. This is valid when InputTable is partition by any. ",
      "description": "Specify the type of algorithm to be used. Acceptable values are 'forward', 'backward', 'both', and 'bidirectional'. This is valid when InputTable is partition by any. ",
      "datatype": "STRING",
      "allowsLists": false,
      "rName": "stepwise.direction",
      "useInR": true,
      "rOrderNum": 19
    },
    {
      "defaultValue": 5,
      "lowerBound": 1,
      "upperBound": 2147483647,
      "lowerBoundType": "INCLUSIVE",
      "upperBoundType": "INCLUSIVE",
      "allowNaN": false,
      "name": "MaxStepsNum",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the maximum number of steps to be used for the Stepwise Algorithm. This is valid when InputTable is partition by any. ",
      "description": "Specify the maximum number of steps to be used for the Stepwise Algorithm. This is valid when InputTable is partition by any. ",
      "datatype": "INTEGER",
      "allowsLists": false,
      "rName": "max.steps.num",
      "useInR": true,
      "rOrderNum": 20
    },
    {
      "targetTable": [
        "inputtable"
      ],
      "checkDuplicate": true,
      "allowedTypes": [],
      "allowedTypeGroups": [
        "NUMERIC"
      ],
      "matchLengthOfArgument": "",
      "allowPadding": false,
      "name": "InitialStepwiseColumns",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the names of the initial state model columns that need to be used as starting point for Stepwise Regression algorithm (predictors, features or independent variables). This is valid when InputTable is partition by any. ",
      "description": "Specify the names of the initial state model columns that need to be used as starting point for Stepwise Regression algorithm (predictors, features or independent variables). This is valid when InputTable is partition by any. ",
      "datatype": "COLUMNS",
      "allowsLists": true,
      "rName": "initial.stepwise.columns",
      "useInR": true,
      "rFormulaUsage": true,
      "rOrderNum": 21
    },
    {
      "permittedValues": [
        "BATCH",
        "EPOCH"
      ],
      "defaultValue": "BATCH",
      "isOutputColumn": false,
      "name": "IterationMode",
      "alternateNames": [],
      "isRequired": false,
      "rDescription": "Specify the iteration mode. Acceptable values are Batch, Epoch, where Batch is one iteration per batch and Epoch is one iteration per epoch. This is valid when InputTable is partition by key. ",
      "description": "Specify the iteration mode. Acceptable values are Batch, Epoch, where Batch is one iteration per batch and Epoch is one iteration per epoch. This is valid when InputTable is partition by key. ",
      "datatype": "STRING",
      "allowsLists": false,
      "rName": "iteration.mode",
      "useInR": true,
      "rOrderNum": 22
    },
    {
        "targetTable": [
          "InputTable"
        ],
        "checkDuplicate": false,
        "allowedTypes": [],
        "allowedTypeGroups": [
          "STRING"
        ],
        "matchLengthOfArgument": "",
        "allowPadding": false,
        "name": "PartitionColumn",
        "alternateNames": [],
        "isRequired": false,
        "rDescription": "Specify the name of the InputTable columns on which to partition the input. The name should be consistent with the partition_by_column in the ON clause. If the partition_by_column is unicode with foreign language characters, it is necessary to specify PartitionColumn argument. Note: Column range is not supported for PartitionColumn argument. This is valid when InputTable is partition by key. ",
        "description": "Specify the name of the InputTable columns on which to partition the input. The name should be consistent with the partition_by_column in the ON clause. If the partition_by_column is unicode with foreign language characters, it is necessary to specify PartitionColumn argument. Note: Column range is not supported for PartitionColumn argument. This is valid when InputTable is partition by key. ",
        "datatype": "COLUMNS",
        "allowsLists": false,
        "rName": "partition.column",
        "useInR": true,
        "rOrderNum": 23
    }
  ]
}