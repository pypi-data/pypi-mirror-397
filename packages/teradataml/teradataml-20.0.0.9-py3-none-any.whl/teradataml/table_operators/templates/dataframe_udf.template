import sys, csv
import datetime
import decimal

td_buffer = {{}}

{ARRAY_UTILITY_FUNCTIONS}

{FUNCTION_DEFINITION}

function_args = {FUNCTION_ARGS}
# Information that is required to help with the script usage.
#  The delimiter to use with the input and output text.
delimiter = "{DELIMITER}"
#  The names of columns in the input teradataml DataFrame.
_input_columns = {INPUT_COLUMNS}
#  The names of columns in the output teradataml DataFrame.
_output_columns = {OUTPUT_COLUMNS}
#  The definition for new columns in output.
columns_definitions = {COLUMNS_DEFINITIONS}
#  The types of columns in the input/output teradataml DataFrame.
output_type_converters = {OUTPUT_TYPE_CONVERTERS}
#  The original column types mapping for array type handling.
_column_types = {COLUMN_TYPES}
for k,v in output_type_converters.items():
    if v == 'datetime.date' or v == 'datetime.time' or v == 'datetime.datetime':
        output_type_converters[k] = 'str'
output_type_converters = {{
    k: (decimal.Decimal if v == 'decimal.Decimal' else getattr(__builtins__, v))
    for k, v in output_type_converters.items()
}}
#  The quotechar to use.
quotechar = "{QUOTECHAR}"
if quotechar == "None":
    quotechar = None


# The entry point to the script.
if __name__ == "__main__":

    records = csv.reader(sys.stdin.readlines(), delimiter=delimiter, quotechar=quotechar)
    for record in records:
        record = [''] if len(record)==0 else record
        record = dict(zip(_input_columns, record))
        out_rec = []
        for column in _output_columns:

            # If it is a new column, get the value from definition.
            if column in columns_definitions:
                f_args = tuple()
                # Convert the argument types first.
                for v in function_args[column]:
                    if v in _input_columns:
                        c_type_ = output_type_converters.get(v)
                        if record[v]:
                            # If it is a float, replace the empty character.
                            if c_type_.__name__ == 'float':
                                arg = output_type_converters.get(v)(record[v].replace(' ', ''))
                            else:
                                arg = output_type_converters.get(v)(record[v])
                        else:
                            arg = record[v] if c_type_.__name__ == 'str' else None
                    else:
                        arg = v
                    f_args = f_args + (arg, )
                
                func_name = columns_definitions[column]
                func_ = globals()[func_name]
                
                # Check if this is an array UDF function that supports column_type parameter
                array_udfs = ['td_array_sort', 'td_array_join', 'td_array_slice', 'td_array_overlap',
                              'td_array_insert', 'td_array_remove', 'td_array_distinct', 'td_array_intersect',
                              'td_array_union', 'td_array_except', 'td_array_compact', 'td_array_position',
                              'td_shuffle', 'td_array_reverse', 'td_sequence', 'td_array_repeat'] 
                if func_name in array_udfs:
                    # For supported array UDF functions, pass the column type as the last argument
                    column_type = _column_types.get(function_args[column][0]) if function_args[column][0] in _column_types else None
                    f_args = f_args + (column_type,)
                
                func_res = func_(*f_args)
                out_rec.append(output_type_converters[column](func_res) if func_res != '' else '')
            else:
                out_rec.append(record[column])

        print("{{}}".format(delimiter).join((str(i) for i in out_rec)))
