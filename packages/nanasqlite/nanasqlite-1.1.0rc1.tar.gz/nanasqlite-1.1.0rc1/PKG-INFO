Metadata-Version: 2.4
Name: nanasqlite
Version: 1.1.0rc1
Summary: A dict-like SQLite wrapper with APSW for instant persistence and memory caching
Author-email: Disnana <support@disnana.com>
License-Expression: MIT
Project-URL: Homepage, https://github.com/disnana/nanasqlite
Project-URL: Documentation, https://github.com/disnana/nanasqlite/tree/main/docs
Project-URL: Repository, https://github.com/disnana/nanasqlite
Project-URL: Issues, https://github.com/disnana/nanasqlite/issues
Keywords: sqlite,apsw,dict,database,persistence,cache,key-value,nosql
Classifier: Development Status :: 5 - Production/Stable
Classifier: Intended Audience :: Developers
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Classifier: Programming Language :: Python :: 3.14
Classifier: Topic :: Database
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Typing :: Typed
Requires-Python: >=3.9
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: apsw>=3.40.0.0
Provides-Extra: dev
Requires-Dist: pytest>=7.0.0; extra == "dev"
Requires-Dist: pytest-cov>=4.0.0; extra == "dev"
Requires-Dist: pytest-asyncio<1.0.0,>=0.21.0; extra == "dev"
Requires-Dist: pydantic>=2.0.0; extra == "dev"
Dynamic: license-file

# NanaSQLite

[![PyPI version](https://img.shields.io/pypi/v/nanasqlite.svg)](https://pypi.org/project/nanasqlite/)
[![Python versions](https://img.shields.io/pypi/pyversions/dictsqlite.svg)](https://pypi.org/project/nanasqlite/)
[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](https://opensource.org/licenses/MIT)
[![Downloads](https://static.pepy.tech/badge/nanasqlite)](https://pepy.tech/project/nanasqlite)
[![Tests](https://github.com/disnana/nanasqlite/actions/workflows/test.yml/badge.svg)](https://github.com/disnana/nanasqlite/actions/workflows/test.yml)

**A dict-like SQLite wrapper with instant persistence and intelligent caching.**

[English](#english) | [æ—¥æœ¬èª](#æ—¥æœ¬èª)

---

## English

### ğŸš€ Features

- **Dict-like Interface**: Use familiar `db["key"] = value` syntax
- **Instant Persistence**: All writes are immediately saved to SQLite
- **Smart Caching**: Lazy load (on-access) or bulk load (all at once)
- **Nested Structures**: Full support for nested dicts and lists (up to 30+ levels)
- **High Performance**: WAL mode, mmap, and batch operations for maximum speed
- **Zero Configuration**: Works out of the box with sensible defaults

### ğŸ“¦ Installation

```bash
pip install nanasqlite
```

### âš¡ Quick Start

```python
from nanasqlite import NanaSQLite

# Create or open a database
db = NanaSQLite("mydata.db")

# Use it like a dict
db["user"] = {"name": "Nana", "age": 20, "tags": ["admin", "active"]}
print(db["user"])  # {'name': 'Nana', 'age': 20, 'tags': ['admin', 'active']}

# Data persists automatically
db.close()

# Reopen later - data is still there!
db = NanaSQLite("mydata.db")
print(db["user"]["name"])  # 'Nana'
```

### ğŸ”§ Advanced Usage

```python
# Bulk load for faster repeated access
db = NanaSQLite("mydata.db", bulk_load=True)

# Batch operations for high-speed writes
db.batch_update({
    "key1": "value1",
    "key2": "value2",
    "key3": {"nested": "data"}
})

# Context manager support
with NanaSQLite("mydata.db") as db:
    db["temp"] = "value"
```

### ğŸ“š Documentation

- [English Documentation](docs/en/README.md)
- [API Reference](docs/en/reference.md)

### âœ¨ New Features (v1.0.3rc3+)

**Pydantic Support:**
```python
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int

db.set_model("user", User(name="Nana", age=20))
user = db.get_model("user", User)
```

**Direct SQL Execution:**
```python
# Execute custom SQL
cursor = db.execute("SELECT * FROM data WHERE key LIKE ?", ("user%",))
rows = db.fetch_all("SELECT key, value FROM data")
```

**SQLite Wrapper Functions:**
```python
# Create tables and indexes easily
db.create_table("users", {
    "id": "INTEGER PRIMARY KEY",
    "name": "TEXT NOT NULL",
    "email": "TEXT UNIQUE"
})
db.create_index("idx_users_email", "users", ["email"])

# Simple queries
results = db.query(table_name="users", where="age > ?", parameters=(20,))
```

### âœ¨ Additional Features (v1.0.3rc4+)

**22 new wrapper functions for comprehensive SQLite operations:**

```python
# Data operations
rowid = db.sql_insert("users", {"name": "Alice", "age": 25})
db.sql_update("users", {"age": 26}, "name = ?", ("Alice",))
db.upsert("users", {"id": 1, "name": "Alice", "age": 25})
total = db.count("users", "age >= ?", (18,))

# Query extensions (pagination, grouping)
page2 = db.query_with_pagination("users", limit=10, offset=10)
stats = db.query_with_pagination("orders", 
    columns=["user_id", "COUNT(*) as count"], group_by="user_id")

# Schema management
db.alter_table_add_column("users", "phone", "TEXT")
schema = db.get_table_schema("users")
db.drop_table("old_table", if_exists=True)

# Utilities & transactions
db.vacuum()  # Optimize database
with db.transaction():
    db.sql_insert("logs", {"message": "Event"})
```

### âœ¨ Multi-Table Support (v1.1.0dev1+)

**Safely operate multiple tables in the same database with shared connections:**

```python
from nanasqlite import NanaSQLite

# Create main table instance
main_db = NanaSQLite("mydata.db", table="users")

# Get another table instance sharing the same connection
products_db = main_db.table("products")
orders_db = main_db.table("orders")

# Each table has isolated cache and operations
main_db["user1"] = {"name": "Alice", "email": "alice@example.com"}
products_db["prod1"] = {"name": "Laptop", "price": 999}
orders_db["order1"] = {"user": "user1", "product": "prod1"}

# Thread-safe concurrent writes to different tables
from concurrent.futures import ThreadPoolExecutor

def write_users(i):
    main_db[f"user{i}"] = {"name": f"User{i}"}

def write_products(i):
    products_db[f"prod{i}"] = {"name": f"Product{i}"}

with ThreadPoolExecutor(max_workers=10) as executor:
    executor.map(write_users, range(100))
    executor.map(write_products, range(100))

# Close only the main instance (closes shared connection)
main_db.close()
```

**Key features:**
- **Shared connection & lock**: All table instances share the same SQLite connection and thread lock
- **Thread-safe**: Concurrent writes to different tables are safely synchronized
- **Memory efficient**: Reuses connections instead of creating new ones
- **Isolated cache**: Each table maintains its own memory cache
- **Works with async**: `await db.table("table_name")` for AsyncNanaSQLite

**âš ï¸ Important Usage Notes:**

1. **Do not create multiple instances for the same table:**
   ```python
   # âŒ Not recommended: Causes cache inconsistency
   users1 = db.table("users")
   users2 = db.table("users")  # Different cache, same DB table!
   
   # âœ… Recommended: Reuse the same instance
   users_db = db.table("users")
   # Use users_db throughout your code
   ```

2. **Use context managers to avoid issues after close:**
   ```python
   # âœ… Recommended: Proper cleanup with context manager
   with NanaSQLite("app.db", table="main") as main_db:
       sub_db = main_db.table("sub")
       sub_db["key"] = "value"
   # Automatically closed, no orphaned instances
   ```

3. **About chained table() calls:**
   ```python
   # âœ… Works: sub2 is created as a child of sub
   sub = db.table("sub")
   sub2 = sub.table("sub2")  # Creates sub2 table
   
   # âœ… More recommended: Get directly from parent
   sub = db.table("sub")
   sub2 = db.table("sub2")  # Clearer parent-child relationship
   ```

**Best Practices:**
- Store table instances in variables and reuse them
- Prefer context managers (`with` statement) for automatic resource management
- Close the parent instance when done (child instances share the same connection)

### âœ¨ Transaction Support & Error Handling (v1.1.0+)

**Enhanced transaction management with proper error handling:**

```python
from nanasqlite import NanaSQLite, NanaSQLiteTransactionError

db = NanaSQLite("mydata.db")

# Context manager (recommended - auto commit/rollback)
with db.transaction():
    db["key1"] = "value1"
    db["key2"] = "value2"
    # Automatically commits on success, rolls back on exception

# Manual transaction control
db.begin_transaction()
try:
    db.sql_insert("users", {"name": "Alice"})
    db.sql_insert("users", {"name": "Bob"})
    db.commit()
except Exception:
    db.rollback()

# Check transaction state
if not db.in_transaction():
    db.begin_transaction()
```

**Custom exceptions for better error handling:**

```python
from nanasqlite import (
    NanaSQLiteError,           # Base exception
    NanaSQLiteValidationError, # Invalid input/parameters
    NanaSQLiteDatabaseError,   # Database operation errors
    NanaSQLiteTransactionError,# Transaction-related errors
    NanaSQLiteConnectionError, # Connection errors
)

try:
    db = NanaSQLite("mydata.db")
    db.begin_transaction()
    # Nested transactions are not supported
    db.begin_transaction()  # Raises NanaSQLiteTransactionError
except NanaSQLiteTransactionError as e:
    print(f"Transaction error: {e}")
```

**âš ï¸ Important Usage Notes:**

1. **Do not create multiple instances for the same table:**
   ```python
   # âŒ BAD: Creates cache inconsistency
   users1 = db.table("users")
   users2 = db.table("users")  # Different cache, same DB table!
   
   # âœ… GOOD: Reuse the same instance
   users_db = db.table("users")
   # Use users_db throughout your code
   ```
   
   Each instance has its own independent cache. Multiple instances of the same table can lead to cache inconsistency at the memory level (though database writes remain correct).

2. **Use context managers to avoid issues after close:**
   ```python
   # âœ… RECOMMENDED: Context manager ensures proper cleanup
   with NanaSQLite("app.db", table="main") as main_db:
       sub_db = main_db.table("sub")
       sub_db["key"] = "value"
   # Automatically closed, no orphaned instances
   
   # âŒ AVOID: Manual close can leave orphaned sub-instances
   main_db = NanaSQLite("app.db")
   sub_db = main_db.table("sub")
   main_db.close()  # sub_db may still access cached data
   ```

**Best practices:**
- Store table instances in variables and reuse them
- Prefer context managers (`with` statement) for automatic resource management
- Close the parent instance when done; child instances share the same connection

### âœ¨ Async Support (v1.0.3rc7+)

**Full async/await support with optimized thread pool for high-performance non-blocking operations:**

```python
import asyncio
from nanasqlite import AsyncNanaSQLite

async def main():
    # Use async context manager with optimized thread pool
    async with AsyncNanaSQLite("mydata.db", max_workers=10) as db:
        # Async dict-like operations
        await db.aset("user", {"name": "Nana", "age": 20})
        user = await db.aget("user")
        print(user)  # {'name': 'Nana', 'age': 20}
        
        # Async batch operations
        await db.batch_update({
            "key1": "value1",
            "key2": "value2",
            "key3": {"nested": "data"}
        })
        
        # Concurrent operations (high-performance with thread pool)
        results = await asyncio.gather(
            db.aget("key1"),
            db.aget("key2"),
            db.aget("key3")
        )
        
        # Async SQL execution
        await db.create_table("users", {
            "id": "INTEGER PRIMARY KEY",
            "name": "TEXT",
            "age": "INTEGER"
        })
        await db.sql_insert("users", {"name": "Alice", "age": 25})
        users = await db.query("users", where="age > ?", parameters=(20,))
        
        # Multi-table support in async
        products_db = await db.table("products")
        await products_db.aset("prod1", {"name": "Laptop", "price": 999})
        
        # Async transaction support (v1.1.0+)
        async with db.transaction():
            await db.sql_insert("users", {"name": "Bob", "age": 30})
            await db.sql_insert("users", {"name": "Charlie", "age": 35})
            # Auto commit on success, rollback on exception

asyncio.run(main())
```

**Performance optimizations:**
- Dedicated thread pool executor (configurable with `max_workers`)
- APSW-based for maximum SQLite performance
- WAL mode and connection optimizations
- Ideal for high-concurrency scenarios

**Perfect for async frameworks:**
- FastAPI, Quart, Sanic (async web frameworks)
- aiohttp (async HTTP client/server)
- Discord.py, Telegram bots (async bots)
- Any asyncio-based application

---

## æ—¥æœ¬èª

### ğŸš€ ç‰¹å¾´

- **dicté¢¨ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹**: ãŠãªã˜ã¿ã® `db["key"] = value` æ§‹æ–‡ã§æ“ä½œ
- **å³æ™‚æ°¸ç¶šåŒ–**: æ›¸ãè¾¼ã¿ã¯å³åº§ã«SQLiteã«ä¿å­˜
- **ã‚¹ãƒãƒ¼ãƒˆã‚­ãƒ£ãƒƒã‚·ãƒ¥**: é…å»¶ãƒ­ãƒ¼ãƒ‰ï¼ˆã‚¢ã‚¯ã‚»ã‚¹æ™‚ï¼‰ã¾ãŸã¯ä¸€æ‹¬ãƒ­ãƒ¼ãƒ‰ï¼ˆèµ·å‹•æ™‚ï¼‰
- **ãƒã‚¹ãƒˆæ§‹é€ å¯¾å¿œ**: 30éšå±¤ä»¥ä¸Šã®ãƒã‚¹ãƒˆã—ãŸdict/listã‚’ã‚µãƒãƒ¼ãƒˆ
- **é«˜æ€§èƒ½**: WALãƒ¢ãƒ¼ãƒ‰ã€mmapã€ãƒãƒƒãƒæ“ä½œã§æœ€é«˜é€Ÿåº¦ã‚’å®Ÿç¾
- **è¨­å®šä¸è¦**: åˆç†çš„ãªãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®šã§ãã®ã¾ã¾å‹•ä½œ

### ğŸ“¦ ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«

```bash
pip install nanasqlite
```

### âš¡ ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¿ãƒ¼ãƒˆ

```python
from nanasqlite import NanaSQLite

# ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ä½œæˆã¾ãŸã¯é–‹ã
db = NanaSQLite("mydata.db")

# dictã®ã‚ˆã†ã«ä½¿ã†
db["user"] = {"name": "Nana", "age": 20, "tags": ["admin", "active"]}
print(db["user"])  # {'name': 'Nana', 'age': 20, 'tags': ['admin', 'active']}

# ãƒ‡ãƒ¼ã‚¿ã¯è‡ªå‹•çš„ã«æ°¸ç¶šåŒ–
db.close()

# å¾Œã§å†åº¦é–‹ã„ã¦ã‚‚ã€ãƒ‡ãƒ¼ã‚¿ã¯ãã®ã¾ã¾ï¼
db = NanaSQLite("mydata.db")
print(db["user"]["name"])  # 'Nana'
```

### ğŸ”§ é«˜åº¦ãªä½¿ã„æ–¹

```python
# ä¸€æ‹¬ãƒ­ãƒ¼ãƒ‰ã§ç¹°ã‚Šè¿”ã—ã‚¢ã‚¯ã‚»ã‚¹ã‚’é«˜é€ŸåŒ–
db = NanaSQLite("mydata.db", bulk_load=True)

# ãƒãƒƒãƒæ“ä½œã§é«˜é€Ÿæ›¸ãè¾¼ã¿
db.batch_update({
    "key1": "value1",
    "key2": "value2",
    "key3": {"nested": "data"}
})

# ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£å¯¾å¿œ
with NanaSQLite("mydata.db") as db:
    db["temp"] = "value"
```

### ğŸ“š ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [æ—¥æœ¬èªãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](docs/ja/README.md)
- [APIãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹](docs/ja/reference.md)

### âœ¨ æ–°æ©Ÿèƒ½ (v1.0.3rc3+)

**Pydanticäº’æ›æ€§:**
```python
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int

db.set_model("user", User(name="Nana", age=20))
user = db.get_model("user", User)
```

**ç›´æ¥SQLå®Ÿè¡Œ:**
```python
# ã‚«ã‚¹ã‚¿ãƒ SQLã®å®Ÿè¡Œ
cursor = db.execute("SELECT * FROM data WHERE key LIKE ?", ("user%",))
rows = db.fetch_all("SELECT key, value FROM data")
```

**SQLiteãƒ©ãƒƒãƒ‘ãƒ¼é–¢æ•°:**
```python
# ãƒ†ãƒ¼ãƒ–ãƒ«ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ç°¡å˜ã«ä½œæˆ
db.create_table("users", {
    "id": "INTEGER PRIMARY KEY",
    "name": "TEXT NOT NULL",
    "email": "TEXT UNIQUE"
})
db.create_index("idx_users_email", "users", ["email"])

# ã‚·ãƒ³ãƒ—ãƒ«ãªã‚¯ã‚¨ãƒª
results = db.query(table_name="users", where="age > ?", parameters=(20,))
```

### âœ¨ ãƒãƒ«ãƒãƒ†ãƒ¼ãƒ–ãƒ«ã‚µãƒãƒ¼ãƒˆ (v1.1.0dev1+)

**åŒä¸€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹å†…ã®è¤‡æ•°ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’æ¥ç¶šå…±æœ‰ã§å®‰å…¨ã«æ“ä½œ:**

```python
from nanasqlite import NanaSQLite

# ãƒ¡ã‚¤ãƒ³ãƒ†ãƒ¼ãƒ–ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆ
main_db = NanaSQLite("mydata.db", table="users")

# åŒã˜æ¥ç¶šã‚’å…±æœ‰ã™ã‚‹åˆ¥ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å–å¾—
products_db = main_db.table("products")
orders_db = main_db.table("orders")

# å„ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ç‹¬ç«‹ã—ãŸã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¨æ“ä½œã‚’æŒã¤
main_db["user1"] = {"name": "Alice", "email": "alice@example.com"}
products_db["prod1"] = {"name": "Laptop", "price": 999}
orders_db["order1"] = {"user": "user1", "product": "prod1"}

# ç•°ãªã‚‹ãƒ†ãƒ¼ãƒ–ãƒ«ã¸ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ãªä¸¦è¡Œæ›¸ãè¾¼ã¿
from concurrent.futures import ThreadPoolExecutor

def write_users(i):
    main_db[f"user{i}"] = {"name": f"User{i}"}

def write_products(i):
    products_db[f"prod{i}"] = {"name": f"Product{i}"}

with ThreadPoolExecutor(max_workers=10) as executor:
    executor.map(write_users, range(100))
    executor.map(write_products, range(100))

# ãƒ¡ã‚¤ãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ã¿ã‚’ã‚¯ãƒ­ãƒ¼ã‚ºï¼ˆå…±æœ‰æ¥ç¶šã‚’é–‰ã˜ã‚‹ï¼‰
main_db.close()
```

**ä¸»ãªç‰¹å¾´:**
- **æ¥ç¶šã¨ãƒ­ãƒƒã‚¯ã®å…±æœ‰**: å…¨ã¦ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒåŒã˜SQLiteæ¥ç¶šã¨ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã‚’å…±æœ‰
- **ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•**: ç•°ãªã‚‹ãƒ†ãƒ¼ãƒ–ãƒ«ã¸ã®ä¸¦è¡Œæ›¸ãè¾¼ã¿ãŒå®‰å…¨ã«åŒæœŸã•ã‚Œã‚‹
- **ãƒ¡ãƒ¢ãƒªåŠ¹ç‡**: æ–°ã—ã„æ¥ç¶šã‚’ä½œæˆã›ãšã€æ—¢å­˜ã®æ¥ç¶šã‚’å†åˆ©ç”¨
- **ã‚­ãƒ£ãƒƒã‚·ãƒ¥åˆ†é›¢**: å„ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ç‹¬è‡ªã®ãƒ¡ãƒ¢ãƒªã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ä¿æŒ
- **éåŒæœŸå¯¾å¿œ**: AsyncNanaSQLiteã§ã¯ `await db.table("table_name")` ã§ä½¿ç”¨å¯èƒ½

**âš ï¸ é‡è¦ãªä½¿ç”¨ä¸Šã®æ³¨æ„:**

1. **åŒã˜ãƒ†ãƒ¼ãƒ–ãƒ«ã«å¯¾ã—ã¦è¤‡æ•°ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ãªã„ã§ãã ã•ã„:**
   ```python
   # âŒ éæ¨å¥¨: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¸æ•´åˆã‚’å¼•ãèµ·ã“ã™
   users1 = db.table("users")
   users2 = db.table("users")  # ç•°ãªã‚‹ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã€åŒã˜DBãƒ†ãƒ¼ãƒ–ãƒ«ï¼
   
   # âœ… æ¨å¥¨: åŒã˜ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å†åˆ©ç”¨
   users_db = db.table("users")
   # ã‚³ãƒ¼ãƒ‰å…¨ä½“ã§users_dbã‚’ä½¿ç”¨ã™ã‚‹
   ```
   
   å„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯ç‹¬ç«‹ã—ãŸã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æŒã¡ã¾ã™ã€‚åŒã˜ãƒ†ãƒ¼ãƒ–ãƒ«ã«å¯¾ã—ã¦è¤‡æ•°ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã™ã‚‹ã¨ã€ãƒ¡ãƒ¢ãƒªãƒ¬ãƒ™ãƒ«ã§ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥ä¸æ•´åˆãŒç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼ˆãŸã ã—ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¸ã®æ›¸ãè¾¼ã¿ã¯æ­£ã—ãè¡Œã‚ã‚Œã¾ã™ï¼‰ã€‚

2. **closeå¾Œã®å•é¡Œã‚’é¿ã‘ã‚‹ãŸã‚ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„:**
   ```python
   # âœ… æ¨å¥¨: ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã§é©åˆ‡ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   with NanaSQLite("app.db", table="main") as main_db:
       sub_db = main_db.table("sub")
       sub_db["key"] = "value"
   # è‡ªå‹•çš„ã«ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚Œã€å­¤ç«‹ã—ãŸã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãªã—
   
   # âŒ éæ¨å¥¨: æ‰‹å‹•closeã¯å­¤ç«‹ã—ãŸã‚µãƒ–ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ®‹ã™å¯èƒ½æ€§
   main_db = NanaSQLite("app.db")
   sub_db = main_db.table("sub")
   main_db.close()  # sub_dbã¯ã¾ã ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ‡ãƒ¼ã‚¿ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹
   ```

3. **table()ã®ãƒã‚§ãƒ¼ãƒ³å‘¼ã³å‡ºã—ã«ã¤ã„ã¦:**
   ```python
   # âœ… å‹•ä½œã—ã¾ã™: sub2ã¯subã®å­ã¨ã—ã¦ä½œæˆã•ã‚Œã‚‹
   sub = db.table("sub")
   sub2 = sub.table("sub2")  # sub2ãƒ†ãƒ¼ãƒ–ãƒ«ãŒä½œæˆã•ã‚Œã‚‹
   
   # âœ… ã‚ˆã‚Šæ¨å¥¨: è¦ªã‹ã‚‰ç›´æ¥å–å¾—
   sub = db.table("sub")
   sub2 = db.table("sub2")  # ã‚ˆã‚Šæ˜ç¢ºãªè¦ªå­é–¢ä¿‚
   ```
   
   `table().table()`ã®ãƒã‚§ãƒ¼ãƒ³ã¯æŠ€è¡“çš„ã«ã¯å‹•ä½œã—ã¾ã™ãŒã€ä»¥ä¸‹ã®ç‚¹ã«æ³¨æ„ï¼š
   - ã™ã¹ã¦ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯åŒã˜æ¥ç¶šã‚’å…±æœ‰ã™ã‚‹ãŸã‚å®‰å…¨ã§ã™
   - `sub2`ã¯`sub`ã®å­ã¨ã—ã¦è¿½è·¡ã•ã‚Œã¾ã™ãŒã€å®Ÿéš›ã«ã¯åˆ¥ã®ãƒ†ãƒ¼ãƒ–ãƒ«ã§ã™
   - ã‚ˆã‚Šæ˜ç¢ºãªã‚³ãƒ¼ãƒ‰ã®ãŸã‚ã€ãƒ«ãƒ¼ãƒˆDBã‹ã‚‰ç›´æ¥ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’å–å¾—ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨

**ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹:**
- ãƒ†ãƒ¼ãƒ–ãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å¤‰æ•°ã«ä¿å­˜ã—ã¦å†åˆ©ç”¨ã™ã‚‹
- è‡ªå‹•ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†ã®ãŸã‚ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ï¼ˆ`with`æ–‡ï¼‰ã‚’å„ªå…ˆã™ã‚‹
- å®Œäº†æ™‚ã¯è¦ªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã™ã‚‹ï¼ˆå­ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¯åŒã˜æ¥ç¶šã‚’å…±æœ‰ï¼‰

### âœ¨ ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚µãƒãƒ¼ãƒˆã¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚° (v1.1.0+)

**é©åˆ‡ãªã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°æ©Ÿèƒ½ã‚’å‚™ãˆãŸå¼·åŒ–ã•ã‚ŒãŸãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ç®¡ç†:**

```python
from nanasqlite import NanaSQLite, NanaSQLiteTransactionError

db = NanaSQLite("mydata.db")

# ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ï¼ˆæ¨å¥¨ - è‡ªå‹•ã‚³ãƒŸãƒƒãƒˆ/ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
with db.transaction():
    db["key1"] = "value1"
    db["key2"] = "value2"
    # æˆåŠŸæ™‚ã¯è‡ªå‹•ã‚³ãƒŸãƒƒãƒˆã€ä¾‹å¤–ç™ºç”Ÿæ™‚ã¯è‡ªå‹•ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯

# æ‰‹å‹•ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³åˆ¶å¾¡
db.begin_transaction()
try:
    db.sql_insert("users", {"name": "Alice"})
    db.sql_insert("users", {"name": "Bob"})
    db.commit()
except Exception:
    db.rollback()

# ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã®ç¢ºèª
if not db.in_transaction():
    db.begin_transaction()
```

**ã‚ˆã‚Šè‰¯ã„ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®ãŸã‚ã®ã‚«ã‚¹ã‚¿ãƒ ä¾‹å¤–:**

```python
from nanasqlite import (
    NanaSQLiteError,           # åŸºåº•ä¾‹å¤–
    NanaSQLiteValidationError, # ä¸æ­£ãªå…¥åŠ›/ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    NanaSQLiteDatabaseError,   # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ“ä½œã‚¨ãƒ©ãƒ¼
    NanaSQLiteTransactionError,# ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³é–¢é€£ã‚¨ãƒ©ãƒ¼
    NanaSQLiteConnectionError, # æ¥ç¶šã‚¨ãƒ©ãƒ¼
)

try:
    db = NanaSQLite("mydata.db")
    db.begin_transaction()
    # ãƒã‚¹ãƒˆã—ãŸãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“
    db.begin_transaction()  # NanaSQLiteTransactionErrorã‚’ç™ºç”Ÿ
except NanaSQLiteTransactionError as e:
    print(f"ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")
```

### âœ¨ éåŒæœŸã‚µãƒãƒ¼ãƒˆ (v1.0.3rc7+)

**é«˜é€ŸåŒ–ã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ã«ã‚ˆã‚‹å®Œå…¨ãª async/await ã‚µãƒãƒ¼ãƒˆ:**

```python
import asyncio
from nanasqlite import AsyncNanaSQLite

async def main():
    # æœ€é©åŒ–ã•ã‚ŒãŸã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ã§éåŒæœŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒãƒãƒ¼ã‚¸ãƒ£ã‚’ä½¿ç”¨
    async with AsyncNanaSQLite("mydata.db", max_workers=10) as db:
        # éåŒæœŸdicté¢¨æ“ä½œ
        await db.aset("user", {"name": "Nana", "age": 20})
        user = await db.aget("user")
        print(user)  # {'name': 'Nana', 'age': 20}
        
        # éåŒæœŸãƒãƒƒãƒæ“ä½œ
        await db.batch_update({
            "key1": "value1",
            "key2": "value2",
            "key3": {"nested": "data"}
        })
        
        # ä¸¦è¡Œæ“ä½œï¼ˆã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ã«ã‚ˆã‚Šé«˜æ€§èƒ½ï¼‰
        results = await asyncio.gather(
            db.aget("key1"),
            db.aget("key2"),
            db.aget("key3")
        )
        
        # éåŒæœŸSQLå®Ÿè¡Œ
        await db.create_table("users", {
            "id": "INTEGER PRIMARY KEY",
            "name": "TEXT",
            "age": "INTEGER"
        })
        await db.sql_insert("users", {"name": "Alice", "age": 25})
        users = await db.query("users", where="age > ?", parameters=(20,))
        
        # éåŒæœŸã§ã®ãƒãƒ«ãƒãƒ†ãƒ¼ãƒ–ãƒ«ã‚µãƒãƒ¼ãƒˆ
        products_db = await db.table("products")
        await products_db.aset("prod1", {"name": "Laptop", "price": 999})
        
        # éåŒæœŸãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚µãƒãƒ¼ãƒˆ (v1.1.0+)
        async with db.transaction():
            await db.sql_insert("users", {"name": "Bob", "age": 30})
            await db.sql_insert("users", {"name": "Charlie", "age": 35})
            # æˆåŠŸæ™‚ã¯è‡ªå‹•ã‚³ãƒŸãƒƒãƒˆã€ä¾‹å¤–ç™ºç”Ÿæ™‚ã¯è‡ªå‹•ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯

asyncio.run(main())
```

**ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–:**
- å°‚ç”¨ã‚¹ãƒ¬ãƒƒãƒ‰ãƒ—ãƒ¼ãƒ«ã‚¨ã‚°ã‚¼ã‚­ãƒ¥ãƒ¼ã‚¿ãƒ¼ï¼ˆ`max_workers`ã§è¨­å®šå¯èƒ½ï¼‰
- é«˜æ€§èƒ½ãªAPSWãƒ™ãƒ¼ã‚¹
- WALãƒ¢ãƒ¼ãƒ‰ã¨æ¥ç¶šæœ€é©åŒ–
- é«˜ä¸¦è¡Œæ€§ã‚·ãƒŠãƒªã‚ªã«æœ€é©

**éåŒæœŸãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã«æœ€é©:**
- FastAPI, Quart, Sanicï¼ˆéåŒæœŸWebãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ï¼‰
- aiohttpï¼ˆéåŒæœŸHTTP ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ/ã‚µãƒ¼ãƒãƒ¼ï¼‰
- Discord.py, Telegramãƒœãƒƒãƒˆï¼ˆéåŒæœŸãƒœãƒƒãƒˆï¼‰
- ã‚ã‚‰ã‚†ã‚‹asyncioãƒ™ãƒ¼ã‚¹ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³

---

## License

MIT License - see [LICENSE](LICENSE) for details.
