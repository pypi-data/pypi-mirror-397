"""
Run Python code generated by an LLM in a given environment. Currently, supports local host and
E2B sandbox execution. Also, defines custom exceptions for security and environment errors.

User Code
    ↓
[1] Syntax Check (AST parse)
    ↓
[2] Import Whitelist
    ↓
[3] Pattern Detection - Catches obfuscation
    ↓
[4] LLM Review
    ↓
[5] Execute Code (locally or in Sandbox)
"""
import re
import warnings
from typing import Optional, Literal

from . import kutils as ku
from .code_reviewer import CodeSecurityReviewer
from .pattern_detector import analyze_code_patterns


CODE_ENV_NAMES = Literal['host', 'docker', 'e2b']
"""Allowed code execution environment names."""
DEFAULT_ALLOWED_IMPORTS = {
    'ast', 'operator', 're',  # calculator tool
    'time', 'random',
}
""" Default allowed imports for code execution."""
# Check for the use of dangerous builtins
DANGEROUS_BUILTINS = {'exec', 'eval', '__import__', 'compile'}
"""Dangerous built-in functions that are not allowed in code execution."""

logger = ku.get_logger()


class CodeSecurityError(Exception):
    """Exception raised for security violations in code execution."""


class UnknownCodeEnvError(Exception):
    """Exception raised for unknown code execution environments."""


class CodeRunner:
    """Run Python code generated by an LLM in a given environment."""
    def __init__(
            self,
            env: CODE_ENV_NAMES,
            allowed_imports: list[str],
            model_name: str,
            pip_packages: Optional[str] = None,
            timeout: int = 30,
            env_vars_to_set: Optional[dict[str, str]] = None,
            litellm_params: Optional[dict] = None
    ):
        """
        Create an environment to run Python code.

        Args:
            env: The code execution environment. Must be a string from `CODE_ENV_NAMES`.
            allowed_imports: A list of Python modules that are allowed to be imported.
            model_name: The LLM model name to use for security review.
            pip_packages: Optional Python libs to be installed by `pip` [E2B].
            timeout: Code execution timeout (default 30s).
            env_vars_to_set: Optional environment variables to set in the code execution
             environment (E2B only).
            litellm_params: Optional parameters for LiteLLM.
        """
        self.allowed_imports: set[str] = set(allowed_imports).union(DEFAULT_ALLOWED_IMPORTS)
        self.env: CODE_ENV_NAMES = env
        if pip_packages and len(pip_packages.strip()) > 0:
            self.pip_packages: list[str] = re.split('[,;]', pip_packages)
        else:
            self.pip_packages = []
        self.default_timeout = timeout
        self.local_modules_to_copy = []
        self.pip_packages_str = ' '.join(self.pip_packages) if self.pip_packages else None
        self.env_vars_to_set = env_vars_to_set
        self.code_reviewer = CodeSecurityReviewer(
            model_name=model_name,
            litellm_params=litellm_params
        )

    def check_imports(self, code: str) -> set[str]:
        """
        Check for disallowed imports in code.

        Args:
            code: The Python source code to check.

        Returns:
            A set of disallowed imported module names.
        """
        import ast

        tree = ast.parse(code)
        imported_modules = set()

        for node in ast.walk(tree):
            if isinstance(node, ast.Name) and node.id in DANGEROUS_BUILTINS:
                raise CodeSecurityError(f'Forbidden builtin: {node.id}')

        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imported_modules.add(alias.name)
            elif isinstance(node, ast.ImportFrom):
                imported_modules.add(node.module)

        logger.debug(
            'Imported modules found: %s // Allowed imports: %s',
            imported_modules, self.allowed_imports
        )
        disallowed = imported_modules - self.allowed_imports
        return disallowed

    async def run(self, tools_code: str, generated_code: str, task_id: str) -> tuple[str, str, int]:
        """
        Run Python code in pre-specified environment after security review.

        Args:
            tools_code: The Python source code for agent tools.
            generated_code: The Python source code generated to solve a task.
            task_id: Unique task identifier for tracking.

        Returns:
            A tuple of (stdout, stderr, return_code).

        Raises:
            UnknownCodeEnvError: If the specified environment is unsupported.
            CodeSecurityError: If the code fails security review.
        """
        import ast

        source_code = f'{tools_code}\n\n{generated_code}'

        try:
            ast.parse(source_code)
        except SyntaxError as se:
            return (
                '',
                f'Code parsing failed due to: {type(se).__name__}\n{se.text}\nError: {str(se)}',
                -1
            )

        disallowed_imports: set = self.check_imports(source_code)
        if len(disallowed_imports) > 0:
            modules = '\n'.join(list(disallowed_imports))
            logger.error('CodeRunner found disallowed imports: %s', modules)
            return (
                '',
                f'The following imports are disallowed:{modules}'
                '\nPlease only use the allowed modules for importing.',
                -1
            )

        # Security review before execution
        # We check only the AI-generated code; tools are assumed to be "safe"
        # At first, do a static analysis check for dangerous patterns in the generated code
        logger.debug('Performing static analysis of code...')
        is_safe, reason, _ = analyze_code_patterns(generated_code)
        if not is_safe:
            raise CodeSecurityError(f'Pattern detection blocked: {reason}')
       
        # If the code fails the static analysis, it is not executed
        # If the code passes the static analysis, do another round of check by the LLM
        logger.debug('Performing security review of code...')
        review_result = await self.code_reviewer.review(generated_code)
        if not review_result.is_secure:
            logger.error('Code failed security review: %s', review_result.reason)
            raise CodeSecurityError(
                f'Code execution blocked due to security concerns: {review_result.reason}'
            )
        logger.info('Code security review passed: %s', review_result.reason)

        if self.env == 'host':
            return self._run_code_host(source_code)

        if self.env =='e2b':
            return self._run_code_e2b(source_code, task_id)

        raise UnknownCodeEnvError(f'Unsupported code execution env: {self.env}')

    def _run_code_host(self, source_code: str) -> tuple[str, str, int]:
        """
        Run code on the host machine.

        Args:
            source_code: The Python source code to execute.

        Returns:
            A tuple of (stdout, stderr, return_code).
        """
        import os
        import shutil
        import subprocess as sp
        import sys
        import tempfile

        warnings.warn(
            'You are running LLM-generated code on your host. This could be potentially'
            ' dangerous! Please consider using a different code runner environment.',
            UserWarning
        )
        with tempfile.NamedTemporaryFile(
                mode='w+t', suffix='.py', delete=False, encoding='utf-8'
        ) as code_file:
            code_file.write(source_code)
            code_file.close()

            for a_file in self.local_modules_to_copy:
                shutil.copy2(
                    os.path.join(os.path.dirname(__file__), a_file),
                    tempfile.gettempdir()
                )

            result = sp.run(
                [sys.executable, code_file.name],
                shell=False, capture_output=True, text=True,
                timeout=self.default_timeout,
                check=False,
                encoding='utf-8'
            )
            os.remove(code_file.name)
            return result.stdout, result.stderr, result.returncode

    def _run_code_e2b(self, source_code: str, task_id: str) -> tuple[str, str, int]:
        """
        Run code in the E2B sandbox environment.

        Args:
            source_code: The Python source code to execute.
            task_id: Unique task identifier for tracking.

        Returns:
            A tuple of (stdout, stderr, return_code).
        """
        import os
        import sys

        try:
            import e2b_code_interpreter as e2b
        except ModuleNotFoundError:
            logger.critical(
                'The module `e2b_code_interpreter` was not found. Please install E2B as:'
                ' `pip install e2b-code-interpreter`\nExecution will halt now.'
            )
            sys.exit(-1)

        # Do not reuse existing sandboxes due to security reasons, as they may leak other tasks
        with e2b.Sandbox.create(
                timeout=self.default_timeout + 15,
                envs=self.env_vars_to_set or {},
                metadata={'task_id': task_id}
        ) as sbx:
            if self.pip_packages_str:
                sbx.commands.run(f'pip install {self.pip_packages_str}')

            for a_file in self.local_modules_to_copy:
                with open(
                        os.path.join(os.path.dirname(__file__), a_file),
                        'r',
                        encoding='utf-8'
                ) as py_file:
                    sbx.files.write(f'/home/user/{a_file}', py_file.read())
                    logger.info('Copied file %s...', a_file)

            logger.info('E2B sandbox info: %s', sbx.get_info())
            execution = sbx.run_code(code=source_code, timeout=self.default_timeout)
            std_out: str = '\n'.join(execution.logs.stdout)
            std_err: str = '\n'.join(execution.logs.stderr)
            if execution.error:
                std_err += f'\n{execution.error.name}\n{execution.error.value}'
            ret_code: int = -1 if execution.error else 0

        return std_out, std_err, ret_code
