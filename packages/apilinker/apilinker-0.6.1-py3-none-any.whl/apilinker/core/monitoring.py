"""
Monitoring and Alerting module for APILinker.

Provides health checks, configurable alert rules, and integrations with
external systems like PagerDuty, Slack, and Email.
"""

import logging
import smtplib
import time
from abc import ABC, abstractmethod
from datetime import datetime
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Union
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

import httpx
from pydantic import BaseModel, Field, ConfigDict

logger = logging.getLogger(__name__)


class HealthStatus(str, Enum):
    """Health status of a component."""

    HEALTHY = "healthy"
    DEGRADED = "degraded"
    UNHEALTHY = "unhealthy"
    UNKNOWN = "unknown"


class AlertSeverity(str, Enum):
    """Severity level of an alert."""

    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


class HealthCheckResult(BaseModel):
    """Result of a health check."""

    status: HealthStatus
    component: str
    message: str = ""
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    details: Dict[str, Any] = Field(default_factory=dict)
    latency_ms: float = 0.0

    model_config = ConfigDict(arbitrary_types_allowed=True)


class Alert(BaseModel):
    """An alert generated by the monitoring system."""

    id: str
    rule_name: str
    severity: AlertSeverity
    message: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    details: Dict[str, Any] = Field(default_factory=dict)
    status: str = "active"  # active, resolved

    model_config = ConfigDict(arbitrary_types_allowed=True)


class AlertIntegration(ABC):
    """Base class for alert integrations."""

    @abstractmethod
    def send_alert(self, alert: Alert) -> bool:
        """Send an alert to the integration."""
        pass


class PagerDutyIntegration(AlertIntegration):
    """Integration with PagerDuty."""

    def __init__(self, routing_key: str):
        self.routing_key = routing_key
        self.api_url = "https://events.pagerduty.com/v2/enqueue"

    def send_alert(self, alert: Alert) -> bool:
        """Send alert to PagerDuty."""
        payload = {
            "routing_key": self.routing_key,
            "event_action": "trigger" if alert.status == "active" else "resolve",
            "dedup_key": alert.id,
            "payload": {
                "summary": alert.message,
                "severity": alert.severity.value,
                "source": "apilinker",
                "timestamp": alert.timestamp.isoformat(),
                "custom_details": alert.details,
            },
        }

        try:
            with httpx.Client() as client:
                response = client.post(self.api_url, json=payload)
                response.raise_for_status()
                return True
        except Exception as e:
            logger.error(f"Failed to send alert to PagerDuty: {e}")
            return False


class SlackIntegration(AlertIntegration):
    """Integration with Slack."""

    def __init__(self, webhook_url: str):
        self.webhook_url = webhook_url

    def send_alert(self, alert: Alert) -> bool:
        """Send alert to Slack."""
        color = {
            AlertSeverity.INFO: "#36a64f",
            AlertSeverity.WARNING: "#ffcc00",
            AlertSeverity.CRITICAL: "#ff0000",
        }.get(alert.severity, "#cccccc")

        payload = {
            "attachments": [
                {
                    "color": color,
                    "title": f"[{alert.severity.upper()}] {alert.rule_name}",
                    "text": alert.message,
                    "fields": [
                        {
                            "title": "Time",
                            "value": alert.timestamp.isoformat(),
                            "short": True,
                        },
                        {"title": "Status", "value": alert.status, "short": True},
                    ],
                    "footer": "APILinker Monitoring",
                }
            ]
        }

        try:
            with httpx.Client() as client:
                response = client.post(self.webhook_url, json=payload)
                response.raise_for_status()
                return True
        except Exception as e:
            logger.error(f"Failed to send alert to Slack: {e}")
            return False


class EmailIntegration(AlertIntegration):
    """Integration with Email."""

    def __init__(
        self,
        smtp_host: str,
        smtp_port: int,
        sender: str,
        recipients: List[str],
        username: Optional[str] = None,
        password: Optional[str] = None,
        use_tls: bool = True,
    ):
        self.smtp_host = smtp_host
        self.smtp_port = smtp_port
        self.sender = sender
        self.recipients = recipients
        self.username = username
        self.password = password
        self.use_tls = use_tls

    def send_alert(self, alert: Alert) -> bool:
        """Send alert via Email."""
        msg = MIMEMultipart()
        msg["From"] = self.sender
        msg["To"] = ", ".join(self.recipients)
        msg["Subject"] = f"[APILinker] {alert.severity.upper()}: {alert.rule_name}"

        body = (
            f"Alert: {alert.rule_name}\n"
            f"Severity: {alert.severity.value}\n"
            f"Status: {alert.status}\n"
            f"Time: {alert.timestamp}\n"
            f"Message: {alert.message}\n"
            f"\n"
            f"Details:\n"
            f"{alert.details}"
        )
        msg.attach(MIMEText(body, "plain"))

        try:
            with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:
                if self.use_tls:
                    server.starttls()
                if self.username and self.password:
                    server.login(self.username, self.password)
                server.send_message(msg)
            return True
        except Exception as e:
            logger.error(f"Failed to send alert via Email: {e}")
            return False


class AlertRule(ABC):
    """Base class for alert rules."""

    def __init__(self, name: str, severity: AlertSeverity, cooldown_seconds: int = 300):
        self.name = name
        self.severity = severity
        self.cooldown_seconds = cooldown_seconds
        self.last_triggered: Optional[datetime] = None

    def should_trigger(self, context: Dict[str, Any]) -> bool:
        """Check if the rule should trigger based on context."""
        if self.last_triggered:
            elapsed = (datetime.utcnow() - self.last_triggered).total_seconds()
            if elapsed < self.cooldown_seconds:
                return False

        should_alert = self.evaluate(context)
        if should_alert:
            self.last_triggered = datetime.utcnow()
        return should_alert

    @abstractmethod
    def evaluate(self, context: Dict[str, Any]) -> bool:
        """Evaluate the rule logic."""
        pass


class ThresholdAlertRule(AlertRule):
    """Alert when a value exceeds a threshold."""

    def __init__(
        self,
        name: str,
        metric: str,
        threshold: float,
        operator: str = ">",
        severity: AlertSeverity = AlertSeverity.WARNING,
        **kwargs,
    ):
        super().__init__(name, severity, **kwargs)
        self.metric = metric
        self.threshold = threshold
        self.operator = operator

    def evaluate(self, context: Dict[str, Any]) -> bool:
        value = context.get(self.metric)
        if value is None:
            return False

        if self.operator == ">":
            return bool(value > self.threshold)
        elif self.operator == ">=":
            return bool(value >= self.threshold)
        elif self.operator == "<":
            return bool(value < self.threshold)
        elif self.operator == "<=":
            return bool(value <= self.threshold)
        elif self.operator == "==":
            return bool(value == self.threshold)
        return False


class StatusAlertRule(AlertRule):
    """Alert when a component status is not healthy."""

    def __init__(
        self,
        name: str,
        component: str,
        target_status: HealthStatus = HealthStatus.UNHEALTHY,
        severity: AlertSeverity = AlertSeverity.CRITICAL,
        **kwargs,
    ):
        super().__init__(name, severity, **kwargs)
        self.component = component
        self.target_status = target_status

    def evaluate(self, context: Dict[str, Any]) -> bool:
        status = context.get(f"{self.component}_status")
        if status is None:
            return False
        return bool(status == self.target_status)


class MonitoringManager:
    """
    Manages health checks and alerts.
    """

    def __init__(self):
        self.integrations: List[AlertIntegration] = []
        self.rules: List[AlertRule] = []
        self.alert_history: List[Alert] = []
        self.health_checks: Dict[str, Callable[[], Union[bool, HealthCheckResult]]] = {}

    def add_integration(self, integration: AlertIntegration):
        """Add an alert integration."""
        self.integrations.append(integration)

    def add_rule(self, rule: AlertRule):
        """Add an alert rule."""
        self.rules.append(rule)

    def register_health_check(
        self, component: str, check_func: Callable[[], Union[bool, HealthCheckResult]]
    ) -> None:
        """Register a health check function for a component."""
        self.health_checks[component] = check_func

    def run_health_checks(self) -> Dict[str, HealthCheckResult]:
        """Run all registered health checks."""
        results: Dict[str, HealthCheckResult] = {}
        context: Dict[str, Any] = {}

        for component, check_func in self.health_checks.items():
            try:
                start_time = time.time()
                result = check_func()
                latency = (time.time() - start_time) * 1000

                if isinstance(result, bool):
                    status = HealthStatus.HEALTHY if result else HealthStatus.UNHEALTHY
                    message = "OK" if result else "Check failed"
                    details: Dict[str, Any] = {}
                else:
                    # result is HealthCheckResult
                    status = result.status
                    message = result.message
                    details = result.details
                    # Use the latency from the result if provided, or the measured one
                    if result.latency_ms > 0:
                        latency = result.latency_ms

                results[component] = HealthCheckResult(
                    status=status,
                    component=component,
                    message=message,
                    latency_ms=latency,
                    details=details,
                )
                context[f"{component}_status"] = status
                context[f"{component}_latency_ms"] = latency

            except Exception as e:
                logger.error(f"Health check failed for {component}: {e}")
                results[component] = HealthCheckResult(
                    status=HealthStatus.UNHEALTHY,
                    component=component,
                    message=str(e),
                    latency_ms=0.0,
                )
                context[f"{component}_status"] = HealthStatus.UNHEALTHY

        # Evaluate alert rules
        self._evaluate_rules(context)

        return results

    def _evaluate_rules(self, context: Dict[str, Any]):
        """Evaluate all alert rules against the current context."""
        for rule in self.rules:
            if rule.should_trigger(context):
                alert = Alert(
                    id=f"{rule.name}_{int(time.time())}",
                    rule_name=rule.name,
                    severity=rule.severity,
                    message=f"Alert rule '{rule.name}' triggered",
                    details=context,
                )
                self._trigger_alert(alert)

    def _trigger_alert(self, alert: Alert):
        """Trigger an alert across all integrations."""
        logger.warning(f"Triggering alert: {alert.rule_name} - {alert.message}")
        self.alert_history.append(alert)

        # Deduplication check (simple version: check if same rule triggered recently)
        # Note: Real deduplication is complex, this is a basic implementation

        for integration in self.integrations:
            integration.send_alert(alert)

    def get_alert_history(self, limit: int = 100) -> List[Alert]:
        """Get the history of triggered alerts."""
        return sorted(self.alert_history, key=lambda x: x.timestamp, reverse=True)[
            :limit
        ]
