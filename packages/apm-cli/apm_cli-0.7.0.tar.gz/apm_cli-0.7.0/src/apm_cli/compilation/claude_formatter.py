"""CLAUDE.md formatter for Claude Memory integration.

This module generates CLAUDE.md files following the Claude Memory documentation format,
using the same distributed strategy as AGENTS.md compilation. It produces a parallel
output format specifically optimized for Claude's project memory system.

Also handles generation of .claude/commands/ from APM prompts (.prompt.md files).
"""

import builtins
import re
from collections import defaultdict
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple

import frontmatter

from ..primitives.models import Instruction, PrimitiveCollection, Chatmode
from ..version import get_version
from .constants import BUILD_ID_PLACEHOLDER
from .constitution import read_constitution

# CRITICAL: Shadow Click commands to prevent namespace collision
set = builtins.set
list = builtins.list
dict = builtins.dict


# Header comment for CLAUDE.md files
CLAUDE_HEADER = "<!-- Generated by APM CLI -->"


@dataclass
class ClaudePlacement:
    """Result of CLAUDE.md placement analysis."""
    claude_path: Path
    instructions: List[Instruction]
    agents: List[Chatmode] = field(default_factory=list)
    dependencies: List[str] = field(default_factory=list)  # @import paths
    coverage_patterns: Set[str] = field(default_factory=set)
    source_attribution: Dict[str, str] = field(default_factory=dict)


@dataclass
class ClaudeCompilationResult:
    """Result of CLAUDE.md compilation."""
    success: bool
    placements: List[ClaudePlacement]
    content_map: Dict[Path, str]  # claude_path -> content
    warnings: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)
    stats: Dict[str, float] = field(default_factory=dict)


class ClaudeFormatter:
    """Formatter for generating CLAUDE.md files from APM primitives.
    
    Generates CLAUDE.md files following Claude's Memory format with:
    - @import syntax for dependencies
    - Grouped project standards from instructions
    
    Note: Agents/workflows are handled separately as .github/agents/ files,
    not included in CLAUDE.md (same as AGENTS.md behavior).
    """
    
    def __init__(self, base_dir: str = "."):
        """Initialize the Claude formatter.
        
        Args:
            base_dir (str): Base directory for compilation.
        """
        try:
            self.base_dir = Path(base_dir).resolve()
        except (OSError, FileNotFoundError):
            self.base_dir = Path(base_dir).absolute()
        
        self.warnings: List[str] = []
        self.errors: List[str] = []
    
    def format_distributed(
        self,
        primitives: PrimitiveCollection,
        placement_map: Dict[Path, List[Instruction]],
        config: Optional[dict] = None
    ) -> ClaudeCompilationResult:
        """Format primitives into distributed CLAUDE.md files.
        
        Args:
            primitives (PrimitiveCollection): Collection of primitives to compile.
            placement_map (Dict[Path, List[Instruction]]): Directory to instructions mapping.
            config (Optional[dict]): Configuration options.
        
        Returns:
            ClaudeCompilationResult: Result of the CLAUDE.md compilation.
        """
        self.warnings.clear()
        self.errors.clear()
        
        try:
            config = config or {}
            source_attribution = config.get('source_attribution', True)
            
            # Generate Claude placements from the placement map
            placements = self._generate_placements(
                placement_map,
                primitives,
                source_attribution=source_attribution
            )
            
            # Generate content for each placement
            content_map = {}
            for placement in placements:
                content = self._generate_claude_content(placement, primitives)
                content_map[placement.claude_path] = content
            
            # Compile statistics
            stats = self._compile_stats(placements, primitives)
            
            return ClaudeCompilationResult(
                success=len(self.errors) == 0,
                placements=placements,
                content_map=content_map,
                warnings=self.warnings.copy(),
                errors=self.errors.copy(),
                stats=stats
            )
            
        except Exception as e:
            self.errors.append(f"CLAUDE.md formatting failed: {str(e)}")
            return ClaudeCompilationResult(
                success=False,
                placements=[],
                content_map={},
                warnings=self.warnings.copy(),
                errors=self.errors.copy(),
                stats={}
            )
    
    def _generate_placements(
        self,
        placement_map: Dict[Path, List[Instruction]],
        primitives: PrimitiveCollection,
        source_attribution: bool = True
    ) -> List[ClaudePlacement]:
        """Generate CLAUDE.md file placements from the placement map.
        
        Args:
            placement_map (Dict[Path, List[Instruction]]): Directory to instructions mapping.
            primitives (PrimitiveCollection): Full primitive collection.
            source_attribution (bool): Whether to include source attribution.
        
        Returns:
            List[ClaudePlacement]: List of placement results.
        """
        placements = []
        
        # Handle empty placement map with constitution
        if not placement_map:
            constitution = read_constitution(self.base_dir)
            if constitution:
                # Create root placement for constitution-only projects
                root_path = self.base_dir / "CLAUDE.md"
                placement = ClaudePlacement(
                    claude_path=root_path,
                    instructions=[],
                    agents=list(primitives.chatmodes),
                    dependencies=self._collect_dependencies(),
                    coverage_patterns=set(),
                    source_attribution={}
                )
                placements.append(placement)
        else:
            # Determine which directories get which agents (chatmodes)
            # Root directory gets all agents
            root_agents = list(primitives.chatmodes)
            
            for dir_path, instructions in placement_map.items():
                claude_path = dir_path / "CLAUDE.md"
                
                # Build source attribution map if enabled
                source_map = {}
                if source_attribution:
                    for instruction in instructions:
                        source_info = getattr(instruction, 'source', 'local')
                        source_map[str(instruction.file_path)] = source_info
                
                # Extract coverage patterns
                patterns = set()
                for instruction in instructions:
                    if instruction.apply_to:
                        patterns.add(instruction.apply_to)
                
                # Root directory gets agents and dependencies
                is_root = dir_path == self.base_dir
                
                placement = ClaudePlacement(
                    claude_path=claude_path,
                    instructions=instructions,
                    agents=root_agents if is_root else [],
                    dependencies=self._collect_dependencies() if is_root else [],
                    coverage_patterns=patterns,
                    source_attribution=source_map
                )
                
                placements.append(placement)
        
        return placements
    
    def _collect_dependencies(self) -> List[str]:
        """Collect @import paths for apm_modules dependencies.
        
        Returns:
            List[str]: List of @import paths for dependencies.
        """
        dependencies = []
        apm_modules_dir = self.base_dir / "apm_modules"
        
        if not apm_modules_dir.exists():
            return dependencies
        
        # Scan for CLAUDE.md files in apm_modules
        # Structure: apm_modules/{owner}/{package}/CLAUDE.md
        for owner_dir in apm_modules_dir.iterdir():
            if not owner_dir.is_dir() or owner_dir.name.startswith('.'):
                continue
            
            for package_dir in owner_dir.iterdir():
                if not package_dir.is_dir() or package_dir.name.startswith('.'):
                    continue
                
                # Build the @import path
                import_path = f"@apm_modules/{owner_dir.name}/{package_dir.name}/CLAUDE.md"
                dependencies.append(import_path)
        
        return sorted(dependencies)
    
    def _generate_claude_content(
        self,
        placement: ClaudePlacement,
        primitives: PrimitiveCollection
    ) -> str:
        """Generate CLAUDE.md content for a specific placement.
        
        Args:
            placement (ClaudePlacement): Placement result with instructions.
            primitives (PrimitiveCollection): Full primitive collection.
        
        Returns:
            str: Generated CLAUDE.md content.
        """
        sections = []
        
        # Header
        sections.append("# CLAUDE.md")
        sections.append(CLAUDE_HEADER)
        sections.append(BUILD_ID_PLACEHOLDER)
        sections.append(f"<!-- APM Version: {get_version()} -->")
        sections.append("")
        
        # Dependencies section (only for root CLAUDE.md)
        if placement.dependencies:
            sections.append("# Dependencies")
            for dep in placement.dependencies:
                sections.append(dep)
            sections.append("")
        
        # Constitution section (only for root CLAUDE.md)
        is_root = placement.claude_path.parent == self.base_dir
        if is_root:
            constitution = read_constitution(self.base_dir)
            if constitution:
                sections.append("# Constitution")
                sections.append("")
                sections.append(constitution.strip())
                sections.append("")
        
        # Project Standards section (grouped by pattern)
        if placement.instructions:
            sections.append("# Project Standards")
            sections.append("")
            
            # Group instructions by pattern
            pattern_groups: Dict[str, List[Instruction]] = defaultdict(list)
            for instruction in placement.instructions:
                if instruction.apply_to:
                    pattern_groups[instruction.apply_to].append(instruction)
            
            for pattern, pattern_instructions in sorted(pattern_groups.items()):
                sections.append(f"## Files matching `{pattern}`")
                sections.append("")
                
                for instruction in pattern_instructions:
                    content = instruction.content.strip()
                    if content:
                        # Add source attribution comment
                        if placement.source_attribution:
                            source = placement.source_attribution.get(
                                str(instruction.file_path), 'local'
                            )
                            try:
                                rel_path = instruction.file_path.relative_to(self.base_dir)
                            except ValueError:
                                rel_path = instruction.file_path
                            
                            sections.append(f"<!-- Source: {source} {rel_path} -->")
                        
                        sections.append(content)
                        sections.append("")
        
        # Note: CLAUDE.md only contains instructions (Project Standards).
        # Agents/workflows are NOT included - they go to .github/agents/ as separate files.
        # This matches AGENTS.md behavior which also only contains instructions.
        
        # Footer
        sections.append("---")
        sections.append("*This file was generated by APM CLI. Do not edit manually.*")
        sections.append("*To regenerate: `apm compile`*")
        sections.append("")
        
        return "\n".join(sections)
    
    def _compile_stats(
        self,
        placements: List[ClaudePlacement],
        primitives: PrimitiveCollection
    ) -> Dict[str, float]:
        """Compile statistics about the CLAUDE.md compilation.
        
        Args:
            placements (List[ClaudePlacement]): Generated placements.
            primitives (PrimitiveCollection): Full primitive collection.
        
        Returns:
            Dict[str, float]: Compilation statistics.
        """
        total_instructions = sum(len(p.instructions) for p in placements)
        total_patterns = sum(len(p.coverage_patterns) for p in placements)
        total_deps = sum(len(p.dependencies) for p in placements)
        
        return {
            "claude_files_generated": len(placements),
            "total_instructions_placed": total_instructions,
            "total_patterns_covered": total_patterns,
            "total_dependencies": total_deps,
            "primitives_found": primitives.count(),
        }
    
    def generate_commands(
        self,
        prompt_files: List[Path],
        dry_run: bool = False
    ) -> "CommandGenerationResult":
        """Generate .claude/commands/ from APM prompt files.
        
        Transforms .prompt.md files into Claude Code custom slash commands.
        Each prompt becomes a command file in .claude/commands/{name}.md.
        
        Args:
            prompt_files (List[Path]): List of .prompt.md file paths to transform.
            dry_run (bool): If True, preview without writing files.
        
        Returns:
            CommandGenerationResult: Result of the command generation.
        """
        commands_dir = self.base_dir / ".claude" / "commands"
        generated_commands: Dict[Path, str] = {}
        warnings: List[str] = []
        errors: List[str] = []
        
        for prompt_path in prompt_files:
            try:
                # Parse the prompt file
                command_name, content, parse_warnings = self._transform_prompt_to_command(prompt_path)
                warnings.extend(parse_warnings)
                
                if content:
                    command_path = commands_dir / f"{command_name}.md"
                    generated_commands[command_path] = content
                    
            except Exception as e:
                errors.append(f"Failed to transform {prompt_path.name}: {str(e)}")
        
        # Write files if not dry run
        files_written = 0
        if not dry_run and generated_commands:
            try:
                commands_dir.mkdir(parents=True, exist_ok=True)
                
                for command_path, content in generated_commands.items():
                    command_path.write_text(content, encoding='utf-8')
                    files_written += 1
                    
            except Exception as e:
                errors.append(f"Failed to write commands: {str(e)}")
        
        return CommandGenerationResult(
            success=len(errors) == 0,
            commands_generated=generated_commands,
            commands_dir=commands_dir,
            files_written=files_written,
            warnings=warnings,
            errors=errors
        )
    
    def _transform_prompt_to_command(
        self,
        prompt_path: Path
    ) -> Tuple[str, str, List[str]]:
        """Transform a single .prompt.md file into Claude command format.
        
        Args:
            prompt_path (Path): Path to the .prompt.md file.
        
        Returns:
            Tuple[str, str, List[str]]: (command_name, content, warnings)
        """
        warnings: List[str] = []
        
        # Parse the prompt file with frontmatter
        post = frontmatter.load(prompt_path)
        
        # Extract command name from filename
        # e.g., "code-review.prompt.md" -> "code-review"
        # e.g., "security/audit.prompt.md" -> "audit" (flatten nested paths)
        filename = prompt_path.name
        if filename.endswith('.prompt.md'):
            command_name = filename[:-len('.prompt.md')]
        else:
            command_name = prompt_path.stem
        
        # Build Claude command frontmatter
        claude_frontmatter = {}
        
        # Map APM frontmatter to Claude frontmatter
        # Claude supports: description, allowed-tools, model, argument-hint
        if 'description' in post.metadata:
            claude_frontmatter['description'] = post.metadata['description']
        
        if 'allowed-tools' in post.metadata:
            claude_frontmatter['allowed-tools'] = post.metadata['allowed-tools']
        elif 'allowedTools' in post.metadata:
            # Support camelCase variant
            claude_frontmatter['allowed-tools'] = post.metadata['allowedTools']
        
        if 'model' in post.metadata:
            claude_frontmatter['model'] = post.metadata['model']
        
        if 'argument-hint' in post.metadata:
            claude_frontmatter['argument-hint'] = post.metadata['argument-hint']
        elif 'argumentHint' in post.metadata:
            claude_frontmatter['argument-hint'] = post.metadata['argumentHint']
        
        # Get the prompt content
        content = post.content.strip()
        
        # Check if content already has $ARGUMENTS or positional args
        has_arguments_placeholder = bool(
            re.search(r'\$ARGUMENTS|\$\d+', content)
        )
        
        # Append $ARGUMENTS placeholder if not present
        if not has_arguments_placeholder:
            content = content + "\n\n$ARGUMENTS"
            warnings.append(
                f"Added $ARGUMENTS placeholder to {prompt_path.name}"
            )
        
        # Build the final command file content
        command_content = self._build_command_content(claude_frontmatter, content)
        
        return command_name, command_content, warnings
    
    def _build_command_content(
        self,
        frontmatter_dict: Dict[str, str],
        content: str
    ) -> str:
        """Build the final command file content with frontmatter.
        
        Args:
            frontmatter_dict (Dict[str, str]): Frontmatter key-value pairs.
            content (str): The command content.
        
        Returns:
            str: Complete command file content.
        """
        sections = []
        
        # Add frontmatter if we have any metadata
        if frontmatter_dict:
            sections.append("---")
            for key, value in frontmatter_dict.items():
                # Handle multi-word values that need quoting
                if isinstance(value, str) and (':' in value or '\n' in value):
                    sections.append(f'{key}: "{value}"')
                else:
                    sections.append(f"{key}: {value}")
            sections.append("---")
            sections.append("")
        
        # Add the content
        sections.append(content)
        sections.append("")
        
        return "\n".join(sections)
    
    def discover_prompt_files(self) -> List[Path]:
        """Discover all .prompt.md files in the project.
        
        Searches in standard APM locations:
        - .apm/prompts/
        - .github/prompts/
        - apm_modules/*/prompts/ (installed dependencies)
        
        Returns:
            List[Path]: List of discovered prompt file paths.
        """
        prompt_files: List[Path] = []
        
        # Search in .apm/prompts/
        apm_prompts = self.base_dir / ".apm" / "prompts"
        if apm_prompts.exists():
            prompt_files.extend(apm_prompts.rglob("*.prompt.md"))
        
        # Search in .github/prompts/
        github_prompts = self.base_dir / ".github" / "prompts"
        if github_prompts.exists():
            prompt_files.extend(github_prompts.rglob("*.prompt.md"))
        
        # Search in root directory
        prompt_files.extend(self.base_dir.glob("*.prompt.md"))
        
        # Search in apm_modules (installed dependencies)
        apm_modules = self.base_dir / "apm_modules"
        if apm_modules.exists():
            for package_dir in apm_modules.rglob("prompts"):
                if package_dir.is_dir():
                    prompt_files.extend(package_dir.glob("*.prompt.md"))
        
        # Remove duplicates while preserving order
        seen = set()
        unique_files = []
        for f in prompt_files:
            abs_path = f.resolve()
            if abs_path not in seen:
                seen.add(abs_path)
                unique_files.append(f)
        
        return unique_files


@dataclass
class CommandGenerationResult:
    """Result of .claude/commands/ generation."""
    success: bool
    commands_generated: Dict[Path, str]  # command_path -> content
    commands_dir: Path
    files_written: int
    warnings: List[str] = field(default_factory=list)
    errors: List[str] = field(default_factory=list)


def format_claude_md(
    primitives: PrimitiveCollection,
    placement_map: Dict[Path, List[Instruction]],
    base_dir: str = ".",
    config: Optional[dict] = None
) -> ClaudeCompilationResult:
    """Convenience function to format CLAUDE.md files.
    
    Args:
        primitives (PrimitiveCollection): Collection of primitives.
        placement_map (Dict[Path, List[Instruction]]): Directory to instructions mapping.
        base_dir (str): Base directory for compilation.
        config (Optional[dict]): Configuration options.
    
    Returns:
        ClaudeCompilationResult: Result of the CLAUDE.md compilation.
    """
    formatter = ClaudeFormatter(base_dir)
    return formatter.format_distributed(primitives, placement_map, config)


def generate_claude_commands(
    base_dir: str = ".",
    prompt_files: Optional[List[Path]] = None,
    dry_run: bool = False
) -> CommandGenerationResult:
    """Convenience function to generate .claude/commands/ from prompts.
    
    Transforms APM .prompt.md files into Claude Code custom slash commands.
    
    Args:
        base_dir (str): Base directory for compilation.
        prompt_files (Optional[List[Path]]): Specific prompt files to transform.
            If None, discovers prompts automatically.
        dry_run (bool): If True, preview without writing files.
    
    Returns:
        CommandGenerationResult: Result of the command generation.
    
    Example:
        >>> result = generate_claude_commands(".", dry_run=True)
        >>> print(f"Would generate {len(result.commands_generated)} commands")
        >>> for path, content in result.commands_generated.items():
        ...     print(f"  /{path.stem}: {len(content)} bytes")
    """
    formatter = ClaudeFormatter(base_dir)
    
    if prompt_files is None:
        prompt_files = formatter.discover_prompt_files()
    
    return formatter.generate_commands(prompt_files, dry_run=dry_run)
