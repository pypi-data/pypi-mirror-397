"""
Auto-generated Python types from spec/schema.json
Generated: 2025-12-15T12:01:47.762065

DO NOT EDIT - Regenerate with: python tools/codegen.py --types

Architecture Notes (RFC-0006):
==============================
These types define the INPUT CONTRACT - what a valid PSDL YAML looks like.
They are generated from spec/schema.json and are used for:
- Input validation (optional strict mode)
- Type checking during parsing
- API documentation

For internal processing, use the IR types from psdl.core.ir:
- Signal, TrendExpr, LogicExpr, PSDLScenario

The data flow is:
    YAML Input → (schema validation) → Parser → IR Types → Compiler → ScenarioIR
"""

# generated by datamodel-codegen:
#   filename:  schema.json
#   timestamp: 2025-12-15T17:01:47+00:00

from __future__ import annotations

from dataclasses import dataclass
from enum import Enum
from typing import Dict, List, Optional, Union

from typing_extensions import TypeAlias

PSDLVersion: TypeAlias = str


ScenarioName: TypeAlias = str


SemanticVersion: TypeAlias = str


Identifier: TypeAlias = str


SemanticRef: TypeAlias = str


PopulationExpression: TypeAlias = str


class SignalType(Enum):
    numeric = "numeric"
    categorical = "categorical"
    boolean = "boolean"
    datetime = "datetime"


class TrendType(Enum):
    float = "float"
    int = "int"
    timestamp = "timestamp"


TrendExpression: TypeAlias = str


LogicExpression: TypeAlias = str


class SeverityLevel(Enum):
    low = "low"
    medium = "medium"
    high = "high"
    critical = "critical"


class Type(Enum):
    boolean = "boolean"
    enum = "enum"


@dataclass
class DecisionOutput:
    type: Type
    from_: str
    values: Optional[List[str]] = None
    description: Optional[str] = None


class Type1(Enum):
    float = "float"
    int = "int"


@dataclass
class FeatureOutput1:
    type: Type1
    from_: str
    unit: Optional[str] = None
    expr: Optional[str] = None
    description: Optional[str] = None


@dataclass
class FeatureOutput2:
    type: Type1
    expr: str
    unit: Optional[str] = None
    from_: Optional[str] = None
    description: Optional[str] = None


FeatureOutput: TypeAlias = Union[FeatureOutput1, FeatureOutput2]


class Type3(Enum):
    timestamp = "timestamp"
    interval = "interval"
    string__ = "string[]"
    string = "string"


@dataclass
class EvidenceOutput1:
    type: Type3
    from_: str
    expr: Optional[str] = None
    description: Optional[str] = None


@dataclass
class EvidenceOutput2:
    type: Type3
    expr: str
    from_: Optional[str] = None
    description: Optional[str] = None


EvidenceOutput: TypeAlias = Union[EvidenceOutput1, EvidenceOutput2]


class ValidationStatus(Enum):
    draft = "draft"
    validated = "validated"
    clinical_review = "clinical_review"
    production = "production"


@dataclass
class ScenarioMetadata:
    created: Optional[str] = None
    updated: Optional[str] = None
    author: Optional[str] = None
    reviewers: Optional[List[str]] = None
    validation_status: Optional[ValidationStatus] = None
    references: Optional[List[str]] = None


Window: TypeAlias = str


class WindowedOperator(Enum):
    delta = "delta"
    slope = "slope"
    sma = "sma"
    ema = "ema"
    min = "min"
    max = "max"
    count = "count"
    first = "first"
    std = "std"
    stddev = "stddev"
    percentile = "percentile"


class PointwiseOperator(Enum):
    last = "last"
    exists = "exists"
    missing = "missing"


class ComparisonOperator(Enum):
    field__ = "=="
    field___1 = "!="
    field_ = "<"
    field___2 = "<="
    field__1 = ">"
    field___3 = ">="


class BooleanOperator(Enum):
    AND = "AND"
    OR = "OR"
    NOT = "NOT"


class Type5(Enum):
    guideline = "guideline"
    publication = "publication"
    sop = "sop"
    regulatory = "regulatory"
    expert = "expert"


@dataclass
class ProvenanceSpec1:
    type: Type5
    reference: str
    uri: Optional[str] = None
    version: Optional[str] = None


ProvenanceSpec: TypeAlias = Union[str, ProvenanceSpec1]


LogicRef: TypeAlias = str


@dataclass
class Scenario:
    name: ScenarioName
    version: SemanticVersion
    display_name: Optional[str] = None
    description: Optional[str] = None
    tags: Optional[List[str]] = None


@dataclass
class PopulationFilter:
    include: Optional[List[PopulationExpression]] = None
    exclude: Optional[List[PopulationExpression]] = None


@dataclass
class SignalSpec1:
    ref: SemanticRef
    expected_type: Optional[SignalType] = SignalType.numeric
    expected_unit: Optional[str] = None
    description: Optional[str] = None


SignalSpec: TypeAlias = Union[SemanticRef, SignalSpec1]


@dataclass
class TrendSpec1:
    expr: TrendExpression
    type: Optional[TrendType] = TrendType.float
    unit: Optional[str] = None
    description: Optional[str] = None


TrendSpec: TypeAlias = Union[TrendExpression, TrendSpec1]


@dataclass
class LogicSpec1:
    when: LogicExpression
    severity: Optional[SeverityLevel] = None
    description: Optional[str] = None
    recommendation: Optional[str] = None


LogicSpec: TypeAlias = Union[LogicExpression, LogicSpec1]


@dataclass
class OutputDefinitions:
    decision: Optional[Dict[str, DecisionOutput]] = None
    features: Optional[Dict[str, FeatureOutput]] = None
    evidence: Optional[Dict[str, EvidenceOutput]] = None


@dataclass
class AuditBlock:
    intent: str
    rationale: str
    provenance: ProvenanceSpec
    author: Optional[str] = None
    created: Optional[str] = None
    risk_class: Optional[str] = None
    evidence_level: Optional[str] = None
    approved_by: Optional[str] = None
    approval_id: Optional[str] = None


@dataclass
class StateTransition:
    from_: str
    to: str
    when: LogicRef


SignalDefinitions: TypeAlias = Dict[str, SignalSpec]


TrendDefinitions: TypeAlias = Dict[str, TrendSpec]


LogicDefinitions: TypeAlias = Dict[str, LogicSpec]


@dataclass
class StateMachine:
    initial: Optional[str] = None
    states: Optional[List[str]] = None
    transitions: Optional[List[StateTransition]] = None


@dataclass
class PsdlScenarioSchemaV03:
    psdl_version: PSDLVersion
    scenario: Scenario
    audit: AuditBlock
    signals: SignalDefinitions
    logic: LogicDefinitions
    outputs: OutputDefinitions
    population: Optional[PopulationFilter] = None
    trends: Optional[TrendDefinitions] = None
    state: Optional[StateMachine] = None
    metadata: Optional[ScenarioMetadata] = None
