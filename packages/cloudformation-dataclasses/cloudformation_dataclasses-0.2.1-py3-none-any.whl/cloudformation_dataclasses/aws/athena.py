"""
AWS CloudFormation Athena Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 227.0.0
  Generator Version: 1.0.0
  Combined: spec-227.0.0_gen-1.0.0
  Generated: 2025-12-15 17:57:11

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service Athena
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


@dataclass
class CapacityAssignment:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    workgroup_names: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.workgroup_names is not None:
            if hasattr(self.workgroup_names, 'to_dict'):
                props['WorkgroupNames'] = self.workgroup_names.to_dict()
            elif isinstance(self.workgroup_names, list):
                props['WorkgroupNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.workgroup_names
                ]
            else:
                props['WorkgroupNames'] = self.workgroup_names

        return props


@dataclass
class CapacityAssignmentConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_assignments: Optional[list[CapacityAssignment]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capacity_assignments is not None:
            if hasattr(self.capacity_assignments, 'to_dict'):
                props['CapacityAssignments'] = self.capacity_assignments.to_dict()
            elif isinstance(self.capacity_assignments, list):
                props['CapacityAssignments'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_assignments
                ]
            else:
                props['CapacityAssignments'] = self.capacity_assignments

        return props


@dataclass
class CapacityReservation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-athen"""

    resource_type: ClassVar[str] = "AWS::Athena::CapacityReservation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_dpus: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    capacity_assignment_configuration: Optional[CapacityAssignmentConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.target_dpus is not None:
            # Serialize target_dpus (handle intrinsic functions)
            if hasattr(self.target_dpus, 'to_dict'):
                props["TargetDpus"] = self.target_dpus.to_dict()
            elif isinstance(self.target_dpus, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetDpus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_dpus
                ]
            else:
                props["TargetDpus"] = self.target_dpus

        if self.capacity_assignment_configuration is not None:
            # Serialize capacity_assignment_configuration (handle intrinsic functions)
            if hasattr(self.capacity_assignment_configuration, 'to_dict'):
                props["CapacityAssignmentConfiguration"] = self.capacity_assignment_configuration.to_dict()
            elif isinstance(self.capacity_assignment_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['CapacityAssignmentConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_assignment_configuration
                ]
            else:
                props["CapacityAssignmentConfiguration"] = self.capacity_assignment_configuration

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_allocated_dpus(self) -> GetAtt:
        """Get the AllocatedDpus attribute."""
        return self.get_att("AllocatedDpus")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_last_successful_allocation_time(self) -> GetAtt:
        """Get the LastSuccessfulAllocationTime attribute."""
        return self.get_att("LastSuccessfulAllocationTime")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class DataCatalog(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-athen"""

    resource_type: ClassVar[str] = "AWS::Athena::DataCatalog"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    parameters: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connection_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    error: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.status is not None:
            # Serialize status (handle intrinsic functions)
            if hasattr(self.status, 'to_dict'):
                props["Status"] = self.status.to_dict()
            elif isinstance(self.status, list):
                # Serialize list items (may contain intrinsic functions)
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props["Status"] = self.status

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.parameters is not None:
            # Serialize parameters (handle intrinsic functions)
            if hasattr(self.parameters, 'to_dict'):
                props["Parameters"] = self.parameters.to_dict()
            elif isinstance(self.parameters, list):
                # Serialize list items (may contain intrinsic functions)
                props['Parameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameters
                ]
            else:
                props["Parameters"] = self.parameters

        if self.connection_type is not None:
            # Serialize connection_type (handle intrinsic functions)
            if hasattr(self.connection_type, 'to_dict'):
                props["ConnectionType"] = self.connection_type.to_dict()
            elif isinstance(self.connection_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConnectionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connection_type
                ]
            else:
                props["ConnectionType"] = self.connection_type

        if self.error is not None:
            # Serialize error (handle intrinsic functions)
            if hasattr(self.error, 'to_dict'):
                props["Error"] = self.error.to_dict()
            elif isinstance(self.error, list):
                # Serialize list items (may contain intrinsic functions)
                props['Error'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.error
                ]
            else:
                props["Error"] = self.error

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props



@dataclass
class NamedQuery(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-athen"""

    resource_type: ClassVar[str] = "AWS::Athena::NamedQuery"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    work_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    query_string: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    database: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.work_group is not None:
            # Serialize work_group (handle intrinsic functions)
            if hasattr(self.work_group, 'to_dict'):
                props["WorkGroup"] = self.work_group.to_dict()
            elif isinstance(self.work_group, list):
                # Serialize list items (may contain intrinsic functions)
                props['WorkGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.work_group
                ]
            else:
                props["WorkGroup"] = self.work_group

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.query_string is not None:
            # Serialize query_string (handle intrinsic functions)
            if hasattr(self.query_string, 'to_dict'):
                props["QueryString"] = self.query_string.to_dict()
            elif isinstance(self.query_string, list):
                # Serialize list items (may contain intrinsic functions)
                props['QueryString'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.query_string
                ]
            else:
                props["QueryString"] = self.query_string

        if self.database is not None:
            # Serialize database (handle intrinsic functions)
            if hasattr(self.database, 'to_dict'):
                props["Database"] = self.database.to_dict()
            elif isinstance(self.database, list):
                # Serialize list items (may contain intrinsic functions)
                props['Database'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.database
                ]
            else:
                props["Database"] = self.database

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_named_query_id(self) -> GetAtt:
        """Get the NamedQueryId attribute."""
        return self.get_att("NamedQueryId")




@dataclass
class PreparedStatement(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-athen"""

    resource_type: ClassVar[str] = "AWS::Athena::PreparedStatement"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    statement_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    work_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    query_statement: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.statement_name is not None:
            # Serialize statement_name (handle intrinsic functions)
            if hasattr(self.statement_name, 'to_dict'):
                props["StatementName"] = self.statement_name.to_dict()
            elif isinstance(self.statement_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['StatementName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.statement_name
                ]
            else:
                props["StatementName"] = self.statement_name

        if self.work_group is not None:
            # Serialize work_group (handle intrinsic functions)
            if hasattr(self.work_group, 'to_dict'):
                props["WorkGroup"] = self.work_group.to_dict()
            elif isinstance(self.work_group, list):
                # Serialize list items (may contain intrinsic functions)
                props['WorkGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.work_group
                ]
            else:
                props["WorkGroup"] = self.work_group

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.query_statement is not None:
            # Serialize query_statement (handle intrinsic functions)
            if hasattr(self.query_statement, 'to_dict'):
                props["QueryStatement"] = self.query_statement.to_dict()
            elif isinstance(self.query_statement, list):
                # Serialize list items (may contain intrinsic functions)
                props['QueryStatement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.query_statement
                ]
            else:
                props["QueryStatement"] = self.query_statement

        return props



@dataclass
class AclConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_acl_option: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_acl_option is not None:
            if hasattr(self.s3_acl_option, 'to_dict'):
                props['S3AclOption'] = self.s3_acl_option.to_dict()
            elif isinstance(self.s3_acl_option, list):
                props['S3AclOption'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_acl_option
                ]
            else:
                props['S3AclOption'] = self.s3_acl_option

        return props


@dataclass
class Classification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    properties: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.properties is not None:
            if hasattr(self.properties, 'to_dict'):
                props['Properties'] = self.properties.to_dict()
            elif isinstance(self.properties, list):
                props['Properties'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.properties
                ]
            else:
                props['Properties'] = self.properties

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class CloudWatchLoggingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_stream_name_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_types: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.log_group is not None:
            if hasattr(self.log_group, 'to_dict'):
                props['LogGroup'] = self.log_group.to_dict()
            elif isinstance(self.log_group, list):
                props['LogGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group
                ]
            else:
                props['LogGroup'] = self.log_group

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        if self.log_stream_name_prefix is not None:
            if hasattr(self.log_stream_name_prefix, 'to_dict'):
                props['LogStreamNamePrefix'] = self.log_stream_name_prefix.to_dict()
            elif isinstance(self.log_stream_name_prefix, list):
                props['LogStreamNamePrefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_stream_name_prefix
                ]
            else:
                props['LogStreamNamePrefix'] = self.log_stream_name_prefix

        if self.log_types is not None:
            if hasattr(self.log_types, 'to_dict'):
                props['LogTypes'] = self.log_types.to_dict()
            elif isinstance(self.log_types, list):
                props['LogTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_types
                ]
            else:
                props['LogTypes'] = self.log_types

        return props


@dataclass
class CustomerContentEncryptionConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key is not None:
            if hasattr(self.kms_key, 'to_dict'):
                props['KmsKey'] = self.kms_key.to_dict()
            elif isinstance(self.kms_key, list):
                props['KmsKey'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key
                ]
            else:
                props['KmsKey'] = self.kms_key

        return props


@dataclass
class EncryptionConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encryption_option: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.encryption_option is not None:
            if hasattr(self.encryption_option, 'to_dict'):
                props['EncryptionOption'] = self.encryption_option.to_dict()
            elif isinstance(self.encryption_option, list):
                props['EncryptionOption'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encryption_option
                ]
            else:
                props['EncryptionOption'] = self.encryption_option

        if self.kms_key is not None:
            if hasattr(self.kms_key, 'to_dict'):
                props['KmsKey'] = self.kms_key.to_dict()
            elif isinstance(self.kms_key, list):
                props['KmsKey'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key
                ]
            else:
                props['KmsKey'] = self.kms_key

        return props


@dataclass
class EngineConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spark_properties: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    classifications: Optional[list[Classification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_concurrent_dpus: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    coordinator_dpu_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_executor_dpu_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    additional_configs: Optional[dict[str, str]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.spark_properties is not None:
            if hasattr(self.spark_properties, 'to_dict'):
                props['SparkProperties'] = self.spark_properties.to_dict()
            elif isinstance(self.spark_properties, list):
                props['SparkProperties'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spark_properties
                ]
            else:
                props['SparkProperties'] = self.spark_properties

        if self.classifications is not None:
            if hasattr(self.classifications, 'to_dict'):
                props['Classifications'] = self.classifications.to_dict()
            elif isinstance(self.classifications, list):
                props['Classifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.classifications
                ]
            else:
                props['Classifications'] = self.classifications

        if self.max_concurrent_dpus is not None:
            if hasattr(self.max_concurrent_dpus, 'to_dict'):
                props['MaxConcurrentDpus'] = self.max_concurrent_dpus.to_dict()
            elif isinstance(self.max_concurrent_dpus, list):
                props['MaxConcurrentDpus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_concurrent_dpus
                ]
            else:
                props['MaxConcurrentDpus'] = self.max_concurrent_dpus

        if self.coordinator_dpu_size is not None:
            if hasattr(self.coordinator_dpu_size, 'to_dict'):
                props['CoordinatorDpuSize'] = self.coordinator_dpu_size.to_dict()
            elif isinstance(self.coordinator_dpu_size, list):
                props['CoordinatorDpuSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.coordinator_dpu_size
                ]
            else:
                props['CoordinatorDpuSize'] = self.coordinator_dpu_size

        if self.default_executor_dpu_size is not None:
            if hasattr(self.default_executor_dpu_size, 'to_dict'):
                props['DefaultExecutorDpuSize'] = self.default_executor_dpu_size.to_dict()
            elif isinstance(self.default_executor_dpu_size, list):
                props['DefaultExecutorDpuSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_executor_dpu_size
                ]
            else:
                props['DefaultExecutorDpuSize'] = self.default_executor_dpu_size

        if self.additional_configs is not None:
            if hasattr(self.additional_configs, 'to_dict'):
                props['AdditionalConfigs'] = self.additional_configs.to_dict()
            elif isinstance(self.additional_configs, list):
                props['AdditionalConfigs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_configs
                ]
            else:
                props['AdditionalConfigs'] = self.additional_configs

        return props


@dataclass
class EngineVersion:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    selected_engine_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    effective_engine_version: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.selected_engine_version is not None:
            if hasattr(self.selected_engine_version, 'to_dict'):
                props['SelectedEngineVersion'] = self.selected_engine_version.to_dict()
            elif isinstance(self.selected_engine_version, list):
                props['SelectedEngineVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.selected_engine_version
                ]
            else:
                props['SelectedEngineVersion'] = self.selected_engine_version

        if self.effective_engine_version is not None:
            if hasattr(self.effective_engine_version, 'to_dict'):
                props['EffectiveEngineVersion'] = self.effective_engine_version.to_dict()
            elif isinstance(self.effective_engine_version, list):
                props['EffectiveEngineVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.effective_engine_version
                ]
            else:
                props['EffectiveEngineVersion'] = self.effective_engine_version

        return props


@dataclass
class ManagedLoggingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        if self.kms_key is not None:
            if hasattr(self.kms_key, 'to_dict'):
                props['KmsKey'] = self.kms_key.to_dict()
            elif isinstance(self.kms_key, list):
                props['KmsKey'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key
                ]
            else:
                props['KmsKey'] = self.kms_key

        return props


@dataclass
class ManagedQueryResultsConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encryption_configuration: Optional[ManagedStorageEncryptionConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.encryption_configuration is not None:
            if hasattr(self.encryption_configuration, 'to_dict'):
                props['EncryptionConfiguration'] = self.encryption_configuration.to_dict()
            elif isinstance(self.encryption_configuration, list):
                props['EncryptionConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encryption_configuration
                ]
            else:
                props['EncryptionConfiguration'] = self.encryption_configuration

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class ManagedStorageEncryptionConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key is not None:
            if hasattr(self.kms_key, 'to_dict'):
                props['KmsKey'] = self.kms_key.to_dict()
            elif isinstance(self.kms_key, list):
                props['KmsKey'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key
                ]
            else:
                props['KmsKey'] = self.kms_key

        return props


@dataclass
class MonitoringConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_logging_configuration: Optional[S3LoggingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    managed_logging_configuration: Optional[ManagedLoggingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logging_configuration: Optional[CloudWatchLoggingConfiguration] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_logging_configuration is not None:
            if hasattr(self.s3_logging_configuration, 'to_dict'):
                props['S3LoggingConfiguration'] = self.s3_logging_configuration.to_dict()
            elif isinstance(self.s3_logging_configuration, list):
                props['S3LoggingConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_logging_configuration
                ]
            else:
                props['S3LoggingConfiguration'] = self.s3_logging_configuration

        if self.managed_logging_configuration is not None:
            if hasattr(self.managed_logging_configuration, 'to_dict'):
                props['ManagedLoggingConfiguration'] = self.managed_logging_configuration.to_dict()
            elif isinstance(self.managed_logging_configuration, list):
                props['ManagedLoggingConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.managed_logging_configuration
                ]
            else:
                props['ManagedLoggingConfiguration'] = self.managed_logging_configuration

        if self.cloud_watch_logging_configuration is not None:
            if hasattr(self.cloud_watch_logging_configuration, 'to_dict'):
                props['CloudWatchLoggingConfiguration'] = self.cloud_watch_logging_configuration.to_dict()
            elif isinstance(self.cloud_watch_logging_configuration, list):
                props['CloudWatchLoggingConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cloud_watch_logging_configuration
                ]
            else:
                props['CloudWatchLoggingConfiguration'] = self.cloud_watch_logging_configuration

        return props


@dataclass
class ResultConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encryption_configuration: Optional[EncryptionConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_location: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    acl_configuration: Optional[AclConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    expected_bucket_owner: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.encryption_configuration is not None:
            if hasattr(self.encryption_configuration, 'to_dict'):
                props['EncryptionConfiguration'] = self.encryption_configuration.to_dict()
            elif isinstance(self.encryption_configuration, list):
                props['EncryptionConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encryption_configuration
                ]
            else:
                props['EncryptionConfiguration'] = self.encryption_configuration

        if self.output_location is not None:
            if hasattr(self.output_location, 'to_dict'):
                props['OutputLocation'] = self.output_location.to_dict()
            elif isinstance(self.output_location, list):
                props['OutputLocation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_location
                ]
            else:
                props['OutputLocation'] = self.output_location

        if self.acl_configuration is not None:
            if hasattr(self.acl_configuration, 'to_dict'):
                props['AclConfiguration'] = self.acl_configuration.to_dict()
            elif isinstance(self.acl_configuration, list):
                props['AclConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.acl_configuration
                ]
            else:
                props['AclConfiguration'] = self.acl_configuration

        if self.expected_bucket_owner is not None:
            if hasattr(self.expected_bucket_owner, 'to_dict'):
                props['ExpectedBucketOwner'] = self.expected_bucket_owner.to_dict()
            elif isinstance(self.expected_bucket_owner, list):
                props['ExpectedBucketOwner'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.expected_bucket_owner
                ]
            else:
                props['ExpectedBucketOwner'] = self.expected_bucket_owner

        return props


@dataclass
class S3LoggingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_location: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.log_location is not None:
            if hasattr(self.log_location, 'to_dict'):
                props['LogLocation'] = self.log_location.to_dict()
            elif isinstance(self.log_location, list):
                props['LogLocation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_location
                ]
            else:
                props['LogLocation'] = self.log_location

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        if self.kms_key is not None:
            if hasattr(self.kms_key, 'to_dict'):
                props['KmsKey'] = self.kms_key.to_dict()
            elif isinstance(self.kms_key, list):
                props['KmsKey'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key
                ]
            else:
                props['KmsKey'] = self.kms_key

        return props


@dataclass
class WorkGroupConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ath"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enforce_work_group_configuration: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    engine_version: Optional[EngineVersion] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    publish_cloud_watch_metrics_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    result_configuration: Optional[ResultConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    additional_configuration: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    engine_configuration: Optional[EngineConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customer_content_encryption_configuration: Optional[CustomerContentEncryptionConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bytes_scanned_cutoff_per_query: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring_configuration: Optional[MonitoringConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    requester_pays_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    managed_query_results_configuration: Optional[ManagedQueryResultsConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    execution_role: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enforce_work_group_configuration is not None:
            if hasattr(self.enforce_work_group_configuration, 'to_dict'):
                props['EnforceWorkGroupConfiguration'] = self.enforce_work_group_configuration.to_dict()
            elif isinstance(self.enforce_work_group_configuration, list):
                props['EnforceWorkGroupConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enforce_work_group_configuration
                ]
            else:
                props['EnforceWorkGroupConfiguration'] = self.enforce_work_group_configuration

        if self.engine_version is not None:
            if hasattr(self.engine_version, 'to_dict'):
                props['EngineVersion'] = self.engine_version.to_dict()
            elif isinstance(self.engine_version, list):
                props['EngineVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.engine_version
                ]
            else:
                props['EngineVersion'] = self.engine_version

        if self.publish_cloud_watch_metrics_enabled is not None:
            if hasattr(self.publish_cloud_watch_metrics_enabled, 'to_dict'):
                props['PublishCloudWatchMetricsEnabled'] = self.publish_cloud_watch_metrics_enabled.to_dict()
            elif isinstance(self.publish_cloud_watch_metrics_enabled, list):
                props['PublishCloudWatchMetricsEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.publish_cloud_watch_metrics_enabled
                ]
            else:
                props['PublishCloudWatchMetricsEnabled'] = self.publish_cloud_watch_metrics_enabled

        if self.result_configuration is not None:
            if hasattr(self.result_configuration, 'to_dict'):
                props['ResultConfiguration'] = self.result_configuration.to_dict()
            elif isinstance(self.result_configuration, list):
                props['ResultConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.result_configuration
                ]
            else:
                props['ResultConfiguration'] = self.result_configuration

        if self.additional_configuration is not None:
            if hasattr(self.additional_configuration, 'to_dict'):
                props['AdditionalConfiguration'] = self.additional_configuration.to_dict()
            elif isinstance(self.additional_configuration, list):
                props['AdditionalConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_configuration
                ]
            else:
                props['AdditionalConfiguration'] = self.additional_configuration

        if self.engine_configuration is not None:
            if hasattr(self.engine_configuration, 'to_dict'):
                props['EngineConfiguration'] = self.engine_configuration.to_dict()
            elif isinstance(self.engine_configuration, list):
                props['EngineConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.engine_configuration
                ]
            else:
                props['EngineConfiguration'] = self.engine_configuration

        if self.customer_content_encryption_configuration is not None:
            if hasattr(self.customer_content_encryption_configuration, 'to_dict'):
                props['CustomerContentEncryptionConfiguration'] = self.customer_content_encryption_configuration.to_dict()
            elif isinstance(self.customer_content_encryption_configuration, list):
                props['CustomerContentEncryptionConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customer_content_encryption_configuration
                ]
            else:
                props['CustomerContentEncryptionConfiguration'] = self.customer_content_encryption_configuration

        if self.bytes_scanned_cutoff_per_query is not None:
            if hasattr(self.bytes_scanned_cutoff_per_query, 'to_dict'):
                props['BytesScannedCutoffPerQuery'] = self.bytes_scanned_cutoff_per_query.to_dict()
            elif isinstance(self.bytes_scanned_cutoff_per_query, list):
                props['BytesScannedCutoffPerQuery'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bytes_scanned_cutoff_per_query
                ]
            else:
                props['BytesScannedCutoffPerQuery'] = self.bytes_scanned_cutoff_per_query

        if self.monitoring_configuration is not None:
            if hasattr(self.monitoring_configuration, 'to_dict'):
                props['MonitoringConfiguration'] = self.monitoring_configuration.to_dict()
            elif isinstance(self.monitoring_configuration, list):
                props['MonitoringConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_configuration
                ]
            else:
                props['MonitoringConfiguration'] = self.monitoring_configuration

        if self.requester_pays_enabled is not None:
            if hasattr(self.requester_pays_enabled, 'to_dict'):
                props['RequesterPaysEnabled'] = self.requester_pays_enabled.to_dict()
            elif isinstance(self.requester_pays_enabled, list):
                props['RequesterPaysEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.requester_pays_enabled
                ]
            else:
                props['RequesterPaysEnabled'] = self.requester_pays_enabled

        if self.managed_query_results_configuration is not None:
            if hasattr(self.managed_query_results_configuration, 'to_dict'):
                props['ManagedQueryResultsConfiguration'] = self.managed_query_results_configuration.to_dict()
            elif isinstance(self.managed_query_results_configuration, list):
                props['ManagedQueryResultsConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.managed_query_results_configuration
                ]
            else:
                props['ManagedQueryResultsConfiguration'] = self.managed_query_results_configuration

        if self.execution_role is not None:
            if hasattr(self.execution_role, 'to_dict'):
                props['ExecutionRole'] = self.execution_role.to_dict()
            elif isinstance(self.execution_role, list):
                props['ExecutionRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role
                ]
            else:
                props['ExecutionRole'] = self.execution_role

        return props


@dataclass
class WorkGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-athen"""

    resource_type: ClassVar[str] = "AWS::Athena::WorkGroup"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    recursive_delete_option: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    work_group_configuration: Optional[WorkGroupConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    state: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.recursive_delete_option is not None:
            # Serialize recursive_delete_option (handle intrinsic functions)
            if hasattr(self.recursive_delete_option, 'to_dict'):
                props["RecursiveDeleteOption"] = self.recursive_delete_option.to_dict()
            elif isinstance(self.recursive_delete_option, list):
                # Serialize list items (may contain intrinsic functions)
                props['RecursiveDeleteOption'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.recursive_delete_option
                ]
            else:
                props["RecursiveDeleteOption"] = self.recursive_delete_option

        if self.work_group_configuration is not None:
            # Serialize work_group_configuration (handle intrinsic functions)
            if hasattr(self.work_group_configuration, 'to_dict'):
                props["WorkGroupConfiguration"] = self.work_group_configuration.to_dict()
            elif isinstance(self.work_group_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['WorkGroupConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.work_group_configuration
                ]
            else:
                props["WorkGroupConfiguration"] = self.work_group_configuration

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.state is not None:
            # Serialize state (handle intrinsic functions)
            if hasattr(self.state, 'to_dict'):
                props["State"] = self.state.to_dict()
            elif isinstance(self.state, list):
                # Serialize list items (may contain intrinsic functions)
                props['State'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state
                ]
            else:
                props["State"] = self.state

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_work_group_configuration__engine_version__effective_engine_version(self) -> GetAtt:
        """Get the WorkGroupConfiguration.EngineVersion.EffectiveEngineVersion attribute."""
        return self.get_att("WorkGroupConfiguration.EngineVersion.EffectiveEngineVersion")



