"""
AWS CloudFormation SQS Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 227.0.0
  Generator Version: 1.0.0
  Combined: spec-227.0.0_gen-1.0.0
  Generated: 2025-12-15 17:57:35

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service SQS
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


@dataclass
class Queue(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-q"""

    resource_type: ClassVar[str] = "AWS::SQS::Queue"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    receive_message_wait_time_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    fifo_throughput_limit: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_master_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    fifo_queue: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    maximum_message_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    visibility_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_data_key_reuse_period_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    redrive_allow_policy: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sqs_managed_sse_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delay_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    redrive_policy: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    message_retention_period: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    deduplication_scope: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    content_based_deduplication: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    queue_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.receive_message_wait_time_seconds is not None:
            # Serialize receive_message_wait_time_seconds (handle intrinsic functions)
            if hasattr(self.receive_message_wait_time_seconds, 'to_dict'):
                props["ReceiveMessageWaitTimeSeconds"] = self.receive_message_wait_time_seconds.to_dict()
            elif isinstance(self.receive_message_wait_time_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['ReceiveMessageWaitTimeSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.receive_message_wait_time_seconds
                ]
            else:
                props["ReceiveMessageWaitTimeSeconds"] = self.receive_message_wait_time_seconds

        if self.fifo_throughput_limit is not None:
            # Serialize fifo_throughput_limit (handle intrinsic functions)
            if hasattr(self.fifo_throughput_limit, 'to_dict'):
                props["FifoThroughputLimit"] = self.fifo_throughput_limit.to_dict()
            elif isinstance(self.fifo_throughput_limit, list):
                # Serialize list items (may contain intrinsic functions)
                props['FifoThroughputLimit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fifo_throughput_limit
                ]
            else:
                props["FifoThroughputLimit"] = self.fifo_throughput_limit

        if self.kms_master_key_id is not None:
            # Serialize kms_master_key_id (handle intrinsic functions)
            if hasattr(self.kms_master_key_id, 'to_dict'):
                props["KmsMasterKeyId"] = self.kms_master_key_id.to_dict()
            elif isinstance(self.kms_master_key_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsMasterKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_master_key_id
                ]
            else:
                props["KmsMasterKeyId"] = self.kms_master_key_id

        if self.fifo_queue is not None:
            # Serialize fifo_queue (handle intrinsic functions)
            if hasattr(self.fifo_queue, 'to_dict'):
                props["FifoQueue"] = self.fifo_queue.to_dict()
            elif isinstance(self.fifo_queue, list):
                # Serialize list items (may contain intrinsic functions)
                props['FifoQueue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fifo_queue
                ]
            else:
                props["FifoQueue"] = self.fifo_queue

        if self.maximum_message_size is not None:
            # Serialize maximum_message_size (handle intrinsic functions)
            if hasattr(self.maximum_message_size, 'to_dict'):
                props["MaximumMessageSize"] = self.maximum_message_size.to_dict()
            elif isinstance(self.maximum_message_size, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaximumMessageSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_message_size
                ]
            else:
                props["MaximumMessageSize"] = self.maximum_message_size

        if self.visibility_timeout is not None:
            # Serialize visibility_timeout (handle intrinsic functions)
            if hasattr(self.visibility_timeout, 'to_dict'):
                props["VisibilityTimeout"] = self.visibility_timeout.to_dict()
            elif isinstance(self.visibility_timeout, list):
                # Serialize list items (may contain intrinsic functions)
                props['VisibilityTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.visibility_timeout
                ]
            else:
                props["VisibilityTimeout"] = self.visibility_timeout

        if self.kms_data_key_reuse_period_seconds is not None:
            # Serialize kms_data_key_reuse_period_seconds (handle intrinsic functions)
            if hasattr(self.kms_data_key_reuse_period_seconds, 'to_dict'):
                props["KmsDataKeyReusePeriodSeconds"] = self.kms_data_key_reuse_period_seconds.to_dict()
            elif isinstance(self.kms_data_key_reuse_period_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsDataKeyReusePeriodSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_data_key_reuse_period_seconds
                ]
            else:
                props["KmsDataKeyReusePeriodSeconds"] = self.kms_data_key_reuse_period_seconds

        if self.redrive_allow_policy is not None:
            # Serialize redrive_allow_policy (handle intrinsic functions)
            if hasattr(self.redrive_allow_policy, 'to_dict'):
                props["RedriveAllowPolicy"] = self.redrive_allow_policy.to_dict()
            elif isinstance(self.redrive_allow_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['RedriveAllowPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.redrive_allow_policy
                ]
            else:
                props["RedriveAllowPolicy"] = self.redrive_allow_policy

        if self.sqs_managed_sse_enabled is not None:
            # Serialize sqs_managed_sse_enabled (handle intrinsic functions)
            if hasattr(self.sqs_managed_sse_enabled, 'to_dict'):
                props["SqsManagedSseEnabled"] = self.sqs_managed_sse_enabled.to_dict()
            elif isinstance(self.sqs_managed_sse_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['SqsManagedSseEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sqs_managed_sse_enabled
                ]
            else:
                props["SqsManagedSseEnabled"] = self.sqs_managed_sse_enabled

        if self.delay_seconds is not None:
            # Serialize delay_seconds (handle intrinsic functions)
            if hasattr(self.delay_seconds, 'to_dict'):
                props["DelaySeconds"] = self.delay_seconds.to_dict()
            elif isinstance(self.delay_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['DelaySeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delay_seconds
                ]
            else:
                props["DelaySeconds"] = self.delay_seconds

        if self.redrive_policy is not None:
            # Serialize redrive_policy (handle intrinsic functions)
            if hasattr(self.redrive_policy, 'to_dict'):
                props["RedrivePolicy"] = self.redrive_policy.to_dict()
            elif isinstance(self.redrive_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['RedrivePolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.redrive_policy
                ]
            else:
                props["RedrivePolicy"] = self.redrive_policy

        if self.message_retention_period is not None:
            # Serialize message_retention_period (handle intrinsic functions)
            if hasattr(self.message_retention_period, 'to_dict'):
                props["MessageRetentionPeriod"] = self.message_retention_period.to_dict()
            elif isinstance(self.message_retention_period, list):
                # Serialize list items (may contain intrinsic functions)
                props['MessageRetentionPeriod'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.message_retention_period
                ]
            else:
                props["MessageRetentionPeriod"] = self.message_retention_period

        if self.deduplication_scope is not None:
            # Serialize deduplication_scope (handle intrinsic functions)
            if hasattr(self.deduplication_scope, 'to_dict'):
                props["DeduplicationScope"] = self.deduplication_scope.to_dict()
            elif isinstance(self.deduplication_scope, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeduplicationScope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.deduplication_scope
                ]
            else:
                props["DeduplicationScope"] = self.deduplication_scope

        if self.content_based_deduplication is not None:
            # Serialize content_based_deduplication (handle intrinsic functions)
            if hasattr(self.content_based_deduplication, 'to_dict'):
                props["ContentBasedDeduplication"] = self.content_based_deduplication.to_dict()
            elif isinstance(self.content_based_deduplication, list):
                # Serialize list items (may contain intrinsic functions)
                props['ContentBasedDeduplication'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.content_based_deduplication
                ]
            else:
                props["ContentBasedDeduplication"] = self.content_based_deduplication

        if self.queue_name is not None:
            # Serialize queue_name (handle intrinsic functions)
            if hasattr(self.queue_name, 'to_dict'):
                props["QueueName"] = self.queue_name.to_dict()
            elif isinstance(self.queue_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['QueueName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.queue_name
                ]
            else:
                props["QueueName"] = self.queue_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_queue_name(self) -> GetAtt:
        """Get the QueueName attribute."""
        return self.get_att("QueueName")

    @property
    def attr_queue_url(self) -> GetAtt:
        """Get the QueueUrl attribute."""
        return self.get_att("QueueUrl")




@dataclass
class QueueInlinePolicy(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-q"""

    resource_type: ClassVar[str] = "AWS::SQS::QueueInlinePolicy"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_document: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    queue: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.policy_document is not None:
            # Serialize policy_document (handle intrinsic functions)
            if hasattr(self.policy_document, 'to_dict'):
                props["PolicyDocument"] = self.policy_document.to_dict()
            elif isinstance(self.policy_document, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyDocument'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_document
                ]
            else:
                props["PolicyDocument"] = self.policy_document

        if self.queue is not None:
            # Serialize queue (handle intrinsic functions)
            if hasattr(self.queue, 'to_dict'):
                props["Queue"] = self.queue.to_dict()
            elif isinstance(self.queue, list):
                # Serialize list items (may contain intrinsic functions)
                props['Queue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.queue
                ]
            else:
                props["Queue"] = self.queue

        return props



@dataclass
class QueuePolicy(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sqs-q"""

    resource_type: ClassVar[str] = "AWS::SQS::QueuePolicy"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_document: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    queues: Optional[Union[list[str], Ref]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.policy_document is not None:
            # Serialize policy_document (handle intrinsic functions)
            if hasattr(self.policy_document, 'to_dict'):
                props["PolicyDocument"] = self.policy_document.to_dict()
            elif isinstance(self.policy_document, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyDocument'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_document
                ]
            else:
                props["PolicyDocument"] = self.policy_document

        if self.queues is not None:
            # Serialize queues (handle intrinsic functions)
            if hasattr(self.queues, 'to_dict'):
                props["Queues"] = self.queues.to_dict()
            elif isinstance(self.queues, list):
                # Serialize list items (may contain intrinsic functions)
                props['Queues'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.queues
                ]
            else:
                props["Queues"] = self.queues

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")



