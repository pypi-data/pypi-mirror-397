"""
AWS CloudFormation IoTFleetWise Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 227.0.0
  Generator Version: 1.0.0
  Combined: spec-227.0.0_gen-1.0.0
  Generated: 2025-12-15 17:57:24

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service IoTFleetWise
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


@dataclass
class CollectionScheme:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    time_based_collection_scheme: Optional[TimeBasedCollectionScheme] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    condition_based_collection_scheme: Optional[ConditionBasedCollectionScheme] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.time_based_collection_scheme is not None:
            if hasattr(self.time_based_collection_scheme, 'to_dict'):
                props['TimeBasedCollectionScheme'] = self.time_based_collection_scheme.to_dict()
            elif isinstance(self.time_based_collection_scheme, list):
                props['TimeBasedCollectionScheme'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.time_based_collection_scheme
                ]
            else:
                props['TimeBasedCollectionScheme'] = self.time_based_collection_scheme

        if self.condition_based_collection_scheme is not None:
            if hasattr(self.condition_based_collection_scheme, 'to_dict'):
                props['ConditionBasedCollectionScheme'] = self.condition_based_collection_scheme.to_dict()
            elif isinstance(self.condition_based_collection_scheme, list):
                props['ConditionBasedCollectionScheme'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.condition_based_collection_scheme
                ]
            else:
                props['ConditionBasedCollectionScheme'] = self.condition_based_collection_scheme

        return props


@dataclass
class ConditionBasedCollectionScheme:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    minimum_trigger_interval_ms: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    expression: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    trigger_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    condition_language_version: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.minimum_trigger_interval_ms is not None:
            if hasattr(self.minimum_trigger_interval_ms, 'to_dict'):
                props['MinimumTriggerIntervalMs'] = self.minimum_trigger_interval_ms.to_dict()
            elif isinstance(self.minimum_trigger_interval_ms, list):
                props['MinimumTriggerIntervalMs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.minimum_trigger_interval_ms
                ]
            else:
                props['MinimumTriggerIntervalMs'] = self.minimum_trigger_interval_ms

        if self.expression is not None:
            if hasattr(self.expression, 'to_dict'):
                props['Expression'] = self.expression.to_dict()
            elif isinstance(self.expression, list):
                props['Expression'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.expression
                ]
            else:
                props['Expression'] = self.expression

        if self.trigger_mode is not None:
            if hasattr(self.trigger_mode, 'to_dict'):
                props['TriggerMode'] = self.trigger_mode.to_dict()
            elif isinstance(self.trigger_mode, list):
                props['TriggerMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.trigger_mode
                ]
            else:
                props['TriggerMode'] = self.trigger_mode

        if self.condition_language_version is not None:
            if hasattr(self.condition_language_version, 'to_dict'):
                props['ConditionLanguageVersion'] = self.condition_language_version.to_dict()
            elif isinstance(self.condition_language_version, list):
                props['ConditionLanguageVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.condition_language_version
                ]
            else:
                props['ConditionLanguageVersion'] = self.condition_language_version

        return props


@dataclass
class ConditionBasedSignalFetchConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    condition_expression: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    trigger_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.condition_expression is not None:
            if hasattr(self.condition_expression, 'to_dict'):
                props['ConditionExpression'] = self.condition_expression.to_dict()
            elif isinstance(self.condition_expression, list):
                props['ConditionExpression'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.condition_expression
                ]
            else:
                props['ConditionExpression'] = self.condition_expression

        if self.trigger_mode is not None:
            if hasattr(self.trigger_mode, 'to_dict'):
                props['TriggerMode'] = self.trigger_mode.to_dict()
            elif isinstance(self.trigger_mode, list):
                props['TriggerMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.trigger_mode
                ]
            else:
                props['TriggerMode'] = self.trigger_mode

        return props


@dataclass
class DataDestinationConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_config: Optional[S3Config] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mqtt_topic_config: Optional[MqttTopicConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    timestream_config: Optional[TimestreamConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_config is not None:
            if hasattr(self.s3_config, 'to_dict'):
                props['S3Config'] = self.s3_config.to_dict()
            elif isinstance(self.s3_config, list):
                props['S3Config'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_config
                ]
            else:
                props['S3Config'] = self.s3_config

        if self.mqtt_topic_config is not None:
            if hasattr(self.mqtt_topic_config, 'to_dict'):
                props['MqttTopicConfig'] = self.mqtt_topic_config.to_dict()
            elif isinstance(self.mqtt_topic_config, list):
                props['MqttTopicConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mqtt_topic_config
                ]
            else:
                props['MqttTopicConfig'] = self.mqtt_topic_config

        if self.timestream_config is not None:
            if hasattr(self.timestream_config, 'to_dict'):
                props['TimestreamConfig'] = self.timestream_config.to_dict()
            elif isinstance(self.timestream_config, list):
                props['TimestreamConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.timestream_config
                ]
            else:
                props['TimestreamConfig'] = self.timestream_config

        return props


@dataclass
class DataPartition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    upload_options: Optional[DataPartitionUploadOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    storage_options: Optional[DataPartitionStorageOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.upload_options is not None:
            if hasattr(self.upload_options, 'to_dict'):
                props['UploadOptions'] = self.upload_options.to_dict()
            elif isinstance(self.upload_options, list):
                props['UploadOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.upload_options
                ]
            else:
                props['UploadOptions'] = self.upload_options

        if self.storage_options is not None:
            if hasattr(self.storage_options, 'to_dict'):
                props['StorageOptions'] = self.storage_options.to_dict()
            elif isinstance(self.storage_options, list):
                props['StorageOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_options
                ]
            else:
                props['StorageOptions'] = self.storage_options

        if self.id is not None:
            if hasattr(self.id, 'to_dict'):
                props['Id'] = self.id.to_dict()
            elif isinstance(self.id, list):
                props['Id'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.id
                ]
            else:
                props['Id'] = self.id

        return props


@dataclass
class DataPartitionStorageOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_size: Optional[StorageMaximumSize] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    storage_location: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    minimum_time_to_live: Optional[StorageMinimumTimeToLive] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.maximum_size is not None:
            if hasattr(self.maximum_size, 'to_dict'):
                props['MaximumSize'] = self.maximum_size.to_dict()
            elif isinstance(self.maximum_size, list):
                props['MaximumSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_size
                ]
            else:
                props['MaximumSize'] = self.maximum_size

        if self.storage_location is not None:
            if hasattr(self.storage_location, 'to_dict'):
                props['StorageLocation'] = self.storage_location.to_dict()
            elif isinstance(self.storage_location, list):
                props['StorageLocation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_location
                ]
            else:
                props['StorageLocation'] = self.storage_location

        if self.minimum_time_to_live is not None:
            if hasattr(self.minimum_time_to_live, 'to_dict'):
                props['MinimumTimeToLive'] = self.minimum_time_to_live.to_dict()
            elif isinstance(self.minimum_time_to_live, list):
                props['MinimumTimeToLive'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.minimum_time_to_live
                ]
            else:
                props['MinimumTimeToLive'] = self.minimum_time_to_live

        return props


@dataclass
class DataPartitionUploadOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    expression: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    condition_language_version: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.expression is not None:
            if hasattr(self.expression, 'to_dict'):
                props['Expression'] = self.expression.to_dict()
            elif isinstance(self.expression, list):
                props['Expression'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.expression
                ]
            else:
                props['Expression'] = self.expression

        if self.condition_language_version is not None:
            if hasattr(self.condition_language_version, 'to_dict'):
                props['ConditionLanguageVersion'] = self.condition_language_version.to_dict()
            elif isinstance(self.condition_language_version, list):
                props['ConditionLanguageVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.condition_language_version
                ]
            else:
                props['ConditionLanguageVersion'] = self.condition_language_version

        return props


@dataclass
class MqttTopicConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    execution_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mqtt_topic_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.execution_role_arn is not None:
            if hasattr(self.execution_role_arn, 'to_dict'):
                props['ExecutionRoleArn'] = self.execution_role_arn.to_dict()
            elif isinstance(self.execution_role_arn, list):
                props['ExecutionRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role_arn
                ]
            else:
                props['ExecutionRoleArn'] = self.execution_role_arn

        if self.mqtt_topic_arn is not None:
            if hasattr(self.mqtt_topic_arn, 'to_dict'):
                props['MqttTopicArn'] = self.mqtt_topic_arn.to_dict()
            elif isinstance(self.mqtt_topic_arn, list):
                props['MqttTopicArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mqtt_topic_arn
                ]
            else:
                props['MqttTopicArn'] = self.mqtt_topic_arn

        return props


@dataclass
class S3Config:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    storage_compression_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.bucket_arn is not None:
            if hasattr(self.bucket_arn, 'to_dict'):
                props['BucketArn'] = self.bucket_arn.to_dict()
            elif isinstance(self.bucket_arn, list):
                props['BucketArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket_arn
                ]
            else:
                props['BucketArn'] = self.bucket_arn

        if self.data_format is not None:
            if hasattr(self.data_format, 'to_dict'):
                props['DataFormat'] = self.data_format.to_dict()
            elif isinstance(self.data_format, list):
                props['DataFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_format
                ]
            else:
                props['DataFormat'] = self.data_format

        if self.storage_compression_format is not None:
            if hasattr(self.storage_compression_format, 'to_dict'):
                props['StorageCompressionFormat'] = self.storage_compression_format.to_dict()
            elif isinstance(self.storage_compression_format, list):
                props['StorageCompressionFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_compression_format
                ]
            else:
                props['StorageCompressionFormat'] = self.storage_compression_format

        if self.prefix is not None:
            if hasattr(self.prefix, 'to_dict'):
                props['Prefix'] = self.prefix.to_dict()
            elif isinstance(self.prefix, list):
                props['Prefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.prefix
                ]
            else:
                props['Prefix'] = self.prefix

        return props


@dataclass
class SignalFetchConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    condition_based: Optional[ConditionBasedSignalFetchConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    time_based: Optional[TimeBasedSignalFetchConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.condition_based is not None:
            if hasattr(self.condition_based, 'to_dict'):
                props['ConditionBased'] = self.condition_based.to_dict()
            elif isinstance(self.condition_based, list):
                props['ConditionBased'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.condition_based
                ]
            else:
                props['ConditionBased'] = self.condition_based

        if self.time_based is not None:
            if hasattr(self.time_based, 'to_dict'):
                props['TimeBased'] = self.time_based.to_dict()
            elif isinstance(self.time_based, list):
                props['TimeBased'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.time_based
                ]
            else:
                props['TimeBased'] = self.time_based

        return props


@dataclass
class SignalFetchInformation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    actions: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    fully_qualified_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    signal_fetch_config: Optional[SignalFetchConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    condition_language_version: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.actions is not None:
            if hasattr(self.actions, 'to_dict'):
                props['Actions'] = self.actions.to_dict()
            elif isinstance(self.actions, list):
                props['Actions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.actions
                ]
            else:
                props['Actions'] = self.actions

        if self.fully_qualified_name is not None:
            if hasattr(self.fully_qualified_name, 'to_dict'):
                props['FullyQualifiedName'] = self.fully_qualified_name.to_dict()
            elif isinstance(self.fully_qualified_name, list):
                props['FullyQualifiedName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fully_qualified_name
                ]
            else:
                props['FullyQualifiedName'] = self.fully_qualified_name

        if self.signal_fetch_config is not None:
            if hasattr(self.signal_fetch_config, 'to_dict'):
                props['SignalFetchConfig'] = self.signal_fetch_config.to_dict()
            elif isinstance(self.signal_fetch_config, list):
                props['SignalFetchConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.signal_fetch_config
                ]
            else:
                props['SignalFetchConfig'] = self.signal_fetch_config

        if self.condition_language_version is not None:
            if hasattr(self.condition_language_version, 'to_dict'):
                props['ConditionLanguageVersion'] = self.condition_language_version.to_dict()
            elif isinstance(self.condition_language_version, list):
                props['ConditionLanguageVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.condition_language_version
                ]
            else:
                props['ConditionLanguageVersion'] = self.condition_language_version

        return props


@dataclass
class SignalInformation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_sample_count: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_partition_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    minimum_sampling_interval_ms: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_sample_count is not None:
            if hasattr(self.max_sample_count, 'to_dict'):
                props['MaxSampleCount'] = self.max_sample_count.to_dict()
            elif isinstance(self.max_sample_count, list):
                props['MaxSampleCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_sample_count
                ]
            else:
                props['MaxSampleCount'] = self.max_sample_count

        if self.data_partition_id is not None:
            if hasattr(self.data_partition_id, 'to_dict'):
                props['DataPartitionId'] = self.data_partition_id.to_dict()
            elif isinstance(self.data_partition_id, list):
                props['DataPartitionId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_partition_id
                ]
            else:
                props['DataPartitionId'] = self.data_partition_id

        if self.minimum_sampling_interval_ms is not None:
            if hasattr(self.minimum_sampling_interval_ms, 'to_dict'):
                props['MinimumSamplingIntervalMs'] = self.minimum_sampling_interval_ms.to_dict()
            elif isinstance(self.minimum_sampling_interval_ms, list):
                props['MinimumSamplingIntervalMs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.minimum_sampling_interval_ms
                ]
            else:
                props['MinimumSamplingIntervalMs'] = self.minimum_sampling_interval_ms

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class StorageMaximumSize:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.unit is not None:
            if hasattr(self.unit, 'to_dict'):
                props['Unit'] = self.unit.to_dict()
            elif isinstance(self.unit, list):
                props['Unit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unit
                ]
            else:
                props['Unit'] = self.unit

        return props


@dataclass
class StorageMinimumTimeToLive:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.unit is not None:
            if hasattr(self.unit, 'to_dict'):
                props['Unit'] = self.unit.to_dict()
            elif isinstance(self.unit, list):
                props['Unit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unit
                ]
            else:
                props['Unit'] = self.unit

        return props


@dataclass
class TimeBasedCollectionScheme:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    period_ms: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.period_ms is not None:
            if hasattr(self.period_ms, 'to_dict'):
                props['PeriodMs'] = self.period_ms.to_dict()
            elif isinstance(self.period_ms, list):
                props['PeriodMs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.period_ms
                ]
            else:
                props['PeriodMs'] = self.period_ms

        return props


@dataclass
class TimeBasedSignalFetchConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    execution_frequency_ms: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.execution_frequency_ms is not None:
            if hasattr(self.execution_frequency_ms, 'to_dict'):
                props['ExecutionFrequencyMs'] = self.execution_frequency_ms.to_dict()
            elif isinstance(self.execution_frequency_ms, list):
                props['ExecutionFrequencyMs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_frequency_ms
                ]
            else:
                props['ExecutionFrequencyMs'] = self.execution_frequency_ms

        return props


@dataclass
class TimestreamConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    execution_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    timestream_table_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.execution_role_arn is not None:
            if hasattr(self.execution_role_arn, 'to_dict'):
                props['ExecutionRoleArn'] = self.execution_role_arn.to_dict()
            elif isinstance(self.execution_role_arn, list):
                props['ExecutionRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role_arn
                ]
            else:
                props['ExecutionRoleArn'] = self.execution_role_arn

        if self.timestream_table_arn is not None:
            if hasattr(self.timestream_table_arn, 'to_dict'):
                props['TimestreamTableArn'] = self.timestream_table_arn.to_dict()
            elif isinstance(self.timestream_table_arn, list):
                props['TimestreamTableArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.timestream_table_arn
                ]
            else:
                props['TimestreamTableArn'] = self.timestream_table_arn

        return props


@dataclass
class Campaign(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iotfl"""

    resource_type: ClassVar[str] = "AWS::IoTFleetWise::Campaign"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    compression: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_partitions: Optional[list[DataPartition]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    priority: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    signals_to_collect: Optional[list[SignalInformation]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    start_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    signals_to_fetch: Optional[list[SignalFetchInformation]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    expiry_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    spooling_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_destination_configs: Optional[list[DataDestinationConfig]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    signal_catalog_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    post_trigger_collection_duration: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_extra_dimensions: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    diagnostics_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    collection_scheme: Optional[CollectionScheme] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.action is not None:
            # Serialize action (handle intrinsic functions)
            if hasattr(self.action, 'to_dict'):
                props["Action"] = self.action.to_dict()
            elif isinstance(self.action, list):
                # Serialize list items (may contain intrinsic functions)
                props['Action'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.action
                ]
            else:
                props["Action"] = self.action

        if self.compression is not None:
            # Serialize compression (handle intrinsic functions)
            if hasattr(self.compression, 'to_dict'):
                props["Compression"] = self.compression.to_dict()
            elif isinstance(self.compression, list):
                # Serialize list items (may contain intrinsic functions)
                props['Compression'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compression
                ]
            else:
                props["Compression"] = self.compression

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.data_partitions is not None:
            # Serialize data_partitions (handle intrinsic functions)
            if hasattr(self.data_partitions, 'to_dict'):
                props["DataPartitions"] = self.data_partitions.to_dict()
            elif isinstance(self.data_partitions, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataPartitions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_partitions
                ]
            else:
                props["DataPartitions"] = self.data_partitions

        if self.priority is not None:
            # Serialize priority (handle intrinsic functions)
            if hasattr(self.priority, 'to_dict'):
                props["Priority"] = self.priority.to_dict()
            elif isinstance(self.priority, list):
                # Serialize list items (may contain intrinsic functions)
                props['Priority'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.priority
                ]
            else:
                props["Priority"] = self.priority

        if self.signals_to_collect is not None:
            # Serialize signals_to_collect (handle intrinsic functions)
            if hasattr(self.signals_to_collect, 'to_dict'):
                props["SignalsToCollect"] = self.signals_to_collect.to_dict()
            elif isinstance(self.signals_to_collect, list):
                # Serialize list items (may contain intrinsic functions)
                props['SignalsToCollect'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.signals_to_collect
                ]
            else:
                props["SignalsToCollect"] = self.signals_to_collect

        if self.start_time is not None:
            # Serialize start_time (handle intrinsic functions)
            if hasattr(self.start_time, 'to_dict'):
                props["StartTime"] = self.start_time.to_dict()
            elif isinstance(self.start_time, list):
                # Serialize list items (may contain intrinsic functions)
                props['StartTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.start_time
                ]
            else:
                props["StartTime"] = self.start_time

        if self.signals_to_fetch is not None:
            # Serialize signals_to_fetch (handle intrinsic functions)
            if hasattr(self.signals_to_fetch, 'to_dict'):
                props["SignalsToFetch"] = self.signals_to_fetch.to_dict()
            elif isinstance(self.signals_to_fetch, list):
                # Serialize list items (may contain intrinsic functions)
                props['SignalsToFetch'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.signals_to_fetch
                ]
            else:
                props["SignalsToFetch"] = self.signals_to_fetch

        if self.expiry_time is not None:
            # Serialize expiry_time (handle intrinsic functions)
            if hasattr(self.expiry_time, 'to_dict'):
                props["ExpiryTime"] = self.expiry_time.to_dict()
            elif isinstance(self.expiry_time, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExpiryTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.expiry_time
                ]
            else:
                props["ExpiryTime"] = self.expiry_time

        if self.spooling_mode is not None:
            # Serialize spooling_mode (handle intrinsic functions)
            if hasattr(self.spooling_mode, 'to_dict'):
                props["SpoolingMode"] = self.spooling_mode.to_dict()
            elif isinstance(self.spooling_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['SpoolingMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spooling_mode
                ]
            else:
                props["SpoolingMode"] = self.spooling_mode

        if self.data_destination_configs is not None:
            # Serialize data_destination_configs (handle intrinsic functions)
            if hasattr(self.data_destination_configs, 'to_dict'):
                props["DataDestinationConfigs"] = self.data_destination_configs.to_dict()
            elif isinstance(self.data_destination_configs, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataDestinationConfigs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_destination_configs
                ]
            else:
                props["DataDestinationConfigs"] = self.data_destination_configs

        if self.signal_catalog_arn is not None:
            # Serialize signal_catalog_arn (handle intrinsic functions)
            if hasattr(self.signal_catalog_arn, 'to_dict'):
                props["SignalCatalogArn"] = self.signal_catalog_arn.to_dict()
            elif isinstance(self.signal_catalog_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['SignalCatalogArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.signal_catalog_arn
                ]
            else:
                props["SignalCatalogArn"] = self.signal_catalog_arn

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.post_trigger_collection_duration is not None:
            # Serialize post_trigger_collection_duration (handle intrinsic functions)
            if hasattr(self.post_trigger_collection_duration, 'to_dict'):
                props["PostTriggerCollectionDuration"] = self.post_trigger_collection_duration.to_dict()
            elif isinstance(self.post_trigger_collection_duration, list):
                # Serialize list items (may contain intrinsic functions)
                props['PostTriggerCollectionDuration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.post_trigger_collection_duration
                ]
            else:
                props["PostTriggerCollectionDuration"] = self.post_trigger_collection_duration

        if self.data_extra_dimensions is not None:
            # Serialize data_extra_dimensions (handle intrinsic functions)
            if hasattr(self.data_extra_dimensions, 'to_dict'):
                props["DataExtraDimensions"] = self.data_extra_dimensions.to_dict()
            elif isinstance(self.data_extra_dimensions, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataExtraDimensions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_extra_dimensions
                ]
            else:
                props["DataExtraDimensions"] = self.data_extra_dimensions

        if self.diagnostics_mode is not None:
            # Serialize diagnostics_mode (handle intrinsic functions)
            if hasattr(self.diagnostics_mode, 'to_dict'):
                props["DiagnosticsMode"] = self.diagnostics_mode.to_dict()
            elif isinstance(self.diagnostics_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['DiagnosticsMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.diagnostics_mode
                ]
            else:
                props["DiagnosticsMode"] = self.diagnostics_mode

        if self.target_arn is not None:
            # Serialize target_arn (handle intrinsic functions)
            if hasattr(self.target_arn, 'to_dict'):
                props["TargetArn"] = self.target_arn.to_dict()
            elif isinstance(self.target_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_arn
                ]
            else:
                props["TargetArn"] = self.target_arn

        if self.collection_scheme is not None:
            # Serialize collection_scheme (handle intrinsic functions)
            if hasattr(self.collection_scheme, 'to_dict'):
                props["CollectionScheme"] = self.collection_scheme.to_dict()
            elif isinstance(self.collection_scheme, list):
                # Serialize list items (may contain intrinsic functions)
                props['CollectionScheme'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.collection_scheme
                ]
            else:
                props["CollectionScheme"] = self.collection_scheme

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_last_modification_time(self) -> GetAtt:
        """Get the LastModificationTime attribute."""
        return self.get_att("LastModificationTime")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class CanInterface:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.protocol_name is not None:
            if hasattr(self.protocol_name, 'to_dict'):
                props['ProtocolName'] = self.protocol_name.to_dict()
            elif isinstance(self.protocol_name, list):
                props['ProtocolName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol_name
                ]
            else:
                props['ProtocolName'] = self.protocol_name

        if self.protocol_version is not None:
            if hasattr(self.protocol_version, 'to_dict'):
                props['ProtocolVersion'] = self.protocol_version.to_dict()
            elif isinstance(self.protocol_version, list):
                props['ProtocolVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol_version
                ]
            else:
                props['ProtocolVersion'] = self.protocol_version

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class CanSignal:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    is_big_endian: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    length: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    factor: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    is_signed: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    signal_value_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    start_bit: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    message_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    offset: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.is_big_endian is not None:
            if hasattr(self.is_big_endian, 'to_dict'):
                props['IsBigEndian'] = self.is_big_endian.to_dict()
            elif isinstance(self.is_big_endian, list):
                props['IsBigEndian'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.is_big_endian
                ]
            else:
                props['IsBigEndian'] = self.is_big_endian

        if self.length is not None:
            if hasattr(self.length, 'to_dict'):
                props['Length'] = self.length.to_dict()
            elif isinstance(self.length, list):
                props['Length'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.length
                ]
            else:
                props['Length'] = self.length

        if self.factor is not None:
            if hasattr(self.factor, 'to_dict'):
                props['Factor'] = self.factor.to_dict()
            elif isinstance(self.factor, list):
                props['Factor'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.factor
                ]
            else:
                props['Factor'] = self.factor

        if self.is_signed is not None:
            if hasattr(self.is_signed, 'to_dict'):
                props['IsSigned'] = self.is_signed.to_dict()
            elif isinstance(self.is_signed, list):
                props['IsSigned'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.is_signed
                ]
            else:
                props['IsSigned'] = self.is_signed

        if self.signal_value_type is not None:
            if hasattr(self.signal_value_type, 'to_dict'):
                props['SignalValueType'] = self.signal_value_type.to_dict()
            elif isinstance(self.signal_value_type, list):
                props['SignalValueType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.signal_value_type
                ]
            else:
                props['SignalValueType'] = self.signal_value_type

        if self.start_bit is not None:
            if hasattr(self.start_bit, 'to_dict'):
                props['StartBit'] = self.start_bit.to_dict()
            elif isinstance(self.start_bit, list):
                props['StartBit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.start_bit
                ]
            else:
                props['StartBit'] = self.start_bit

        if self.message_id is not None:
            if hasattr(self.message_id, 'to_dict'):
                props['MessageId'] = self.message_id.to_dict()
            elif isinstance(self.message_id, list):
                props['MessageId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.message_id
                ]
            else:
                props['MessageId'] = self.message_id

        if self.offset is not None:
            if hasattr(self.offset, 'to_dict'):
                props['Offset'] = self.offset.to_dict()
            elif isinstance(self.offset, list):
                props['Offset'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.offset
                ]
            else:
                props['Offset'] = self.offset

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class CustomDecodingInterface:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class CustomDecodingSignal:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.id is not None:
            if hasattr(self.id, 'to_dict'):
                props['Id'] = self.id.to_dict()
            elif isinstance(self.id, list):
                props['Id'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.id
                ]
            else:
                props['Id'] = self.id

        return props


@dataclass
class NetworkInterfacesItems:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    can_interface: Optional[CanInterface] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_decoding_interface: Optional[CustomDecodingInterface] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    obd_interface: Optional[ObdInterface] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.can_interface is not None:
            if hasattr(self.can_interface, 'to_dict'):
                props['CanInterface'] = self.can_interface.to_dict()
            elif isinstance(self.can_interface, list):
                props['CanInterface'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.can_interface
                ]
            else:
                props['CanInterface'] = self.can_interface

        if self.custom_decoding_interface is not None:
            if hasattr(self.custom_decoding_interface, 'to_dict'):
                props['CustomDecodingInterface'] = self.custom_decoding_interface.to_dict()
            elif isinstance(self.custom_decoding_interface, list):
                props['CustomDecodingInterface'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_decoding_interface
                ]
            else:
                props['CustomDecodingInterface'] = self.custom_decoding_interface

        if self.interface_id is not None:
            if hasattr(self.interface_id, 'to_dict'):
                props['InterfaceId'] = self.interface_id.to_dict()
            elif isinstance(self.interface_id, list):
                props['InterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.interface_id
                ]
            else:
                props['InterfaceId'] = self.interface_id

        if self.obd_interface is not None:
            if hasattr(self.obd_interface, 'to_dict'):
                props['ObdInterface'] = self.obd_interface.to_dict()
            elif isinstance(self.obd_interface, list):
                props['ObdInterface'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.obd_interface
                ]
            else:
                props['ObdInterface'] = self.obd_interface

        return props


@dataclass
class ObdInterface:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    has_transmission_ecu: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    pid_request_interval_seconds: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    use_extended_ids: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    request_message_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    obd_standard: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dtc_request_interval_seconds: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.has_transmission_ecu is not None:
            if hasattr(self.has_transmission_ecu, 'to_dict'):
                props['HasTransmissionEcu'] = self.has_transmission_ecu.to_dict()
            elif isinstance(self.has_transmission_ecu, list):
                props['HasTransmissionEcu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.has_transmission_ecu
                ]
            else:
                props['HasTransmissionEcu'] = self.has_transmission_ecu

        if self.pid_request_interval_seconds is not None:
            if hasattr(self.pid_request_interval_seconds, 'to_dict'):
                props['PidRequestIntervalSeconds'] = self.pid_request_interval_seconds.to_dict()
            elif isinstance(self.pid_request_interval_seconds, list):
                props['PidRequestIntervalSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pid_request_interval_seconds
                ]
            else:
                props['PidRequestIntervalSeconds'] = self.pid_request_interval_seconds

        if self.use_extended_ids is not None:
            if hasattr(self.use_extended_ids, 'to_dict'):
                props['UseExtendedIds'] = self.use_extended_ids.to_dict()
            elif isinstance(self.use_extended_ids, list):
                props['UseExtendedIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.use_extended_ids
                ]
            else:
                props['UseExtendedIds'] = self.use_extended_ids

        if self.request_message_id is not None:
            if hasattr(self.request_message_id, 'to_dict'):
                props['RequestMessageId'] = self.request_message_id.to_dict()
            elif isinstance(self.request_message_id, list):
                props['RequestMessageId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.request_message_id
                ]
            else:
                props['RequestMessageId'] = self.request_message_id

        if self.obd_standard is not None:
            if hasattr(self.obd_standard, 'to_dict'):
                props['ObdStandard'] = self.obd_standard.to_dict()
            elif isinstance(self.obd_standard, list):
                props['ObdStandard'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.obd_standard
                ]
            else:
                props['ObdStandard'] = self.obd_standard

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        if self.dtc_request_interval_seconds is not None:
            if hasattr(self.dtc_request_interval_seconds, 'to_dict'):
                props['DtcRequestIntervalSeconds'] = self.dtc_request_interval_seconds.to_dict()
            elif isinstance(self.dtc_request_interval_seconds, list):
                props['DtcRequestIntervalSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dtc_request_interval_seconds
                ]
            else:
                props['DtcRequestIntervalSeconds'] = self.dtc_request_interval_seconds

        return props


@dataclass
class ObdSignal:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bit_right_shift: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bit_mask_length: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    start_byte: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    byte_length: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    pid_response_length: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scaling: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    pid: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    is_signed: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    signal_value_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    service_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    offset: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.bit_right_shift is not None:
            if hasattr(self.bit_right_shift, 'to_dict'):
                props['BitRightShift'] = self.bit_right_shift.to_dict()
            elif isinstance(self.bit_right_shift, list):
                props['BitRightShift'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bit_right_shift
                ]
            else:
                props['BitRightShift'] = self.bit_right_shift

        if self.bit_mask_length is not None:
            if hasattr(self.bit_mask_length, 'to_dict'):
                props['BitMaskLength'] = self.bit_mask_length.to_dict()
            elif isinstance(self.bit_mask_length, list):
                props['BitMaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bit_mask_length
                ]
            else:
                props['BitMaskLength'] = self.bit_mask_length

        if self.start_byte is not None:
            if hasattr(self.start_byte, 'to_dict'):
                props['StartByte'] = self.start_byte.to_dict()
            elif isinstance(self.start_byte, list):
                props['StartByte'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.start_byte
                ]
            else:
                props['StartByte'] = self.start_byte

        if self.byte_length is not None:
            if hasattr(self.byte_length, 'to_dict'):
                props['ByteLength'] = self.byte_length.to_dict()
            elif isinstance(self.byte_length, list):
                props['ByteLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.byte_length
                ]
            else:
                props['ByteLength'] = self.byte_length

        if self.pid_response_length is not None:
            if hasattr(self.pid_response_length, 'to_dict'):
                props['PidResponseLength'] = self.pid_response_length.to_dict()
            elif isinstance(self.pid_response_length, list):
                props['PidResponseLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pid_response_length
                ]
            else:
                props['PidResponseLength'] = self.pid_response_length

        if self.scaling is not None:
            if hasattr(self.scaling, 'to_dict'):
                props['Scaling'] = self.scaling.to_dict()
            elif isinstance(self.scaling, list):
                props['Scaling'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scaling
                ]
            else:
                props['Scaling'] = self.scaling

        if self.pid is not None:
            if hasattr(self.pid, 'to_dict'):
                props['Pid'] = self.pid.to_dict()
            elif isinstance(self.pid, list):
                props['Pid'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pid
                ]
            else:
                props['Pid'] = self.pid

        if self.is_signed is not None:
            if hasattr(self.is_signed, 'to_dict'):
                props['IsSigned'] = self.is_signed.to_dict()
            elif isinstance(self.is_signed, list):
                props['IsSigned'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.is_signed
                ]
            else:
                props['IsSigned'] = self.is_signed

        if self.signal_value_type is not None:
            if hasattr(self.signal_value_type, 'to_dict'):
                props['SignalValueType'] = self.signal_value_type.to_dict()
            elif isinstance(self.signal_value_type, list):
                props['SignalValueType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.signal_value_type
                ]
            else:
                props['SignalValueType'] = self.signal_value_type

        if self.service_mode is not None:
            if hasattr(self.service_mode, 'to_dict'):
                props['ServiceMode'] = self.service_mode.to_dict()
            elif isinstance(self.service_mode, list):
                props['ServiceMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_mode
                ]
            else:
                props['ServiceMode'] = self.service_mode

        if self.offset is not None:
            if hasattr(self.offset, 'to_dict'):
                props['Offset'] = self.offset.to_dict()
            elif isinstance(self.offset, list):
                props['Offset'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.offset
                ]
            else:
                props['Offset'] = self.offset

        return props


@dataclass
class SignalDecodersItems:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    obd_signal: Optional[ObdSignal] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    fully_qualified_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_decoding_signal: Optional[CustomDecodingSignal] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    can_signal: Optional[CanSignal] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.obd_signal is not None:
            if hasattr(self.obd_signal, 'to_dict'):
                props['ObdSignal'] = self.obd_signal.to_dict()
            elif isinstance(self.obd_signal, list):
                props['ObdSignal'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.obd_signal
                ]
            else:
                props['ObdSignal'] = self.obd_signal

        if self.fully_qualified_name is not None:
            if hasattr(self.fully_qualified_name, 'to_dict'):
                props['FullyQualifiedName'] = self.fully_qualified_name.to_dict()
            elif isinstance(self.fully_qualified_name, list):
                props['FullyQualifiedName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fully_qualified_name
                ]
            else:
                props['FullyQualifiedName'] = self.fully_qualified_name

        if self.custom_decoding_signal is not None:
            if hasattr(self.custom_decoding_signal, 'to_dict'):
                props['CustomDecodingSignal'] = self.custom_decoding_signal.to_dict()
            elif isinstance(self.custom_decoding_signal, list):
                props['CustomDecodingSignal'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_decoding_signal
                ]
            else:
                props['CustomDecodingSignal'] = self.custom_decoding_signal

        if self.can_signal is not None:
            if hasattr(self.can_signal, 'to_dict'):
                props['CanSignal'] = self.can_signal.to_dict()
            elif isinstance(self.can_signal, list):
                props['CanSignal'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.can_signal
                ]
            else:
                props['CanSignal'] = self.can_signal

        if self.interface_id is not None:
            if hasattr(self.interface_id, 'to_dict'):
                props['InterfaceId'] = self.interface_id.to_dict()
            elif isinstance(self.interface_id, list):
                props['InterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.interface_id
                ]
            else:
                props['InterfaceId'] = self.interface_id

        return props


@dataclass
class DecoderManifest(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iotfl"""

    resource_type: ClassVar[str] = "AWS::IoTFleetWise::DecoderManifest"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    signal_decoders: Optional[list[SignalDecodersItems]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interfaces: Optional[list[NetworkInterfacesItems]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_manifest_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_for_unmapped_signals: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.signal_decoders is not None:
            # Serialize signal_decoders (handle intrinsic functions)
            if hasattr(self.signal_decoders, 'to_dict'):
                props["SignalDecoders"] = self.signal_decoders.to_dict()
            elif isinstance(self.signal_decoders, list):
                # Serialize list items (may contain intrinsic functions)
                props['SignalDecoders'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.signal_decoders
                ]
            else:
                props["SignalDecoders"] = self.signal_decoders

        if self.status is not None:
            # Serialize status (handle intrinsic functions)
            if hasattr(self.status, 'to_dict'):
                props["Status"] = self.status.to_dict()
            elif isinstance(self.status, list):
                # Serialize list items (may contain intrinsic functions)
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props["Status"] = self.status

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.network_interfaces is not None:
            # Serialize network_interfaces (handle intrinsic functions)
            if hasattr(self.network_interfaces, 'to_dict'):
                props["NetworkInterfaces"] = self.network_interfaces.to_dict()
            elif isinstance(self.network_interfaces, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaces'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interfaces
                ]
            else:
                props["NetworkInterfaces"] = self.network_interfaces

        if self.model_manifest_arn is not None:
            # Serialize model_manifest_arn (handle intrinsic functions)
            if hasattr(self.model_manifest_arn, 'to_dict'):
                props["ModelManifestArn"] = self.model_manifest_arn.to_dict()
            elif isinstance(self.model_manifest_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelManifestArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_manifest_arn
                ]
            else:
                props["ModelManifestArn"] = self.model_manifest_arn

        if self.default_for_unmapped_signals is not None:
            # Serialize default_for_unmapped_signals (handle intrinsic functions)
            if hasattr(self.default_for_unmapped_signals, 'to_dict'):
                props["DefaultForUnmappedSignals"] = self.default_for_unmapped_signals.to_dict()
            elif isinstance(self.default_for_unmapped_signals, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultForUnmappedSignals'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_for_unmapped_signals
                ]
            else:
                props["DefaultForUnmappedSignals"] = self.default_for_unmapped_signals

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_last_modification_time(self) -> GetAtt:
        """Get the LastModificationTime attribute."""
        return self.get_att("LastModificationTime")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class Fleet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iotfl"""

    resource_type: ClassVar[str] = "AWS::IoTFleetWise::Fleet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    signal_catalog_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.id is not None:
            # Serialize id (handle intrinsic functions)
            if hasattr(self.id, 'to_dict'):
                props["Id"] = self.id.to_dict()
            elif isinstance(self.id, list):
                # Serialize list items (may contain intrinsic functions)
                props['Id'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.id
                ]
            else:
                props["Id"] = self.id

        if self.signal_catalog_arn is not None:
            # Serialize signal_catalog_arn (handle intrinsic functions)
            if hasattr(self.signal_catalog_arn, 'to_dict'):
                props["SignalCatalogArn"] = self.signal_catalog_arn.to_dict()
            elif isinstance(self.signal_catalog_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['SignalCatalogArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.signal_catalog_arn
                ]
            else:
                props["SignalCatalogArn"] = self.signal_catalog_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_last_modification_time(self) -> GetAtt:
        """Get the LastModificationTime attribute."""
        return self.get_att("LastModificationTime")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class ModelManifest(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iotfl"""

    resource_type: ClassVar[str] = "AWS::IoTFleetWise::ModelManifest"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    signal_catalog_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    nodes: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.status is not None:
            # Serialize status (handle intrinsic functions)
            if hasattr(self.status, 'to_dict'):
                props["Status"] = self.status.to_dict()
            elif isinstance(self.status, list):
                # Serialize list items (may contain intrinsic functions)
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props["Status"] = self.status

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.signal_catalog_arn is not None:
            # Serialize signal_catalog_arn (handle intrinsic functions)
            if hasattr(self.signal_catalog_arn, 'to_dict'):
                props["SignalCatalogArn"] = self.signal_catalog_arn.to_dict()
            elif isinstance(self.signal_catalog_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['SignalCatalogArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.signal_catalog_arn
                ]
            else:
                props["SignalCatalogArn"] = self.signal_catalog_arn

        if self.nodes is not None:
            # Serialize nodes (handle intrinsic functions)
            if hasattr(self.nodes, 'to_dict'):
                props["Nodes"] = self.nodes.to_dict()
            elif isinstance(self.nodes, list):
                # Serialize list items (may contain intrinsic functions)
                props['Nodes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.nodes
                ]
            else:
                props["Nodes"] = self.nodes

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_last_modification_time(self) -> GetAtt:
        """Get the LastModificationTime attribute."""
        return self.get_att("LastModificationTime")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class Actuator:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allowed_values: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    fully_qualified_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    assigned_value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.allowed_values is not None:
            if hasattr(self.allowed_values, 'to_dict'):
                props['AllowedValues'] = self.allowed_values.to_dict()
            elif isinstance(self.allowed_values, list):
                props['AllowedValues'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_values
                ]
            else:
                props['AllowedValues'] = self.allowed_values

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        if self.fully_qualified_name is not None:
            if hasattr(self.fully_qualified_name, 'to_dict'):
                props['FullyQualifiedName'] = self.fully_qualified_name.to_dict()
            elif isinstance(self.fully_qualified_name, list):
                props['FullyQualifiedName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fully_qualified_name
                ]
            else:
                props['FullyQualifiedName'] = self.fully_qualified_name

        if self.assigned_value is not None:
            if hasattr(self.assigned_value, 'to_dict'):
                props['AssignedValue'] = self.assigned_value.to_dict()
            elif isinstance(self.assigned_value, list):
                props['AssignedValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.assigned_value
                ]
            else:
                props['AssignedValue'] = self.assigned_value

        if self.data_type is not None:
            if hasattr(self.data_type, 'to_dict'):
                props['DataType'] = self.data_type.to_dict()
            elif isinstance(self.data_type, list):
                props['DataType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_type
                ]
            else:
                props['DataType'] = self.data_type

        if self.unit is not None:
            if hasattr(self.unit, 'to_dict'):
                props['Unit'] = self.unit.to_dict()
            elif isinstance(self.unit, list):
                props['Unit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unit
                ]
            else:
                props['Unit'] = self.unit

        return props


@dataclass
class Attribute:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allowed_values: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    fully_qualified_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    assigned_value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_value is not None:
            if hasattr(self.default_value, 'to_dict'):
                props['DefaultValue'] = self.default_value.to_dict()
            elif isinstance(self.default_value, list):
                props['DefaultValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_value
                ]
            else:
                props['DefaultValue'] = self.default_value

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.allowed_values is not None:
            if hasattr(self.allowed_values, 'to_dict'):
                props['AllowedValues'] = self.allowed_values.to_dict()
            elif isinstance(self.allowed_values, list):
                props['AllowedValues'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_values
                ]
            else:
                props['AllowedValues'] = self.allowed_values

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        if self.fully_qualified_name is not None:
            if hasattr(self.fully_qualified_name, 'to_dict'):
                props['FullyQualifiedName'] = self.fully_qualified_name.to_dict()
            elif isinstance(self.fully_qualified_name, list):
                props['FullyQualifiedName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fully_qualified_name
                ]
            else:
                props['FullyQualifiedName'] = self.fully_qualified_name

        if self.assigned_value is not None:
            if hasattr(self.assigned_value, 'to_dict'):
                props['AssignedValue'] = self.assigned_value.to_dict()
            elif isinstance(self.assigned_value, list):
                props['AssignedValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.assigned_value
                ]
            else:
                props['AssignedValue'] = self.assigned_value

        if self.data_type is not None:
            if hasattr(self.data_type, 'to_dict'):
                props['DataType'] = self.data_type.to_dict()
            elif isinstance(self.data_type, list):
                props['DataType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_type
                ]
            else:
                props['DataType'] = self.data_type

        if self.unit is not None:
            if hasattr(self.unit, 'to_dict'):
                props['Unit'] = self.unit.to_dict()
            elif isinstance(self.unit, list):
                props['Unit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unit
                ]
            else:
                props['Unit'] = self.unit

        return props


@dataclass
class Branch:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    fully_qualified_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.fully_qualified_name is not None:
            if hasattr(self.fully_qualified_name, 'to_dict'):
                props['FullyQualifiedName'] = self.fully_qualified_name.to_dict()
            elif isinstance(self.fully_qualified_name, list):
                props['FullyQualifiedName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fully_qualified_name
                ]
            else:
                props['FullyQualifiedName'] = self.fully_qualified_name

        return props


@dataclass
class Node:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attribute: Optional[Attribute] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    branch: Optional[Branch] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sensor: Optional[Sensor] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    actuator: Optional[Actuator] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.attribute is not None:
            if hasattr(self.attribute, 'to_dict'):
                props['Attribute'] = self.attribute.to_dict()
            elif isinstance(self.attribute, list):
                props['Attribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attribute
                ]
            else:
                props['Attribute'] = self.attribute

        if self.branch is not None:
            if hasattr(self.branch, 'to_dict'):
                props['Branch'] = self.branch.to_dict()
            elif isinstance(self.branch, list):
                props['Branch'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.branch
                ]
            else:
                props['Branch'] = self.branch

        if self.sensor is not None:
            if hasattr(self.sensor, 'to_dict'):
                props['Sensor'] = self.sensor.to_dict()
            elif isinstance(self.sensor, list):
                props['Sensor'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sensor
                ]
            else:
                props['Sensor'] = self.sensor

        if self.actuator is not None:
            if hasattr(self.actuator, 'to_dict'):
                props['Actuator'] = self.actuator.to_dict()
            elif isinstance(self.actuator, list):
                props['Actuator'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.actuator
                ]
            else:
                props['Actuator'] = self.actuator

        return props


@dataclass
class NodeCounts:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    total_actuators: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    total_nodes: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    total_attributes: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    total_branches: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    total_sensors: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.total_actuators is not None:
            if hasattr(self.total_actuators, 'to_dict'):
                props['TotalActuators'] = self.total_actuators.to_dict()
            elif isinstance(self.total_actuators, list):
                props['TotalActuators'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_actuators
                ]
            else:
                props['TotalActuators'] = self.total_actuators

        if self.total_nodes is not None:
            if hasattr(self.total_nodes, 'to_dict'):
                props['TotalNodes'] = self.total_nodes.to_dict()
            elif isinstance(self.total_nodes, list):
                props['TotalNodes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_nodes
                ]
            else:
                props['TotalNodes'] = self.total_nodes

        if self.total_attributes is not None:
            if hasattr(self.total_attributes, 'to_dict'):
                props['TotalAttributes'] = self.total_attributes.to_dict()
            elif isinstance(self.total_attributes, list):
                props['TotalAttributes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_attributes
                ]
            else:
                props['TotalAttributes'] = self.total_attributes

        if self.total_branches is not None:
            if hasattr(self.total_branches, 'to_dict'):
                props['TotalBranches'] = self.total_branches.to_dict()
            elif isinstance(self.total_branches, list):
                props['TotalBranches'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_branches
                ]
            else:
                props['TotalBranches'] = self.total_branches

        if self.total_sensors is not None:
            if hasattr(self.total_sensors, 'to_dict'):
                props['TotalSensors'] = self.total_sensors.to_dict()
            elif isinstance(self.total_sensors, list):
                props['TotalSensors'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_sensors
                ]
            else:
                props['TotalSensors'] = self.total_sensors

        return props


@dataclass
class Sensor:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allowed_values: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    fully_qualified_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.allowed_values is not None:
            if hasattr(self.allowed_values, 'to_dict'):
                props['AllowedValues'] = self.allowed_values.to_dict()
            elif isinstance(self.allowed_values, list):
                props['AllowedValues'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_values
                ]
            else:
                props['AllowedValues'] = self.allowed_values

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        if self.fully_qualified_name is not None:
            if hasattr(self.fully_qualified_name, 'to_dict'):
                props['FullyQualifiedName'] = self.fully_qualified_name.to_dict()
            elif isinstance(self.fully_qualified_name, list):
                props['FullyQualifiedName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fully_qualified_name
                ]
            else:
                props['FullyQualifiedName'] = self.fully_qualified_name

        if self.data_type is not None:
            if hasattr(self.data_type, 'to_dict'):
                props['DataType'] = self.data_type.to_dict()
            elif isinstance(self.data_type, list):
                props['DataType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_type
                ]
            else:
                props['DataType'] = self.data_type

        if self.unit is not None:
            if hasattr(self.unit, 'to_dict'):
                props['Unit'] = self.unit.to_dict()
            elif isinstance(self.unit, list):
                props['Unit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unit
                ]
            else:
                props['Unit'] = self.unit

        return props


@dataclass
class SignalCatalog(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iotfl"""

    resource_type: ClassVar[str] = "AWS::IoTFleetWise::SignalCatalog"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    node_counts: Optional[NodeCounts] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    nodes: Optional[list[Node]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.node_counts is not None:
            # Serialize node_counts (handle intrinsic functions)
            if hasattr(self.node_counts, 'to_dict'):
                props["NodeCounts"] = self.node_counts.to_dict()
            elif isinstance(self.node_counts, list):
                # Serialize list items (may contain intrinsic functions)
                props['NodeCounts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.node_counts
                ]
            else:
                props["NodeCounts"] = self.node_counts

        if self.nodes is not None:
            # Serialize nodes (handle intrinsic functions)
            if hasattr(self.nodes, 'to_dict'):
                props["Nodes"] = self.nodes.to_dict()
            elif isinstance(self.nodes, list):
                # Serialize list items (may contain intrinsic functions)
                props['Nodes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.nodes
                ]
            else:
                props["Nodes"] = self.nodes

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_last_modification_time(self) -> GetAtt:
        """Get the LastModificationTime attribute."""
        return self.get_att("LastModificationTime")

    @property
    def attr_node_counts__total_nodes(self) -> GetAtt:
        """Get the NodeCounts.TotalNodes attribute."""
        return self.get_att("NodeCounts.TotalNodes")

    @property
    def attr_node_counts__total_sensors(self) -> GetAtt:
        """Get the NodeCounts.TotalSensors attribute."""
        return self.get_att("NodeCounts.TotalSensors")

    @property
    def attr_node_counts__total_attributes(self) -> GetAtt:
        """Get the NodeCounts.TotalAttributes attribute."""
        return self.get_att("NodeCounts.TotalAttributes")

    @property
    def attr_node_counts__total_branches(self) -> GetAtt:
        """Get the NodeCounts.TotalBranches attribute."""
        return self.get_att("NodeCounts.TotalBranches")

    @property
    def attr_node_counts__total_actuators(self) -> GetAtt:
        """Get the NodeCounts.TotalActuators attribute."""
        return self.get_att("NodeCounts.TotalActuators")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class StateTemplate(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iotfl"""

    resource_type: ClassVar[str] = "AWS::IoTFleetWise::StateTemplate"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    state_template_properties: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_extra_dimensions: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    signal_catalog_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metadata_extra_dimensions: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.state_template_properties is not None:
            # Serialize state_template_properties (handle intrinsic functions)
            if hasattr(self.state_template_properties, 'to_dict'):
                props["StateTemplateProperties"] = self.state_template_properties.to_dict()
            elif isinstance(self.state_template_properties, list):
                # Serialize list items (may contain intrinsic functions)
                props['StateTemplateProperties'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state_template_properties
                ]
            else:
                props["StateTemplateProperties"] = self.state_template_properties

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.data_extra_dimensions is not None:
            # Serialize data_extra_dimensions (handle intrinsic functions)
            if hasattr(self.data_extra_dimensions, 'to_dict'):
                props["DataExtraDimensions"] = self.data_extra_dimensions.to_dict()
            elif isinstance(self.data_extra_dimensions, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataExtraDimensions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_extra_dimensions
                ]
            else:
                props["DataExtraDimensions"] = self.data_extra_dimensions

        if self.signal_catalog_arn is not None:
            # Serialize signal_catalog_arn (handle intrinsic functions)
            if hasattr(self.signal_catalog_arn, 'to_dict'):
                props["SignalCatalogArn"] = self.signal_catalog_arn.to_dict()
            elif isinstance(self.signal_catalog_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['SignalCatalogArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.signal_catalog_arn
                ]
            else:
                props["SignalCatalogArn"] = self.signal_catalog_arn

        if self.metadata_extra_dimensions is not None:
            # Serialize metadata_extra_dimensions (handle intrinsic functions)
            if hasattr(self.metadata_extra_dimensions, 'to_dict'):
                props["MetadataExtraDimensions"] = self.metadata_extra_dimensions.to_dict()
            elif isinstance(self.metadata_extra_dimensions, list):
                # Serialize list items (may contain intrinsic functions)
                props['MetadataExtraDimensions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metadata_extra_dimensions
                ]
            else:
                props["MetadataExtraDimensions"] = self.metadata_extra_dimensions

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_last_modification_time(self) -> GetAtt:
        """Get the LastModificationTime attribute."""
        return self.get_att("LastModificationTime")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class PeriodicStateTemplateUpdateStrategy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    state_template_update_rate: Optional[TimePeriod] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.state_template_update_rate is not None:
            if hasattr(self.state_template_update_rate, 'to_dict'):
                props['StateTemplateUpdateRate'] = self.state_template_update_rate.to_dict()
            elif isinstance(self.state_template_update_rate, list):
                props['StateTemplateUpdateRate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state_template_update_rate
                ]
            else:
                props['StateTemplateUpdateRate'] = self.state_template_update_rate

        return props


@dataclass
class StateTemplateAssociation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    state_template_update_strategy: Optional[StateTemplateUpdateStrategy] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.identifier is not None:
            if hasattr(self.identifier, 'to_dict'):
                props['Identifier'] = self.identifier.to_dict()
            elif isinstance(self.identifier, list):
                props['Identifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.identifier
                ]
            else:
                props['Identifier'] = self.identifier

        if self.state_template_update_strategy is not None:
            if hasattr(self.state_template_update_strategy, 'to_dict'):
                props['StateTemplateUpdateStrategy'] = self.state_template_update_strategy.to_dict()
            elif isinstance(self.state_template_update_strategy, list):
                props['StateTemplateUpdateStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state_template_update_strategy
                ]
            else:
                props['StateTemplateUpdateStrategy'] = self.state_template_update_strategy

        return props


@dataclass
class StateTemplateUpdateStrategy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_change: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    periodic: Optional[PeriodicStateTemplateUpdateStrategy] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.on_change is not None:
            if hasattr(self.on_change, 'to_dict'):
                props['OnChange'] = self.on_change.to_dict()
            elif isinstance(self.on_change, list):
                props['OnChange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_change
                ]
            else:
                props['OnChange'] = self.on_change

        if self.periodic is not None:
            if hasattr(self.periodic, 'to_dict'):
                props['Periodic'] = self.periodic.to_dict()
            elif isinstance(self.periodic, list):
                props['Periodic'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.periodic
                ]
            else:
                props['Periodic'] = self.periodic

        return props


@dataclass
class TimePeriod:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-iot"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.unit is not None:
            if hasattr(self.unit, 'to_dict'):
                props['Unit'] = self.unit.to_dict()
            elif isinstance(self.unit, list):
                props['Unit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unit
                ]
            else:
                props['Unit'] = self.unit

        return props


@dataclass
class Vehicle(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iotfl"""

    resource_type: ClassVar[str] = "AWS::IoTFleetWise::Vehicle"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    association_behavior: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    attributes: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    decoder_manifest_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    state_templates: Optional[list[StateTemplateAssociation]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_manifest_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.association_behavior is not None:
            # Serialize association_behavior (handle intrinsic functions)
            if hasattr(self.association_behavior, 'to_dict'):
                props["AssociationBehavior"] = self.association_behavior.to_dict()
            elif isinstance(self.association_behavior, list):
                # Serialize list items (may contain intrinsic functions)
                props['AssociationBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.association_behavior
                ]
            else:
                props["AssociationBehavior"] = self.association_behavior

        if self.attributes is not None:
            # Serialize attributes (handle intrinsic functions)
            if hasattr(self.attributes, 'to_dict'):
                props["Attributes"] = self.attributes.to_dict()
            elif isinstance(self.attributes, list):
                # Serialize list items (may contain intrinsic functions)
                props['Attributes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attributes
                ]
            else:
                props["Attributes"] = self.attributes

        if self.decoder_manifest_arn is not None:
            # Serialize decoder_manifest_arn (handle intrinsic functions)
            if hasattr(self.decoder_manifest_arn, 'to_dict'):
                props["DecoderManifestArn"] = self.decoder_manifest_arn.to_dict()
            elif isinstance(self.decoder_manifest_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['DecoderManifestArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.decoder_manifest_arn
                ]
            else:
                props["DecoderManifestArn"] = self.decoder_manifest_arn

        if self.state_templates is not None:
            # Serialize state_templates (handle intrinsic functions)
            if hasattr(self.state_templates, 'to_dict'):
                props["StateTemplates"] = self.state_templates.to_dict()
            elif isinstance(self.state_templates, list):
                # Serialize list items (may contain intrinsic functions)
                props['StateTemplates'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state_templates
                ]
            else:
                props["StateTemplates"] = self.state_templates

        if self.model_manifest_arn is not None:
            # Serialize model_manifest_arn (handle intrinsic functions)
            if hasattr(self.model_manifest_arn, 'to_dict'):
                props["ModelManifestArn"] = self.model_manifest_arn.to_dict()
            elif isinstance(self.model_manifest_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelManifestArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_manifest_arn
                ]
            else:
                props["ModelManifestArn"] = self.model_manifest_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_last_modification_time(self) -> GetAtt:
        """Get the LastModificationTime attribute."""
        return self.get_att("LastModificationTime")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")



