"""
AWS CloudFormation FSx Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 227.0.0
  Generator Version: 1.0.0
  Combined: spec-227.0.0_gen-1.0.0
  Generated: 2025-12-15 17:57:21

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service FSx
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


@dataclass
class AutoExportPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    events: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.events is not None:
            if hasattr(self.events, 'to_dict'):
                props['Events'] = self.events.to_dict()
            elif isinstance(self.events, list):
                props['Events'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.events
                ]
            else:
                props['Events'] = self.events

        return props


@dataclass
class AutoImportPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    events: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.events is not None:
            if hasattr(self.events, 'to_dict'):
                props['Events'] = self.events.to_dict()
            elif isinstance(self.events, list):
                props['Events'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.events
                ]
            else:
                props['Events'] = self.events

        return props


@dataclass
class S3:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auto_import_policy: Optional[AutoImportPolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auto_export_policy: Optional[AutoExportPolicy] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.auto_import_policy is not None:
            if hasattr(self.auto_import_policy, 'to_dict'):
                props['AutoImportPolicy'] = self.auto_import_policy.to_dict()
            elif isinstance(self.auto_import_policy, list):
                props['AutoImportPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_import_policy
                ]
            else:
                props['AutoImportPolicy'] = self.auto_import_policy

        if self.auto_export_policy is not None:
            if hasattr(self.auto_export_policy, 'to_dict'):
                props['AutoExportPolicy'] = self.auto_export_policy.to_dict()
            elif isinstance(self.auto_export_policy, list):
                props['AutoExportPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_export_policy
                ]
            else:
                props['AutoExportPolicy'] = self.auto_export_policy

        return props


@dataclass
class DataRepositoryAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-fsx-d"""

    resource_type: ClassVar[str] = "AWS::FSx::DataRepositoryAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    file_system_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_repository_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    batch_import_meta_data_on_create: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    s3: Optional[S3] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    file_system_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    imported_file_chunk_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.file_system_path is not None:
            # Serialize file_system_path (handle intrinsic functions)
            if hasattr(self.file_system_path, 'to_dict'):
                props["FileSystemPath"] = self.file_system_path.to_dict()
            elif isinstance(self.file_system_path, list):
                # Serialize list items (may contain intrinsic functions)
                props['FileSystemPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_path
                ]
            else:
                props["FileSystemPath"] = self.file_system_path

        if self.data_repository_path is not None:
            # Serialize data_repository_path (handle intrinsic functions)
            if hasattr(self.data_repository_path, 'to_dict'):
                props["DataRepositoryPath"] = self.data_repository_path.to_dict()
            elif isinstance(self.data_repository_path, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataRepositoryPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_repository_path
                ]
            else:
                props["DataRepositoryPath"] = self.data_repository_path

        if self.batch_import_meta_data_on_create is not None:
            # Serialize batch_import_meta_data_on_create (handle intrinsic functions)
            if hasattr(self.batch_import_meta_data_on_create, 'to_dict'):
                props["BatchImportMetaDataOnCreate"] = self.batch_import_meta_data_on_create.to_dict()
            elif isinstance(self.batch_import_meta_data_on_create, list):
                # Serialize list items (may contain intrinsic functions)
                props['BatchImportMetaDataOnCreate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.batch_import_meta_data_on_create
                ]
            else:
                props["BatchImportMetaDataOnCreate"] = self.batch_import_meta_data_on_create

        if self.s3 is not None:
            # Serialize s3 (handle intrinsic functions)
            if hasattr(self.s3, 'to_dict'):
                props["S3"] = self.s3.to_dict()
            elif isinstance(self.s3, list):
                # Serialize list items (may contain intrinsic functions)
                props['S3'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3
                ]
            else:
                props["S3"] = self.s3

        if self.file_system_id is not None:
            # Serialize file_system_id (handle intrinsic functions)
            if hasattr(self.file_system_id, 'to_dict'):
                props["FileSystemId"] = self.file_system_id.to_dict()
            elif isinstance(self.file_system_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['FileSystemId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_id
                ]
            else:
                props["FileSystemId"] = self.file_system_id

        if self.imported_file_chunk_size is not None:
            # Serialize imported_file_chunk_size (handle intrinsic functions)
            if hasattr(self.imported_file_chunk_size, 'to_dict'):
                props["ImportedFileChunkSize"] = self.imported_file_chunk_size.to_dict()
            elif isinstance(self.imported_file_chunk_size, list):
                # Serialize list items (may contain intrinsic functions)
                props['ImportedFileChunkSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.imported_file_chunk_size
                ]
            else:
                props["ImportedFileChunkSize"] = self.imported_file_chunk_size

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_resource_arn(self) -> GetAtt:
        """Get the ResourceARN attribute."""
        return self.get_att("ResourceARN")

    @property
    def attr_association_id(self) -> GetAtt:
        """Get the AssociationId attribute."""
        return self.get_att("AssociationId")




@dataclass
class AuditLogConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_access_audit_log_level: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_share_access_audit_log_level: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    audit_log_destination: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.file_access_audit_log_level is not None:
            if hasattr(self.file_access_audit_log_level, 'to_dict'):
                props['FileAccessAuditLogLevel'] = self.file_access_audit_log_level.to_dict()
            elif isinstance(self.file_access_audit_log_level, list):
                props['FileAccessAuditLogLevel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_access_audit_log_level
                ]
            else:
                props['FileAccessAuditLogLevel'] = self.file_access_audit_log_level

        if self.file_share_access_audit_log_level is not None:
            if hasattr(self.file_share_access_audit_log_level, 'to_dict'):
                props['FileShareAccessAuditLogLevel'] = self.file_share_access_audit_log_level.to_dict()
            elif isinstance(self.file_share_access_audit_log_level, list):
                props['FileShareAccessAuditLogLevel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_share_access_audit_log_level
                ]
            else:
                props['FileShareAccessAuditLogLevel'] = self.file_share_access_audit_log_level

        if self.audit_log_destination is not None:
            if hasattr(self.audit_log_destination, 'to_dict'):
                props['AuditLogDestination'] = self.audit_log_destination.to_dict()
            elif isinstance(self.audit_log_destination, list):
                props['AuditLogDestination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.audit_log_destination
                ]
            else:
                props['AuditLogDestination'] = self.audit_log_destination

        return props


@dataclass
class ClientConfigurations:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    options: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    clients: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.options is not None:
            if hasattr(self.options, 'to_dict'):
                props['Options'] = self.options.to_dict()
            elif isinstance(self.options, list):
                props['Options'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.options
                ]
            else:
                props['Options'] = self.options

        if self.clients is not None:
            if hasattr(self.clients, 'to_dict'):
                props['Clients'] = self.clients.to_dict()
            elif isinstance(self.clients, list):
                props['Clients'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.clients
                ]
            else:
                props['Clients'] = self.clients

        return props


@dataclass
class DataReadCacheConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sizing_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    size_gi_b: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.sizing_mode is not None:
            if hasattr(self.sizing_mode, 'to_dict'):
                props['SizingMode'] = self.sizing_mode.to_dict()
            elif isinstance(self.sizing_mode, list):
                props['SizingMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sizing_mode
                ]
            else:
                props['SizingMode'] = self.sizing_mode

        if self.size_gi_b is not None:
            if hasattr(self.size_gi_b, 'to_dict'):
                props['SizeGiB'] = self.size_gi_b.to_dict()
            elif isinstance(self.size_gi_b, list):
                props['SizeGiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.size_gi_b
                ]
            else:
                props['SizeGiB'] = self.size_gi_b

        return props


@dataclass
class DiskIopsConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mode is not None:
            if hasattr(self.mode, 'to_dict'):
                props['Mode'] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props['Mode'] = self.mode

        if self.iops is not None:
            if hasattr(self.iops, 'to_dict'):
                props['Iops'] = self.iops.to_dict()
            elif isinstance(self.iops, list):
                props['Iops'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iops
                ]
            else:
                props['Iops'] = self.iops

        return props


@dataclass
class LustreConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    drive_cache_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auto_import_policy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    efa_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    imported_file_chunk_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    deployment_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    throughput_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_compression_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_read_cache_configuration: Optional[DataReadCacheConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    import_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    weekly_maintenance_start_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metadata_configuration: Optional[MetadataConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    daily_automatic_backup_start_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    copy_tags_to_backups: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    export_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    per_unit_storage_throughput: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    automatic_backup_retention_days: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.drive_cache_type is not None:
            if hasattr(self.drive_cache_type, 'to_dict'):
                props['DriveCacheType'] = self.drive_cache_type.to_dict()
            elif isinstance(self.drive_cache_type, list):
                props['DriveCacheType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.drive_cache_type
                ]
            else:
                props['DriveCacheType'] = self.drive_cache_type

        if self.auto_import_policy is not None:
            if hasattr(self.auto_import_policy, 'to_dict'):
                props['AutoImportPolicy'] = self.auto_import_policy.to_dict()
            elif isinstance(self.auto_import_policy, list):
                props['AutoImportPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_import_policy
                ]
            else:
                props['AutoImportPolicy'] = self.auto_import_policy

        if self.efa_enabled is not None:
            if hasattr(self.efa_enabled, 'to_dict'):
                props['EfaEnabled'] = self.efa_enabled.to_dict()
            elif isinstance(self.efa_enabled, list):
                props['EfaEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.efa_enabled
                ]
            else:
                props['EfaEnabled'] = self.efa_enabled

        if self.imported_file_chunk_size is not None:
            if hasattr(self.imported_file_chunk_size, 'to_dict'):
                props['ImportedFileChunkSize'] = self.imported_file_chunk_size.to_dict()
            elif isinstance(self.imported_file_chunk_size, list):
                props['ImportedFileChunkSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.imported_file_chunk_size
                ]
            else:
                props['ImportedFileChunkSize'] = self.imported_file_chunk_size

        if self.deployment_type is not None:
            if hasattr(self.deployment_type, 'to_dict'):
                props['DeploymentType'] = self.deployment_type.to_dict()
            elif isinstance(self.deployment_type, list):
                props['DeploymentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.deployment_type
                ]
            else:
                props['DeploymentType'] = self.deployment_type

        if self.throughput_capacity is not None:
            if hasattr(self.throughput_capacity, 'to_dict'):
                props['ThroughputCapacity'] = self.throughput_capacity.to_dict()
            elif isinstance(self.throughput_capacity, list):
                props['ThroughputCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.throughput_capacity
                ]
            else:
                props['ThroughputCapacity'] = self.throughput_capacity

        if self.data_compression_type is not None:
            if hasattr(self.data_compression_type, 'to_dict'):
                props['DataCompressionType'] = self.data_compression_type.to_dict()
            elif isinstance(self.data_compression_type, list):
                props['DataCompressionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_compression_type
                ]
            else:
                props['DataCompressionType'] = self.data_compression_type

        if self.data_read_cache_configuration is not None:
            if hasattr(self.data_read_cache_configuration, 'to_dict'):
                props['DataReadCacheConfiguration'] = self.data_read_cache_configuration.to_dict()
            elif isinstance(self.data_read_cache_configuration, list):
                props['DataReadCacheConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_read_cache_configuration
                ]
            else:
                props['DataReadCacheConfiguration'] = self.data_read_cache_configuration

        if self.import_path is not None:
            if hasattr(self.import_path, 'to_dict'):
                props['ImportPath'] = self.import_path.to_dict()
            elif isinstance(self.import_path, list):
                props['ImportPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.import_path
                ]
            else:
                props['ImportPath'] = self.import_path

        if self.weekly_maintenance_start_time is not None:
            if hasattr(self.weekly_maintenance_start_time, 'to_dict'):
                props['WeeklyMaintenanceStartTime'] = self.weekly_maintenance_start_time.to_dict()
            elif isinstance(self.weekly_maintenance_start_time, list):
                props['WeeklyMaintenanceStartTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weekly_maintenance_start_time
                ]
            else:
                props['WeeklyMaintenanceStartTime'] = self.weekly_maintenance_start_time

        if self.metadata_configuration is not None:
            if hasattr(self.metadata_configuration, 'to_dict'):
                props['MetadataConfiguration'] = self.metadata_configuration.to_dict()
            elif isinstance(self.metadata_configuration, list):
                props['MetadataConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metadata_configuration
                ]
            else:
                props['MetadataConfiguration'] = self.metadata_configuration

        if self.daily_automatic_backup_start_time is not None:
            if hasattr(self.daily_automatic_backup_start_time, 'to_dict'):
                props['DailyAutomaticBackupStartTime'] = self.daily_automatic_backup_start_time.to_dict()
            elif isinstance(self.daily_automatic_backup_start_time, list):
                props['DailyAutomaticBackupStartTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.daily_automatic_backup_start_time
                ]
            else:
                props['DailyAutomaticBackupStartTime'] = self.daily_automatic_backup_start_time

        if self.copy_tags_to_backups is not None:
            if hasattr(self.copy_tags_to_backups, 'to_dict'):
                props['CopyTagsToBackups'] = self.copy_tags_to_backups.to_dict()
            elif isinstance(self.copy_tags_to_backups, list):
                props['CopyTagsToBackups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.copy_tags_to_backups
                ]
            else:
                props['CopyTagsToBackups'] = self.copy_tags_to_backups

        if self.export_path is not None:
            if hasattr(self.export_path, 'to_dict'):
                props['ExportPath'] = self.export_path.to_dict()
            elif isinstance(self.export_path, list):
                props['ExportPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.export_path
                ]
            else:
                props['ExportPath'] = self.export_path

        if self.per_unit_storage_throughput is not None:
            if hasattr(self.per_unit_storage_throughput, 'to_dict'):
                props['PerUnitStorageThroughput'] = self.per_unit_storage_throughput.to_dict()
            elif isinstance(self.per_unit_storage_throughput, list):
                props['PerUnitStorageThroughput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.per_unit_storage_throughput
                ]
            else:
                props['PerUnitStorageThroughput'] = self.per_unit_storage_throughput

        if self.automatic_backup_retention_days is not None:
            if hasattr(self.automatic_backup_retention_days, 'to_dict'):
                props['AutomaticBackupRetentionDays'] = self.automatic_backup_retention_days.to_dict()
            elif isinstance(self.automatic_backup_retention_days, list):
                props['AutomaticBackupRetentionDays'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.automatic_backup_retention_days
                ]
            else:
                props['AutomaticBackupRetentionDays'] = self.automatic_backup_retention_days

        return props


@dataclass
class MetadataConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mode is not None:
            if hasattr(self.mode, 'to_dict'):
                props['Mode'] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props['Mode'] = self.mode

        if self.iops is not None:
            if hasattr(self.iops, 'to_dict'):
                props['Iops'] = self.iops.to_dict()
            elif isinstance(self.iops, list):
                props['Iops'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iops
                ]
            else:
                props['Iops'] = self.iops

        return props


@dataclass
class NfsExports:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    client_configurations: Optional[list[ClientConfigurations]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.client_configurations is not None:
            if hasattr(self.client_configurations, 'to_dict'):
                props['ClientConfigurations'] = self.client_configurations.to_dict()
            elif isinstance(self.client_configurations, list):
                props['ClientConfigurations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_configurations
                ]
            else:
                props['ClientConfigurations'] = self.client_configurations

        return props


@dataclass
class OntapConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ha_pairs: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    fsx_admin_password: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    throughput_capacity_per_ha_pair: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    deployment_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    throughput_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_ip_address_range: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    route_table_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    weekly_maintenance_start_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    disk_iops_configuration: Optional[DiskIopsConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    daily_automatic_backup_start_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    automatic_backup_retention_days: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_ipv6_address_range: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    preferred_subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ha_pairs is not None:
            if hasattr(self.ha_pairs, 'to_dict'):
                props['HAPairs'] = self.ha_pairs.to_dict()
            elif isinstance(self.ha_pairs, list):
                props['HAPairs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ha_pairs
                ]
            else:
                props['HAPairs'] = self.ha_pairs

        if self.fsx_admin_password is not None:
            if hasattr(self.fsx_admin_password, 'to_dict'):
                props['FsxAdminPassword'] = self.fsx_admin_password.to_dict()
            elif isinstance(self.fsx_admin_password, list):
                props['FsxAdminPassword'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fsx_admin_password
                ]
            else:
                props['FsxAdminPassword'] = self.fsx_admin_password

        if self.throughput_capacity_per_ha_pair is not None:
            if hasattr(self.throughput_capacity_per_ha_pair, 'to_dict'):
                props['ThroughputCapacityPerHAPair'] = self.throughput_capacity_per_ha_pair.to_dict()
            elif isinstance(self.throughput_capacity_per_ha_pair, list):
                props['ThroughputCapacityPerHAPair'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.throughput_capacity_per_ha_pair
                ]
            else:
                props['ThroughputCapacityPerHAPair'] = self.throughput_capacity_per_ha_pair

        if self.deployment_type is not None:
            if hasattr(self.deployment_type, 'to_dict'):
                props['DeploymentType'] = self.deployment_type.to_dict()
            elif isinstance(self.deployment_type, list):
                props['DeploymentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.deployment_type
                ]
            else:
                props['DeploymentType'] = self.deployment_type

        if self.throughput_capacity is not None:
            if hasattr(self.throughput_capacity, 'to_dict'):
                props['ThroughputCapacity'] = self.throughput_capacity.to_dict()
            elif isinstance(self.throughput_capacity, list):
                props['ThroughputCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.throughput_capacity
                ]
            else:
                props['ThroughputCapacity'] = self.throughput_capacity

        if self.endpoint_ip_address_range is not None:
            if hasattr(self.endpoint_ip_address_range, 'to_dict'):
                props['EndpointIpAddressRange'] = self.endpoint_ip_address_range.to_dict()
            elif isinstance(self.endpoint_ip_address_range, list):
                props['EndpointIpAddressRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_ip_address_range
                ]
            else:
                props['EndpointIpAddressRange'] = self.endpoint_ip_address_range

        if self.route_table_ids is not None:
            if hasattr(self.route_table_ids, 'to_dict'):
                props['RouteTableIds'] = self.route_table_ids.to_dict()
            elif isinstance(self.route_table_ids, list):
                props['RouteTableIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_ids
                ]
            else:
                props['RouteTableIds'] = self.route_table_ids

        if self.weekly_maintenance_start_time is not None:
            if hasattr(self.weekly_maintenance_start_time, 'to_dict'):
                props['WeeklyMaintenanceStartTime'] = self.weekly_maintenance_start_time.to_dict()
            elif isinstance(self.weekly_maintenance_start_time, list):
                props['WeeklyMaintenanceStartTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weekly_maintenance_start_time
                ]
            else:
                props['WeeklyMaintenanceStartTime'] = self.weekly_maintenance_start_time

        if self.disk_iops_configuration is not None:
            if hasattr(self.disk_iops_configuration, 'to_dict'):
                props['DiskIopsConfiguration'] = self.disk_iops_configuration.to_dict()
            elif isinstance(self.disk_iops_configuration, list):
                props['DiskIopsConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disk_iops_configuration
                ]
            else:
                props['DiskIopsConfiguration'] = self.disk_iops_configuration

        if self.daily_automatic_backup_start_time is not None:
            if hasattr(self.daily_automatic_backup_start_time, 'to_dict'):
                props['DailyAutomaticBackupStartTime'] = self.daily_automatic_backup_start_time.to_dict()
            elif isinstance(self.daily_automatic_backup_start_time, list):
                props['DailyAutomaticBackupStartTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.daily_automatic_backup_start_time
                ]
            else:
                props['DailyAutomaticBackupStartTime'] = self.daily_automatic_backup_start_time

        if self.automatic_backup_retention_days is not None:
            if hasattr(self.automatic_backup_retention_days, 'to_dict'):
                props['AutomaticBackupRetentionDays'] = self.automatic_backup_retention_days.to_dict()
            elif isinstance(self.automatic_backup_retention_days, list):
                props['AutomaticBackupRetentionDays'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.automatic_backup_retention_days
                ]
            else:
                props['AutomaticBackupRetentionDays'] = self.automatic_backup_retention_days

        if self.endpoint_ipv6_address_range is not None:
            if hasattr(self.endpoint_ipv6_address_range, 'to_dict'):
                props['EndpointIpv6AddressRange'] = self.endpoint_ipv6_address_range.to_dict()
            elif isinstance(self.endpoint_ipv6_address_range, list):
                props['EndpointIpv6AddressRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_ipv6_address_range
                ]
            else:
                props['EndpointIpv6AddressRange'] = self.endpoint_ipv6_address_range

        if self.preferred_subnet_id is not None:
            if hasattr(self.preferred_subnet_id, 'to_dict'):
                props['PreferredSubnetId'] = self.preferred_subnet_id.to_dict()
            elif isinstance(self.preferred_subnet_id, list):
                props['PreferredSubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.preferred_subnet_id
                ]
            else:
                props['PreferredSubnetId'] = self.preferred_subnet_id

        return props


@dataclass
class OpenZFSConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    options: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    copy_tags_to_volumes: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    deployment_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    throughput_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    root_volume_configuration: Optional[RootVolumeConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_ip_address_range: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    read_cache_configuration: Optional[ReadCacheConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    route_table_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    weekly_maintenance_start_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    disk_iops_configuration: Optional[DiskIopsConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    daily_automatic_backup_start_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    copy_tags_to_backups: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    automatic_backup_retention_days: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_ipv6_address_range: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    preferred_subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.options is not None:
            if hasattr(self.options, 'to_dict'):
                props['Options'] = self.options.to_dict()
            elif isinstance(self.options, list):
                props['Options'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.options
                ]
            else:
                props['Options'] = self.options

        if self.copy_tags_to_volumes is not None:
            if hasattr(self.copy_tags_to_volumes, 'to_dict'):
                props['CopyTagsToVolumes'] = self.copy_tags_to_volumes.to_dict()
            elif isinstance(self.copy_tags_to_volumes, list):
                props['CopyTagsToVolumes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.copy_tags_to_volumes
                ]
            else:
                props['CopyTagsToVolumes'] = self.copy_tags_to_volumes

        if self.deployment_type is not None:
            if hasattr(self.deployment_type, 'to_dict'):
                props['DeploymentType'] = self.deployment_type.to_dict()
            elif isinstance(self.deployment_type, list):
                props['DeploymentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.deployment_type
                ]
            else:
                props['DeploymentType'] = self.deployment_type

        if self.throughput_capacity is not None:
            if hasattr(self.throughput_capacity, 'to_dict'):
                props['ThroughputCapacity'] = self.throughput_capacity.to_dict()
            elif isinstance(self.throughput_capacity, list):
                props['ThroughputCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.throughput_capacity
                ]
            else:
                props['ThroughputCapacity'] = self.throughput_capacity

        if self.root_volume_configuration is not None:
            if hasattr(self.root_volume_configuration, 'to_dict'):
                props['RootVolumeConfiguration'] = self.root_volume_configuration.to_dict()
            elif isinstance(self.root_volume_configuration, list):
                props['RootVolumeConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.root_volume_configuration
                ]
            else:
                props['RootVolumeConfiguration'] = self.root_volume_configuration

        if self.endpoint_ip_address_range is not None:
            if hasattr(self.endpoint_ip_address_range, 'to_dict'):
                props['EndpointIpAddressRange'] = self.endpoint_ip_address_range.to_dict()
            elif isinstance(self.endpoint_ip_address_range, list):
                props['EndpointIpAddressRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_ip_address_range
                ]
            else:
                props['EndpointIpAddressRange'] = self.endpoint_ip_address_range

        if self.read_cache_configuration is not None:
            if hasattr(self.read_cache_configuration, 'to_dict'):
                props['ReadCacheConfiguration'] = self.read_cache_configuration.to_dict()
            elif isinstance(self.read_cache_configuration, list):
                props['ReadCacheConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.read_cache_configuration
                ]
            else:
                props['ReadCacheConfiguration'] = self.read_cache_configuration

        if self.route_table_ids is not None:
            if hasattr(self.route_table_ids, 'to_dict'):
                props['RouteTableIds'] = self.route_table_ids.to_dict()
            elif isinstance(self.route_table_ids, list):
                props['RouteTableIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_ids
                ]
            else:
                props['RouteTableIds'] = self.route_table_ids

        if self.weekly_maintenance_start_time is not None:
            if hasattr(self.weekly_maintenance_start_time, 'to_dict'):
                props['WeeklyMaintenanceStartTime'] = self.weekly_maintenance_start_time.to_dict()
            elif isinstance(self.weekly_maintenance_start_time, list):
                props['WeeklyMaintenanceStartTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weekly_maintenance_start_time
                ]
            else:
                props['WeeklyMaintenanceStartTime'] = self.weekly_maintenance_start_time

        if self.disk_iops_configuration is not None:
            if hasattr(self.disk_iops_configuration, 'to_dict'):
                props['DiskIopsConfiguration'] = self.disk_iops_configuration.to_dict()
            elif isinstance(self.disk_iops_configuration, list):
                props['DiskIopsConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disk_iops_configuration
                ]
            else:
                props['DiskIopsConfiguration'] = self.disk_iops_configuration

        if self.daily_automatic_backup_start_time is not None:
            if hasattr(self.daily_automatic_backup_start_time, 'to_dict'):
                props['DailyAutomaticBackupStartTime'] = self.daily_automatic_backup_start_time.to_dict()
            elif isinstance(self.daily_automatic_backup_start_time, list):
                props['DailyAutomaticBackupStartTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.daily_automatic_backup_start_time
                ]
            else:
                props['DailyAutomaticBackupStartTime'] = self.daily_automatic_backup_start_time

        if self.copy_tags_to_backups is not None:
            if hasattr(self.copy_tags_to_backups, 'to_dict'):
                props['CopyTagsToBackups'] = self.copy_tags_to_backups.to_dict()
            elif isinstance(self.copy_tags_to_backups, list):
                props['CopyTagsToBackups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.copy_tags_to_backups
                ]
            else:
                props['CopyTagsToBackups'] = self.copy_tags_to_backups

        if self.automatic_backup_retention_days is not None:
            if hasattr(self.automatic_backup_retention_days, 'to_dict'):
                props['AutomaticBackupRetentionDays'] = self.automatic_backup_retention_days.to_dict()
            elif isinstance(self.automatic_backup_retention_days, list):
                props['AutomaticBackupRetentionDays'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.automatic_backup_retention_days
                ]
            else:
                props['AutomaticBackupRetentionDays'] = self.automatic_backup_retention_days

        if self.endpoint_ipv6_address_range is not None:
            if hasattr(self.endpoint_ipv6_address_range, 'to_dict'):
                props['EndpointIpv6AddressRange'] = self.endpoint_ipv6_address_range.to_dict()
            elif isinstance(self.endpoint_ipv6_address_range, list):
                props['EndpointIpv6AddressRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_ipv6_address_range
                ]
            else:
                props['EndpointIpv6AddressRange'] = self.endpoint_ipv6_address_range

        if self.preferred_subnet_id is not None:
            if hasattr(self.preferred_subnet_id, 'to_dict'):
                props['PreferredSubnetId'] = self.preferred_subnet_id.to_dict()
            elif isinstance(self.preferred_subnet_id, list):
                props['PreferredSubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.preferred_subnet_id
                ]
            else:
                props['PreferredSubnetId'] = self.preferred_subnet_id

        return props


@dataclass
class ReadCacheConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sizing_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    size_gi_b: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.sizing_mode is not None:
            if hasattr(self.sizing_mode, 'to_dict'):
                props['SizingMode'] = self.sizing_mode.to_dict()
            elif isinstance(self.sizing_mode, list):
                props['SizingMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sizing_mode
                ]
            else:
                props['SizingMode'] = self.sizing_mode

        if self.size_gi_b is not None:
            if hasattr(self.size_gi_b, 'to_dict'):
                props['SizeGiB'] = self.size_gi_b.to_dict()
            elif isinstance(self.size_gi_b, list):
                props['SizeGiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.size_gi_b
                ]
            else:
                props['SizeGiB'] = self.size_gi_b

        return props


@dataclass
class RootVolumeConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    read_only: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_compression_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    nfs_exports: Optional[list[NfsExports]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    copy_tags_to_snapshots: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    record_size_ki_b: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_and_group_quotas: Optional[list[UserAndGroupQuotas]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.read_only is not None:
            if hasattr(self.read_only, 'to_dict'):
                props['ReadOnly'] = self.read_only.to_dict()
            elif isinstance(self.read_only, list):
                props['ReadOnly'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.read_only
                ]
            else:
                props['ReadOnly'] = self.read_only

        if self.data_compression_type is not None:
            if hasattr(self.data_compression_type, 'to_dict'):
                props['DataCompressionType'] = self.data_compression_type.to_dict()
            elif isinstance(self.data_compression_type, list):
                props['DataCompressionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_compression_type
                ]
            else:
                props['DataCompressionType'] = self.data_compression_type

        if self.nfs_exports is not None:
            if hasattr(self.nfs_exports, 'to_dict'):
                props['NfsExports'] = self.nfs_exports.to_dict()
            elif isinstance(self.nfs_exports, list):
                props['NfsExports'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.nfs_exports
                ]
            else:
                props['NfsExports'] = self.nfs_exports

        if self.copy_tags_to_snapshots is not None:
            if hasattr(self.copy_tags_to_snapshots, 'to_dict'):
                props['CopyTagsToSnapshots'] = self.copy_tags_to_snapshots.to_dict()
            elif isinstance(self.copy_tags_to_snapshots, list):
                props['CopyTagsToSnapshots'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.copy_tags_to_snapshots
                ]
            else:
                props['CopyTagsToSnapshots'] = self.copy_tags_to_snapshots

        if self.record_size_ki_b is not None:
            if hasattr(self.record_size_ki_b, 'to_dict'):
                props['RecordSizeKiB'] = self.record_size_ki_b.to_dict()
            elif isinstance(self.record_size_ki_b, list):
                props['RecordSizeKiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.record_size_ki_b
                ]
            else:
                props['RecordSizeKiB'] = self.record_size_ki_b

        if self.user_and_group_quotas is not None:
            if hasattr(self.user_and_group_quotas, 'to_dict'):
                props['UserAndGroupQuotas'] = self.user_and_group_quotas.to_dict()
            elif isinstance(self.user_and_group_quotas, list):
                props['UserAndGroupQuotas'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_and_group_quotas
                ]
            else:
                props['UserAndGroupQuotas'] = self.user_and_group_quotas

        return props


@dataclass
class SelfManagedActiveDirectoryConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_system_administrators_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    domain_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    organizational_unit_distinguished_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    domain_join_service_account_secret: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dns_ips: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    password: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.file_system_administrators_group is not None:
            if hasattr(self.file_system_administrators_group, 'to_dict'):
                props['FileSystemAdministratorsGroup'] = self.file_system_administrators_group.to_dict()
            elif isinstance(self.file_system_administrators_group, list):
                props['FileSystemAdministratorsGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_administrators_group
                ]
            else:
                props['FileSystemAdministratorsGroup'] = self.file_system_administrators_group

        if self.user_name is not None:
            if hasattr(self.user_name, 'to_dict'):
                props['UserName'] = self.user_name.to_dict()
            elif isinstance(self.user_name, list):
                props['UserName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_name
                ]
            else:
                props['UserName'] = self.user_name

        if self.domain_name is not None:
            if hasattr(self.domain_name, 'to_dict'):
                props['DomainName'] = self.domain_name.to_dict()
            elif isinstance(self.domain_name, list):
                props['DomainName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_name
                ]
            else:
                props['DomainName'] = self.domain_name

        if self.organizational_unit_distinguished_name is not None:
            if hasattr(self.organizational_unit_distinguished_name, 'to_dict'):
                props['OrganizationalUnitDistinguishedName'] = self.organizational_unit_distinguished_name.to_dict()
            elif isinstance(self.organizational_unit_distinguished_name, list):
                props['OrganizationalUnitDistinguishedName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organizational_unit_distinguished_name
                ]
            else:
                props['OrganizationalUnitDistinguishedName'] = self.organizational_unit_distinguished_name

        if self.domain_join_service_account_secret is not None:
            if hasattr(self.domain_join_service_account_secret, 'to_dict'):
                props['DomainJoinServiceAccountSecret'] = self.domain_join_service_account_secret.to_dict()
            elif isinstance(self.domain_join_service_account_secret, list):
                props['DomainJoinServiceAccountSecret'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_join_service_account_secret
                ]
            else:
                props['DomainJoinServiceAccountSecret'] = self.domain_join_service_account_secret

        if self.dns_ips is not None:
            if hasattr(self.dns_ips, 'to_dict'):
                props['DnsIps'] = self.dns_ips.to_dict()
            elif isinstance(self.dns_ips, list):
                props['DnsIps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dns_ips
                ]
            else:
                props['DnsIps'] = self.dns_ips

        if self.password is not None:
            if hasattr(self.password, 'to_dict'):
                props['Password'] = self.password.to_dict()
            elif isinstance(self.password, list):
                props['Password'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.password
                ]
            else:
                props['Password'] = self.password

        return props


@dataclass
class UserAndGroupQuotas:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    id: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    storage_capacity_quota_gi_b: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.id is not None:
            if hasattr(self.id, 'to_dict'):
                props['Id'] = self.id.to_dict()
            elif isinstance(self.id, list):
                props['Id'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.id
                ]
            else:
                props['Id'] = self.id

        if self.storage_capacity_quota_gi_b is not None:
            if hasattr(self.storage_capacity_quota_gi_b, 'to_dict'):
                props['StorageCapacityQuotaGiB'] = self.storage_capacity_quota_gi_b.to_dict()
            elif isinstance(self.storage_capacity_quota_gi_b, list):
                props['StorageCapacityQuotaGiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_capacity_quota_gi_b
                ]
            else:
                props['StorageCapacityQuotaGiB'] = self.storage_capacity_quota_gi_b

        return props


@dataclass
class WindowsConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    self_managed_active_directory_configuration: Optional[SelfManagedActiveDirectoryConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    audit_log_configuration: Optional[AuditLogConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    weekly_maintenance_start_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    active_directory_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    disk_iops_configuration: Optional[DiskIopsConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    deployment_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    aliases: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    throughput_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    copy_tags_to_backups: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    daily_automatic_backup_start_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    automatic_backup_retention_days: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    preferred_subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.self_managed_active_directory_configuration is not None:
            if hasattr(self.self_managed_active_directory_configuration, 'to_dict'):
                props['SelfManagedActiveDirectoryConfiguration'] = self.self_managed_active_directory_configuration.to_dict()
            elif isinstance(self.self_managed_active_directory_configuration, list):
                props['SelfManagedActiveDirectoryConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.self_managed_active_directory_configuration
                ]
            else:
                props['SelfManagedActiveDirectoryConfiguration'] = self.self_managed_active_directory_configuration

        if self.audit_log_configuration is not None:
            if hasattr(self.audit_log_configuration, 'to_dict'):
                props['AuditLogConfiguration'] = self.audit_log_configuration.to_dict()
            elif isinstance(self.audit_log_configuration, list):
                props['AuditLogConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.audit_log_configuration
                ]
            else:
                props['AuditLogConfiguration'] = self.audit_log_configuration

        if self.weekly_maintenance_start_time is not None:
            if hasattr(self.weekly_maintenance_start_time, 'to_dict'):
                props['WeeklyMaintenanceStartTime'] = self.weekly_maintenance_start_time.to_dict()
            elif isinstance(self.weekly_maintenance_start_time, list):
                props['WeeklyMaintenanceStartTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weekly_maintenance_start_time
                ]
            else:
                props['WeeklyMaintenanceStartTime'] = self.weekly_maintenance_start_time

        if self.active_directory_id is not None:
            if hasattr(self.active_directory_id, 'to_dict'):
                props['ActiveDirectoryId'] = self.active_directory_id.to_dict()
            elif isinstance(self.active_directory_id, list):
                props['ActiveDirectoryId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.active_directory_id
                ]
            else:
                props['ActiveDirectoryId'] = self.active_directory_id

        if self.disk_iops_configuration is not None:
            if hasattr(self.disk_iops_configuration, 'to_dict'):
                props['DiskIopsConfiguration'] = self.disk_iops_configuration.to_dict()
            elif isinstance(self.disk_iops_configuration, list):
                props['DiskIopsConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disk_iops_configuration
                ]
            else:
                props['DiskIopsConfiguration'] = self.disk_iops_configuration

        if self.deployment_type is not None:
            if hasattr(self.deployment_type, 'to_dict'):
                props['DeploymentType'] = self.deployment_type.to_dict()
            elif isinstance(self.deployment_type, list):
                props['DeploymentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.deployment_type
                ]
            else:
                props['DeploymentType'] = self.deployment_type

        if self.aliases is not None:
            if hasattr(self.aliases, 'to_dict'):
                props['Aliases'] = self.aliases.to_dict()
            elif isinstance(self.aliases, list):
                props['Aliases'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.aliases
                ]
            else:
                props['Aliases'] = self.aliases

        if self.throughput_capacity is not None:
            if hasattr(self.throughput_capacity, 'to_dict'):
                props['ThroughputCapacity'] = self.throughput_capacity.to_dict()
            elif isinstance(self.throughput_capacity, list):
                props['ThroughputCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.throughput_capacity
                ]
            else:
                props['ThroughputCapacity'] = self.throughput_capacity

        if self.copy_tags_to_backups is not None:
            if hasattr(self.copy_tags_to_backups, 'to_dict'):
                props['CopyTagsToBackups'] = self.copy_tags_to_backups.to_dict()
            elif isinstance(self.copy_tags_to_backups, list):
                props['CopyTagsToBackups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.copy_tags_to_backups
                ]
            else:
                props['CopyTagsToBackups'] = self.copy_tags_to_backups

        if self.daily_automatic_backup_start_time is not None:
            if hasattr(self.daily_automatic_backup_start_time, 'to_dict'):
                props['DailyAutomaticBackupStartTime'] = self.daily_automatic_backup_start_time.to_dict()
            elif isinstance(self.daily_automatic_backup_start_time, list):
                props['DailyAutomaticBackupStartTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.daily_automatic_backup_start_time
                ]
            else:
                props['DailyAutomaticBackupStartTime'] = self.daily_automatic_backup_start_time

        if self.automatic_backup_retention_days is not None:
            if hasattr(self.automatic_backup_retention_days, 'to_dict'):
                props['AutomaticBackupRetentionDays'] = self.automatic_backup_retention_days.to_dict()
            elif isinstance(self.automatic_backup_retention_days, list):
                props['AutomaticBackupRetentionDays'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.automatic_backup_retention_days
                ]
            else:
                props['AutomaticBackupRetentionDays'] = self.automatic_backup_retention_days

        if self.preferred_subnet_id is not None:
            if hasattr(self.preferred_subnet_id, 'to_dict'):
                props['PreferredSubnetId'] = self.preferred_subnet_id.to_dict()
            elif isinstance(self.preferred_subnet_id, list):
                props['PreferredSubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.preferred_subnet_id
                ]
            else:
                props['PreferredSubnetId'] = self.preferred_subnet_id

        return props


@dataclass
class FileSystem(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-fsx-f"""

    resource_type: ClassVar[str] = "AWS::FSx::FileSystem"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    storage_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    storage_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    lustre_configuration: Optional[LustreConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    backup_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ontap_configuration: Optional[OntapConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    windows_configuration: Optional[WindowsConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    file_system_type_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    open_zfs_configuration: Optional[OpenZFSConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    file_system_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.storage_type is not None:
            # Serialize storage_type (handle intrinsic functions)
            if hasattr(self.storage_type, 'to_dict'):
                props["StorageType"] = self.storage_type.to_dict()
            elif isinstance(self.storage_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['StorageType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_type
                ]
            else:
                props["StorageType"] = self.storage_type

        if self.kms_key_id is not None:
            # Serialize kms_key_id (handle intrinsic functions)
            if hasattr(self.kms_key_id, 'to_dict'):
                props["KmsKeyId"] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props["KmsKeyId"] = self.kms_key_id

        if self.storage_capacity is not None:
            # Serialize storage_capacity (handle intrinsic functions)
            if hasattr(self.storage_capacity, 'to_dict'):
                props["StorageCapacity"] = self.storage_capacity.to_dict()
            elif isinstance(self.storage_capacity, list):
                # Serialize list items (may contain intrinsic functions)
                props['StorageCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_capacity
                ]
            else:
                props["StorageCapacity"] = self.storage_capacity

        if self.lustre_configuration is not None:
            # Serialize lustre_configuration (handle intrinsic functions)
            if hasattr(self.lustre_configuration, 'to_dict'):
                props["LustreConfiguration"] = self.lustre_configuration.to_dict()
            elif isinstance(self.lustre_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['LustreConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lustre_configuration
                ]
            else:
                props["LustreConfiguration"] = self.lustre_configuration

        if self.backup_id is not None:
            # Serialize backup_id (handle intrinsic functions)
            if hasattr(self.backup_id, 'to_dict'):
                props["BackupId"] = self.backup_id.to_dict()
            elif isinstance(self.backup_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['BackupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.backup_id
                ]
            else:
                props["BackupId"] = self.backup_id

        if self.ontap_configuration is not None:
            # Serialize ontap_configuration (handle intrinsic functions)
            if hasattr(self.ontap_configuration, 'to_dict'):
                props["OntapConfiguration"] = self.ontap_configuration.to_dict()
            elif isinstance(self.ontap_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['OntapConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ontap_configuration
                ]
            else:
                props["OntapConfiguration"] = self.ontap_configuration

        if self.subnet_ids is not None:
            # Serialize subnet_ids (handle intrinsic functions)
            if hasattr(self.subnet_ids, 'to_dict'):
                props["SubnetIds"] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props["SubnetIds"] = self.subnet_ids

        if self.security_group_ids is not None:
            # Serialize security_group_ids (handle intrinsic functions)
            if hasattr(self.security_group_ids, 'to_dict'):
                props["SecurityGroupIds"] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props["SecurityGroupIds"] = self.security_group_ids

        if self.windows_configuration is not None:
            # Serialize windows_configuration (handle intrinsic functions)
            if hasattr(self.windows_configuration, 'to_dict'):
                props["WindowsConfiguration"] = self.windows_configuration.to_dict()
            elif isinstance(self.windows_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['WindowsConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.windows_configuration
                ]
            else:
                props["WindowsConfiguration"] = self.windows_configuration

        if self.file_system_type_version is not None:
            # Serialize file_system_type_version (handle intrinsic functions)
            if hasattr(self.file_system_type_version, 'to_dict'):
                props["FileSystemTypeVersion"] = self.file_system_type_version.to_dict()
            elif isinstance(self.file_system_type_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['FileSystemTypeVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_type_version
                ]
            else:
                props["FileSystemTypeVersion"] = self.file_system_type_version

        if self.open_zfs_configuration is not None:
            # Serialize open_zfs_configuration (handle intrinsic functions)
            if hasattr(self.open_zfs_configuration, 'to_dict'):
                props["OpenZFSConfiguration"] = self.open_zfs_configuration.to_dict()
            elif isinstance(self.open_zfs_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['OpenZFSConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.open_zfs_configuration
                ]
            else:
                props["OpenZFSConfiguration"] = self.open_zfs_configuration

        if self.network_type is not None:
            # Serialize network_type (handle intrinsic functions)
            if hasattr(self.network_type, 'to_dict'):
                props["NetworkType"] = self.network_type.to_dict()
            elif isinstance(self.network_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_type
                ]
            else:
                props["NetworkType"] = self.network_type

        if self.file_system_type is not None:
            # Serialize file_system_type (handle intrinsic functions)
            if hasattr(self.file_system_type, 'to_dict'):
                props["FileSystemType"] = self.file_system_type.to_dict()
            elif isinstance(self.file_system_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['FileSystemType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_type
                ]
            else:
                props["FileSystemType"] = self.file_system_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_resource_arn(self) -> GetAtt:
        """Get the ResourceARN attribute."""
        return self.get_att("ResourceARN")

    @property
    def attr_root_volume_id(self) -> GetAtt:
        """Get the RootVolumeId attribute."""
        return self.get_att("RootVolumeId")

    @property
    def attr_dns_name(self) -> GetAtt:
        """Get the DNSName attribute."""
        return self.get_att("DNSName")

    @property
    def attr_lustre_mount_name(self) -> GetAtt:
        """Get the LustreMountName attribute."""
        return self.get_att("LustreMountName")




@dataclass
class FileSystemGID:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    gid: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.gid is not None:
            if hasattr(self.gid, 'to_dict'):
                props['Gid'] = self.gid.to_dict()
            elif isinstance(self.gid, list):
                props['Gid'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gid
                ]
            else:
                props['Gid'] = self.gid

        return props


@dataclass
class OntapFileSystemIdentity:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unix_user: Optional[OntapUnixFileSystemUser] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    windows_user: Optional[OntapWindowsFileSystemUser] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.unix_user is not None:
            if hasattr(self.unix_user, 'to_dict'):
                props['UnixUser'] = self.unix_user.to_dict()
            elif isinstance(self.unix_user, list):
                props['UnixUser'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unix_user
                ]
            else:
                props['UnixUser'] = self.unix_user

        if self.windows_user is not None:
            if hasattr(self.windows_user, 'to_dict'):
                props['WindowsUser'] = self.windows_user.to_dict()
            elif isinstance(self.windows_user, list):
                props['WindowsUser'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.windows_user
                ]
            else:
                props['WindowsUser'] = self.windows_user

        return props


@dataclass
class OntapUnixFileSystemUser:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class OntapWindowsFileSystemUser:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class OpenZFSFileSystemIdentity:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    posix_user: Optional[OpenZFSPosixFileSystemUser] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.posix_user is not None:
            if hasattr(self.posix_user, 'to_dict'):
                props['PosixUser'] = self.posix_user.to_dict()
            elif isinstance(self.posix_user, list):
                props['PosixUser'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.posix_user
                ]
            else:
                props['PosixUser'] = self.posix_user

        return props


@dataclass
class OpenZFSPosixFileSystemUser:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    uid: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    secondary_gids: Optional[list[FileSystemGID]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    gid: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.uid is not None:
            if hasattr(self.uid, 'to_dict'):
                props['Uid'] = self.uid.to_dict()
            elif isinstance(self.uid, list):
                props['Uid'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.uid
                ]
            else:
                props['Uid'] = self.uid

        if self.secondary_gids is not None:
            if hasattr(self.secondary_gids, 'to_dict'):
                props['SecondaryGids'] = self.secondary_gids.to_dict()
            elif isinstance(self.secondary_gids, list):
                props['SecondaryGids'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_gids
                ]
            else:
                props['SecondaryGids'] = self.secondary_gids

        if self.gid is not None:
            if hasattr(self.gid, 'to_dict'):
                props['Gid'] = self.gid.to_dict()
            elif isinstance(self.gid, list):
                props['Gid'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gid
                ]
            else:
                props['Gid'] = self.gid

        return props


@dataclass
class S3AccessPoint:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    policy: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    alias: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_configuration: Optional[S3AccessPointVpcConfiguration] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.policy is not None:
            if hasattr(self.policy, 'to_dict'):
                props['Policy'] = self.policy.to_dict()
            elif isinstance(self.policy, list):
                props['Policy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy
                ]
            else:
                props['Policy'] = self.policy

        if self.resource_arn is not None:
            if hasattr(self.resource_arn, 'to_dict'):
                props['ResourceARN'] = self.resource_arn.to_dict()
            elif isinstance(self.resource_arn, list):
                props['ResourceARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_arn
                ]
            else:
                props['ResourceARN'] = self.resource_arn

        if self.alias is not None:
            if hasattr(self.alias, 'to_dict'):
                props['Alias'] = self.alias.to_dict()
            elif isinstance(self.alias, list):
                props['Alias'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.alias
                ]
            else:
                props['Alias'] = self.alias

        if self.vpc_configuration is not None:
            if hasattr(self.vpc_configuration, 'to_dict'):
                props['VpcConfiguration'] = self.vpc_configuration.to_dict()
            elif isinstance(self.vpc_configuration, list):
                props['VpcConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_configuration
                ]
            else:
                props['VpcConfiguration'] = self.vpc_configuration

        return props


@dataclass
class S3AccessPointOntapConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_system_identity: Optional[OntapFileSystemIdentity] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.volume_id is not None:
            if hasattr(self.volume_id, 'to_dict'):
                props['VolumeId'] = self.volume_id.to_dict()
            elif isinstance(self.volume_id, list):
                props['VolumeId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_id
                ]
            else:
                props['VolumeId'] = self.volume_id

        if self.file_system_identity is not None:
            if hasattr(self.file_system_identity, 'to_dict'):
                props['FileSystemIdentity'] = self.file_system_identity.to_dict()
            elif isinstance(self.file_system_identity, list):
                props['FileSystemIdentity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_identity
                ]
            else:
                props['FileSystemIdentity'] = self.file_system_identity

        return props


@dataclass
class S3AccessPointOpenZFSConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_system_identity: Optional[OpenZFSFileSystemIdentity] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.volume_id is not None:
            if hasattr(self.volume_id, 'to_dict'):
                props['VolumeId'] = self.volume_id.to_dict()
            elif isinstance(self.volume_id, list):
                props['VolumeId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_id
                ]
            else:
                props['VolumeId'] = self.volume_id

        if self.file_system_identity is not None:
            if hasattr(self.file_system_identity, 'to_dict'):
                props['FileSystemIdentity'] = self.file_system_identity.to_dict()
            elif isinstance(self.file_system_identity, list):
                props['FileSystemIdentity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_identity
                ]
            else:
                props['FileSystemIdentity'] = self.file_system_identity

        return props


@dataclass
class S3AccessPointVpcConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            if hasattr(self.vpc_id, 'to_dict'):
                props['VpcId'] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props['VpcId'] = self.vpc_id

        return props


@dataclass
class S3AccessPointAttachment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-fsx-s"""

    resource_type: ClassVar[str] = "AWS::FSx::S3AccessPointAttachment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    open_zfs_configuration: Optional[S3AccessPointOpenZFSConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    s3_access_point: Optional[S3AccessPoint] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ontap_configuration: Optional[S3AccessPointOntapConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.open_zfs_configuration is not None:
            # Serialize open_zfs_configuration (handle intrinsic functions)
            if hasattr(self.open_zfs_configuration, 'to_dict'):
                props["OpenZFSConfiguration"] = self.open_zfs_configuration.to_dict()
            elif isinstance(self.open_zfs_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['OpenZFSConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.open_zfs_configuration
                ]
            else:
                props["OpenZFSConfiguration"] = self.open_zfs_configuration

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.s3_access_point is not None:
            # Serialize s3_access_point (handle intrinsic functions)
            if hasattr(self.s3_access_point, 'to_dict'):
                props["S3AccessPoint"] = self.s3_access_point.to_dict()
            elif isinstance(self.s3_access_point, list):
                # Serialize list items (may contain intrinsic functions)
                props['S3AccessPoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_access_point
                ]
            else:
                props["S3AccessPoint"] = self.s3_access_point

        if self.ontap_configuration is not None:
            # Serialize ontap_configuration (handle intrinsic functions)
            if hasattr(self.ontap_configuration, 'to_dict'):
                props["OntapConfiguration"] = self.ontap_configuration.to_dict()
            elif isinstance(self.ontap_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['OntapConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ontap_configuration
                ]
            else:
                props["OntapConfiguration"] = self.ontap_configuration

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_s3_access_point__alias(self) -> GetAtt:
        """Get the S3AccessPoint.Alias attribute."""
        return self.get_att("S3AccessPoint.Alias")

    @property
    def attr_s3_access_point__resource_arn(self) -> GetAtt:
        """Get the S3AccessPoint.ResourceARN attribute."""
        return self.get_att("S3AccessPoint.ResourceARN")




@dataclass
class Snapshot(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-fsx-s"""

    resource_type: ClassVar[str] = "AWS::FSx::Snapshot"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    volume_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.volume_id is not None:
            # Serialize volume_id (handle intrinsic functions)
            if hasattr(self.volume_id, 'to_dict'):
                props["VolumeId"] = self.volume_id.to_dict()
            elif isinstance(self.volume_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VolumeId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_id
                ]
            else:
                props["VolumeId"] = self.volume_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_resource_arn(self) -> GetAtt:
        """Get the ResourceARN attribute."""
        return self.get_att("ResourceARN")




@dataclass
class ActiveDirectoryConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    self_managed_active_directory_configuration: Optional[SelfManagedActiveDirectoryConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    net_bios_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.self_managed_active_directory_configuration is not None:
            if hasattr(self.self_managed_active_directory_configuration, 'to_dict'):
                props['SelfManagedActiveDirectoryConfiguration'] = self.self_managed_active_directory_configuration.to_dict()
            elif isinstance(self.self_managed_active_directory_configuration, list):
                props['SelfManagedActiveDirectoryConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.self_managed_active_directory_configuration
                ]
            else:
                props['SelfManagedActiveDirectoryConfiguration'] = self.self_managed_active_directory_configuration

        if self.net_bios_name is not None:
            if hasattr(self.net_bios_name, 'to_dict'):
                props['NetBiosName'] = self.net_bios_name.to_dict()
            elif isinstance(self.net_bios_name, list):
                props['NetBiosName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.net_bios_name
                ]
            else:
                props['NetBiosName'] = self.net_bios_name

        return props


@dataclass
class SelfManagedActiveDirectoryConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_system_administrators_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    domain_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    organizational_unit_distinguished_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    domain_join_service_account_secret: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dns_ips: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    password: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.file_system_administrators_group is not None:
            if hasattr(self.file_system_administrators_group, 'to_dict'):
                props['FileSystemAdministratorsGroup'] = self.file_system_administrators_group.to_dict()
            elif isinstance(self.file_system_administrators_group, list):
                props['FileSystemAdministratorsGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_administrators_group
                ]
            else:
                props['FileSystemAdministratorsGroup'] = self.file_system_administrators_group

        if self.user_name is not None:
            if hasattr(self.user_name, 'to_dict'):
                props['UserName'] = self.user_name.to_dict()
            elif isinstance(self.user_name, list):
                props['UserName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_name
                ]
            else:
                props['UserName'] = self.user_name

        if self.domain_name is not None:
            if hasattr(self.domain_name, 'to_dict'):
                props['DomainName'] = self.domain_name.to_dict()
            elif isinstance(self.domain_name, list):
                props['DomainName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_name
                ]
            else:
                props['DomainName'] = self.domain_name

        if self.organizational_unit_distinguished_name is not None:
            if hasattr(self.organizational_unit_distinguished_name, 'to_dict'):
                props['OrganizationalUnitDistinguishedName'] = self.organizational_unit_distinguished_name.to_dict()
            elif isinstance(self.organizational_unit_distinguished_name, list):
                props['OrganizationalUnitDistinguishedName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organizational_unit_distinguished_name
                ]
            else:
                props['OrganizationalUnitDistinguishedName'] = self.organizational_unit_distinguished_name

        if self.domain_join_service_account_secret is not None:
            if hasattr(self.domain_join_service_account_secret, 'to_dict'):
                props['DomainJoinServiceAccountSecret'] = self.domain_join_service_account_secret.to_dict()
            elif isinstance(self.domain_join_service_account_secret, list):
                props['DomainJoinServiceAccountSecret'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_join_service_account_secret
                ]
            else:
                props['DomainJoinServiceAccountSecret'] = self.domain_join_service_account_secret

        if self.dns_ips is not None:
            if hasattr(self.dns_ips, 'to_dict'):
                props['DnsIps'] = self.dns_ips.to_dict()
            elif isinstance(self.dns_ips, list):
                props['DnsIps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dns_ips
                ]
            else:
                props['DnsIps'] = self.dns_ips

        if self.password is not None:
            if hasattr(self.password, 'to_dict'):
                props['Password'] = self.password.to_dict()
            elif isinstance(self.password, list):
                props['Password'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.password
                ]
            else:
                props['Password'] = self.password

        return props


@dataclass
class StorageVirtualMachine(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-fsx-s"""

    resource_type: ClassVar[str] = "AWS::FSx::StorageVirtualMachine"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    svm_admin_password: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    active_directory_configuration: Optional[ActiveDirectoryConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    root_volume_security_style: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    file_system_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.svm_admin_password is not None:
            # Serialize svm_admin_password (handle intrinsic functions)
            if hasattr(self.svm_admin_password, 'to_dict'):
                props["SvmAdminPassword"] = self.svm_admin_password.to_dict()
            elif isinstance(self.svm_admin_password, list):
                # Serialize list items (may contain intrinsic functions)
                props['SvmAdminPassword'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.svm_admin_password
                ]
            else:
                props["SvmAdminPassword"] = self.svm_admin_password

        if self.active_directory_configuration is not None:
            # Serialize active_directory_configuration (handle intrinsic functions)
            if hasattr(self.active_directory_configuration, 'to_dict'):
                props["ActiveDirectoryConfiguration"] = self.active_directory_configuration.to_dict()
            elif isinstance(self.active_directory_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['ActiveDirectoryConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.active_directory_configuration
                ]
            else:
                props["ActiveDirectoryConfiguration"] = self.active_directory_configuration

        if self.root_volume_security_style is not None:
            # Serialize root_volume_security_style (handle intrinsic functions)
            if hasattr(self.root_volume_security_style, 'to_dict'):
                props["RootVolumeSecurityStyle"] = self.root_volume_security_style.to_dict()
            elif isinstance(self.root_volume_security_style, list):
                # Serialize list items (may contain intrinsic functions)
                props['RootVolumeSecurityStyle'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.root_volume_security_style
                ]
            else:
                props["RootVolumeSecurityStyle"] = self.root_volume_security_style

        if self.file_system_id is not None:
            # Serialize file_system_id (handle intrinsic functions)
            if hasattr(self.file_system_id, 'to_dict'):
                props["FileSystemId"] = self.file_system_id.to_dict()
            elif isinstance(self.file_system_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['FileSystemId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_id
                ]
            else:
                props["FileSystemId"] = self.file_system_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_resource_arn(self) -> GetAtt:
        """Get the ResourceARN attribute."""
        return self.get_att("ResourceARN")

    @property
    def attr_storage_virtual_machine_id(self) -> GetAtt:
        """Get the StorageVirtualMachineId attribute."""
        return self.get_att("StorageVirtualMachineId")

    @property
    def attr_uuid(self) -> GetAtt:
        """Get the UUID attribute."""
        return self.get_att("UUID")




@dataclass
class AggregateConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    aggregates: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    constituents_per_aggregate: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.aggregates is not None:
            if hasattr(self.aggregates, 'to_dict'):
                props['Aggregates'] = self.aggregates.to_dict()
            elif isinstance(self.aggregates, list):
                props['Aggregates'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.aggregates
                ]
            else:
                props['Aggregates'] = self.aggregates

        if self.constituents_per_aggregate is not None:
            if hasattr(self.constituents_per_aggregate, 'to_dict'):
                props['ConstituentsPerAggregate'] = self.constituents_per_aggregate.to_dict()
            elif isinstance(self.constituents_per_aggregate, list):
                props['ConstituentsPerAggregate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.constituents_per_aggregate
                ]
            else:
                props['ConstituentsPerAggregate'] = self.constituents_per_aggregate

        return props


@dataclass
class AutocommitPeriod:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class ClientConfigurations:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    options: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    clients: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.options is not None:
            if hasattr(self.options, 'to_dict'):
                props['Options'] = self.options.to_dict()
            elif isinstance(self.options, list):
                props['Options'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.options
                ]
            else:
                props['Options'] = self.options

        if self.clients is not None:
            if hasattr(self.clients, 'to_dict'):
                props['Clients'] = self.clients.to_dict()
            elif isinstance(self.clients, list):
                props['Clients'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.clients
                ]
            else:
                props['Clients'] = self.clients

        return props


@dataclass
class NfsExports:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    client_configurations: Optional[list[ClientConfigurations]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.client_configurations is not None:
            if hasattr(self.client_configurations, 'to_dict'):
                props['ClientConfigurations'] = self.client_configurations.to_dict()
            elif isinstance(self.client_configurations, list):
                props['ClientConfigurations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_configurations
                ]
            else:
                props['ClientConfigurations'] = self.client_configurations

        return props


@dataclass
class OntapConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    junction_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    storage_virtual_machine_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tiering_policy: Optional[TieringPolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    size_in_megabytes: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_style: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    size_in_bytes: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_style: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snaplock_configuration: Optional[SnaplockConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    aggregate_configuration: Optional[AggregateConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snapshot_policy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    storage_efficiency_enabled: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    copy_tags_to_backups: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ontap_volume_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.junction_path is not None:
            if hasattr(self.junction_path, 'to_dict'):
                props['JunctionPath'] = self.junction_path.to_dict()
            elif isinstance(self.junction_path, list):
                props['JunctionPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.junction_path
                ]
            else:
                props['JunctionPath'] = self.junction_path

        if self.storage_virtual_machine_id is not None:
            if hasattr(self.storage_virtual_machine_id, 'to_dict'):
                props['StorageVirtualMachineId'] = self.storage_virtual_machine_id.to_dict()
            elif isinstance(self.storage_virtual_machine_id, list):
                props['StorageVirtualMachineId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_virtual_machine_id
                ]
            else:
                props['StorageVirtualMachineId'] = self.storage_virtual_machine_id

        if self.tiering_policy is not None:
            if hasattr(self.tiering_policy, 'to_dict'):
                props['TieringPolicy'] = self.tiering_policy.to_dict()
            elif isinstance(self.tiering_policy, list):
                props['TieringPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tiering_policy
                ]
            else:
                props['TieringPolicy'] = self.tiering_policy

        if self.size_in_megabytes is not None:
            if hasattr(self.size_in_megabytes, 'to_dict'):
                props['SizeInMegabytes'] = self.size_in_megabytes.to_dict()
            elif isinstance(self.size_in_megabytes, list):
                props['SizeInMegabytes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.size_in_megabytes
                ]
            else:
                props['SizeInMegabytes'] = self.size_in_megabytes

        if self.volume_style is not None:
            if hasattr(self.volume_style, 'to_dict'):
                props['VolumeStyle'] = self.volume_style.to_dict()
            elif isinstance(self.volume_style, list):
                props['VolumeStyle'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_style
                ]
            else:
                props['VolumeStyle'] = self.volume_style

        if self.size_in_bytes is not None:
            if hasattr(self.size_in_bytes, 'to_dict'):
                props['SizeInBytes'] = self.size_in_bytes.to_dict()
            elif isinstance(self.size_in_bytes, list):
                props['SizeInBytes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.size_in_bytes
                ]
            else:
                props['SizeInBytes'] = self.size_in_bytes

        if self.security_style is not None:
            if hasattr(self.security_style, 'to_dict'):
                props['SecurityStyle'] = self.security_style.to_dict()
            elif isinstance(self.security_style, list):
                props['SecurityStyle'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_style
                ]
            else:
                props['SecurityStyle'] = self.security_style

        if self.snaplock_configuration is not None:
            if hasattr(self.snaplock_configuration, 'to_dict'):
                props['SnaplockConfiguration'] = self.snaplock_configuration.to_dict()
            elif isinstance(self.snaplock_configuration, list):
                props['SnaplockConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snaplock_configuration
                ]
            else:
                props['SnaplockConfiguration'] = self.snaplock_configuration

        if self.aggregate_configuration is not None:
            if hasattr(self.aggregate_configuration, 'to_dict'):
                props['AggregateConfiguration'] = self.aggregate_configuration.to_dict()
            elif isinstance(self.aggregate_configuration, list):
                props['AggregateConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.aggregate_configuration
                ]
            else:
                props['AggregateConfiguration'] = self.aggregate_configuration

        if self.snapshot_policy is not None:
            if hasattr(self.snapshot_policy, 'to_dict'):
                props['SnapshotPolicy'] = self.snapshot_policy.to_dict()
            elif isinstance(self.snapshot_policy, list):
                props['SnapshotPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snapshot_policy
                ]
            else:
                props['SnapshotPolicy'] = self.snapshot_policy

        if self.storage_efficiency_enabled is not None:
            if hasattr(self.storage_efficiency_enabled, 'to_dict'):
                props['StorageEfficiencyEnabled'] = self.storage_efficiency_enabled.to_dict()
            elif isinstance(self.storage_efficiency_enabled, list):
                props['StorageEfficiencyEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_efficiency_enabled
                ]
            else:
                props['StorageEfficiencyEnabled'] = self.storage_efficiency_enabled

        if self.copy_tags_to_backups is not None:
            if hasattr(self.copy_tags_to_backups, 'to_dict'):
                props['CopyTagsToBackups'] = self.copy_tags_to_backups.to_dict()
            elif isinstance(self.copy_tags_to_backups, list):
                props['CopyTagsToBackups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.copy_tags_to_backups
                ]
            else:
                props['CopyTagsToBackups'] = self.copy_tags_to_backups

        if self.ontap_volume_type is not None:
            if hasattr(self.ontap_volume_type, 'to_dict'):
                props['OntapVolumeType'] = self.ontap_volume_type.to_dict()
            elif isinstance(self.ontap_volume_type, list):
                props['OntapVolumeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ontap_volume_type
                ]
            else:
                props['OntapVolumeType'] = self.ontap_volume_type

        return props


@dataclass
class OpenZFSConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    read_only: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    options: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_compression_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    nfs_exports: Optional[list[NfsExports]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    storage_capacity_quota_gi_b: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    copy_tags_to_snapshots: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parent_volume_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    storage_capacity_reservation_gi_b: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    record_size_ki_b: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    origin_snapshot: Optional[OriginSnapshot] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_and_group_quotas: Optional[list[UserAndGroupQuotas]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.read_only is not None:
            if hasattr(self.read_only, 'to_dict'):
                props['ReadOnly'] = self.read_only.to_dict()
            elif isinstance(self.read_only, list):
                props['ReadOnly'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.read_only
                ]
            else:
                props['ReadOnly'] = self.read_only

        if self.options is not None:
            if hasattr(self.options, 'to_dict'):
                props['Options'] = self.options.to_dict()
            elif isinstance(self.options, list):
                props['Options'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.options
                ]
            else:
                props['Options'] = self.options

        if self.data_compression_type is not None:
            if hasattr(self.data_compression_type, 'to_dict'):
                props['DataCompressionType'] = self.data_compression_type.to_dict()
            elif isinstance(self.data_compression_type, list):
                props['DataCompressionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_compression_type
                ]
            else:
                props['DataCompressionType'] = self.data_compression_type

        if self.nfs_exports is not None:
            if hasattr(self.nfs_exports, 'to_dict'):
                props['NfsExports'] = self.nfs_exports.to_dict()
            elif isinstance(self.nfs_exports, list):
                props['NfsExports'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.nfs_exports
                ]
            else:
                props['NfsExports'] = self.nfs_exports

        if self.storage_capacity_quota_gi_b is not None:
            if hasattr(self.storage_capacity_quota_gi_b, 'to_dict'):
                props['StorageCapacityQuotaGiB'] = self.storage_capacity_quota_gi_b.to_dict()
            elif isinstance(self.storage_capacity_quota_gi_b, list):
                props['StorageCapacityQuotaGiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_capacity_quota_gi_b
                ]
            else:
                props['StorageCapacityQuotaGiB'] = self.storage_capacity_quota_gi_b

        if self.copy_tags_to_snapshots is not None:
            if hasattr(self.copy_tags_to_snapshots, 'to_dict'):
                props['CopyTagsToSnapshots'] = self.copy_tags_to_snapshots.to_dict()
            elif isinstance(self.copy_tags_to_snapshots, list):
                props['CopyTagsToSnapshots'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.copy_tags_to_snapshots
                ]
            else:
                props['CopyTagsToSnapshots'] = self.copy_tags_to_snapshots

        if self.parent_volume_id is not None:
            if hasattr(self.parent_volume_id, 'to_dict'):
                props['ParentVolumeId'] = self.parent_volume_id.to_dict()
            elif isinstance(self.parent_volume_id, list):
                props['ParentVolumeId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parent_volume_id
                ]
            else:
                props['ParentVolumeId'] = self.parent_volume_id

        if self.storage_capacity_reservation_gi_b is not None:
            if hasattr(self.storage_capacity_reservation_gi_b, 'to_dict'):
                props['StorageCapacityReservationGiB'] = self.storage_capacity_reservation_gi_b.to_dict()
            elif isinstance(self.storage_capacity_reservation_gi_b, list):
                props['StorageCapacityReservationGiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_capacity_reservation_gi_b
                ]
            else:
                props['StorageCapacityReservationGiB'] = self.storage_capacity_reservation_gi_b

        if self.record_size_ki_b is not None:
            if hasattr(self.record_size_ki_b, 'to_dict'):
                props['RecordSizeKiB'] = self.record_size_ki_b.to_dict()
            elif isinstance(self.record_size_ki_b, list):
                props['RecordSizeKiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.record_size_ki_b
                ]
            else:
                props['RecordSizeKiB'] = self.record_size_ki_b

        if self.origin_snapshot is not None:
            if hasattr(self.origin_snapshot, 'to_dict'):
                props['OriginSnapshot'] = self.origin_snapshot.to_dict()
            elif isinstance(self.origin_snapshot, list):
                props['OriginSnapshot'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.origin_snapshot
                ]
            else:
                props['OriginSnapshot'] = self.origin_snapshot

        if self.user_and_group_quotas is not None:
            if hasattr(self.user_and_group_quotas, 'to_dict'):
                props['UserAndGroupQuotas'] = self.user_and_group_quotas.to_dict()
            elif isinstance(self.user_and_group_quotas, list):
                props['UserAndGroupQuotas'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_and_group_quotas
                ]
            else:
                props['UserAndGroupQuotas'] = self.user_and_group_quotas

        return props


@dataclass
class OriginSnapshot:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    copy_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snapshot_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.copy_strategy is not None:
            if hasattr(self.copy_strategy, 'to_dict'):
                props['CopyStrategy'] = self.copy_strategy.to_dict()
            elif isinstance(self.copy_strategy, list):
                props['CopyStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.copy_strategy
                ]
            else:
                props['CopyStrategy'] = self.copy_strategy

        if self.snapshot_arn is not None:
            if hasattr(self.snapshot_arn, 'to_dict'):
                props['SnapshotARN'] = self.snapshot_arn.to_dict()
            elif isinstance(self.snapshot_arn, list):
                props['SnapshotARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snapshot_arn
                ]
            else:
                props['SnapshotARN'] = self.snapshot_arn

        return props


@dataclass
class RetentionPeriod:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class SnaplockConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    audit_log_volume: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_append_mode_enabled: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    autocommit_period: Optional[AutocommitPeriod] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    retention_period: Optional[SnaplockRetentionPeriod] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    privileged_delete: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snaplock_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.audit_log_volume is not None:
            if hasattr(self.audit_log_volume, 'to_dict'):
                props['AuditLogVolume'] = self.audit_log_volume.to_dict()
            elif isinstance(self.audit_log_volume, list):
                props['AuditLogVolume'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.audit_log_volume
                ]
            else:
                props['AuditLogVolume'] = self.audit_log_volume

        if self.volume_append_mode_enabled is not None:
            if hasattr(self.volume_append_mode_enabled, 'to_dict'):
                props['VolumeAppendModeEnabled'] = self.volume_append_mode_enabled.to_dict()
            elif isinstance(self.volume_append_mode_enabled, list):
                props['VolumeAppendModeEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_append_mode_enabled
                ]
            else:
                props['VolumeAppendModeEnabled'] = self.volume_append_mode_enabled

        if self.autocommit_period is not None:
            if hasattr(self.autocommit_period, 'to_dict'):
                props['AutocommitPeriod'] = self.autocommit_period.to_dict()
            elif isinstance(self.autocommit_period, list):
                props['AutocommitPeriod'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.autocommit_period
                ]
            else:
                props['AutocommitPeriod'] = self.autocommit_period

        if self.retention_period is not None:
            if hasattr(self.retention_period, 'to_dict'):
                props['RetentionPeriod'] = self.retention_period.to_dict()
            elif isinstance(self.retention_period, list):
                props['RetentionPeriod'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.retention_period
                ]
            else:
                props['RetentionPeriod'] = self.retention_period

        if self.privileged_delete is not None:
            if hasattr(self.privileged_delete, 'to_dict'):
                props['PrivilegedDelete'] = self.privileged_delete.to_dict()
            elif isinstance(self.privileged_delete, list):
                props['PrivilegedDelete'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.privileged_delete
                ]
            else:
                props['PrivilegedDelete'] = self.privileged_delete

        if self.snaplock_type is not None:
            if hasattr(self.snaplock_type, 'to_dict'):
                props['SnaplockType'] = self.snaplock_type.to_dict()
            elif isinstance(self.snaplock_type, list):
                props['SnaplockType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snaplock_type
                ]
            else:
                props['SnaplockType'] = self.snaplock_type

        return props


@dataclass
class SnaplockRetentionPeriod:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_retention: Optional[RetentionPeriod] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_retention: Optional[RetentionPeriod] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    minimum_retention: Optional[RetentionPeriod] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_retention is not None:
            if hasattr(self.default_retention, 'to_dict'):
                props['DefaultRetention'] = self.default_retention.to_dict()
            elif isinstance(self.default_retention, list):
                props['DefaultRetention'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_retention
                ]
            else:
                props['DefaultRetention'] = self.default_retention

        if self.maximum_retention is not None:
            if hasattr(self.maximum_retention, 'to_dict'):
                props['MaximumRetention'] = self.maximum_retention.to_dict()
            elif isinstance(self.maximum_retention, list):
                props['MaximumRetention'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_retention
                ]
            else:
                props['MaximumRetention'] = self.maximum_retention

        if self.minimum_retention is not None:
            if hasattr(self.minimum_retention, 'to_dict'):
                props['MinimumRetention'] = self.minimum_retention.to_dict()
            elif isinstance(self.minimum_retention, list):
                props['MinimumRetention'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.minimum_retention
                ]
            else:
                props['MinimumRetention'] = self.minimum_retention

        return props


@dataclass
class TieringPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cooling_period: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cooling_period is not None:
            if hasattr(self.cooling_period, 'to_dict'):
                props['CoolingPeriod'] = self.cooling_period.to_dict()
            elif isinstance(self.cooling_period, list):
                props['CoolingPeriod'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cooling_period
                ]
            else:
                props['CoolingPeriod'] = self.cooling_period

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class UserAndGroupQuotas:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fsx"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    id: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    storage_capacity_quota_gi_b: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.id is not None:
            if hasattr(self.id, 'to_dict'):
                props['Id'] = self.id.to_dict()
            elif isinstance(self.id, list):
                props['Id'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.id
                ]
            else:
                props['Id'] = self.id

        if self.storage_capacity_quota_gi_b is not None:
            if hasattr(self.storage_capacity_quota_gi_b, 'to_dict'):
                props['StorageCapacityQuotaGiB'] = self.storage_capacity_quota_gi_b.to_dict()
            elif isinstance(self.storage_capacity_quota_gi_b, list):
                props['StorageCapacityQuotaGiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_capacity_quota_gi_b
                ]
            else:
                props['StorageCapacityQuotaGiB'] = self.storage_capacity_quota_gi_b

        return props


@dataclass
class Volume(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-fsx-v"""

    resource_type: ClassVar[str] = "AWS::FSx::Volume"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    open_zfs_configuration: Optional[OpenZFSConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    volume_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    backup_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ontap_configuration: Optional[OntapConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.open_zfs_configuration is not None:
            # Serialize open_zfs_configuration (handle intrinsic functions)
            if hasattr(self.open_zfs_configuration, 'to_dict'):
                props["OpenZFSConfiguration"] = self.open_zfs_configuration.to_dict()
            elif isinstance(self.open_zfs_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['OpenZFSConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.open_zfs_configuration
                ]
            else:
                props["OpenZFSConfiguration"] = self.open_zfs_configuration

        if self.volume_type is not None:
            # Serialize volume_type (handle intrinsic functions)
            if hasattr(self.volume_type, 'to_dict'):
                props["VolumeType"] = self.volume_type.to_dict()
            elif isinstance(self.volume_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['VolumeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_type
                ]
            else:
                props["VolumeType"] = self.volume_type

        if self.backup_id is not None:
            # Serialize backup_id (handle intrinsic functions)
            if hasattr(self.backup_id, 'to_dict'):
                props["BackupId"] = self.backup_id.to_dict()
            elif isinstance(self.backup_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['BackupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.backup_id
                ]
            else:
                props["BackupId"] = self.backup_id

        if self.ontap_configuration is not None:
            # Serialize ontap_configuration (handle intrinsic functions)
            if hasattr(self.ontap_configuration, 'to_dict'):
                props["OntapConfiguration"] = self.ontap_configuration.to_dict()
            elif isinstance(self.ontap_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['OntapConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ontap_configuration
                ]
            else:
                props["OntapConfiguration"] = self.ontap_configuration

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_resource_arn(self) -> GetAtt:
        """Get the ResourceARN attribute."""
        return self.get_att("ResourceARN")

    @property
    def attr_volume_id(self) -> GetAtt:
        """Get the VolumeId attribute."""
        return self.get_att("VolumeId")

    @property
    def attr_uuid(self) -> GetAtt:
        """Get the UUID attribute."""
        return self.get_att("UUID")



