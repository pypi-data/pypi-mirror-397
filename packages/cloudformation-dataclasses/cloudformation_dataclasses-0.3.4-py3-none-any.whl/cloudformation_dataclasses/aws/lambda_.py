"""
AWS CloudFormation Lambda Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 21:57:47

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service Lambda
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource, PropertyType, Tag
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class ApplicationLogLevel:
    """ApplicationLogLevel enum values."""

    TRACE = "TRACE"
    DEBUG = "DEBUG"
    INFO = "INFO"
    WARN = "WARN"
    ERROR = "ERROR"
    FATAL = "FATAL"


class Architecture:
    """Architecture enum values."""

    X86_64 = "x86_64"
    ARM64 = "arm64"


class CapacityProviderPredefinedMetricType:
    """CapacityProviderPredefinedMetricType enum values."""

    LAMBDACAPACITYPROVIDERAVERAGECPUUTILIZATION = "LambdaCapacityProviderAverageCPUUtilization"


class CapacityProviderScalingMode:
    """CapacityProviderScalingMode enum values."""

    AUTO = "Auto"
    MANUAL = "Manual"


class CapacityProviderState:
    """CapacityProviderState enum values."""

    PENDING = "Pending"
    ACTIVE = "Active"
    FAILED = "Failed"
    DELETING = "Deleting"


class CodeSigningPolicy:
    """CodeSigningPolicy enum values."""

    WARN = "Warn"
    ENFORCE = "Enforce"


class EndPointType:
    """EndPointType enum values."""

    KAFKA_BOOTSTRAP_SERVERS = "KAFKA_BOOTSTRAP_SERVERS"


class EventSourceMappingMetric:
    """EventSourceMappingMetric enum values."""

    EVENTCOUNT = "EventCount"


class EventSourcePosition:
    """EventSourcePosition enum values."""

    TRIM_HORIZON = "TRIM_HORIZON"
    LATEST = "LATEST"
    AT_TIMESTAMP = "AT_TIMESTAMP"


class EventType:
    """EventType enum values."""

    EXECUTIONSTARTED = "ExecutionStarted"
    EXECUTIONSUCCEEDED = "ExecutionSucceeded"
    EXECUTIONFAILED = "ExecutionFailed"
    EXECUTIONTIMEDOUT = "ExecutionTimedOut"
    EXECUTIONSTOPPED = "ExecutionStopped"
    CONTEXTSTARTED = "ContextStarted"
    CONTEXTSUCCEEDED = "ContextSucceeded"
    CONTEXTFAILED = "ContextFailed"
    WAITSTARTED = "WaitStarted"
    WAITSUCCEEDED = "WaitSucceeded"
    WAITCANCELLED = "WaitCancelled"
    STEPSTARTED = "StepStarted"
    STEPSUCCEEDED = "StepSucceeded"
    STEPFAILED = "StepFailed"
    CHAINEDINVOKESTARTED = "ChainedInvokeStarted"
    CHAINEDINVOKESUCCEEDED = "ChainedInvokeSucceeded"
    CHAINEDINVOKEFAILED = "ChainedInvokeFailed"
    CHAINEDINVOKETIMEDOUT = "ChainedInvokeTimedOut"
    CHAINEDINVOKESTOPPED = "ChainedInvokeStopped"
    CALLBACKSTARTED = "CallbackStarted"
    CALLBACKSUCCEEDED = "CallbackSucceeded"
    CALLBACKFAILED = "CallbackFailed"
    CALLBACKTIMEDOUT = "CallbackTimedOut"
    INVOCATIONCOMPLETED = "InvocationCompleted"


class ExecutionStatus:
    """ExecutionStatus enum values."""

    RUNNING = "RUNNING"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    TIMED_OUT = "TIMED_OUT"
    STOPPED = "STOPPED"


class FullDocument:
    """FullDocument enum values."""

    UPDATELOOKUP = "UpdateLookup"
    DEFAULT = "Default"


class FunctionResponseType:
    """FunctionResponseType enum values."""

    REPORTBATCHITEMFAILURES = "ReportBatchItemFailures"


class FunctionUrlAuthType:
    """FunctionUrlAuthType enum values."""

    NONE = "NONE"
    AWS_IAM = "AWS_IAM"


class FunctionVersion:
    """FunctionVersion enum values."""

    ALL = "ALL"


class FunctionVersionLatestPublished:
    """FunctionVersionLatestPublished enum values."""

    LATEST_PUBLISHED = "LATEST_PUBLISHED"


class InvocationType:
    """InvocationType enum values."""

    EVENT = "Event"
    REQUESTRESPONSE = "RequestResponse"
    DRYRUN = "DryRun"


class InvokeMode:
    """InvokeMode enum values."""

    BUFFERED = "BUFFERED"
    RESPONSE_STREAM = "RESPONSE_STREAM"


class KafkaSchemaRegistryAuthType:
    """KafkaSchemaRegistryAuthType enum values."""

    BASIC_AUTH = "BASIC_AUTH"
    CLIENT_CERTIFICATE_TLS_AUTH = "CLIENT_CERTIFICATE_TLS_AUTH"
    SERVER_ROOT_CA_CERTIFICATE = "SERVER_ROOT_CA_CERTIFICATE"


class KafkaSchemaValidationAttribute:
    """KafkaSchemaValidationAttribute enum values."""

    KEY = "KEY"
    VALUE = "VALUE"


class LastUpdateStatus:
    """LastUpdateStatus enum values."""

    SUCCESSFUL = "Successful"
    FAILED = "Failed"
    INPROGRESS = "InProgress"


class LastUpdateStatusReasonCode:
    """LastUpdateStatusReasonCode enum values."""

    ENILIMITEXCEEDED = "EniLimitExceeded"
    INSUFFICIENTROLEPERMISSIONS = "InsufficientRolePermissions"
    INVALIDCONFIGURATION = "InvalidConfiguration"
    INTERNALERROR = "InternalError"
    SUBNETOUTOFIPADDRESSES = "SubnetOutOfIPAddresses"
    INVALIDSUBNET = "InvalidSubnet"
    INVALIDSECURITYGROUP = "InvalidSecurityGroup"
    IMAGEDELETED = "ImageDeleted"
    IMAGEACCESSDENIED = "ImageAccessDenied"
    INVALIDIMAGE = "InvalidImage"
    KMSKEYACCESSDENIED = "KMSKeyAccessDenied"
    KMSKEYNOTFOUND = "KMSKeyNotFound"
    INVALIDSTATEKMSKEY = "InvalidStateKMSKey"
    DISABLEDKMSKEY = "DisabledKMSKey"
    EFSIOERROR = "EFSIOError"
    EFSMOUNTCONNECTIVITYERROR = "EFSMountConnectivityError"
    EFSMOUNTFAILURE = "EFSMountFailure"
    EFSMOUNTTIMEOUT = "EFSMountTimeout"
    INVALIDRUNTIME = "InvalidRuntime"
    INVALIDZIPFILEEXCEPTION = "InvalidZipFileException"
    FUNCTIONERROR = "FunctionError"
    VCPULIMITEXCEEDED = "VcpuLimitExceeded"
    CAPACITYPROVIDERSCALINGLIMITEXCEEDED = "CapacityProviderScalingLimitExceeded"
    INSUFFICIENTCAPACITY = "InsufficientCapacity"
    EC2REQUESTLIMITEXCEEDED = "EC2RequestLimitExceeded"
    FUNCTIONERROR_INITTIMEOUT = "FunctionError.InitTimeout"
    FUNCTIONERROR_RUNTIMEINITERROR = "FunctionError.RuntimeInitError"
    FUNCTIONERROR_EXTENSIONINITERROR = "FunctionError.ExtensionInitError"
    FUNCTIONERROR_INVALIDENTRYPOINT = "FunctionError.InvalidEntryPoint"
    FUNCTIONERROR_INVALIDWORKINGDIRECTORY = "FunctionError.InvalidWorkingDirectory"
    FUNCTIONERROR_PERMISSIONDENIED = "FunctionError.PermissionDenied"
    FUNCTIONERROR_TOOMANYEXTENSIONS = "FunctionError.TooManyExtensions"
    FUNCTIONERROR_INITRESOURCEEXHAUSTED = "FunctionError.InitResourceExhausted"
    DISALLOWEDBYVPCENCRYPTIONCONTROL = "DisallowedByVpcEncryptionControl"


class LogFormat:
    """LogFormat enum values."""

    JSON = "JSON"
    TEXT = "Text"


class LogType:
    """LogType enum values."""

    NONE = "None"
    TAIL = "Tail"


class OperationAction:
    """OperationAction enum values."""

    START = "START"
    SUCCEED = "SUCCEED"
    FAIL = "FAIL"
    RETRY = "RETRY"
    CANCEL = "CANCEL"


class OperationStatus:
    """OperationStatus enum values."""

    STARTED = "STARTED"
    PENDING = "PENDING"
    READY = "READY"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"
    TIMED_OUT = "TIMED_OUT"
    STOPPED = "STOPPED"


class OperationType:
    """OperationType enum values."""

    EXECUTION = "EXECUTION"
    CONTEXT = "CONTEXT"
    STEP = "STEP"
    WAIT = "WAIT"
    CALLBACK = "CALLBACK"
    CHAINED_INVOKE = "CHAINED_INVOKE"


class PackageType:
    """PackageType enum values."""

    ZIP = "Zip"
    IMAGE = "Image"


class ProvisionedConcurrencyStatusEnum:
    """ProvisionedConcurrencyStatusEnum enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    READY = "READY"
    FAILED = "FAILED"


class RecursiveLoop:
    """RecursiveLoop enum values."""

    ALLOW = "Allow"
    TERMINATE = "Terminate"


class ResponseStreamingInvocationType:
    """ResponseStreamingInvocationType enum values."""

    REQUESTRESPONSE = "RequestResponse"
    DRYRUN = "DryRun"


class Runtime:
    """Runtime enum values."""

    NODEJS = "nodejs"
    NODEJS4_3 = "nodejs4.3"
    NODEJS6_10 = "nodejs6.10"
    NODEJS8_10 = "nodejs8.10"
    NODEJS10_X = "nodejs10.x"
    NODEJS12_X = "nodejs12.x"
    NODEJS14_X = "nodejs14.x"
    NODEJS16_X = "nodejs16.x"
    JAVA8 = "java8"
    JAVA8_AL2 = "java8.al2"
    JAVA11 = "java11"
    PYTHON2_7 = "python2.7"
    PYTHON3_6 = "python3.6"
    PYTHON3_7 = "python3.7"
    PYTHON3_8 = "python3.8"
    PYTHON3_9 = "python3.9"
    DOTNETCORE1_0 = "dotnetcore1.0"
    DOTNETCORE2_0 = "dotnetcore2.0"
    DOTNETCORE2_1 = "dotnetcore2.1"
    DOTNETCORE3_1 = "dotnetcore3.1"
    DOTNET6 = "dotnet6"
    DOTNET8 = "dotnet8"
    NODEJS4_3_EDGE = "nodejs4.3-edge"
    GO1_X = "go1.x"
    RUBY2_5 = "ruby2.5"
    RUBY2_7 = "ruby2.7"
    PROVIDED = "provided"
    PROVIDED_AL2 = "provided.al2"
    NODEJS18_X = "nodejs18.x"
    PYTHON3_10 = "python3.10"
    JAVA17 = "java17"
    RUBY3_2 = "ruby3.2"
    RUBY3_3 = "ruby3.3"
    RUBY3_4 = "ruby3.4"
    PYTHON3_11 = "python3.11"
    NODEJS20_X = "nodejs20.x"
    PROVIDED_AL2023 = "provided.al2023"
    PYTHON3_12 = "python3.12"
    JAVA21 = "java21"
    PYTHON3_13 = "python3.13"
    NODEJS22_X = "nodejs22.x"
    NODEJS24_X = "nodejs24.x"
    PYTHON3_14 = "python3.14"
    JAVA25 = "java25"
    DOTNET10 = "dotnet10"


class SchemaRegistryEventRecordFormat:
    """SchemaRegistryEventRecordFormat enum values."""

    JSON = "JSON"
    SOURCE = "SOURCE"


class SnapStartApplyOn:
    """SnapStartApplyOn enum values."""

    PUBLISHEDVERSIONS = "PublishedVersions"
    NONE = "None"


class SnapStartOptimizationStatus:
    """SnapStartOptimizationStatus enum values."""

    ON = "On"
    OFF = "Off"


class SourceAccessType:
    """SourceAccessType enum values."""

    BASIC_AUTH = "BASIC_AUTH"
    VPC_SUBNET = "VPC_SUBNET"
    VPC_SECURITY_GROUP = "VPC_SECURITY_GROUP"
    SASL_SCRAM_512_AUTH = "SASL_SCRAM_512_AUTH"
    SASL_SCRAM_256_AUTH = "SASL_SCRAM_256_AUTH"
    VIRTUAL_HOST = "VIRTUAL_HOST"
    CLIENT_CERTIFICATE_TLS_AUTH = "CLIENT_CERTIFICATE_TLS_AUTH"
    SERVER_ROOT_CA_CERTIFICATE = "SERVER_ROOT_CA_CERTIFICATE"


class State:
    """State enum values."""

    PENDING = "Pending"
    ACTIVE = "Active"
    INACTIVE = "Inactive"
    FAILED = "Failed"
    DEACTIVATING = "Deactivating"
    DEACTIVATED = "Deactivated"
    ACTIVENONINVOCABLE = "ActiveNonInvocable"
    DELETING = "Deleting"


class StateReasonCode:
    """StateReasonCode enum values."""

    IDLE = "Idle"
    CREATING = "Creating"
    RESTORING = "Restoring"
    ENILIMITEXCEEDED = "EniLimitExceeded"
    INSUFFICIENTROLEPERMISSIONS = "InsufficientRolePermissions"
    INVALIDCONFIGURATION = "InvalidConfiguration"
    INTERNALERROR = "InternalError"
    SUBNETOUTOFIPADDRESSES = "SubnetOutOfIPAddresses"
    INVALIDSUBNET = "InvalidSubnet"
    INVALIDSECURITYGROUP = "InvalidSecurityGroup"
    IMAGEDELETED = "ImageDeleted"
    IMAGEACCESSDENIED = "ImageAccessDenied"
    INVALIDIMAGE = "InvalidImage"
    KMSKEYACCESSDENIED = "KMSKeyAccessDenied"
    KMSKEYNOTFOUND = "KMSKeyNotFound"
    INVALIDSTATEKMSKEY = "InvalidStateKMSKey"
    DISABLEDKMSKEY = "DisabledKMSKey"
    EFSIOERROR = "EFSIOError"
    EFSMOUNTCONNECTIVITYERROR = "EFSMountConnectivityError"
    EFSMOUNTFAILURE = "EFSMountFailure"
    EFSMOUNTTIMEOUT = "EFSMountTimeout"
    INVALIDRUNTIME = "InvalidRuntime"
    INVALIDZIPFILEEXCEPTION = "InvalidZipFileException"
    FUNCTIONERROR = "FunctionError"
    DRAININGDURABLEEXECUTIONS = "DrainingDurableExecutions"
    VCPULIMITEXCEEDED = "VcpuLimitExceeded"
    CAPACITYPROVIDERSCALINGLIMITEXCEEDED = "CapacityProviderScalingLimitExceeded"
    INSUFFICIENTCAPACITY = "InsufficientCapacity"
    EC2REQUESTLIMITEXCEEDED = "EC2RequestLimitExceeded"
    FUNCTIONERROR_INITTIMEOUT = "FunctionError.InitTimeout"
    FUNCTIONERROR_RUNTIMEINITERROR = "FunctionError.RuntimeInitError"
    FUNCTIONERROR_EXTENSIONINITERROR = "FunctionError.ExtensionInitError"
    FUNCTIONERROR_INVALIDENTRYPOINT = "FunctionError.InvalidEntryPoint"
    FUNCTIONERROR_INVALIDWORKINGDIRECTORY = "FunctionError.InvalidWorkingDirectory"
    FUNCTIONERROR_PERMISSIONDENIED = "FunctionError.PermissionDenied"
    FUNCTIONERROR_TOOMANYEXTENSIONS = "FunctionError.TooManyExtensions"
    FUNCTIONERROR_INITRESOURCEEXHAUSTED = "FunctionError.InitResourceExhausted"
    DISALLOWEDBYVPCENCRYPTIONCONTROL = "DisallowedByVpcEncryptionControl"


class SystemLogLevel:
    """SystemLogLevel enum values."""

    DEBUG = "DEBUG"
    INFO = "INFO"
    WARN = "WARN"


class TenantIsolationMode:
    """TenantIsolationMode enum values."""

    PER_TENANT = "PER_TENANT"


class ThrottleReason:
    """ThrottleReason enum values."""

    CONCURRENTINVOCATIONLIMITEXCEEDED = "ConcurrentInvocationLimitExceeded"
    FUNCTIONINVOCATIONRATELIMITEXCEEDED = "FunctionInvocationRateLimitExceeded"
    RESERVEDFUNCTIONCONCURRENTINVOCATIONLIMITEXCEEDED = "ReservedFunctionConcurrentInvocationLimitExceeded"
    RESERVEDFUNCTIONINVOCATIONRATELIMITEXCEEDED = "ReservedFunctionInvocationRateLimitExceeded"
    CALLERRATELIMITEXCEEDED = "CallerRateLimitExceeded"
    CONCURRENTSNAPSHOTCREATELIMITEXCEEDED = "ConcurrentSnapshotCreateLimitExceeded"


class TracingMode:
    """TracingMode enum values."""

    ACTIVE = "Active"
    PASSTHROUGH = "PassThrough"


class UpdateRuntimeOn:
    """UpdateRuntimeOn enum values."""

    AUTO = "Auto"
    MANUAL = "Manual"
    FUNCTIONUPDATE = "FunctionUpdate"


# Convenient aliases for enum values
TRACE = ApplicationLogLevel.TRACE
DEBUG = ApplicationLogLevel.DEBUG
INFO = ApplicationLogLevel.INFO
WARN = ApplicationLogLevel.WARN
ERROR = ApplicationLogLevel.ERROR
FATAL = ApplicationLogLevel.FATAL
X86_64 = Architecture.X86_64
ARM64 = Architecture.ARM64
LAMBDACAPACITYPROVIDERAVERAGECPUUTILIZATION = CapacityProviderPredefinedMetricType.LAMBDACAPACITYPROVIDERAVERAGECPUUTILIZATION
AUTO = CapacityProviderScalingMode.AUTO
MANUAL = CapacityProviderScalingMode.MANUAL
PENDING = CapacityProviderState.PENDING
ACTIVE = CapacityProviderState.ACTIVE
FAILED = CapacityProviderState.FAILED
DELETING = CapacityProviderState.DELETING
WARN = CodeSigningPolicy.WARN
ENFORCE = CodeSigningPolicy.ENFORCE
KAFKA_BOOTSTRAP_SERVERS = EndPointType.KAFKA_BOOTSTRAP_SERVERS
EVENTCOUNT = EventSourceMappingMetric.EVENTCOUNT
TRIM_HORIZON = EventSourcePosition.TRIM_HORIZON
LATEST = EventSourcePosition.LATEST
AT_TIMESTAMP = EventSourcePosition.AT_TIMESTAMP
EXECUTIONSTARTED = EventType.EXECUTIONSTARTED
EXECUTIONSUCCEEDED = EventType.EXECUTIONSUCCEEDED
EXECUTIONFAILED = EventType.EXECUTIONFAILED
EXECUTIONTIMEDOUT = EventType.EXECUTIONTIMEDOUT
EXECUTIONSTOPPED = EventType.EXECUTIONSTOPPED
CONTEXTSTARTED = EventType.CONTEXTSTARTED
CONTEXTSUCCEEDED = EventType.CONTEXTSUCCEEDED
CONTEXTFAILED = EventType.CONTEXTFAILED
WAITSTARTED = EventType.WAITSTARTED
WAITSUCCEEDED = EventType.WAITSUCCEEDED
WAITCANCELLED = EventType.WAITCANCELLED
STEPSTARTED = EventType.STEPSTARTED
STEPSUCCEEDED = EventType.STEPSUCCEEDED
STEPFAILED = EventType.STEPFAILED
CHAINEDINVOKESTARTED = EventType.CHAINEDINVOKESTARTED
CHAINEDINVOKESUCCEEDED = EventType.CHAINEDINVOKESUCCEEDED
CHAINEDINVOKEFAILED = EventType.CHAINEDINVOKEFAILED
CHAINEDINVOKETIMEDOUT = EventType.CHAINEDINVOKETIMEDOUT
CHAINEDINVOKESTOPPED = EventType.CHAINEDINVOKESTOPPED
CALLBACKSTARTED = EventType.CALLBACKSTARTED
CALLBACKSUCCEEDED = EventType.CALLBACKSUCCEEDED
CALLBACKFAILED = EventType.CALLBACKFAILED
CALLBACKTIMEDOUT = EventType.CALLBACKTIMEDOUT
INVOCATIONCOMPLETED = EventType.INVOCATIONCOMPLETED
RUNNING = ExecutionStatus.RUNNING
SUCCEEDED = ExecutionStatus.SUCCEEDED
FAILED = ExecutionStatus.FAILED
TIMED_OUT = ExecutionStatus.TIMED_OUT
STOPPED = ExecutionStatus.STOPPED
UPDATELOOKUP = FullDocument.UPDATELOOKUP
DEFAULT = FullDocument.DEFAULT
REPORTBATCHITEMFAILURES = FunctionResponseType.REPORTBATCHITEMFAILURES
NONE = FunctionUrlAuthType.NONE
AWS_IAM = FunctionUrlAuthType.AWS_IAM
ALL = FunctionVersion.ALL
LATEST_PUBLISHED = FunctionVersionLatestPublished.LATEST_PUBLISHED
EVENT = InvocationType.EVENT
REQUESTRESPONSE = InvocationType.REQUESTRESPONSE
DRYRUN = InvocationType.DRYRUN
BUFFERED = InvokeMode.BUFFERED
RESPONSE_STREAM = InvokeMode.RESPONSE_STREAM
BASIC_AUTH = KafkaSchemaRegistryAuthType.BASIC_AUTH
CLIENT_CERTIFICATE_TLS_AUTH = KafkaSchemaRegistryAuthType.CLIENT_CERTIFICATE_TLS_AUTH
SERVER_ROOT_CA_CERTIFICATE = KafkaSchemaRegistryAuthType.SERVER_ROOT_CA_CERTIFICATE
KEY = KafkaSchemaValidationAttribute.KEY
VALUE = KafkaSchemaValidationAttribute.VALUE
SUCCESSFUL = LastUpdateStatus.SUCCESSFUL
FAILED = LastUpdateStatus.FAILED
INPROGRESS = LastUpdateStatus.INPROGRESS
ENILIMITEXCEEDED = LastUpdateStatusReasonCode.ENILIMITEXCEEDED
INSUFFICIENTROLEPERMISSIONS = LastUpdateStatusReasonCode.INSUFFICIENTROLEPERMISSIONS
INVALIDCONFIGURATION = LastUpdateStatusReasonCode.INVALIDCONFIGURATION
INTERNALERROR = LastUpdateStatusReasonCode.INTERNALERROR
SUBNETOUTOFIPADDRESSES = LastUpdateStatusReasonCode.SUBNETOUTOFIPADDRESSES
INVALIDSUBNET = LastUpdateStatusReasonCode.INVALIDSUBNET
INVALIDSECURITYGROUP = LastUpdateStatusReasonCode.INVALIDSECURITYGROUP
IMAGEDELETED = LastUpdateStatusReasonCode.IMAGEDELETED
IMAGEACCESSDENIED = LastUpdateStatusReasonCode.IMAGEACCESSDENIED
INVALIDIMAGE = LastUpdateStatusReasonCode.INVALIDIMAGE
KMSKEYACCESSDENIED = LastUpdateStatusReasonCode.KMSKEYACCESSDENIED
KMSKEYNOTFOUND = LastUpdateStatusReasonCode.KMSKEYNOTFOUND
INVALIDSTATEKMSKEY = LastUpdateStatusReasonCode.INVALIDSTATEKMSKEY
DISABLEDKMSKEY = LastUpdateStatusReasonCode.DISABLEDKMSKEY
EFSIOERROR = LastUpdateStatusReasonCode.EFSIOERROR
EFSMOUNTCONNECTIVITYERROR = LastUpdateStatusReasonCode.EFSMOUNTCONNECTIVITYERROR
EFSMOUNTFAILURE = LastUpdateStatusReasonCode.EFSMOUNTFAILURE
EFSMOUNTTIMEOUT = LastUpdateStatusReasonCode.EFSMOUNTTIMEOUT
INVALIDRUNTIME = LastUpdateStatusReasonCode.INVALIDRUNTIME
INVALIDZIPFILEEXCEPTION = LastUpdateStatusReasonCode.INVALIDZIPFILEEXCEPTION
FUNCTIONERROR = LastUpdateStatusReasonCode.FUNCTIONERROR
VCPULIMITEXCEEDED = LastUpdateStatusReasonCode.VCPULIMITEXCEEDED
CAPACITYPROVIDERSCALINGLIMITEXCEEDED = LastUpdateStatusReasonCode.CAPACITYPROVIDERSCALINGLIMITEXCEEDED
INSUFFICIENTCAPACITY = LastUpdateStatusReasonCode.INSUFFICIENTCAPACITY
EC2REQUESTLIMITEXCEEDED = LastUpdateStatusReasonCode.EC2REQUESTLIMITEXCEEDED
FUNCTIONERROR_INITTIMEOUT = LastUpdateStatusReasonCode.FUNCTIONERROR_INITTIMEOUT
FUNCTIONERROR_RUNTIMEINITERROR = LastUpdateStatusReasonCode.FUNCTIONERROR_RUNTIMEINITERROR
FUNCTIONERROR_EXTENSIONINITERROR = LastUpdateStatusReasonCode.FUNCTIONERROR_EXTENSIONINITERROR
FUNCTIONERROR_INVALIDENTRYPOINT = LastUpdateStatusReasonCode.FUNCTIONERROR_INVALIDENTRYPOINT
FUNCTIONERROR_INVALIDWORKINGDIRECTORY = LastUpdateStatusReasonCode.FUNCTIONERROR_INVALIDWORKINGDIRECTORY
FUNCTIONERROR_PERMISSIONDENIED = LastUpdateStatusReasonCode.FUNCTIONERROR_PERMISSIONDENIED
FUNCTIONERROR_TOOMANYEXTENSIONS = LastUpdateStatusReasonCode.FUNCTIONERROR_TOOMANYEXTENSIONS
FUNCTIONERROR_INITRESOURCEEXHAUSTED = LastUpdateStatusReasonCode.FUNCTIONERROR_INITRESOURCEEXHAUSTED
DISALLOWEDBYVPCENCRYPTIONCONTROL = LastUpdateStatusReasonCode.DISALLOWEDBYVPCENCRYPTIONCONTROL
JSON = LogFormat.JSON
TEXT = LogFormat.TEXT
NONE = LogType.NONE
TAIL = LogType.TAIL
START = OperationAction.START
SUCCEED = OperationAction.SUCCEED
FAIL = OperationAction.FAIL
RETRY = OperationAction.RETRY
CANCEL = OperationAction.CANCEL
STARTED = OperationStatus.STARTED
PENDING = OperationStatus.PENDING
READY = OperationStatus.READY
SUCCEEDED = OperationStatus.SUCCEEDED
FAILED = OperationStatus.FAILED
CANCELLED = OperationStatus.CANCELLED
TIMED_OUT = OperationStatus.TIMED_OUT
STOPPED = OperationStatus.STOPPED
EXECUTION = OperationType.EXECUTION
CONTEXT = OperationType.CONTEXT
STEP = OperationType.STEP
WAIT = OperationType.WAIT
CALLBACK = OperationType.CALLBACK
CHAINED_INVOKE = OperationType.CHAINED_INVOKE
ZIP = PackageType.ZIP
IMAGE = PackageType.IMAGE
IN_PROGRESS = ProvisionedConcurrencyStatusEnum.IN_PROGRESS
READY = ProvisionedConcurrencyStatusEnum.READY
FAILED = ProvisionedConcurrencyStatusEnum.FAILED
ALLOW = RecursiveLoop.ALLOW
TERMINATE = RecursiveLoop.TERMINATE
REQUESTRESPONSE = ResponseStreamingInvocationType.REQUESTRESPONSE
DRYRUN = ResponseStreamingInvocationType.DRYRUN
NODEJS = Runtime.NODEJS
NODEJS4_3 = Runtime.NODEJS4_3
NODEJS6_10 = Runtime.NODEJS6_10
NODEJS8_10 = Runtime.NODEJS8_10
NODEJS10_X = Runtime.NODEJS10_X
NODEJS12_X = Runtime.NODEJS12_X
NODEJS14_X = Runtime.NODEJS14_X
NODEJS16_X = Runtime.NODEJS16_X
JAVA8 = Runtime.JAVA8
JAVA8_AL2 = Runtime.JAVA8_AL2
JAVA11 = Runtime.JAVA11
PYTHON2_7 = Runtime.PYTHON2_7
PYTHON3_6 = Runtime.PYTHON3_6
PYTHON3_7 = Runtime.PYTHON3_7
PYTHON3_8 = Runtime.PYTHON3_8
PYTHON3_9 = Runtime.PYTHON3_9
DOTNETCORE1_0 = Runtime.DOTNETCORE1_0
DOTNETCORE2_0 = Runtime.DOTNETCORE2_0
DOTNETCORE2_1 = Runtime.DOTNETCORE2_1
DOTNETCORE3_1 = Runtime.DOTNETCORE3_1
DOTNET6 = Runtime.DOTNET6
DOTNET8 = Runtime.DOTNET8
NODEJS4_3_EDGE = Runtime.NODEJS4_3_EDGE
GO1_X = Runtime.GO1_X
RUBY2_5 = Runtime.RUBY2_5
RUBY2_7 = Runtime.RUBY2_7
PROVIDED = Runtime.PROVIDED
PROVIDED_AL2 = Runtime.PROVIDED_AL2
NODEJS18_X = Runtime.NODEJS18_X
PYTHON3_10 = Runtime.PYTHON3_10
JAVA17 = Runtime.JAVA17
RUBY3_2 = Runtime.RUBY3_2
RUBY3_3 = Runtime.RUBY3_3
RUBY3_4 = Runtime.RUBY3_4
PYTHON3_11 = Runtime.PYTHON3_11
NODEJS20_X = Runtime.NODEJS20_X
PROVIDED_AL2023 = Runtime.PROVIDED_AL2023
PYTHON3_12 = Runtime.PYTHON3_12
JAVA21 = Runtime.JAVA21
PYTHON3_13 = Runtime.PYTHON3_13
NODEJS22_X = Runtime.NODEJS22_X
NODEJS24_X = Runtime.NODEJS24_X
PYTHON3_14 = Runtime.PYTHON3_14
JAVA25 = Runtime.JAVA25
DOTNET10 = Runtime.DOTNET10
JSON = SchemaRegistryEventRecordFormat.JSON
SOURCE = SchemaRegistryEventRecordFormat.SOURCE
PUBLISHEDVERSIONS = SnapStartApplyOn.PUBLISHEDVERSIONS
NONE = SnapStartApplyOn.NONE
ON = SnapStartOptimizationStatus.ON
OFF = SnapStartOptimizationStatus.OFF
BASIC_AUTH = SourceAccessType.BASIC_AUTH
VPC_SUBNET = SourceAccessType.VPC_SUBNET
VPC_SECURITY_GROUP = SourceAccessType.VPC_SECURITY_GROUP
SASL_SCRAM_512_AUTH = SourceAccessType.SASL_SCRAM_512_AUTH
SASL_SCRAM_256_AUTH = SourceAccessType.SASL_SCRAM_256_AUTH
VIRTUAL_HOST = SourceAccessType.VIRTUAL_HOST
CLIENT_CERTIFICATE_TLS_AUTH = SourceAccessType.CLIENT_CERTIFICATE_TLS_AUTH
SERVER_ROOT_CA_CERTIFICATE = SourceAccessType.SERVER_ROOT_CA_CERTIFICATE
PENDING = State.PENDING
ACTIVE = State.ACTIVE
INACTIVE = State.INACTIVE
FAILED = State.FAILED
DEACTIVATING = State.DEACTIVATING
DEACTIVATED = State.DEACTIVATED
ACTIVENONINVOCABLE = State.ACTIVENONINVOCABLE
DELETING = State.DELETING
IDLE = StateReasonCode.IDLE
CREATING = StateReasonCode.CREATING
RESTORING = StateReasonCode.RESTORING
ENILIMITEXCEEDED = StateReasonCode.ENILIMITEXCEEDED
INSUFFICIENTROLEPERMISSIONS = StateReasonCode.INSUFFICIENTROLEPERMISSIONS
INVALIDCONFIGURATION = StateReasonCode.INVALIDCONFIGURATION
INTERNALERROR = StateReasonCode.INTERNALERROR
SUBNETOUTOFIPADDRESSES = StateReasonCode.SUBNETOUTOFIPADDRESSES
INVALIDSUBNET = StateReasonCode.INVALIDSUBNET
INVALIDSECURITYGROUP = StateReasonCode.INVALIDSECURITYGROUP
IMAGEDELETED = StateReasonCode.IMAGEDELETED
IMAGEACCESSDENIED = StateReasonCode.IMAGEACCESSDENIED
INVALIDIMAGE = StateReasonCode.INVALIDIMAGE
KMSKEYACCESSDENIED = StateReasonCode.KMSKEYACCESSDENIED
KMSKEYNOTFOUND = StateReasonCode.KMSKEYNOTFOUND
INVALIDSTATEKMSKEY = StateReasonCode.INVALIDSTATEKMSKEY
DISABLEDKMSKEY = StateReasonCode.DISABLEDKMSKEY
EFSIOERROR = StateReasonCode.EFSIOERROR
EFSMOUNTCONNECTIVITYERROR = StateReasonCode.EFSMOUNTCONNECTIVITYERROR
EFSMOUNTFAILURE = StateReasonCode.EFSMOUNTFAILURE
EFSMOUNTTIMEOUT = StateReasonCode.EFSMOUNTTIMEOUT
INVALIDRUNTIME = StateReasonCode.INVALIDRUNTIME
INVALIDZIPFILEEXCEPTION = StateReasonCode.INVALIDZIPFILEEXCEPTION
FUNCTIONERROR = StateReasonCode.FUNCTIONERROR
DRAININGDURABLEEXECUTIONS = StateReasonCode.DRAININGDURABLEEXECUTIONS
VCPULIMITEXCEEDED = StateReasonCode.VCPULIMITEXCEEDED
CAPACITYPROVIDERSCALINGLIMITEXCEEDED = StateReasonCode.CAPACITYPROVIDERSCALINGLIMITEXCEEDED
INSUFFICIENTCAPACITY = StateReasonCode.INSUFFICIENTCAPACITY
EC2REQUESTLIMITEXCEEDED = StateReasonCode.EC2REQUESTLIMITEXCEEDED
FUNCTIONERROR_INITTIMEOUT = StateReasonCode.FUNCTIONERROR_INITTIMEOUT
FUNCTIONERROR_RUNTIMEINITERROR = StateReasonCode.FUNCTIONERROR_RUNTIMEINITERROR
FUNCTIONERROR_EXTENSIONINITERROR = StateReasonCode.FUNCTIONERROR_EXTENSIONINITERROR
FUNCTIONERROR_INVALIDENTRYPOINT = StateReasonCode.FUNCTIONERROR_INVALIDENTRYPOINT
FUNCTIONERROR_INVALIDWORKINGDIRECTORY = StateReasonCode.FUNCTIONERROR_INVALIDWORKINGDIRECTORY
FUNCTIONERROR_PERMISSIONDENIED = StateReasonCode.FUNCTIONERROR_PERMISSIONDENIED
FUNCTIONERROR_TOOMANYEXTENSIONS = StateReasonCode.FUNCTIONERROR_TOOMANYEXTENSIONS
FUNCTIONERROR_INITRESOURCEEXHAUSTED = StateReasonCode.FUNCTIONERROR_INITRESOURCEEXHAUSTED
DISALLOWEDBYVPCENCRYPTIONCONTROL = StateReasonCode.DISALLOWEDBYVPCENCRYPTIONCONTROL
DEBUG = SystemLogLevel.DEBUG
INFO = SystemLogLevel.INFO
WARN = SystemLogLevel.WARN
PER_TENANT = TenantIsolationMode.PER_TENANT
CONCURRENTINVOCATIONLIMITEXCEEDED = ThrottleReason.CONCURRENTINVOCATIONLIMITEXCEEDED
FUNCTIONINVOCATIONRATELIMITEXCEEDED = ThrottleReason.FUNCTIONINVOCATIONRATELIMITEXCEEDED
RESERVEDFUNCTIONCONCURRENTINVOCATIONLIMITEXCEEDED = ThrottleReason.RESERVEDFUNCTIONCONCURRENTINVOCATIONLIMITEXCEEDED
RESERVEDFUNCTIONINVOCATIONRATELIMITEXCEEDED = ThrottleReason.RESERVEDFUNCTIONINVOCATIONRATELIMITEXCEEDED
CALLERRATELIMITEXCEEDED = ThrottleReason.CALLERRATELIMITEXCEEDED
CONCURRENTSNAPSHOTCREATELIMITEXCEEDED = ThrottleReason.CONCURRENTSNAPSHOTCREATELIMITEXCEEDED
ACTIVE = TracingMode.ACTIVE
PASSTHROUGH = TracingMode.PASSTHROUGH
AUTO = UpdateRuntimeOn.AUTO
MANUAL = UpdateRuntimeOn.MANUAL
FUNCTIONUPDATE = UpdateRuntimeOn.FUNCTIONUPDATE


@dataclass
class AliasRoutingConfiguration(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "additional_version_weights": "AdditionalVersionWeights",
    }

    additional_version_weights: Optional[list[VersionWeight]] = None


@dataclass
class ProvisionedConcurrencyConfiguration(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "provisioned_concurrent_executions": "ProvisionedConcurrentExecutions",
    }

    provisioned_concurrent_executions: Optional[Union[int, Ref, GetAtt, Sub]] = None


@dataclass
class VersionWeight(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "function_version": "FunctionVersion",
        "function_weight": "FunctionWeight",
    }

    function_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    function_weight: Optional[Union[float, Ref, GetAtt, Sub]] = None


@dataclass
class Alias(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::Alias"
    _property_mappings: ClassVar[dict[str, str]] = {
        "function_name": "FunctionName",
        "provisioned_concurrency_config": "ProvisionedConcurrencyConfig",
        "description": "Description",
        "function_version": "FunctionVersion",
        "routing_config": "RoutingConfig",
        "name": "Name",
    }

    function_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    provisioned_concurrency_config: Optional[ProvisionedConcurrencyConfiguration] = None
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    function_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    routing_config: Optional[AliasRoutingConfiguration] = None
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    @property
    def attr_alias_arn(self) -> GetAtt:
        """Get the AliasArn attribute."""
        return self.get_att("AliasArn")




@dataclass
class CapacityProviderPermissionsConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "capacity_provider_operator_role_arn": "CapacityProviderOperatorRoleArn",
    }

    capacity_provider_operator_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None


@dataclass
class CapacityProviderScalingConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "scaling_policies": "ScalingPolicies",
        "scaling_mode": "ScalingMode",
        "max_v_cpu_count": "MaxVCpuCount",
    }

    scaling_policies: Optional[list[TargetTrackingScalingPolicy]] = None
    scaling_mode: Optional[Union[str, CapacityProviderScalingMode, Ref, GetAtt, Sub]] = None
    max_v_cpu_count: Optional[Union[int, Ref, GetAtt, Sub]] = None


@dataclass
class CapacityProviderVpcConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "subnet_ids": "SubnetIds",
        "security_group_ids": "SecurityGroupIds",
    }

    subnet_ids: Optional[Union[list[str], Ref]] = None
    security_group_ids: Optional[Union[list[str], Ref]] = None


@dataclass
class InstanceRequirements(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "allowed_instance_types": "AllowedInstanceTypes",
        "excluded_instance_types": "ExcludedInstanceTypes",
        "architectures": "Architectures",
    }

    allowed_instance_types: Optional[Union[list[str], Ref]] = None
    excluded_instance_types: Optional[Union[list[str], Ref]] = None
    architectures: Optional[Union[list[str], Ref]] = None


@dataclass
class TargetTrackingScalingPolicy(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "predefined_metric_type": "PredefinedMetricType",
        "target_value": "TargetValue",
    }

    predefined_metric_type: Optional[Union[str, CapacityProviderPredefinedMetricType, Ref, GetAtt, Sub]] = None
    target_value: Optional[Union[float, Ref, GetAtt, Sub]] = None


@dataclass
class CapacityProvider(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::CapacityProvider"
    _property_mappings: ClassVar[dict[str, str]] = {
        "capacity_provider_scaling_config": "CapacityProviderScalingConfig",
        "kms_key_arn": "KmsKeyArn",
        "vpc_config": "VpcConfig",
        "capacity_provider_name": "CapacityProviderName",
        "instance_requirements": "InstanceRequirements",
        "permissions_config": "PermissionsConfig",
        "tags": "Tags",
    }

    capacity_provider_scaling_config: Optional[CapacityProviderScalingConfig] = None
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    vpc_config: Optional[CapacityProviderVpcConfig] = None
    capacity_provider_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    instance_requirements: Optional[InstanceRequirements] = None
    permissions_config: Optional[CapacityProviderPermissionsConfig] = None
    tags: Optional[list[Tag]] = None

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class AllowedPublishers(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "signing_profile_version_arns": "SigningProfileVersionArns",
    }

    signing_profile_version_arns: Optional[Union[list[str], Ref]] = None


@dataclass
class CodeSigningPolicies(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "untrusted_artifact_on_deployment": "UntrustedArtifactOnDeployment",
    }

    untrusted_artifact_on_deployment: Optional[Union[str, CodeSigningPolicy, Ref, GetAtt, Sub]] = None


@dataclass
class CodeSigningConfig(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::CodeSigningConfig"
    _property_mappings: ClassVar[dict[str, str]] = {
        "description": "Description",
        "allowed_publishers": "AllowedPublishers",
        "code_signing_policies": "CodeSigningPolicies",
        "tags": "Tags",
    }

    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    allowed_publishers: Optional[AllowedPublishers] = None
    code_signing_policies: Optional[CodeSigningPolicies] = None
    tags: Optional[list[Tag]] = None

    @property
    def attr_code_signing_config_id(self) -> GetAtt:
        """Get the CodeSigningConfigId attribute."""
        return self.get_att("CodeSigningConfigId")

    @property
    def attr_code_signing_config_arn(self) -> GetAtt:
        """Get the CodeSigningConfigArn attribute."""
        return self.get_att("CodeSigningConfigArn")




@dataclass
class DestinationConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "on_success": "OnSuccess",
        "on_failure": "OnFailure",
    }

    on_success: Optional[OnSuccess] = None
    on_failure: Optional[OnFailure] = None


@dataclass
class OnFailure(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "destination": "Destination",
    }

    destination: Optional[Union[str, Ref, GetAtt, Sub]] = None


@dataclass
class OnSuccess(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "destination": "Destination",
    }

    destination: Optional[Union[str, Ref, GetAtt, Sub]] = None


@dataclass
class EventInvokeConfig(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::EventInvokeConfig"
    _property_mappings: ClassVar[dict[str, str]] = {
        "function_name": "FunctionName",
        "maximum_retry_attempts": "MaximumRetryAttempts",
        "destination_config": "DestinationConfig",
        "qualifier": "Qualifier",
        "maximum_event_age_in_seconds": "MaximumEventAgeInSeconds",
    }

    function_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    maximum_retry_attempts: Optional[Union[int, Ref, GetAtt, Sub]] = None
    destination_config: Optional[DestinationConfig] = None
    qualifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    maximum_event_age_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None



@dataclass
class AmazonManagedKafkaEventSourceConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "consumer_group_id": "ConsumerGroupId",
        "schema_registry_config": "SchemaRegistryConfig",
    }

    consumer_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    schema_registry_config: Optional[SchemaRegistryConfig] = None


@dataclass
class DestinationConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "on_failure": "OnFailure",
    }

    on_failure: Optional[OnFailure] = None


@dataclass
class DocumentDBEventSourceConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "full_document": "FullDocument",
        "collection_name": "CollectionName",
        "database_name": "DatabaseName",
    }

    full_document: Optional[Union[str, FullDocument, Ref, GetAtt, Sub]] = None
    collection_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    database_name: Optional[Union[str, Ref, GetAtt, Sub]] = None


@dataclass
class Endpoints(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "kafka_bootstrap_servers": "KafkaBootstrapServers",
    }

    kafka_bootstrap_servers: Optional[Union[list[str], Ref]] = None


@dataclass
class Filter(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "pattern": "Pattern",
    }

    pattern: Optional[Union[str, Ref, GetAtt, Sub]] = None


@dataclass
class FilterCriteria(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "filters": "Filters",
    }

    filters: Optional[list[Filter]] = None


@dataclass
class LoggingConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "system_log_level": "SystemLogLevel",
    }

    system_log_level: Optional[Union[str, SystemLogLevel, Ref, GetAtt, Sub]] = None


@dataclass
class MetricsConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "metrics": "Metrics",
    }

    metrics: Optional[Union[list[str], Ref]] = None


@dataclass
class OnFailure(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "destination": "Destination",
    }

    destination: Optional[Union[str, Ref, GetAtt, Sub]] = None


@dataclass
class ProvisionedPollerConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "poller_group_name": "PollerGroupName",
        "minimum_pollers": "MinimumPollers",
        "maximum_pollers": "MaximumPollers",
    }

    poller_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    minimum_pollers: Optional[Union[int, Ref, GetAtt, Sub]] = None
    maximum_pollers: Optional[Union[int, Ref, GetAtt, Sub]] = None


@dataclass
class ScalingConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "maximum_concurrency": "MaximumConcurrency",
    }

    maximum_concurrency: Optional[Union[int, Ref, GetAtt, Sub]] = None


@dataclass
class SchemaRegistryAccessConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "type_": "Type",
        "uri": "URI",
    }

    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    uri: Optional[Union[str, Ref, GetAtt, Sub]] = None


@dataclass
class SchemaRegistryConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "schema_validation_configs": "SchemaValidationConfigs",
        "schema_registry_uri": "SchemaRegistryURI",
        "event_record_format": "EventRecordFormat",
        "access_configs": "AccessConfigs",
    }

    schema_validation_configs: Optional[list[SchemaValidationConfig]] = None
    schema_registry_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    event_record_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    access_configs: Optional[list[SchemaRegistryAccessConfig]] = None


@dataclass
class SchemaValidationConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "attribute": "Attribute",
    }

    attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None


@dataclass
class SelfManagedEventSource(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "endpoints": "Endpoints",
    }

    endpoints: Optional[Endpoints] = None


@dataclass
class SelfManagedKafkaEventSourceConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "consumer_group_id": "ConsumerGroupId",
        "schema_registry_config": "SchemaRegistryConfig",
    }

    consumer_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    schema_registry_config: Optional[SchemaRegistryConfig] = None


@dataclass
class SourceAccessConfiguration(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "type_": "Type",
        "uri": "URI",
    }

    type_: Optional[Union[str, SourceAccessType, Ref, GetAtt, Sub]] = None
    uri: Optional[Union[str, Ref, GetAtt, Sub]] = None


@dataclass
class EventSourceMapping(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::EventSourceMapping"
    _property_mappings: ClassVar[dict[str, str]] = {
        "starting_position": "StartingPosition",
        "self_managed_event_source": "SelfManagedEventSource",
        "parallelization_factor": "ParallelizationFactor",
        "filter_criteria": "FilterCriteria",
        "provisioned_poller_config": "ProvisionedPollerConfig",
        "metrics_config": "MetricsConfig",
        "function_name": "FunctionName",
        "destination_config": "DestinationConfig",
        "kms_key_arn": "KmsKeyArn",
        "amazon_managed_kafka_event_source_config": "AmazonManagedKafkaEventSourceConfig",
        "source_access_configurations": "SourceAccessConfigurations",
        "tags": "Tags",
        "maximum_batching_window_in_seconds": "MaximumBatchingWindowInSeconds",
        "batch_size": "BatchSize",
        "maximum_retry_attempts": "MaximumRetryAttempts",
        "topics": "Topics",
        "scaling_config": "ScalingConfig",
        "enabled": "Enabled",
        "event_source_arn": "EventSourceArn",
        "self_managed_kafka_event_source_config": "SelfManagedKafkaEventSourceConfig",
        "document_db_event_source_config": "DocumentDBEventSourceConfig",
        "tumbling_window_in_seconds": "TumblingWindowInSeconds",
        "bisect_batch_on_function_error": "BisectBatchOnFunctionError",
        "maximum_record_age_in_seconds": "MaximumRecordAgeInSeconds",
        "starting_position_timestamp": "StartingPositionTimestamp",
        "logging_config": "LoggingConfig",
        "queues": "Queues",
        "function_response_types": "FunctionResponseTypes",
    }

    starting_position: Optional[Union[str, Ref, GetAtt, Sub]] = None
    self_managed_event_source: Optional[SelfManagedEventSource] = None
    parallelization_factor: Optional[Union[int, Ref, GetAtt, Sub]] = None
    filter_criteria: Optional[FilterCriteria] = None
    provisioned_poller_config: Optional[ProvisionedPollerConfig] = None
    metrics_config: Optional[MetricsConfig] = None
    function_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    destination_config: Optional[DestinationConfig] = None
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    amazon_managed_kafka_event_source_config: Optional[AmazonManagedKafkaEventSourceConfig] = None
    source_access_configurations: Optional[list[SourceAccessConfiguration]] = None
    tags: Optional[list[Tag]] = None
    maximum_batching_window_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    batch_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    maximum_retry_attempts: Optional[Union[int, Ref, GetAtt, Sub]] = None
    topics: Optional[Union[list[str], Ref]] = None
    scaling_config: Optional[ScalingConfig] = None
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    event_source_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    self_managed_kafka_event_source_config: Optional[SelfManagedKafkaEventSourceConfig] = None
    document_db_event_source_config: Optional[DocumentDBEventSourceConfig] = None
    tumbling_window_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    bisect_batch_on_function_error: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    maximum_record_age_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    starting_position_timestamp: Optional[Union[float, Ref, GetAtt, Sub]] = None
    logging_config: Optional[LoggingConfig] = None
    queues: Optional[Union[list[str], Ref]] = None
    function_response_types: Optional[Union[list[str], Ref]] = None

    @property
    def attr_event_source_mapping_arn(self) -> GetAtt:
        """Get the EventSourceMappingArn attribute."""
        return self.get_att("EventSourceMappingArn")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class CapacityProviderConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "lambda_managed_instances_capacity_provider_config": "LambdaManagedInstancesCapacityProviderConfig",
    }

    lambda_managed_instances_capacity_provider_config: Optional[LambdaManagedInstancesCapacityProviderConfig] = None


@dataclass
class Code(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "source_kms_key_arn": "SourceKMSKeyArn",
        "s3_object_version": "S3ObjectVersion",
        "s3_bucket": "S3Bucket",
        "zip_file": "ZipFile",
        "s3_key": "S3Key",
        "image_uri": "ImageUri",
    }

    source_kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    s3_object_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    s3_bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    zip_file: Optional[Union[str, Ref, GetAtt, Sub]] = None
    s3_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    image_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None


@dataclass
class DeadLetterConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "target_arn": "TargetArn",
    }

    target_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None


@dataclass
class DurableConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "execution_timeout": "ExecutionTimeout",
        "retention_period_in_days": "RetentionPeriodInDays",
    }

    execution_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    retention_period_in_days: Optional[Union[int, Ref, GetAtt, Sub]] = None


@dataclass
class Environment(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "variables": "Variables",
    }

    variables: Optional[dict[str, str]] = None


@dataclass
class EphemeralStorage(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "size": "Size",
    }

    size: Optional[Union[int, Ref, GetAtt, Sub]] = None


@dataclass
class FileSystemConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "arn": "Arn",
        "local_mount_path": "LocalMountPath",
    }

    arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    local_mount_path: Optional[Union[str, Ref, GetAtt, Sub]] = None


@dataclass
class FunctionScalingConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "min_execution_environments": "MinExecutionEnvironments",
        "max_execution_environments": "MaxExecutionEnvironments",
    }

    min_execution_environments: Optional[Union[int, Ref, GetAtt, Sub]] = None
    max_execution_environments: Optional[Union[int, Ref, GetAtt, Sub]] = None


@dataclass
class ImageConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "working_directory": "WorkingDirectory",
        "command": "Command",
        "entry_point": "EntryPoint",
    }

    working_directory: Optional[Union[str, Ref, GetAtt, Sub]] = None
    command: Optional[Union[list[str], Ref]] = None
    entry_point: Optional[Union[list[str], Ref]] = None


@dataclass
class LambdaManagedInstancesCapacityProviderConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "execution_environment_memory_gi_b_per_v_cpu": "ExecutionEnvironmentMemoryGiBPerVCpu",
        "capacity_provider_arn": "CapacityProviderArn",
        "per_execution_environment_max_concurrency": "PerExecutionEnvironmentMaxConcurrency",
    }

    execution_environment_memory_gi_b_per_v_cpu: Optional[Union[float, Ref, GetAtt, Sub]] = None
    capacity_provider_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    per_execution_environment_max_concurrency: Optional[Union[int, Ref, GetAtt, Sub]] = None


@dataclass
class LoggingConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "log_format": "LogFormat",
        "application_log_level": "ApplicationLogLevel",
        "log_group": "LogGroup",
        "system_log_level": "SystemLogLevel",
    }

    log_format: Optional[Union[str, LogFormat, Ref, GetAtt, Sub]] = None
    application_log_level: Optional[Union[str, ApplicationLogLevel, Ref, GetAtt, Sub]] = None
    log_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    system_log_level: Optional[Union[str, SystemLogLevel, Ref, GetAtt, Sub]] = None


@dataclass
class RuntimeManagementConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "update_runtime_on": "UpdateRuntimeOn",
        "runtime_version_arn": "RuntimeVersionArn",
    }

    update_runtime_on: Optional[Union[str, Ref, GetAtt, Sub]] = None
    runtime_version_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None


@dataclass
class SnapStart(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "apply_on": "ApplyOn",
    }

    apply_on: Optional[Union[str, SnapStartApplyOn, Ref, GetAtt, Sub]] = None


@dataclass
class SnapStartResponse(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "optimization_status": "OptimizationStatus",
        "apply_on": "ApplyOn",
    }

    optimization_status: Optional[Union[str, SnapStartOptimizationStatus, Ref, GetAtt, Sub]] = None
    apply_on: Optional[Union[str, SnapStartApplyOn, Ref, GetAtt, Sub]] = None


@dataclass
class TenancyConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "tenant_isolation_mode": "TenantIsolationMode",
    }

    tenant_isolation_mode: Optional[Union[str, TenantIsolationMode, Ref, GetAtt, Sub]] = None


@dataclass
class TracingConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "mode": "Mode",
    }

    mode: Optional[Union[str, TracingMode, Ref, GetAtt, Sub]] = None


@dataclass
class VpcConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "ipv6_allowed_for_dual_stack": "Ipv6AllowedForDualStack",
        "security_group_ids": "SecurityGroupIds",
        "subnet_ids": "SubnetIds",
    }

    ipv6_allowed_for_dual_stack: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    security_group_ids: Optional[Union[list[str], Ref]] = None
    subnet_ids: Optional[Union[list[str], Ref]] = None


@dataclass
class Function(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::Function"
    _property_mappings: ClassVar[dict[str, str]] = {
        "function_scaling_config": "FunctionScalingConfig",
        "description": "Description",
        "tracing_config": "TracingConfig",
        "vpc_config": "VpcConfig",
        "runtime_management_config": "RuntimeManagementConfig",
        "durable_config": "DurableConfig",
        "reserved_concurrent_executions": "ReservedConcurrentExecutions",
        "snap_start": "SnapStart",
        "file_system_configs": "FileSystemConfigs",
        "function_name": "FunctionName",
        "runtime": "Runtime",
        "kms_key_arn": "KmsKeyArn",
        "publish_to_latest_published": "PublishToLatestPublished",
        "package_type": "PackageType",
        "code_signing_config_arn": "CodeSigningConfigArn",
        "layers": "Layers",
        "tenancy_config": "TenancyConfig",
        "tags": "Tags",
        "image_config": "ImageConfig",
        "memory_size": "MemorySize",
        "dead_letter_config": "DeadLetterConfig",
        "timeout": "Timeout",
        "capacity_provider_config": "CapacityProviderConfig",
        "handler": "Handler",
        "code": "Code",
        "role": "Role",
        "logging_config": "LoggingConfig",
        "recursive_loop": "RecursiveLoop",
        "environment": "Environment",
        "ephemeral_storage": "EphemeralStorage",
        "architectures": "Architectures",
    }

    function_scaling_config: Optional[FunctionScalingConfig] = None
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    tracing_config: Optional[TracingConfig] = None
    vpc_config: Optional[VpcConfig] = None
    runtime_management_config: Optional[RuntimeManagementConfig] = None
    durable_config: Optional[DurableConfig] = None
    reserved_concurrent_executions: Optional[Union[int, Ref, GetAtt, Sub]] = None
    snap_start: Optional[SnapStart] = None
    file_system_configs: Optional[list[FileSystemConfig]] = None
    function_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    runtime: Optional[Union[str, Ref, GetAtt, Sub]] = None
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    publish_to_latest_published: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    package_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    code_signing_config_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    layers: Optional[Union[list[str], Ref]] = None
    tenancy_config: Optional[TenancyConfig] = None
    tags: Optional[list[Tag]] = None
    image_config: Optional[ImageConfig] = None
    memory_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    dead_letter_config: Optional[DeadLetterConfig] = None
    timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    capacity_provider_config: Optional[CapacityProviderConfig] = None
    handler: Optional[Union[str, Ref, GetAtt, Sub]] = None
    code: Optional[Code] = None
    role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    logging_config: Optional[LoggingConfig] = None
    recursive_loop: Optional[Union[str, Ref, GetAtt, Sub]] = None
    environment: Optional[Environment] = None
    ephemeral_storage: Optional[EphemeralStorage] = None
    architectures: Optional[Union[list[str], Ref]] = None

    @property
    def attr_snap_start_response__optimization_status(self) -> GetAtt:
        """Get the SnapStartResponse.OptimizationStatus attribute."""
        return self.get_att("SnapStartResponse.OptimizationStatus")

    @property
    def attr_snap_start_response__apply_on(self) -> GetAtt:
        """Get the SnapStartResponse.ApplyOn attribute."""
        return self.get_att("SnapStartResponse.ApplyOn")

    @property
    def attr_snap_start_response(self) -> GetAtt:
        """Get the SnapStartResponse attribute."""
        return self.get_att("SnapStartResponse")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class Content(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "s3_object_version": "S3ObjectVersion",
        "s3_bucket": "S3Bucket",
        "s3_key": "S3Key",
    }

    s3_object_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    s3_bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    s3_key: Optional[Union[str, Ref, GetAtt, Sub]] = None


@dataclass
class LayerVersion(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::LayerVersion"
    _property_mappings: ClassVar[dict[str, str]] = {
        "compatible_runtimes": "CompatibleRuntimes",
        "license_info": "LicenseInfo",
        "description": "Description",
        "layer_name": "LayerName",
        "content": "Content",
        "compatible_architectures": "CompatibleArchitectures",
    }

    compatible_runtimes: Optional[Union[list[str], Ref]] = None
    license_info: Optional[Union[str, Ref, GetAtt, Sub]] = None
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    layer_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    content: Optional[Content] = None
    compatible_architectures: Optional[Union[list[str], Ref]] = None

    @property
    def attr_layer_version_arn(self) -> GetAtt:
        """Get the LayerVersionArn attribute."""
        return self.get_att("LayerVersionArn")




@dataclass
class LayerVersionPermission(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::LayerVersionPermission"
    _property_mappings: ClassVar[dict[str, str]] = {
        "action": "Action",
        "layer_version_arn": "LayerVersionArn",
        "organization_id": "OrganizationId",
        "principal": "Principal",
    }

    action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    layer_version_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    organization_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    principal: Optional[Union[str, Ref, GetAtt, Sub]] = None

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class Permission(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::Permission"
    _property_mappings: ClassVar[dict[str, str]] = {
        "function_name": "FunctionName",
        "action": "Action",
        "invoked_via_function_url": "InvokedViaFunctionUrl",
        "event_source_token": "EventSourceToken",
        "function_url_auth_type": "FunctionUrlAuthType",
        "source_arn": "SourceArn",
        "source_account": "SourceAccount",
        "principal_org_id": "PrincipalOrgID",
        "principal": "Principal",
    }

    function_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    invoked_via_function_url: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    event_source_token: Optional[Union[str, Ref, GetAtt, Sub]] = None
    function_url_auth_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    source_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    source_account: Optional[Union[str, Ref, GetAtt, Sub]] = None
    principal_org_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    principal: Optional[Union[str, Ref, GetAtt, Sub]] = None

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class Cors(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "allow_credentials": "AllowCredentials",
        "allow_origins": "AllowOrigins",
        "expose_headers": "ExposeHeaders",
        "allow_headers": "AllowHeaders",
        "max_age": "MaxAge",
        "allow_methods": "AllowMethods",
    }

    allow_credentials: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    allow_origins: Optional[Union[list[str], Ref]] = None
    expose_headers: Optional[Union[list[str], Ref]] = None
    allow_headers: Optional[Union[list[str], Ref]] = None
    max_age: Optional[Union[int, Ref, GetAtt, Sub]] = None
    allow_methods: Optional[Union[list[str], Ref]] = None


@dataclass
class Url(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::Url"
    _property_mappings: ClassVar[dict[str, str]] = {
        "qualifier": "Qualifier",
        "invoke_mode": "InvokeMode",
        "auth_type": "AuthType",
        "target_function_arn": "TargetFunctionArn",
        "cors": "Cors",
    }

    qualifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    invoke_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    auth_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    target_function_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    cors: Optional[Cors] = None

    @property
    def attr_function_arn(self) -> GetAtt:
        """Get the FunctionArn attribute."""
        return self.get_att("FunctionArn")

    @property
    def attr_function_url(self) -> GetAtt:
        """Get the FunctionUrl attribute."""
        return self.get_att("FunctionUrl")




@dataclass
class FunctionScalingConfig(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "min_execution_environments": "MinExecutionEnvironments",
        "max_execution_environments": "MaxExecutionEnvironments",
    }

    min_execution_environments: Optional[Union[int, Ref, GetAtt, Sub]] = None
    max_execution_environments: Optional[Union[int, Ref, GetAtt, Sub]] = None


@dataclass
class ProvisionedConcurrencyConfiguration(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "provisioned_concurrent_executions": "ProvisionedConcurrentExecutions",
    }

    provisioned_concurrent_executions: Optional[Union[int, Ref, GetAtt, Sub]] = None


@dataclass
class RuntimePolicy(PropertyType):
    _property_mappings: ClassVar[dict[str, str]] = {
        "update_runtime_on": "UpdateRuntimeOn",
        "runtime_version_arn": "RuntimeVersionArn",
    }

    update_runtime_on: Optional[Union[str, Ref, GetAtt, Sub]] = None
    runtime_version_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None


@dataclass
class Version(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::Version"
    _property_mappings: ClassVar[dict[str, str]] = {
        "function_scaling_config": "FunctionScalingConfig",
        "function_name": "FunctionName",
        "provisioned_concurrency_config": "ProvisionedConcurrencyConfig",
        "description": "Description",
        "runtime_policy": "RuntimePolicy",
        "code_sha256": "CodeSha256",
    }

    function_scaling_config: Optional[FunctionScalingConfig] = None
    function_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    provisioned_concurrency_config: Optional[ProvisionedConcurrencyConfiguration] = None
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    runtime_policy: Optional[RuntimePolicy] = None
    code_sha256: Optional[Union[str, Ref, GetAtt, Sub]] = None

    @property
    def attr_function_arn(self) -> GetAtt:
        """Get the FunctionArn attribute."""
        return self.get_att("FunctionArn")

    @property
    def attr_version(self) -> GetAtt:
        """Get the Version attribute."""
        return self.get_att("Version")



