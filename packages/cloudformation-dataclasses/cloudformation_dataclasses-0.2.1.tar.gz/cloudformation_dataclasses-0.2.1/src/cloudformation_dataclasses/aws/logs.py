"""
AWS CloudFormation Logs Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 227.0.0
  Generator Version: 1.0.0
  Combined: spec-227.0.0_gen-1.0.0
  Generated: 2025-12-15 17:57:27

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service Logs
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


@dataclass
class AccountPolicy(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-"""

    resource_type: ClassVar[str] = "AWS::Logs::AccountPolicy"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    scope: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    selection_criteria: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_document: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.policy_type is not None:
            # Serialize policy_type (handle intrinsic functions)
            if hasattr(self.policy_type, 'to_dict'):
                props["PolicyType"] = self.policy_type.to_dict()
            elif isinstance(self.policy_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_type
                ]
            else:
                props["PolicyType"] = self.policy_type

        if self.scope is not None:
            # Serialize scope (handle intrinsic functions)
            if hasattr(self.scope, 'to_dict'):
                props["Scope"] = self.scope.to_dict()
            elif isinstance(self.scope, list):
                # Serialize list items (may contain intrinsic functions)
                props['Scope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scope
                ]
            else:
                props["Scope"] = self.scope

        if self.policy_name is not None:
            # Serialize policy_name (handle intrinsic functions)
            if hasattr(self.policy_name, 'to_dict'):
                props["PolicyName"] = self.policy_name.to_dict()
            elif isinstance(self.policy_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_name
                ]
            else:
                props["PolicyName"] = self.policy_name

        if self.selection_criteria is not None:
            # Serialize selection_criteria (handle intrinsic functions)
            if hasattr(self.selection_criteria, 'to_dict'):
                props["SelectionCriteria"] = self.selection_criteria.to_dict()
            elif isinstance(self.selection_criteria, list):
                # Serialize list items (may contain intrinsic functions)
                props['SelectionCriteria'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.selection_criteria
                ]
            else:
                props["SelectionCriteria"] = self.selection_criteria

        if self.policy_document is not None:
            # Serialize policy_document (handle intrinsic functions)
            if hasattr(self.policy_document, 'to_dict'):
                props["PolicyDocument"] = self.policy_document.to_dict()
            elif isinstance(self.policy_document, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyDocument'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_document
                ]
            else:
                props["PolicyDocument"] = self.policy_document

        return props

    @property
    def attr_account_id(self) -> GetAtt:
        """Get the AccountId attribute."""
        return self.get_att("AccountId")




@dataclass
class Delivery(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-"""

    resource_type: ClassVar[str] = "AWS::Logs::Delivery"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    s3_enable_hive_compatible_path: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    field_delimiter: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delivery_destination_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delivery_source_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    record_fields: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    s3_suffix_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_enable_hive_compatible_path is not None:
            # Serialize s3_enable_hive_compatible_path (handle intrinsic functions)
            if hasattr(self.s3_enable_hive_compatible_path, 'to_dict'):
                props["S3EnableHiveCompatiblePath"] = self.s3_enable_hive_compatible_path.to_dict()
            elif isinstance(self.s3_enable_hive_compatible_path, list):
                # Serialize list items (may contain intrinsic functions)
                props['S3EnableHiveCompatiblePath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_enable_hive_compatible_path
                ]
            else:
                props["S3EnableHiveCompatiblePath"] = self.s3_enable_hive_compatible_path

        if self.field_delimiter is not None:
            # Serialize field_delimiter (handle intrinsic functions)
            if hasattr(self.field_delimiter, 'to_dict'):
                props["FieldDelimiter"] = self.field_delimiter.to_dict()
            elif isinstance(self.field_delimiter, list):
                # Serialize list items (may contain intrinsic functions)
                props['FieldDelimiter'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.field_delimiter
                ]
            else:
                props["FieldDelimiter"] = self.field_delimiter

        if self.delivery_destination_arn is not None:
            # Serialize delivery_destination_arn (handle intrinsic functions)
            if hasattr(self.delivery_destination_arn, 'to_dict'):
                props["DeliveryDestinationArn"] = self.delivery_destination_arn.to_dict()
            elif isinstance(self.delivery_destination_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeliveryDestinationArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delivery_destination_arn
                ]
            else:
                props["DeliveryDestinationArn"] = self.delivery_destination_arn

        if self.delivery_source_name is not None:
            # Serialize delivery_source_name (handle intrinsic functions)
            if hasattr(self.delivery_source_name, 'to_dict'):
                props["DeliverySourceName"] = self.delivery_source_name.to_dict()
            elif isinstance(self.delivery_source_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeliverySourceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delivery_source_name
                ]
            else:
                props["DeliverySourceName"] = self.delivery_source_name

        if self.record_fields is not None:
            # Serialize record_fields (handle intrinsic functions)
            if hasattr(self.record_fields, 'to_dict'):
                props["RecordFields"] = self.record_fields.to_dict()
            elif isinstance(self.record_fields, list):
                # Serialize list items (may contain intrinsic functions)
                props['RecordFields'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.record_fields
                ]
            else:
                props["RecordFields"] = self.record_fields

        if self.s3_suffix_path is not None:
            # Serialize s3_suffix_path (handle intrinsic functions)
            if hasattr(self.s3_suffix_path, 'to_dict'):
                props["S3SuffixPath"] = self.s3_suffix_path.to_dict()
            elif isinstance(self.s3_suffix_path, list):
                # Serialize list items (may contain intrinsic functions)
                props['S3SuffixPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_suffix_path
                ]
            else:
                props["S3SuffixPath"] = self.s3_suffix_path

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_delivery_id(self) -> GetAtt:
        """Get the DeliveryId attribute."""
        return self.get_att("DeliveryId")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_delivery_destination_type(self) -> GetAtt:
        """Get the DeliveryDestinationType attribute."""
        return self.get_att("DeliveryDestinationType")




@dataclass
class DestinationPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delivery_destination_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delivery_destination_policy: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.delivery_destination_name is not None:
            if hasattr(self.delivery_destination_name, 'to_dict'):
                props['DeliveryDestinationName'] = self.delivery_destination_name.to_dict()
            elif isinstance(self.delivery_destination_name, list):
                props['DeliveryDestinationName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delivery_destination_name
                ]
            else:
                props['DeliveryDestinationName'] = self.delivery_destination_name

        if self.delivery_destination_policy is not None:
            if hasattr(self.delivery_destination_policy, 'to_dict'):
                props['DeliveryDestinationPolicy'] = self.delivery_destination_policy.to_dict()
            elif isinstance(self.delivery_destination_policy, list):
                props['DeliveryDestinationPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delivery_destination_policy
                ]
            else:
                props['DeliveryDestinationPolicy'] = self.delivery_destination_policy

        return props


@dataclass
class DeliveryDestination(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-"""

    resource_type: ClassVar[str] = "AWS::Logs::DeliveryDestination"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_resource_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    output_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delivery_destination_policy: Optional[DestinationPolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delivery_destination_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination_resource_arn is not None:
            # Serialize destination_resource_arn (handle intrinsic functions)
            if hasattr(self.destination_resource_arn, 'to_dict'):
                props["DestinationResourceArn"] = self.destination_resource_arn.to_dict()
            elif isinstance(self.destination_resource_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationResourceArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_resource_arn
                ]
            else:
                props["DestinationResourceArn"] = self.destination_resource_arn

        if self.output_format is not None:
            # Serialize output_format (handle intrinsic functions)
            if hasattr(self.output_format, 'to_dict'):
                props["OutputFormat"] = self.output_format.to_dict()
            elif isinstance(self.output_format, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutputFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_format
                ]
            else:
                props["OutputFormat"] = self.output_format

        if self.delivery_destination_policy is not None:
            # Serialize delivery_destination_policy (handle intrinsic functions)
            if hasattr(self.delivery_destination_policy, 'to_dict'):
                props["DeliveryDestinationPolicy"] = self.delivery_destination_policy.to_dict()
            elif isinstance(self.delivery_destination_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeliveryDestinationPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delivery_destination_policy
                ]
            else:
                props["DeliveryDestinationPolicy"] = self.delivery_destination_policy

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.delivery_destination_type is not None:
            # Serialize delivery_destination_type (handle intrinsic functions)
            if hasattr(self.delivery_destination_type, 'to_dict'):
                props["DeliveryDestinationType"] = self.delivery_destination_type.to_dict()
            elif isinstance(self.delivery_destination_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeliveryDestinationType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delivery_destination_type
                ]
            else:
                props["DeliveryDestinationType"] = self.delivery_destination_type

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class DeliverySource(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-"""

    resource_type: ClassVar[str] = "AWS::Logs::DeliverySource"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_arn is not None:
            # Serialize resource_arn (handle intrinsic functions)
            if hasattr(self.resource_arn, 'to_dict'):
                props["ResourceArn"] = self.resource_arn.to_dict()
            elif isinstance(self.resource_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_arn
                ]
            else:
                props["ResourceArn"] = self.resource_arn

        if self.log_type is not None:
            # Serialize log_type (handle intrinsic functions)
            if hasattr(self.log_type, 'to_dict'):
                props["LogType"] = self.log_type.to_dict()
            elif isinstance(self.log_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_type
                ]
            else:
                props["LogType"] = self.log_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_service(self) -> GetAtt:
        """Get the Service attribute."""
        return self.get_att("Service")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_resource_arns(self) -> GetAtt:
        """Get the ResourceArns attribute."""
        return self.get_att("ResourceArns")




@dataclass
class Destination(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-"""

    resource_type: ClassVar[str] = "AWS::Logs::Destination"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_policy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination_policy is not None:
            # Serialize destination_policy (handle intrinsic functions)
            if hasattr(self.destination_policy, 'to_dict'):
                props["DestinationPolicy"] = self.destination_policy.to_dict()
            elif isinstance(self.destination_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_policy
                ]
            else:
                props["DestinationPolicy"] = self.destination_policy

        if self.destination_name is not None:
            # Serialize destination_name (handle intrinsic functions)
            if hasattr(self.destination_name, 'to_dict'):
                props["DestinationName"] = self.destination_name.to_dict()
            elif isinstance(self.destination_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_name
                ]
            else:
                props["DestinationName"] = self.destination_name

        if self.target_arn is not None:
            # Serialize target_arn (handle intrinsic functions)
            if hasattr(self.target_arn, 'to_dict'):
                props["TargetArn"] = self.target_arn.to_dict()
            elif isinstance(self.target_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_arn
                ]
            else:
                props["TargetArn"] = self.target_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class OpenSearchResourceConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dashboard_viewer_principals: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    application_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    retention_days: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_source_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.dashboard_viewer_principals is not None:
            if hasattr(self.dashboard_viewer_principals, 'to_dict'):
                props['DashboardViewerPrincipals'] = self.dashboard_viewer_principals.to_dict()
            elif isinstance(self.dashboard_viewer_principals, list):
                props['DashboardViewerPrincipals'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dashboard_viewer_principals
                ]
            else:
                props['DashboardViewerPrincipals'] = self.dashboard_viewer_principals

        if self.application_arn is not None:
            if hasattr(self.application_arn, 'to_dict'):
                props['ApplicationARN'] = self.application_arn.to_dict()
            elif isinstance(self.application_arn, list):
                props['ApplicationARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.application_arn
                ]
            else:
                props['ApplicationARN'] = self.application_arn

        if self.kms_key_arn is not None:
            if hasattr(self.kms_key_arn, 'to_dict'):
                props['KmsKeyArn'] = self.kms_key_arn.to_dict()
            elif isinstance(self.kms_key_arn, list):
                props['KmsKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_arn
                ]
            else:
                props['KmsKeyArn'] = self.kms_key_arn

        if self.retention_days is not None:
            if hasattr(self.retention_days, 'to_dict'):
                props['RetentionDays'] = self.retention_days.to_dict()
            elif isinstance(self.retention_days, list):
                props['RetentionDays'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.retention_days
                ]
            else:
                props['RetentionDays'] = self.retention_days

        if self.data_source_role_arn is not None:
            if hasattr(self.data_source_role_arn, 'to_dict'):
                props['DataSourceRoleArn'] = self.data_source_role_arn.to_dict()
            elif isinstance(self.data_source_role_arn, list):
                props['DataSourceRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_source_role_arn
                ]
            else:
                props['DataSourceRoleArn'] = self.data_source_role_arn

        return props


@dataclass
class ResourceConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    open_search_resource_config: Optional[OpenSearchResourceConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.open_search_resource_config is not None:
            if hasattr(self.open_search_resource_config, 'to_dict'):
                props['OpenSearchResourceConfig'] = self.open_search_resource_config.to_dict()
            elif isinstance(self.open_search_resource_config, list):
                props['OpenSearchResourceConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.open_search_resource_config
                ]
            else:
                props['OpenSearchResourceConfig'] = self.open_search_resource_config

        return props


@dataclass
class Integration(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-"""

    resource_type: ClassVar[str] = "AWS::Logs::Integration"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    integration_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_config: Optional[ResourceConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    integration_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.integration_name is not None:
            # Serialize integration_name (handle intrinsic functions)
            if hasattr(self.integration_name, 'to_dict'):
                props["IntegrationName"] = self.integration_name.to_dict()
            elif isinstance(self.integration_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['IntegrationName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.integration_name
                ]
            else:
                props["IntegrationName"] = self.integration_name

        if self.resource_config is not None:
            # Serialize resource_config (handle intrinsic functions)
            if hasattr(self.resource_config, 'to_dict'):
                props["ResourceConfig"] = self.resource_config.to_dict()
            elif isinstance(self.resource_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_config
                ]
            else:
                props["ResourceConfig"] = self.resource_config

        if self.integration_type is not None:
            # Serialize integration_type (handle intrinsic functions)
            if hasattr(self.integration_type, 'to_dict'):
                props["IntegrationType"] = self.integration_type.to_dict()
            elif isinstance(self.integration_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['IntegrationType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.integration_type
                ]
            else:
                props["IntegrationType"] = self.integration_type

        return props

    @property
    def attr_integration_status(self) -> GetAtt:
        """Get the IntegrationStatus attribute."""
        return self.get_att("IntegrationStatus")




@dataclass
class LogAnomalyDetector(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-"""

    resource_type: ClassVar[str] = "AWS::Logs::LogAnomalyDetector"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    anomaly_visibility_time: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    filter_pattern: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    account_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_group_arn_list: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    evaluation_frequency: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    detector_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.anomaly_visibility_time is not None:
            # Serialize anomaly_visibility_time (handle intrinsic functions)
            if hasattr(self.anomaly_visibility_time, 'to_dict'):
                props["AnomalyVisibilityTime"] = self.anomaly_visibility_time.to_dict()
            elif isinstance(self.anomaly_visibility_time, list):
                # Serialize list items (may contain intrinsic functions)
                props['AnomalyVisibilityTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.anomaly_visibility_time
                ]
            else:
                props["AnomalyVisibilityTime"] = self.anomaly_visibility_time

        if self.filter_pattern is not None:
            # Serialize filter_pattern (handle intrinsic functions)
            if hasattr(self.filter_pattern, 'to_dict'):
                props["FilterPattern"] = self.filter_pattern.to_dict()
            elif isinstance(self.filter_pattern, list):
                # Serialize list items (may contain intrinsic functions)
                props['FilterPattern'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter_pattern
                ]
            else:
                props["FilterPattern"] = self.filter_pattern

        if self.account_id is not None:
            # Serialize account_id (handle intrinsic functions)
            if hasattr(self.account_id, 'to_dict'):
                props["AccountId"] = self.account_id.to_dict()
            elif isinstance(self.account_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AccountId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.account_id
                ]
            else:
                props["AccountId"] = self.account_id

        if self.kms_key_id is not None:
            # Serialize kms_key_id (handle intrinsic functions)
            if hasattr(self.kms_key_id, 'to_dict'):
                props["KmsKeyId"] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props["KmsKeyId"] = self.kms_key_id

        if self.log_group_arn_list is not None:
            # Serialize log_group_arn_list (handle intrinsic functions)
            if hasattr(self.log_group_arn_list, 'to_dict'):
                props["LogGroupArnList"] = self.log_group_arn_list.to_dict()
            elif isinstance(self.log_group_arn_list, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogGroupArnList'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_arn_list
                ]
            else:
                props["LogGroupArnList"] = self.log_group_arn_list

        if self.evaluation_frequency is not None:
            # Serialize evaluation_frequency (handle intrinsic functions)
            if hasattr(self.evaluation_frequency, 'to_dict'):
                props["EvaluationFrequency"] = self.evaluation_frequency.to_dict()
            elif isinstance(self.evaluation_frequency, list):
                # Serialize list items (may contain intrinsic functions)
                props['EvaluationFrequency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.evaluation_frequency
                ]
            else:
                props["EvaluationFrequency"] = self.evaluation_frequency

        if self.detector_name is not None:
            # Serialize detector_name (handle intrinsic functions)
            if hasattr(self.detector_name, 'to_dict'):
                props["DetectorName"] = self.detector_name.to_dict()
            elif isinstance(self.detector_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DetectorName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.detector_name
                ]
            else:
                props["DetectorName"] = self.detector_name

        return props

    @property
    def attr_creation_time_stamp(self) -> GetAtt:
        """Get the CreationTimeStamp attribute."""
        return self.get_att("CreationTimeStamp")

    @property
    def attr_anomaly_detector_status(self) -> GetAtt:
        """Get the AnomalyDetectorStatus attribute."""
        return self.get_att("AnomalyDetectorStatus")

    @property
    def attr_anomaly_detector_arn(self) -> GetAtt:
        """Get the AnomalyDetectorArn attribute."""
        return self.get_att("AnomalyDetectorArn")

    @property
    def attr_last_modified_time_stamp(self) -> GetAtt:
        """Get the LastModifiedTimeStamp attribute."""
        return self.get_att("LastModifiedTimeStamp")




@dataclass
class LogGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-"""

    resource_type: ClassVar[str] = "AWS::Logs::LogGroup"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    field_index_policies: Optional[Union[list[dict[str, Any]], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    retention_in_days: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_group_class: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_policy_document: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_protection_policy: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.field_index_policies is not None:
            # Serialize field_index_policies (handle intrinsic functions)
            if hasattr(self.field_index_policies, 'to_dict'):
                props["FieldIndexPolicies"] = self.field_index_policies.to_dict()
            elif isinstance(self.field_index_policies, list):
                # Serialize list items (may contain intrinsic functions)
                props['FieldIndexPolicies'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.field_index_policies
                ]
            else:
                props["FieldIndexPolicies"] = self.field_index_policies

        if self.retention_in_days is not None:
            # Serialize retention_in_days (handle intrinsic functions)
            if hasattr(self.retention_in_days, 'to_dict'):
                props["RetentionInDays"] = self.retention_in_days.to_dict()
            elif isinstance(self.retention_in_days, list):
                # Serialize list items (may contain intrinsic functions)
                props['RetentionInDays'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.retention_in_days
                ]
            else:
                props["RetentionInDays"] = self.retention_in_days

        if self.kms_key_id is not None:
            # Serialize kms_key_id (handle intrinsic functions)
            if hasattr(self.kms_key_id, 'to_dict'):
                props["KmsKeyId"] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props["KmsKeyId"] = self.kms_key_id

        if self.log_group_class is not None:
            # Serialize log_group_class (handle intrinsic functions)
            if hasattr(self.log_group_class, 'to_dict'):
                props["LogGroupClass"] = self.log_group_class.to_dict()
            elif isinstance(self.log_group_class, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogGroupClass'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_class
                ]
            else:
                props["LogGroupClass"] = self.log_group_class

        if self.resource_policy_document is not None:
            # Serialize resource_policy_document (handle intrinsic functions)
            if hasattr(self.resource_policy_document, 'to_dict'):
                props["ResourcePolicyDocument"] = self.resource_policy_document.to_dict()
            elif isinstance(self.resource_policy_document, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourcePolicyDocument'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_policy_document
                ]
            else:
                props["ResourcePolicyDocument"] = self.resource_policy_document

        if self.log_group_name is not None:
            # Serialize log_group_name (handle intrinsic functions)
            if hasattr(self.log_group_name, 'to_dict'):
                props["LogGroupName"] = self.log_group_name.to_dict()
            elif isinstance(self.log_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_name
                ]
            else:
                props["LogGroupName"] = self.log_group_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.data_protection_policy is not None:
            # Serialize data_protection_policy (handle intrinsic functions)
            if hasattr(self.data_protection_policy, 'to_dict'):
                props["DataProtectionPolicy"] = self.data_protection_policy.to_dict()
            elif isinstance(self.data_protection_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataProtectionPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_protection_policy
                ]
            else:
                props["DataProtectionPolicy"] = self.data_protection_policy

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class LogStream(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-"""

    resource_type: ClassVar[str] = "AWS::Logs::LogStream"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_stream_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.log_stream_name is not None:
            # Serialize log_stream_name (handle intrinsic functions)
            if hasattr(self.log_stream_name, 'to_dict'):
                props["LogStreamName"] = self.log_stream_name.to_dict()
            elif isinstance(self.log_stream_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogStreamName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_stream_name
                ]
            else:
                props["LogStreamName"] = self.log_stream_name

        if self.log_group_name is not None:
            # Serialize log_group_name (handle intrinsic functions)
            if hasattr(self.log_group_name, 'to_dict'):
                props["LogGroupName"] = self.log_group_name.to_dict()
            elif isinstance(self.log_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_name
                ]
            else:
                props["LogGroupName"] = self.log_group_name

        return props



@dataclass
class Dimension:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class MetricTransformation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_value: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_namespace: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dimensions: Optional[list[Dimension]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_value is not None:
            if hasattr(self.default_value, 'to_dict'):
                props['DefaultValue'] = self.default_value.to_dict()
            elif isinstance(self.default_value, list):
                props['DefaultValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_value
                ]
            else:
                props['DefaultValue'] = self.default_value

        if self.metric_name is not None:
            if hasattr(self.metric_name, 'to_dict'):
                props['MetricName'] = self.metric_name.to_dict()
            elif isinstance(self.metric_name, list):
                props['MetricName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_name
                ]
            else:
                props['MetricName'] = self.metric_name

        if self.metric_value is not None:
            if hasattr(self.metric_value, 'to_dict'):
                props['MetricValue'] = self.metric_value.to_dict()
            elif isinstance(self.metric_value, list):
                props['MetricValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_value
                ]
            else:
                props['MetricValue'] = self.metric_value

        if self.metric_namespace is not None:
            if hasattr(self.metric_namespace, 'to_dict'):
                props['MetricNamespace'] = self.metric_namespace.to_dict()
            elif isinstance(self.metric_namespace, list):
                props['MetricNamespace'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_namespace
                ]
            else:
                props['MetricNamespace'] = self.metric_namespace

        if self.dimensions is not None:
            if hasattr(self.dimensions, 'to_dict'):
                props['Dimensions'] = self.dimensions.to_dict()
            elif isinstance(self.dimensions, list):
                props['Dimensions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dimensions
                ]
            else:
                props['Dimensions'] = self.dimensions

        if self.unit is not None:
            if hasattr(self.unit, 'to_dict'):
                props['Unit'] = self.unit.to_dict()
            elif isinstance(self.unit, list):
                props['Unit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unit
                ]
            else:
                props['Unit'] = self.unit

        return props


@dataclass
class MetricFilter(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-"""

    resource_type: ClassVar[str] = "AWS::Logs::MetricFilter"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    field_selection_criteria: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metric_transformations: Optional[list[MetricTransformation]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    filter_pattern: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    emit_system_field_dimensions: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    apply_on_transformed_logs: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    filter_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.field_selection_criteria is not None:
            # Serialize field_selection_criteria (handle intrinsic functions)
            if hasattr(self.field_selection_criteria, 'to_dict'):
                props["FieldSelectionCriteria"] = self.field_selection_criteria.to_dict()
            elif isinstance(self.field_selection_criteria, list):
                # Serialize list items (may contain intrinsic functions)
                props['FieldSelectionCriteria'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.field_selection_criteria
                ]
            else:
                props["FieldSelectionCriteria"] = self.field_selection_criteria

        if self.metric_transformations is not None:
            # Serialize metric_transformations (handle intrinsic functions)
            if hasattr(self.metric_transformations, 'to_dict'):
                props["MetricTransformations"] = self.metric_transformations.to_dict()
            elif isinstance(self.metric_transformations, list):
                # Serialize list items (may contain intrinsic functions)
                props['MetricTransformations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_transformations
                ]
            else:
                props["MetricTransformations"] = self.metric_transformations

        if self.filter_pattern is not None:
            # Serialize filter_pattern (handle intrinsic functions)
            if hasattr(self.filter_pattern, 'to_dict'):
                props["FilterPattern"] = self.filter_pattern.to_dict()
            elif isinstance(self.filter_pattern, list):
                # Serialize list items (may contain intrinsic functions)
                props['FilterPattern'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter_pattern
                ]
            else:
                props["FilterPattern"] = self.filter_pattern

        if self.emit_system_field_dimensions is not None:
            # Serialize emit_system_field_dimensions (handle intrinsic functions)
            if hasattr(self.emit_system_field_dimensions, 'to_dict'):
                props["EmitSystemFieldDimensions"] = self.emit_system_field_dimensions.to_dict()
            elif isinstance(self.emit_system_field_dimensions, list):
                # Serialize list items (may contain intrinsic functions)
                props['EmitSystemFieldDimensions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.emit_system_field_dimensions
                ]
            else:
                props["EmitSystemFieldDimensions"] = self.emit_system_field_dimensions

        if self.log_group_name is not None:
            # Serialize log_group_name (handle intrinsic functions)
            if hasattr(self.log_group_name, 'to_dict'):
                props["LogGroupName"] = self.log_group_name.to_dict()
            elif isinstance(self.log_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_name
                ]
            else:
                props["LogGroupName"] = self.log_group_name

        if self.apply_on_transformed_logs is not None:
            # Serialize apply_on_transformed_logs (handle intrinsic functions)
            if hasattr(self.apply_on_transformed_logs, 'to_dict'):
                props["ApplyOnTransformedLogs"] = self.apply_on_transformed_logs.to_dict()
            elif isinstance(self.apply_on_transformed_logs, list):
                # Serialize list items (may contain intrinsic functions)
                props['ApplyOnTransformedLogs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.apply_on_transformed_logs
                ]
            else:
                props["ApplyOnTransformedLogs"] = self.apply_on_transformed_logs

        if self.filter_name is not None:
            # Serialize filter_name (handle intrinsic functions)
            if hasattr(self.filter_name, 'to_dict'):
                props["FilterName"] = self.filter_name.to_dict()
            elif isinstance(self.filter_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['FilterName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter_name
                ]
            else:
                props["FilterName"] = self.filter_name

        return props



@dataclass
class QueryDefinition(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-"""

    resource_type: ClassVar[str] = "AWS::Logs::QueryDefinition"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    query_string: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_group_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    query_language: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.query_string is not None:
            # Serialize query_string (handle intrinsic functions)
            if hasattr(self.query_string, 'to_dict'):
                props["QueryString"] = self.query_string.to_dict()
            elif isinstance(self.query_string, list):
                # Serialize list items (may contain intrinsic functions)
                props['QueryString'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.query_string
                ]
            else:
                props["QueryString"] = self.query_string

        if self.log_group_names is not None:
            # Serialize log_group_names (handle intrinsic functions)
            if hasattr(self.log_group_names, 'to_dict'):
                props["LogGroupNames"] = self.log_group_names.to_dict()
            elif isinstance(self.log_group_names, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogGroupNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_names
                ]
            else:
                props["LogGroupNames"] = self.log_group_names

        if self.query_language is not None:
            # Serialize query_language (handle intrinsic functions)
            if hasattr(self.query_language, 'to_dict'):
                props["QueryLanguage"] = self.query_language.to_dict()
            elif isinstance(self.query_language, list):
                # Serialize list items (may contain intrinsic functions)
                props['QueryLanguage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.query_language
                ]
            else:
                props["QueryLanguage"] = self.query_language

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_query_definition_id(self) -> GetAtt:
        """Get the QueryDefinitionId attribute."""
        return self.get_att("QueryDefinitionId")




@dataclass
class ResourcePolicy(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-"""

    resource_type: ClassVar[str] = "AWS::Logs::ResourcePolicy"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_document: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.policy_name is not None:
            # Serialize policy_name (handle intrinsic functions)
            if hasattr(self.policy_name, 'to_dict'):
                props["PolicyName"] = self.policy_name.to_dict()
            elif isinstance(self.policy_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_name
                ]
            else:
                props["PolicyName"] = self.policy_name

        if self.policy_document is not None:
            # Serialize policy_document (handle intrinsic functions)
            if hasattr(self.policy_document, 'to_dict'):
                props["PolicyDocument"] = self.policy_document.to_dict()
            elif isinstance(self.policy_document, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyDocument'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_document
                ]
            else:
                props["PolicyDocument"] = self.policy_document

        return props



@dataclass
class SubscriptionFilter(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-"""

    resource_type: ClassVar[str] = "AWS::Logs::SubscriptionFilter"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    field_selection_criteria: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    filter_pattern: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    emit_system_fields: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    distribution: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    apply_on_transformed_logs: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    filter_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.field_selection_criteria is not None:
            # Serialize field_selection_criteria (handle intrinsic functions)
            if hasattr(self.field_selection_criteria, 'to_dict'):
                props["FieldSelectionCriteria"] = self.field_selection_criteria.to_dict()
            elif isinstance(self.field_selection_criteria, list):
                # Serialize list items (may contain intrinsic functions)
                props['FieldSelectionCriteria'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.field_selection_criteria
                ]
            else:
                props["FieldSelectionCriteria"] = self.field_selection_criteria

        if self.filter_pattern is not None:
            # Serialize filter_pattern (handle intrinsic functions)
            if hasattr(self.filter_pattern, 'to_dict'):
                props["FilterPattern"] = self.filter_pattern.to_dict()
            elif isinstance(self.filter_pattern, list):
                # Serialize list items (may contain intrinsic functions)
                props['FilterPattern'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter_pattern
                ]
            else:
                props["FilterPattern"] = self.filter_pattern

        if self.emit_system_fields is not None:
            # Serialize emit_system_fields (handle intrinsic functions)
            if hasattr(self.emit_system_fields, 'to_dict'):
                props["EmitSystemFields"] = self.emit_system_fields.to_dict()
            elif isinstance(self.emit_system_fields, list):
                # Serialize list items (may contain intrinsic functions)
                props['EmitSystemFields'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.emit_system_fields
                ]
            else:
                props["EmitSystemFields"] = self.emit_system_fields

        if self.distribution is not None:
            # Serialize distribution (handle intrinsic functions)
            if hasattr(self.distribution, 'to_dict'):
                props["Distribution"] = self.distribution.to_dict()
            elif isinstance(self.distribution, list):
                # Serialize list items (may contain intrinsic functions)
                props['Distribution'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.distribution
                ]
            else:
                props["Distribution"] = self.distribution

        if self.log_group_name is not None:
            # Serialize log_group_name (handle intrinsic functions)
            if hasattr(self.log_group_name, 'to_dict'):
                props["LogGroupName"] = self.log_group_name.to_dict()
            elif isinstance(self.log_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_name
                ]
            else:
                props["LogGroupName"] = self.log_group_name

        if self.apply_on_transformed_logs is not None:
            # Serialize apply_on_transformed_logs (handle intrinsic functions)
            if hasattr(self.apply_on_transformed_logs, 'to_dict'):
                props["ApplyOnTransformedLogs"] = self.apply_on_transformed_logs.to_dict()
            elif isinstance(self.apply_on_transformed_logs, list):
                # Serialize list items (may contain intrinsic functions)
                props['ApplyOnTransformedLogs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.apply_on_transformed_logs
                ]
            else:
                props["ApplyOnTransformedLogs"] = self.apply_on_transformed_logs

        if self.filter_name is not None:
            # Serialize filter_name (handle intrinsic functions)
            if hasattr(self.filter_name, 'to_dict'):
                props["FilterName"] = self.filter_name.to_dict()
            elif isinstance(self.filter_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['FilterName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter_name
                ]
            else:
                props["FilterName"] = self.filter_name

        if self.destination_arn is not None:
            # Serialize destination_arn (handle intrinsic functions)
            if hasattr(self.destination_arn, 'to_dict'):
                props["DestinationArn"] = self.destination_arn.to_dict()
            elif isinstance(self.destination_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_arn
                ]
            else:
                props["DestinationArn"] = self.destination_arn

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        return props



@dataclass
class AddKeyEntry:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    overwrite_if_exists: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.overwrite_if_exists is not None:
            if hasattr(self.overwrite_if_exists, 'to_dict'):
                props['OverwriteIfExists'] = self.overwrite_if_exists.to_dict()
            elif isinstance(self.overwrite_if_exists, list):
                props['OverwriteIfExists'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.overwrite_if_exists
                ]
            else:
                props['OverwriteIfExists'] = self.overwrite_if_exists

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class AddKeys:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    entries: Optional[list[AddKeyEntry]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.entries is not None:
            if hasattr(self.entries, 'to_dict'):
                props['Entries'] = self.entries.to_dict()
            elif isinstance(self.entries, list):
                props['Entries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.entries
                ]
            else:
                props['Entries'] = self.entries

        return props


@dataclass
class CopyValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    entries: Optional[list[CopyValueEntry]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.entries is not None:
            if hasattr(self.entries, 'to_dict'):
                props['Entries'] = self.entries.to_dict()
            elif isinstance(self.entries, list):
                props['Entries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.entries
                ]
            else:
                props['Entries'] = self.entries

        return props


@dataclass
class CopyValueEntry:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    overwrite_if_exists: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.target is not None:
            if hasattr(self.target, 'to_dict'):
                props['Target'] = self.target.to_dict()
            elif isinstance(self.target, list):
                props['Target'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target
                ]
            else:
                props['Target'] = self.target

        if self.overwrite_if_exists is not None:
            if hasattr(self.overwrite_if_exists, 'to_dict'):
                props['OverwriteIfExists'] = self.overwrite_if_exists.to_dict()
            elif isinstance(self.overwrite_if_exists, list):
                props['OverwriteIfExists'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.overwrite_if_exists
                ]
            else:
                props['OverwriteIfExists'] = self.overwrite_if_exists

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        return props


@dataclass
class Csv:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    quote_character: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delimiter: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    columns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.quote_character is not None:
            if hasattr(self.quote_character, 'to_dict'):
                props['QuoteCharacter'] = self.quote_character.to_dict()
            elif isinstance(self.quote_character, list):
                props['QuoteCharacter'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.quote_character
                ]
            else:
                props['QuoteCharacter'] = self.quote_character

        if self.delimiter is not None:
            if hasattr(self.delimiter, 'to_dict'):
                props['Delimiter'] = self.delimiter.to_dict()
            elif isinstance(self.delimiter, list):
                props['Delimiter'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delimiter
                ]
            else:
                props['Delimiter'] = self.delimiter

        if self.columns is not None:
            if hasattr(self.columns, 'to_dict'):
                props['Columns'] = self.columns.to_dict()
            elif isinstance(self.columns, list):
                props['Columns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.columns
                ]
            else:
                props['Columns'] = self.columns

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        return props


@dataclass
class DateTimeConverter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    locale: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    match_patterns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_timezone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_timezone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.locale is not None:
            if hasattr(self.locale, 'to_dict'):
                props['Locale'] = self.locale.to_dict()
            elif isinstance(self.locale, list):
                props['Locale'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.locale
                ]
            else:
                props['Locale'] = self.locale

        if self.target is not None:
            if hasattr(self.target, 'to_dict'):
                props['Target'] = self.target.to_dict()
            elif isinstance(self.target, list):
                props['Target'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target
                ]
            else:
                props['Target'] = self.target

        if self.match_patterns is not None:
            if hasattr(self.match_patterns, 'to_dict'):
                props['MatchPatterns'] = self.match_patterns.to_dict()
            elif isinstance(self.match_patterns, list):
                props['MatchPatterns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.match_patterns
                ]
            else:
                props['MatchPatterns'] = self.match_patterns

        if self.source_timezone is not None:
            if hasattr(self.source_timezone, 'to_dict'):
                props['SourceTimezone'] = self.source_timezone.to_dict()
            elif isinstance(self.source_timezone, list):
                props['SourceTimezone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_timezone
                ]
            else:
                props['SourceTimezone'] = self.source_timezone

        if self.target_format is not None:
            if hasattr(self.target_format, 'to_dict'):
                props['TargetFormat'] = self.target_format.to_dict()
            elif isinstance(self.target_format, list):
                props['TargetFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_format
                ]
            else:
                props['TargetFormat'] = self.target_format

        if self.target_timezone is not None:
            if hasattr(self.target_timezone, 'to_dict'):
                props['TargetTimezone'] = self.target_timezone.to_dict()
            elif isinstance(self.target_timezone, list):
                props['TargetTimezone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_timezone
                ]
            else:
                props['TargetTimezone'] = self.target_timezone

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        return props


@dataclass
class DeleteKeys:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    with_keys: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.with_keys is not None:
            if hasattr(self.with_keys, 'to_dict'):
                props['WithKeys'] = self.with_keys.to_dict()
            elif isinstance(self.with_keys, list):
                props['WithKeys'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.with_keys
                ]
            else:
                props['WithKeys'] = self.with_keys

        return props


@dataclass
class Grok:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    match: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        if self.match is not None:
            if hasattr(self.match, 'to_dict'):
                props['Match'] = self.match.to_dict()
            elif isinstance(self.match, list):
                props['Match'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.match
                ]
            else:
                props['Match'] = self.match

        return props


@dataclass
class ListToMap:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    flatten: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    flattened_element: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value_key is not None:
            if hasattr(self.value_key, 'to_dict'):
                props['ValueKey'] = self.value_key.to_dict()
            elif isinstance(self.value_key, list):
                props['ValueKey'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value_key
                ]
            else:
                props['ValueKey'] = self.value_key

        if self.target is not None:
            if hasattr(self.target, 'to_dict'):
                props['Target'] = self.target.to_dict()
            elif isinstance(self.target, list):
                props['Target'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target
                ]
            else:
                props['Target'] = self.target

        if self.flatten is not None:
            if hasattr(self.flatten, 'to_dict'):
                props['Flatten'] = self.flatten.to_dict()
            elif isinstance(self.flatten, list):
                props['Flatten'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.flatten
                ]
            else:
                props['Flatten'] = self.flatten

        if self.flattened_element is not None:
            if hasattr(self.flattened_element, 'to_dict'):
                props['FlattenedElement'] = self.flattened_element.to_dict()
            elif isinstance(self.flattened_element, list):
                props['FlattenedElement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.flattened_element
                ]
            else:
                props['FlattenedElement'] = self.flattened_element

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class LowerCaseString:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    with_keys: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.with_keys is not None:
            if hasattr(self.with_keys, 'to_dict'):
                props['WithKeys'] = self.with_keys.to_dict()
            elif isinstance(self.with_keys, list):
                props['WithKeys'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.with_keys
                ]
            else:
                props['WithKeys'] = self.with_keys

        return props


@dataclass
class MoveKeyEntry:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    overwrite_if_exists: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.target is not None:
            if hasattr(self.target, 'to_dict'):
                props['Target'] = self.target.to_dict()
            elif isinstance(self.target, list):
                props['Target'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target
                ]
            else:
                props['Target'] = self.target

        if self.overwrite_if_exists is not None:
            if hasattr(self.overwrite_if_exists, 'to_dict'):
                props['OverwriteIfExists'] = self.overwrite_if_exists.to_dict()
            elif isinstance(self.overwrite_if_exists, list):
                props['OverwriteIfExists'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.overwrite_if_exists
                ]
            else:
                props['OverwriteIfExists'] = self.overwrite_if_exists

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        return props


@dataclass
class MoveKeys:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    entries: Optional[list[MoveKeyEntry]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.entries is not None:
            if hasattr(self.entries, 'to_dict'):
                props['Entries'] = self.entries.to_dict()
            elif isinstance(self.entries, list):
                props['Entries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.entries
                ]
            else:
                props['Entries'] = self.entries

        return props


@dataclass
class ParseCloudfront:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        return props


@dataclass
class ParseJSON:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination is not None:
            if hasattr(self.destination, 'to_dict'):
                props['Destination'] = self.destination.to_dict()
            elif isinstance(self.destination, list):
                props['Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination
                ]
            else:
                props['Destination'] = self.destination

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        return props


@dataclass
class ParseKeyValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key_value_delimiter: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    overwrite_if_exists: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    field_delimiter: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    non_match_value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination is not None:
            if hasattr(self.destination, 'to_dict'):
                props['Destination'] = self.destination.to_dict()
            elif isinstance(self.destination, list):
                props['Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination
                ]
            else:
                props['Destination'] = self.destination

        if self.key_value_delimiter is not None:
            if hasattr(self.key_value_delimiter, 'to_dict'):
                props['KeyValueDelimiter'] = self.key_value_delimiter.to_dict()
            elif isinstance(self.key_value_delimiter, list):
                props['KeyValueDelimiter'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_value_delimiter
                ]
            else:
                props['KeyValueDelimiter'] = self.key_value_delimiter

        if self.overwrite_if_exists is not None:
            if hasattr(self.overwrite_if_exists, 'to_dict'):
                props['OverwriteIfExists'] = self.overwrite_if_exists.to_dict()
            elif isinstance(self.overwrite_if_exists, list):
                props['OverwriteIfExists'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.overwrite_if_exists
                ]
            else:
                props['OverwriteIfExists'] = self.overwrite_if_exists

        if self.field_delimiter is not None:
            if hasattr(self.field_delimiter, 'to_dict'):
                props['FieldDelimiter'] = self.field_delimiter.to_dict()
            elif isinstance(self.field_delimiter, list):
                props['FieldDelimiter'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.field_delimiter
                ]
            else:
                props['FieldDelimiter'] = self.field_delimiter

        if self.non_match_value is not None:
            if hasattr(self.non_match_value, 'to_dict'):
                props['NonMatchValue'] = self.non_match_value.to_dict()
            elif isinstance(self.non_match_value, list):
                props['NonMatchValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.non_match_value
                ]
            else:
                props['NonMatchValue'] = self.non_match_value

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        if self.key_prefix is not None:
            if hasattr(self.key_prefix, 'to_dict'):
                props['KeyPrefix'] = self.key_prefix.to_dict()
            elif isinstance(self.key_prefix, list):
                props['KeyPrefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_prefix
                ]
            else:
                props['KeyPrefix'] = self.key_prefix

        return props


@dataclass
class ParsePostgres:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        return props


@dataclass
class ParseRoute53:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        return props


@dataclass
class ParseToOCSF:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    event_source: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ocsf_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.event_source is not None:
            if hasattr(self.event_source, 'to_dict'):
                props['EventSource'] = self.event_source.to_dict()
            elif isinstance(self.event_source, list):
                props['EventSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.event_source
                ]
            else:
                props['EventSource'] = self.event_source

        if self.ocsf_version is not None:
            if hasattr(self.ocsf_version, 'to_dict'):
                props['OcsfVersion'] = self.ocsf_version.to_dict()
            elif isinstance(self.ocsf_version, list):
                props['OcsfVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ocsf_version
                ]
            else:
                props['OcsfVersion'] = self.ocsf_version

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        return props


@dataclass
class ParseVPC:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        return props


@dataclass
class ParseWAF:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        return props


@dataclass
class Processor:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parse_cloudfront: Optional[ParseCloudfront] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lower_case_string: Optional[LowerCaseString] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    upper_case_string: Optional[UpperCaseString] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_keys: Optional[DeleteKeys] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rename_keys: Optional[RenameKeys] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    grok: Optional[Grok] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    split_string: Optional[SplitString] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    csv: Optional[Csv] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    add_keys: Optional[AddKeys] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parse_to_ocsf: Optional[ParseToOCSF] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    substitute_string: Optional[SubstituteString] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parse_key_value: Optional[ParseKeyValue] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parse_waf: Optional[ParseWAF] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parse_vpc: Optional[ParseVPC] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parse_route53: Optional[ParseRoute53] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_converter: Optional[TypeConverter] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parse_json: Optional[ParseJSON] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parse_postgres: Optional[ParsePostgres] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    copy_value: Optional[CopyValue] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    move_keys: Optional[MoveKeys] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    date_time_converter: Optional[DateTimeConverter] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    trim_string: Optional[TrimString] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    list_to_map: Optional[ListToMap] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.parse_cloudfront is not None:
            if hasattr(self.parse_cloudfront, 'to_dict'):
                props['ParseCloudfront'] = self.parse_cloudfront.to_dict()
            elif isinstance(self.parse_cloudfront, list):
                props['ParseCloudfront'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parse_cloudfront
                ]
            else:
                props['ParseCloudfront'] = self.parse_cloudfront

        if self.lower_case_string is not None:
            if hasattr(self.lower_case_string, 'to_dict'):
                props['LowerCaseString'] = self.lower_case_string.to_dict()
            elif isinstance(self.lower_case_string, list):
                props['LowerCaseString'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lower_case_string
                ]
            else:
                props['LowerCaseString'] = self.lower_case_string

        if self.upper_case_string is not None:
            if hasattr(self.upper_case_string, 'to_dict'):
                props['UpperCaseString'] = self.upper_case_string.to_dict()
            elif isinstance(self.upper_case_string, list):
                props['UpperCaseString'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.upper_case_string
                ]
            else:
                props['UpperCaseString'] = self.upper_case_string

        if self.delete_keys is not None:
            if hasattr(self.delete_keys, 'to_dict'):
                props['DeleteKeys'] = self.delete_keys.to_dict()
            elif isinstance(self.delete_keys, list):
                props['DeleteKeys'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_keys
                ]
            else:
                props['DeleteKeys'] = self.delete_keys

        if self.rename_keys is not None:
            if hasattr(self.rename_keys, 'to_dict'):
                props['RenameKeys'] = self.rename_keys.to_dict()
            elif isinstance(self.rename_keys, list):
                props['RenameKeys'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rename_keys
                ]
            else:
                props['RenameKeys'] = self.rename_keys

        if self.grok is not None:
            if hasattr(self.grok, 'to_dict'):
                props['Grok'] = self.grok.to_dict()
            elif isinstance(self.grok, list):
                props['Grok'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.grok
                ]
            else:
                props['Grok'] = self.grok

        if self.split_string is not None:
            if hasattr(self.split_string, 'to_dict'):
                props['SplitString'] = self.split_string.to_dict()
            elif isinstance(self.split_string, list):
                props['SplitString'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.split_string
                ]
            else:
                props['SplitString'] = self.split_string

        if self.csv is not None:
            if hasattr(self.csv, 'to_dict'):
                props['Csv'] = self.csv.to_dict()
            elif isinstance(self.csv, list):
                props['Csv'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.csv
                ]
            else:
                props['Csv'] = self.csv

        if self.add_keys is not None:
            if hasattr(self.add_keys, 'to_dict'):
                props['AddKeys'] = self.add_keys.to_dict()
            elif isinstance(self.add_keys, list):
                props['AddKeys'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.add_keys
                ]
            else:
                props['AddKeys'] = self.add_keys

        if self.parse_to_ocsf is not None:
            if hasattr(self.parse_to_ocsf, 'to_dict'):
                props['ParseToOCSF'] = self.parse_to_ocsf.to_dict()
            elif isinstance(self.parse_to_ocsf, list):
                props['ParseToOCSF'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parse_to_ocsf
                ]
            else:
                props['ParseToOCSF'] = self.parse_to_ocsf

        if self.substitute_string is not None:
            if hasattr(self.substitute_string, 'to_dict'):
                props['SubstituteString'] = self.substitute_string.to_dict()
            elif isinstance(self.substitute_string, list):
                props['SubstituteString'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.substitute_string
                ]
            else:
                props['SubstituteString'] = self.substitute_string

        if self.parse_key_value is not None:
            if hasattr(self.parse_key_value, 'to_dict'):
                props['ParseKeyValue'] = self.parse_key_value.to_dict()
            elif isinstance(self.parse_key_value, list):
                props['ParseKeyValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parse_key_value
                ]
            else:
                props['ParseKeyValue'] = self.parse_key_value

        if self.parse_waf is not None:
            if hasattr(self.parse_waf, 'to_dict'):
                props['ParseWAF'] = self.parse_waf.to_dict()
            elif isinstance(self.parse_waf, list):
                props['ParseWAF'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parse_waf
                ]
            else:
                props['ParseWAF'] = self.parse_waf

        if self.parse_vpc is not None:
            if hasattr(self.parse_vpc, 'to_dict'):
                props['ParseVPC'] = self.parse_vpc.to_dict()
            elif isinstance(self.parse_vpc, list):
                props['ParseVPC'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parse_vpc
                ]
            else:
                props['ParseVPC'] = self.parse_vpc

        if self.parse_route53 is not None:
            if hasattr(self.parse_route53, 'to_dict'):
                props['ParseRoute53'] = self.parse_route53.to_dict()
            elif isinstance(self.parse_route53, list):
                props['ParseRoute53'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parse_route53
                ]
            else:
                props['ParseRoute53'] = self.parse_route53

        if self.type_converter is not None:
            if hasattr(self.type_converter, 'to_dict'):
                props['TypeConverter'] = self.type_converter.to_dict()
            elif isinstance(self.type_converter, list):
                props['TypeConverter'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_converter
                ]
            else:
                props['TypeConverter'] = self.type_converter

        if self.parse_json is not None:
            if hasattr(self.parse_json, 'to_dict'):
                props['ParseJSON'] = self.parse_json.to_dict()
            elif isinstance(self.parse_json, list):
                props['ParseJSON'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parse_json
                ]
            else:
                props['ParseJSON'] = self.parse_json

        if self.parse_postgres is not None:
            if hasattr(self.parse_postgres, 'to_dict'):
                props['ParsePostgres'] = self.parse_postgres.to_dict()
            elif isinstance(self.parse_postgres, list):
                props['ParsePostgres'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parse_postgres
                ]
            else:
                props['ParsePostgres'] = self.parse_postgres

        if self.copy_value is not None:
            if hasattr(self.copy_value, 'to_dict'):
                props['CopyValue'] = self.copy_value.to_dict()
            elif isinstance(self.copy_value, list):
                props['CopyValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.copy_value
                ]
            else:
                props['CopyValue'] = self.copy_value

        if self.move_keys is not None:
            if hasattr(self.move_keys, 'to_dict'):
                props['MoveKeys'] = self.move_keys.to_dict()
            elif isinstance(self.move_keys, list):
                props['MoveKeys'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.move_keys
                ]
            else:
                props['MoveKeys'] = self.move_keys

        if self.date_time_converter is not None:
            if hasattr(self.date_time_converter, 'to_dict'):
                props['DateTimeConverter'] = self.date_time_converter.to_dict()
            elif isinstance(self.date_time_converter, list):
                props['DateTimeConverter'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.date_time_converter
                ]
            else:
                props['DateTimeConverter'] = self.date_time_converter

        if self.trim_string is not None:
            if hasattr(self.trim_string, 'to_dict'):
                props['TrimString'] = self.trim_string.to_dict()
            elif isinstance(self.trim_string, list):
                props['TrimString'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.trim_string
                ]
            else:
                props['TrimString'] = self.trim_string

        if self.list_to_map is not None:
            if hasattr(self.list_to_map, 'to_dict'):
                props['ListToMap'] = self.list_to_map.to_dict()
            elif isinstance(self.list_to_map, list):
                props['ListToMap'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.list_to_map
                ]
            else:
                props['ListToMap'] = self.list_to_map

        return props


@dataclass
class RenameKeyEntry:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    overwrite_if_exists: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rename_to: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.overwrite_if_exists is not None:
            if hasattr(self.overwrite_if_exists, 'to_dict'):
                props['OverwriteIfExists'] = self.overwrite_if_exists.to_dict()
            elif isinstance(self.overwrite_if_exists, list):
                props['OverwriteIfExists'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.overwrite_if_exists
                ]
            else:
                props['OverwriteIfExists'] = self.overwrite_if_exists

        if self.rename_to is not None:
            if hasattr(self.rename_to, 'to_dict'):
                props['RenameTo'] = self.rename_to.to_dict()
            elif isinstance(self.rename_to, list):
                props['RenameTo'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rename_to
                ]
            else:
                props['RenameTo'] = self.rename_to

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class RenameKeys:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    entries: Optional[list[RenameKeyEntry]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.entries is not None:
            if hasattr(self.entries, 'to_dict'):
                props['Entries'] = self.entries.to_dict()
            elif isinstance(self.entries, list):
                props['Entries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.entries
                ]
            else:
                props['Entries'] = self.entries

        return props


@dataclass
class SplitString:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    entries: Optional[list[SplitStringEntry]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.entries is not None:
            if hasattr(self.entries, 'to_dict'):
                props['Entries'] = self.entries.to_dict()
            elif isinstance(self.entries, list):
                props['Entries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.entries
                ]
            else:
                props['Entries'] = self.entries

        return props


@dataclass
class SplitStringEntry:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delimiter: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.delimiter is not None:
            if hasattr(self.delimiter, 'to_dict'):
                props['Delimiter'] = self.delimiter.to_dict()
            elif isinstance(self.delimiter, list):
                props['Delimiter'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delimiter
                ]
            else:
                props['Delimiter'] = self.delimiter

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        return props


@dataclass
class SubstituteString:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    entries: Optional[list[SubstituteStringEntry]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.entries is not None:
            if hasattr(self.entries, 'to_dict'):
                props['Entries'] = self.entries.to_dict()
            elif isinstance(self.entries, list):
                props['Entries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.entries
                ]
            else:
                props['Entries'] = self.entries

        return props


@dataclass
class SubstituteStringEntry:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.from_ is not None:
            if hasattr(self.from_, 'to_dict'):
                props['From'] = self.from_.to_dict()
            elif isinstance(self.from_, list):
                props['From'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_
                ]
            else:
                props['From'] = self.from_

        if self.to is not None:
            if hasattr(self.to, 'to_dict'):
                props['To'] = self.to.to_dict()
            elif isinstance(self.to, list):
                props['To'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to
                ]
            else:
                props['To'] = self.to

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        return props


@dataclass
class TrimString:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    with_keys: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.with_keys is not None:
            if hasattr(self.with_keys, 'to_dict'):
                props['WithKeys'] = self.with_keys.to_dict()
            elif isinstance(self.with_keys, list):
                props['WithKeys'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.with_keys
                ]
            else:
                props['WithKeys'] = self.with_keys

        return props


@dataclass
class TypeConverter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    entries: Optional[list[TypeConverterEntry]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.entries is not None:
            if hasattr(self.entries, 'to_dict'):
                props['Entries'] = self.entries.to_dict()
            elif isinstance(self.entries, list):
                props['Entries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.entries
                ]
            else:
                props['Entries'] = self.entries

        return props


@dataclass
class TypeConverterEntry:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class UpperCaseString:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-log"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    with_keys: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.with_keys is not None:
            if hasattr(self.with_keys, 'to_dict'):
                props['WithKeys'] = self.with_keys.to_dict()
            elif isinstance(self.with_keys, list):
                props['WithKeys'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.with_keys
                ]
            else:
                props['WithKeys'] = self.with_keys

        return props


@dataclass
class Transformer(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-"""

    resource_type: ClassVar[str] = "AWS::Logs::Transformer"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transformer_config: Optional[list[Processor]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_group_identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transformer_config is not None:
            # Serialize transformer_config (handle intrinsic functions)
            if hasattr(self.transformer_config, 'to_dict'):
                props["TransformerConfig"] = self.transformer_config.to_dict()
            elif isinstance(self.transformer_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransformerConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transformer_config
                ]
            else:
                props["TransformerConfig"] = self.transformer_config

        if self.log_group_identifier is not None:
            # Serialize log_group_identifier (handle intrinsic functions)
            if hasattr(self.log_group_identifier, 'to_dict'):
                props["LogGroupIdentifier"] = self.log_group_identifier.to_dict()
            elif isinstance(self.log_group_identifier, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogGroupIdentifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_identifier
                ]
            else:
                props["LogGroupIdentifier"] = self.log_group_identifier

        return props


