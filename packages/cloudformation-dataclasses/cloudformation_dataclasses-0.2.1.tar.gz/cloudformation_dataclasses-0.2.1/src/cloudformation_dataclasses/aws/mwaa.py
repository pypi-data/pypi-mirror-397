"""
AWS CloudFormation MWAA Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 227.0.0
  Generator Version: 1.0.0
  Combined: spec-227.0.0_gen-1.0.0
  Generated: 2025-12-15 17:57:27

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service MWAA
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


@dataclass
class LoggingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mwa"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scheduler_logs: Optional[ModuleLoggingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    task_logs: Optional[ModuleLoggingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dag_processing_logs: Optional[ModuleLoggingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    webserver_logs: Optional[ModuleLoggingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    worker_logs: Optional[ModuleLoggingConfiguration] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.scheduler_logs is not None:
            if hasattr(self.scheduler_logs, 'to_dict'):
                props['SchedulerLogs'] = self.scheduler_logs.to_dict()
            elif isinstance(self.scheduler_logs, list):
                props['SchedulerLogs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scheduler_logs
                ]
            else:
                props['SchedulerLogs'] = self.scheduler_logs

        if self.task_logs is not None:
            if hasattr(self.task_logs, 'to_dict'):
                props['TaskLogs'] = self.task_logs.to_dict()
            elif isinstance(self.task_logs, list):
                props['TaskLogs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.task_logs
                ]
            else:
                props['TaskLogs'] = self.task_logs

        if self.dag_processing_logs is not None:
            if hasattr(self.dag_processing_logs, 'to_dict'):
                props['DagProcessingLogs'] = self.dag_processing_logs.to_dict()
            elif isinstance(self.dag_processing_logs, list):
                props['DagProcessingLogs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dag_processing_logs
                ]
            else:
                props['DagProcessingLogs'] = self.dag_processing_logs

        if self.webserver_logs is not None:
            if hasattr(self.webserver_logs, 'to_dict'):
                props['WebserverLogs'] = self.webserver_logs.to_dict()
            elif isinstance(self.webserver_logs, list):
                props['WebserverLogs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.webserver_logs
                ]
            else:
                props['WebserverLogs'] = self.webserver_logs

        if self.worker_logs is not None:
            if hasattr(self.worker_logs, 'to_dict'):
                props['WorkerLogs'] = self.worker_logs.to_dict()
            elif isinstance(self.worker_logs, list):
                props['WorkerLogs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.worker_logs
                ]
            else:
                props['WorkerLogs'] = self.worker_logs

        return props


@dataclass
class ModuleLoggingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mwa"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_log_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_level: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cloud_watch_log_group_arn is not None:
            if hasattr(self.cloud_watch_log_group_arn, 'to_dict'):
                props['CloudWatchLogGroupArn'] = self.cloud_watch_log_group_arn.to_dict()
            elif isinstance(self.cloud_watch_log_group_arn, list):
                props['CloudWatchLogGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cloud_watch_log_group_arn
                ]
            else:
                props['CloudWatchLogGroupArn'] = self.cloud_watch_log_group_arn

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        if self.log_level is not None:
            if hasattr(self.log_level, 'to_dict'):
                props['LogLevel'] = self.log_level.to_dict()
            elif isinstance(self.log_level, list):
                props['LogLevel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_level
                ]
            else:
                props['LogLevel'] = self.log_level

        return props


@dataclass
class NetworkConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-mwa"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnet_ids is not None:
            if hasattr(self.subnet_ids, 'to_dict'):
                props['SubnetIds'] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props['SubnetIds'] = self.subnet_ids

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class Environment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-mwaa-"""

    resource_type: ClassVar[str] = "AWS::MWAA::Environment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    airflow_configuration_options: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    plugins_s3_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    worker_replacement_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    startup_script_s3_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    execution_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    startup_script_s3_object_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    dag_s3_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    logging_configuration: Optional[LoggingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    webserver_access_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_configuration: Optional[NetworkConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_workers: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    environment_class: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    schedulers: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    requirements_s3_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    min_workers: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    airflow_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    requirements_s3_object_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_bucket_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    weekly_maintenance_window_start: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    plugins_s3_object_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    endpoint_management: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_webservers: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    min_webservers: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.airflow_configuration_options is not None:
            # Serialize airflow_configuration_options (handle intrinsic functions)
            if hasattr(self.airflow_configuration_options, 'to_dict'):
                props["AirflowConfigurationOptions"] = self.airflow_configuration_options.to_dict()
            elif isinstance(self.airflow_configuration_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['AirflowConfigurationOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.airflow_configuration_options
                ]
            else:
                props["AirflowConfigurationOptions"] = self.airflow_configuration_options

        if self.plugins_s3_path is not None:
            # Serialize plugins_s3_path (handle intrinsic functions)
            if hasattr(self.plugins_s3_path, 'to_dict'):
                props["PluginsS3Path"] = self.plugins_s3_path.to_dict()
            elif isinstance(self.plugins_s3_path, list):
                # Serialize list items (may contain intrinsic functions)
                props['PluginsS3Path'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.plugins_s3_path
                ]
            else:
                props["PluginsS3Path"] = self.plugins_s3_path

        if self.worker_replacement_strategy is not None:
            # Serialize worker_replacement_strategy (handle intrinsic functions)
            if hasattr(self.worker_replacement_strategy, 'to_dict'):
                props["WorkerReplacementStrategy"] = self.worker_replacement_strategy.to_dict()
            elif isinstance(self.worker_replacement_strategy, list):
                # Serialize list items (may contain intrinsic functions)
                props['WorkerReplacementStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.worker_replacement_strategy
                ]
            else:
                props["WorkerReplacementStrategy"] = self.worker_replacement_strategy

        if self.startup_script_s3_path is not None:
            # Serialize startup_script_s3_path (handle intrinsic functions)
            if hasattr(self.startup_script_s3_path, 'to_dict'):
                props["StartupScriptS3Path"] = self.startup_script_s3_path.to_dict()
            elif isinstance(self.startup_script_s3_path, list):
                # Serialize list items (may contain intrinsic functions)
                props['StartupScriptS3Path'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.startup_script_s3_path
                ]
            else:
                props["StartupScriptS3Path"] = self.startup_script_s3_path

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.execution_role_arn is not None:
            # Serialize execution_role_arn (handle intrinsic functions)
            if hasattr(self.execution_role_arn, 'to_dict'):
                props["ExecutionRoleArn"] = self.execution_role_arn.to_dict()
            elif isinstance(self.execution_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExecutionRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role_arn
                ]
            else:
                props["ExecutionRoleArn"] = self.execution_role_arn

        if self.startup_script_s3_object_version is not None:
            # Serialize startup_script_s3_object_version (handle intrinsic functions)
            if hasattr(self.startup_script_s3_object_version, 'to_dict'):
                props["StartupScriptS3ObjectVersion"] = self.startup_script_s3_object_version.to_dict()
            elif isinstance(self.startup_script_s3_object_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['StartupScriptS3ObjectVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.startup_script_s3_object_version
                ]
            else:
                props["StartupScriptS3ObjectVersion"] = self.startup_script_s3_object_version

        if self.dag_s3_path is not None:
            # Serialize dag_s3_path (handle intrinsic functions)
            if hasattr(self.dag_s3_path, 'to_dict'):
                props["DagS3Path"] = self.dag_s3_path.to_dict()
            elif isinstance(self.dag_s3_path, list):
                # Serialize list items (may contain intrinsic functions)
                props['DagS3Path'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dag_s3_path
                ]
            else:
                props["DagS3Path"] = self.dag_s3_path

        if self.logging_configuration is not None:
            # Serialize logging_configuration (handle intrinsic functions)
            if hasattr(self.logging_configuration, 'to_dict'):
                props["LoggingConfiguration"] = self.logging_configuration.to_dict()
            elif isinstance(self.logging_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['LoggingConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.logging_configuration
                ]
            else:
                props["LoggingConfiguration"] = self.logging_configuration

        if self.webserver_access_mode is not None:
            # Serialize webserver_access_mode (handle intrinsic functions)
            if hasattr(self.webserver_access_mode, 'to_dict'):
                props["WebserverAccessMode"] = self.webserver_access_mode.to_dict()
            elif isinstance(self.webserver_access_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['WebserverAccessMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.webserver_access_mode
                ]
            else:
                props["WebserverAccessMode"] = self.webserver_access_mode

        if self.network_configuration is not None:
            # Serialize network_configuration (handle intrinsic functions)
            if hasattr(self.network_configuration, 'to_dict'):
                props["NetworkConfiguration"] = self.network_configuration.to_dict()
            elif isinstance(self.network_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_configuration
                ]
            else:
                props["NetworkConfiguration"] = self.network_configuration

        if self.kms_key is not None:
            # Serialize kms_key (handle intrinsic functions)
            if hasattr(self.kms_key, 'to_dict'):
                props["KmsKey"] = self.kms_key.to_dict()
            elif isinstance(self.kms_key, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKey'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key
                ]
            else:
                props["KmsKey"] = self.kms_key

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.max_workers is not None:
            # Serialize max_workers (handle intrinsic functions)
            if hasattr(self.max_workers, 'to_dict'):
                props["MaxWorkers"] = self.max_workers.to_dict()
            elif isinstance(self.max_workers, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxWorkers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_workers
                ]
            else:
                props["MaxWorkers"] = self.max_workers

        if self.environment_class is not None:
            # Serialize environment_class (handle intrinsic functions)
            if hasattr(self.environment_class, 'to_dict'):
                props["EnvironmentClass"] = self.environment_class.to_dict()
            elif isinstance(self.environment_class, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnvironmentClass'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment_class
                ]
            else:
                props["EnvironmentClass"] = self.environment_class

        if self.schedulers is not None:
            # Serialize schedulers (handle intrinsic functions)
            if hasattr(self.schedulers, 'to_dict'):
                props["Schedulers"] = self.schedulers.to_dict()
            elif isinstance(self.schedulers, list):
                # Serialize list items (may contain intrinsic functions)
                props['Schedulers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schedulers
                ]
            else:
                props["Schedulers"] = self.schedulers

        if self.requirements_s3_path is not None:
            # Serialize requirements_s3_path (handle intrinsic functions)
            if hasattr(self.requirements_s3_path, 'to_dict'):
                props["RequirementsS3Path"] = self.requirements_s3_path.to_dict()
            elif isinstance(self.requirements_s3_path, list):
                # Serialize list items (may contain intrinsic functions)
                props['RequirementsS3Path'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.requirements_s3_path
                ]
            else:
                props["RequirementsS3Path"] = self.requirements_s3_path

        if self.min_workers is not None:
            # Serialize min_workers (handle intrinsic functions)
            if hasattr(self.min_workers, 'to_dict'):
                props["MinWorkers"] = self.min_workers.to_dict()
            elif isinstance(self.min_workers, list):
                # Serialize list items (may contain intrinsic functions)
                props['MinWorkers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_workers
                ]
            else:
                props["MinWorkers"] = self.min_workers

        if self.airflow_version is not None:
            # Serialize airflow_version (handle intrinsic functions)
            if hasattr(self.airflow_version, 'to_dict'):
                props["AirflowVersion"] = self.airflow_version.to_dict()
            elif isinstance(self.airflow_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['AirflowVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.airflow_version
                ]
            else:
                props["AirflowVersion"] = self.airflow_version

        if self.requirements_s3_object_version is not None:
            # Serialize requirements_s3_object_version (handle intrinsic functions)
            if hasattr(self.requirements_s3_object_version, 'to_dict'):
                props["RequirementsS3ObjectVersion"] = self.requirements_s3_object_version.to_dict()
            elif isinstance(self.requirements_s3_object_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['RequirementsS3ObjectVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.requirements_s3_object_version
                ]
            else:
                props["RequirementsS3ObjectVersion"] = self.requirements_s3_object_version

        if self.source_bucket_arn is not None:
            # Serialize source_bucket_arn (handle intrinsic functions)
            if hasattr(self.source_bucket_arn, 'to_dict'):
                props["SourceBucketArn"] = self.source_bucket_arn.to_dict()
            elif isinstance(self.source_bucket_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceBucketArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_bucket_arn
                ]
            else:
                props["SourceBucketArn"] = self.source_bucket_arn

        if self.weekly_maintenance_window_start is not None:
            # Serialize weekly_maintenance_window_start (handle intrinsic functions)
            if hasattr(self.weekly_maintenance_window_start, 'to_dict'):
                props["WeeklyMaintenanceWindowStart"] = self.weekly_maintenance_window_start.to_dict()
            elif isinstance(self.weekly_maintenance_window_start, list):
                # Serialize list items (may contain intrinsic functions)
                props['WeeklyMaintenanceWindowStart'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weekly_maintenance_window_start
                ]
            else:
                props["WeeklyMaintenanceWindowStart"] = self.weekly_maintenance_window_start

        if self.plugins_s3_object_version is not None:
            # Serialize plugins_s3_object_version (handle intrinsic functions)
            if hasattr(self.plugins_s3_object_version, 'to_dict'):
                props["PluginsS3ObjectVersion"] = self.plugins_s3_object_version.to_dict()
            elif isinstance(self.plugins_s3_object_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['PluginsS3ObjectVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.plugins_s3_object_version
                ]
            else:
                props["PluginsS3ObjectVersion"] = self.plugins_s3_object_version

        if self.endpoint_management is not None:
            # Serialize endpoint_management (handle intrinsic functions)
            if hasattr(self.endpoint_management, 'to_dict'):
                props["EndpointManagement"] = self.endpoint_management.to_dict()
            elif isinstance(self.endpoint_management, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndpointManagement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_management
                ]
            else:
                props["EndpointManagement"] = self.endpoint_management

        if self.max_webservers is not None:
            # Serialize max_webservers (handle intrinsic functions)
            if hasattr(self.max_webservers, 'to_dict'):
                props["MaxWebservers"] = self.max_webservers.to_dict()
            elif isinstance(self.max_webservers, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxWebservers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_webservers
                ]
            else:
                props["MaxWebservers"] = self.max_webservers

        if self.min_webservers is not None:
            # Serialize min_webservers (handle intrinsic functions)
            if hasattr(self.min_webservers, 'to_dict'):
                props["MinWebservers"] = self.min_webservers.to_dict()
            elif isinstance(self.min_webservers, list):
                # Serialize list items (may contain intrinsic functions)
                props['MinWebservers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_webservers
                ]
            else:
                props["MinWebservers"] = self.min_webservers

        return props

    @property
    def attr_logging_configuration__task_logs__cloud_watch_log_group_arn(self) -> GetAtt:
        """Get the LoggingConfiguration.TaskLogs.CloudWatchLogGroupArn attribute."""
        return self.get_att("LoggingConfiguration.TaskLogs.CloudWatchLogGroupArn")

    @property
    def attr_webserver_vpc_endpoint_service(self) -> GetAtt:
        """Get the WebserverVpcEndpointService attribute."""
        return self.get_att("WebserverVpcEndpointService")

    @property
    def attr_database_vpc_endpoint_service(self) -> GetAtt:
        """Get the DatabaseVpcEndpointService attribute."""
        return self.get_att("DatabaseVpcEndpointService")

    @property
    def attr_celery_executor_queue(self) -> GetAtt:
        """Get the CeleryExecutorQueue attribute."""
        return self.get_att("CeleryExecutorQueue")

    @property
    def attr_logging_configuration__webserver_logs__cloud_watch_log_group_arn(self) -> GetAtt:
        """Get the LoggingConfiguration.WebserverLogs.CloudWatchLogGroupArn attribute."""
        return self.get_att("LoggingConfiguration.WebserverLogs.CloudWatchLogGroupArn")

    @property
    def attr_logging_configuration__dag_processing_logs__cloud_watch_log_group_arn(self) -> GetAtt:
        """Get the LoggingConfiguration.DagProcessingLogs.CloudWatchLogGroupArn attribute."""
        return self.get_att("LoggingConfiguration.DagProcessingLogs.CloudWatchLogGroupArn")

    @property
    def attr_webserver_url(self) -> GetAtt:
        """Get the WebserverUrl attribute."""
        return self.get_att("WebserverUrl")

    @property
    def attr_logging_configuration__scheduler_logs__cloud_watch_log_group_arn(self) -> GetAtt:
        """Get the LoggingConfiguration.SchedulerLogs.CloudWatchLogGroupArn attribute."""
        return self.get_att("LoggingConfiguration.SchedulerLogs.CloudWatchLogGroupArn")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_logging_configuration__worker_logs__cloud_watch_log_group_arn(self) -> GetAtt:
        """Get the LoggingConfiguration.WorkerLogs.CloudWatchLogGroupArn attribute."""
        return self.get_att("LoggingConfiguration.WorkerLogs.CloudWatchLogGroupArn")



