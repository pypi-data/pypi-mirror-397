"""
AWS CloudFormation ApplicationAutoScaling Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 227.0.0
  Generator Version: 1.0.0
  Combined: spec-227.0.0_gen-1.0.0
  Generated: 2025-12-15 17:57:11

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service ApplicationAutoScaling
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


@dataclass
class ScalableTargetAction:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min_capacity is not None:
            if hasattr(self.min_capacity, 'to_dict'):
                props['MinCapacity'] = self.min_capacity.to_dict()
            elif isinstance(self.min_capacity, list):
                props['MinCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_capacity
                ]
            else:
                props['MinCapacity'] = self.min_capacity

        if self.max_capacity is not None:
            if hasattr(self.max_capacity, 'to_dict'):
                props['MaxCapacity'] = self.max_capacity.to_dict()
            elif isinstance(self.max_capacity, list):
                props['MaxCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_capacity
                ]
            else:
                props['MaxCapacity'] = self.max_capacity

        return props


@dataclass
class ScheduledAction:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    timezone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scheduled_action_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    end_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    schedule: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    start_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scalable_target_action: Optional[ScalableTargetAction] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.timezone is not None:
            if hasattr(self.timezone, 'to_dict'):
                props['Timezone'] = self.timezone.to_dict()
            elif isinstance(self.timezone, list):
                props['Timezone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.timezone
                ]
            else:
                props['Timezone'] = self.timezone

        if self.scheduled_action_name is not None:
            if hasattr(self.scheduled_action_name, 'to_dict'):
                props['ScheduledActionName'] = self.scheduled_action_name.to_dict()
            elif isinstance(self.scheduled_action_name, list):
                props['ScheduledActionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scheduled_action_name
                ]
            else:
                props['ScheduledActionName'] = self.scheduled_action_name

        if self.end_time is not None:
            if hasattr(self.end_time, 'to_dict'):
                props['EndTime'] = self.end_time.to_dict()
            elif isinstance(self.end_time, list):
                props['EndTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.end_time
                ]
            else:
                props['EndTime'] = self.end_time

        if self.schedule is not None:
            if hasattr(self.schedule, 'to_dict'):
                props['Schedule'] = self.schedule.to_dict()
            elif isinstance(self.schedule, list):
                props['Schedule'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schedule
                ]
            else:
                props['Schedule'] = self.schedule

        if self.start_time is not None:
            if hasattr(self.start_time, 'to_dict'):
                props['StartTime'] = self.start_time.to_dict()
            elif isinstance(self.start_time, list):
                props['StartTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.start_time
                ]
            else:
                props['StartTime'] = self.start_time

        if self.scalable_target_action is not None:
            if hasattr(self.scalable_target_action, 'to_dict'):
                props['ScalableTargetAction'] = self.scalable_target_action.to_dict()
            elif isinstance(self.scalable_target_action, list):
                props['ScalableTargetAction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scalable_target_action
                ]
            else:
                props['ScalableTargetAction'] = self.scalable_target_action

        return props


@dataclass
class SuspendedState:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dynamic_scaling_out_suspended: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scheduled_scaling_suspended: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dynamic_scaling_in_suspended: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.dynamic_scaling_out_suspended is not None:
            if hasattr(self.dynamic_scaling_out_suspended, 'to_dict'):
                props['DynamicScalingOutSuspended'] = self.dynamic_scaling_out_suspended.to_dict()
            elif isinstance(self.dynamic_scaling_out_suspended, list):
                props['DynamicScalingOutSuspended'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dynamic_scaling_out_suspended
                ]
            else:
                props['DynamicScalingOutSuspended'] = self.dynamic_scaling_out_suspended

        if self.scheduled_scaling_suspended is not None:
            if hasattr(self.scheduled_scaling_suspended, 'to_dict'):
                props['ScheduledScalingSuspended'] = self.scheduled_scaling_suspended.to_dict()
            elif isinstance(self.scheduled_scaling_suspended, list):
                props['ScheduledScalingSuspended'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scheduled_scaling_suspended
                ]
            else:
                props['ScheduledScalingSuspended'] = self.scheduled_scaling_suspended

        if self.dynamic_scaling_in_suspended is not None:
            if hasattr(self.dynamic_scaling_in_suspended, 'to_dict'):
                props['DynamicScalingInSuspended'] = self.dynamic_scaling_in_suspended.to_dict()
            elif isinstance(self.dynamic_scaling_in_suspended, list):
                props['DynamicScalingInSuspended'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dynamic_scaling_in_suspended
                ]
            else:
                props['DynamicScalingInSuspended'] = self.dynamic_scaling_in_suspended

        return props


@dataclass
class ScalableTarget(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appli"""

    resource_type: ClassVar[str] = "AWS::ApplicationAutoScaling::ScalableTarget"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    scheduled_actions: Optional[list[ScheduledAction]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_namespace: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    scalable_dimension: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    suspended_state: Optional[SuspendedState] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    min_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.scheduled_actions is not None:
            # Serialize scheduled_actions (handle intrinsic functions)
            if hasattr(self.scheduled_actions, 'to_dict'):
                props["ScheduledActions"] = self.scheduled_actions.to_dict()
            elif isinstance(self.scheduled_actions, list):
                # Serialize list items (may contain intrinsic functions)
                props['ScheduledActions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scheduled_actions
                ]
            else:
                props["ScheduledActions"] = self.scheduled_actions

        if self.resource_id is not None:
            # Serialize resource_id (handle intrinsic functions)
            if hasattr(self.resource_id, 'to_dict'):
                props["ResourceId"] = self.resource_id.to_dict()
            elif isinstance(self.resource_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_id
                ]
            else:
                props["ResourceId"] = self.resource_id

        if self.service_namespace is not None:
            # Serialize service_namespace (handle intrinsic functions)
            if hasattr(self.service_namespace, 'to_dict'):
                props["ServiceNamespace"] = self.service_namespace.to_dict()
            elif isinstance(self.service_namespace, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceNamespace'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_namespace
                ]
            else:
                props["ServiceNamespace"] = self.service_namespace

        if self.scalable_dimension is not None:
            # Serialize scalable_dimension (handle intrinsic functions)
            if hasattr(self.scalable_dimension, 'to_dict'):
                props["ScalableDimension"] = self.scalable_dimension.to_dict()
            elif isinstance(self.scalable_dimension, list):
                # Serialize list items (may contain intrinsic functions)
                props['ScalableDimension'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scalable_dimension
                ]
            else:
                props["ScalableDimension"] = self.scalable_dimension

        if self.suspended_state is not None:
            # Serialize suspended_state (handle intrinsic functions)
            if hasattr(self.suspended_state, 'to_dict'):
                props["SuspendedState"] = self.suspended_state.to_dict()
            elif isinstance(self.suspended_state, list):
                # Serialize list items (may contain intrinsic functions)
                props['SuspendedState'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.suspended_state
                ]
            else:
                props["SuspendedState"] = self.suspended_state

        if self.min_capacity is not None:
            # Serialize min_capacity (handle intrinsic functions)
            if hasattr(self.min_capacity, 'to_dict'):
                props["MinCapacity"] = self.min_capacity.to_dict()
            elif isinstance(self.min_capacity, list):
                # Serialize list items (may contain intrinsic functions)
                props['MinCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_capacity
                ]
            else:
                props["MinCapacity"] = self.min_capacity

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleARN"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleARN"] = self.role_arn

        if self.max_capacity is not None:
            # Serialize max_capacity (handle intrinsic functions)
            if hasattr(self.max_capacity, 'to_dict'):
                props["MaxCapacity"] = self.max_capacity.to_dict()
            elif isinstance(self.max_capacity, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_capacity
                ]
            else:
                props["MaxCapacity"] = self.max_capacity

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class CustomizedMetricSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metrics: Optional[list[TargetTrackingMetricDataQuery]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    statistic: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dimensions: Optional[list[MetricDimension]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    namespace: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_name is not None:
            if hasattr(self.metric_name, 'to_dict'):
                props['MetricName'] = self.metric_name.to_dict()
            elif isinstance(self.metric_name, list):
                props['MetricName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_name
                ]
            else:
                props['MetricName'] = self.metric_name

        if self.metrics is not None:
            if hasattr(self.metrics, 'to_dict'):
                props['Metrics'] = self.metrics.to_dict()
            elif isinstance(self.metrics, list):
                props['Metrics'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metrics
                ]
            else:
                props['Metrics'] = self.metrics

        if self.statistic is not None:
            if hasattr(self.statistic, 'to_dict'):
                props['Statistic'] = self.statistic.to_dict()
            elif isinstance(self.statistic, list):
                props['Statistic'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.statistic
                ]
            else:
                props['Statistic'] = self.statistic

        if self.dimensions is not None:
            if hasattr(self.dimensions, 'to_dict'):
                props['Dimensions'] = self.dimensions.to_dict()
            elif isinstance(self.dimensions, list):
                props['Dimensions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dimensions
                ]
            else:
                props['Dimensions'] = self.dimensions

        if self.unit is not None:
            if hasattr(self.unit, 'to_dict'):
                props['Unit'] = self.unit.to_dict()
            elif isinstance(self.unit, list):
                props['Unit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unit
                ]
            else:
                props['Unit'] = self.unit

        if self.namespace is not None:
            if hasattr(self.namespace, 'to_dict'):
                props['Namespace'] = self.namespace.to_dict()
            elif isinstance(self.namespace, list):
                props['Namespace'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.namespace
                ]
            else:
                props['Namespace'] = self.namespace

        return props


@dataclass
class MetricDimension:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class PredefinedMetricSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_label: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.predefined_metric_type is not None:
            if hasattr(self.predefined_metric_type, 'to_dict'):
                props['PredefinedMetricType'] = self.predefined_metric_type.to_dict()
            elif isinstance(self.predefined_metric_type, list):
                props['PredefinedMetricType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_metric_type
                ]
            else:
                props['PredefinedMetricType'] = self.predefined_metric_type

        if self.resource_label is not None:
            if hasattr(self.resource_label, 'to_dict'):
                props['ResourceLabel'] = self.resource_label.to_dict()
            elif isinstance(self.resource_label, list):
                props['ResourceLabel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_label
                ]
            else:
                props['ResourceLabel'] = self.resource_label

        return props


@dataclass
class PredictiveScalingCustomizedCapacityMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_data_queries: Optional[list[PredictiveScalingMetricDataQuery]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_data_queries is not None:
            if hasattr(self.metric_data_queries, 'to_dict'):
                props['MetricDataQueries'] = self.metric_data_queries.to_dict()
            elif isinstance(self.metric_data_queries, list):
                props['MetricDataQueries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_data_queries
                ]
            else:
                props['MetricDataQueries'] = self.metric_data_queries

        return props


@dataclass
class PredictiveScalingCustomizedLoadMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_data_queries: Optional[list[PredictiveScalingMetricDataQuery]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_data_queries is not None:
            if hasattr(self.metric_data_queries, 'to_dict'):
                props['MetricDataQueries'] = self.metric_data_queries.to_dict()
            elif isinstance(self.metric_data_queries, list):
                props['MetricDataQueries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_data_queries
                ]
            else:
                props['MetricDataQueries'] = self.metric_data_queries

        return props


@dataclass
class PredictiveScalingCustomizedScalingMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_data_queries: Optional[list[PredictiveScalingMetricDataQuery]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_data_queries is not None:
            if hasattr(self.metric_data_queries, 'to_dict'):
                props['MetricDataQueries'] = self.metric_data_queries.to_dict()
            elif isinstance(self.metric_data_queries, list):
                props['MetricDataQueries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_data_queries
                ]
            else:
                props['MetricDataQueries'] = self.metric_data_queries

        return props


@dataclass
class PredictiveScalingMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dimensions: Optional[list[PredictiveScalingMetricDimension]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    namespace: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_name is not None:
            if hasattr(self.metric_name, 'to_dict'):
                props['MetricName'] = self.metric_name.to_dict()
            elif isinstance(self.metric_name, list):
                props['MetricName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_name
                ]
            else:
                props['MetricName'] = self.metric_name

        if self.dimensions is not None:
            if hasattr(self.dimensions, 'to_dict'):
                props['Dimensions'] = self.dimensions.to_dict()
            elif isinstance(self.dimensions, list):
                props['Dimensions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dimensions
                ]
            else:
                props['Dimensions'] = self.dimensions

        if self.namespace is not None:
            if hasattr(self.namespace, 'to_dict'):
                props['Namespace'] = self.namespace.to_dict()
            elif isinstance(self.namespace, list):
                props['Namespace'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.namespace
                ]
            else:
                props['Namespace'] = self.namespace

        return props


@dataclass
class PredictiveScalingMetricDataQuery:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    return_data: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    expression: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    label: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_stat: Optional[PredictiveScalingMetricStat] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.return_data is not None:
            if hasattr(self.return_data, 'to_dict'):
                props['ReturnData'] = self.return_data.to_dict()
            elif isinstance(self.return_data, list):
                props['ReturnData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.return_data
                ]
            else:
                props['ReturnData'] = self.return_data

        if self.expression is not None:
            if hasattr(self.expression, 'to_dict'):
                props['Expression'] = self.expression.to_dict()
            elif isinstance(self.expression, list):
                props['Expression'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.expression
                ]
            else:
                props['Expression'] = self.expression

        if self.label is not None:
            if hasattr(self.label, 'to_dict'):
                props['Label'] = self.label.to_dict()
            elif isinstance(self.label, list):
                props['Label'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.label
                ]
            else:
                props['Label'] = self.label

        if self.metric_stat is not None:
            if hasattr(self.metric_stat, 'to_dict'):
                props['MetricStat'] = self.metric_stat.to_dict()
            elif isinstance(self.metric_stat, list):
                props['MetricStat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_stat
                ]
            else:
                props['MetricStat'] = self.metric_stat

        if self.id is not None:
            if hasattr(self.id, 'to_dict'):
                props['Id'] = self.id.to_dict()
            elif isinstance(self.id, list):
                props['Id'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.id
                ]
            else:
                props['Id'] = self.id

        return props


@dataclass
class PredictiveScalingMetricDimension:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class PredictiveScalingMetricSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customized_load_metric_specification: Optional[PredictiveScalingCustomizedLoadMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_load_metric_specification: Optional[PredictiveScalingPredefinedLoadMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_value: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_scaling_metric_specification: Optional[PredictiveScalingPredefinedScalingMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customized_capacity_metric_specification: Optional[PredictiveScalingCustomizedCapacityMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customized_scaling_metric_specification: Optional[PredictiveScalingCustomizedScalingMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_pair_specification: Optional[PredictiveScalingPredefinedMetricPair] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.customized_load_metric_specification is not None:
            if hasattr(self.customized_load_metric_specification, 'to_dict'):
                props['CustomizedLoadMetricSpecification'] = self.customized_load_metric_specification.to_dict()
            elif isinstance(self.customized_load_metric_specification, list):
                props['CustomizedLoadMetricSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customized_load_metric_specification
                ]
            else:
                props['CustomizedLoadMetricSpecification'] = self.customized_load_metric_specification

        if self.predefined_load_metric_specification is not None:
            if hasattr(self.predefined_load_metric_specification, 'to_dict'):
                props['PredefinedLoadMetricSpecification'] = self.predefined_load_metric_specification.to_dict()
            elif isinstance(self.predefined_load_metric_specification, list):
                props['PredefinedLoadMetricSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_load_metric_specification
                ]
            else:
                props['PredefinedLoadMetricSpecification'] = self.predefined_load_metric_specification

        if self.target_value is not None:
            if hasattr(self.target_value, 'to_dict'):
                props['TargetValue'] = self.target_value.to_dict()
            elif isinstance(self.target_value, list):
                props['TargetValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_value
                ]
            else:
                props['TargetValue'] = self.target_value

        if self.predefined_scaling_metric_specification is not None:
            if hasattr(self.predefined_scaling_metric_specification, 'to_dict'):
                props['PredefinedScalingMetricSpecification'] = self.predefined_scaling_metric_specification.to_dict()
            elif isinstance(self.predefined_scaling_metric_specification, list):
                props['PredefinedScalingMetricSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_scaling_metric_specification
                ]
            else:
                props['PredefinedScalingMetricSpecification'] = self.predefined_scaling_metric_specification

        if self.customized_capacity_metric_specification is not None:
            if hasattr(self.customized_capacity_metric_specification, 'to_dict'):
                props['CustomizedCapacityMetricSpecification'] = self.customized_capacity_metric_specification.to_dict()
            elif isinstance(self.customized_capacity_metric_specification, list):
                props['CustomizedCapacityMetricSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customized_capacity_metric_specification
                ]
            else:
                props['CustomizedCapacityMetricSpecification'] = self.customized_capacity_metric_specification

        if self.customized_scaling_metric_specification is not None:
            if hasattr(self.customized_scaling_metric_specification, 'to_dict'):
                props['CustomizedScalingMetricSpecification'] = self.customized_scaling_metric_specification.to_dict()
            elif isinstance(self.customized_scaling_metric_specification, list):
                props['CustomizedScalingMetricSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customized_scaling_metric_specification
                ]
            else:
                props['CustomizedScalingMetricSpecification'] = self.customized_scaling_metric_specification

        if self.predefined_metric_pair_specification is not None:
            if hasattr(self.predefined_metric_pair_specification, 'to_dict'):
                props['PredefinedMetricPairSpecification'] = self.predefined_metric_pair_specification.to_dict()
            elif isinstance(self.predefined_metric_pair_specification, list):
                props['PredefinedMetricPairSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_metric_pair_specification
                ]
            else:
                props['PredefinedMetricPairSpecification'] = self.predefined_metric_pair_specification

        return props


@dataclass
class PredictiveScalingMetricStat:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    stat: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric: Optional[PredictiveScalingMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.stat is not None:
            if hasattr(self.stat, 'to_dict'):
                props['Stat'] = self.stat.to_dict()
            elif isinstance(self.stat, list):
                props['Stat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stat
                ]
            else:
                props['Stat'] = self.stat

        if self.metric is not None:
            if hasattr(self.metric, 'to_dict'):
                props['Metric'] = self.metric.to_dict()
            elif isinstance(self.metric, list):
                props['Metric'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric
                ]
            else:
                props['Metric'] = self.metric

        if self.unit is not None:
            if hasattr(self.unit, 'to_dict'):
                props['Unit'] = self.unit.to_dict()
            elif isinstance(self.unit, list):
                props['Unit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unit
                ]
            else:
                props['Unit'] = self.unit

        return props


@dataclass
class PredictiveScalingPolicyConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_capacity_breach_behavior: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_capacity_buffer: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_specifications: Optional[list[PredictiveScalingMetricSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scheduling_buffer_time: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_capacity_breach_behavior is not None:
            if hasattr(self.max_capacity_breach_behavior, 'to_dict'):
                props['MaxCapacityBreachBehavior'] = self.max_capacity_breach_behavior.to_dict()
            elif isinstance(self.max_capacity_breach_behavior, list):
                props['MaxCapacityBreachBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_capacity_breach_behavior
                ]
            else:
                props['MaxCapacityBreachBehavior'] = self.max_capacity_breach_behavior

        if self.max_capacity_buffer is not None:
            if hasattr(self.max_capacity_buffer, 'to_dict'):
                props['MaxCapacityBuffer'] = self.max_capacity_buffer.to_dict()
            elif isinstance(self.max_capacity_buffer, list):
                props['MaxCapacityBuffer'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_capacity_buffer
                ]
            else:
                props['MaxCapacityBuffer'] = self.max_capacity_buffer

        if self.mode is not None:
            if hasattr(self.mode, 'to_dict'):
                props['Mode'] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props['Mode'] = self.mode

        if self.metric_specifications is not None:
            if hasattr(self.metric_specifications, 'to_dict'):
                props['MetricSpecifications'] = self.metric_specifications.to_dict()
            elif isinstance(self.metric_specifications, list):
                props['MetricSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_specifications
                ]
            else:
                props['MetricSpecifications'] = self.metric_specifications

        if self.scheduling_buffer_time is not None:
            if hasattr(self.scheduling_buffer_time, 'to_dict'):
                props['SchedulingBufferTime'] = self.scheduling_buffer_time.to_dict()
            elif isinstance(self.scheduling_buffer_time, list):
                props['SchedulingBufferTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scheduling_buffer_time
                ]
            else:
                props['SchedulingBufferTime'] = self.scheduling_buffer_time

        return props


@dataclass
class PredictiveScalingPredefinedLoadMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_label: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.predefined_metric_type is not None:
            if hasattr(self.predefined_metric_type, 'to_dict'):
                props['PredefinedMetricType'] = self.predefined_metric_type.to_dict()
            elif isinstance(self.predefined_metric_type, list):
                props['PredefinedMetricType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_metric_type
                ]
            else:
                props['PredefinedMetricType'] = self.predefined_metric_type

        if self.resource_label is not None:
            if hasattr(self.resource_label, 'to_dict'):
                props['ResourceLabel'] = self.resource_label.to_dict()
            elif isinstance(self.resource_label, list):
                props['ResourceLabel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_label
                ]
            else:
                props['ResourceLabel'] = self.resource_label

        return props


@dataclass
class PredictiveScalingPredefinedMetricPair:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_label: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.predefined_metric_type is not None:
            if hasattr(self.predefined_metric_type, 'to_dict'):
                props['PredefinedMetricType'] = self.predefined_metric_type.to_dict()
            elif isinstance(self.predefined_metric_type, list):
                props['PredefinedMetricType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_metric_type
                ]
            else:
                props['PredefinedMetricType'] = self.predefined_metric_type

        if self.resource_label is not None:
            if hasattr(self.resource_label, 'to_dict'):
                props['ResourceLabel'] = self.resource_label.to_dict()
            elif isinstance(self.resource_label, list):
                props['ResourceLabel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_label
                ]
            else:
                props['ResourceLabel'] = self.resource_label

        return props


@dataclass
class PredictiveScalingPredefinedScalingMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_label: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.predefined_metric_type is not None:
            if hasattr(self.predefined_metric_type, 'to_dict'):
                props['PredefinedMetricType'] = self.predefined_metric_type.to_dict()
            elif isinstance(self.predefined_metric_type, list):
                props['PredefinedMetricType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_metric_type
                ]
            else:
                props['PredefinedMetricType'] = self.predefined_metric_type

        if self.resource_label is not None:
            if hasattr(self.resource_label, 'to_dict'):
                props['ResourceLabel'] = self.resource_label.to_dict()
            elif isinstance(self.resource_label, list):
                props['ResourceLabel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_label
                ]
            else:
                props['ResourceLabel'] = self.resource_label

        return props


@dataclass
class StepAdjustment:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_interval_upper_bound: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_interval_lower_bound: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scaling_adjustment: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_interval_upper_bound is not None:
            if hasattr(self.metric_interval_upper_bound, 'to_dict'):
                props['MetricIntervalUpperBound'] = self.metric_interval_upper_bound.to_dict()
            elif isinstance(self.metric_interval_upper_bound, list):
                props['MetricIntervalUpperBound'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_interval_upper_bound
                ]
            else:
                props['MetricIntervalUpperBound'] = self.metric_interval_upper_bound

        if self.metric_interval_lower_bound is not None:
            if hasattr(self.metric_interval_lower_bound, 'to_dict'):
                props['MetricIntervalLowerBound'] = self.metric_interval_lower_bound.to_dict()
            elif isinstance(self.metric_interval_lower_bound, list):
                props['MetricIntervalLowerBound'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_interval_lower_bound
                ]
            else:
                props['MetricIntervalLowerBound'] = self.metric_interval_lower_bound

        if self.scaling_adjustment is not None:
            if hasattr(self.scaling_adjustment, 'to_dict'):
                props['ScalingAdjustment'] = self.scaling_adjustment.to_dict()
            elif isinstance(self.scaling_adjustment, list):
                props['ScalingAdjustment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scaling_adjustment
                ]
            else:
                props['ScalingAdjustment'] = self.scaling_adjustment

        return props


@dataclass
class StepScalingPolicyConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_aggregation_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cooldown: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    step_adjustments: Optional[list[StepAdjustment]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_adjustment_magnitude: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    adjustment_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_aggregation_type is not None:
            if hasattr(self.metric_aggregation_type, 'to_dict'):
                props['MetricAggregationType'] = self.metric_aggregation_type.to_dict()
            elif isinstance(self.metric_aggregation_type, list):
                props['MetricAggregationType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_aggregation_type
                ]
            else:
                props['MetricAggregationType'] = self.metric_aggregation_type

        if self.cooldown is not None:
            if hasattr(self.cooldown, 'to_dict'):
                props['Cooldown'] = self.cooldown.to_dict()
            elif isinstance(self.cooldown, list):
                props['Cooldown'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cooldown
                ]
            else:
                props['Cooldown'] = self.cooldown

        if self.step_adjustments is not None:
            if hasattr(self.step_adjustments, 'to_dict'):
                props['StepAdjustments'] = self.step_adjustments.to_dict()
            elif isinstance(self.step_adjustments, list):
                props['StepAdjustments'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.step_adjustments
                ]
            else:
                props['StepAdjustments'] = self.step_adjustments

        if self.min_adjustment_magnitude is not None:
            if hasattr(self.min_adjustment_magnitude, 'to_dict'):
                props['MinAdjustmentMagnitude'] = self.min_adjustment_magnitude.to_dict()
            elif isinstance(self.min_adjustment_magnitude, list):
                props['MinAdjustmentMagnitude'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_adjustment_magnitude
                ]
            else:
                props['MinAdjustmentMagnitude'] = self.min_adjustment_magnitude

        if self.adjustment_type is not None:
            if hasattr(self.adjustment_type, 'to_dict'):
                props['AdjustmentType'] = self.adjustment_type.to_dict()
            elif isinstance(self.adjustment_type, list):
                props['AdjustmentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.adjustment_type
                ]
            else:
                props['AdjustmentType'] = self.adjustment_type

        return props


@dataclass
class TargetTrackingMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dimensions: Optional[list[TargetTrackingMetricDimension]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    namespace: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_name is not None:
            if hasattr(self.metric_name, 'to_dict'):
                props['MetricName'] = self.metric_name.to_dict()
            elif isinstance(self.metric_name, list):
                props['MetricName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_name
                ]
            else:
                props['MetricName'] = self.metric_name

        if self.dimensions is not None:
            if hasattr(self.dimensions, 'to_dict'):
                props['Dimensions'] = self.dimensions.to_dict()
            elif isinstance(self.dimensions, list):
                props['Dimensions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dimensions
                ]
            else:
                props['Dimensions'] = self.dimensions

        if self.namespace is not None:
            if hasattr(self.namespace, 'to_dict'):
                props['Namespace'] = self.namespace.to_dict()
            elif isinstance(self.namespace, list):
                props['Namespace'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.namespace
                ]
            else:
                props['Namespace'] = self.namespace

        return props


@dataclass
class TargetTrackingMetricDataQuery:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    return_data: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    expression: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    label: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_stat: Optional[TargetTrackingMetricStat] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.return_data is not None:
            if hasattr(self.return_data, 'to_dict'):
                props['ReturnData'] = self.return_data.to_dict()
            elif isinstance(self.return_data, list):
                props['ReturnData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.return_data
                ]
            else:
                props['ReturnData'] = self.return_data

        if self.expression is not None:
            if hasattr(self.expression, 'to_dict'):
                props['Expression'] = self.expression.to_dict()
            elif isinstance(self.expression, list):
                props['Expression'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.expression
                ]
            else:
                props['Expression'] = self.expression

        if self.label is not None:
            if hasattr(self.label, 'to_dict'):
                props['Label'] = self.label.to_dict()
            elif isinstance(self.label, list):
                props['Label'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.label
                ]
            else:
                props['Label'] = self.label

        if self.metric_stat is not None:
            if hasattr(self.metric_stat, 'to_dict'):
                props['MetricStat'] = self.metric_stat.to_dict()
            elif isinstance(self.metric_stat, list):
                props['MetricStat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_stat
                ]
            else:
                props['MetricStat'] = self.metric_stat

        if self.id is not None:
            if hasattr(self.id, 'to_dict'):
                props['Id'] = self.id.to_dict()
            elif isinstance(self.id, list):
                props['Id'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.id
                ]
            else:
                props['Id'] = self.id

        return props


@dataclass
class TargetTrackingMetricDimension:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class TargetTrackingMetricStat:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    stat: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric: Optional[TargetTrackingMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.stat is not None:
            if hasattr(self.stat, 'to_dict'):
                props['Stat'] = self.stat.to_dict()
            elif isinstance(self.stat, list):
                props['Stat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stat
                ]
            else:
                props['Stat'] = self.stat

        if self.metric is not None:
            if hasattr(self.metric, 'to_dict'):
                props['Metric'] = self.metric.to_dict()
            elif isinstance(self.metric, list):
                props['Metric'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric
                ]
            else:
                props['Metric'] = self.metric

        if self.unit is not None:
            if hasattr(self.unit, 'to_dict'):
                props['Unit'] = self.unit.to_dict()
            elif isinstance(self.unit, list):
                props['Unit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unit
                ]
            else:
                props['Unit'] = self.unit

        return props


@dataclass
class TargetTrackingScalingPolicyConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scale_out_cooldown: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_value: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customized_metric_specification: Optional[CustomizedMetricSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    disable_scale_in: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scale_in_cooldown: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_specification: Optional[PredefinedMetricSpecification] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.scale_out_cooldown is not None:
            if hasattr(self.scale_out_cooldown, 'to_dict'):
                props['ScaleOutCooldown'] = self.scale_out_cooldown.to_dict()
            elif isinstance(self.scale_out_cooldown, list):
                props['ScaleOutCooldown'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scale_out_cooldown
                ]
            else:
                props['ScaleOutCooldown'] = self.scale_out_cooldown

        if self.target_value is not None:
            if hasattr(self.target_value, 'to_dict'):
                props['TargetValue'] = self.target_value.to_dict()
            elif isinstance(self.target_value, list):
                props['TargetValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_value
                ]
            else:
                props['TargetValue'] = self.target_value

        if self.customized_metric_specification is not None:
            if hasattr(self.customized_metric_specification, 'to_dict'):
                props['CustomizedMetricSpecification'] = self.customized_metric_specification.to_dict()
            elif isinstance(self.customized_metric_specification, list):
                props['CustomizedMetricSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customized_metric_specification
                ]
            else:
                props['CustomizedMetricSpecification'] = self.customized_metric_specification

        if self.disable_scale_in is not None:
            if hasattr(self.disable_scale_in, 'to_dict'):
                props['DisableScaleIn'] = self.disable_scale_in.to_dict()
            elif isinstance(self.disable_scale_in, list):
                props['DisableScaleIn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disable_scale_in
                ]
            else:
                props['DisableScaleIn'] = self.disable_scale_in

        if self.scale_in_cooldown is not None:
            if hasattr(self.scale_in_cooldown, 'to_dict'):
                props['ScaleInCooldown'] = self.scale_in_cooldown.to_dict()
            elif isinstance(self.scale_in_cooldown, list):
                props['ScaleInCooldown'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scale_in_cooldown
                ]
            else:
                props['ScaleInCooldown'] = self.scale_in_cooldown

        if self.predefined_metric_specification is not None:
            if hasattr(self.predefined_metric_specification, 'to_dict'):
                props['PredefinedMetricSpecification'] = self.predefined_metric_specification.to_dict()
            elif isinstance(self.predefined_metric_specification, list):
                props['PredefinedMetricSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_metric_specification
                ]
            else:
                props['PredefinedMetricSpecification'] = self.predefined_metric_specification

        return props


@dataclass
class ScalingPolicy(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appli"""

    resource_type: ClassVar[str] = "AWS::ApplicationAutoScaling::ScalingPolicy"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    scaling_target_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_namespace: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    scalable_dimension: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_tracking_scaling_policy_configuration: Optional[TargetTrackingScalingPolicyConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    step_scaling_policy_configuration: Optional[StepScalingPolicyConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    predictive_scaling_policy_configuration: Optional[PredictiveScalingPolicyConfiguration] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.policy_type is not None:
            # Serialize policy_type (handle intrinsic functions)
            if hasattr(self.policy_type, 'to_dict'):
                props["PolicyType"] = self.policy_type.to_dict()
            elif isinstance(self.policy_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_type
                ]
            else:
                props["PolicyType"] = self.policy_type

        if self.resource_id is not None:
            # Serialize resource_id (handle intrinsic functions)
            if hasattr(self.resource_id, 'to_dict'):
                props["ResourceId"] = self.resource_id.to_dict()
            elif isinstance(self.resource_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_id
                ]
            else:
                props["ResourceId"] = self.resource_id

        if self.scaling_target_id is not None:
            # Serialize scaling_target_id (handle intrinsic functions)
            if hasattr(self.scaling_target_id, 'to_dict'):
                props["ScalingTargetId"] = self.scaling_target_id.to_dict()
            elif isinstance(self.scaling_target_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ScalingTargetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scaling_target_id
                ]
            else:
                props["ScalingTargetId"] = self.scaling_target_id

        if self.policy_name is not None:
            # Serialize policy_name (handle intrinsic functions)
            if hasattr(self.policy_name, 'to_dict'):
                props["PolicyName"] = self.policy_name.to_dict()
            elif isinstance(self.policy_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_name
                ]
            else:
                props["PolicyName"] = self.policy_name

        if self.service_namespace is not None:
            # Serialize service_namespace (handle intrinsic functions)
            if hasattr(self.service_namespace, 'to_dict'):
                props["ServiceNamespace"] = self.service_namespace.to_dict()
            elif isinstance(self.service_namespace, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceNamespace'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_namespace
                ]
            else:
                props["ServiceNamespace"] = self.service_namespace

        if self.scalable_dimension is not None:
            # Serialize scalable_dimension (handle intrinsic functions)
            if hasattr(self.scalable_dimension, 'to_dict'):
                props["ScalableDimension"] = self.scalable_dimension.to_dict()
            elif isinstance(self.scalable_dimension, list):
                # Serialize list items (may contain intrinsic functions)
                props['ScalableDimension'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scalable_dimension
                ]
            else:
                props["ScalableDimension"] = self.scalable_dimension

        if self.target_tracking_scaling_policy_configuration is not None:
            # Serialize target_tracking_scaling_policy_configuration (handle intrinsic functions)
            if hasattr(self.target_tracking_scaling_policy_configuration, 'to_dict'):
                props["TargetTrackingScalingPolicyConfiguration"] = self.target_tracking_scaling_policy_configuration.to_dict()
            elif isinstance(self.target_tracking_scaling_policy_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetTrackingScalingPolicyConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_tracking_scaling_policy_configuration
                ]
            else:
                props["TargetTrackingScalingPolicyConfiguration"] = self.target_tracking_scaling_policy_configuration

        if self.step_scaling_policy_configuration is not None:
            # Serialize step_scaling_policy_configuration (handle intrinsic functions)
            if hasattr(self.step_scaling_policy_configuration, 'to_dict'):
                props["StepScalingPolicyConfiguration"] = self.step_scaling_policy_configuration.to_dict()
            elif isinstance(self.step_scaling_policy_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['StepScalingPolicyConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.step_scaling_policy_configuration
                ]
            else:
                props["StepScalingPolicyConfiguration"] = self.step_scaling_policy_configuration

        if self.predictive_scaling_policy_configuration is not None:
            # Serialize predictive_scaling_policy_configuration (handle intrinsic functions)
            if hasattr(self.predictive_scaling_policy_configuration, 'to_dict'):
                props["PredictiveScalingPolicyConfiguration"] = self.predictive_scaling_policy_configuration.to_dict()
            elif isinstance(self.predictive_scaling_policy_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['PredictiveScalingPolicyConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predictive_scaling_policy_configuration
                ]
            else:
                props["PredictiveScalingPolicyConfiguration"] = self.predictive_scaling_policy_configuration

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")



