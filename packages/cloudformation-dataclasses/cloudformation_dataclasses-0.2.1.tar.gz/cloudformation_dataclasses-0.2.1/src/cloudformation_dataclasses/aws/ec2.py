"""
AWS CloudFormation EC2 Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 227.0.0
  Generator Version: 1.0.0
  Combined: spec-227.0.0_gen-1.0.0
  Generated: 2025-12-15 17:57:18

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service EC2
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


@dataclass
class CapacityManagerDataExport(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::CapacityManagerDataExport"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    s3_bucket_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    schedule: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    output_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    s3_bucket_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_bucket_prefix is not None:
            # Serialize s3_bucket_prefix (handle intrinsic functions)
            if hasattr(self.s3_bucket_prefix, 'to_dict'):
                props["S3BucketPrefix"] = self.s3_bucket_prefix.to_dict()
            elif isinstance(self.s3_bucket_prefix, list):
                # Serialize list items (may contain intrinsic functions)
                props['S3BucketPrefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_bucket_prefix
                ]
            else:
                props["S3BucketPrefix"] = self.s3_bucket_prefix

        if self.schedule is not None:
            # Serialize schedule (handle intrinsic functions)
            if hasattr(self.schedule, 'to_dict'):
                props["Schedule"] = self.schedule.to_dict()
            elif isinstance(self.schedule, list):
                # Serialize list items (may contain intrinsic functions)
                props['Schedule'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schedule
                ]
            else:
                props["Schedule"] = self.schedule

        if self.output_format is not None:
            # Serialize output_format (handle intrinsic functions)
            if hasattr(self.output_format, 'to_dict'):
                props["OutputFormat"] = self.output_format.to_dict()
            elif isinstance(self.output_format, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutputFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_format
                ]
            else:
                props["OutputFormat"] = self.output_format

        if self.s3_bucket_name is not None:
            # Serialize s3_bucket_name (handle intrinsic functions)
            if hasattr(self.s3_bucket_name, 'to_dict'):
                props["S3BucketName"] = self.s3_bucket_name.to_dict()
            elif isinstance(self.s3_bucket_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['S3BucketName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_bucket_name
                ]
            else:
                props["S3BucketName"] = self.s3_bucket_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_capacity_manager_data_export_id(self) -> GetAtt:
        """Get the CapacityManagerDataExportId attribute."""
        return self.get_att("CapacityManagerDataExportId")




@dataclass
class CapacityAllocation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allocation_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.allocation_type is not None:
            if hasattr(self.allocation_type, 'to_dict'):
                props['AllocationType'] = self.allocation_type.to_dict()
            elif isinstance(self.allocation_type, list):
                props['AllocationType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_type
                ]
            else:
                props['AllocationType'] = self.allocation_type

        if self.count is not None:
            if hasattr(self.count, 'to_dict'):
                props['Count'] = self.count.to_dict()
            elif isinstance(self.count, list):
                props['Count'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.count
                ]
            else:
                props['Count'] = self.count

        return props


@dataclass
class CommitmentInfo:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    committed_instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    commitment_end_date: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.committed_instance_count is not None:
            if hasattr(self.committed_instance_count, 'to_dict'):
                props['CommittedInstanceCount'] = self.committed_instance_count.to_dict()
            elif isinstance(self.committed_instance_count, list):
                props['CommittedInstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.committed_instance_count
                ]
            else:
                props['CommittedInstanceCount'] = self.committed_instance_count

        if self.commitment_end_date is not None:
            if hasattr(self.commitment_end_date, 'to_dict'):
                props['CommitmentEndDate'] = self.commitment_end_date.to_dict()
            elif isinstance(self.commitment_end_date, list):
                props['CommitmentEndDate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.commitment_end_date
                ]
            else:
                props['CommitmentEndDate'] = self.commitment_end_date

        return props


@dataclass
class TagSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tags: Optional[list[Tag]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        if self.tags is not None:
            if hasattr(self.tags, 'to_dict'):
                props['Tags'] = self.tags.to_dict()
            elif isinstance(self.tags, list):
                props['Tags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tags
                ]
            else:
                props['Tags'] = self.tags

        return props


@dataclass
class CapacityReservation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::CapacityReservation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tenancy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    end_date_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tag_specifications: Optional[list[TagSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    unused_reservation_billing_owner_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    end_date: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ebs_optimized: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    out_post_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    placement_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_platform: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ephemeral_storage: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_match_criteria: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.tenancy is not None:
            # Serialize tenancy (handle intrinsic functions)
            if hasattr(self.tenancy, 'to_dict'):
                props["Tenancy"] = self.tenancy.to_dict()
            elif isinstance(self.tenancy, list):
                # Serialize list items (may contain intrinsic functions)
                props['Tenancy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tenancy
                ]
            else:
                props["Tenancy"] = self.tenancy

        if self.end_date_type is not None:
            # Serialize end_date_type (handle intrinsic functions)
            if hasattr(self.end_date_type, 'to_dict'):
                props["EndDateType"] = self.end_date_type.to_dict()
            elif isinstance(self.end_date_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndDateType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.end_date_type
                ]
            else:
                props["EndDateType"] = self.end_date_type

        if self.tag_specifications is not None:
            # Serialize tag_specifications (handle intrinsic functions)
            if hasattr(self.tag_specifications, 'to_dict'):
                props["TagSpecifications"] = self.tag_specifications.to_dict()
            elif isinstance(self.tag_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['TagSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_specifications
                ]
            else:
                props["TagSpecifications"] = self.tag_specifications

        if self.unused_reservation_billing_owner_id is not None:
            # Serialize unused_reservation_billing_owner_id (handle intrinsic functions)
            if hasattr(self.unused_reservation_billing_owner_id, 'to_dict'):
                props["UnusedReservationBillingOwnerId"] = self.unused_reservation_billing_owner_id.to_dict()
            elif isinstance(self.unused_reservation_billing_owner_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['UnusedReservationBillingOwnerId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unused_reservation_billing_owner_id
                ]
            else:
                props["UnusedReservationBillingOwnerId"] = self.unused_reservation_billing_owner_id

        if self.availability_zone_id is not None:
            # Serialize availability_zone_id (handle intrinsic functions)
            if hasattr(self.availability_zone_id, 'to_dict'):
                props["AvailabilityZoneId"] = self.availability_zone_id.to_dict()
            elif isinstance(self.availability_zone_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZoneId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone_id
                ]
            else:
                props["AvailabilityZoneId"] = self.availability_zone_id

        if self.availability_zone is not None:
            # Serialize availability_zone (handle intrinsic functions)
            if hasattr(self.availability_zone, 'to_dict'):
                props["AvailabilityZone"] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props["AvailabilityZone"] = self.availability_zone

        if self.end_date is not None:
            # Serialize end_date (handle intrinsic functions)
            if hasattr(self.end_date, 'to_dict'):
                props["EndDate"] = self.end_date.to_dict()
            elif isinstance(self.end_date, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndDate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.end_date
                ]
            else:
                props["EndDate"] = self.end_date

        if self.ebs_optimized is not None:
            # Serialize ebs_optimized (handle intrinsic functions)
            if hasattr(self.ebs_optimized, 'to_dict'):
                props["EbsOptimized"] = self.ebs_optimized.to_dict()
            elif isinstance(self.ebs_optimized, list):
                # Serialize list items (may contain intrinsic functions)
                props['EbsOptimized'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_optimized
                ]
            else:
                props["EbsOptimized"] = self.ebs_optimized

        if self.out_post_arn is not None:
            # Serialize out_post_arn (handle intrinsic functions)
            if hasattr(self.out_post_arn, 'to_dict'):
                props["OutPostArn"] = self.out_post_arn.to_dict()
            elif isinstance(self.out_post_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutPostArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.out_post_arn
                ]
            else:
                props["OutPostArn"] = self.out_post_arn

        if self.instance_count is not None:
            # Serialize instance_count (handle intrinsic functions)
            if hasattr(self.instance_count, 'to_dict'):
                props["InstanceCount"] = self.instance_count.to_dict()
            elif isinstance(self.instance_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_count
                ]
            else:
                props["InstanceCount"] = self.instance_count

        if self.placement_group_arn is not None:
            # Serialize placement_group_arn (handle intrinsic functions)
            if hasattr(self.placement_group_arn, 'to_dict'):
                props["PlacementGroupArn"] = self.placement_group_arn.to_dict()
            elif isinstance(self.placement_group_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['PlacementGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.placement_group_arn
                ]
            else:
                props["PlacementGroupArn"] = self.placement_group_arn

        if self.instance_platform is not None:
            # Serialize instance_platform (handle intrinsic functions)
            if hasattr(self.instance_platform, 'to_dict'):
                props["InstancePlatform"] = self.instance_platform.to_dict()
            elif isinstance(self.instance_platform, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstancePlatform'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_platform
                ]
            else:
                props["InstancePlatform"] = self.instance_platform

        if self.instance_type is not None:
            # Serialize instance_type (handle intrinsic functions)
            if hasattr(self.instance_type, 'to_dict'):
                props["InstanceType"] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props["InstanceType"] = self.instance_type

        if self.ephemeral_storage is not None:
            # Serialize ephemeral_storage (handle intrinsic functions)
            if hasattr(self.ephemeral_storage, 'to_dict'):
                props["EphemeralStorage"] = self.ephemeral_storage.to_dict()
            elif isinstance(self.ephemeral_storage, list):
                # Serialize list items (may contain intrinsic functions)
                props['EphemeralStorage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ephemeral_storage
                ]
            else:
                props["EphemeralStorage"] = self.ephemeral_storage

        if self.instance_match_criteria is not None:
            # Serialize instance_match_criteria (handle intrinsic functions)
            if hasattr(self.instance_match_criteria, 'to_dict'):
                props["InstanceMatchCriteria"] = self.instance_match_criteria.to_dict()
            elif isinstance(self.instance_match_criteria, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceMatchCriteria'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_match_criteria
                ]
            else:
                props["InstanceMatchCriteria"] = self.instance_match_criteria

        return props

    @property
    def attr_tenancy(self) -> GetAtt:
        """Get the Tenancy attribute."""
        return self.get_att("Tenancy")

    @property
    def attr_commitment_info__committed_instance_count(self) -> GetAtt:
        """Get the CommitmentInfo.CommittedInstanceCount attribute."""
        return self.get_att("CommitmentInfo.CommittedInstanceCount")

    @property
    def attr_capacity_reservation_fleet_id(self) -> GetAtt:
        """Get the CapacityReservationFleetId attribute."""
        return self.get_att("CapacityReservationFleetId")

    @property
    def attr_availability_zone(self) -> GetAtt:
        """Get the AvailabilityZone attribute."""
        return self.get_att("AvailabilityZone")

    @property
    def attr_total_instance_count(self) -> GetAtt:
        """Get the TotalInstanceCount attribute."""
        return self.get_att("TotalInstanceCount")

    @property
    def attr_create_date(self) -> GetAtt:
        """Get the CreateDate attribute."""
        return self.get_att("CreateDate")

    @property
    def attr_start_date(self) -> GetAtt:
        """Get the StartDate attribute."""
        return self.get_att("StartDate")

    @property
    def attr_capacity_reservation_arn(self) -> GetAtt:
        """Get the CapacityReservationArn attribute."""
        return self.get_att("CapacityReservationArn")

    @property
    def attr_delivery_preference(self) -> GetAtt:
        """Get the DeliveryPreference attribute."""
        return self.get_att("DeliveryPreference")

    @property
    def attr_commitment_info(self) -> GetAtt:
        """Get the CommitmentInfo attribute."""
        return self.get_att("CommitmentInfo")

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_available_instance_count(self) -> GetAtt:
        """Get the AvailableInstanceCount attribute."""
        return self.get_att("AvailableInstanceCount")

    @property
    def attr_reservation_type(self) -> GetAtt:
        """Get the ReservationType attribute."""
        return self.get_att("ReservationType")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")

    @property
    def attr_capacity_allocation_set(self) -> GetAtt:
        """Get the CapacityAllocationSet attribute."""
        return self.get_att("CapacityAllocationSet")

    @property
    def attr_instance_type(self) -> GetAtt:
        """Get the InstanceType attribute."""
        return self.get_att("InstanceType")

    @property
    def attr_commitment_info__commitment_end_date(self) -> GetAtt:
        """Get the CommitmentInfo.CommitmentEndDate attribute."""
        return self.get_att("CommitmentInfo.CommitmentEndDate")




@dataclass
class InstanceTypeSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    priority: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_platform: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    weight: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs_optimized: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.priority is not None:
            if hasattr(self.priority, 'to_dict'):
                props['Priority'] = self.priority.to_dict()
            elif isinstance(self.priority, list):
                props['Priority'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.priority
                ]
            else:
                props['Priority'] = self.priority

        if self.availability_zone_id is not None:
            if hasattr(self.availability_zone_id, 'to_dict'):
                props['AvailabilityZoneId'] = self.availability_zone_id.to_dict()
            elif isinstance(self.availability_zone_id, list):
                props['AvailabilityZoneId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone_id
                ]
            else:
                props['AvailabilityZoneId'] = self.availability_zone_id

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        if self.instance_platform is not None:
            if hasattr(self.instance_platform, 'to_dict'):
                props['InstancePlatform'] = self.instance_platform.to_dict()
            elif isinstance(self.instance_platform, list):
                props['InstancePlatform'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_platform
                ]
            else:
                props['InstancePlatform'] = self.instance_platform

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        if self.weight is not None:
            if hasattr(self.weight, 'to_dict'):
                props['Weight'] = self.weight.to_dict()
            elif isinstance(self.weight, list):
                props['Weight'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weight
                ]
            else:
                props['Weight'] = self.weight

        if self.ebs_optimized is not None:
            if hasattr(self.ebs_optimized, 'to_dict'):
                props['EbsOptimized'] = self.ebs_optimized.to_dict()
            elif isinstance(self.ebs_optimized, list):
                props['EbsOptimized'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_optimized
                ]
            else:
                props['EbsOptimized'] = self.ebs_optimized

        return props


@dataclass
class TagSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tags: Optional[list[Tag]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        if self.tags is not None:
            if hasattr(self.tags, 'to_dict'):
                props['Tags'] = self.tags.to_dict()
            elif isinstance(self.tags, list):
                props['Tags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tags
                ]
            else:
                props['Tags'] = self.tags

        return props


@dataclass
class CapacityReservationFleet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::CapacityReservationFleet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tenancy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    total_target_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allocation_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tag_specifications: Optional[list[TagSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    no_remove_end_date: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_type_specifications: Optional[list[InstanceTypeSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    remove_end_date: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_match_criteria: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    end_date: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.tenancy is not None:
            # Serialize tenancy (handle intrinsic functions)
            if hasattr(self.tenancy, 'to_dict'):
                props["Tenancy"] = self.tenancy.to_dict()
            elif isinstance(self.tenancy, list):
                # Serialize list items (may contain intrinsic functions)
                props['Tenancy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tenancy
                ]
            else:
                props["Tenancy"] = self.tenancy

        if self.total_target_capacity is not None:
            # Serialize total_target_capacity (handle intrinsic functions)
            if hasattr(self.total_target_capacity, 'to_dict'):
                props["TotalTargetCapacity"] = self.total_target_capacity.to_dict()
            elif isinstance(self.total_target_capacity, list):
                # Serialize list items (may contain intrinsic functions)
                props['TotalTargetCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_target_capacity
                ]
            else:
                props["TotalTargetCapacity"] = self.total_target_capacity

        if self.allocation_strategy is not None:
            # Serialize allocation_strategy (handle intrinsic functions)
            if hasattr(self.allocation_strategy, 'to_dict'):
                props["AllocationStrategy"] = self.allocation_strategy.to_dict()
            elif isinstance(self.allocation_strategy, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllocationStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_strategy
                ]
            else:
                props["AllocationStrategy"] = self.allocation_strategy

        if self.tag_specifications is not None:
            # Serialize tag_specifications (handle intrinsic functions)
            if hasattr(self.tag_specifications, 'to_dict'):
                props["TagSpecifications"] = self.tag_specifications.to_dict()
            elif isinstance(self.tag_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['TagSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_specifications
                ]
            else:
                props["TagSpecifications"] = self.tag_specifications

        if self.no_remove_end_date is not None:
            # Serialize no_remove_end_date (handle intrinsic functions)
            if hasattr(self.no_remove_end_date, 'to_dict'):
                props["NoRemoveEndDate"] = self.no_remove_end_date.to_dict()
            elif isinstance(self.no_remove_end_date, list):
                # Serialize list items (may contain intrinsic functions)
                props['NoRemoveEndDate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.no_remove_end_date
                ]
            else:
                props["NoRemoveEndDate"] = self.no_remove_end_date

        if self.instance_type_specifications is not None:
            # Serialize instance_type_specifications (handle intrinsic functions)
            if hasattr(self.instance_type_specifications, 'to_dict'):
                props["InstanceTypeSpecifications"] = self.instance_type_specifications.to_dict()
            elif isinstance(self.instance_type_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceTypeSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type_specifications
                ]
            else:
                props["InstanceTypeSpecifications"] = self.instance_type_specifications

        if self.remove_end_date is not None:
            # Serialize remove_end_date (handle intrinsic functions)
            if hasattr(self.remove_end_date, 'to_dict'):
                props["RemoveEndDate"] = self.remove_end_date.to_dict()
            elif isinstance(self.remove_end_date, list):
                # Serialize list items (may contain intrinsic functions)
                props['RemoveEndDate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.remove_end_date
                ]
            else:
                props["RemoveEndDate"] = self.remove_end_date

        if self.instance_match_criteria is not None:
            # Serialize instance_match_criteria (handle intrinsic functions)
            if hasattr(self.instance_match_criteria, 'to_dict'):
                props["InstanceMatchCriteria"] = self.instance_match_criteria.to_dict()
            elif isinstance(self.instance_match_criteria, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceMatchCriteria'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_match_criteria
                ]
            else:
                props["InstanceMatchCriteria"] = self.instance_match_criteria

        if self.end_date is not None:
            # Serialize end_date (handle intrinsic functions)
            if hasattr(self.end_date, 'to_dict'):
                props["EndDate"] = self.end_date.to_dict()
            elif isinstance(self.end_date, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndDate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.end_date
                ]
            else:
                props["EndDate"] = self.end_date

        return props

    @property
    def attr_capacity_reservation_fleet_id(self) -> GetAtt:
        """Get the CapacityReservationFleetId attribute."""
        return self.get_att("CapacityReservationFleetId")




@dataclass
class CarrierGateway(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::CarrierGateway"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_carrier_gateway_id(self) -> GetAtt:
        """Get the CarrierGatewayId attribute."""
        return self.get_att("CarrierGatewayId")




@dataclass
class ClientVpnAuthorizationRule(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::ClientVpnAuthorizationRule"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_vpn_endpoint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    access_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_network_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    authorize_all_groups: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.client_vpn_endpoint_id is not None:
            # Serialize client_vpn_endpoint_id (handle intrinsic functions)
            if hasattr(self.client_vpn_endpoint_id, 'to_dict'):
                props["ClientVpnEndpointId"] = self.client_vpn_endpoint_id.to_dict()
            elif isinstance(self.client_vpn_endpoint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientVpnEndpointId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_vpn_endpoint_id
                ]
            else:
                props["ClientVpnEndpointId"] = self.client_vpn_endpoint_id

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.access_group_id is not None:
            # Serialize access_group_id (handle intrinsic functions)
            if hasattr(self.access_group_id, 'to_dict'):
                props["AccessGroupId"] = self.access_group_id.to_dict()
            elif isinstance(self.access_group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AccessGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.access_group_id
                ]
            else:
                props["AccessGroupId"] = self.access_group_id

        if self.target_network_cidr is not None:
            # Serialize target_network_cidr (handle intrinsic functions)
            if hasattr(self.target_network_cidr, 'to_dict'):
                props["TargetNetworkCidr"] = self.target_network_cidr.to_dict()
            elif isinstance(self.target_network_cidr, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetNetworkCidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_network_cidr
                ]
            else:
                props["TargetNetworkCidr"] = self.target_network_cidr

        if self.authorize_all_groups is not None:
            # Serialize authorize_all_groups (handle intrinsic functions)
            if hasattr(self.authorize_all_groups, 'to_dict'):
                props["AuthorizeAllGroups"] = self.authorize_all_groups.to_dict()
            elif isinstance(self.authorize_all_groups, list):
                # Serialize list items (may contain intrinsic functions)
                props['AuthorizeAllGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.authorize_all_groups
                ]
            else:
                props["AuthorizeAllGroups"] = self.authorize_all_groups

        return props



@dataclass
class CertificateAuthenticationRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    client_root_certificate_chain_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.client_root_certificate_chain_arn is not None:
            if hasattr(self.client_root_certificate_chain_arn, 'to_dict'):
                props['ClientRootCertificateChainArn'] = self.client_root_certificate_chain_arn.to_dict()
            elif isinstance(self.client_root_certificate_chain_arn, list):
                props['ClientRootCertificateChainArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_root_certificate_chain_arn
                ]
            else:
                props['ClientRootCertificateChainArn'] = self.client_root_certificate_chain_arn

        return props


@dataclass
class ClientAuthenticationRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mutual_authentication: Optional[CertificateAuthenticationRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    federated_authentication: Optional[FederatedAuthenticationRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    active_directory: Optional[DirectoryServiceAuthenticationRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mutual_authentication is not None:
            if hasattr(self.mutual_authentication, 'to_dict'):
                props['MutualAuthentication'] = self.mutual_authentication.to_dict()
            elif isinstance(self.mutual_authentication, list):
                props['MutualAuthentication'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mutual_authentication
                ]
            else:
                props['MutualAuthentication'] = self.mutual_authentication

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.federated_authentication is not None:
            if hasattr(self.federated_authentication, 'to_dict'):
                props['FederatedAuthentication'] = self.federated_authentication.to_dict()
            elif isinstance(self.federated_authentication, list):
                props['FederatedAuthentication'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.federated_authentication
                ]
            else:
                props['FederatedAuthentication'] = self.federated_authentication

        if self.active_directory is not None:
            if hasattr(self.active_directory, 'to_dict'):
                props['ActiveDirectory'] = self.active_directory.to_dict()
            elif isinstance(self.active_directory, list):
                props['ActiveDirectory'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.active_directory
                ]
            else:
                props['ActiveDirectory'] = self.active_directory

        return props


@dataclass
class ClientConnectOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lambda_function_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.lambda_function_arn is not None:
            if hasattr(self.lambda_function_arn, 'to_dict'):
                props['LambdaFunctionArn'] = self.lambda_function_arn.to_dict()
            elif isinstance(self.lambda_function_arn, list):
                props['LambdaFunctionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lambda_function_arn
                ]
            else:
                props['LambdaFunctionArn'] = self.lambda_function_arn

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class ClientLoginBannerOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    banner_text: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        if self.banner_text is not None:
            if hasattr(self.banner_text, 'to_dict'):
                props['BannerText'] = self.banner_text.to_dict()
            elif isinstance(self.banner_text, list):
                props['BannerText'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.banner_text
                ]
            else:
                props['BannerText'] = self.banner_text

        return props


@dataclass
class ClientRouteEnforcementOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enforced: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enforced is not None:
            if hasattr(self.enforced, 'to_dict'):
                props['Enforced'] = self.enforced.to_dict()
            elif isinstance(self.enforced, list):
                props['Enforced'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enforced
                ]
            else:
                props['Enforced'] = self.enforced

        return props


@dataclass
class ConnectionLogOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloudwatch_log_stream: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloudwatch_log_group: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cloudwatch_log_stream is not None:
            if hasattr(self.cloudwatch_log_stream, 'to_dict'):
                props['CloudwatchLogStream'] = self.cloudwatch_log_stream.to_dict()
            elif isinstance(self.cloudwatch_log_stream, list):
                props['CloudwatchLogStream'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cloudwatch_log_stream
                ]
            else:
                props['CloudwatchLogStream'] = self.cloudwatch_log_stream

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        if self.cloudwatch_log_group is not None:
            if hasattr(self.cloudwatch_log_group, 'to_dict'):
                props['CloudwatchLogGroup'] = self.cloudwatch_log_group.to_dict()
            elif isinstance(self.cloudwatch_log_group, list):
                props['CloudwatchLogGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cloudwatch_log_group
                ]
            else:
                props['CloudwatchLogGroup'] = self.cloudwatch_log_group

        return props


@dataclass
class DirectoryServiceAuthenticationRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    directory_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.directory_id is not None:
            if hasattr(self.directory_id, 'to_dict'):
                props['DirectoryId'] = self.directory_id.to_dict()
            elif isinstance(self.directory_id, list):
                props['DirectoryId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.directory_id
                ]
            else:
                props['DirectoryId'] = self.directory_id

        return props


@dataclass
class FederatedAuthenticationRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    self_service_saml_provider_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    saml_provider_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.self_service_saml_provider_arn is not None:
            if hasattr(self.self_service_saml_provider_arn, 'to_dict'):
                props['SelfServiceSAMLProviderArn'] = self.self_service_saml_provider_arn.to_dict()
            elif isinstance(self.self_service_saml_provider_arn, list):
                props['SelfServiceSAMLProviderArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.self_service_saml_provider_arn
                ]
            else:
                props['SelfServiceSAMLProviderArn'] = self.self_service_saml_provider_arn

        if self.saml_provider_arn is not None:
            if hasattr(self.saml_provider_arn, 'to_dict'):
                props['SAMLProviderArn'] = self.saml_provider_arn.to_dict()
            elif isinstance(self.saml_provider_arn, list):
                props['SAMLProviderArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.saml_provider_arn
                ]
            else:
                props['SAMLProviderArn'] = self.saml_provider_arn

        return props


@dataclass
class TagSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tags: Optional[list[Tag]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        if self.tags is not None:
            if hasattr(self.tags, 'to_dict'):
                props['Tags'] = self.tags.to_dict()
            elif isinstance(self.tags, list):
                props['Tags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tags
                ]
            else:
                props['Tags'] = self.tags

        return props


@dataclass
class ClientVpnEndpoint(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::ClientVpnEndpoint"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_connect_options: Optional[ClientConnectOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_route_enforcement_options: Optional[ClientRouteEnforcementOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tag_specifications: Optional[list[TagSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    authentication_options: Optional[list[ClientAuthenticationRequest]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    server_certificate_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    session_timeout_hours: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    dns_servers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    disconnect_on_session_timeout: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connection_log_options: Optional[ConnectionLogOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    split_tunnel: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_login_banner_options: Optional[ClientLoginBannerOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    self_service_portal: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transport_protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpn_port: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.client_cidr_block is not None:
            # Serialize client_cidr_block (handle intrinsic functions)
            if hasattr(self.client_cidr_block, 'to_dict'):
                props["ClientCidrBlock"] = self.client_cidr_block.to_dict()
            elif isinstance(self.client_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_cidr_block
                ]
            else:
                props["ClientCidrBlock"] = self.client_cidr_block

        if self.client_connect_options is not None:
            # Serialize client_connect_options (handle intrinsic functions)
            if hasattr(self.client_connect_options, 'to_dict'):
                props["ClientConnectOptions"] = self.client_connect_options.to_dict()
            elif isinstance(self.client_connect_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientConnectOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_connect_options
                ]
            else:
                props["ClientConnectOptions"] = self.client_connect_options

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.client_route_enforcement_options is not None:
            # Serialize client_route_enforcement_options (handle intrinsic functions)
            if hasattr(self.client_route_enforcement_options, 'to_dict'):
                props["ClientRouteEnforcementOptions"] = self.client_route_enforcement_options.to_dict()
            elif isinstance(self.client_route_enforcement_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientRouteEnforcementOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_route_enforcement_options
                ]
            else:
                props["ClientRouteEnforcementOptions"] = self.client_route_enforcement_options

        if self.tag_specifications is not None:
            # Serialize tag_specifications (handle intrinsic functions)
            if hasattr(self.tag_specifications, 'to_dict'):
                props["TagSpecifications"] = self.tag_specifications.to_dict()
            elif isinstance(self.tag_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['TagSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_specifications
                ]
            else:
                props["TagSpecifications"] = self.tag_specifications

        if self.authentication_options is not None:
            # Serialize authentication_options (handle intrinsic functions)
            if hasattr(self.authentication_options, 'to_dict'):
                props["AuthenticationOptions"] = self.authentication_options.to_dict()
            elif isinstance(self.authentication_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['AuthenticationOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.authentication_options
                ]
            else:
                props["AuthenticationOptions"] = self.authentication_options

        if self.server_certificate_arn is not None:
            # Serialize server_certificate_arn (handle intrinsic functions)
            if hasattr(self.server_certificate_arn, 'to_dict'):
                props["ServerCertificateArn"] = self.server_certificate_arn.to_dict()
            elif isinstance(self.server_certificate_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServerCertificateArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.server_certificate_arn
                ]
            else:
                props["ServerCertificateArn"] = self.server_certificate_arn

        if self.session_timeout_hours is not None:
            # Serialize session_timeout_hours (handle intrinsic functions)
            if hasattr(self.session_timeout_hours, 'to_dict'):
                props["SessionTimeoutHours"] = self.session_timeout_hours.to_dict()
            elif isinstance(self.session_timeout_hours, list):
                # Serialize list items (may contain intrinsic functions)
                props['SessionTimeoutHours'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.session_timeout_hours
                ]
            else:
                props["SessionTimeoutHours"] = self.session_timeout_hours

        if self.dns_servers is not None:
            # Serialize dns_servers (handle intrinsic functions)
            if hasattr(self.dns_servers, 'to_dict'):
                props["DnsServers"] = self.dns_servers.to_dict()
            elif isinstance(self.dns_servers, list):
                # Serialize list items (may contain intrinsic functions)
                props['DnsServers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dns_servers
                ]
            else:
                props["DnsServers"] = self.dns_servers

        if self.security_group_ids is not None:
            # Serialize security_group_ids (handle intrinsic functions)
            if hasattr(self.security_group_ids, 'to_dict'):
                props["SecurityGroupIds"] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props["SecurityGroupIds"] = self.security_group_ids

        if self.disconnect_on_session_timeout is not None:
            # Serialize disconnect_on_session_timeout (handle intrinsic functions)
            if hasattr(self.disconnect_on_session_timeout, 'to_dict'):
                props["DisconnectOnSessionTimeout"] = self.disconnect_on_session_timeout.to_dict()
            elif isinstance(self.disconnect_on_session_timeout, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisconnectOnSessionTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disconnect_on_session_timeout
                ]
            else:
                props["DisconnectOnSessionTimeout"] = self.disconnect_on_session_timeout

        if self.connection_log_options is not None:
            # Serialize connection_log_options (handle intrinsic functions)
            if hasattr(self.connection_log_options, 'to_dict'):
                props["ConnectionLogOptions"] = self.connection_log_options.to_dict()
            elif isinstance(self.connection_log_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConnectionLogOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connection_log_options
                ]
            else:
                props["ConnectionLogOptions"] = self.connection_log_options

        if self.split_tunnel is not None:
            # Serialize split_tunnel (handle intrinsic functions)
            if hasattr(self.split_tunnel, 'to_dict'):
                props["SplitTunnel"] = self.split_tunnel.to_dict()
            elif isinstance(self.split_tunnel, list):
                # Serialize list items (may contain intrinsic functions)
                props['SplitTunnel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.split_tunnel
                ]
            else:
                props["SplitTunnel"] = self.split_tunnel

        if self.client_login_banner_options is not None:
            # Serialize client_login_banner_options (handle intrinsic functions)
            if hasattr(self.client_login_banner_options, 'to_dict'):
                props["ClientLoginBannerOptions"] = self.client_login_banner_options.to_dict()
            elif isinstance(self.client_login_banner_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientLoginBannerOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_login_banner_options
                ]
            else:
                props["ClientLoginBannerOptions"] = self.client_login_banner_options

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.self_service_portal is not None:
            # Serialize self_service_portal (handle intrinsic functions)
            if hasattr(self.self_service_portal, 'to_dict'):
                props["SelfServicePortal"] = self.self_service_portal.to_dict()
            elif isinstance(self.self_service_portal, list):
                # Serialize list items (may contain intrinsic functions)
                props['SelfServicePortal'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.self_service_portal
                ]
            else:
                props["SelfServicePortal"] = self.self_service_portal

        if self.transport_protocol is not None:
            # Serialize transport_protocol (handle intrinsic functions)
            if hasattr(self.transport_protocol, 'to_dict'):
                props["TransportProtocol"] = self.transport_protocol.to_dict()
            elif isinstance(self.transport_protocol, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransportProtocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transport_protocol
                ]
            else:
                props["TransportProtocol"] = self.transport_protocol

        if self.vpn_port is not None:
            # Serialize vpn_port (handle intrinsic functions)
            if hasattr(self.vpn_port, 'to_dict'):
                props["VpnPort"] = self.vpn_port.to_dict()
            elif isinstance(self.vpn_port, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpnPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_port
                ]
            else:
                props["VpnPort"] = self.vpn_port

        return props



@dataclass
class ClientVpnRoute(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::ClientVpnRoute"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_vpn_endpoint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_vpc_subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.client_vpn_endpoint_id is not None:
            # Serialize client_vpn_endpoint_id (handle intrinsic functions)
            if hasattr(self.client_vpn_endpoint_id, 'to_dict'):
                props["ClientVpnEndpointId"] = self.client_vpn_endpoint_id.to_dict()
            elif isinstance(self.client_vpn_endpoint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientVpnEndpointId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_vpn_endpoint_id
                ]
            else:
                props["ClientVpnEndpointId"] = self.client_vpn_endpoint_id

        if self.target_vpc_subnet_id is not None:
            # Serialize target_vpc_subnet_id (handle intrinsic functions)
            if hasattr(self.target_vpc_subnet_id, 'to_dict'):
                props["TargetVpcSubnetId"] = self.target_vpc_subnet_id.to_dict()
            elif isinstance(self.target_vpc_subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetVpcSubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_vpc_subnet_id
                ]
            else:
                props["TargetVpcSubnetId"] = self.target_vpc_subnet_id

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.destination_cidr_block is not None:
            # Serialize destination_cidr_block (handle intrinsic functions)
            if hasattr(self.destination_cidr_block, 'to_dict'):
                props["DestinationCidrBlock"] = self.destination_cidr_block.to_dict()
            elif isinstance(self.destination_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr_block
                ]
            else:
                props["DestinationCidrBlock"] = self.destination_cidr_block

        return props



@dataclass
class ClientVpnTargetNetworkAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::ClientVpnTargetNetworkAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_vpn_endpoint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.client_vpn_endpoint_id is not None:
            # Serialize client_vpn_endpoint_id (handle intrinsic functions)
            if hasattr(self.client_vpn_endpoint_id, 'to_dict'):
                props["ClientVpnEndpointId"] = self.client_vpn_endpoint_id.to_dict()
            elif isinstance(self.client_vpn_endpoint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientVpnEndpointId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_vpn_endpoint_id
                ]
            else:
                props["ClientVpnEndpointId"] = self.client_vpn_endpoint_id

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        return props



@dataclass
class CustomerGateway(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::CustomerGateway"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    bgp_asn_extended: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    bgp_asn: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    certificate_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    device_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.ip_address is not None:
            # Serialize ip_address (handle intrinsic functions)
            if hasattr(self.ip_address, 'to_dict'):
                props["IpAddress"] = self.ip_address.to_dict()
            elif isinstance(self.ip_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_address
                ]
            else:
                props["IpAddress"] = self.ip_address

        if self.bgp_asn_extended is not None:
            # Serialize bgp_asn_extended (handle intrinsic functions)
            if hasattr(self.bgp_asn_extended, 'to_dict'):
                props["BgpAsnExtended"] = self.bgp_asn_extended.to_dict()
            elif isinstance(self.bgp_asn_extended, list):
                # Serialize list items (may contain intrinsic functions)
                props['BgpAsnExtended'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bgp_asn_extended
                ]
            else:
                props["BgpAsnExtended"] = self.bgp_asn_extended

        if self.bgp_asn is not None:
            # Serialize bgp_asn (handle intrinsic functions)
            if hasattr(self.bgp_asn, 'to_dict'):
                props["BgpAsn"] = self.bgp_asn.to_dict()
            elif isinstance(self.bgp_asn, list):
                # Serialize list items (may contain intrinsic functions)
                props['BgpAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bgp_asn
                ]
            else:
                props["BgpAsn"] = self.bgp_asn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.certificate_arn is not None:
            # Serialize certificate_arn (handle intrinsic functions)
            if hasattr(self.certificate_arn, 'to_dict'):
                props["CertificateArn"] = self.certificate_arn.to_dict()
            elif isinstance(self.certificate_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['CertificateArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_arn
                ]
            else:
                props["CertificateArn"] = self.certificate_arn

        if self.device_name is not None:
            # Serialize device_name (handle intrinsic functions)
            if hasattr(self.device_name, 'to_dict'):
                props["DeviceName"] = self.device_name.to_dict()
            elif isinstance(self.device_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeviceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_name
                ]
            else:
                props["DeviceName"] = self.device_name

        return props

    @property
    def attr_customer_gateway_id(self) -> GetAtt:
        """Get the CustomerGatewayId attribute."""
        return self.get_att("CustomerGatewayId")




@dataclass
class DHCPOptions(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-d"""

    resource_type: ClassVar[str] = "AWS::EC2::DHCPOptions"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    netbios_name_servers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ntp_servers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_address_preferred_lease_time: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    netbios_node_type: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_name_servers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.netbios_name_servers is not None:
            # Serialize netbios_name_servers (handle intrinsic functions)
            if hasattr(self.netbios_name_servers, 'to_dict'):
                props["NetbiosNameServers"] = self.netbios_name_servers.to_dict()
            elif isinstance(self.netbios_name_servers, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetbiosNameServers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.netbios_name_servers
                ]
            else:
                props["NetbiosNameServers"] = self.netbios_name_servers

        if self.ntp_servers is not None:
            # Serialize ntp_servers (handle intrinsic functions)
            if hasattr(self.ntp_servers, 'to_dict'):
                props["NtpServers"] = self.ntp_servers.to_dict()
            elif isinstance(self.ntp_servers, list):
                # Serialize list items (may contain intrinsic functions)
                props['NtpServers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ntp_servers
                ]
            else:
                props["NtpServers"] = self.ntp_servers

        if self.domain_name is not None:
            # Serialize domain_name (handle intrinsic functions)
            if hasattr(self.domain_name, 'to_dict'):
                props["DomainName"] = self.domain_name.to_dict()
            elif isinstance(self.domain_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_name
                ]
            else:
                props["DomainName"] = self.domain_name

        if self.ipv6_address_preferred_lease_time is not None:
            # Serialize ipv6_address_preferred_lease_time (handle intrinsic functions)
            if hasattr(self.ipv6_address_preferred_lease_time, 'to_dict'):
                props["Ipv6AddressPreferredLeaseTime"] = self.ipv6_address_preferred_lease_time.to_dict()
            elif isinstance(self.ipv6_address_preferred_lease_time, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6AddressPreferredLeaseTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address_preferred_lease_time
                ]
            else:
                props["Ipv6AddressPreferredLeaseTime"] = self.ipv6_address_preferred_lease_time

        if self.netbios_node_type is not None:
            # Serialize netbios_node_type (handle intrinsic functions)
            if hasattr(self.netbios_node_type, 'to_dict'):
                props["NetbiosNodeType"] = self.netbios_node_type.to_dict()
            elif isinstance(self.netbios_node_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetbiosNodeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.netbios_node_type
                ]
            else:
                props["NetbiosNodeType"] = self.netbios_node_type

        if self.domain_name_servers is not None:
            # Serialize domain_name_servers (handle intrinsic functions)
            if hasattr(self.domain_name_servers, 'to_dict'):
                props["DomainNameServers"] = self.domain_name_servers.to_dict()
            elif isinstance(self.domain_name_servers, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainNameServers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_name_servers
                ]
            else:
                props["DomainNameServers"] = self.domain_name_servers

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_dhcp_options_id(self) -> GetAtt:
        """Get the DhcpOptionsId attribute."""
        return self.get_att("DhcpOptionsId")




@dataclass
class AcceleratorCountRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class AcceleratorTotalMemoryMiBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class BaselineEbsBandwidthMbpsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class BaselinePerformanceFactorsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu: Optional[CpuPerformanceFactorRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cpu is not None:
            if hasattr(self.cpu, 'to_dict'):
                props['Cpu'] = self.cpu.to_dict()
            elif isinstance(self.cpu, list):
                props['Cpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu
                ]
            else:
                props['Cpu'] = self.cpu

        return props


@dataclass
class BlockDeviceMapping:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs: Optional[EbsBlockDevice] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    no_device: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    virtual_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ebs is not None:
            if hasattr(self.ebs, 'to_dict'):
                props['Ebs'] = self.ebs.to_dict()
            elif isinstance(self.ebs, list):
                props['Ebs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs
                ]
            else:
                props['Ebs'] = self.ebs

        if self.no_device is not None:
            if hasattr(self.no_device, 'to_dict'):
                props['NoDevice'] = self.no_device.to_dict()
            elif isinstance(self.no_device, list):
                props['NoDevice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.no_device
                ]
            else:
                props['NoDevice'] = self.no_device

        if self.virtual_name is not None:
            if hasattr(self.virtual_name, 'to_dict'):
                props['VirtualName'] = self.virtual_name.to_dict()
            elif isinstance(self.virtual_name, list):
                props['VirtualName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.virtual_name
                ]
            else:
                props['VirtualName'] = self.virtual_name

        if self.device_name is not None:
            if hasattr(self.device_name, 'to_dict'):
                props['DeviceName'] = self.device_name.to_dict()
            elif isinstance(self.device_name, list):
                props['DeviceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_name
                ]
            else:
                props['DeviceName'] = self.device_name

        return props


@dataclass
class CapacityRebalance:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    termination_delay: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    replacement_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.termination_delay is not None:
            if hasattr(self.termination_delay, 'to_dict'):
                props['TerminationDelay'] = self.termination_delay.to_dict()
            elif isinstance(self.termination_delay, list):
                props['TerminationDelay'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.termination_delay
                ]
            else:
                props['TerminationDelay'] = self.termination_delay

        if self.replacement_strategy is not None:
            if hasattr(self.replacement_strategy, 'to_dict'):
                props['ReplacementStrategy'] = self.replacement_strategy.to_dict()
            elif isinstance(self.replacement_strategy, list):
                props['ReplacementStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.replacement_strategy
                ]
            else:
                props['ReplacementStrategy'] = self.replacement_strategy

        return props


@dataclass
class CapacityReservationOptionsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    usage_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.usage_strategy is not None:
            if hasattr(self.usage_strategy, 'to_dict'):
                props['UsageStrategy'] = self.usage_strategy.to_dict()
            elif isinstance(self.usage_strategy, list):
                props['UsageStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.usage_strategy
                ]
            else:
                props['UsageStrategy'] = self.usage_strategy

        return props


@dataclass
class CpuPerformanceFactorRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    references: Optional[list[PerformanceFactorReferenceRequest]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.references is not None:
            if hasattr(self.references, 'to_dict'):
                props['References'] = self.references.to_dict()
            elif isinstance(self.references, list):
                props['References'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.references
                ]
            else:
                props['References'] = self.references

        return props


@dataclass
class EbsBlockDevice:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snapshot_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encrypted: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.snapshot_id is not None:
            if hasattr(self.snapshot_id, 'to_dict'):
                props['SnapshotId'] = self.snapshot_id.to_dict()
            elif isinstance(self.snapshot_id, list):
                props['SnapshotId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snapshot_id
                ]
            else:
                props['SnapshotId'] = self.snapshot_id

        if self.volume_type is not None:
            if hasattr(self.volume_type, 'to_dict'):
                props['VolumeType'] = self.volume_type.to_dict()
            elif isinstance(self.volume_type, list):
                props['VolumeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_type
                ]
            else:
                props['VolumeType'] = self.volume_type

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.encrypted is not None:
            if hasattr(self.encrypted, 'to_dict'):
                props['Encrypted'] = self.encrypted.to_dict()
            elif isinstance(self.encrypted, list):
                props['Encrypted'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encrypted
                ]
            else:
                props['Encrypted'] = self.encrypted

        if self.iops is not None:
            if hasattr(self.iops, 'to_dict'):
                props['Iops'] = self.iops.to_dict()
            elif isinstance(self.iops, list):
                props['Iops'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iops
                ]
            else:
                props['Iops'] = self.iops

        if self.volume_size is not None:
            if hasattr(self.volume_size, 'to_dict'):
                props['VolumeSize'] = self.volume_size.to_dict()
            elif isinstance(self.volume_size, list):
                props['VolumeSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size
                ]
            else:
                props['VolumeSize'] = self.volume_size

        if self.delete_on_termination is not None:
            if hasattr(self.delete_on_termination, 'to_dict'):
                props['DeleteOnTermination'] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props['DeleteOnTermination'] = self.delete_on_termination

        return props


@dataclass
class FleetLaunchTemplateConfigRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_specification: Optional[FleetLaunchTemplateSpecificationRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    overrides: Optional[list[FleetLaunchTemplateOverridesRequest]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.launch_template_specification is not None:
            if hasattr(self.launch_template_specification, 'to_dict'):
                props['LaunchTemplateSpecification'] = self.launch_template_specification.to_dict()
            elif isinstance(self.launch_template_specification, list):
                props['LaunchTemplateSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_specification
                ]
            else:
                props['LaunchTemplateSpecification'] = self.launch_template_specification

        if self.overrides is not None:
            if hasattr(self.overrides, 'to_dict'):
                props['Overrides'] = self.overrides.to_dict()
            elif isinstance(self.overrides, list):
                props['Overrides'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.overrides
                ]
            else:
                props['Overrides'] = self.overrides

        return props


@dataclass
class FleetLaunchTemplateOverridesRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    weighted_capacity: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    placement: Optional[Placement] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    priority: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    block_device_mappings: Optional[list[BlockDeviceMapping]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_requirements: Optional[InstanceRequirementsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_price: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.weighted_capacity is not None:
            if hasattr(self.weighted_capacity, 'to_dict'):
                props['WeightedCapacity'] = self.weighted_capacity.to_dict()
            elif isinstance(self.weighted_capacity, list):
                props['WeightedCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weighted_capacity
                ]
            else:
                props['WeightedCapacity'] = self.weighted_capacity

        if self.placement is not None:
            if hasattr(self.placement, 'to_dict'):
                props['Placement'] = self.placement.to_dict()
            elif isinstance(self.placement, list):
                props['Placement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.placement
                ]
            else:
                props['Placement'] = self.placement

        if self.priority is not None:
            if hasattr(self.priority, 'to_dict'):
                props['Priority'] = self.priority.to_dict()
            elif isinstance(self.priority, list):
                props['Priority'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.priority
                ]
            else:
                props['Priority'] = self.priority

        if self.block_device_mappings is not None:
            if hasattr(self.block_device_mappings, 'to_dict'):
                props['BlockDeviceMappings'] = self.block_device_mappings.to_dict()
            elif isinstance(self.block_device_mappings, list):
                props['BlockDeviceMappings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.block_device_mappings
                ]
            else:
                props['BlockDeviceMappings'] = self.block_device_mappings

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        if self.subnet_id is not None:
            if hasattr(self.subnet_id, 'to_dict'):
                props['SubnetId'] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props['SubnetId'] = self.subnet_id

        if self.instance_requirements is not None:
            if hasattr(self.instance_requirements, 'to_dict'):
                props['InstanceRequirements'] = self.instance_requirements.to_dict()
            elif isinstance(self.instance_requirements, list):
                props['InstanceRequirements'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_requirements
                ]
            else:
                props['InstanceRequirements'] = self.instance_requirements

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        if self.max_price is not None:
            if hasattr(self.max_price, 'to_dict'):
                props['MaxPrice'] = self.max_price.to_dict()
            elif isinstance(self.max_price, list):
                props['MaxPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_price
                ]
            else:
                props['MaxPrice'] = self.max_price

        return props


@dataclass
class FleetLaunchTemplateSpecificationRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.launch_template_name is not None:
            if hasattr(self.launch_template_name, 'to_dict'):
                props['LaunchTemplateName'] = self.launch_template_name.to_dict()
            elif isinstance(self.launch_template_name, list):
                props['LaunchTemplateName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_name
                ]
            else:
                props['LaunchTemplateName'] = self.launch_template_name

        if self.version is not None:
            if hasattr(self.version, 'to_dict'):
                props['Version'] = self.version.to_dict()
            elif isinstance(self.version, list):
                props['Version'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version
                ]
            else:
                props['Version'] = self.version

        if self.launch_template_id is not None:
            if hasattr(self.launch_template_id, 'to_dict'):
                props['LaunchTemplateId'] = self.launch_template_id.to_dict()
            elif isinstance(self.launch_template_id, list):
                props['LaunchTemplateId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_id
                ]
            else:
                props['LaunchTemplateId'] = self.launch_template_id

        return props


@dataclass
class InstanceRequirementsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_generations: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    require_encryption_in_transit: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_gi_b_per_v_cpu: Optional[MemoryGiBPerVCpuRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    v_cpu_count: Optional[VCpuCountRangeRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_manufacturers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_storage: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_manufacturers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bare_metal: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    require_hibernate_support: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_max_price_percentage_over_lowest_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_mi_b: Optional[MemoryMiBRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_storage_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_count: Optional[NetworkInterfaceCountRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    excluded_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allowed_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_bandwidth_gbps: Optional[NetworkBandwidthGbpsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_count: Optional[AcceleratorCountRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_performance_factors: Optional[BaselinePerformanceFactorsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_max_price_percentage_over_lowest_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_ebs_bandwidth_mbps: Optional[BaselineEbsBandwidthMbpsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_total_memory_mi_b: Optional[AcceleratorTotalMemoryMiBRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    burstable_performance: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    total_local_storage_gb: Optional[TotalLocalStorageGBRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_generations is not None:
            if hasattr(self.instance_generations, 'to_dict'):
                props['InstanceGenerations'] = self.instance_generations.to_dict()
            elif isinstance(self.instance_generations, list):
                props['InstanceGenerations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_generations
                ]
            else:
                props['InstanceGenerations'] = self.instance_generations

        if self.require_encryption_in_transit is not None:
            if hasattr(self.require_encryption_in_transit, 'to_dict'):
                props['RequireEncryptionInTransit'] = self.require_encryption_in_transit.to_dict()
            elif isinstance(self.require_encryption_in_transit, list):
                props['RequireEncryptionInTransit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.require_encryption_in_transit
                ]
            else:
                props['RequireEncryptionInTransit'] = self.require_encryption_in_transit

        if self.memory_gi_b_per_v_cpu is not None:
            if hasattr(self.memory_gi_b_per_v_cpu, 'to_dict'):
                props['MemoryGiBPerVCpu'] = self.memory_gi_b_per_v_cpu.to_dict()
            elif isinstance(self.memory_gi_b_per_v_cpu, list):
                props['MemoryGiBPerVCpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_gi_b_per_v_cpu
                ]
            else:
                props['MemoryGiBPerVCpu'] = self.memory_gi_b_per_v_cpu

        if self.accelerator_types is not None:
            if hasattr(self.accelerator_types, 'to_dict'):
                props['AcceleratorTypes'] = self.accelerator_types.to_dict()
            elif isinstance(self.accelerator_types, list):
                props['AcceleratorTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_types
                ]
            else:
                props['AcceleratorTypes'] = self.accelerator_types

        if self.v_cpu_count is not None:
            if hasattr(self.v_cpu_count, 'to_dict'):
                props['VCpuCount'] = self.v_cpu_count.to_dict()
            elif isinstance(self.v_cpu_count, list):
                props['VCpuCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.v_cpu_count
                ]
            else:
                props['VCpuCount'] = self.v_cpu_count

        if self.accelerator_manufacturers is not None:
            if hasattr(self.accelerator_manufacturers, 'to_dict'):
                props['AcceleratorManufacturers'] = self.accelerator_manufacturers.to_dict()
            elif isinstance(self.accelerator_manufacturers, list):
                props['AcceleratorManufacturers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_manufacturers
                ]
            else:
                props['AcceleratorManufacturers'] = self.accelerator_manufacturers

        if self.local_storage is not None:
            if hasattr(self.local_storage, 'to_dict'):
                props['LocalStorage'] = self.local_storage.to_dict()
            elif isinstance(self.local_storage, list):
                props['LocalStorage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_storage
                ]
            else:
                props['LocalStorage'] = self.local_storage

        if self.cpu_manufacturers is not None:
            if hasattr(self.cpu_manufacturers, 'to_dict'):
                props['CpuManufacturers'] = self.cpu_manufacturers.to_dict()
            elif isinstance(self.cpu_manufacturers, list):
                props['CpuManufacturers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_manufacturers
                ]
            else:
                props['CpuManufacturers'] = self.cpu_manufacturers

        if self.bare_metal is not None:
            if hasattr(self.bare_metal, 'to_dict'):
                props['BareMetal'] = self.bare_metal.to_dict()
            elif isinstance(self.bare_metal, list):
                props['BareMetal'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bare_metal
                ]
            else:
                props['BareMetal'] = self.bare_metal

        if self.require_hibernate_support is not None:
            if hasattr(self.require_hibernate_support, 'to_dict'):
                props['RequireHibernateSupport'] = self.require_hibernate_support.to_dict()
            elif isinstance(self.require_hibernate_support, list):
                props['RequireHibernateSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.require_hibernate_support
                ]
            else:
                props['RequireHibernateSupport'] = self.require_hibernate_support

        if self.max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            if hasattr(self.max_spot_price_as_percentage_of_optimal_on_demand_price, 'to_dict'):
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = self.max_spot_price_as_percentage_of_optimal_on_demand_price.to_dict()
            elif isinstance(self.max_spot_price_as_percentage_of_optimal_on_demand_price, list):
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_spot_price_as_percentage_of_optimal_on_demand_price
                ]
            else:
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = self.max_spot_price_as_percentage_of_optimal_on_demand_price

        if self.on_demand_max_price_percentage_over_lowest_price is not None:
            if hasattr(self.on_demand_max_price_percentage_over_lowest_price, 'to_dict'):
                props['OnDemandMaxPricePercentageOverLowestPrice'] = self.on_demand_max_price_percentage_over_lowest_price.to_dict()
            elif isinstance(self.on_demand_max_price_percentage_over_lowest_price, list):
                props['OnDemandMaxPricePercentageOverLowestPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_max_price_percentage_over_lowest_price
                ]
            else:
                props['OnDemandMaxPricePercentageOverLowestPrice'] = self.on_demand_max_price_percentage_over_lowest_price

        if self.memory_mi_b is not None:
            if hasattr(self.memory_mi_b, 'to_dict'):
                props['MemoryMiB'] = self.memory_mi_b.to_dict()
            elif isinstance(self.memory_mi_b, list):
                props['MemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_mi_b
                ]
            else:
                props['MemoryMiB'] = self.memory_mi_b

        if self.local_storage_types is not None:
            if hasattr(self.local_storage_types, 'to_dict'):
                props['LocalStorageTypes'] = self.local_storage_types.to_dict()
            elif isinstance(self.local_storage_types, list):
                props['LocalStorageTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_storage_types
                ]
            else:
                props['LocalStorageTypes'] = self.local_storage_types

        if self.network_interface_count is not None:
            if hasattr(self.network_interface_count, 'to_dict'):
                props['NetworkInterfaceCount'] = self.network_interface_count.to_dict()
            elif isinstance(self.network_interface_count, list):
                props['NetworkInterfaceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_count
                ]
            else:
                props['NetworkInterfaceCount'] = self.network_interface_count

        if self.excluded_instance_types is not None:
            if hasattr(self.excluded_instance_types, 'to_dict'):
                props['ExcludedInstanceTypes'] = self.excluded_instance_types.to_dict()
            elif isinstance(self.excluded_instance_types, list):
                props['ExcludedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.excluded_instance_types
                ]
            else:
                props['ExcludedInstanceTypes'] = self.excluded_instance_types

        if self.allowed_instance_types is not None:
            if hasattr(self.allowed_instance_types, 'to_dict'):
                props['AllowedInstanceTypes'] = self.allowed_instance_types.to_dict()
            elif isinstance(self.allowed_instance_types, list):
                props['AllowedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_instance_types
                ]
            else:
                props['AllowedInstanceTypes'] = self.allowed_instance_types

        if self.network_bandwidth_gbps is not None:
            if hasattr(self.network_bandwidth_gbps, 'to_dict'):
                props['NetworkBandwidthGbps'] = self.network_bandwidth_gbps.to_dict()
            elif isinstance(self.network_bandwidth_gbps, list):
                props['NetworkBandwidthGbps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_bandwidth_gbps
                ]
            else:
                props['NetworkBandwidthGbps'] = self.network_bandwidth_gbps

        if self.accelerator_count is not None:
            if hasattr(self.accelerator_count, 'to_dict'):
                props['AcceleratorCount'] = self.accelerator_count.to_dict()
            elif isinstance(self.accelerator_count, list):
                props['AcceleratorCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_count
                ]
            else:
                props['AcceleratorCount'] = self.accelerator_count

        if self.baseline_performance_factors is not None:
            if hasattr(self.baseline_performance_factors, 'to_dict'):
                props['BaselinePerformanceFactors'] = self.baseline_performance_factors.to_dict()
            elif isinstance(self.baseline_performance_factors, list):
                props['BaselinePerformanceFactors'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baseline_performance_factors
                ]
            else:
                props['BaselinePerformanceFactors'] = self.baseline_performance_factors

        if self.spot_max_price_percentage_over_lowest_price is not None:
            if hasattr(self.spot_max_price_percentage_over_lowest_price, 'to_dict'):
                props['SpotMaxPricePercentageOverLowestPrice'] = self.spot_max_price_percentage_over_lowest_price.to_dict()
            elif isinstance(self.spot_max_price_percentage_over_lowest_price, list):
                props['SpotMaxPricePercentageOverLowestPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_max_price_percentage_over_lowest_price
                ]
            else:
                props['SpotMaxPricePercentageOverLowestPrice'] = self.spot_max_price_percentage_over_lowest_price

        if self.baseline_ebs_bandwidth_mbps is not None:
            if hasattr(self.baseline_ebs_bandwidth_mbps, 'to_dict'):
                props['BaselineEbsBandwidthMbps'] = self.baseline_ebs_bandwidth_mbps.to_dict()
            elif isinstance(self.baseline_ebs_bandwidth_mbps, list):
                props['BaselineEbsBandwidthMbps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baseline_ebs_bandwidth_mbps
                ]
            else:
                props['BaselineEbsBandwidthMbps'] = self.baseline_ebs_bandwidth_mbps

        if self.accelerator_names is not None:
            if hasattr(self.accelerator_names, 'to_dict'):
                props['AcceleratorNames'] = self.accelerator_names.to_dict()
            elif isinstance(self.accelerator_names, list):
                props['AcceleratorNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_names
                ]
            else:
                props['AcceleratorNames'] = self.accelerator_names

        if self.accelerator_total_memory_mi_b is not None:
            if hasattr(self.accelerator_total_memory_mi_b, 'to_dict'):
                props['AcceleratorTotalMemoryMiB'] = self.accelerator_total_memory_mi_b.to_dict()
            elif isinstance(self.accelerator_total_memory_mi_b, list):
                props['AcceleratorTotalMemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_total_memory_mi_b
                ]
            else:
                props['AcceleratorTotalMemoryMiB'] = self.accelerator_total_memory_mi_b

        if self.burstable_performance is not None:
            if hasattr(self.burstable_performance, 'to_dict'):
                props['BurstablePerformance'] = self.burstable_performance.to_dict()
            elif isinstance(self.burstable_performance, list):
                props['BurstablePerformance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.burstable_performance
                ]
            else:
                props['BurstablePerformance'] = self.burstable_performance

        if self.total_local_storage_gb is not None:
            if hasattr(self.total_local_storage_gb, 'to_dict'):
                props['TotalLocalStorageGB'] = self.total_local_storage_gb.to_dict()
            elif isinstance(self.total_local_storage_gb, list):
                props['TotalLocalStorageGB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_local_storage_gb
                ]
            else:
                props['TotalLocalStorageGB'] = self.total_local_storage_gb

        return props


@dataclass
class MaintenanceStrategies:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_rebalance: Optional[CapacityRebalance] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capacity_rebalance is not None:
            if hasattr(self.capacity_rebalance, 'to_dict'):
                props['CapacityRebalance'] = self.capacity_rebalance.to_dict()
            elif isinstance(self.capacity_rebalance, list):
                props['CapacityRebalance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_rebalance
                ]
            else:
                props['CapacityRebalance'] = self.capacity_rebalance

        return props


@dataclass
class MemoryGiBPerVCpuRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class MemoryMiBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class NetworkBandwidthGbpsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class NetworkInterfaceCountRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class OnDemandOptionsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    single_availability_zone: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allocation_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    single_instance_type: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_target_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_total_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_options: Optional[CapacityReservationOptionsRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.single_availability_zone is not None:
            if hasattr(self.single_availability_zone, 'to_dict'):
                props['SingleAvailabilityZone'] = self.single_availability_zone.to_dict()
            elif isinstance(self.single_availability_zone, list):
                props['SingleAvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.single_availability_zone
                ]
            else:
                props['SingleAvailabilityZone'] = self.single_availability_zone

        if self.allocation_strategy is not None:
            if hasattr(self.allocation_strategy, 'to_dict'):
                props['AllocationStrategy'] = self.allocation_strategy.to_dict()
            elif isinstance(self.allocation_strategy, list):
                props['AllocationStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_strategy
                ]
            else:
                props['AllocationStrategy'] = self.allocation_strategy

        if self.single_instance_type is not None:
            if hasattr(self.single_instance_type, 'to_dict'):
                props['SingleInstanceType'] = self.single_instance_type.to_dict()
            elif isinstance(self.single_instance_type, list):
                props['SingleInstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.single_instance_type
                ]
            else:
                props['SingleInstanceType'] = self.single_instance_type

        if self.min_target_capacity is not None:
            if hasattr(self.min_target_capacity, 'to_dict'):
                props['MinTargetCapacity'] = self.min_target_capacity.to_dict()
            elif isinstance(self.min_target_capacity, list):
                props['MinTargetCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_target_capacity
                ]
            else:
                props['MinTargetCapacity'] = self.min_target_capacity

        if self.max_total_price is not None:
            if hasattr(self.max_total_price, 'to_dict'):
                props['MaxTotalPrice'] = self.max_total_price.to_dict()
            elif isinstance(self.max_total_price, list):
                props['MaxTotalPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_total_price
                ]
            else:
                props['MaxTotalPrice'] = self.max_total_price

        if self.capacity_reservation_options is not None:
            if hasattr(self.capacity_reservation_options, 'to_dict'):
                props['CapacityReservationOptions'] = self.capacity_reservation_options.to_dict()
            elif isinstance(self.capacity_reservation_options, list):
                props['CapacityReservationOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_options
                ]
            else:
                props['CapacityReservationOptions'] = self.capacity_reservation_options

        return props


@dataclass
class PerformanceFactorReferenceRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_family: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_family is not None:
            if hasattr(self.instance_family, 'to_dict'):
                props['InstanceFamily'] = self.instance_family.to_dict()
            elif isinstance(self.instance_family, list):
                props['InstanceFamily'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_family
                ]
            else:
                props['InstanceFamily'] = self.instance_family

        return props


@dataclass
class Placement:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tenancy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spread_domain: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    partition_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    affinity: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    host_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    host_resource_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.group_name is not None:
            if hasattr(self.group_name, 'to_dict'):
                props['GroupName'] = self.group_name.to_dict()
            elif isinstance(self.group_name, list):
                props['GroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_name
                ]
            else:
                props['GroupName'] = self.group_name

        if self.tenancy is not None:
            if hasattr(self.tenancy, 'to_dict'):
                props['Tenancy'] = self.tenancy.to_dict()
            elif isinstance(self.tenancy, list):
                props['Tenancy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tenancy
                ]
            else:
                props['Tenancy'] = self.tenancy

        if self.spread_domain is not None:
            if hasattr(self.spread_domain, 'to_dict'):
                props['SpreadDomain'] = self.spread_domain.to_dict()
            elif isinstance(self.spread_domain, list):
                props['SpreadDomain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spread_domain
                ]
            else:
                props['SpreadDomain'] = self.spread_domain

        if self.partition_number is not None:
            if hasattr(self.partition_number, 'to_dict'):
                props['PartitionNumber'] = self.partition_number.to_dict()
            elif isinstance(self.partition_number, list):
                props['PartitionNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.partition_number
                ]
            else:
                props['PartitionNumber'] = self.partition_number

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        if self.affinity is not None:
            if hasattr(self.affinity, 'to_dict'):
                props['Affinity'] = self.affinity.to_dict()
            elif isinstance(self.affinity, list):
                props['Affinity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.affinity
                ]
            else:
                props['Affinity'] = self.affinity

        if self.host_id is not None:
            if hasattr(self.host_id, 'to_dict'):
                props['HostId'] = self.host_id.to_dict()
            elif isinstance(self.host_id, list):
                props['HostId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_id
                ]
            else:
                props['HostId'] = self.host_id

        if self.host_resource_group_arn is not None:
            if hasattr(self.host_resource_group_arn, 'to_dict'):
                props['HostResourceGroupArn'] = self.host_resource_group_arn.to_dict()
            elif isinstance(self.host_resource_group_arn, list):
                props['HostResourceGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_resource_group_arn
                ]
            else:
                props['HostResourceGroupArn'] = self.host_resource_group_arn

        return props


@dataclass
class SpotOptionsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    single_availability_zone: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allocation_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    single_instance_type: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_target_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_total_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maintenance_strategies: Optional[MaintenanceStrategies] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_interruption_behavior: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_pools_to_use_count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.single_availability_zone is not None:
            if hasattr(self.single_availability_zone, 'to_dict'):
                props['SingleAvailabilityZone'] = self.single_availability_zone.to_dict()
            elif isinstance(self.single_availability_zone, list):
                props['SingleAvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.single_availability_zone
                ]
            else:
                props['SingleAvailabilityZone'] = self.single_availability_zone

        if self.allocation_strategy is not None:
            if hasattr(self.allocation_strategy, 'to_dict'):
                props['AllocationStrategy'] = self.allocation_strategy.to_dict()
            elif isinstance(self.allocation_strategy, list):
                props['AllocationStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_strategy
                ]
            else:
                props['AllocationStrategy'] = self.allocation_strategy

        if self.single_instance_type is not None:
            if hasattr(self.single_instance_type, 'to_dict'):
                props['SingleInstanceType'] = self.single_instance_type.to_dict()
            elif isinstance(self.single_instance_type, list):
                props['SingleInstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.single_instance_type
                ]
            else:
                props['SingleInstanceType'] = self.single_instance_type

        if self.min_target_capacity is not None:
            if hasattr(self.min_target_capacity, 'to_dict'):
                props['MinTargetCapacity'] = self.min_target_capacity.to_dict()
            elif isinstance(self.min_target_capacity, list):
                props['MinTargetCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_target_capacity
                ]
            else:
                props['MinTargetCapacity'] = self.min_target_capacity

        if self.max_total_price is not None:
            if hasattr(self.max_total_price, 'to_dict'):
                props['MaxTotalPrice'] = self.max_total_price.to_dict()
            elif isinstance(self.max_total_price, list):
                props['MaxTotalPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_total_price
                ]
            else:
                props['MaxTotalPrice'] = self.max_total_price

        if self.maintenance_strategies is not None:
            if hasattr(self.maintenance_strategies, 'to_dict'):
                props['MaintenanceStrategies'] = self.maintenance_strategies.to_dict()
            elif isinstance(self.maintenance_strategies, list):
                props['MaintenanceStrategies'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maintenance_strategies
                ]
            else:
                props['MaintenanceStrategies'] = self.maintenance_strategies

        if self.instance_interruption_behavior is not None:
            if hasattr(self.instance_interruption_behavior, 'to_dict'):
                props['InstanceInterruptionBehavior'] = self.instance_interruption_behavior.to_dict()
            elif isinstance(self.instance_interruption_behavior, list):
                props['InstanceInterruptionBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_interruption_behavior
                ]
            else:
                props['InstanceInterruptionBehavior'] = self.instance_interruption_behavior

        if self.instance_pools_to_use_count is not None:
            if hasattr(self.instance_pools_to_use_count, 'to_dict'):
                props['InstancePoolsToUseCount'] = self.instance_pools_to_use_count.to_dict()
            elif isinstance(self.instance_pools_to_use_count, list):
                props['InstancePoolsToUseCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_pools_to_use_count
                ]
            else:
                props['InstancePoolsToUseCount'] = self.instance_pools_to_use_count

        return props


@dataclass
class TagSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tags: Optional[list[Tag]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        if self.tags is not None:
            if hasattr(self.tags, 'to_dict'):
                props['Tags'] = self.tags.to_dict()
            elif isinstance(self.tags, list):
                props['Tags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tags
                ]
            else:
                props['Tags'] = self.tags

        return props


@dataclass
class TargetCapacitySpecificationRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_target_capacity_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    total_target_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_target_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_target_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_capacity_unit_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_target_capacity_type is not None:
            if hasattr(self.default_target_capacity_type, 'to_dict'):
                props['DefaultTargetCapacityType'] = self.default_target_capacity_type.to_dict()
            elif isinstance(self.default_target_capacity_type, list):
                props['DefaultTargetCapacityType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_target_capacity_type
                ]
            else:
                props['DefaultTargetCapacityType'] = self.default_target_capacity_type

        if self.total_target_capacity is not None:
            if hasattr(self.total_target_capacity, 'to_dict'):
                props['TotalTargetCapacity'] = self.total_target_capacity.to_dict()
            elif isinstance(self.total_target_capacity, list):
                props['TotalTargetCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_target_capacity
                ]
            else:
                props['TotalTargetCapacity'] = self.total_target_capacity

        if self.on_demand_target_capacity is not None:
            if hasattr(self.on_demand_target_capacity, 'to_dict'):
                props['OnDemandTargetCapacity'] = self.on_demand_target_capacity.to_dict()
            elif isinstance(self.on_demand_target_capacity, list):
                props['OnDemandTargetCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_target_capacity
                ]
            else:
                props['OnDemandTargetCapacity'] = self.on_demand_target_capacity

        if self.spot_target_capacity is not None:
            if hasattr(self.spot_target_capacity, 'to_dict'):
                props['SpotTargetCapacity'] = self.spot_target_capacity.to_dict()
            elif isinstance(self.spot_target_capacity, list):
                props['SpotTargetCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_target_capacity
                ]
            else:
                props['SpotTargetCapacity'] = self.spot_target_capacity

        if self.target_capacity_unit_type is not None:
            if hasattr(self.target_capacity_unit_type, 'to_dict'):
                props['TargetCapacityUnitType'] = self.target_capacity_unit_type.to_dict()
            elif isinstance(self.target_capacity_unit_type, list):
                props['TargetCapacityUnitType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_capacity_unit_type
                ]
            else:
                props['TargetCapacityUnitType'] = self.target_capacity_unit_type

        return props


@dataclass
class TotalLocalStorageGBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class VCpuCountRangeRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class EC2Fleet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-e"""

    resource_type: ClassVar[str] = "AWS::EC2::EC2Fleet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    context: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_capacity_specification: Optional[TargetCapacitySpecificationRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    on_demand_options: Optional[OnDemandOptionsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    excess_capacity_termination_policy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tag_specifications: Optional[list[TagSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    spot_options: Optional[SpotOptionsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    valid_from: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    replace_unhealthy_instances: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_template_configs: Optional[list[FleetLaunchTemplateConfigRequest]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    terminate_instances_with_expiration: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    valid_until: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.context is not None:
            # Serialize context (handle intrinsic functions)
            if hasattr(self.context, 'to_dict'):
                props["Context"] = self.context.to_dict()
            elif isinstance(self.context, list):
                # Serialize list items (may contain intrinsic functions)
                props['Context'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.context
                ]
            else:
                props["Context"] = self.context

        if self.target_capacity_specification is not None:
            # Serialize target_capacity_specification (handle intrinsic functions)
            if hasattr(self.target_capacity_specification, 'to_dict'):
                props["TargetCapacitySpecification"] = self.target_capacity_specification.to_dict()
            elif isinstance(self.target_capacity_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetCapacitySpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_capacity_specification
                ]
            else:
                props["TargetCapacitySpecification"] = self.target_capacity_specification

        if self.on_demand_options is not None:
            # Serialize on_demand_options (handle intrinsic functions)
            if hasattr(self.on_demand_options, 'to_dict'):
                props["OnDemandOptions"] = self.on_demand_options.to_dict()
            elif isinstance(self.on_demand_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['OnDemandOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_options
                ]
            else:
                props["OnDemandOptions"] = self.on_demand_options

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.excess_capacity_termination_policy is not None:
            # Serialize excess_capacity_termination_policy (handle intrinsic functions)
            if hasattr(self.excess_capacity_termination_policy, 'to_dict'):
                props["ExcessCapacityTerminationPolicy"] = self.excess_capacity_termination_policy.to_dict()
            elif isinstance(self.excess_capacity_termination_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExcessCapacityTerminationPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.excess_capacity_termination_policy
                ]
            else:
                props["ExcessCapacityTerminationPolicy"] = self.excess_capacity_termination_policy

        if self.tag_specifications is not None:
            # Serialize tag_specifications (handle intrinsic functions)
            if hasattr(self.tag_specifications, 'to_dict'):
                props["TagSpecifications"] = self.tag_specifications.to_dict()
            elif isinstance(self.tag_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['TagSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_specifications
                ]
            else:
                props["TagSpecifications"] = self.tag_specifications

        if self.spot_options is not None:
            # Serialize spot_options (handle intrinsic functions)
            if hasattr(self.spot_options, 'to_dict'):
                props["SpotOptions"] = self.spot_options.to_dict()
            elif isinstance(self.spot_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['SpotOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_options
                ]
            else:
                props["SpotOptions"] = self.spot_options

        if self.valid_from is not None:
            # Serialize valid_from (handle intrinsic functions)
            if hasattr(self.valid_from, 'to_dict'):
                props["ValidFrom"] = self.valid_from.to_dict()
            elif isinstance(self.valid_from, list):
                # Serialize list items (may contain intrinsic functions)
                props['ValidFrom'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.valid_from
                ]
            else:
                props["ValidFrom"] = self.valid_from

        if self.replace_unhealthy_instances is not None:
            # Serialize replace_unhealthy_instances (handle intrinsic functions)
            if hasattr(self.replace_unhealthy_instances, 'to_dict'):
                props["ReplaceUnhealthyInstances"] = self.replace_unhealthy_instances.to_dict()
            elif isinstance(self.replace_unhealthy_instances, list):
                # Serialize list items (may contain intrinsic functions)
                props['ReplaceUnhealthyInstances'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.replace_unhealthy_instances
                ]
            else:
                props["ReplaceUnhealthyInstances"] = self.replace_unhealthy_instances

        if self.launch_template_configs is not None:
            # Serialize launch_template_configs (handle intrinsic functions)
            if hasattr(self.launch_template_configs, 'to_dict'):
                props["LaunchTemplateConfigs"] = self.launch_template_configs.to_dict()
            elif isinstance(self.launch_template_configs, list):
                # Serialize list items (may contain intrinsic functions)
                props['LaunchTemplateConfigs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_configs
                ]
            else:
                props["LaunchTemplateConfigs"] = self.launch_template_configs

        if self.terminate_instances_with_expiration is not None:
            # Serialize terminate_instances_with_expiration (handle intrinsic functions)
            if hasattr(self.terminate_instances_with_expiration, 'to_dict'):
                props["TerminateInstancesWithExpiration"] = self.terminate_instances_with_expiration.to_dict()
            elif isinstance(self.terminate_instances_with_expiration, list):
                # Serialize list items (may contain intrinsic functions)
                props['TerminateInstancesWithExpiration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.terminate_instances_with_expiration
                ]
            else:
                props["TerminateInstancesWithExpiration"] = self.terminate_instances_with_expiration

        if self.valid_until is not None:
            # Serialize valid_until (handle intrinsic functions)
            if hasattr(self.valid_until, 'to_dict'):
                props["ValidUntil"] = self.valid_until.to_dict()
            elif isinstance(self.valid_until, list):
                # Serialize list items (may contain intrinsic functions)
                props['ValidUntil'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.valid_until
                ]
            else:
                props["ValidUntil"] = self.valid_until

        return props

    @property
    def attr_fleet_id(self) -> GetAtt:
        """Get the FleetId attribute."""
        return self.get_att("FleetId")




@dataclass
class EIP(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-e"""

    resource_type: ClassVar[str] = "AWS::EC2::EIP"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    public_ipv4_pool: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transfer_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_border_group: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.address is not None:
            # Serialize address (handle intrinsic functions)
            if hasattr(self.address, 'to_dict'):
                props["Address"] = self.address.to_dict()
            elif isinstance(self.address, list):
                # Serialize list items (may contain intrinsic functions)
                props['Address'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.address
                ]
            else:
                props["Address"] = self.address

        if self.instance_id is not None:
            # Serialize instance_id (handle intrinsic functions)
            if hasattr(self.instance_id, 'to_dict'):
                props["InstanceId"] = self.instance_id.to_dict()
            elif isinstance(self.instance_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_id
                ]
            else:
                props["InstanceId"] = self.instance_id

        if self.ipam_pool_id is not None:
            # Serialize ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipam_pool_id, 'to_dict'):
                props["IpamPoolId"] = self.ipam_pool_id.to_dict()
            elif isinstance(self.ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipam_pool_id
                ]
            else:
                props["IpamPoolId"] = self.ipam_pool_id

        if self.public_ipv4_pool is not None:
            # Serialize public_ipv4_pool (handle intrinsic functions)
            if hasattr(self.public_ipv4_pool, 'to_dict'):
                props["PublicIpv4Pool"] = self.public_ipv4_pool.to_dict()
            elif isinstance(self.public_ipv4_pool, list):
                # Serialize list items (may contain intrinsic functions)
                props['PublicIpv4Pool'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_ipv4_pool
                ]
            else:
                props["PublicIpv4Pool"] = self.public_ipv4_pool

        if self.transfer_address is not None:
            # Serialize transfer_address (handle intrinsic functions)
            if hasattr(self.transfer_address, 'to_dict'):
                props["TransferAddress"] = self.transfer_address.to_dict()
            elif isinstance(self.transfer_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransferAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transfer_address
                ]
            else:
                props["TransferAddress"] = self.transfer_address

        if self.domain is not None:
            # Serialize domain (handle intrinsic functions)
            if hasattr(self.domain, 'to_dict'):
                props["Domain"] = self.domain.to_dict()
            elif isinstance(self.domain, list):
                # Serialize list items (may contain intrinsic functions)
                props['Domain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain
                ]
            else:
                props["Domain"] = self.domain

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.network_border_group is not None:
            # Serialize network_border_group (handle intrinsic functions)
            if hasattr(self.network_border_group, 'to_dict'):
                props["NetworkBorderGroup"] = self.network_border_group.to_dict()
            elif isinstance(self.network_border_group, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkBorderGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_border_group
                ]
            else:
                props["NetworkBorderGroup"] = self.network_border_group

        return props

    @property
    def attr_public_ip(self) -> GetAtt:
        """Get the PublicIp attribute."""
        return self.get_att("PublicIp")

    @property
    def attr_allocation_id(self) -> GetAtt:
        """Get the AllocationId attribute."""
        return self.get_att("AllocationId")




@dataclass
class EIPAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-e"""

    resource_type: ClassVar[str] = "AWS::EC2::EIPAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allocation_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.private_ip_address is not None:
            # Serialize private_ip_address (handle intrinsic functions)
            if hasattr(self.private_ip_address, 'to_dict'):
                props["PrivateIpAddress"] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props["PrivateIpAddress"] = self.private_ip_address

        if self.instance_id is not None:
            # Serialize instance_id (handle intrinsic functions)
            if hasattr(self.instance_id, 'to_dict'):
                props["InstanceId"] = self.instance_id.to_dict()
            elif isinstance(self.instance_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_id
                ]
            else:
                props["InstanceId"] = self.instance_id

        if self.allocation_id is not None:
            # Serialize allocation_id (handle intrinsic functions)
            if hasattr(self.allocation_id, 'to_dict'):
                props["AllocationId"] = self.allocation_id.to_dict()
            elif isinstance(self.allocation_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllocationId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_id
                ]
            else:
                props["AllocationId"] = self.allocation_id

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class EgressOnlyInternetGateway(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-e"""

    resource_type: ClassVar[str] = "AWS::EC2::EgressOnlyInternetGateway"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class EnclaveCertificateIamRoleAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-e"""

    resource_type: ClassVar[str] = "AWS::EC2::EnclaveCertificateIamRoleAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    certificate_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        if self.certificate_arn is not None:
            # Serialize certificate_arn (handle intrinsic functions)
            if hasattr(self.certificate_arn, 'to_dict'):
                props["CertificateArn"] = self.certificate_arn.to_dict()
            elif isinstance(self.certificate_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['CertificateArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_arn
                ]
            else:
                props["CertificateArn"] = self.certificate_arn

        return props

    @property
    def attr_encryption_kms_key_id(self) -> GetAtt:
        """Get the EncryptionKmsKeyId attribute."""
        return self.get_att("EncryptionKmsKeyId")

    @property
    def attr_certificate_s3_bucket_name(self) -> GetAtt:
        """Get the CertificateS3BucketName attribute."""
        return self.get_att("CertificateS3BucketName")

    @property
    def attr_certificate_s3_object_key(self) -> GetAtt:
        """Get the CertificateS3ObjectKey attribute."""
        return self.get_att("CertificateS3ObjectKey")




@dataclass
class DestinationOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    per_hour_partition: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hive_compatible_partitions: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_format: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.per_hour_partition is not None:
            if hasattr(self.per_hour_partition, 'to_dict'):
                props['PerHourPartition'] = self.per_hour_partition.to_dict()
            elif isinstance(self.per_hour_partition, list):
                props['PerHourPartition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.per_hour_partition
                ]
            else:
                props['PerHourPartition'] = self.per_hour_partition

        if self.hive_compatible_partitions is not None:
            if hasattr(self.hive_compatible_partitions, 'to_dict'):
                props['HiveCompatiblePartitions'] = self.hive_compatible_partitions.to_dict()
            elif isinstance(self.hive_compatible_partitions, list):
                props['HiveCompatiblePartitions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hive_compatible_partitions
                ]
            else:
                props['HiveCompatiblePartitions'] = self.hive_compatible_partitions

        if self.file_format is not None:
            if hasattr(self.file_format, 'to_dict'):
                props['FileFormat'] = self.file_format.to_dict()
            elif isinstance(self.file_format, list):
                props['FileFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_format
                ]
            else:
                props['FileFormat'] = self.file_format

        return props


@dataclass
class FlowLog(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-f"""

    resource_type: ClassVar[str] = "AWS::EC2::FlowLog"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_aggregation_interval: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_options: Optional[DestinationOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    deliver_cross_account_role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_destination: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    deliver_logs_permission_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_destination_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    traffic_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.log_format is not None:
            # Serialize log_format (handle intrinsic functions)
            if hasattr(self.log_format, 'to_dict'):
                props["LogFormat"] = self.log_format.to_dict()
            elif isinstance(self.log_format, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_format
                ]
            else:
                props["LogFormat"] = self.log_format

        if self.resource_id is not None:
            # Serialize resource_id (handle intrinsic functions)
            if hasattr(self.resource_id, 'to_dict'):
                props["ResourceId"] = self.resource_id.to_dict()
            elif isinstance(self.resource_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_id
                ]
            else:
                props["ResourceId"] = self.resource_id

        if self.max_aggregation_interval is not None:
            # Serialize max_aggregation_interval (handle intrinsic functions)
            if hasattr(self.max_aggregation_interval, 'to_dict'):
                props["MaxAggregationInterval"] = self.max_aggregation_interval.to_dict()
            elif isinstance(self.max_aggregation_interval, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxAggregationInterval'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_aggregation_interval
                ]
            else:
                props["MaxAggregationInterval"] = self.max_aggregation_interval

        if self.destination_options is not None:
            # Serialize destination_options (handle intrinsic functions)
            if hasattr(self.destination_options, 'to_dict'):
                props["DestinationOptions"] = self.destination_options.to_dict()
            elif isinstance(self.destination_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_options
                ]
            else:
                props["DestinationOptions"] = self.destination_options

        if self.resource_type is not None:
            # Serialize resource_type (handle intrinsic functions)
            if hasattr(self.resource_type, 'to_dict'):
                props["ResourceType"] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props["ResourceType"] = self.resource_type

        if self.deliver_cross_account_role is not None:
            # Serialize deliver_cross_account_role (handle intrinsic functions)
            if hasattr(self.deliver_cross_account_role, 'to_dict'):
                props["DeliverCrossAccountRole"] = self.deliver_cross_account_role.to_dict()
            elif isinstance(self.deliver_cross_account_role, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeliverCrossAccountRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.deliver_cross_account_role
                ]
            else:
                props["DeliverCrossAccountRole"] = self.deliver_cross_account_role

        if self.log_destination is not None:
            # Serialize log_destination (handle intrinsic functions)
            if hasattr(self.log_destination, 'to_dict'):
                props["LogDestination"] = self.log_destination.to_dict()
            elif isinstance(self.log_destination, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogDestination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_destination
                ]
            else:
                props["LogDestination"] = self.log_destination

        if self.log_group_name is not None:
            # Serialize log_group_name (handle intrinsic functions)
            if hasattr(self.log_group_name, 'to_dict'):
                props["LogGroupName"] = self.log_group_name.to_dict()
            elif isinstance(self.log_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_name
                ]
            else:
                props["LogGroupName"] = self.log_group_name

        if self.deliver_logs_permission_arn is not None:
            # Serialize deliver_logs_permission_arn (handle intrinsic functions)
            if hasattr(self.deliver_logs_permission_arn, 'to_dict'):
                props["DeliverLogsPermissionArn"] = self.deliver_logs_permission_arn.to_dict()
            elif isinstance(self.deliver_logs_permission_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeliverLogsPermissionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.deliver_logs_permission_arn
                ]
            else:
                props["DeliverLogsPermissionArn"] = self.deliver_logs_permission_arn

        if self.log_destination_type is not None:
            # Serialize log_destination_type (handle intrinsic functions)
            if hasattr(self.log_destination_type, 'to_dict'):
                props["LogDestinationType"] = self.log_destination_type.to_dict()
            elif isinstance(self.log_destination_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogDestinationType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_destination_type
                ]
            else:
                props["LogDestinationType"] = self.log_destination_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.traffic_type is not None:
            # Serialize traffic_type (handle intrinsic functions)
            if hasattr(self.traffic_type, 'to_dict'):
                props["TrafficType"] = self.traffic_type.to_dict()
            elif isinstance(self.traffic_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['TrafficType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.traffic_type
                ]
            else:
                props["TrafficType"] = self.traffic_type

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class GatewayRouteTableAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-g"""

    resource_type: ClassVar[str] = "AWS::EC2::GatewayRouteTableAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.route_table_id is not None:
            # Serialize route_table_id (handle intrinsic functions)
            if hasattr(self.route_table_id, 'to_dict'):
                props["RouteTableId"] = self.route_table_id.to_dict()
            elif isinstance(self.route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_id
                ]
            else:
                props["RouteTableId"] = self.route_table_id

        if self.gateway_id is not None:
            # Serialize gateway_id (handle intrinsic functions)
            if hasattr(self.gateway_id, 'to_dict'):
                props["GatewayId"] = self.gateway_id.to_dict()
            elif isinstance(self.gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['GatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gateway_id
                ]
            else:
                props["GatewayId"] = self.gateway_id

        return props

    @property
    def attr_association_id(self) -> GetAtt:
        """Get the AssociationId attribute."""
        return self.get_att("AssociationId")




@dataclass
class Host(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-h"""

    resource_type: ClassVar[str] = "AWS::EC2::Host"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    host_recovery: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_family: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_placement: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    outpost_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    host_maintenance: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    asset_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.host_recovery is not None:
            # Serialize host_recovery (handle intrinsic functions)
            if hasattr(self.host_recovery, 'to_dict'):
                props["HostRecovery"] = self.host_recovery.to_dict()
            elif isinstance(self.host_recovery, list):
                # Serialize list items (may contain intrinsic functions)
                props['HostRecovery'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_recovery
                ]
            else:
                props["HostRecovery"] = self.host_recovery

        if self.instance_family is not None:
            # Serialize instance_family (handle intrinsic functions)
            if hasattr(self.instance_family, 'to_dict'):
                props["InstanceFamily"] = self.instance_family.to_dict()
            elif isinstance(self.instance_family, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceFamily'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_family
                ]
            else:
                props["InstanceFamily"] = self.instance_family

        if self.auto_placement is not None:
            # Serialize auto_placement (handle intrinsic functions)
            if hasattr(self.auto_placement, 'to_dict'):
                props["AutoPlacement"] = self.auto_placement.to_dict()
            elif isinstance(self.auto_placement, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoPlacement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_placement
                ]
            else:
                props["AutoPlacement"] = self.auto_placement

        if self.outpost_arn is not None:
            # Serialize outpost_arn (handle intrinsic functions)
            if hasattr(self.outpost_arn, 'to_dict'):
                props["OutpostArn"] = self.outpost_arn.to_dict()
            elif isinstance(self.outpost_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutpostArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.outpost_arn
                ]
            else:
                props["OutpostArn"] = self.outpost_arn

        if self.host_maintenance is not None:
            # Serialize host_maintenance (handle intrinsic functions)
            if hasattr(self.host_maintenance, 'to_dict'):
                props["HostMaintenance"] = self.host_maintenance.to_dict()
            elif isinstance(self.host_maintenance, list):
                # Serialize list items (may contain intrinsic functions)
                props['HostMaintenance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_maintenance
                ]
            else:
                props["HostMaintenance"] = self.host_maintenance

        if self.availability_zone is not None:
            # Serialize availability_zone (handle intrinsic functions)
            if hasattr(self.availability_zone, 'to_dict'):
                props["AvailabilityZone"] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props["AvailabilityZone"] = self.availability_zone

        if self.instance_type is not None:
            # Serialize instance_type (handle intrinsic functions)
            if hasattr(self.instance_type, 'to_dict'):
                props["InstanceType"] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props["InstanceType"] = self.instance_type

        if self.asset_id is not None:
            # Serialize asset_id (handle intrinsic functions)
            if hasattr(self.asset_id, 'to_dict'):
                props["AssetId"] = self.asset_id.to_dict()
            elif isinstance(self.asset_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AssetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.asset_id
                ]
            else:
                props["AssetId"] = self.asset_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_host_id(self) -> GetAtt:
        """Get the HostId attribute."""
        return self.get_att("HostId")




@dataclass
class IpamOperatingRegion:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    region_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.region_name is not None:
            if hasattr(self.region_name, 'to_dict'):
                props['RegionName'] = self.region_name.to_dict()
            elif isinstance(self.region_name, list):
                props['RegionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.region_name
                ]
            else:
                props['RegionName'] = self.region_name

        return props


@dataclass
class IpamOrganizationalUnitExclusion:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    organizations_entity_path: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.organizations_entity_path is not None:
            if hasattr(self.organizations_entity_path, 'to_dict'):
                props['OrganizationsEntityPath'] = self.organizations_entity_path.to_dict()
            elif isinstance(self.organizations_entity_path, list):
                props['OrganizationsEntityPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organizations_entity_path
                ]
            else:
                props['OrganizationsEntityPath'] = self.organizations_entity_path

        return props


@dataclass
class IPAM(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::IPAM"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_resource_discovery_organizational_unit_exclusions: Optional[list[IpamOrganizationalUnitExclusion]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metered_account: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_private_gua: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    operating_regions: Optional[list[IpamOperatingRegion]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_resource_discovery_organizational_unit_exclusions is not None:
            # Serialize default_resource_discovery_organizational_unit_exclusions (handle intrinsic functions)
            if hasattr(self.default_resource_discovery_organizational_unit_exclusions, 'to_dict'):
                props["DefaultResourceDiscoveryOrganizationalUnitExclusions"] = self.default_resource_discovery_organizational_unit_exclusions.to_dict()
            elif isinstance(self.default_resource_discovery_organizational_unit_exclusions, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultResourceDiscoveryOrganizationalUnitExclusions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_resource_discovery_organizational_unit_exclusions
                ]
            else:
                props["DefaultResourceDiscoveryOrganizationalUnitExclusions"] = self.default_resource_discovery_organizational_unit_exclusions

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.metered_account is not None:
            # Serialize metered_account (handle intrinsic functions)
            if hasattr(self.metered_account, 'to_dict'):
                props["MeteredAccount"] = self.metered_account.to_dict()
            elif isinstance(self.metered_account, list):
                # Serialize list items (may contain intrinsic functions)
                props['MeteredAccount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metered_account
                ]
            else:
                props["MeteredAccount"] = self.metered_account

        if self.tier is not None:
            # Serialize tier (handle intrinsic functions)
            if hasattr(self.tier, 'to_dict'):
                props["Tier"] = self.tier.to_dict()
            elif isinstance(self.tier, list):
                # Serialize list items (may contain intrinsic functions)
                props['Tier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tier
                ]
            else:
                props["Tier"] = self.tier

        if self.enable_private_gua is not None:
            # Serialize enable_private_gua (handle intrinsic functions)
            if hasattr(self.enable_private_gua, 'to_dict'):
                props["EnablePrivateGua"] = self.enable_private_gua.to_dict()
            elif isinstance(self.enable_private_gua, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnablePrivateGua'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_private_gua
                ]
            else:
                props["EnablePrivateGua"] = self.enable_private_gua

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.operating_regions is not None:
            # Serialize operating_regions (handle intrinsic functions)
            if hasattr(self.operating_regions, 'to_dict'):
                props["OperatingRegions"] = self.operating_regions.to_dict()
            elif isinstance(self.operating_regions, list):
                # Serialize list items (may contain intrinsic functions)
                props['OperatingRegions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.operating_regions
                ]
            else:
                props["OperatingRegions"] = self.operating_regions

        return props

    @property
    def attr_default_resource_discovery_association_id(self) -> GetAtt:
        """Get the DefaultResourceDiscoveryAssociationId attribute."""
        return self.get_att("DefaultResourceDiscoveryAssociationId")

    @property
    def attr_default_resource_discovery_id(self) -> GetAtt:
        """Get the DefaultResourceDiscoveryId attribute."""
        return self.get_att("DefaultResourceDiscoveryId")

    @property
    def attr_ipam_id(self) -> GetAtt:
        """Get the IpamId attribute."""
        return self.get_att("IpamId")

    @property
    def attr_resource_discovery_association_count(self) -> GetAtt:
        """Get the ResourceDiscoveryAssociationCount attribute."""
        return self.get_att("ResourceDiscoveryAssociationCount")

    @property
    def attr_scope_count(self) -> GetAtt:
        """Get the ScopeCount attribute."""
        return self.get_att("ScopeCount")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_private_default_scope_id(self) -> GetAtt:
        """Get the PrivateDefaultScopeId attribute."""
        return self.get_att("PrivateDefaultScopeId")

    @property
    def attr_public_default_scope_id(self) -> GetAtt:
        """Get the PublicDefaultScopeId attribute."""
        return self.get_att("PublicDefaultScopeId")




@dataclass
class IPAMAllocation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::IPAMAllocation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.cidr is not None:
            # Serialize cidr (handle intrinsic functions)
            if hasattr(self.cidr, 'to_dict'):
                props["Cidr"] = self.cidr.to_dict()
            elif isinstance(self.cidr, list):
                # Serialize list items (may contain intrinsic functions)
                props['Cidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr
                ]
            else:
                props["Cidr"] = self.cidr

        if self.netmask_length is not None:
            # Serialize netmask_length (handle intrinsic functions)
            if hasattr(self.netmask_length, 'to_dict'):
                props["NetmaskLength"] = self.netmask_length.to_dict()
            elif isinstance(self.netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.netmask_length
                ]
            else:
                props["NetmaskLength"] = self.netmask_length

        if self.ipam_pool_id is not None:
            # Serialize ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipam_pool_id, 'to_dict'):
                props["IpamPoolId"] = self.ipam_pool_id.to_dict()
            elif isinstance(self.ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipam_pool_id
                ]
            else:
                props["IpamPoolId"] = self.ipam_pool_id

        return props

    @property
    def attr_ipam_pool_allocation_id(self) -> GetAtt:
        """Get the IpamPoolAllocationId attribute."""
        return self.get_att("IpamPoolAllocationId")




@dataclass
class ProvisionedCidr:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cidr is not None:
            if hasattr(self.cidr, 'to_dict'):
                props['Cidr'] = self.cidr.to_dict()
            elif isinstance(self.cidr, list):
                props['Cidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr
                ]
            else:
                props['Cidr'] = self.cidr

        return props


@dataclass
class SourceResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_owner: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_region is not None:
            if hasattr(self.resource_region, 'to_dict'):
                props['ResourceRegion'] = self.resource_region.to_dict()
            elif isinstance(self.resource_region, list):
                props['ResourceRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_region
                ]
            else:
                props['ResourceRegion'] = self.resource_region

        if self.resource_id is not None:
            if hasattr(self.resource_id, 'to_dict'):
                props['ResourceId'] = self.resource_id.to_dict()
            elif isinstance(self.resource_id, list):
                props['ResourceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_id
                ]
            else:
                props['ResourceId'] = self.resource_id

        if self.resource_owner is not None:
            if hasattr(self.resource_owner, 'to_dict'):
                props['ResourceOwner'] = self.resource_owner.to_dict()
            elif isinstance(self.resource_owner, list):
                props['ResourceOwner'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_owner
                ]
            else:
                props['ResourceOwner'] = self.resource_owner

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        return props


@dataclass
class IPAMPool(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::IPAMPool"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    aws_service: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    locale: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    public_ip_source: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_resource: Optional[SourceResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allocation_min_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipam_scope_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    provisioned_cidrs: Optional[list[ProvisionedCidr]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allocation_max_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allocation_default_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_import: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    address_family: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allocation_resource_tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    publicly_advertisable: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.aws_service is not None:
            # Serialize aws_service (handle intrinsic functions)
            if hasattr(self.aws_service, 'to_dict'):
                props["AwsService"] = self.aws_service.to_dict()
            elif isinstance(self.aws_service, list):
                # Serialize list items (may contain intrinsic functions)
                props['AwsService'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.aws_service
                ]
            else:
                props["AwsService"] = self.aws_service

        if self.locale is not None:
            # Serialize locale (handle intrinsic functions)
            if hasattr(self.locale, 'to_dict'):
                props["Locale"] = self.locale.to_dict()
            elif isinstance(self.locale, list):
                # Serialize list items (may contain intrinsic functions)
                props['Locale'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.locale
                ]
            else:
                props["Locale"] = self.locale

        if self.public_ip_source is not None:
            # Serialize public_ip_source (handle intrinsic functions)
            if hasattr(self.public_ip_source, 'to_dict'):
                props["PublicIpSource"] = self.public_ip_source.to_dict()
            elif isinstance(self.public_ip_source, list):
                # Serialize list items (may contain intrinsic functions)
                props['PublicIpSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_ip_source
                ]
            else:
                props["PublicIpSource"] = self.public_ip_source

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.source_resource is not None:
            # Serialize source_resource (handle intrinsic functions)
            if hasattr(self.source_resource, 'to_dict'):
                props["SourceResource"] = self.source_resource.to_dict()
            elif isinstance(self.source_resource, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceResource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_resource
                ]
            else:
                props["SourceResource"] = self.source_resource

        if self.source_ipam_pool_id is not None:
            # Serialize source_ipam_pool_id (handle intrinsic functions)
            if hasattr(self.source_ipam_pool_id, 'to_dict'):
                props["SourceIpamPoolId"] = self.source_ipam_pool_id.to_dict()
            elif isinstance(self.source_ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceIpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_ipam_pool_id
                ]
            else:
                props["SourceIpamPoolId"] = self.source_ipam_pool_id

        if self.allocation_min_netmask_length is not None:
            # Serialize allocation_min_netmask_length (handle intrinsic functions)
            if hasattr(self.allocation_min_netmask_length, 'to_dict'):
                props["AllocationMinNetmaskLength"] = self.allocation_min_netmask_length.to_dict()
            elif isinstance(self.allocation_min_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllocationMinNetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_min_netmask_length
                ]
            else:
                props["AllocationMinNetmaskLength"] = self.allocation_min_netmask_length

        if self.ipam_scope_id is not None:
            # Serialize ipam_scope_id (handle intrinsic functions)
            if hasattr(self.ipam_scope_id, 'to_dict'):
                props["IpamScopeId"] = self.ipam_scope_id.to_dict()
            elif isinstance(self.ipam_scope_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpamScopeId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipam_scope_id
                ]
            else:
                props["IpamScopeId"] = self.ipam_scope_id

        if self.provisioned_cidrs is not None:
            # Serialize provisioned_cidrs (handle intrinsic functions)
            if hasattr(self.provisioned_cidrs, 'to_dict'):
                props["ProvisionedCidrs"] = self.provisioned_cidrs.to_dict()
            elif isinstance(self.provisioned_cidrs, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProvisionedCidrs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.provisioned_cidrs
                ]
            else:
                props["ProvisionedCidrs"] = self.provisioned_cidrs

        if self.allocation_max_netmask_length is not None:
            # Serialize allocation_max_netmask_length (handle intrinsic functions)
            if hasattr(self.allocation_max_netmask_length, 'to_dict'):
                props["AllocationMaxNetmaskLength"] = self.allocation_max_netmask_length.to_dict()
            elif isinstance(self.allocation_max_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllocationMaxNetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_max_netmask_length
                ]
            else:
                props["AllocationMaxNetmaskLength"] = self.allocation_max_netmask_length

        if self.allocation_default_netmask_length is not None:
            # Serialize allocation_default_netmask_length (handle intrinsic functions)
            if hasattr(self.allocation_default_netmask_length, 'to_dict'):
                props["AllocationDefaultNetmaskLength"] = self.allocation_default_netmask_length.to_dict()
            elif isinstance(self.allocation_default_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllocationDefaultNetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_default_netmask_length
                ]
            else:
                props["AllocationDefaultNetmaskLength"] = self.allocation_default_netmask_length

        if self.auto_import is not None:
            # Serialize auto_import (handle intrinsic functions)
            if hasattr(self.auto_import, 'to_dict'):
                props["AutoImport"] = self.auto_import.to_dict()
            elif isinstance(self.auto_import, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoImport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_import
                ]
            else:
                props["AutoImport"] = self.auto_import

        if self.address_family is not None:
            # Serialize address_family (handle intrinsic functions)
            if hasattr(self.address_family, 'to_dict'):
                props["AddressFamily"] = self.address_family.to_dict()
            elif isinstance(self.address_family, list):
                # Serialize list items (may contain intrinsic functions)
                props['AddressFamily'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.address_family
                ]
            else:
                props["AddressFamily"] = self.address_family

        if self.allocation_resource_tags is not None:
            # Serialize allocation_resource_tags (handle intrinsic functions)
            if hasattr(self.allocation_resource_tags, 'to_dict'):
                props["AllocationResourceTags"] = self.allocation_resource_tags.to_dict()
            elif isinstance(self.allocation_resource_tags, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllocationResourceTags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_resource_tags
                ]
            else:
                props["AllocationResourceTags"] = self.allocation_resource_tags

        if self.publicly_advertisable is not None:
            # Serialize publicly_advertisable (handle intrinsic functions)
            if hasattr(self.publicly_advertisable, 'to_dict'):
                props["PubliclyAdvertisable"] = self.publicly_advertisable.to_dict()
            elif isinstance(self.publicly_advertisable, list):
                # Serialize list items (may contain intrinsic functions)
                props['PubliclyAdvertisable'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.publicly_advertisable
                ]
            else:
                props["PubliclyAdvertisable"] = self.publicly_advertisable

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_ipam_pool_id(self) -> GetAtt:
        """Get the IpamPoolId attribute."""
        return self.get_att("IpamPoolId")

    @property
    def attr_ipam_arn(self) -> GetAtt:
        """Get the IpamArn attribute."""
        return self.get_att("IpamArn")

    @property
    def attr_pool_depth(self) -> GetAtt:
        """Get the PoolDepth attribute."""
        return self.get_att("PoolDepth")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_ipam_scope_arn(self) -> GetAtt:
        """Get the IpamScopeArn attribute."""
        return self.get_att("IpamScopeArn")

    @property
    def attr_ipam_scope_type(self) -> GetAtt:
        """Get the IpamScopeType attribute."""
        return self.get_att("IpamScopeType")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_state_message(self) -> GetAtt:
        """Get the StateMessage attribute."""
        return self.get_att("StateMessage")




@dataclass
class IPAMPoolCidr(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::IPAMPoolCidr"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cidr is not None:
            # Serialize cidr (handle intrinsic functions)
            if hasattr(self.cidr, 'to_dict'):
                props["Cidr"] = self.cidr.to_dict()
            elif isinstance(self.cidr, list):
                # Serialize list items (may contain intrinsic functions)
                props['Cidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr
                ]
            else:
                props["Cidr"] = self.cidr

        if self.netmask_length is not None:
            # Serialize netmask_length (handle intrinsic functions)
            if hasattr(self.netmask_length, 'to_dict'):
                props["NetmaskLength"] = self.netmask_length.to_dict()
            elif isinstance(self.netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.netmask_length
                ]
            else:
                props["NetmaskLength"] = self.netmask_length

        if self.ipam_pool_id is not None:
            # Serialize ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipam_pool_id, 'to_dict'):
                props["IpamPoolId"] = self.ipam_pool_id.to_dict()
            elif isinstance(self.ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipam_pool_id
                ]
            else:
                props["IpamPoolId"] = self.ipam_pool_id

        return props

    @property
    def attr_ipam_pool_cidr_id(self) -> GetAtt:
        """Get the IpamPoolCidrId attribute."""
        return self.get_att("IpamPoolCidrId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")




@dataclass
class IpamOperatingRegion:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    region_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.region_name is not None:
            if hasattr(self.region_name, 'to_dict'):
                props['RegionName'] = self.region_name.to_dict()
            elif isinstance(self.region_name, list):
                props['RegionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.region_name
                ]
            else:
                props['RegionName'] = self.region_name

        return props


@dataclass
class IpamResourceDiscoveryOrganizationalUnitExclusion:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    organizations_entity_path: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.organizations_entity_path is not None:
            if hasattr(self.organizations_entity_path, 'to_dict'):
                props['OrganizationsEntityPath'] = self.organizations_entity_path.to_dict()
            elif isinstance(self.organizations_entity_path, list):
                props['OrganizationsEntityPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organizations_entity_path
                ]
            else:
                props['OrganizationsEntityPath'] = self.organizations_entity_path

        return props


@dataclass
class IPAMResourceDiscovery(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::IPAMResourceDiscovery"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    organizational_unit_exclusions: Optional[list[IpamResourceDiscoveryOrganizationalUnitExclusion]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    operating_regions: Optional[list[IpamOperatingRegion]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.organizational_unit_exclusions is not None:
            # Serialize organizational_unit_exclusions (handle intrinsic functions)
            if hasattr(self.organizational_unit_exclusions, 'to_dict'):
                props["OrganizationalUnitExclusions"] = self.organizational_unit_exclusions.to_dict()
            elif isinstance(self.organizational_unit_exclusions, list):
                # Serialize list items (may contain intrinsic functions)
                props['OrganizationalUnitExclusions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organizational_unit_exclusions
                ]
            else:
                props["OrganizationalUnitExclusions"] = self.organizational_unit_exclusions

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.operating_regions is not None:
            # Serialize operating_regions (handle intrinsic functions)
            if hasattr(self.operating_regions, 'to_dict'):
                props["OperatingRegions"] = self.operating_regions.to_dict()
            elif isinstance(self.operating_regions, list):
                # Serialize list items (may contain intrinsic functions)
                props['OperatingRegions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.operating_regions
                ]
            else:
                props["OperatingRegions"] = self.operating_regions

        return props

    @property
    def attr_is_default(self) -> GetAtt:
        """Get the IsDefault attribute."""
        return self.get_att("IsDefault")

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_ipam_resource_discovery_region(self) -> GetAtt:
        """Get the IpamResourceDiscoveryRegion attribute."""
        return self.get_att("IpamResourceDiscoveryRegion")

    @property
    def attr_ipam_resource_discovery_arn(self) -> GetAtt:
        """Get the IpamResourceDiscoveryArn attribute."""
        return self.get_att("IpamResourceDiscoveryArn")

    @property
    def attr_ipam_resource_discovery_id(self) -> GetAtt:
        """Get the IpamResourceDiscoveryId attribute."""
        return self.get_att("IpamResourceDiscoveryId")




@dataclass
class IPAMResourceDiscoveryAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::IPAMResourceDiscoveryAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipam_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipam_resource_discovery_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipam_id is not None:
            # Serialize ipam_id (handle intrinsic functions)
            if hasattr(self.ipam_id, 'to_dict'):
                props["IpamId"] = self.ipam_id.to_dict()
            elif isinstance(self.ipam_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpamId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipam_id
                ]
            else:
                props["IpamId"] = self.ipam_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.ipam_resource_discovery_id is not None:
            # Serialize ipam_resource_discovery_id (handle intrinsic functions)
            if hasattr(self.ipam_resource_discovery_id, 'to_dict'):
                props["IpamResourceDiscoveryId"] = self.ipam_resource_discovery_id.to_dict()
            elif isinstance(self.ipam_resource_discovery_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpamResourceDiscoveryId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipam_resource_discovery_id
                ]
            else:
                props["IpamResourceDiscoveryId"] = self.ipam_resource_discovery_id

        return props

    @property
    def attr_is_default(self) -> GetAtt:
        """Get the IsDefault attribute."""
        return self.get_att("IsDefault")

    @property
    def attr_resource_discovery_status(self) -> GetAtt:
        """Get the ResourceDiscoveryStatus attribute."""
        return self.get_att("ResourceDiscoveryStatus")

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_ipam_arn(self) -> GetAtt:
        """Get the IpamArn attribute."""
        return self.get_att("IpamArn")

    @property
    def attr_ipam_resource_discovery_association_id(self) -> GetAtt:
        """Get the IpamResourceDiscoveryAssociationId attribute."""
        return self.get_att("IpamResourceDiscoveryAssociationId")

    @property
    def attr_ipam_resource_discovery_association_arn(self) -> GetAtt:
        """Get the IpamResourceDiscoveryAssociationArn attribute."""
        return self.get_att("IpamResourceDiscoveryAssociationArn")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_ipam_region(self) -> GetAtt:
        """Get the IpamRegion attribute."""
        return self.get_att("IpamRegion")




@dataclass
class IpamScopeExternalAuthorityConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    external_resource_identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipam_scope_external_authority_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.external_resource_identifier is not None:
            if hasattr(self.external_resource_identifier, 'to_dict'):
                props['ExternalResourceIdentifier'] = self.external_resource_identifier.to_dict()
            elif isinstance(self.external_resource_identifier, list):
                props['ExternalResourceIdentifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.external_resource_identifier
                ]
            else:
                props['ExternalResourceIdentifier'] = self.external_resource_identifier

        if self.ipam_scope_external_authority_type is not None:
            if hasattr(self.ipam_scope_external_authority_type, 'to_dict'):
                props['IpamScopeExternalAuthorityType'] = self.ipam_scope_external_authority_type.to_dict()
            elif isinstance(self.ipam_scope_external_authority_type, list):
                props['IpamScopeExternalAuthorityType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipam_scope_external_authority_type
                ]
            else:
                props['IpamScopeExternalAuthorityType'] = self.ipam_scope_external_authority_type

        return props


@dataclass
class IPAMScope(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::IPAMScope"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipam_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    external_authority_configuration: Optional[IpamScopeExternalAuthorityConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.ipam_id is not None:
            # Serialize ipam_id (handle intrinsic functions)
            if hasattr(self.ipam_id, 'to_dict'):
                props["IpamId"] = self.ipam_id.to_dict()
            elif isinstance(self.ipam_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpamId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipam_id
                ]
            else:
                props["IpamId"] = self.ipam_id

        if self.external_authority_configuration is not None:
            # Serialize external_authority_configuration (handle intrinsic functions)
            if hasattr(self.external_authority_configuration, 'to_dict'):
                props["ExternalAuthorityConfiguration"] = self.external_authority_configuration.to_dict()
            elif isinstance(self.external_authority_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExternalAuthorityConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.external_authority_configuration
                ]
            else:
                props["ExternalAuthorityConfiguration"] = self.external_authority_configuration

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_ipam_scope_id(self) -> GetAtt:
        """Get the IpamScopeId attribute."""
        return self.get_att("IpamScopeId")

    @property
    def attr_is_default(self) -> GetAtt:
        """Get the IsDefault attribute."""
        return self.get_att("IsDefault")

    @property
    def attr_ipam_arn(self) -> GetAtt:
        """Get the IpamArn attribute."""
        return self.get_att("IpamArn")

    @property
    def attr_ipam_scope_type(self) -> GetAtt:
        """Get the IpamScopeType attribute."""
        return self.get_att("IpamScopeType")

    @property
    def attr_pool_count(self) -> GetAtt:
        """Get the PoolCount attribute."""
        return self.get_att("PoolCount")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class AssociationParameter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class BlockDeviceMapping:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs: Optional[Ebs] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    no_device: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    virtual_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ebs is not None:
            if hasattr(self.ebs, 'to_dict'):
                props['Ebs'] = self.ebs.to_dict()
            elif isinstance(self.ebs, list):
                props['Ebs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs
                ]
            else:
                props['Ebs'] = self.ebs

        if self.no_device is not None:
            if hasattr(self.no_device, 'to_dict'):
                props['NoDevice'] = self.no_device.to_dict()
            elif isinstance(self.no_device, list):
                props['NoDevice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.no_device
                ]
            else:
                props['NoDevice'] = self.no_device

        if self.virtual_name is not None:
            if hasattr(self.virtual_name, 'to_dict'):
                props['VirtualName'] = self.virtual_name.to_dict()
            elif isinstance(self.virtual_name, list):
                props['VirtualName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.virtual_name
                ]
            else:
                props['VirtualName'] = self.virtual_name

        if self.device_name is not None:
            if hasattr(self.device_name, 'to_dict'):
                props['DeviceName'] = self.device_name.to_dict()
            elif isinstance(self.device_name, list):
                props['DeviceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_name
                ]
            else:
                props['DeviceName'] = self.device_name

        return props


@dataclass
class CpuOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    threads_per_core: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    core_count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.threads_per_core is not None:
            if hasattr(self.threads_per_core, 'to_dict'):
                props['ThreadsPerCore'] = self.threads_per_core.to_dict()
            elif isinstance(self.threads_per_core, list):
                props['ThreadsPerCore'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.threads_per_core
                ]
            else:
                props['ThreadsPerCore'] = self.threads_per_core

        if self.core_count is not None:
            if hasattr(self.core_count, 'to_dict'):
                props['CoreCount'] = self.core_count.to_dict()
            elif isinstance(self.core_count, list):
                props['CoreCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.core_count
                ]
            else:
                props['CoreCount'] = self.core_count

        return props


@dataclass
class CreditSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_credits: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cpu_credits is not None:
            if hasattr(self.cpu_credits, 'to_dict'):
                props['CPUCredits'] = self.cpu_credits.to_dict()
            elif isinstance(self.cpu_credits, list):
                props['CPUCredits'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_credits
                ]
            else:
                props['CPUCredits'] = self.cpu_credits

        return props


@dataclass
class Ebs:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snapshot_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encrypted: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.snapshot_id is not None:
            if hasattr(self.snapshot_id, 'to_dict'):
                props['SnapshotId'] = self.snapshot_id.to_dict()
            elif isinstance(self.snapshot_id, list):
                props['SnapshotId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snapshot_id
                ]
            else:
                props['SnapshotId'] = self.snapshot_id

        if self.volume_type is not None:
            if hasattr(self.volume_type, 'to_dict'):
                props['VolumeType'] = self.volume_type.to_dict()
            elif isinstance(self.volume_type, list):
                props['VolumeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_type
                ]
            else:
                props['VolumeType'] = self.volume_type

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.encrypted is not None:
            if hasattr(self.encrypted, 'to_dict'):
                props['Encrypted'] = self.encrypted.to_dict()
            elif isinstance(self.encrypted, list):
                props['Encrypted'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encrypted
                ]
            else:
                props['Encrypted'] = self.encrypted

        if self.iops is not None:
            if hasattr(self.iops, 'to_dict'):
                props['Iops'] = self.iops.to_dict()
            elif isinstance(self.iops, list):
                props['Iops'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iops
                ]
            else:
                props['Iops'] = self.iops

        if self.volume_size is not None:
            if hasattr(self.volume_size, 'to_dict'):
                props['VolumeSize'] = self.volume_size.to_dict()
            elif isinstance(self.volume_size, list):
                props['VolumeSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size
                ]
            else:
                props['VolumeSize'] = self.volume_size

        if self.delete_on_termination is not None:
            if hasattr(self.delete_on_termination, 'to_dict'):
                props['DeleteOnTermination'] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props['DeleteOnTermination'] = self.delete_on_termination

        return props


@dataclass
class ElasticGpuSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        return props


@dataclass
class ElasticInferenceAccelerator:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.count is not None:
            if hasattr(self.count, 'to_dict'):
                props['Count'] = self.count.to_dict()
            elif isinstance(self.count, list):
                props['Count'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.count
                ]
            else:
                props['Count'] = self.count

        return props


@dataclass
class EnaSrdSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_udp_specification: Optional[EnaSrdUdpSpecification] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ena_srd_enabled is not None:
            if hasattr(self.ena_srd_enabled, 'to_dict'):
                props['EnaSrdEnabled'] = self.ena_srd_enabled.to_dict()
            elif isinstance(self.ena_srd_enabled, list):
                props['EnaSrdEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_enabled
                ]
            else:
                props['EnaSrdEnabled'] = self.ena_srd_enabled

        if self.ena_srd_udp_specification is not None:
            if hasattr(self.ena_srd_udp_specification, 'to_dict'):
                props['EnaSrdUdpSpecification'] = self.ena_srd_udp_specification.to_dict()
            elif isinstance(self.ena_srd_udp_specification, list):
                props['EnaSrdUdpSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_udp_specification
                ]
            else:
                props['EnaSrdUdpSpecification'] = self.ena_srd_udp_specification

        return props


@dataclass
class EnaSrdUdpSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_udp_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ena_srd_udp_enabled is not None:
            if hasattr(self.ena_srd_udp_enabled, 'to_dict'):
                props['EnaSrdUdpEnabled'] = self.ena_srd_udp_enabled.to_dict()
            elif isinstance(self.ena_srd_udp_enabled, list):
                props['EnaSrdUdpEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_udp_enabled
                ]
            else:
                props['EnaSrdUdpEnabled'] = self.ena_srd_udp_enabled

        return props


@dataclass
class EnclaveOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class HibernationOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    configured: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.configured is not None:
            if hasattr(self.configured, 'to_dict'):
                props['Configured'] = self.configured.to_dict()
            elif isinstance(self.configured, list):
                props['Configured'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.configured
                ]
            else:
                props['Configured'] = self.configured

        return props


@dataclass
class InstanceIpv6Address:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_address: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_address is not None:
            if hasattr(self.ipv6_address, 'to_dict'):
                props['Ipv6Address'] = self.ipv6_address.to_dict()
            elif isinstance(self.ipv6_address, list):
                props['Ipv6Address'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address
                ]
            else:
                props['Ipv6Address'] = self.ipv6_address

        return props


@dataclass
class LaunchTemplateSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.launch_template_name is not None:
            if hasattr(self.launch_template_name, 'to_dict'):
                props['LaunchTemplateName'] = self.launch_template_name.to_dict()
            elif isinstance(self.launch_template_name, list):
                props['LaunchTemplateName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_name
                ]
            else:
                props['LaunchTemplateName'] = self.launch_template_name

        if self.version is not None:
            if hasattr(self.version, 'to_dict'):
                props['Version'] = self.version.to_dict()
            elif isinstance(self.version, list):
                props['Version'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version
                ]
            else:
                props['Version'] = self.version

        if self.launch_template_id is not None:
            if hasattr(self.launch_template_id, 'to_dict'):
                props['LaunchTemplateId'] = self.launch_template_id.to_dict()
            elif isinstance(self.launch_template_id, list):
                props['LaunchTemplateId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_id
                ]
            else:
                props['LaunchTemplateId'] = self.launch_template_id

        return props


@dataclass
class LicenseSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    license_configuration_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.license_configuration_arn is not None:
            if hasattr(self.license_configuration_arn, 'to_dict'):
                props['LicenseConfigurationArn'] = self.license_configuration_arn.to_dict()
            elif isinstance(self.license_configuration_arn, list):
                props['LicenseConfigurationArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.license_configuration_arn
                ]
            else:
                props['LicenseConfigurationArn'] = self.license_configuration_arn

        return props


@dataclass
class MetadataOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_put_response_hop_limit: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_protocol_ipv6: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_tokens: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_metadata_tags: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.http_put_response_hop_limit is not None:
            if hasattr(self.http_put_response_hop_limit, 'to_dict'):
                props['HttpPutResponseHopLimit'] = self.http_put_response_hop_limit.to_dict()
            elif isinstance(self.http_put_response_hop_limit, list):
                props['HttpPutResponseHopLimit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_put_response_hop_limit
                ]
            else:
                props['HttpPutResponseHopLimit'] = self.http_put_response_hop_limit

        if self.http_protocol_ipv6 is not None:
            if hasattr(self.http_protocol_ipv6, 'to_dict'):
                props['HttpProtocolIpv6'] = self.http_protocol_ipv6.to_dict()
            elif isinstance(self.http_protocol_ipv6, list):
                props['HttpProtocolIpv6'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_protocol_ipv6
                ]
            else:
                props['HttpProtocolIpv6'] = self.http_protocol_ipv6

        if self.http_tokens is not None:
            if hasattr(self.http_tokens, 'to_dict'):
                props['HttpTokens'] = self.http_tokens.to_dict()
            elif isinstance(self.http_tokens, list):
                props['HttpTokens'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_tokens
                ]
            else:
                props['HttpTokens'] = self.http_tokens

        if self.instance_metadata_tags is not None:
            if hasattr(self.instance_metadata_tags, 'to_dict'):
                props['InstanceMetadataTags'] = self.instance_metadata_tags.to_dict()
            elif isinstance(self.instance_metadata_tags, list):
                props['InstanceMetadataTags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_metadata_tags
                ]
            else:
                props['InstanceMetadataTags'] = self.instance_metadata_tags

        if self.http_endpoint is not None:
            if hasattr(self.http_endpoint, 'to_dict'):
                props['HttpEndpoint'] = self.http_endpoint.to_dict()
            elif isinstance(self.http_endpoint, list):
                props['HttpEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_endpoint
                ]
            else:
                props['HttpEndpoint'] = self.http_endpoint

        return props


@dataclass
class NetworkInterface:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_addresses: Optional[list[PrivateIpAddressSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    secondary_private_ip_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_index: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    group_set: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_addresses: Optional[list[InstanceIpv6Address]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    associate_public_ip_address: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    associate_carrier_ip_address: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_specification: Optional[EnaSrdSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.private_ip_address is not None:
            if hasattr(self.private_ip_address, 'to_dict'):
                props['PrivateIpAddress'] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props['PrivateIpAddress'] = self.private_ip_address

        if self.private_ip_addresses is not None:
            if hasattr(self.private_ip_addresses, 'to_dict'):
                props['PrivateIpAddresses'] = self.private_ip_addresses.to_dict()
            elif isinstance(self.private_ip_addresses, list):
                props['PrivateIpAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_addresses
                ]
            else:
                props['PrivateIpAddresses'] = self.private_ip_addresses

        if self.secondary_private_ip_address_count is not None:
            if hasattr(self.secondary_private_ip_address_count, 'to_dict'):
                props['SecondaryPrivateIpAddressCount'] = self.secondary_private_ip_address_count.to_dict()
            elif isinstance(self.secondary_private_ip_address_count, list):
                props['SecondaryPrivateIpAddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_private_ip_address_count
                ]
            else:
                props['SecondaryPrivateIpAddressCount'] = self.secondary_private_ip_address_count

        if self.device_index is not None:
            if hasattr(self.device_index, 'to_dict'):
                props['DeviceIndex'] = self.device_index.to_dict()
            elif isinstance(self.device_index, list):
                props['DeviceIndex'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_index
                ]
            else:
                props['DeviceIndex'] = self.device_index

        if self.group_set is not None:
            if hasattr(self.group_set, 'to_dict'):
                props['GroupSet'] = self.group_set.to_dict()
            elif isinstance(self.group_set, list):
                props['GroupSet'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_set
                ]
            else:
                props['GroupSet'] = self.group_set

        if self.ipv6_addresses is not None:
            if hasattr(self.ipv6_addresses, 'to_dict'):
                props['Ipv6Addresses'] = self.ipv6_addresses.to_dict()
            elif isinstance(self.ipv6_addresses, list):
                props['Ipv6Addresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_addresses
                ]
            else:
                props['Ipv6Addresses'] = self.ipv6_addresses

        if self.subnet_id is not None:
            if hasattr(self.subnet_id, 'to_dict'):
                props['SubnetId'] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props['SubnetId'] = self.subnet_id

        if self.associate_public_ip_address is not None:
            if hasattr(self.associate_public_ip_address, 'to_dict'):
                props['AssociatePublicIpAddress'] = self.associate_public_ip_address.to_dict()
            elif isinstance(self.associate_public_ip_address, list):
                props['AssociatePublicIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.associate_public_ip_address
                ]
            else:
                props['AssociatePublicIpAddress'] = self.associate_public_ip_address

        if self.network_interface_id is not None:
            if hasattr(self.network_interface_id, 'to_dict'):
                props['NetworkInterfaceId'] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props['NetworkInterfaceId'] = self.network_interface_id

        if self.associate_carrier_ip_address is not None:
            if hasattr(self.associate_carrier_ip_address, 'to_dict'):
                props['AssociateCarrierIpAddress'] = self.associate_carrier_ip_address.to_dict()
            elif isinstance(self.associate_carrier_ip_address, list):
                props['AssociateCarrierIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.associate_carrier_ip_address
                ]
            else:
                props['AssociateCarrierIpAddress'] = self.associate_carrier_ip_address

        if self.ena_srd_specification is not None:
            if hasattr(self.ena_srd_specification, 'to_dict'):
                props['EnaSrdSpecification'] = self.ena_srd_specification.to_dict()
            elif isinstance(self.ena_srd_specification, list):
                props['EnaSrdSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_specification
                ]
            else:
                props['EnaSrdSpecification'] = self.ena_srd_specification

        if self.ipv6_address_count is not None:
            if hasattr(self.ipv6_address_count, 'to_dict'):
                props['Ipv6AddressCount'] = self.ipv6_address_count.to_dict()
            elif isinstance(self.ipv6_address_count, list):
                props['Ipv6AddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address_count
                ]
            else:
                props['Ipv6AddressCount'] = self.ipv6_address_count

        if self.delete_on_termination is not None:
            if hasattr(self.delete_on_termination, 'to_dict'):
                props['DeleteOnTermination'] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props['DeleteOnTermination'] = self.delete_on_termination

        return props


@dataclass
class PrivateDnsNameOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_resource_name_dns_a_record: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hostname_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_resource_name_dns_aaaa_record: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enable_resource_name_dns_a_record is not None:
            if hasattr(self.enable_resource_name_dns_a_record, 'to_dict'):
                props['EnableResourceNameDnsARecord'] = self.enable_resource_name_dns_a_record.to_dict()
            elif isinstance(self.enable_resource_name_dns_a_record, list):
                props['EnableResourceNameDnsARecord'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_resource_name_dns_a_record
                ]
            else:
                props['EnableResourceNameDnsARecord'] = self.enable_resource_name_dns_a_record

        if self.hostname_type is not None:
            if hasattr(self.hostname_type, 'to_dict'):
                props['HostnameType'] = self.hostname_type.to_dict()
            elif isinstance(self.hostname_type, list):
                props['HostnameType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hostname_type
                ]
            else:
                props['HostnameType'] = self.hostname_type

        if self.enable_resource_name_dns_aaaa_record is not None:
            if hasattr(self.enable_resource_name_dns_aaaa_record, 'to_dict'):
                props['EnableResourceNameDnsAAAARecord'] = self.enable_resource_name_dns_aaaa_record.to_dict()
            elif isinstance(self.enable_resource_name_dns_aaaa_record, list):
                props['EnableResourceNameDnsAAAARecord'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_resource_name_dns_aaaa_record
                ]
            else:
                props['EnableResourceNameDnsAAAARecord'] = self.enable_resource_name_dns_aaaa_record

        return props


@dataclass
class PrivateIpAddressSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    primary: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.private_ip_address is not None:
            if hasattr(self.private_ip_address, 'to_dict'):
                props['PrivateIpAddress'] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props['PrivateIpAddress'] = self.private_ip_address

        if self.primary is not None:
            if hasattr(self.primary, 'to_dict'):
                props['Primary'] = self.primary.to_dict()
            elif isinstance(self.primary, list):
                props['Primary'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.primary
                ]
            else:
                props['Primary'] = self.primary

        return props


@dataclass
class SsmAssociation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    association_parameters: Optional[list[AssociationParameter]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    document_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.association_parameters is not None:
            if hasattr(self.association_parameters, 'to_dict'):
                props['AssociationParameters'] = self.association_parameters.to_dict()
            elif isinstance(self.association_parameters, list):
                props['AssociationParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.association_parameters
                ]
            else:
                props['AssociationParameters'] = self.association_parameters

        if self.document_name is not None:
            if hasattr(self.document_name, 'to_dict'):
                props['DocumentName'] = self.document_name.to_dict()
            elif isinstance(self.document_name, list):
                props['DocumentName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_name
                ]
            else:
                props['DocumentName'] = self.document_name

        return props


@dataclass
class State:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    code: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.code is not None:
            if hasattr(self.code, 'to_dict'):
                props['Code'] = self.code.to_dict()
            elif isinstance(self.code, list):
                props['Code'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code
                ]
            else:
                props['Code'] = self.code

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class Volume:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.volume_id is not None:
            if hasattr(self.volume_id, 'to_dict'):
                props['VolumeId'] = self.volume_id.to_dict()
            elif isinstance(self.volume_id, list):
                props['VolumeId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_id
                ]
            else:
                props['VolumeId'] = self.volume_id

        if self.device is not None:
            if hasattr(self.device, 'to_dict'):
                props['Device'] = self.device.to_dict()
            elif isinstance(self.device, list):
                props['Device'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device
                ]
            else:
                props['Device'] = self.device

        return props


@dataclass
class Instance(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::Instance"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tenancy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    user_data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    block_device_mappings: Optional[list[BlockDeviceMapping]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    iam_instance_profile: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_addresses: Optional[list[InstanceIpv6Address]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kernel_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ebs_optimized: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    propagate_tags_to_volume_on_creation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    elastic_gpu_specifications: Optional[list[ElasticGpuSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    elastic_inference_accelerators: Optional[list[ElasticInferenceAccelerator]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    volumes: Optional[list[Volume]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_template: Optional[LaunchTemplateSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enclave_options: Optional[EnclaveOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interfaces: Optional[list[NetworkInterface]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    image_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    monitoring: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    additional_info: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    hibernation_options: Optional[HibernationOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    license_specifications: Optional[list[LicenseSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metadata_options: Optional[MetadataOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_initiated_shutdown_behavior: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cpu_options: Optional[CpuOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_dns_name_options: Optional[PrivateDnsNameOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    host_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    host_resource_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    disable_api_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    key_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ramdisk_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_dest_check: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    placement_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ssm_associations: Optional[list[SsmAssociation]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    affinity: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    credit_specification: Optional[CreditSpecification] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.tenancy is not None:
            # Serialize tenancy (handle intrinsic functions)
            if hasattr(self.tenancy, 'to_dict'):
                props["Tenancy"] = self.tenancy.to_dict()
            elif isinstance(self.tenancy, list):
                # Serialize list items (may contain intrinsic functions)
                props['Tenancy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tenancy
                ]
            else:
                props["Tenancy"] = self.tenancy

        if self.security_groups is not None:
            # Serialize security_groups (handle intrinsic functions)
            if hasattr(self.security_groups, 'to_dict'):
                props["SecurityGroups"] = self.security_groups.to_dict()
            elif isinstance(self.security_groups, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_groups
                ]
            else:
                props["SecurityGroups"] = self.security_groups

        if self.private_ip_address is not None:
            # Serialize private_ip_address (handle intrinsic functions)
            if hasattr(self.private_ip_address, 'to_dict'):
                props["PrivateIpAddress"] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props["PrivateIpAddress"] = self.private_ip_address

        if self.user_data is not None:
            # Serialize user_data (handle intrinsic functions)
            if hasattr(self.user_data, 'to_dict'):
                props["UserData"] = self.user_data.to_dict()
            elif isinstance(self.user_data, list):
                # Serialize list items (may contain intrinsic functions)
                props['UserData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_data
                ]
            else:
                props["UserData"] = self.user_data

        if self.block_device_mappings is not None:
            # Serialize block_device_mappings (handle intrinsic functions)
            if hasattr(self.block_device_mappings, 'to_dict'):
                props["BlockDeviceMappings"] = self.block_device_mappings.to_dict()
            elif isinstance(self.block_device_mappings, list):
                # Serialize list items (may contain intrinsic functions)
                props['BlockDeviceMappings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.block_device_mappings
                ]
            else:
                props["BlockDeviceMappings"] = self.block_device_mappings

        if self.iam_instance_profile is not None:
            # Serialize iam_instance_profile (handle intrinsic functions)
            if hasattr(self.iam_instance_profile, 'to_dict'):
                props["IamInstanceProfile"] = self.iam_instance_profile.to_dict()
            elif isinstance(self.iam_instance_profile, list):
                # Serialize list items (may contain intrinsic functions)
                props['IamInstanceProfile'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iam_instance_profile
                ]
            else:
                props["IamInstanceProfile"] = self.iam_instance_profile

        if self.ipv6_addresses is not None:
            # Serialize ipv6_addresses (handle intrinsic functions)
            if hasattr(self.ipv6_addresses, 'to_dict'):
                props["Ipv6Addresses"] = self.ipv6_addresses.to_dict()
            elif isinstance(self.ipv6_addresses, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6Addresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_addresses
                ]
            else:
                props["Ipv6Addresses"] = self.ipv6_addresses

        if self.kernel_id is not None:
            # Serialize kernel_id (handle intrinsic functions)
            if hasattr(self.kernel_id, 'to_dict'):
                props["KernelId"] = self.kernel_id.to_dict()
            elif isinstance(self.kernel_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['KernelId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kernel_id
                ]
            else:
                props["KernelId"] = self.kernel_id

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        if self.ebs_optimized is not None:
            # Serialize ebs_optimized (handle intrinsic functions)
            if hasattr(self.ebs_optimized, 'to_dict'):
                props["EbsOptimized"] = self.ebs_optimized.to_dict()
            elif isinstance(self.ebs_optimized, list):
                # Serialize list items (may contain intrinsic functions)
                props['EbsOptimized'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_optimized
                ]
            else:
                props["EbsOptimized"] = self.ebs_optimized

        if self.propagate_tags_to_volume_on_creation is not None:
            # Serialize propagate_tags_to_volume_on_creation (handle intrinsic functions)
            if hasattr(self.propagate_tags_to_volume_on_creation, 'to_dict'):
                props["PropagateTagsToVolumeOnCreation"] = self.propagate_tags_to_volume_on_creation.to_dict()
            elif isinstance(self.propagate_tags_to_volume_on_creation, list):
                # Serialize list items (may contain intrinsic functions)
                props['PropagateTagsToVolumeOnCreation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.propagate_tags_to_volume_on_creation
                ]
            else:
                props["PropagateTagsToVolumeOnCreation"] = self.propagate_tags_to_volume_on_creation

        if self.elastic_gpu_specifications is not None:
            # Serialize elastic_gpu_specifications (handle intrinsic functions)
            if hasattr(self.elastic_gpu_specifications, 'to_dict'):
                props["ElasticGpuSpecifications"] = self.elastic_gpu_specifications.to_dict()
            elif isinstance(self.elastic_gpu_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['ElasticGpuSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.elastic_gpu_specifications
                ]
            else:
                props["ElasticGpuSpecifications"] = self.elastic_gpu_specifications

        if self.elastic_inference_accelerators is not None:
            # Serialize elastic_inference_accelerators (handle intrinsic functions)
            if hasattr(self.elastic_inference_accelerators, 'to_dict'):
                props["ElasticInferenceAccelerators"] = self.elastic_inference_accelerators.to_dict()
            elif isinstance(self.elastic_inference_accelerators, list):
                # Serialize list items (may contain intrinsic functions)
                props['ElasticInferenceAccelerators'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.elastic_inference_accelerators
                ]
            else:
                props["ElasticInferenceAccelerators"] = self.elastic_inference_accelerators

        if self.volumes is not None:
            # Serialize volumes (handle intrinsic functions)
            if hasattr(self.volumes, 'to_dict'):
                props["Volumes"] = self.volumes.to_dict()
            elif isinstance(self.volumes, list):
                # Serialize list items (may contain intrinsic functions)
                props['Volumes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volumes
                ]
            else:
                props["Volumes"] = self.volumes

        if self.ipv6_address_count is not None:
            # Serialize ipv6_address_count (handle intrinsic functions)
            if hasattr(self.ipv6_address_count, 'to_dict'):
                props["Ipv6AddressCount"] = self.ipv6_address_count.to_dict()
            elif isinstance(self.ipv6_address_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6AddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address_count
                ]
            else:
                props["Ipv6AddressCount"] = self.ipv6_address_count

        if self.launch_template is not None:
            # Serialize launch_template (handle intrinsic functions)
            if hasattr(self.launch_template, 'to_dict'):
                props["LaunchTemplate"] = self.launch_template.to_dict()
            elif isinstance(self.launch_template, list):
                # Serialize list items (may contain intrinsic functions)
                props['LaunchTemplate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template
                ]
            else:
                props["LaunchTemplate"] = self.launch_template

        if self.enclave_options is not None:
            # Serialize enclave_options (handle intrinsic functions)
            if hasattr(self.enclave_options, 'to_dict'):
                props["EnclaveOptions"] = self.enclave_options.to_dict()
            elif isinstance(self.enclave_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnclaveOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enclave_options
                ]
            else:
                props["EnclaveOptions"] = self.enclave_options

        if self.network_interfaces is not None:
            # Serialize network_interfaces (handle intrinsic functions)
            if hasattr(self.network_interfaces, 'to_dict'):
                props["NetworkInterfaces"] = self.network_interfaces.to_dict()
            elif isinstance(self.network_interfaces, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaces'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interfaces
                ]
            else:
                props["NetworkInterfaces"] = self.network_interfaces

        if self.image_id is not None:
            # Serialize image_id (handle intrinsic functions)
            if hasattr(self.image_id, 'to_dict'):
                props["ImageId"] = self.image_id.to_dict()
            elif isinstance(self.image_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ImageId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_id
                ]
            else:
                props["ImageId"] = self.image_id

        if self.instance_type is not None:
            # Serialize instance_type (handle intrinsic functions)
            if hasattr(self.instance_type, 'to_dict'):
                props["InstanceType"] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props["InstanceType"] = self.instance_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.monitoring is not None:
            # Serialize monitoring (handle intrinsic functions)
            if hasattr(self.monitoring, 'to_dict'):
                props["Monitoring"] = self.monitoring.to_dict()
            elif isinstance(self.monitoring, list):
                # Serialize list items (may contain intrinsic functions)
                props['Monitoring'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring
                ]
            else:
                props["Monitoring"] = self.monitoring

        if self.additional_info is not None:
            # Serialize additional_info (handle intrinsic functions)
            if hasattr(self.additional_info, 'to_dict'):
                props["AdditionalInfo"] = self.additional_info.to_dict()
            elif isinstance(self.additional_info, list):
                # Serialize list items (may contain intrinsic functions)
                props['AdditionalInfo'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_info
                ]
            else:
                props["AdditionalInfo"] = self.additional_info

        if self.hibernation_options is not None:
            # Serialize hibernation_options (handle intrinsic functions)
            if hasattr(self.hibernation_options, 'to_dict'):
                props["HibernationOptions"] = self.hibernation_options.to_dict()
            elif isinstance(self.hibernation_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['HibernationOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hibernation_options
                ]
            else:
                props["HibernationOptions"] = self.hibernation_options

        if self.license_specifications is not None:
            # Serialize license_specifications (handle intrinsic functions)
            if hasattr(self.license_specifications, 'to_dict'):
                props["LicenseSpecifications"] = self.license_specifications.to_dict()
            elif isinstance(self.license_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['LicenseSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.license_specifications
                ]
            else:
                props["LicenseSpecifications"] = self.license_specifications

        if self.metadata_options is not None:
            # Serialize metadata_options (handle intrinsic functions)
            if hasattr(self.metadata_options, 'to_dict'):
                props["MetadataOptions"] = self.metadata_options.to_dict()
            elif isinstance(self.metadata_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['MetadataOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metadata_options
                ]
            else:
                props["MetadataOptions"] = self.metadata_options

        if self.instance_initiated_shutdown_behavior is not None:
            # Serialize instance_initiated_shutdown_behavior (handle intrinsic functions)
            if hasattr(self.instance_initiated_shutdown_behavior, 'to_dict'):
                props["InstanceInitiatedShutdownBehavior"] = self.instance_initiated_shutdown_behavior.to_dict()
            elif isinstance(self.instance_initiated_shutdown_behavior, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceInitiatedShutdownBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_initiated_shutdown_behavior
                ]
            else:
                props["InstanceInitiatedShutdownBehavior"] = self.instance_initiated_shutdown_behavior

        if self.cpu_options is not None:
            # Serialize cpu_options (handle intrinsic functions)
            if hasattr(self.cpu_options, 'to_dict'):
                props["CpuOptions"] = self.cpu_options.to_dict()
            elif isinstance(self.cpu_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['CpuOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_options
                ]
            else:
                props["CpuOptions"] = self.cpu_options

        if self.availability_zone is not None:
            # Serialize availability_zone (handle intrinsic functions)
            if hasattr(self.availability_zone, 'to_dict'):
                props["AvailabilityZone"] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props["AvailabilityZone"] = self.availability_zone

        if self.private_dns_name_options is not None:
            # Serialize private_dns_name_options (handle intrinsic functions)
            if hasattr(self.private_dns_name_options, 'to_dict'):
                props["PrivateDnsNameOptions"] = self.private_dns_name_options.to_dict()
            elif isinstance(self.private_dns_name_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateDnsNameOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_dns_name_options
                ]
            else:
                props["PrivateDnsNameOptions"] = self.private_dns_name_options

        if self.host_id is not None:
            # Serialize host_id (handle intrinsic functions)
            if hasattr(self.host_id, 'to_dict'):
                props["HostId"] = self.host_id.to_dict()
            elif isinstance(self.host_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['HostId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_id
                ]
            else:
                props["HostId"] = self.host_id

        if self.host_resource_group_arn is not None:
            # Serialize host_resource_group_arn (handle intrinsic functions)
            if hasattr(self.host_resource_group_arn, 'to_dict'):
                props["HostResourceGroupArn"] = self.host_resource_group_arn.to_dict()
            elif isinstance(self.host_resource_group_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['HostResourceGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_resource_group_arn
                ]
            else:
                props["HostResourceGroupArn"] = self.host_resource_group_arn

        if self.security_group_ids is not None:
            # Serialize security_group_ids (handle intrinsic functions)
            if hasattr(self.security_group_ids, 'to_dict'):
                props["SecurityGroupIds"] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props["SecurityGroupIds"] = self.security_group_ids

        if self.disable_api_termination is not None:
            # Serialize disable_api_termination (handle intrinsic functions)
            if hasattr(self.disable_api_termination, 'to_dict'):
                props["DisableApiTermination"] = self.disable_api_termination.to_dict()
            elif isinstance(self.disable_api_termination, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisableApiTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disable_api_termination
                ]
            else:
                props["DisableApiTermination"] = self.disable_api_termination

        if self.key_name is not None:
            # Serialize key_name (handle intrinsic functions)
            if hasattr(self.key_name, 'to_dict'):
                props["KeyName"] = self.key_name.to_dict()
            elif isinstance(self.key_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['KeyName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_name
                ]
            else:
                props["KeyName"] = self.key_name

        if self.ramdisk_id is not None:
            # Serialize ramdisk_id (handle intrinsic functions)
            if hasattr(self.ramdisk_id, 'to_dict'):
                props["RamdiskId"] = self.ramdisk_id.to_dict()
            elif isinstance(self.ramdisk_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RamdiskId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ramdisk_id
                ]
            else:
                props["RamdiskId"] = self.ramdisk_id

        if self.source_dest_check is not None:
            # Serialize source_dest_check (handle intrinsic functions)
            if hasattr(self.source_dest_check, 'to_dict'):
                props["SourceDestCheck"] = self.source_dest_check.to_dict()
            elif isinstance(self.source_dest_check, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceDestCheck'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_dest_check
                ]
            else:
                props["SourceDestCheck"] = self.source_dest_check

        if self.placement_group_name is not None:
            # Serialize placement_group_name (handle intrinsic functions)
            if hasattr(self.placement_group_name, 'to_dict'):
                props["PlacementGroupName"] = self.placement_group_name.to_dict()
            elif isinstance(self.placement_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['PlacementGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.placement_group_name
                ]
            else:
                props["PlacementGroupName"] = self.placement_group_name

        if self.ssm_associations is not None:
            # Serialize ssm_associations (handle intrinsic functions)
            if hasattr(self.ssm_associations, 'to_dict'):
                props["SsmAssociations"] = self.ssm_associations.to_dict()
            elif isinstance(self.ssm_associations, list):
                # Serialize list items (may contain intrinsic functions)
                props['SsmAssociations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ssm_associations
                ]
            else:
                props["SsmAssociations"] = self.ssm_associations

        if self.affinity is not None:
            # Serialize affinity (handle intrinsic functions)
            if hasattr(self.affinity, 'to_dict'):
                props["Affinity"] = self.affinity.to_dict()
            elif isinstance(self.affinity, list):
                # Serialize list items (may contain intrinsic functions)
                props['Affinity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.affinity
                ]
            else:
                props["Affinity"] = self.affinity

        if self.credit_specification is not None:
            # Serialize credit_specification (handle intrinsic functions)
            if hasattr(self.credit_specification, 'to_dict'):
                props["CreditSpecification"] = self.credit_specification.to_dict()
            elif isinstance(self.credit_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['CreditSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.credit_specification
                ]
            else:
                props["CreditSpecification"] = self.credit_specification

        return props

    @property
    def attr_state__code(self) -> GetAtt:
        """Get the State.Code attribute."""
        return self.get_att("State.Code")

    @property
    def attr_private_dns_name(self) -> GetAtt:
        """Get the PrivateDnsName attribute."""
        return self.get_att("PrivateDnsName")

    @property
    def attr_vpc_id(self) -> GetAtt:
        """Get the VpcId attribute."""
        return self.get_att("VpcId")

    @property
    def attr_private_ip(self) -> GetAtt:
        """Get the PrivateIp attribute."""
        return self.get_att("PrivateIp")

    @property
    def attr_instance_id(self) -> GetAtt:
        """Get the InstanceId attribute."""
        return self.get_att("InstanceId")

    @property
    def attr_public_ip(self) -> GetAtt:
        """Get the PublicIp attribute."""
        return self.get_att("PublicIp")

    @property
    def attr_state__name(self) -> GetAtt:
        """Get the State.Name attribute."""
        return self.get_att("State.Name")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_availability_zone(self) -> GetAtt:
        """Get the AvailabilityZone attribute."""
        return self.get_att("AvailabilityZone")

    @property
    def attr_public_dns_name(self) -> GetAtt:
        """Get the PublicDnsName attribute."""
        return self.get_att("PublicDnsName")




@dataclass
class InstanceConnectEndpoint(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::InstanceConnectEndpoint"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    preserve_client_ip: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_token: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.preserve_client_ip is not None:
            # Serialize preserve_client_ip (handle intrinsic functions)
            if hasattr(self.preserve_client_ip, 'to_dict'):
                props["PreserveClientIp"] = self.preserve_client_ip.to_dict()
            elif isinstance(self.preserve_client_ip, list):
                # Serialize list items (may contain intrinsic functions)
                props['PreserveClientIp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.preserve_client_ip
                ]
            else:
                props["PreserveClientIp"] = self.preserve_client_ip

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        if self.client_token is not None:
            # Serialize client_token (handle intrinsic functions)
            if hasattr(self.client_token, 'to_dict'):
                props["ClientToken"] = self.client_token.to_dict()
            elif isinstance(self.client_token, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientToken'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_token
                ]
            else:
                props["ClientToken"] = self.client_token

        if self.security_group_ids is not None:
            # Serialize security_group_ids (handle intrinsic functions)
            if hasattr(self.security_group_ids, 'to_dict'):
                props["SecurityGroupIds"] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props["SecurityGroupIds"] = self.security_group_ids

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class InternetGateway(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::InternetGateway"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_internet_gateway_id(self) -> GetAtt:
        """Get the InternetGatewayId attribute."""
        return self.get_att("InternetGatewayId")




@dataclass
class IpPoolRouteTableAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::IpPoolRouteTableAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    public_ipv4_pool: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.route_table_id is not None:
            # Serialize route_table_id (handle intrinsic functions)
            if hasattr(self.route_table_id, 'to_dict'):
                props["RouteTableId"] = self.route_table_id.to_dict()
            elif isinstance(self.route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_id
                ]
            else:
                props["RouteTableId"] = self.route_table_id

        if self.public_ipv4_pool is not None:
            # Serialize public_ipv4_pool (handle intrinsic functions)
            if hasattr(self.public_ipv4_pool, 'to_dict'):
                props["PublicIpv4Pool"] = self.public_ipv4_pool.to_dict()
            elif isinstance(self.public_ipv4_pool, list):
                # Serialize list items (may contain intrinsic functions)
                props['PublicIpv4Pool'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_ipv4_pool
                ]
            else:
                props["PublicIpv4Pool"] = self.public_ipv4_pool

        return props

    @property
    def attr_association_id(self) -> GetAtt:
        """Get the AssociationId attribute."""
        return self.get_att("AssociationId")




@dataclass
class KeyPair(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-k"""

    resource_type: ClassVar[str] = "AWS::EC2::KeyPair"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    key_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    key_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    key_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    public_key_material: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.key_name is not None:
            # Serialize key_name (handle intrinsic functions)
            if hasattr(self.key_name, 'to_dict'):
                props["KeyName"] = self.key_name.to_dict()
            elif isinstance(self.key_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['KeyName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_name
                ]
            else:
                props["KeyName"] = self.key_name

        if self.key_type is not None:
            # Serialize key_type (handle intrinsic functions)
            if hasattr(self.key_type, 'to_dict'):
                props["KeyType"] = self.key_type.to_dict()
            elif isinstance(self.key_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['KeyType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_type
                ]
            else:
                props["KeyType"] = self.key_type

        if self.key_format is not None:
            # Serialize key_format (handle intrinsic functions)
            if hasattr(self.key_format, 'to_dict'):
                props["KeyFormat"] = self.key_format.to_dict()
            elif isinstance(self.key_format, list):
                # Serialize list items (may contain intrinsic functions)
                props['KeyFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_format
                ]
            else:
                props["KeyFormat"] = self.key_format

        if self.public_key_material is not None:
            # Serialize public_key_material (handle intrinsic functions)
            if hasattr(self.public_key_material, 'to_dict'):
                props["PublicKeyMaterial"] = self.public_key_material.to_dict()
            elif isinstance(self.public_key_material, list):
                # Serialize list items (may contain intrinsic functions)
                props['PublicKeyMaterial'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_key_material
                ]
            else:
                props["PublicKeyMaterial"] = self.public_key_material

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_key_pair_id(self) -> GetAtt:
        """Get the KeyPairId attribute."""
        return self.get_att("KeyPairId")

    @property
    def attr_key_fingerprint(self) -> GetAtt:
        """Get the KeyFingerprint attribute."""
        return self.get_att("KeyFingerprint")




@dataclass
class AcceleratorCount:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class AcceleratorTotalMemoryMiB:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class BaselineEbsBandwidthMbps:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class BaselinePerformanceFactors:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu: Optional[Cpu] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cpu is not None:
            if hasattr(self.cpu, 'to_dict'):
                props['Cpu'] = self.cpu.to_dict()
            elif isinstance(self.cpu, list):
                props['Cpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu
                ]
            else:
                props['Cpu'] = self.cpu

        return props


@dataclass
class BlockDeviceMapping:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs: Optional[Ebs] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    no_device: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    virtual_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ebs is not None:
            if hasattr(self.ebs, 'to_dict'):
                props['Ebs'] = self.ebs.to_dict()
            elif isinstance(self.ebs, list):
                props['Ebs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs
                ]
            else:
                props['Ebs'] = self.ebs

        if self.no_device is not None:
            if hasattr(self.no_device, 'to_dict'):
                props['NoDevice'] = self.no_device.to_dict()
            elif isinstance(self.no_device, list):
                props['NoDevice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.no_device
                ]
            else:
                props['NoDevice'] = self.no_device

        if self.virtual_name is not None:
            if hasattr(self.virtual_name, 'to_dict'):
                props['VirtualName'] = self.virtual_name.to_dict()
            elif isinstance(self.virtual_name, list):
                props['VirtualName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.virtual_name
                ]
            else:
                props['VirtualName'] = self.virtual_name

        if self.device_name is not None:
            if hasattr(self.device_name, 'to_dict'):
                props['DeviceName'] = self.device_name.to_dict()
            elif isinstance(self.device_name, list):
                props['DeviceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_name
                ]
            else:
                props['DeviceName'] = self.device_name

        return props


@dataclass
class CapacityReservationSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_preference: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_target: Optional[CapacityReservationTarget] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capacity_reservation_preference is not None:
            if hasattr(self.capacity_reservation_preference, 'to_dict'):
                props['CapacityReservationPreference'] = self.capacity_reservation_preference.to_dict()
            elif isinstance(self.capacity_reservation_preference, list):
                props['CapacityReservationPreference'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_preference
                ]
            else:
                props['CapacityReservationPreference'] = self.capacity_reservation_preference

        if self.capacity_reservation_target is not None:
            if hasattr(self.capacity_reservation_target, 'to_dict'):
                props['CapacityReservationTarget'] = self.capacity_reservation_target.to_dict()
            elif isinstance(self.capacity_reservation_target, list):
                props['CapacityReservationTarget'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_target
                ]
            else:
                props['CapacityReservationTarget'] = self.capacity_reservation_target

        return props


@dataclass
class CapacityReservationTarget:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_resource_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capacity_reservation_resource_group_arn is not None:
            if hasattr(self.capacity_reservation_resource_group_arn, 'to_dict'):
                props['CapacityReservationResourceGroupArn'] = self.capacity_reservation_resource_group_arn.to_dict()
            elif isinstance(self.capacity_reservation_resource_group_arn, list):
                props['CapacityReservationResourceGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_resource_group_arn
                ]
            else:
                props['CapacityReservationResourceGroupArn'] = self.capacity_reservation_resource_group_arn

        if self.capacity_reservation_id is not None:
            if hasattr(self.capacity_reservation_id, 'to_dict'):
                props['CapacityReservationId'] = self.capacity_reservation_id.to_dict()
            elif isinstance(self.capacity_reservation_id, list):
                props['CapacityReservationId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_id
                ]
            else:
                props['CapacityReservationId'] = self.capacity_reservation_id

        return props


@dataclass
class ConnectionTrackingSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    udp_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tcp_established_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    udp_stream_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.udp_timeout is not None:
            if hasattr(self.udp_timeout, 'to_dict'):
                props['UdpTimeout'] = self.udp_timeout.to_dict()
            elif isinstance(self.udp_timeout, list):
                props['UdpTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.udp_timeout
                ]
            else:
                props['UdpTimeout'] = self.udp_timeout

        if self.tcp_established_timeout is not None:
            if hasattr(self.tcp_established_timeout, 'to_dict'):
                props['TcpEstablishedTimeout'] = self.tcp_established_timeout.to_dict()
            elif isinstance(self.tcp_established_timeout, list):
                props['TcpEstablishedTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tcp_established_timeout
                ]
            else:
                props['TcpEstablishedTimeout'] = self.tcp_established_timeout

        if self.udp_stream_timeout is not None:
            if hasattr(self.udp_stream_timeout, 'to_dict'):
                props['UdpStreamTimeout'] = self.udp_stream_timeout.to_dict()
            elif isinstance(self.udp_stream_timeout, list):
                props['UdpStreamTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.udp_stream_timeout
                ]
            else:
                props['UdpStreamTimeout'] = self.udp_stream_timeout

        return props


@dataclass
class Cpu:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    references: Optional[list[Reference]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.references is not None:
            if hasattr(self.references, 'to_dict'):
                props['References'] = self.references.to_dict()
            elif isinstance(self.references, list):
                props['References'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.references
                ]
            else:
                props['References'] = self.references

        return props


@dataclass
class CpuOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    threads_per_core: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    amd_sev_snp: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    core_count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.threads_per_core is not None:
            if hasattr(self.threads_per_core, 'to_dict'):
                props['ThreadsPerCore'] = self.threads_per_core.to_dict()
            elif isinstance(self.threads_per_core, list):
                props['ThreadsPerCore'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.threads_per_core
                ]
            else:
                props['ThreadsPerCore'] = self.threads_per_core

        if self.amd_sev_snp is not None:
            if hasattr(self.amd_sev_snp, 'to_dict'):
                props['AmdSevSnp'] = self.amd_sev_snp.to_dict()
            elif isinstance(self.amd_sev_snp, list):
                props['AmdSevSnp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.amd_sev_snp
                ]
            else:
                props['AmdSevSnp'] = self.amd_sev_snp

        if self.core_count is not None:
            if hasattr(self.core_count, 'to_dict'):
                props['CoreCount'] = self.core_count.to_dict()
            elif isinstance(self.core_count, list):
                props['CoreCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.core_count
                ]
            else:
                props['CoreCount'] = self.core_count

        return props


@dataclass
class CreditSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_credits: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cpu_credits is not None:
            if hasattr(self.cpu_credits, 'to_dict'):
                props['CpuCredits'] = self.cpu_credits.to_dict()
            elif isinstance(self.cpu_credits, list):
                props['CpuCredits'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_credits
                ]
            else:
                props['CpuCredits'] = self.cpu_credits

        return props


@dataclass
class Ebs:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snapshot_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encrypted: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    throughput: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_initialization_rate: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.snapshot_id is not None:
            if hasattr(self.snapshot_id, 'to_dict'):
                props['SnapshotId'] = self.snapshot_id.to_dict()
            elif isinstance(self.snapshot_id, list):
                props['SnapshotId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snapshot_id
                ]
            else:
                props['SnapshotId'] = self.snapshot_id

        if self.volume_type is not None:
            if hasattr(self.volume_type, 'to_dict'):
                props['VolumeType'] = self.volume_type.to_dict()
            elif isinstance(self.volume_type, list):
                props['VolumeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_type
                ]
            else:
                props['VolumeType'] = self.volume_type

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.encrypted is not None:
            if hasattr(self.encrypted, 'to_dict'):
                props['Encrypted'] = self.encrypted.to_dict()
            elif isinstance(self.encrypted, list):
                props['Encrypted'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encrypted
                ]
            else:
                props['Encrypted'] = self.encrypted

        if self.throughput is not None:
            if hasattr(self.throughput, 'to_dict'):
                props['Throughput'] = self.throughput.to_dict()
            elif isinstance(self.throughput, list):
                props['Throughput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.throughput
                ]
            else:
                props['Throughput'] = self.throughput

        if self.iops is not None:
            if hasattr(self.iops, 'to_dict'):
                props['Iops'] = self.iops.to_dict()
            elif isinstance(self.iops, list):
                props['Iops'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iops
                ]
            else:
                props['Iops'] = self.iops

        if self.volume_initialization_rate is not None:
            if hasattr(self.volume_initialization_rate, 'to_dict'):
                props['VolumeInitializationRate'] = self.volume_initialization_rate.to_dict()
            elif isinstance(self.volume_initialization_rate, list):
                props['VolumeInitializationRate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_initialization_rate
                ]
            else:
                props['VolumeInitializationRate'] = self.volume_initialization_rate

        if self.volume_size is not None:
            if hasattr(self.volume_size, 'to_dict'):
                props['VolumeSize'] = self.volume_size.to_dict()
            elif isinstance(self.volume_size, list):
                props['VolumeSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size
                ]
            else:
                props['VolumeSize'] = self.volume_size

        if self.delete_on_termination is not None:
            if hasattr(self.delete_on_termination, 'to_dict'):
                props['DeleteOnTermination'] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props['DeleteOnTermination'] = self.delete_on_termination

        return props


@dataclass
class EnaSrdSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_udp_specification: Optional[EnaSrdUdpSpecification] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ena_srd_enabled is not None:
            if hasattr(self.ena_srd_enabled, 'to_dict'):
                props['EnaSrdEnabled'] = self.ena_srd_enabled.to_dict()
            elif isinstance(self.ena_srd_enabled, list):
                props['EnaSrdEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_enabled
                ]
            else:
                props['EnaSrdEnabled'] = self.ena_srd_enabled

        if self.ena_srd_udp_specification is not None:
            if hasattr(self.ena_srd_udp_specification, 'to_dict'):
                props['EnaSrdUdpSpecification'] = self.ena_srd_udp_specification.to_dict()
            elif isinstance(self.ena_srd_udp_specification, list):
                props['EnaSrdUdpSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_udp_specification
                ]
            else:
                props['EnaSrdUdpSpecification'] = self.ena_srd_udp_specification

        return props


@dataclass
class EnaSrdUdpSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_udp_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ena_srd_udp_enabled is not None:
            if hasattr(self.ena_srd_udp_enabled, 'to_dict'):
                props['EnaSrdUdpEnabled'] = self.ena_srd_udp_enabled.to_dict()
            elif isinstance(self.ena_srd_udp_enabled, list):
                props['EnaSrdUdpEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_udp_enabled
                ]
            else:
                props['EnaSrdUdpEnabled'] = self.ena_srd_udp_enabled

        return props


@dataclass
class EnclaveOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class HibernationOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    configured: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.configured is not None:
            if hasattr(self.configured, 'to_dict'):
                props['Configured'] = self.configured.to_dict()
            elif isinstance(self.configured, list):
                props['Configured'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.configured
                ]
            else:
                props['Configured'] = self.configured

        return props


@dataclass
class IamInstanceProfile:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.arn is not None:
            if hasattr(self.arn, 'to_dict'):
                props['Arn'] = self.arn.to_dict()
            elif isinstance(self.arn, list):
                props['Arn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.arn
                ]
            else:
                props['Arn'] = self.arn

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class InstanceMarketOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_options: Optional[SpotOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    market_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.spot_options is not None:
            if hasattr(self.spot_options, 'to_dict'):
                props['SpotOptions'] = self.spot_options.to_dict()
            elif isinstance(self.spot_options, list):
                props['SpotOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_options
                ]
            else:
                props['SpotOptions'] = self.spot_options

        if self.market_type is not None:
            if hasattr(self.market_type, 'to_dict'):
                props['MarketType'] = self.market_type.to_dict()
            elif isinstance(self.market_type, list):
                props['MarketType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.market_type
                ]
            else:
                props['MarketType'] = self.market_type

        return props


@dataclass
class InstanceRequirements:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_generations: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_gi_b_per_v_cpu: Optional[MemoryGiBPerVCpu] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    v_cpu_count: Optional[VCpuCount] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_manufacturers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_storage: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_manufacturers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bare_metal: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    require_hibernate_support: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_max_price_percentage_over_lowest_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_mi_b: Optional[MemoryMiB] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_storage_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_count: Optional[NetworkInterfaceCount] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    excluded_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allowed_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_count: Optional[AcceleratorCount] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_bandwidth_gbps: Optional[NetworkBandwidthGbps] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_performance_factors: Optional[BaselinePerformanceFactors] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_max_price_percentage_over_lowest_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_ebs_bandwidth_mbps: Optional[BaselineEbsBandwidthMbps] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_total_memory_mi_b: Optional[AcceleratorTotalMemoryMiB] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    burstable_performance: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    total_local_storage_gb: Optional[TotalLocalStorageGB] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_generations is not None:
            if hasattr(self.instance_generations, 'to_dict'):
                props['InstanceGenerations'] = self.instance_generations.to_dict()
            elif isinstance(self.instance_generations, list):
                props['InstanceGenerations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_generations
                ]
            else:
                props['InstanceGenerations'] = self.instance_generations

        if self.memory_gi_b_per_v_cpu is not None:
            if hasattr(self.memory_gi_b_per_v_cpu, 'to_dict'):
                props['MemoryGiBPerVCpu'] = self.memory_gi_b_per_v_cpu.to_dict()
            elif isinstance(self.memory_gi_b_per_v_cpu, list):
                props['MemoryGiBPerVCpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_gi_b_per_v_cpu
                ]
            else:
                props['MemoryGiBPerVCpu'] = self.memory_gi_b_per_v_cpu

        if self.accelerator_types is not None:
            if hasattr(self.accelerator_types, 'to_dict'):
                props['AcceleratorTypes'] = self.accelerator_types.to_dict()
            elif isinstance(self.accelerator_types, list):
                props['AcceleratorTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_types
                ]
            else:
                props['AcceleratorTypes'] = self.accelerator_types

        if self.v_cpu_count is not None:
            if hasattr(self.v_cpu_count, 'to_dict'):
                props['VCpuCount'] = self.v_cpu_count.to_dict()
            elif isinstance(self.v_cpu_count, list):
                props['VCpuCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.v_cpu_count
                ]
            else:
                props['VCpuCount'] = self.v_cpu_count

        if self.accelerator_manufacturers is not None:
            if hasattr(self.accelerator_manufacturers, 'to_dict'):
                props['AcceleratorManufacturers'] = self.accelerator_manufacturers.to_dict()
            elif isinstance(self.accelerator_manufacturers, list):
                props['AcceleratorManufacturers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_manufacturers
                ]
            else:
                props['AcceleratorManufacturers'] = self.accelerator_manufacturers

        if self.local_storage is not None:
            if hasattr(self.local_storage, 'to_dict'):
                props['LocalStorage'] = self.local_storage.to_dict()
            elif isinstance(self.local_storage, list):
                props['LocalStorage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_storage
                ]
            else:
                props['LocalStorage'] = self.local_storage

        if self.cpu_manufacturers is not None:
            if hasattr(self.cpu_manufacturers, 'to_dict'):
                props['CpuManufacturers'] = self.cpu_manufacturers.to_dict()
            elif isinstance(self.cpu_manufacturers, list):
                props['CpuManufacturers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_manufacturers
                ]
            else:
                props['CpuManufacturers'] = self.cpu_manufacturers

        if self.bare_metal is not None:
            if hasattr(self.bare_metal, 'to_dict'):
                props['BareMetal'] = self.bare_metal.to_dict()
            elif isinstance(self.bare_metal, list):
                props['BareMetal'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bare_metal
                ]
            else:
                props['BareMetal'] = self.bare_metal

        if self.require_hibernate_support is not None:
            if hasattr(self.require_hibernate_support, 'to_dict'):
                props['RequireHibernateSupport'] = self.require_hibernate_support.to_dict()
            elif isinstance(self.require_hibernate_support, list):
                props['RequireHibernateSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.require_hibernate_support
                ]
            else:
                props['RequireHibernateSupport'] = self.require_hibernate_support

        if self.max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            if hasattr(self.max_spot_price_as_percentage_of_optimal_on_demand_price, 'to_dict'):
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = self.max_spot_price_as_percentage_of_optimal_on_demand_price.to_dict()
            elif isinstance(self.max_spot_price_as_percentage_of_optimal_on_demand_price, list):
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_spot_price_as_percentage_of_optimal_on_demand_price
                ]
            else:
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = self.max_spot_price_as_percentage_of_optimal_on_demand_price

        if self.on_demand_max_price_percentage_over_lowest_price is not None:
            if hasattr(self.on_demand_max_price_percentage_over_lowest_price, 'to_dict'):
                props['OnDemandMaxPricePercentageOverLowestPrice'] = self.on_demand_max_price_percentage_over_lowest_price.to_dict()
            elif isinstance(self.on_demand_max_price_percentage_over_lowest_price, list):
                props['OnDemandMaxPricePercentageOverLowestPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_max_price_percentage_over_lowest_price
                ]
            else:
                props['OnDemandMaxPricePercentageOverLowestPrice'] = self.on_demand_max_price_percentage_over_lowest_price

        if self.memory_mi_b is not None:
            if hasattr(self.memory_mi_b, 'to_dict'):
                props['MemoryMiB'] = self.memory_mi_b.to_dict()
            elif isinstance(self.memory_mi_b, list):
                props['MemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_mi_b
                ]
            else:
                props['MemoryMiB'] = self.memory_mi_b

        if self.local_storage_types is not None:
            if hasattr(self.local_storage_types, 'to_dict'):
                props['LocalStorageTypes'] = self.local_storage_types.to_dict()
            elif isinstance(self.local_storage_types, list):
                props['LocalStorageTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_storage_types
                ]
            else:
                props['LocalStorageTypes'] = self.local_storage_types

        if self.network_interface_count is not None:
            if hasattr(self.network_interface_count, 'to_dict'):
                props['NetworkInterfaceCount'] = self.network_interface_count.to_dict()
            elif isinstance(self.network_interface_count, list):
                props['NetworkInterfaceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_count
                ]
            else:
                props['NetworkInterfaceCount'] = self.network_interface_count

        if self.excluded_instance_types is not None:
            if hasattr(self.excluded_instance_types, 'to_dict'):
                props['ExcludedInstanceTypes'] = self.excluded_instance_types.to_dict()
            elif isinstance(self.excluded_instance_types, list):
                props['ExcludedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.excluded_instance_types
                ]
            else:
                props['ExcludedInstanceTypes'] = self.excluded_instance_types

        if self.allowed_instance_types is not None:
            if hasattr(self.allowed_instance_types, 'to_dict'):
                props['AllowedInstanceTypes'] = self.allowed_instance_types.to_dict()
            elif isinstance(self.allowed_instance_types, list):
                props['AllowedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_instance_types
                ]
            else:
                props['AllowedInstanceTypes'] = self.allowed_instance_types

        if self.accelerator_count is not None:
            if hasattr(self.accelerator_count, 'to_dict'):
                props['AcceleratorCount'] = self.accelerator_count.to_dict()
            elif isinstance(self.accelerator_count, list):
                props['AcceleratorCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_count
                ]
            else:
                props['AcceleratorCount'] = self.accelerator_count

        if self.network_bandwidth_gbps is not None:
            if hasattr(self.network_bandwidth_gbps, 'to_dict'):
                props['NetworkBandwidthGbps'] = self.network_bandwidth_gbps.to_dict()
            elif isinstance(self.network_bandwidth_gbps, list):
                props['NetworkBandwidthGbps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_bandwidth_gbps
                ]
            else:
                props['NetworkBandwidthGbps'] = self.network_bandwidth_gbps

        if self.baseline_performance_factors is not None:
            if hasattr(self.baseline_performance_factors, 'to_dict'):
                props['BaselinePerformanceFactors'] = self.baseline_performance_factors.to_dict()
            elif isinstance(self.baseline_performance_factors, list):
                props['BaselinePerformanceFactors'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baseline_performance_factors
                ]
            else:
                props['BaselinePerformanceFactors'] = self.baseline_performance_factors

        if self.spot_max_price_percentage_over_lowest_price is not None:
            if hasattr(self.spot_max_price_percentage_over_lowest_price, 'to_dict'):
                props['SpotMaxPricePercentageOverLowestPrice'] = self.spot_max_price_percentage_over_lowest_price.to_dict()
            elif isinstance(self.spot_max_price_percentage_over_lowest_price, list):
                props['SpotMaxPricePercentageOverLowestPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_max_price_percentage_over_lowest_price
                ]
            else:
                props['SpotMaxPricePercentageOverLowestPrice'] = self.spot_max_price_percentage_over_lowest_price

        if self.baseline_ebs_bandwidth_mbps is not None:
            if hasattr(self.baseline_ebs_bandwidth_mbps, 'to_dict'):
                props['BaselineEbsBandwidthMbps'] = self.baseline_ebs_bandwidth_mbps.to_dict()
            elif isinstance(self.baseline_ebs_bandwidth_mbps, list):
                props['BaselineEbsBandwidthMbps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baseline_ebs_bandwidth_mbps
                ]
            else:
                props['BaselineEbsBandwidthMbps'] = self.baseline_ebs_bandwidth_mbps

        if self.accelerator_names is not None:
            if hasattr(self.accelerator_names, 'to_dict'):
                props['AcceleratorNames'] = self.accelerator_names.to_dict()
            elif isinstance(self.accelerator_names, list):
                props['AcceleratorNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_names
                ]
            else:
                props['AcceleratorNames'] = self.accelerator_names

        if self.accelerator_total_memory_mi_b is not None:
            if hasattr(self.accelerator_total_memory_mi_b, 'to_dict'):
                props['AcceleratorTotalMemoryMiB'] = self.accelerator_total_memory_mi_b.to_dict()
            elif isinstance(self.accelerator_total_memory_mi_b, list):
                props['AcceleratorTotalMemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_total_memory_mi_b
                ]
            else:
                props['AcceleratorTotalMemoryMiB'] = self.accelerator_total_memory_mi_b

        if self.burstable_performance is not None:
            if hasattr(self.burstable_performance, 'to_dict'):
                props['BurstablePerformance'] = self.burstable_performance.to_dict()
            elif isinstance(self.burstable_performance, list):
                props['BurstablePerformance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.burstable_performance
                ]
            else:
                props['BurstablePerformance'] = self.burstable_performance

        if self.total_local_storage_gb is not None:
            if hasattr(self.total_local_storage_gb, 'to_dict'):
                props['TotalLocalStorageGB'] = self.total_local_storage_gb.to_dict()
            elif isinstance(self.total_local_storage_gb, list):
                props['TotalLocalStorageGB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_local_storage_gb
                ]
            else:
                props['TotalLocalStorageGB'] = self.total_local_storage_gb

        return props


@dataclass
class Ipv4PrefixSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv4_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv4_prefix is not None:
            if hasattr(self.ipv4_prefix, 'to_dict'):
                props['Ipv4Prefix'] = self.ipv4_prefix.to_dict()
            elif isinstance(self.ipv4_prefix, list):
                props['Ipv4Prefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_prefix
                ]
            else:
                props['Ipv4Prefix'] = self.ipv4_prefix

        return props


@dataclass
class Ipv6Add:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_address: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_address is not None:
            if hasattr(self.ipv6_address, 'to_dict'):
                props['Ipv6Address'] = self.ipv6_address.to_dict()
            elif isinstance(self.ipv6_address, list):
                props['Ipv6Address'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address
                ]
            else:
                props['Ipv6Address'] = self.ipv6_address

        return props


@dataclass
class Ipv6PrefixSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_prefix is not None:
            if hasattr(self.ipv6_prefix, 'to_dict'):
                props['Ipv6Prefix'] = self.ipv6_prefix.to_dict()
            elif isinstance(self.ipv6_prefix, list):
                props['Ipv6Prefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_prefix
                ]
            else:
                props['Ipv6Prefix'] = self.ipv6_prefix

        return props


@dataclass
class LaunchTemplateData:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_specifications: Optional[list[TagSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_performance_options: Optional[NetworkPerformanceOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    block_device_mappings: Optional[list[BlockDeviceMapping]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maintenance_options: Optional[MaintenanceOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iam_instance_profile: Optional[IamInstanceProfile] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kernel_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs_optimized: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    placement: Optional[Placement] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interfaces: Optional[list[NetworkInterface]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enclave_options: Optional[EnclaveOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring: Optional[Monitoring] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hibernation_options: Optional[HibernationOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metadata_options: Optional[MetadataOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    license_specifications: Optional[list[LicenseSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_initiated_shutdown_behavior: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    disable_api_stop: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_options: Optional[CpuOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_dns_name_options: Optional[PrivateDnsNameOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    disable_api_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_market_options: Optional[InstanceMarketOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_requirements: Optional[InstanceRequirements] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ram_disk_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_specification: Optional[CapacityReservationSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    credit_specification: Optional[CreditSpecification] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.security_groups is not None:
            if hasattr(self.security_groups, 'to_dict'):
                props['SecurityGroups'] = self.security_groups.to_dict()
            elif isinstance(self.security_groups, list):
                props['SecurityGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_groups
                ]
            else:
                props['SecurityGroups'] = self.security_groups

        if self.tag_specifications is not None:
            if hasattr(self.tag_specifications, 'to_dict'):
                props['TagSpecifications'] = self.tag_specifications.to_dict()
            elif isinstance(self.tag_specifications, list):
                props['TagSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_specifications
                ]
            else:
                props['TagSpecifications'] = self.tag_specifications

        if self.network_performance_options is not None:
            if hasattr(self.network_performance_options, 'to_dict'):
                props['NetworkPerformanceOptions'] = self.network_performance_options.to_dict()
            elif isinstance(self.network_performance_options, list):
                props['NetworkPerformanceOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_performance_options
                ]
            else:
                props['NetworkPerformanceOptions'] = self.network_performance_options

        if self.user_data is not None:
            if hasattr(self.user_data, 'to_dict'):
                props['UserData'] = self.user_data.to_dict()
            elif isinstance(self.user_data, list):
                props['UserData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_data
                ]
            else:
                props['UserData'] = self.user_data

        if self.block_device_mappings is not None:
            if hasattr(self.block_device_mappings, 'to_dict'):
                props['BlockDeviceMappings'] = self.block_device_mappings.to_dict()
            elif isinstance(self.block_device_mappings, list):
                props['BlockDeviceMappings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.block_device_mappings
                ]
            else:
                props['BlockDeviceMappings'] = self.block_device_mappings

        if self.maintenance_options is not None:
            if hasattr(self.maintenance_options, 'to_dict'):
                props['MaintenanceOptions'] = self.maintenance_options.to_dict()
            elif isinstance(self.maintenance_options, list):
                props['MaintenanceOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maintenance_options
                ]
            else:
                props['MaintenanceOptions'] = self.maintenance_options

        if self.iam_instance_profile is not None:
            if hasattr(self.iam_instance_profile, 'to_dict'):
                props['IamInstanceProfile'] = self.iam_instance_profile.to_dict()
            elif isinstance(self.iam_instance_profile, list):
                props['IamInstanceProfile'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iam_instance_profile
                ]
            else:
                props['IamInstanceProfile'] = self.iam_instance_profile

        if self.kernel_id is not None:
            if hasattr(self.kernel_id, 'to_dict'):
                props['KernelId'] = self.kernel_id.to_dict()
            elif isinstance(self.kernel_id, list):
                props['KernelId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kernel_id
                ]
            else:
                props['KernelId'] = self.kernel_id

        if self.ebs_optimized is not None:
            if hasattr(self.ebs_optimized, 'to_dict'):
                props['EbsOptimized'] = self.ebs_optimized.to_dict()
            elif isinstance(self.ebs_optimized, list):
                props['EbsOptimized'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_optimized
                ]
            else:
                props['EbsOptimized'] = self.ebs_optimized

        if self.placement is not None:
            if hasattr(self.placement, 'to_dict'):
                props['Placement'] = self.placement.to_dict()
            elif isinstance(self.placement, list):
                props['Placement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.placement
                ]
            else:
                props['Placement'] = self.placement

        if self.network_interfaces is not None:
            if hasattr(self.network_interfaces, 'to_dict'):
                props['NetworkInterfaces'] = self.network_interfaces.to_dict()
            elif isinstance(self.network_interfaces, list):
                props['NetworkInterfaces'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interfaces
                ]
            else:
                props['NetworkInterfaces'] = self.network_interfaces

        if self.enclave_options is not None:
            if hasattr(self.enclave_options, 'to_dict'):
                props['EnclaveOptions'] = self.enclave_options.to_dict()
            elif isinstance(self.enclave_options, list):
                props['EnclaveOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enclave_options
                ]
            else:
                props['EnclaveOptions'] = self.enclave_options

        if self.image_id is not None:
            if hasattr(self.image_id, 'to_dict'):
                props['ImageId'] = self.image_id.to_dict()
            elif isinstance(self.image_id, list):
                props['ImageId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_id
                ]
            else:
                props['ImageId'] = self.image_id

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        if self.monitoring is not None:
            if hasattr(self.monitoring, 'to_dict'):
                props['Monitoring'] = self.monitoring.to_dict()
            elif isinstance(self.monitoring, list):
                props['Monitoring'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring
                ]
            else:
                props['Monitoring'] = self.monitoring

        if self.hibernation_options is not None:
            if hasattr(self.hibernation_options, 'to_dict'):
                props['HibernationOptions'] = self.hibernation_options.to_dict()
            elif isinstance(self.hibernation_options, list):
                props['HibernationOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hibernation_options
                ]
            else:
                props['HibernationOptions'] = self.hibernation_options

        if self.metadata_options is not None:
            if hasattr(self.metadata_options, 'to_dict'):
                props['MetadataOptions'] = self.metadata_options.to_dict()
            elif isinstance(self.metadata_options, list):
                props['MetadataOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metadata_options
                ]
            else:
                props['MetadataOptions'] = self.metadata_options

        if self.license_specifications is not None:
            if hasattr(self.license_specifications, 'to_dict'):
                props['LicenseSpecifications'] = self.license_specifications.to_dict()
            elif isinstance(self.license_specifications, list):
                props['LicenseSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.license_specifications
                ]
            else:
                props['LicenseSpecifications'] = self.license_specifications

        if self.instance_initiated_shutdown_behavior is not None:
            if hasattr(self.instance_initiated_shutdown_behavior, 'to_dict'):
                props['InstanceInitiatedShutdownBehavior'] = self.instance_initiated_shutdown_behavior.to_dict()
            elif isinstance(self.instance_initiated_shutdown_behavior, list):
                props['InstanceInitiatedShutdownBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_initiated_shutdown_behavior
                ]
            else:
                props['InstanceInitiatedShutdownBehavior'] = self.instance_initiated_shutdown_behavior

        if self.disable_api_stop is not None:
            if hasattr(self.disable_api_stop, 'to_dict'):
                props['DisableApiStop'] = self.disable_api_stop.to_dict()
            elif isinstance(self.disable_api_stop, list):
                props['DisableApiStop'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disable_api_stop
                ]
            else:
                props['DisableApiStop'] = self.disable_api_stop

        if self.cpu_options is not None:
            if hasattr(self.cpu_options, 'to_dict'):
                props['CpuOptions'] = self.cpu_options.to_dict()
            elif isinstance(self.cpu_options, list):
                props['CpuOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_options
                ]
            else:
                props['CpuOptions'] = self.cpu_options

        if self.private_dns_name_options is not None:
            if hasattr(self.private_dns_name_options, 'to_dict'):
                props['PrivateDnsNameOptions'] = self.private_dns_name_options.to_dict()
            elif isinstance(self.private_dns_name_options, list):
                props['PrivateDnsNameOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_dns_name_options
                ]
            else:
                props['PrivateDnsNameOptions'] = self.private_dns_name_options

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        if self.key_name is not None:
            if hasattr(self.key_name, 'to_dict'):
                props['KeyName'] = self.key_name.to_dict()
            elif isinstance(self.key_name, list):
                props['KeyName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_name
                ]
            else:
                props['KeyName'] = self.key_name

        if self.disable_api_termination is not None:
            if hasattr(self.disable_api_termination, 'to_dict'):
                props['DisableApiTermination'] = self.disable_api_termination.to_dict()
            elif isinstance(self.disable_api_termination, list):
                props['DisableApiTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disable_api_termination
                ]
            else:
                props['DisableApiTermination'] = self.disable_api_termination

        if self.instance_market_options is not None:
            if hasattr(self.instance_market_options, 'to_dict'):
                props['InstanceMarketOptions'] = self.instance_market_options.to_dict()
            elif isinstance(self.instance_market_options, list):
                props['InstanceMarketOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_market_options
                ]
            else:
                props['InstanceMarketOptions'] = self.instance_market_options

        if self.instance_requirements is not None:
            if hasattr(self.instance_requirements, 'to_dict'):
                props['InstanceRequirements'] = self.instance_requirements.to_dict()
            elif isinstance(self.instance_requirements, list):
                props['InstanceRequirements'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_requirements
                ]
            else:
                props['InstanceRequirements'] = self.instance_requirements

        if self.ram_disk_id is not None:
            if hasattr(self.ram_disk_id, 'to_dict'):
                props['RamDiskId'] = self.ram_disk_id.to_dict()
            elif isinstance(self.ram_disk_id, list):
                props['RamDiskId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ram_disk_id
                ]
            else:
                props['RamDiskId'] = self.ram_disk_id

        if self.capacity_reservation_specification is not None:
            if hasattr(self.capacity_reservation_specification, 'to_dict'):
                props['CapacityReservationSpecification'] = self.capacity_reservation_specification.to_dict()
            elif isinstance(self.capacity_reservation_specification, list):
                props['CapacityReservationSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_specification
                ]
            else:
                props['CapacityReservationSpecification'] = self.capacity_reservation_specification

        if self.credit_specification is not None:
            if hasattr(self.credit_specification, 'to_dict'):
                props['CreditSpecification'] = self.credit_specification.to_dict()
            elif isinstance(self.credit_specification, list):
                props['CreditSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.credit_specification
                ]
            else:
                props['CreditSpecification'] = self.credit_specification

        return props


@dataclass
class LaunchTemplateTagSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tags: Optional[list[Tag]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        if self.tags is not None:
            if hasattr(self.tags, 'to_dict'):
                props['Tags'] = self.tags.to_dict()
            elif isinstance(self.tags, list):
                props['Tags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tags
                ]
            else:
                props['Tags'] = self.tags

        return props


@dataclass
class LicenseSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    license_configuration_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.license_configuration_arn is not None:
            if hasattr(self.license_configuration_arn, 'to_dict'):
                props['LicenseConfigurationArn'] = self.license_configuration_arn.to_dict()
            elif isinstance(self.license_configuration_arn, list):
                props['LicenseConfigurationArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.license_configuration_arn
                ]
            else:
                props['LicenseConfigurationArn'] = self.license_configuration_arn

        return props


@dataclass
class MaintenanceOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auto_recovery: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.auto_recovery is not None:
            if hasattr(self.auto_recovery, 'to_dict'):
                props['AutoRecovery'] = self.auto_recovery.to_dict()
            elif isinstance(self.auto_recovery, list):
                props['AutoRecovery'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_recovery
                ]
            else:
                props['AutoRecovery'] = self.auto_recovery

        return props


@dataclass
class MemoryGiBPerVCpu:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class MemoryMiB:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class MetadataOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_put_response_hop_limit: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_tokens: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_protocol_ipv6: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_metadata_tags: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.http_put_response_hop_limit is not None:
            if hasattr(self.http_put_response_hop_limit, 'to_dict'):
                props['HttpPutResponseHopLimit'] = self.http_put_response_hop_limit.to_dict()
            elif isinstance(self.http_put_response_hop_limit, list):
                props['HttpPutResponseHopLimit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_put_response_hop_limit
                ]
            else:
                props['HttpPutResponseHopLimit'] = self.http_put_response_hop_limit

        if self.http_tokens is not None:
            if hasattr(self.http_tokens, 'to_dict'):
                props['HttpTokens'] = self.http_tokens.to_dict()
            elif isinstance(self.http_tokens, list):
                props['HttpTokens'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_tokens
                ]
            else:
                props['HttpTokens'] = self.http_tokens

        if self.http_protocol_ipv6 is not None:
            if hasattr(self.http_protocol_ipv6, 'to_dict'):
                props['HttpProtocolIpv6'] = self.http_protocol_ipv6.to_dict()
            elif isinstance(self.http_protocol_ipv6, list):
                props['HttpProtocolIpv6'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_protocol_ipv6
                ]
            else:
                props['HttpProtocolIpv6'] = self.http_protocol_ipv6

        if self.instance_metadata_tags is not None:
            if hasattr(self.instance_metadata_tags, 'to_dict'):
                props['InstanceMetadataTags'] = self.instance_metadata_tags.to_dict()
            elif isinstance(self.instance_metadata_tags, list):
                props['InstanceMetadataTags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_metadata_tags
                ]
            else:
                props['InstanceMetadataTags'] = self.instance_metadata_tags

        if self.http_endpoint is not None:
            if hasattr(self.http_endpoint, 'to_dict'):
                props['HttpEndpoint'] = self.http_endpoint.to_dict()
            elif isinstance(self.http_endpoint, list):
                props['HttpEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_endpoint
                ]
            else:
                props['HttpEndpoint'] = self.http_endpoint

        return props


@dataclass
class Monitoring:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class NetworkBandwidthGbps:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class NetworkInterface:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_addresses: Optional[list[PrivateIpAdd]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    secondary_private_ip_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_prefix_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv4_prefixes: Optional[list[Ipv4PrefixSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_index: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    primary_ipv6: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv4_prefix_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_queue_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_prefixes: Optional[list[Ipv6PrefixSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_addresses: Optional[list[Ipv6Add]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    associate_public_ip_address: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_card_index: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    interface_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    associate_carrier_ip_address: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_specification: Optional[EnaSrdSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    connection_tracking_specification: Optional[ConnectionTrackingSpecification] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.private_ip_address is not None:
            if hasattr(self.private_ip_address, 'to_dict'):
                props['PrivateIpAddress'] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props['PrivateIpAddress'] = self.private_ip_address

        if self.private_ip_addresses is not None:
            if hasattr(self.private_ip_addresses, 'to_dict'):
                props['PrivateIpAddresses'] = self.private_ip_addresses.to_dict()
            elif isinstance(self.private_ip_addresses, list):
                props['PrivateIpAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_addresses
                ]
            else:
                props['PrivateIpAddresses'] = self.private_ip_addresses

        if self.secondary_private_ip_address_count is not None:
            if hasattr(self.secondary_private_ip_address_count, 'to_dict'):
                props['SecondaryPrivateIpAddressCount'] = self.secondary_private_ip_address_count.to_dict()
            elif isinstance(self.secondary_private_ip_address_count, list):
                props['SecondaryPrivateIpAddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_private_ip_address_count
                ]
            else:
                props['SecondaryPrivateIpAddressCount'] = self.secondary_private_ip_address_count

        if self.ipv6_prefix_count is not None:
            if hasattr(self.ipv6_prefix_count, 'to_dict'):
                props['Ipv6PrefixCount'] = self.ipv6_prefix_count.to_dict()
            elif isinstance(self.ipv6_prefix_count, list):
                props['Ipv6PrefixCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_prefix_count
                ]
            else:
                props['Ipv6PrefixCount'] = self.ipv6_prefix_count

        if self.ipv4_prefixes is not None:
            if hasattr(self.ipv4_prefixes, 'to_dict'):
                props['Ipv4Prefixes'] = self.ipv4_prefixes.to_dict()
            elif isinstance(self.ipv4_prefixes, list):
                props['Ipv4Prefixes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_prefixes
                ]
            else:
                props['Ipv4Prefixes'] = self.ipv4_prefixes

        if self.device_index is not None:
            if hasattr(self.device_index, 'to_dict'):
                props['DeviceIndex'] = self.device_index.to_dict()
            elif isinstance(self.device_index, list):
                props['DeviceIndex'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_index
                ]
            else:
                props['DeviceIndex'] = self.device_index

        if self.primary_ipv6 is not None:
            if hasattr(self.primary_ipv6, 'to_dict'):
                props['PrimaryIpv6'] = self.primary_ipv6.to_dict()
            elif isinstance(self.primary_ipv6, list):
                props['PrimaryIpv6'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.primary_ipv6
                ]
            else:
                props['PrimaryIpv6'] = self.primary_ipv6

        if self.ipv4_prefix_count is not None:
            if hasattr(self.ipv4_prefix_count, 'to_dict'):
                props['Ipv4PrefixCount'] = self.ipv4_prefix_count.to_dict()
            elif isinstance(self.ipv4_prefix_count, list):
                props['Ipv4PrefixCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_prefix_count
                ]
            else:
                props['Ipv4PrefixCount'] = self.ipv4_prefix_count

        if self.ena_queue_count is not None:
            if hasattr(self.ena_queue_count, 'to_dict'):
                props['EnaQueueCount'] = self.ena_queue_count.to_dict()
            elif isinstance(self.ena_queue_count, list):
                props['EnaQueueCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_queue_count
                ]
            else:
                props['EnaQueueCount'] = self.ena_queue_count

        if self.ipv6_prefixes is not None:
            if hasattr(self.ipv6_prefixes, 'to_dict'):
                props['Ipv6Prefixes'] = self.ipv6_prefixes.to_dict()
            elif isinstance(self.ipv6_prefixes, list):
                props['Ipv6Prefixes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_prefixes
                ]
            else:
                props['Ipv6Prefixes'] = self.ipv6_prefixes

        if self.subnet_id is not None:
            if hasattr(self.subnet_id, 'to_dict'):
                props['SubnetId'] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props['SubnetId'] = self.subnet_id

        if self.ipv6_addresses is not None:
            if hasattr(self.ipv6_addresses, 'to_dict'):
                props['Ipv6Addresses'] = self.ipv6_addresses.to_dict()
            elif isinstance(self.ipv6_addresses, list):
                props['Ipv6Addresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_addresses
                ]
            else:
                props['Ipv6Addresses'] = self.ipv6_addresses

        if self.associate_public_ip_address is not None:
            if hasattr(self.associate_public_ip_address, 'to_dict'):
                props['AssociatePublicIpAddress'] = self.associate_public_ip_address.to_dict()
            elif isinstance(self.associate_public_ip_address, list):
                props['AssociatePublicIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.associate_public_ip_address
                ]
            else:
                props['AssociatePublicIpAddress'] = self.associate_public_ip_address

        if self.network_interface_id is not None:
            if hasattr(self.network_interface_id, 'to_dict'):
                props['NetworkInterfaceId'] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props['NetworkInterfaceId'] = self.network_interface_id

        if self.network_card_index is not None:
            if hasattr(self.network_card_index, 'to_dict'):
                props['NetworkCardIndex'] = self.network_card_index.to_dict()
            elif isinstance(self.network_card_index, list):
                props['NetworkCardIndex'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_card_index
                ]
            else:
                props['NetworkCardIndex'] = self.network_card_index

        if self.interface_type is not None:
            if hasattr(self.interface_type, 'to_dict'):
                props['InterfaceType'] = self.interface_type.to_dict()
            elif isinstance(self.interface_type, list):
                props['InterfaceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.interface_type
                ]
            else:
                props['InterfaceType'] = self.interface_type

        if self.associate_carrier_ip_address is not None:
            if hasattr(self.associate_carrier_ip_address, 'to_dict'):
                props['AssociateCarrierIpAddress'] = self.associate_carrier_ip_address.to_dict()
            elif isinstance(self.associate_carrier_ip_address, list):
                props['AssociateCarrierIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.associate_carrier_ip_address
                ]
            else:
                props['AssociateCarrierIpAddress'] = self.associate_carrier_ip_address

        if self.ena_srd_specification is not None:
            if hasattr(self.ena_srd_specification, 'to_dict'):
                props['EnaSrdSpecification'] = self.ena_srd_specification.to_dict()
            elif isinstance(self.ena_srd_specification, list):
                props['EnaSrdSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_specification
                ]
            else:
                props['EnaSrdSpecification'] = self.ena_srd_specification

        if self.ipv6_address_count is not None:
            if hasattr(self.ipv6_address_count, 'to_dict'):
                props['Ipv6AddressCount'] = self.ipv6_address_count.to_dict()
            elif isinstance(self.ipv6_address_count, list):
                props['Ipv6AddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address_count
                ]
            else:
                props['Ipv6AddressCount'] = self.ipv6_address_count

        if self.groups is not None:
            if hasattr(self.groups, 'to_dict'):
                props['Groups'] = self.groups.to_dict()
            elif isinstance(self.groups, list):
                props['Groups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.groups
                ]
            else:
                props['Groups'] = self.groups

        if self.delete_on_termination is not None:
            if hasattr(self.delete_on_termination, 'to_dict'):
                props['DeleteOnTermination'] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props['DeleteOnTermination'] = self.delete_on_termination

        if self.connection_tracking_specification is not None:
            if hasattr(self.connection_tracking_specification, 'to_dict'):
                props['ConnectionTrackingSpecification'] = self.connection_tracking_specification.to_dict()
            elif isinstance(self.connection_tracking_specification, list):
                props['ConnectionTrackingSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connection_tracking_specification
                ]
            else:
                props['ConnectionTrackingSpecification'] = self.connection_tracking_specification

        return props


@dataclass
class NetworkInterfaceCount:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class NetworkPerformanceOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bandwidth_weighting: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.bandwidth_weighting is not None:
            if hasattr(self.bandwidth_weighting, 'to_dict'):
                props['BandwidthWeighting'] = self.bandwidth_weighting.to_dict()
            elif isinstance(self.bandwidth_weighting, list):
                props['BandwidthWeighting'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bandwidth_weighting
                ]
            else:
                props['BandwidthWeighting'] = self.bandwidth_weighting

        return props


@dataclass
class Placement:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tenancy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spread_domain: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    partition_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    affinity: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    host_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    host_resource_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.group_name is not None:
            if hasattr(self.group_name, 'to_dict'):
                props['GroupName'] = self.group_name.to_dict()
            elif isinstance(self.group_name, list):
                props['GroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_name
                ]
            else:
                props['GroupName'] = self.group_name

        if self.tenancy is not None:
            if hasattr(self.tenancy, 'to_dict'):
                props['Tenancy'] = self.tenancy.to_dict()
            elif isinstance(self.tenancy, list):
                props['Tenancy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tenancy
                ]
            else:
                props['Tenancy'] = self.tenancy

        if self.spread_domain is not None:
            if hasattr(self.spread_domain, 'to_dict'):
                props['SpreadDomain'] = self.spread_domain.to_dict()
            elif isinstance(self.spread_domain, list):
                props['SpreadDomain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spread_domain
                ]
            else:
                props['SpreadDomain'] = self.spread_domain

        if self.partition_number is not None:
            if hasattr(self.partition_number, 'to_dict'):
                props['PartitionNumber'] = self.partition_number.to_dict()
            elif isinstance(self.partition_number, list):
                props['PartitionNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.partition_number
                ]
            else:
                props['PartitionNumber'] = self.partition_number

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        if self.affinity is not None:
            if hasattr(self.affinity, 'to_dict'):
                props['Affinity'] = self.affinity.to_dict()
            elif isinstance(self.affinity, list):
                props['Affinity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.affinity
                ]
            else:
                props['Affinity'] = self.affinity

        if self.host_id is not None:
            if hasattr(self.host_id, 'to_dict'):
                props['HostId'] = self.host_id.to_dict()
            elif isinstance(self.host_id, list):
                props['HostId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_id
                ]
            else:
                props['HostId'] = self.host_id

        if self.host_resource_group_arn is not None:
            if hasattr(self.host_resource_group_arn, 'to_dict'):
                props['HostResourceGroupArn'] = self.host_resource_group_arn.to_dict()
            elif isinstance(self.host_resource_group_arn, list):
                props['HostResourceGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_resource_group_arn
                ]
            else:
                props['HostResourceGroupArn'] = self.host_resource_group_arn

        if self.group_id is not None:
            if hasattr(self.group_id, 'to_dict'):
                props['GroupId'] = self.group_id.to_dict()
            elif isinstance(self.group_id, list):
                props['GroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_id
                ]
            else:
                props['GroupId'] = self.group_id

        return props


@dataclass
class PrivateDnsNameOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_resource_name_dns_a_record: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hostname_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_resource_name_dns_aaaa_record: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enable_resource_name_dns_a_record is not None:
            if hasattr(self.enable_resource_name_dns_a_record, 'to_dict'):
                props['EnableResourceNameDnsARecord'] = self.enable_resource_name_dns_a_record.to_dict()
            elif isinstance(self.enable_resource_name_dns_a_record, list):
                props['EnableResourceNameDnsARecord'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_resource_name_dns_a_record
                ]
            else:
                props['EnableResourceNameDnsARecord'] = self.enable_resource_name_dns_a_record

        if self.hostname_type is not None:
            if hasattr(self.hostname_type, 'to_dict'):
                props['HostnameType'] = self.hostname_type.to_dict()
            elif isinstance(self.hostname_type, list):
                props['HostnameType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hostname_type
                ]
            else:
                props['HostnameType'] = self.hostname_type

        if self.enable_resource_name_dns_aaaa_record is not None:
            if hasattr(self.enable_resource_name_dns_aaaa_record, 'to_dict'):
                props['EnableResourceNameDnsAAAARecord'] = self.enable_resource_name_dns_aaaa_record.to_dict()
            elif isinstance(self.enable_resource_name_dns_aaaa_record, list):
                props['EnableResourceNameDnsAAAARecord'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_resource_name_dns_aaaa_record
                ]
            else:
                props['EnableResourceNameDnsAAAARecord'] = self.enable_resource_name_dns_aaaa_record

        return props


@dataclass
class PrivateIpAdd:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    primary: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.private_ip_address is not None:
            if hasattr(self.private_ip_address, 'to_dict'):
                props['PrivateIpAddress'] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props['PrivateIpAddress'] = self.private_ip_address

        if self.primary is not None:
            if hasattr(self.primary, 'to_dict'):
                props['Primary'] = self.primary.to_dict()
            elif isinstance(self.primary, list):
                props['Primary'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.primary
                ]
            else:
                props['Primary'] = self.primary

        return props


@dataclass
class Reference:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_family: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_family is not None:
            if hasattr(self.instance_family, 'to_dict'):
                props['InstanceFamily'] = self.instance_family.to_dict()
            elif isinstance(self.instance_family, list):
                props['InstanceFamily'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_family
                ]
            else:
                props['InstanceFamily'] = self.instance_family

        return props


@dataclass
class SpotOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_interruption_behavior: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    block_duration_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    valid_until: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.spot_instance_type is not None:
            if hasattr(self.spot_instance_type, 'to_dict'):
                props['SpotInstanceType'] = self.spot_instance_type.to_dict()
            elif isinstance(self.spot_instance_type, list):
                props['SpotInstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_instance_type
                ]
            else:
                props['SpotInstanceType'] = self.spot_instance_type

        if self.instance_interruption_behavior is not None:
            if hasattr(self.instance_interruption_behavior, 'to_dict'):
                props['InstanceInterruptionBehavior'] = self.instance_interruption_behavior.to_dict()
            elif isinstance(self.instance_interruption_behavior, list):
                props['InstanceInterruptionBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_interruption_behavior
                ]
            else:
                props['InstanceInterruptionBehavior'] = self.instance_interruption_behavior

        if self.max_price is not None:
            if hasattr(self.max_price, 'to_dict'):
                props['MaxPrice'] = self.max_price.to_dict()
            elif isinstance(self.max_price, list):
                props['MaxPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_price
                ]
            else:
                props['MaxPrice'] = self.max_price

        if self.block_duration_minutes is not None:
            if hasattr(self.block_duration_minutes, 'to_dict'):
                props['BlockDurationMinutes'] = self.block_duration_minutes.to_dict()
            elif isinstance(self.block_duration_minutes, list):
                props['BlockDurationMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.block_duration_minutes
                ]
            else:
                props['BlockDurationMinutes'] = self.block_duration_minutes

        if self.valid_until is not None:
            if hasattr(self.valid_until, 'to_dict'):
                props['ValidUntil'] = self.valid_until.to_dict()
            elif isinstance(self.valid_until, list):
                props['ValidUntil'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.valid_until
                ]
            else:
                props['ValidUntil'] = self.valid_until

        return props


@dataclass
class TagSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tags: Optional[list[Tag]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        if self.tags is not None:
            if hasattr(self.tags, 'to_dict'):
                props['Tags'] = self.tags.to_dict()
            elif isinstance(self.tags, list):
                props['Tags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tags
                ]
            else:
                props['Tags'] = self.tags

        return props


@dataclass
class TotalLocalStorageGB:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class VCpuCount:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class LaunchTemplate(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-l"""

    resource_type: ClassVar[str] = "AWS::EC2::LaunchTemplate"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_template_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_template_data: Optional[LaunchTemplateData] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    version_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tag_specifications: Optional[list[LaunchTemplateTagSpecification]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.launch_template_name is not None:
            # Serialize launch_template_name (handle intrinsic functions)
            if hasattr(self.launch_template_name, 'to_dict'):
                props["LaunchTemplateName"] = self.launch_template_name.to_dict()
            elif isinstance(self.launch_template_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LaunchTemplateName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_name
                ]
            else:
                props["LaunchTemplateName"] = self.launch_template_name

        if self.launch_template_data is not None:
            # Serialize launch_template_data (handle intrinsic functions)
            if hasattr(self.launch_template_data, 'to_dict'):
                props["LaunchTemplateData"] = self.launch_template_data.to_dict()
            elif isinstance(self.launch_template_data, list):
                # Serialize list items (may contain intrinsic functions)
                props['LaunchTemplateData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_data
                ]
            else:
                props["LaunchTemplateData"] = self.launch_template_data

        if self.version_description is not None:
            # Serialize version_description (handle intrinsic functions)
            if hasattr(self.version_description, 'to_dict'):
                props["VersionDescription"] = self.version_description.to_dict()
            elif isinstance(self.version_description, list):
                # Serialize list items (may contain intrinsic functions)
                props['VersionDescription'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version_description
                ]
            else:
                props["VersionDescription"] = self.version_description

        if self.tag_specifications is not None:
            # Serialize tag_specifications (handle intrinsic functions)
            if hasattr(self.tag_specifications, 'to_dict'):
                props["TagSpecifications"] = self.tag_specifications.to_dict()
            elif isinstance(self.tag_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['TagSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_specifications
                ]
            else:
                props["TagSpecifications"] = self.tag_specifications

        return props

    @property
    def attr_latest_version_number(self) -> GetAtt:
        """Get the LatestVersionNumber attribute."""
        return self.get_att("LatestVersionNumber")

    @property
    def attr_launch_template_id(self) -> GetAtt:
        """Get the LaunchTemplateId attribute."""
        return self.get_att("LaunchTemplateId")

    @property
    def attr_default_version_number(self) -> GetAtt:
        """Get the DefaultVersionNumber attribute."""
        return self.get_att("DefaultVersionNumber")




@dataclass
class LocalGatewayRoute(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-l"""

    resource_type: ClassVar[str] = "AWS::EC2::LocalGatewayRoute"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_virtual_interface_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.local_gateway_route_table_id is not None:
            # Serialize local_gateway_route_table_id (handle intrinsic functions)
            if hasattr(self.local_gateway_route_table_id, 'to_dict'):
                props["LocalGatewayRouteTableId"] = self.local_gateway_route_table_id.to_dict()
            elif isinstance(self.local_gateway_route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayRouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_route_table_id
                ]
            else:
                props["LocalGatewayRouteTableId"] = self.local_gateway_route_table_id

        if self.destination_cidr_block is not None:
            # Serialize destination_cidr_block (handle intrinsic functions)
            if hasattr(self.destination_cidr_block, 'to_dict'):
                props["DestinationCidrBlock"] = self.destination_cidr_block.to_dict()
            elif isinstance(self.destination_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr_block
                ]
            else:
                props["DestinationCidrBlock"] = self.destination_cidr_block

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        if self.local_gateway_virtual_interface_group_id is not None:
            # Serialize local_gateway_virtual_interface_group_id (handle intrinsic functions)
            if hasattr(self.local_gateway_virtual_interface_group_id, 'to_dict'):
                props["LocalGatewayVirtualInterfaceGroupId"] = self.local_gateway_virtual_interface_group_id.to_dict()
            elif isinstance(self.local_gateway_virtual_interface_group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayVirtualInterfaceGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_virtual_interface_group_id
                ]
            else:
                props["LocalGatewayVirtualInterfaceGroupId"] = self.local_gateway_virtual_interface_group_id

        return props

    @property
    def attr_type(self) -> GetAtt:
        """Get the Type attribute."""
        return self.get_att("Type")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")




@dataclass
class LocalGatewayRouteTable(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-l"""

    resource_type: ClassVar[str] = "AWS::EC2::LocalGatewayRouteTable"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.local_gateway_id is not None:
            # Serialize local_gateway_id (handle intrinsic functions)
            if hasattr(self.local_gateway_id, 'to_dict'):
                props["LocalGatewayId"] = self.local_gateway_id.to_dict()
            elif isinstance(self.local_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_id
                ]
            else:
                props["LocalGatewayId"] = self.local_gateway_id

        if self.mode is not None:
            # Serialize mode (handle intrinsic functions)
            if hasattr(self.mode, 'to_dict'):
                props["Mode"] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props["Mode"] = self.mode

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_outpost_arn(self) -> GetAtt:
        """Get the OutpostArn attribute."""
        return self.get_att("OutpostArn")

    @property
    def attr_local_gateway_route_table_id(self) -> GetAtt:
        """Get the LocalGatewayRouteTableId attribute."""
        return self.get_att("LocalGatewayRouteTableId")

    @property
    def attr_local_gateway_route_table_arn(self) -> GetAtt:
        """Get the LocalGatewayRouteTableArn attribute."""
        return self.get_att("LocalGatewayRouteTableArn")




@dataclass
class LocalGatewayRouteTableVPCAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-l"""

    resource_type: ClassVar[str] = "AWS::EC2::LocalGatewayRouteTableVPCAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.local_gateway_route_table_id is not None:
            # Serialize local_gateway_route_table_id (handle intrinsic functions)
            if hasattr(self.local_gateway_route_table_id, 'to_dict'):
                props["LocalGatewayRouteTableId"] = self.local_gateway_route_table_id.to_dict()
            elif isinstance(self.local_gateway_route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayRouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_route_table_id
                ]
            else:
                props["LocalGatewayRouteTableId"] = self.local_gateway_route_table_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_local_gateway_id(self) -> GetAtt:
        """Get the LocalGatewayId attribute."""
        return self.get_att("LocalGatewayId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_local_gateway_route_table_vpc_association_id(self) -> GetAtt:
        """Get the LocalGatewayRouteTableVpcAssociationId attribute."""
        return self.get_att("LocalGatewayRouteTableVpcAssociationId")




@dataclass
class LocalGatewayRouteTableVirtualInterfaceGroupAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-l"""

    resource_type: ClassVar[str] = "AWS::EC2::LocalGatewayRouteTableVirtualInterfaceGroupAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_virtual_interface_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.local_gateway_route_table_id is not None:
            # Serialize local_gateway_route_table_id (handle intrinsic functions)
            if hasattr(self.local_gateway_route_table_id, 'to_dict'):
                props["LocalGatewayRouteTableId"] = self.local_gateway_route_table_id.to_dict()
            elif isinstance(self.local_gateway_route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayRouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_route_table_id
                ]
            else:
                props["LocalGatewayRouteTableId"] = self.local_gateway_route_table_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.local_gateway_virtual_interface_group_id is not None:
            # Serialize local_gateway_virtual_interface_group_id (handle intrinsic functions)
            if hasattr(self.local_gateway_virtual_interface_group_id, 'to_dict'):
                props["LocalGatewayVirtualInterfaceGroupId"] = self.local_gateway_virtual_interface_group_id.to_dict()
            elif isinstance(self.local_gateway_virtual_interface_group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayVirtualInterfaceGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_virtual_interface_group_id
                ]
            else:
                props["LocalGatewayVirtualInterfaceGroupId"] = self.local_gateway_virtual_interface_group_id

        return props

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_local_gateway_id(self) -> GetAtt:
        """Get the LocalGatewayId attribute."""
        return self.get_att("LocalGatewayId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_local_gateway_route_table_virtual_interface_group_association_id(self) -> GetAtt:
        """Get the LocalGatewayRouteTableVirtualInterfaceGroupAssociationId attribute."""
        return self.get_att("LocalGatewayRouteTableVirtualInterfaceGroupAssociationId")

    @property
    def attr_local_gateway_route_table_arn(self) -> GetAtt:
        """Get the LocalGatewayRouteTableArn attribute."""
        return self.get_att("LocalGatewayRouteTableArn")




@dataclass
class LocalGatewayVirtualInterface(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-l"""

    resource_type: ClassVar[str] = "AWS::EC2::LocalGatewayVirtualInterface"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    outpost_lag_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vlan: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_bgp_asn: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_virtual_interface_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_bgp_asn_extended: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.outpost_lag_id is not None:
            # Serialize outpost_lag_id (handle intrinsic functions)
            if hasattr(self.outpost_lag_id, 'to_dict'):
                props["OutpostLagId"] = self.outpost_lag_id.to_dict()
            elif isinstance(self.outpost_lag_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutpostLagId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.outpost_lag_id
                ]
            else:
                props["OutpostLagId"] = self.outpost_lag_id

        if self.local_address is not None:
            # Serialize local_address (handle intrinsic functions)
            if hasattr(self.local_address, 'to_dict'):
                props["LocalAddress"] = self.local_address.to_dict()
            elif isinstance(self.local_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_address
                ]
            else:
                props["LocalAddress"] = self.local_address

        if self.peer_address is not None:
            # Serialize peer_address (handle intrinsic functions)
            if hasattr(self.peer_address, 'to_dict'):
                props["PeerAddress"] = self.peer_address.to_dict()
            elif isinstance(self.peer_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_address
                ]
            else:
                props["PeerAddress"] = self.peer_address

        if self.vlan is not None:
            # Serialize vlan (handle intrinsic functions)
            if hasattr(self.vlan, 'to_dict'):
                props["Vlan"] = self.vlan.to_dict()
            elif isinstance(self.vlan, list):
                # Serialize list items (may contain intrinsic functions)
                props['Vlan'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vlan
                ]
            else:
                props["Vlan"] = self.vlan

        if self.peer_bgp_asn is not None:
            # Serialize peer_bgp_asn (handle intrinsic functions)
            if hasattr(self.peer_bgp_asn, 'to_dict'):
                props["PeerBgpAsn"] = self.peer_bgp_asn.to_dict()
            elif isinstance(self.peer_bgp_asn, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerBgpAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_bgp_asn
                ]
            else:
                props["PeerBgpAsn"] = self.peer_bgp_asn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.local_gateway_virtual_interface_group_id is not None:
            # Serialize local_gateway_virtual_interface_group_id (handle intrinsic functions)
            if hasattr(self.local_gateway_virtual_interface_group_id, 'to_dict'):
                props["LocalGatewayVirtualInterfaceGroupId"] = self.local_gateway_virtual_interface_group_id.to_dict()
            elif isinstance(self.local_gateway_virtual_interface_group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayVirtualInterfaceGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_virtual_interface_group_id
                ]
            else:
                props["LocalGatewayVirtualInterfaceGroupId"] = self.local_gateway_virtual_interface_group_id

        if self.peer_bgp_asn_extended is not None:
            # Serialize peer_bgp_asn_extended (handle intrinsic functions)
            if hasattr(self.peer_bgp_asn_extended, 'to_dict'):
                props["PeerBgpAsnExtended"] = self.peer_bgp_asn_extended.to_dict()
            elif isinstance(self.peer_bgp_asn_extended, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerBgpAsnExtended'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_bgp_asn_extended
                ]
            else:
                props["PeerBgpAsnExtended"] = self.peer_bgp_asn_extended

        return props

    @property
    def attr_configuration_state(self) -> GetAtt:
        """Get the ConfigurationState attribute."""
        return self.get_att("ConfigurationState")

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_local_gateway_id(self) -> GetAtt:
        """Get the LocalGatewayId attribute."""
        return self.get_att("LocalGatewayId")

    @property
    def attr_local_bgp_asn(self) -> GetAtt:
        """Get the LocalBgpAsn attribute."""
        return self.get_att("LocalBgpAsn")

    @property
    def attr_local_gateway_virtual_interface_id(self) -> GetAtt:
        """Get the LocalGatewayVirtualInterfaceId attribute."""
        return self.get_att("LocalGatewayVirtualInterfaceId")




@dataclass
class LocalGatewayVirtualInterfaceGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-l"""

    resource_type: ClassVar[str] = "AWS::EC2::LocalGatewayVirtualInterfaceGroup"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_bgp_asn_extended: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_bgp_asn: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.local_gateway_id is not None:
            # Serialize local_gateway_id (handle intrinsic functions)
            if hasattr(self.local_gateway_id, 'to_dict'):
                props["LocalGatewayId"] = self.local_gateway_id.to_dict()
            elif isinstance(self.local_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_id
                ]
            else:
                props["LocalGatewayId"] = self.local_gateway_id

        if self.local_bgp_asn_extended is not None:
            # Serialize local_bgp_asn_extended (handle intrinsic functions)
            if hasattr(self.local_bgp_asn_extended, 'to_dict'):
                props["LocalBgpAsnExtended"] = self.local_bgp_asn_extended.to_dict()
            elif isinstance(self.local_bgp_asn_extended, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalBgpAsnExtended'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_bgp_asn_extended
                ]
            else:
                props["LocalBgpAsnExtended"] = self.local_bgp_asn_extended

        if self.local_bgp_asn is not None:
            # Serialize local_bgp_asn (handle intrinsic functions)
            if hasattr(self.local_bgp_asn, 'to_dict'):
                props["LocalBgpAsn"] = self.local_bgp_asn.to_dict()
            elif isinstance(self.local_bgp_asn, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalBgpAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_bgp_asn
                ]
            else:
                props["LocalBgpAsn"] = self.local_bgp_asn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_local_gateway_virtual_interface_ids(self) -> GetAtt:
        """Get the LocalGatewayVirtualInterfaceIds attribute."""
        return self.get_att("LocalGatewayVirtualInterfaceIds")

    @property
    def attr_configuration_state(self) -> GetAtt:
        """Get the ConfigurationState attribute."""
        return self.get_att("ConfigurationState")

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_local_gateway_virtual_interface_group_arn(self) -> GetAtt:
        """Get the LocalGatewayVirtualInterfaceGroupArn attribute."""
        return self.get_att("LocalGatewayVirtualInterfaceGroupArn")

    @property
    def attr_local_gateway_virtual_interface_group_id(self) -> GetAtt:
        """Get the LocalGatewayVirtualInterfaceGroupId attribute."""
        return self.get_att("LocalGatewayVirtualInterfaceGroupId")




@dataclass
class AvailabilityZoneAddress:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allocation_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.availability_zone_id is not None:
            if hasattr(self.availability_zone_id, 'to_dict'):
                props['AvailabilityZoneId'] = self.availability_zone_id.to_dict()
            elif isinstance(self.availability_zone_id, list):
                props['AvailabilityZoneId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone_id
                ]
            else:
                props['AvailabilityZoneId'] = self.availability_zone_id

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        if self.allocation_ids is not None:
            if hasattr(self.allocation_ids, 'to_dict'):
                props['AllocationIds'] = self.allocation_ids.to_dict()
            elif isinstance(self.allocation_ids, list):
                props['AllocationIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_ids
                ]
            else:
                props['AllocationIds'] = self.allocation_ids

        return props


@dataclass
class NatGateway(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NatGateway"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    secondary_allocation_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    secondary_private_ip_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connectivity_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    secondary_private_ip_addresses: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone_addresses: Optional[list[AvailabilityZoneAddress]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allocation_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_drain_duration_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.secondary_allocation_ids is not None:
            # Serialize secondary_allocation_ids (handle intrinsic functions)
            if hasattr(self.secondary_allocation_ids, 'to_dict'):
                props["SecondaryAllocationIds"] = self.secondary_allocation_ids.to_dict()
            elif isinstance(self.secondary_allocation_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecondaryAllocationIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_allocation_ids
                ]
            else:
                props["SecondaryAllocationIds"] = self.secondary_allocation_ids

        if self.private_ip_address is not None:
            # Serialize private_ip_address (handle intrinsic functions)
            if hasattr(self.private_ip_address, 'to_dict'):
                props["PrivateIpAddress"] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props["PrivateIpAddress"] = self.private_ip_address

        if self.secondary_private_ip_address_count is not None:
            # Serialize secondary_private_ip_address_count (handle intrinsic functions)
            if hasattr(self.secondary_private_ip_address_count, 'to_dict'):
                props["SecondaryPrivateIpAddressCount"] = self.secondary_private_ip_address_count.to_dict()
            elif isinstance(self.secondary_private_ip_address_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecondaryPrivateIpAddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_private_ip_address_count
                ]
            else:
                props["SecondaryPrivateIpAddressCount"] = self.secondary_private_ip_address_count

        if self.connectivity_type is not None:
            # Serialize connectivity_type (handle intrinsic functions)
            if hasattr(self.connectivity_type, 'to_dict'):
                props["ConnectivityType"] = self.connectivity_type.to_dict()
            elif isinstance(self.connectivity_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConnectivityType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connectivity_type
                ]
            else:
                props["ConnectivityType"] = self.connectivity_type

        if self.secondary_private_ip_addresses is not None:
            # Serialize secondary_private_ip_addresses (handle intrinsic functions)
            if hasattr(self.secondary_private_ip_addresses, 'to_dict'):
                props["SecondaryPrivateIpAddresses"] = self.secondary_private_ip_addresses.to_dict()
            elif isinstance(self.secondary_private_ip_addresses, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecondaryPrivateIpAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_private_ip_addresses
                ]
            else:
                props["SecondaryPrivateIpAddresses"] = self.secondary_private_ip_addresses

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.availability_zone_addresses is not None:
            # Serialize availability_zone_addresses (handle intrinsic functions)
            if hasattr(self.availability_zone_addresses, 'to_dict'):
                props["AvailabilityZoneAddresses"] = self.availability_zone_addresses.to_dict()
            elif isinstance(self.availability_zone_addresses, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZoneAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone_addresses
                ]
            else:
                props["AvailabilityZoneAddresses"] = self.availability_zone_addresses

        if self.availability_mode is not None:
            # Serialize availability_mode (handle intrinsic functions)
            if hasattr(self.availability_mode, 'to_dict'):
                props["AvailabilityMode"] = self.availability_mode.to_dict()
            elif isinstance(self.availability_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_mode
                ]
            else:
                props["AvailabilityMode"] = self.availability_mode

        if self.allocation_id is not None:
            # Serialize allocation_id (handle intrinsic functions)
            if hasattr(self.allocation_id, 'to_dict'):
                props["AllocationId"] = self.allocation_id.to_dict()
            elif isinstance(self.allocation_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllocationId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_id
                ]
            else:
                props["AllocationId"] = self.allocation_id

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.max_drain_duration_seconds is not None:
            # Serialize max_drain_duration_seconds (handle intrinsic functions)
            if hasattr(self.max_drain_duration_seconds, 'to_dict'):
                props["MaxDrainDurationSeconds"] = self.max_drain_duration_seconds.to_dict()
            elif isinstance(self.max_drain_duration_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxDrainDurationSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_drain_duration_seconds
                ]
            else:
                props["MaxDrainDurationSeconds"] = self.max_drain_duration_seconds

        return props

    @property
    def attr_route_table_id(self) -> GetAtt:
        """Get the RouteTableId attribute."""
        return self.get_att("RouteTableId")

    @property
    def attr_eni_id(self) -> GetAtt:
        """Get the EniId attribute."""
        return self.get_att("EniId")

    @property
    def attr_auto_provision_zones(self) -> GetAtt:
        """Get the AutoProvisionZones attribute."""
        return self.get_att("AutoProvisionZones")

    @property
    def attr_auto_scaling_ips(self) -> GetAtt:
        """Get the AutoScalingIps attribute."""
        return self.get_att("AutoScalingIps")

    @property
    def attr_nat_gateway_id(self) -> GetAtt:
        """Get the NatGatewayId attribute."""
        return self.get_att("NatGatewayId")




@dataclass
class NetworkAcl(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkAcl"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class Icmp:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    code: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.code is not None:
            if hasattr(self.code, 'to_dict'):
                props['Code'] = self.code.to_dict()
            elif isinstance(self.code, list):
                props['Code'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code
                ]
            else:
                props['Code'] = self.code

        return props


@dataclass
class PortRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.from_ is not None:
            if hasattr(self.from_, 'to_dict'):
                props['From'] = self.from_.to_dict()
            elif isinstance(self.from_, list):
                props['From'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_
                ]
            else:
                props['From'] = self.from_

        if self.to is not None:
            if hasattr(self.to, 'to_dict'):
                props['To'] = self.to.to_dict()
            elif isinstance(self.to, list):
                props['To'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to
                ]
            else:
                props['To'] = self.to

        return props


@dataclass
class NetworkAclEntry(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkAclEntry"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    port_range: Optional[PortRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_acl_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rule_action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    egress: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rule_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    protocol: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    icmp: Optional[Icmp] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.port_range is not None:
            # Serialize port_range (handle intrinsic functions)
            if hasattr(self.port_range, 'to_dict'):
                props["PortRange"] = self.port_range.to_dict()
            elif isinstance(self.port_range, list):
                # Serialize list items (may contain intrinsic functions)
                props['PortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port_range
                ]
            else:
                props["PortRange"] = self.port_range

        if self.network_acl_id is not None:
            # Serialize network_acl_id (handle intrinsic functions)
            if hasattr(self.network_acl_id, 'to_dict'):
                props["NetworkAclId"] = self.network_acl_id.to_dict()
            elif isinstance(self.network_acl_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkAclId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_acl_id
                ]
            else:
                props["NetworkAclId"] = self.network_acl_id

        if self.rule_action is not None:
            # Serialize rule_action (handle intrinsic functions)
            if hasattr(self.rule_action, 'to_dict'):
                props["RuleAction"] = self.rule_action.to_dict()
            elif isinstance(self.rule_action, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuleAction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_action
                ]
            else:
                props["RuleAction"] = self.rule_action

        if self.cidr_block is not None:
            # Serialize cidr_block (handle intrinsic functions)
            if hasattr(self.cidr_block, 'to_dict'):
                props["CidrBlock"] = self.cidr_block.to_dict()
            elif isinstance(self.cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_block
                ]
            else:
                props["CidrBlock"] = self.cidr_block

        if self.egress is not None:
            # Serialize egress (handle intrinsic functions)
            if hasattr(self.egress, 'to_dict'):
                props["Egress"] = self.egress.to_dict()
            elif isinstance(self.egress, list):
                # Serialize list items (may contain intrinsic functions)
                props['Egress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.egress
                ]
            else:
                props["Egress"] = self.egress

        if self.rule_number is not None:
            # Serialize rule_number (handle intrinsic functions)
            if hasattr(self.rule_number, 'to_dict'):
                props["RuleNumber"] = self.rule_number.to_dict()
            elif isinstance(self.rule_number, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuleNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_number
                ]
            else:
                props["RuleNumber"] = self.rule_number

        if self.ipv6_cidr_block is not None:
            # Serialize ipv6_cidr_block (handle intrinsic functions)
            if hasattr(self.ipv6_cidr_block, 'to_dict'):
                props["Ipv6CidrBlock"] = self.ipv6_cidr_block.to_dict()
            elif isinstance(self.ipv6_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_cidr_block
                ]
            else:
                props["Ipv6CidrBlock"] = self.ipv6_cidr_block

        if self.protocol is not None:
            # Serialize protocol (handle intrinsic functions)
            if hasattr(self.protocol, 'to_dict'):
                props["Protocol"] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                # Serialize list items (may contain intrinsic functions)
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props["Protocol"] = self.protocol

        if self.icmp is not None:
            # Serialize icmp (handle intrinsic functions)
            if hasattr(self.icmp, 'to_dict'):
                props["Icmp"] = self.icmp.to_dict()
            elif isinstance(self.icmp, list):
                # Serialize list items (may contain intrinsic functions)
                props['Icmp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.icmp
                ]
            else:
                props["Icmp"] = self.icmp

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class AccessScopePathRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination: Optional[PathStatementRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    through_resources: Optional[list[ThroughResourcesStatementRequest]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[PathStatementRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination is not None:
            if hasattr(self.destination, 'to_dict'):
                props['Destination'] = self.destination.to_dict()
            elif isinstance(self.destination, list):
                props['Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination
                ]
            else:
                props['Destination'] = self.destination

        if self.through_resources is not None:
            if hasattr(self.through_resources, 'to_dict'):
                props['ThroughResources'] = self.through_resources.to_dict()
            elif isinstance(self.through_resources, list):
                props['ThroughResources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.through_resources
                ]
            else:
                props['ThroughResources'] = self.through_resources

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        return props


@dataclass
class PacketHeaderStatementRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocols: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_ports: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_addresses: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_prefix_lists: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_addresses: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_ports: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_prefix_lists: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.protocols is not None:
            if hasattr(self.protocols, 'to_dict'):
                props['Protocols'] = self.protocols.to_dict()
            elif isinstance(self.protocols, list):
                props['Protocols'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocols
                ]
            else:
                props['Protocols'] = self.protocols

        if self.destination_ports is not None:
            if hasattr(self.destination_ports, 'to_dict'):
                props['DestinationPorts'] = self.destination_ports.to_dict()
            elif isinstance(self.destination_ports, list):
                props['DestinationPorts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_ports
                ]
            else:
                props['DestinationPorts'] = self.destination_ports

        if self.destination_addresses is not None:
            if hasattr(self.destination_addresses, 'to_dict'):
                props['DestinationAddresses'] = self.destination_addresses.to_dict()
            elif isinstance(self.destination_addresses, list):
                props['DestinationAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_addresses
                ]
            else:
                props['DestinationAddresses'] = self.destination_addresses

        if self.destination_prefix_lists is not None:
            if hasattr(self.destination_prefix_lists, 'to_dict'):
                props['DestinationPrefixLists'] = self.destination_prefix_lists.to_dict()
            elif isinstance(self.destination_prefix_lists, list):
                props['DestinationPrefixLists'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_prefix_lists
                ]
            else:
                props['DestinationPrefixLists'] = self.destination_prefix_lists

        if self.source_addresses is not None:
            if hasattr(self.source_addresses, 'to_dict'):
                props['SourceAddresses'] = self.source_addresses.to_dict()
            elif isinstance(self.source_addresses, list):
                props['SourceAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_addresses
                ]
            else:
                props['SourceAddresses'] = self.source_addresses

        if self.source_ports is not None:
            if hasattr(self.source_ports, 'to_dict'):
                props['SourcePorts'] = self.source_ports.to_dict()
            elif isinstance(self.source_ports, list):
                props['SourcePorts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_ports
                ]
            else:
                props['SourcePorts'] = self.source_ports

        if self.source_prefix_lists is not None:
            if hasattr(self.source_prefix_lists, 'to_dict'):
                props['SourcePrefixLists'] = self.source_prefix_lists.to_dict()
            elif isinstance(self.source_prefix_lists, list):
                props['SourcePrefixLists'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_prefix_lists
                ]
            else:
                props['SourcePrefixLists'] = self.source_prefix_lists

        return props


@dataclass
class PathStatementRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_statement: Optional[ResourceStatementRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    packet_header_statement: Optional[PacketHeaderStatementRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_statement is not None:
            if hasattr(self.resource_statement, 'to_dict'):
                props['ResourceStatement'] = self.resource_statement.to_dict()
            elif isinstance(self.resource_statement, list):
                props['ResourceStatement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_statement
                ]
            else:
                props['ResourceStatement'] = self.resource_statement

        if self.packet_header_statement is not None:
            if hasattr(self.packet_header_statement, 'to_dict'):
                props['PacketHeaderStatement'] = self.packet_header_statement.to_dict()
            elif isinstance(self.packet_header_statement, list):
                props['PacketHeaderStatement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.packet_header_statement
                ]
            else:
                props['PacketHeaderStatement'] = self.packet_header_statement

        return props


@dataclass
class ResourceStatementRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resources: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_types is not None:
            if hasattr(self.resource_types, 'to_dict'):
                props['ResourceTypes'] = self.resource_types.to_dict()
            elif isinstance(self.resource_types, list):
                props['ResourceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_types
                ]
            else:
                props['ResourceTypes'] = self.resource_types

        if self.resources is not None:
            if hasattr(self.resources, 'to_dict'):
                props['Resources'] = self.resources.to_dict()
            elif isinstance(self.resources, list):
                props['Resources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resources
                ]
            else:
                props['Resources'] = self.resources

        return props


@dataclass
class ThroughResourcesStatementRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_statement: Optional[ResourceStatementRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_statement is not None:
            if hasattr(self.resource_statement, 'to_dict'):
                props['ResourceStatement'] = self.resource_statement.to_dict()
            elif isinstance(self.resource_statement, list):
                props['ResourceStatement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_statement
                ]
            else:
                props['ResourceStatement'] = self.resource_statement

        return props


@dataclass
class NetworkInsightsAccessScope(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkInsightsAccessScope"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    exclude_paths: Optional[list[AccessScopePathRequest]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    match_paths: Optional[list[AccessScopePathRequest]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.exclude_paths is not None:
            # Serialize exclude_paths (handle intrinsic functions)
            if hasattr(self.exclude_paths, 'to_dict'):
                props["ExcludePaths"] = self.exclude_paths.to_dict()
            elif isinstance(self.exclude_paths, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExcludePaths'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.exclude_paths
                ]
            else:
                props["ExcludePaths"] = self.exclude_paths

        if self.match_paths is not None:
            # Serialize match_paths (handle intrinsic functions)
            if hasattr(self.match_paths, 'to_dict'):
                props["MatchPaths"] = self.match_paths.to_dict()
            elif isinstance(self.match_paths, list):
                # Serialize list items (may contain intrinsic functions)
                props['MatchPaths'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.match_paths
                ]
            else:
                props["MatchPaths"] = self.match_paths

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_updated_date(self) -> GetAtt:
        """Get the UpdatedDate attribute."""
        return self.get_att("UpdatedDate")

    @property
    def attr_created_date(self) -> GetAtt:
        """Get the CreatedDate attribute."""
        return self.get_att("CreatedDate")

    @property
    def attr_network_insights_access_scope_arn(self) -> GetAtt:
        """Get the NetworkInsightsAccessScopeArn attribute."""
        return self.get_att("NetworkInsightsAccessScopeArn")

    @property
    def attr_network_insights_access_scope_id(self) -> GetAtt:
        """Get the NetworkInsightsAccessScopeId attribute."""
        return self.get_att("NetworkInsightsAccessScopeId")




@dataclass
class NetworkInsightsAccessScopeAnalysis(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkInsightsAccessScopeAnalysis"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_insights_access_scope_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.network_insights_access_scope_id is not None:
            # Serialize network_insights_access_scope_id (handle intrinsic functions)
            if hasattr(self.network_insights_access_scope_id, 'to_dict'):
                props["NetworkInsightsAccessScopeId"] = self.network_insights_access_scope_id.to_dict()
            elif isinstance(self.network_insights_access_scope_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInsightsAccessScopeId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_insights_access_scope_id
                ]
            else:
                props["NetworkInsightsAccessScopeId"] = self.network_insights_access_scope_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_start_date(self) -> GetAtt:
        """Get the StartDate attribute."""
        return self.get_att("StartDate")

    @property
    def attr_network_insights_access_scope_analysis_id(self) -> GetAtt:
        """Get the NetworkInsightsAccessScopeAnalysisId attribute."""
        return self.get_att("NetworkInsightsAccessScopeAnalysisId")

    @property
    def attr_network_insights_access_scope_analysis_arn(self) -> GetAtt:
        """Get the NetworkInsightsAccessScopeAnalysisArn attribute."""
        return self.get_att("NetworkInsightsAccessScopeAnalysisArn")

    @property
    def attr_end_date(self) -> GetAtt:
        """Get the EndDate attribute."""
        return self.get_att("EndDate")

    @property
    def attr_analyzed_eni_count(self) -> GetAtt:
        """Get the AnalyzedEniCount attribute."""
        return self.get_att("AnalyzedEniCount")

    @property
    def attr_findings_found(self) -> GetAtt:
        """Get the FindingsFound attribute."""
        return self.get_att("FindingsFound")

    @property
    def attr_status_message(self) -> GetAtt:
        """Get the StatusMessage attribute."""
        return self.get_att("StatusMessage")




@dataclass
class AdditionalDetail:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    service_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    additional_detail_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancers: Optional[list[AnalysisComponent]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    component: Optional[AnalysisComponent] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.service_name is not None:
            if hasattr(self.service_name, 'to_dict'):
                props['ServiceName'] = self.service_name.to_dict()
            elif isinstance(self.service_name, list):
                props['ServiceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_name
                ]
            else:
                props['ServiceName'] = self.service_name

        if self.additional_detail_type is not None:
            if hasattr(self.additional_detail_type, 'to_dict'):
                props['AdditionalDetailType'] = self.additional_detail_type.to_dict()
            elif isinstance(self.additional_detail_type, list):
                props['AdditionalDetailType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_detail_type
                ]
            else:
                props['AdditionalDetailType'] = self.additional_detail_type

        if self.load_balancers is not None:
            if hasattr(self.load_balancers, 'to_dict'):
                props['LoadBalancers'] = self.load_balancers.to_dict()
            elif isinstance(self.load_balancers, list):
                props['LoadBalancers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancers
                ]
            else:
                props['LoadBalancers'] = self.load_balancers

        if self.component is not None:
            if hasattr(self.component, 'to_dict'):
                props['Component'] = self.component.to_dict()
            elif isinstance(self.component, list):
                props['Component'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.component
                ]
            else:
                props['Component'] = self.component

        return props


@dataclass
class AlternatePathHint:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    component_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    component_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.component_arn is not None:
            if hasattr(self.component_arn, 'to_dict'):
                props['ComponentArn'] = self.component_arn.to_dict()
            elif isinstance(self.component_arn, list):
                props['ComponentArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.component_arn
                ]
            else:
                props['ComponentArn'] = self.component_arn

        if self.component_id is not None:
            if hasattr(self.component_id, 'to_dict'):
                props['ComponentId'] = self.component_id.to_dict()
            elif isinstance(self.component_id, list):
                props['ComponentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.component_id
                ]
            else:
                props['ComponentId'] = self.component_id

        return props


@dataclass
class AnalysisAclRule:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port_range: Optional[PortRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    egress: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.port_range is not None:
            if hasattr(self.port_range, 'to_dict'):
                props['PortRange'] = self.port_range.to_dict()
            elif isinstance(self.port_range, list):
                props['PortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port_range
                ]
            else:
                props['PortRange'] = self.port_range

        if self.cidr is not None:
            if hasattr(self.cidr, 'to_dict'):
                props['Cidr'] = self.cidr.to_dict()
            elif isinstance(self.cidr, list):
                props['Cidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr
                ]
            else:
                props['Cidr'] = self.cidr

        if self.rule_action is not None:
            if hasattr(self.rule_action, 'to_dict'):
                props['RuleAction'] = self.rule_action.to_dict()
            elif isinstance(self.rule_action, list):
                props['RuleAction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_action
                ]
            else:
                props['RuleAction'] = self.rule_action

        if self.egress is not None:
            if hasattr(self.egress, 'to_dict'):
                props['Egress'] = self.egress.to_dict()
            elif isinstance(self.egress, list):
                props['Egress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.egress
                ]
            else:
                props['Egress'] = self.egress

        if self.rule_number is not None:
            if hasattr(self.rule_number, 'to_dict'):
                props['RuleNumber'] = self.rule_number.to_dict()
            elif isinstance(self.rule_number, list):
                props['RuleNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_number
                ]
            else:
                props['RuleNumber'] = self.rule_number

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        return props


@dataclass
class AnalysisComponent:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.id is not None:
            if hasattr(self.id, 'to_dict'):
                props['Id'] = self.id.to_dict()
            elif isinstance(self.id, list):
                props['Id'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.id
                ]
            else:
                props['Id'] = self.id

        if self.arn is not None:
            if hasattr(self.arn, 'to_dict'):
                props['Arn'] = self.arn.to_dict()
            elif isinstance(self.arn, list):
                props['Arn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.arn
                ]
            else:
                props['Arn'] = self.arn

        return props


@dataclass
class AnalysisLoadBalancerListener:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancer_port: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_port is not None:
            if hasattr(self.instance_port, 'to_dict'):
                props['InstancePort'] = self.instance_port.to_dict()
            elif isinstance(self.instance_port, list):
                props['InstancePort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_port
                ]
            else:
                props['InstancePort'] = self.instance_port

        if self.load_balancer_port is not None:
            if hasattr(self.load_balancer_port, 'to_dict'):
                props['LoadBalancerPort'] = self.load_balancer_port.to_dict()
            elif isinstance(self.load_balancer_port, list):
                props['LoadBalancerPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_port
                ]
            else:
                props['LoadBalancerPort'] = self.load_balancer_port

        return props


@dataclass
class AnalysisLoadBalancerTarget:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.address is not None:
            if hasattr(self.address, 'to_dict'):
                props['Address'] = self.address.to_dict()
            elif isinstance(self.address, list):
                props['Address'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.address
                ]
            else:
                props['Address'] = self.address

        if self.instance is not None:
            if hasattr(self.instance, 'to_dict'):
                props['Instance'] = self.instance.to_dict()
            elif isinstance(self.instance, list):
                props['Instance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance
                ]
            else:
                props['Instance'] = self.instance

        if self.port is not None:
            if hasattr(self.port, 'to_dict'):
                props['Port'] = self.port.to_dict()
            elif isinstance(self.port, list):
                props['Port'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port
                ]
            else:
                props['Port'] = self.port

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        return props


@dataclass
class AnalysisPacketHeader:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_port_ranges: Optional[list[PortRange]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_port_ranges: Optional[list[PortRange]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_addresses: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_addresses: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination_port_ranges is not None:
            if hasattr(self.destination_port_ranges, 'to_dict'):
                props['DestinationPortRanges'] = self.destination_port_ranges.to_dict()
            elif isinstance(self.destination_port_ranges, list):
                props['DestinationPortRanges'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_port_ranges
                ]
            else:
                props['DestinationPortRanges'] = self.destination_port_ranges

        if self.source_port_ranges is not None:
            if hasattr(self.source_port_ranges, 'to_dict'):
                props['SourcePortRanges'] = self.source_port_ranges.to_dict()
            elif isinstance(self.source_port_ranges, list):
                props['SourcePortRanges'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_port_ranges
                ]
            else:
                props['SourcePortRanges'] = self.source_port_ranges

        if self.destination_addresses is not None:
            if hasattr(self.destination_addresses, 'to_dict'):
                props['DestinationAddresses'] = self.destination_addresses.to_dict()
            elif isinstance(self.destination_addresses, list):
                props['DestinationAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_addresses
                ]
            else:
                props['DestinationAddresses'] = self.destination_addresses

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        if self.source_addresses is not None:
            if hasattr(self.source_addresses, 'to_dict'):
                props['SourceAddresses'] = self.source_addresses.to_dict()
            elif isinstance(self.source_addresses, list):
                props['SourceAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_addresses
                ]
            else:
                props['SourceAddresses'] = self.source_addresses

        return props


@dataclass
class AnalysisRouteTableRoute:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    origin: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_prefix_list_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_peering_connection_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    state: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    egress_only_internet_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    nat_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.origin is not None:
            if hasattr(self.origin, 'to_dict'):
                props['Origin'] = self.origin.to_dict()
            elif isinstance(self.origin, list):
                props['Origin'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.origin
                ]
            else:
                props['Origin'] = self.origin

        if self.destination_prefix_list_id is not None:
            if hasattr(self.destination_prefix_list_id, 'to_dict'):
                props['destinationPrefixListId'] = self.destination_prefix_list_id.to_dict()
            elif isinstance(self.destination_prefix_list_id, list):
                props['destinationPrefixListId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_prefix_list_id
                ]
            else:
                props['destinationPrefixListId'] = self.destination_prefix_list_id

        if self.transit_gateway_id is not None:
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props['TransitGatewayId'] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props['TransitGatewayId'] = self.transit_gateway_id

        if self.vpc_peering_connection_id is not None:
            if hasattr(self.vpc_peering_connection_id, 'to_dict'):
                props['VpcPeeringConnectionId'] = self.vpc_peering_connection_id.to_dict()
            elif isinstance(self.vpc_peering_connection_id, list):
                props['VpcPeeringConnectionId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_peering_connection_id
                ]
            else:
                props['VpcPeeringConnectionId'] = self.vpc_peering_connection_id

        if self.instance_id is not None:
            if hasattr(self.instance_id, 'to_dict'):
                props['instanceId'] = self.instance_id.to_dict()
            elif isinstance(self.instance_id, list):
                props['instanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_id
                ]
            else:
                props['instanceId'] = self.instance_id

        if self.state is not None:
            if hasattr(self.state, 'to_dict'):
                props['State'] = self.state.to_dict()
            elif isinstance(self.state, list):
                props['State'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state
                ]
            else:
                props['State'] = self.state

        if self.egress_only_internet_gateway_id is not None:
            if hasattr(self.egress_only_internet_gateway_id, 'to_dict'):
                props['egressOnlyInternetGatewayId'] = self.egress_only_internet_gateway_id.to_dict()
            elif isinstance(self.egress_only_internet_gateway_id, list):
                props['egressOnlyInternetGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.egress_only_internet_gateway_id
                ]
            else:
                props['egressOnlyInternetGatewayId'] = self.egress_only_internet_gateway_id

        if self.destination_cidr is not None:
            if hasattr(self.destination_cidr, 'to_dict'):
                props['destinationCidr'] = self.destination_cidr.to_dict()
            elif isinstance(self.destination_cidr, list):
                props['destinationCidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr
                ]
            else:
                props['destinationCidr'] = self.destination_cidr

        if self.network_interface_id is not None:
            if hasattr(self.network_interface_id, 'to_dict'):
                props['NetworkInterfaceId'] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props['NetworkInterfaceId'] = self.network_interface_id

        if self.nat_gateway_id is not None:
            if hasattr(self.nat_gateway_id, 'to_dict'):
                props['NatGatewayId'] = self.nat_gateway_id.to_dict()
            elif isinstance(self.nat_gateway_id, list):
                props['NatGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.nat_gateway_id
                ]
            else:
                props['NatGatewayId'] = self.nat_gateway_id

        if self.gateway_id is not None:
            if hasattr(self.gateway_id, 'to_dict'):
                props['gatewayId'] = self.gateway_id.to_dict()
            elif isinstance(self.gateway_id, list):
                props['gatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gateway_id
                ]
            else:
                props['gatewayId'] = self.gateway_id

        return props


@dataclass
class AnalysisSecurityGroupRule:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port_range: Optional[PortRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    prefix_list_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    direction: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.port_range is not None:
            if hasattr(self.port_range, 'to_dict'):
                props['PortRange'] = self.port_range.to_dict()
            elif isinstance(self.port_range, list):
                props['PortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port_range
                ]
            else:
                props['PortRange'] = self.port_range

        if self.cidr is not None:
            if hasattr(self.cidr, 'to_dict'):
                props['Cidr'] = self.cidr.to_dict()
            elif isinstance(self.cidr, list):
                props['Cidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr
                ]
            else:
                props['Cidr'] = self.cidr

        if self.prefix_list_id is not None:
            if hasattr(self.prefix_list_id, 'to_dict'):
                props['PrefixListId'] = self.prefix_list_id.to_dict()
            elif isinstance(self.prefix_list_id, list):
                props['PrefixListId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.prefix_list_id
                ]
            else:
                props['PrefixListId'] = self.prefix_list_id

        if self.security_group_id is not None:
            if hasattr(self.security_group_id, 'to_dict'):
                props['SecurityGroupId'] = self.security_group_id.to_dict()
            elif isinstance(self.security_group_id, list):
                props['SecurityGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_id
                ]
            else:
                props['SecurityGroupId'] = self.security_group_id

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        if self.direction is not None:
            if hasattr(self.direction, 'to_dict'):
                props['Direction'] = self.direction.to_dict()
            elif isinstance(self.direction, list):
                props['Direction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.direction
                ]
            else:
                props['Direction'] = self.direction

        return props


@dataclass
class Explanation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpn_gateway: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    packet_field: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway_attachment: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocols: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ingress_route_table: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    classic_load_balancer_listener: Optional[AnalysisLoadBalancerListener] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_peering_connection: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    addresses: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    elastic_load_balancer_listener: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway_route_table: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    explanation_code: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    internet_gateway: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_vpc: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attached_to: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    prefix_list: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway_route_table_route: Optional[TransitGatewayRouteTableRoute] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    component_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancer_target_group: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customer_gateway: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_vpc: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    route_table: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    state: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancer_listener_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_endpoint: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidrs: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_groups: Optional[list[AnalysisComponent]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    component_account: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpn_connection: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    nat_gateway: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    direction: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancer_target_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancer_target: Optional[AnalysisLoadBalancerTarget] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancer_target_groups: Optional[list[AnalysisComponent]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    component: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    missing_component: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    route_table_route: Optional[AnalysisRouteTableRoute] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zones: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port_ranges: Optional[list[PortRange]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    acl: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_rule: Optional[AnalysisSecurityGroupRule] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_route_table: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancer_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    acl_rule: Optional[AnalysisAclRule] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpn_gateway is not None:
            if hasattr(self.vpn_gateway, 'to_dict'):
                props['VpnGateway'] = self.vpn_gateway.to_dict()
            elif isinstance(self.vpn_gateway, list):
                props['VpnGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_gateway
                ]
            else:
                props['VpnGateway'] = self.vpn_gateway

        if self.packet_field is not None:
            if hasattr(self.packet_field, 'to_dict'):
                props['PacketField'] = self.packet_field.to_dict()
            elif isinstance(self.packet_field, list):
                props['PacketField'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.packet_field
                ]
            else:
                props['PacketField'] = self.packet_field

        if self.transit_gateway_attachment is not None:
            if hasattr(self.transit_gateway_attachment, 'to_dict'):
                props['TransitGatewayAttachment'] = self.transit_gateway_attachment.to_dict()
            elif isinstance(self.transit_gateway_attachment, list):
                props['TransitGatewayAttachment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_attachment
                ]
            else:
                props['TransitGatewayAttachment'] = self.transit_gateway_attachment

        if self.protocols is not None:
            if hasattr(self.protocols, 'to_dict'):
                props['Protocols'] = self.protocols.to_dict()
            elif isinstance(self.protocols, list):
                props['Protocols'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocols
                ]
            else:
                props['Protocols'] = self.protocols

        if self.ingress_route_table is not None:
            if hasattr(self.ingress_route_table, 'to_dict'):
                props['IngressRouteTable'] = self.ingress_route_table.to_dict()
            elif isinstance(self.ingress_route_table, list):
                props['IngressRouteTable'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ingress_route_table
                ]
            else:
                props['IngressRouteTable'] = self.ingress_route_table

        if self.classic_load_balancer_listener is not None:
            if hasattr(self.classic_load_balancer_listener, 'to_dict'):
                props['ClassicLoadBalancerListener'] = self.classic_load_balancer_listener.to_dict()
            elif isinstance(self.classic_load_balancer_listener, list):
                props['ClassicLoadBalancerListener'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.classic_load_balancer_listener
                ]
            else:
                props['ClassicLoadBalancerListener'] = self.classic_load_balancer_listener

        if self.vpc_peering_connection is not None:
            if hasattr(self.vpc_peering_connection, 'to_dict'):
                props['VpcPeeringConnection'] = self.vpc_peering_connection.to_dict()
            elif isinstance(self.vpc_peering_connection, list):
                props['VpcPeeringConnection'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_peering_connection
                ]
            else:
                props['VpcPeeringConnection'] = self.vpc_peering_connection

        if self.address is not None:
            if hasattr(self.address, 'to_dict'):
                props['Address'] = self.address.to_dict()
            elif isinstance(self.address, list):
                props['Address'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.address
                ]
            else:
                props['Address'] = self.address

        if self.port is not None:
            if hasattr(self.port, 'to_dict'):
                props['Port'] = self.port.to_dict()
            elif isinstance(self.port, list):
                props['Port'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port
                ]
            else:
                props['Port'] = self.port

        if self.addresses is not None:
            if hasattr(self.addresses, 'to_dict'):
                props['Addresses'] = self.addresses.to_dict()
            elif isinstance(self.addresses, list):
                props['Addresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.addresses
                ]
            else:
                props['Addresses'] = self.addresses

        if self.elastic_load_balancer_listener is not None:
            if hasattr(self.elastic_load_balancer_listener, 'to_dict'):
                props['ElasticLoadBalancerListener'] = self.elastic_load_balancer_listener.to_dict()
            elif isinstance(self.elastic_load_balancer_listener, list):
                props['ElasticLoadBalancerListener'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.elastic_load_balancer_listener
                ]
            else:
                props['ElasticLoadBalancerListener'] = self.elastic_load_balancer_listener

        if self.transit_gateway_route_table is not None:
            if hasattr(self.transit_gateway_route_table, 'to_dict'):
                props['TransitGatewayRouteTable'] = self.transit_gateway_route_table.to_dict()
            elif isinstance(self.transit_gateway_route_table, list):
                props['TransitGatewayRouteTable'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_route_table
                ]
            else:
                props['TransitGatewayRouteTable'] = self.transit_gateway_route_table

        if self.explanation_code is not None:
            if hasattr(self.explanation_code, 'to_dict'):
                props['ExplanationCode'] = self.explanation_code.to_dict()
            elif isinstance(self.explanation_code, list):
                props['ExplanationCode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.explanation_code
                ]
            else:
                props['ExplanationCode'] = self.explanation_code

        if self.internet_gateway is not None:
            if hasattr(self.internet_gateway, 'to_dict'):
                props['InternetGateway'] = self.internet_gateway.to_dict()
            elif isinstance(self.internet_gateway, list):
                props['InternetGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internet_gateway
                ]
            else:
                props['InternetGateway'] = self.internet_gateway

        if self.source_vpc is not None:
            if hasattr(self.source_vpc, 'to_dict'):
                props['SourceVpc'] = self.source_vpc.to_dict()
            elif isinstance(self.source_vpc, list):
                props['SourceVpc'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_vpc
                ]
            else:
                props['SourceVpc'] = self.source_vpc

        if self.attached_to is not None:
            if hasattr(self.attached_to, 'to_dict'):
                props['AttachedTo'] = self.attached_to.to_dict()
            elif isinstance(self.attached_to, list):
                props['AttachedTo'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attached_to
                ]
            else:
                props['AttachedTo'] = self.attached_to

        if self.prefix_list is not None:
            if hasattr(self.prefix_list, 'to_dict'):
                props['PrefixList'] = self.prefix_list.to_dict()
            elif isinstance(self.prefix_list, list):
                props['PrefixList'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.prefix_list
                ]
            else:
                props['PrefixList'] = self.prefix_list

        if self.transit_gateway_route_table_route is not None:
            if hasattr(self.transit_gateway_route_table_route, 'to_dict'):
                props['TransitGatewayRouteTableRoute'] = self.transit_gateway_route_table_route.to_dict()
            elif isinstance(self.transit_gateway_route_table_route, list):
                props['TransitGatewayRouteTableRoute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_route_table_route
                ]
            else:
                props['TransitGatewayRouteTableRoute'] = self.transit_gateway_route_table_route

        if self.component_region is not None:
            if hasattr(self.component_region, 'to_dict'):
                props['ComponentRegion'] = self.component_region.to_dict()
            elif isinstance(self.component_region, list):
                props['ComponentRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.component_region
                ]
            else:
                props['ComponentRegion'] = self.component_region

        if self.load_balancer_target_group is not None:
            if hasattr(self.load_balancer_target_group, 'to_dict'):
                props['LoadBalancerTargetGroup'] = self.load_balancer_target_group.to_dict()
            elif isinstance(self.load_balancer_target_group, list):
                props['LoadBalancerTargetGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_target_group
                ]
            else:
                props['LoadBalancerTargetGroup'] = self.load_balancer_target_group

        if self.network_interface is not None:
            if hasattr(self.network_interface, 'to_dict'):
                props['NetworkInterface'] = self.network_interface.to_dict()
            elif isinstance(self.network_interface, list):
                props['NetworkInterface'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface
                ]
            else:
                props['NetworkInterface'] = self.network_interface

        if self.customer_gateway is not None:
            if hasattr(self.customer_gateway, 'to_dict'):
                props['CustomerGateway'] = self.customer_gateway.to_dict()
            elif isinstance(self.customer_gateway, list):
                props['CustomerGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customer_gateway
                ]
            else:
                props['CustomerGateway'] = self.customer_gateway

        if self.destination_vpc is not None:
            if hasattr(self.destination_vpc, 'to_dict'):
                props['DestinationVpc'] = self.destination_vpc.to_dict()
            elif isinstance(self.destination_vpc, list):
                props['DestinationVpc'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_vpc
                ]
            else:
                props['DestinationVpc'] = self.destination_vpc

        if self.security_group is not None:
            if hasattr(self.security_group, 'to_dict'):
                props['SecurityGroup'] = self.security_group.to_dict()
            elif isinstance(self.security_group, list):
                props['SecurityGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group
                ]
            else:
                props['SecurityGroup'] = self.security_group

        if self.transit_gateway is not None:
            if hasattr(self.transit_gateway, 'to_dict'):
                props['TransitGateway'] = self.transit_gateway.to_dict()
            elif isinstance(self.transit_gateway, list):
                props['TransitGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway
                ]
            else:
                props['TransitGateway'] = self.transit_gateway

        if self.route_table is not None:
            if hasattr(self.route_table, 'to_dict'):
                props['RouteTable'] = self.route_table.to_dict()
            elif isinstance(self.route_table, list):
                props['RouteTable'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table
                ]
            else:
                props['RouteTable'] = self.route_table

        if self.state is not None:
            if hasattr(self.state, 'to_dict'):
                props['State'] = self.state.to_dict()
            elif isinstance(self.state, list):
                props['State'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state
                ]
            else:
                props['State'] = self.state

        if self.load_balancer_listener_port is not None:
            if hasattr(self.load_balancer_listener_port, 'to_dict'):
                props['LoadBalancerListenerPort'] = self.load_balancer_listener_port.to_dict()
            elif isinstance(self.load_balancer_listener_port, list):
                props['LoadBalancerListenerPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_listener_port
                ]
            else:
                props['LoadBalancerListenerPort'] = self.load_balancer_listener_port

        if self.vpc_endpoint is not None:
            if hasattr(self.vpc_endpoint, 'to_dict'):
                props['vpcEndpoint'] = self.vpc_endpoint.to_dict()
            elif isinstance(self.vpc_endpoint, list):
                props['vpcEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_endpoint
                ]
            else:
                props['vpcEndpoint'] = self.vpc_endpoint

        if self.subnet is not None:
            if hasattr(self.subnet, 'to_dict'):
                props['Subnet'] = self.subnet.to_dict()
            elif isinstance(self.subnet, list):
                props['Subnet'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet
                ]
            else:
                props['Subnet'] = self.subnet

        if self.cidrs is not None:
            if hasattr(self.cidrs, 'to_dict'):
                props['Cidrs'] = self.cidrs.to_dict()
            elif isinstance(self.cidrs, list):
                props['Cidrs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidrs
                ]
            else:
                props['Cidrs'] = self.cidrs

        if self.destination is not None:
            if hasattr(self.destination, 'to_dict'):
                props['Destination'] = self.destination.to_dict()
            elif isinstance(self.destination, list):
                props['Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination
                ]
            else:
                props['Destination'] = self.destination

        if self.security_groups is not None:
            if hasattr(self.security_groups, 'to_dict'):
                props['SecurityGroups'] = self.security_groups.to_dict()
            elif isinstance(self.security_groups, list):
                props['SecurityGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_groups
                ]
            else:
                props['SecurityGroups'] = self.security_groups

        if self.component_account is not None:
            if hasattr(self.component_account, 'to_dict'):
                props['ComponentAccount'] = self.component_account.to_dict()
            elif isinstance(self.component_account, list):
                props['ComponentAccount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.component_account
                ]
            else:
                props['ComponentAccount'] = self.component_account

        if self.vpn_connection is not None:
            if hasattr(self.vpn_connection, 'to_dict'):
                props['VpnConnection'] = self.vpn_connection.to_dict()
            elif isinstance(self.vpn_connection, list):
                props['VpnConnection'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_connection
                ]
            else:
                props['VpnConnection'] = self.vpn_connection

        if self.vpc is not None:
            if hasattr(self.vpc, 'to_dict'):
                props['Vpc'] = self.vpc.to_dict()
            elif isinstance(self.vpc, list):
                props['Vpc'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc
                ]
            else:
                props['Vpc'] = self.vpc

        if self.nat_gateway is not None:
            if hasattr(self.nat_gateway, 'to_dict'):
                props['NatGateway'] = self.nat_gateway.to_dict()
            elif isinstance(self.nat_gateway, list):
                props['NatGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.nat_gateway
                ]
            else:
                props['NatGateway'] = self.nat_gateway

        if self.direction is not None:
            if hasattr(self.direction, 'to_dict'):
                props['Direction'] = self.direction.to_dict()
            elif isinstance(self.direction, list):
                props['Direction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.direction
                ]
            else:
                props['Direction'] = self.direction

        if self.load_balancer_target_port is not None:
            if hasattr(self.load_balancer_target_port, 'to_dict'):
                props['LoadBalancerTargetPort'] = self.load_balancer_target_port.to_dict()
            elif isinstance(self.load_balancer_target_port, list):
                props['LoadBalancerTargetPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_target_port
                ]
            else:
                props['LoadBalancerTargetPort'] = self.load_balancer_target_port

        if self.load_balancer_target is not None:
            if hasattr(self.load_balancer_target, 'to_dict'):
                props['LoadBalancerTarget'] = self.load_balancer_target.to_dict()
            elif isinstance(self.load_balancer_target, list):
                props['LoadBalancerTarget'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_target
                ]
            else:
                props['LoadBalancerTarget'] = self.load_balancer_target

        if self.load_balancer_target_groups is not None:
            if hasattr(self.load_balancer_target_groups, 'to_dict'):
                props['LoadBalancerTargetGroups'] = self.load_balancer_target_groups.to_dict()
            elif isinstance(self.load_balancer_target_groups, list):
                props['LoadBalancerTargetGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_target_groups
                ]
            else:
                props['LoadBalancerTargetGroups'] = self.load_balancer_target_groups

        if self.component is not None:
            if hasattr(self.component, 'to_dict'):
                props['Component'] = self.component.to_dict()
            elif isinstance(self.component, list):
                props['Component'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.component
                ]
            else:
                props['Component'] = self.component

        if self.missing_component is not None:
            if hasattr(self.missing_component, 'to_dict'):
                props['MissingComponent'] = self.missing_component.to_dict()
            elif isinstance(self.missing_component, list):
                props['MissingComponent'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.missing_component
                ]
            else:
                props['MissingComponent'] = self.missing_component

        if self.route_table_route is not None:
            if hasattr(self.route_table_route, 'to_dict'):
                props['RouteTableRoute'] = self.route_table_route.to_dict()
            elif isinstance(self.route_table_route, list):
                props['RouteTableRoute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_route
                ]
            else:
                props['RouteTableRoute'] = self.route_table_route

        if self.availability_zones is not None:
            if hasattr(self.availability_zones, 'to_dict'):
                props['AvailabilityZones'] = self.availability_zones.to_dict()
            elif isinstance(self.availability_zones, list):
                props['AvailabilityZones'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zones
                ]
            else:
                props['AvailabilityZones'] = self.availability_zones

        if self.port_ranges is not None:
            if hasattr(self.port_ranges, 'to_dict'):
                props['PortRanges'] = self.port_ranges.to_dict()
            elif isinstance(self.port_ranges, list):
                props['PortRanges'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port_ranges
                ]
            else:
                props['PortRanges'] = self.port_ranges

        if self.acl is not None:
            if hasattr(self.acl, 'to_dict'):
                props['Acl'] = self.acl.to_dict()
            elif isinstance(self.acl, list):
                props['Acl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.acl
                ]
            else:
                props['Acl'] = self.acl

        if self.security_group_rule is not None:
            if hasattr(self.security_group_rule, 'to_dict'):
                props['SecurityGroupRule'] = self.security_group_rule.to_dict()
            elif isinstance(self.security_group_rule, list):
                props['SecurityGroupRule'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_rule
                ]
            else:
                props['SecurityGroupRule'] = self.security_group_rule

        if self.subnet_route_table is not None:
            if hasattr(self.subnet_route_table, 'to_dict'):
                props['SubnetRouteTable'] = self.subnet_route_table.to_dict()
            elif isinstance(self.subnet_route_table, list):
                props['SubnetRouteTable'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_route_table
                ]
            else:
                props['SubnetRouteTable'] = self.subnet_route_table

        if self.load_balancer_arn is not None:
            if hasattr(self.load_balancer_arn, 'to_dict'):
                props['LoadBalancerArn'] = self.load_balancer_arn.to_dict()
            elif isinstance(self.load_balancer_arn, list):
                props['LoadBalancerArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_arn
                ]
            else:
                props['LoadBalancerArn'] = self.load_balancer_arn

        if self.acl_rule is not None:
            if hasattr(self.acl_rule, 'to_dict'):
                props['AclRule'] = self.acl_rule.to_dict()
            elif isinstance(self.acl_rule, list):
                props['AclRule'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.acl_rule
                ]
            else:
                props['AclRule'] = self.acl_rule

        return props


@dataclass
class PathComponent:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    additional_details: Optional[list[AdditionalDetail]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inbound_header: Optional[AnalysisPacketHeader] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_vpc: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_rule: Optional[AnalysisSecurityGroupRule] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    elastic_load_balancer_listener: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    explanations: Optional[list[Explanation]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    service_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sequence_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_vpc: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    outbound_header: Optional[AnalysisPacketHeader] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    acl_rule: Optional[AnalysisAclRule] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway_route_table_route: Optional[TransitGatewayRouteTableRoute] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    component: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    route_table_route: Optional[AnalysisRouteTableRoute] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.additional_details is not None:
            if hasattr(self.additional_details, 'to_dict'):
                props['AdditionalDetails'] = self.additional_details.to_dict()
            elif isinstance(self.additional_details, list):
                props['AdditionalDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_details
                ]
            else:
                props['AdditionalDetails'] = self.additional_details

        if self.inbound_header is not None:
            if hasattr(self.inbound_header, 'to_dict'):
                props['InboundHeader'] = self.inbound_header.to_dict()
            elif isinstance(self.inbound_header, list):
                props['InboundHeader'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inbound_header
                ]
            else:
                props['InboundHeader'] = self.inbound_header

        if self.vpc is not None:
            if hasattr(self.vpc, 'to_dict'):
                props['Vpc'] = self.vpc.to_dict()
            elif isinstance(self.vpc, list):
                props['Vpc'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc
                ]
            else:
                props['Vpc'] = self.vpc

        if self.destination_vpc is not None:
            if hasattr(self.destination_vpc, 'to_dict'):
                props['DestinationVpc'] = self.destination_vpc.to_dict()
            elif isinstance(self.destination_vpc, list):
                props['DestinationVpc'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_vpc
                ]
            else:
                props['DestinationVpc'] = self.destination_vpc

        if self.security_group_rule is not None:
            if hasattr(self.security_group_rule, 'to_dict'):
                props['SecurityGroupRule'] = self.security_group_rule.to_dict()
            elif isinstance(self.security_group_rule, list):
                props['SecurityGroupRule'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_rule
                ]
            else:
                props['SecurityGroupRule'] = self.security_group_rule

        if self.transit_gateway is not None:
            if hasattr(self.transit_gateway, 'to_dict'):
                props['TransitGateway'] = self.transit_gateway.to_dict()
            elif isinstance(self.transit_gateway, list):
                props['TransitGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway
                ]
            else:
                props['TransitGateway'] = self.transit_gateway

        if self.elastic_load_balancer_listener is not None:
            if hasattr(self.elastic_load_balancer_listener, 'to_dict'):
                props['ElasticLoadBalancerListener'] = self.elastic_load_balancer_listener.to_dict()
            elif isinstance(self.elastic_load_balancer_listener, list):
                props['ElasticLoadBalancerListener'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.elastic_load_balancer_listener
                ]
            else:
                props['ElasticLoadBalancerListener'] = self.elastic_load_balancer_listener

        if self.explanations is not None:
            if hasattr(self.explanations, 'to_dict'):
                props['Explanations'] = self.explanations.to_dict()
            elif isinstance(self.explanations, list):
                props['Explanations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.explanations
                ]
            else:
                props['Explanations'] = self.explanations

        if self.service_name is not None:
            if hasattr(self.service_name, 'to_dict'):
                props['ServiceName'] = self.service_name.to_dict()
            elif isinstance(self.service_name, list):
                props['ServiceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_name
                ]
            else:
                props['ServiceName'] = self.service_name

        if self.sequence_number is not None:
            if hasattr(self.sequence_number, 'to_dict'):
                props['SequenceNumber'] = self.sequence_number.to_dict()
            elif isinstance(self.sequence_number, list):
                props['SequenceNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sequence_number
                ]
            else:
                props['SequenceNumber'] = self.sequence_number

        if self.source_vpc is not None:
            if hasattr(self.source_vpc, 'to_dict'):
                props['SourceVpc'] = self.source_vpc.to_dict()
            elif isinstance(self.source_vpc, list):
                props['SourceVpc'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_vpc
                ]
            else:
                props['SourceVpc'] = self.source_vpc

        if self.outbound_header is not None:
            if hasattr(self.outbound_header, 'to_dict'):
                props['OutboundHeader'] = self.outbound_header.to_dict()
            elif isinstance(self.outbound_header, list):
                props['OutboundHeader'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.outbound_header
                ]
            else:
                props['OutboundHeader'] = self.outbound_header

        if self.acl_rule is not None:
            if hasattr(self.acl_rule, 'to_dict'):
                props['AclRule'] = self.acl_rule.to_dict()
            elif isinstance(self.acl_rule, list):
                props['AclRule'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.acl_rule
                ]
            else:
                props['AclRule'] = self.acl_rule

        if self.transit_gateway_route_table_route is not None:
            if hasattr(self.transit_gateway_route_table_route, 'to_dict'):
                props['TransitGatewayRouteTableRoute'] = self.transit_gateway_route_table_route.to_dict()
            elif isinstance(self.transit_gateway_route_table_route, list):
                props['TransitGatewayRouteTableRoute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_route_table_route
                ]
            else:
                props['TransitGatewayRouteTableRoute'] = self.transit_gateway_route_table_route

        if self.component is not None:
            if hasattr(self.component, 'to_dict'):
                props['Component'] = self.component.to_dict()
            elif isinstance(self.component, list):
                props['Component'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.component
                ]
            else:
                props['Component'] = self.component

        if self.subnet is not None:
            if hasattr(self.subnet, 'to_dict'):
                props['Subnet'] = self.subnet.to_dict()
            elif isinstance(self.subnet, list):
                props['Subnet'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet
                ]
            else:
                props['Subnet'] = self.subnet

        if self.route_table_route is not None:
            if hasattr(self.route_table_route, 'to_dict'):
                props['RouteTableRoute'] = self.route_table_route.to_dict()
            elif isinstance(self.route_table_route, list):
                props['RouteTableRoute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_route
                ]
            else:
                props['RouteTableRoute'] = self.route_table_route

        return props


@dataclass
class PortRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.from_ is not None:
            if hasattr(self.from_, 'to_dict'):
                props['From'] = self.from_.to_dict()
            elif isinstance(self.from_, list):
                props['From'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_
                ]
            else:
                props['From'] = self.from_

        if self.to is not None:
            if hasattr(self.to, 'to_dict'):
                props['To'] = self.to.to_dict()
            elif isinstance(self.to, list):
                props['To'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to
                ]
            else:
                props['To'] = self.to

        return props


@dataclass
class TransitGatewayRouteTableRoute:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    prefix_list_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    state: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    route_origin: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.prefix_list_id is not None:
            if hasattr(self.prefix_list_id, 'to_dict'):
                props['PrefixListId'] = self.prefix_list_id.to_dict()
            elif isinstance(self.prefix_list_id, list):
                props['PrefixListId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.prefix_list_id
                ]
            else:
                props['PrefixListId'] = self.prefix_list_id

        if self.resource_id is not None:
            if hasattr(self.resource_id, 'to_dict'):
                props['ResourceId'] = self.resource_id.to_dict()
            elif isinstance(self.resource_id, list):
                props['ResourceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_id
                ]
            else:
                props['ResourceId'] = self.resource_id

        if self.state is not None:
            if hasattr(self.state, 'to_dict'):
                props['State'] = self.state.to_dict()
            elif isinstance(self.state, list):
                props['State'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state
                ]
            else:
                props['State'] = self.state

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        if self.route_origin is not None:
            if hasattr(self.route_origin, 'to_dict'):
                props['RouteOrigin'] = self.route_origin.to_dict()
            elif isinstance(self.route_origin, list):
                props['RouteOrigin'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_origin
                ]
            else:
                props['RouteOrigin'] = self.route_origin

        if self.destination_cidr is not None:
            if hasattr(self.destination_cidr, 'to_dict'):
                props['DestinationCidr'] = self.destination_cidr.to_dict()
            elif isinstance(self.destination_cidr, list):
                props['DestinationCidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr
                ]
            else:
                props['DestinationCidr'] = self.destination_cidr

        if self.attachment_id is not None:
            if hasattr(self.attachment_id, 'to_dict'):
                props['AttachmentId'] = self.attachment_id.to_dict()
            elif isinstance(self.attachment_id, list):
                props['AttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attachment_id
                ]
            else:
                props['AttachmentId'] = self.attachment_id

        return props


@dataclass
class NetworkInsightsAnalysis(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkInsightsAnalysis"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    filter_out_arns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_insights_path_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    filter_in_arns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    additional_accounts: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.filter_out_arns is not None:
            # Serialize filter_out_arns (handle intrinsic functions)
            if hasattr(self.filter_out_arns, 'to_dict'):
                props["FilterOutArns"] = self.filter_out_arns.to_dict()
            elif isinstance(self.filter_out_arns, list):
                # Serialize list items (may contain intrinsic functions)
                props['FilterOutArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter_out_arns
                ]
            else:
                props["FilterOutArns"] = self.filter_out_arns

        if self.network_insights_path_id is not None:
            # Serialize network_insights_path_id (handle intrinsic functions)
            if hasattr(self.network_insights_path_id, 'to_dict'):
                props["NetworkInsightsPathId"] = self.network_insights_path_id.to_dict()
            elif isinstance(self.network_insights_path_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInsightsPathId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_insights_path_id
                ]
            else:
                props["NetworkInsightsPathId"] = self.network_insights_path_id

        if self.filter_in_arns is not None:
            # Serialize filter_in_arns (handle intrinsic functions)
            if hasattr(self.filter_in_arns, 'to_dict'):
                props["FilterInArns"] = self.filter_in_arns.to_dict()
            elif isinstance(self.filter_in_arns, list):
                # Serialize list items (may contain intrinsic functions)
                props['FilterInArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter_in_arns
                ]
            else:
                props["FilterInArns"] = self.filter_in_arns

        if self.additional_accounts is not None:
            # Serialize additional_accounts (handle intrinsic functions)
            if hasattr(self.additional_accounts, 'to_dict'):
                props["AdditionalAccounts"] = self.additional_accounts.to_dict()
            elif isinstance(self.additional_accounts, list):
                # Serialize list items (may contain intrinsic functions)
                props['AdditionalAccounts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_accounts
                ]
            else:
                props["AdditionalAccounts"] = self.additional_accounts

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_return_path_components(self) -> GetAtt:
        """Get the ReturnPathComponents attribute."""
        return self.get_att("ReturnPathComponents")

    @property
    def attr_start_date(self) -> GetAtt:
        """Get the StartDate attribute."""
        return self.get_att("StartDate")

    @property
    def attr_network_insights_analysis_id(self) -> GetAtt:
        """Get the NetworkInsightsAnalysisId attribute."""
        return self.get_att("NetworkInsightsAnalysisId")

    @property
    def attr_alternate_path_hints(self) -> GetAtt:
        """Get the AlternatePathHints attribute."""
        return self.get_att("AlternatePathHints")

    @property
    def attr_explanations(self) -> GetAtt:
        """Get the Explanations attribute."""
        return self.get_att("Explanations")

    @property
    def attr_network_path_found(self) -> GetAtt:
        """Get the NetworkPathFound attribute."""
        return self.get_att("NetworkPathFound")

    @property
    def attr_suggested_accounts(self) -> GetAtt:
        """Get the SuggestedAccounts attribute."""
        return self.get_att("SuggestedAccounts")

    @property
    def attr_forward_path_components(self) -> GetAtt:
        """Get the ForwardPathComponents attribute."""
        return self.get_att("ForwardPathComponents")

    @property
    def attr_network_insights_analysis_arn(self) -> GetAtt:
        """Get the NetworkInsightsAnalysisArn attribute."""
        return self.get_att("NetworkInsightsAnalysisArn")

    @property
    def attr_status_message(self) -> GetAtt:
        """Get the StatusMessage attribute."""
        return self.get_att("StatusMessage")




@dataclass
class FilterPortRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.from_port is not None:
            if hasattr(self.from_port, 'to_dict'):
                props['FromPort'] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props['FromPort'] = self.from_port

        if self.to_port is not None:
            if hasattr(self.to_port, 'to_dict'):
                props['ToPort'] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props['ToPort'] = self.to_port

        return props


@dataclass
class PathFilter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_port_range: Optional[FilterPortRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_port_range: Optional[FilterPortRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_address: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.source_address is not None:
            if hasattr(self.source_address, 'to_dict'):
                props['SourceAddress'] = self.source_address.to_dict()
            elif isinstance(self.source_address, list):
                props['SourceAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_address
                ]
            else:
                props['SourceAddress'] = self.source_address

        if self.destination_port_range is not None:
            if hasattr(self.destination_port_range, 'to_dict'):
                props['DestinationPortRange'] = self.destination_port_range.to_dict()
            elif isinstance(self.destination_port_range, list):
                props['DestinationPortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_port_range
                ]
            else:
                props['DestinationPortRange'] = self.destination_port_range

        if self.source_port_range is not None:
            if hasattr(self.source_port_range, 'to_dict'):
                props['SourcePortRange'] = self.source_port_range.to_dict()
            elif isinstance(self.source_port_range, list):
                props['SourcePortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_port_range
                ]
            else:
                props['SourcePortRange'] = self.source_port_range

        if self.destination_address is not None:
            if hasattr(self.destination_address, 'to_dict'):
                props['DestinationAddress'] = self.destination_address.to_dict()
            elif isinstance(self.destination_address, list):
                props['DestinationAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_address
                ]
            else:
                props['DestinationAddress'] = self.destination_address

        return props


@dataclass
class NetworkInsightsPath(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkInsightsPath"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_ip: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_ip: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    filter_at_destination: Optional[PathFilter] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    filter_at_source: Optional[PathFilter] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination is not None:
            # Serialize destination (handle intrinsic functions)
            if hasattr(self.destination, 'to_dict'):
                props["Destination"] = self.destination.to_dict()
            elif isinstance(self.destination, list):
                # Serialize list items (may contain intrinsic functions)
                props['Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination
                ]
            else:
                props["Destination"] = self.destination

        if self.destination_ip is not None:
            # Serialize destination_ip (handle intrinsic functions)
            if hasattr(self.destination_ip, 'to_dict'):
                props["DestinationIp"] = self.destination_ip.to_dict()
            elif isinstance(self.destination_ip, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationIp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_ip
                ]
            else:
                props["DestinationIp"] = self.destination_ip

        if self.source_ip is not None:
            # Serialize source_ip (handle intrinsic functions)
            if hasattr(self.source_ip, 'to_dict'):
                props["SourceIp"] = self.source_ip.to_dict()
            elif isinstance(self.source_ip, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceIp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_ip
                ]
            else:
                props["SourceIp"] = self.source_ip

        if self.filter_at_destination is not None:
            # Serialize filter_at_destination (handle intrinsic functions)
            if hasattr(self.filter_at_destination, 'to_dict'):
                props["FilterAtDestination"] = self.filter_at_destination.to_dict()
            elif isinstance(self.filter_at_destination, list):
                # Serialize list items (may contain intrinsic functions)
                props['FilterAtDestination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter_at_destination
                ]
            else:
                props["FilterAtDestination"] = self.filter_at_destination

        if self.filter_at_source is not None:
            # Serialize filter_at_source (handle intrinsic functions)
            if hasattr(self.filter_at_source, 'to_dict'):
                props["FilterAtSource"] = self.filter_at_source.to_dict()
            elif isinstance(self.filter_at_source, list):
                # Serialize list items (may contain intrinsic functions)
                props['FilterAtSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter_at_source
                ]
            else:
                props["FilterAtSource"] = self.filter_at_source

        if self.protocol is not None:
            # Serialize protocol (handle intrinsic functions)
            if hasattr(self.protocol, 'to_dict'):
                props["Protocol"] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                # Serialize list items (may contain intrinsic functions)
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props["Protocol"] = self.protocol

        if self.destination_port is not None:
            # Serialize destination_port (handle intrinsic functions)
            if hasattr(self.destination_port, 'to_dict'):
                props["DestinationPort"] = self.destination_port.to_dict()
            elif isinstance(self.destination_port, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_port
                ]
            else:
                props["DestinationPort"] = self.destination_port

        if self.source is not None:
            # Serialize source (handle intrinsic functions)
            if hasattr(self.source, 'to_dict'):
                props["Source"] = self.source.to_dict()
            elif isinstance(self.source, list):
                # Serialize list items (may contain intrinsic functions)
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props["Source"] = self.source

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_source_arn(self) -> GetAtt:
        """Get the SourceArn attribute."""
        return self.get_att("SourceArn")

    @property
    def attr_network_insights_path_id(self) -> GetAtt:
        """Get the NetworkInsightsPathId attribute."""
        return self.get_att("NetworkInsightsPathId")

    @property
    def attr_created_date(self) -> GetAtt:
        """Get the CreatedDate attribute."""
        return self.get_att("CreatedDate")

    @property
    def attr_network_insights_path_arn(self) -> GetAtt:
        """Get the NetworkInsightsPathArn attribute."""
        return self.get_att("NetworkInsightsPathArn")

    @property
    def attr_destination_arn(self) -> GetAtt:
        """Get the DestinationArn attribute."""
        return self.get_att("DestinationArn")




@dataclass
class ConnectionTrackingSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    udp_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tcp_established_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    udp_stream_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.udp_timeout is not None:
            if hasattr(self.udp_timeout, 'to_dict'):
                props['UdpTimeout'] = self.udp_timeout.to_dict()
            elif isinstance(self.udp_timeout, list):
                props['UdpTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.udp_timeout
                ]
            else:
                props['UdpTimeout'] = self.udp_timeout

        if self.tcp_established_timeout is not None:
            if hasattr(self.tcp_established_timeout, 'to_dict'):
                props['TcpEstablishedTimeout'] = self.tcp_established_timeout.to_dict()
            elif isinstance(self.tcp_established_timeout, list):
                props['TcpEstablishedTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tcp_established_timeout
                ]
            else:
                props['TcpEstablishedTimeout'] = self.tcp_established_timeout

        if self.udp_stream_timeout is not None:
            if hasattr(self.udp_stream_timeout, 'to_dict'):
                props['UdpStreamTimeout'] = self.udp_stream_timeout.to_dict()
            elif isinstance(self.udp_stream_timeout, list):
                props['UdpStreamTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.udp_stream_timeout
                ]
            else:
                props['UdpStreamTimeout'] = self.udp_stream_timeout

        return props


@dataclass
class InstanceIpv6Address:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_address: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_address is not None:
            if hasattr(self.ipv6_address, 'to_dict'):
                props['Ipv6Address'] = self.ipv6_address.to_dict()
            elif isinstance(self.ipv6_address, list):
                props['Ipv6Address'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address
                ]
            else:
                props['Ipv6Address'] = self.ipv6_address

        return props


@dataclass
class Ipv4PrefixSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv4_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv4_prefix is not None:
            if hasattr(self.ipv4_prefix, 'to_dict'):
                props['Ipv4Prefix'] = self.ipv4_prefix.to_dict()
            elif isinstance(self.ipv4_prefix, list):
                props['Ipv4Prefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_prefix
                ]
            else:
                props['Ipv4Prefix'] = self.ipv4_prefix

        return props


@dataclass
class Ipv6PrefixSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_prefix is not None:
            if hasattr(self.ipv6_prefix, 'to_dict'):
                props['Ipv6Prefix'] = self.ipv6_prefix.to_dict()
            elif isinstance(self.ipv6_prefix, list):
                props['Ipv6Prefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_prefix
                ]
            else:
                props['Ipv6Prefix'] = self.ipv6_prefix

        return props


@dataclass
class PrivateIpAddressSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    primary: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.private_ip_address is not None:
            if hasattr(self.private_ip_address, 'to_dict'):
                props['PrivateIpAddress'] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props['PrivateIpAddress'] = self.private_ip_address

        if self.primary is not None:
            if hasattr(self.primary, 'to_dict'):
                props['Primary'] = self.primary.to_dict()
            elif isinstance(self.primary, list):
                props['Primary'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.primary
                ]
            else:
                props['Primary'] = self.primary

        return props


@dataclass
class PublicIpDnsNameOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dns_hostname_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    public_ipv4_dns_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    public_dual_stack_dns_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    public_ipv6_dns_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.dns_hostname_type is not None:
            if hasattr(self.dns_hostname_type, 'to_dict'):
                props['DnsHostnameType'] = self.dns_hostname_type.to_dict()
            elif isinstance(self.dns_hostname_type, list):
                props['DnsHostnameType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dns_hostname_type
                ]
            else:
                props['DnsHostnameType'] = self.dns_hostname_type

        if self.public_ipv4_dns_name is not None:
            if hasattr(self.public_ipv4_dns_name, 'to_dict'):
                props['PublicIpv4DnsName'] = self.public_ipv4_dns_name.to_dict()
            elif isinstance(self.public_ipv4_dns_name, list):
                props['PublicIpv4DnsName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_ipv4_dns_name
                ]
            else:
                props['PublicIpv4DnsName'] = self.public_ipv4_dns_name

        if self.public_dual_stack_dns_name is not None:
            if hasattr(self.public_dual_stack_dns_name, 'to_dict'):
                props['PublicDualStackDnsName'] = self.public_dual_stack_dns_name.to_dict()
            elif isinstance(self.public_dual_stack_dns_name, list):
                props['PublicDualStackDnsName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_dual_stack_dns_name
                ]
            else:
                props['PublicDualStackDnsName'] = self.public_dual_stack_dns_name

        if self.public_ipv6_dns_name is not None:
            if hasattr(self.public_ipv6_dns_name, 'to_dict'):
                props['PublicIpv6DnsName'] = self.public_ipv6_dns_name.to_dict()
            elif isinstance(self.public_ipv6_dns_name, list):
                props['PublicIpv6DnsName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_ipv6_dns_name
                ]
            else:
                props['PublicIpv6DnsName'] = self.public_ipv6_dns_name

        return props


@dataclass
class NetworkInterface(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkInterface"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_ip_addresses: Optional[list[PrivateIpAddressSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    secondary_private_ip_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    public_ip_dns_hostname_type_specification: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_prefix_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv4_prefixes: Optional[list[Ipv4PrefixSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv4_prefix_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_set: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_addresses: Optional[list[InstanceIpv6Address]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_prefixes: Optional[list[Ipv6PrefixSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_dest_check: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    interface_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connection_tracking_specification: Optional[ConnectionTrackingSpecification] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.private_ip_address is not None:
            # Serialize private_ip_address (handle intrinsic functions)
            if hasattr(self.private_ip_address, 'to_dict'):
                props["PrivateIpAddress"] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props["PrivateIpAddress"] = self.private_ip_address

        if self.private_ip_addresses is not None:
            # Serialize private_ip_addresses (handle intrinsic functions)
            if hasattr(self.private_ip_addresses, 'to_dict'):
                props["PrivateIpAddresses"] = self.private_ip_addresses.to_dict()
            elif isinstance(self.private_ip_addresses, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateIpAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_addresses
                ]
            else:
                props["PrivateIpAddresses"] = self.private_ip_addresses

        if self.secondary_private_ip_address_count is not None:
            # Serialize secondary_private_ip_address_count (handle intrinsic functions)
            if hasattr(self.secondary_private_ip_address_count, 'to_dict'):
                props["SecondaryPrivateIpAddressCount"] = self.secondary_private_ip_address_count.to_dict()
            elif isinstance(self.secondary_private_ip_address_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecondaryPrivateIpAddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_private_ip_address_count
                ]
            else:
                props["SecondaryPrivateIpAddressCount"] = self.secondary_private_ip_address_count

        if self.public_ip_dns_hostname_type_specification is not None:
            # Serialize public_ip_dns_hostname_type_specification (handle intrinsic functions)
            if hasattr(self.public_ip_dns_hostname_type_specification, 'to_dict'):
                props["PublicIpDnsHostnameTypeSpecification"] = self.public_ip_dns_hostname_type_specification.to_dict()
            elif isinstance(self.public_ip_dns_hostname_type_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['PublicIpDnsHostnameTypeSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_ip_dns_hostname_type_specification
                ]
            else:
                props["PublicIpDnsHostnameTypeSpecification"] = self.public_ip_dns_hostname_type_specification

        if self.ipv6_prefix_count is not None:
            # Serialize ipv6_prefix_count (handle intrinsic functions)
            if hasattr(self.ipv6_prefix_count, 'to_dict'):
                props["Ipv6PrefixCount"] = self.ipv6_prefix_count.to_dict()
            elif isinstance(self.ipv6_prefix_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6PrefixCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_prefix_count
                ]
            else:
                props["Ipv6PrefixCount"] = self.ipv6_prefix_count

        if self.ipv4_prefixes is not None:
            # Serialize ipv4_prefixes (handle intrinsic functions)
            if hasattr(self.ipv4_prefixes, 'to_dict'):
                props["Ipv4Prefixes"] = self.ipv4_prefixes.to_dict()
            elif isinstance(self.ipv4_prefixes, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv4Prefixes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_prefixes
                ]
            else:
                props["Ipv4Prefixes"] = self.ipv4_prefixes

        if self.ipv4_prefix_count is not None:
            # Serialize ipv4_prefix_count (handle intrinsic functions)
            if hasattr(self.ipv4_prefix_count, 'to_dict'):
                props["Ipv4PrefixCount"] = self.ipv4_prefix_count.to_dict()
            elif isinstance(self.ipv4_prefix_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv4PrefixCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_prefix_count
                ]
            else:
                props["Ipv4PrefixCount"] = self.ipv4_prefix_count

        if self.group_set is not None:
            # Serialize group_set (handle intrinsic functions)
            if hasattr(self.group_set, 'to_dict'):
                props["GroupSet"] = self.group_set.to_dict()
            elif isinstance(self.group_set, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupSet'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_set
                ]
            else:
                props["GroupSet"] = self.group_set

        if self.ipv6_addresses is not None:
            # Serialize ipv6_addresses (handle intrinsic functions)
            if hasattr(self.ipv6_addresses, 'to_dict'):
                props["Ipv6Addresses"] = self.ipv6_addresses.to_dict()
            elif isinstance(self.ipv6_addresses, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6Addresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_addresses
                ]
            else:
                props["Ipv6Addresses"] = self.ipv6_addresses

        if self.ipv6_prefixes is not None:
            # Serialize ipv6_prefixes (handle intrinsic functions)
            if hasattr(self.ipv6_prefixes, 'to_dict'):
                props["Ipv6Prefixes"] = self.ipv6_prefixes.to_dict()
            elif isinstance(self.ipv6_prefixes, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6Prefixes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_prefixes
                ]
            else:
                props["Ipv6Prefixes"] = self.ipv6_prefixes

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        if self.source_dest_check is not None:
            # Serialize source_dest_check (handle intrinsic functions)
            if hasattr(self.source_dest_check, 'to_dict'):
                props["SourceDestCheck"] = self.source_dest_check.to_dict()
            elif isinstance(self.source_dest_check, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceDestCheck'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_dest_check
                ]
            else:
                props["SourceDestCheck"] = self.source_dest_check

        if self.interface_type is not None:
            # Serialize interface_type (handle intrinsic functions)
            if hasattr(self.interface_type, 'to_dict'):
                props["InterfaceType"] = self.interface_type.to_dict()
            elif isinstance(self.interface_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['InterfaceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.interface_type
                ]
            else:
                props["InterfaceType"] = self.interface_type

        if self.ipv6_address_count is not None:
            # Serialize ipv6_address_count (handle intrinsic functions)
            if hasattr(self.ipv6_address_count, 'to_dict'):
                props["Ipv6AddressCount"] = self.ipv6_address_count.to_dict()
            elif isinstance(self.ipv6_address_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6AddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address_count
                ]
            else:
                props["Ipv6AddressCount"] = self.ipv6_address_count

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.connection_tracking_specification is not None:
            # Serialize connection_tracking_specification (handle intrinsic functions)
            if hasattr(self.connection_tracking_specification, 'to_dict'):
                props["ConnectionTrackingSpecification"] = self.connection_tracking_specification.to_dict()
            elif isinstance(self.connection_tracking_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConnectionTrackingSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connection_tracking_specification
                ]
            else:
                props["ConnectionTrackingSpecification"] = self.connection_tracking_specification

        return props

    @property
    def attr_public_ip_dns_name_options__public_ipv6_dns_name(self) -> GetAtt:
        """Get the PublicIpDnsNameOptions.PublicIpv6DnsName attribute."""
        return self.get_att("PublicIpDnsNameOptions.PublicIpv6DnsName")

    @property
    def attr_primary_ipv6_address(self) -> GetAtt:
        """Get the PrimaryIpv6Address attribute."""
        return self.get_att("PrimaryIpv6Address")

    @property
    def attr_secondary_private_ip_addresses(self) -> GetAtt:
        """Get the SecondaryPrivateIpAddresses attribute."""
        return self.get_att("SecondaryPrivateIpAddresses")

    @property
    def attr_vpc_id(self) -> GetAtt:
        """Get the VpcId attribute."""
        return self.get_att("VpcId")

    @property
    def attr_primary_private_ip_address(self) -> GetAtt:
        """Get the PrimaryPrivateIpAddress attribute."""
        return self.get_att("PrimaryPrivateIpAddress")

    @property
    def attr_public_ip_dns_name_options__dns_hostname_type(self) -> GetAtt:
        """Get the PublicIpDnsNameOptions.DnsHostnameType attribute."""
        return self.get_att("PublicIpDnsNameOptions.DnsHostnameType")

    @property
    def attr_public_ip_dns_name_options__public_dual_stack_dns_name(self) -> GetAtt:
        """Get the PublicIpDnsNameOptions.PublicDualStackDnsName attribute."""
        return self.get_att("PublicIpDnsNameOptions.PublicDualStackDnsName")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")

    @property
    def attr_public_ip_dns_name_options(self) -> GetAtt:
        """Get the PublicIpDnsNameOptions attribute."""
        return self.get_att("PublicIpDnsNameOptions")

    @property
    def attr_public_ip_dns_name_options__public_ipv4_dns_name(self) -> GetAtt:
        """Get the PublicIpDnsNameOptions.PublicIpv4DnsName attribute."""
        return self.get_att("PublicIpDnsNameOptions.PublicIpv4DnsName")




@dataclass
class EnaSrdSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_udp_specification: Optional[EnaSrdUdpSpecification] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ena_srd_enabled is not None:
            if hasattr(self.ena_srd_enabled, 'to_dict'):
                props['EnaSrdEnabled'] = self.ena_srd_enabled.to_dict()
            elif isinstance(self.ena_srd_enabled, list):
                props['EnaSrdEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_enabled
                ]
            else:
                props['EnaSrdEnabled'] = self.ena_srd_enabled

        if self.ena_srd_udp_specification is not None:
            if hasattr(self.ena_srd_udp_specification, 'to_dict'):
                props['EnaSrdUdpSpecification'] = self.ena_srd_udp_specification.to_dict()
            elif isinstance(self.ena_srd_udp_specification, list):
                props['EnaSrdUdpSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_udp_specification
                ]
            else:
                props['EnaSrdUdpSpecification'] = self.ena_srd_udp_specification

        return props


@dataclass
class EnaSrdUdpSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_udp_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ena_srd_udp_enabled is not None:
            if hasattr(self.ena_srd_udp_enabled, 'to_dict'):
                props['EnaSrdUdpEnabled'] = self.ena_srd_udp_enabled.to_dict()
            elif isinstance(self.ena_srd_udp_enabled, list):
                props['EnaSrdUdpEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_udp_enabled
                ]
            else:
                props['EnaSrdUdpEnabled'] = self.ena_srd_udp_enabled

        return props


@dataclass
class NetworkInterfaceAttachment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkInterfaceAttachment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ena_srd_specification: Optional[EnaSrdSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    device_index: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ena_queue_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ena_srd_specification is not None:
            # Serialize ena_srd_specification (handle intrinsic functions)
            if hasattr(self.ena_srd_specification, 'to_dict'):
                props["EnaSrdSpecification"] = self.ena_srd_specification.to_dict()
            elif isinstance(self.ena_srd_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnaSrdSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_specification
                ]
            else:
                props["EnaSrdSpecification"] = self.ena_srd_specification

        if self.instance_id is not None:
            # Serialize instance_id (handle intrinsic functions)
            if hasattr(self.instance_id, 'to_dict'):
                props["InstanceId"] = self.instance_id.to_dict()
            elif isinstance(self.instance_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_id
                ]
            else:
                props["InstanceId"] = self.instance_id

        if self.device_index is not None:
            # Serialize device_index (handle intrinsic functions)
            if hasattr(self.device_index, 'to_dict'):
                props["DeviceIndex"] = self.device_index.to_dict()
            elif isinstance(self.device_index, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeviceIndex'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_index
                ]
            else:
                props["DeviceIndex"] = self.device_index

        if self.ena_queue_count is not None:
            # Serialize ena_queue_count (handle intrinsic functions)
            if hasattr(self.ena_queue_count, 'to_dict'):
                props["EnaQueueCount"] = self.ena_queue_count.to_dict()
            elif isinstance(self.ena_queue_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnaQueueCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_queue_count
                ]
            else:
                props["EnaQueueCount"] = self.ena_queue_count

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        if self.delete_on_termination is not None:
            # Serialize delete_on_termination (handle intrinsic functions)
            if hasattr(self.delete_on_termination, 'to_dict'):
                props["DeleteOnTermination"] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props["DeleteOnTermination"] = self.delete_on_termination

        return props

    @property
    def attr_attachment_id(self) -> GetAtt:
        """Get the AttachmentId attribute."""
        return self.get_att("AttachmentId")




@dataclass
class NetworkInterfacePermission(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkInterfacePermission"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    aws_account_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    permission: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.aws_account_id is not None:
            # Serialize aws_account_id (handle intrinsic functions)
            if hasattr(self.aws_account_id, 'to_dict'):
                props["AwsAccountId"] = self.aws_account_id.to_dict()
            elif isinstance(self.aws_account_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AwsAccountId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.aws_account_id
                ]
            else:
                props["AwsAccountId"] = self.aws_account_id

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        if self.permission is not None:
            # Serialize permission (handle intrinsic functions)
            if hasattr(self.permission, 'to_dict'):
                props["Permission"] = self.permission.to_dict()
            elif isinstance(self.permission, list):
                # Serialize list items (may contain intrinsic functions)
                props['Permission'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.permission
                ]
            else:
                props["Permission"] = self.permission

        return props



@dataclass
class NetworkPerformanceMetricSubscription(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkPerformanceMetricSubscription"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    statistic: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metric: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination is not None:
            # Serialize destination (handle intrinsic functions)
            if hasattr(self.destination, 'to_dict'):
                props["Destination"] = self.destination.to_dict()
            elif isinstance(self.destination, list):
                # Serialize list items (may contain intrinsic functions)
                props['Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination
                ]
            else:
                props["Destination"] = self.destination

        if self.statistic is not None:
            # Serialize statistic (handle intrinsic functions)
            if hasattr(self.statistic, 'to_dict'):
                props["Statistic"] = self.statistic.to_dict()
            elif isinstance(self.statistic, list):
                # Serialize list items (may contain intrinsic functions)
                props['Statistic'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.statistic
                ]
            else:
                props["Statistic"] = self.statistic

        if self.metric is not None:
            # Serialize metric (handle intrinsic functions)
            if hasattr(self.metric, 'to_dict'):
                props["Metric"] = self.metric.to_dict()
            elif isinstance(self.metric, list):
                # Serialize list items (may contain intrinsic functions)
                props['Metric'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric
                ]
            else:
                props["Metric"] = self.metric

        if self.source is not None:
            # Serialize source (handle intrinsic functions)
            if hasattr(self.source, 'to_dict'):
                props["Source"] = self.source.to_dict()
            elif isinstance(self.source, list):
                # Serialize list items (may contain intrinsic functions)
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props["Source"] = self.source

        return props



@dataclass
class PlacementGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-p"""

    resource_type: ClassVar[str] = "AWS::EC2::PlacementGroup"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    spread_level: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    partition_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.spread_level is not None:
            # Serialize spread_level (handle intrinsic functions)
            if hasattr(self.spread_level, 'to_dict'):
                props["SpreadLevel"] = self.spread_level.to_dict()
            elif isinstance(self.spread_level, list):
                # Serialize list items (may contain intrinsic functions)
                props['SpreadLevel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spread_level
                ]
            else:
                props["SpreadLevel"] = self.spread_level

        if self.strategy is not None:
            # Serialize strategy (handle intrinsic functions)
            if hasattr(self.strategy, 'to_dict'):
                props["Strategy"] = self.strategy.to_dict()
            elif isinstance(self.strategy, list):
                # Serialize list items (may contain intrinsic functions)
                props['Strategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.strategy
                ]
            else:
                props["Strategy"] = self.strategy

        if self.partition_count is not None:
            # Serialize partition_count (handle intrinsic functions)
            if hasattr(self.partition_count, 'to_dict'):
                props["PartitionCount"] = self.partition_count.to_dict()
            elif isinstance(self.partition_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['PartitionCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.partition_count
                ]
            else:
                props["PartitionCount"] = self.partition_count

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_group_name(self) -> GetAtt:
        """Get the GroupName attribute."""
        return self.get_att("GroupName")




@dataclass
class Entry:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.cidr is not None:
            if hasattr(self.cidr, 'to_dict'):
                props['Cidr'] = self.cidr.to_dict()
            elif isinstance(self.cidr, list):
                props['Cidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr
                ]
            else:
                props['Cidr'] = self.cidr

        return props


@dataclass
class PrefixList(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-p"""

    resource_type: ClassVar[str] = "AWS::EC2::PrefixList"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_entries: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    prefix_list_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    entries: Optional[list[Entry]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    address_family: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_entries is not None:
            # Serialize max_entries (handle intrinsic functions)
            if hasattr(self.max_entries, 'to_dict'):
                props["MaxEntries"] = self.max_entries.to_dict()
            elif isinstance(self.max_entries, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxEntries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_entries
                ]
            else:
                props["MaxEntries"] = self.max_entries

        if self.prefix_list_name is not None:
            # Serialize prefix_list_name (handle intrinsic functions)
            if hasattr(self.prefix_list_name, 'to_dict'):
                props["PrefixListName"] = self.prefix_list_name.to_dict()
            elif isinstance(self.prefix_list_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrefixListName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.prefix_list_name
                ]
            else:
                props["PrefixListName"] = self.prefix_list_name

        if self.entries is not None:
            # Serialize entries (handle intrinsic functions)
            if hasattr(self.entries, 'to_dict'):
                props["Entries"] = self.entries.to_dict()
            elif isinstance(self.entries, list):
                # Serialize list items (may contain intrinsic functions)
                props['Entries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.entries
                ]
            else:
                props["Entries"] = self.entries

        if self.address_family is not None:
            # Serialize address_family (handle intrinsic functions)
            if hasattr(self.address_family, 'to_dict'):
                props["AddressFamily"] = self.address_family.to_dict()
            elif isinstance(self.address_family, list):
                # Serialize list items (may contain intrinsic functions)
                props['AddressFamily'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.address_family
                ]
            else:
                props["AddressFamily"] = self.address_family

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_prefix_list_id(self) -> GetAtt:
        """Get the PrefixListId attribute."""
        return self.get_att("PrefixListId")

    @property
    def attr_version(self) -> GetAtt:
        """Get the Version attribute."""
        return self.get_att("Version")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class Route(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-r"""

    resource_type: ClassVar[str] = "AWS::EC2::Route"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_ipv6_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    carrier_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_endpoint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    core_network_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_peering_connection_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    egress_only_internet_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_prefix_list_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    nat_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination_ipv6_cidr_block is not None:
            # Serialize destination_ipv6_cidr_block (handle intrinsic functions)
            if hasattr(self.destination_ipv6_cidr_block, 'to_dict'):
                props["DestinationIpv6CidrBlock"] = self.destination_ipv6_cidr_block.to_dict()
            elif isinstance(self.destination_ipv6_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationIpv6CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_ipv6_cidr_block
                ]
            else:
                props["DestinationIpv6CidrBlock"] = self.destination_ipv6_cidr_block

        if self.route_table_id is not None:
            # Serialize route_table_id (handle intrinsic functions)
            if hasattr(self.route_table_id, 'to_dict'):
                props["RouteTableId"] = self.route_table_id.to_dict()
            elif isinstance(self.route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_id
                ]
            else:
                props["RouteTableId"] = self.route_table_id

        if self.instance_id is not None:
            # Serialize instance_id (handle intrinsic functions)
            if hasattr(self.instance_id, 'to_dict'):
                props["InstanceId"] = self.instance_id.to_dict()
            elif isinstance(self.instance_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_id
                ]
            else:
                props["InstanceId"] = self.instance_id

        if self.local_gateway_id is not None:
            # Serialize local_gateway_id (handle intrinsic functions)
            if hasattr(self.local_gateway_id, 'to_dict'):
                props["LocalGatewayId"] = self.local_gateway_id.to_dict()
            elif isinstance(self.local_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_id
                ]
            else:
                props["LocalGatewayId"] = self.local_gateway_id

        if self.carrier_gateway_id is not None:
            # Serialize carrier_gateway_id (handle intrinsic functions)
            if hasattr(self.carrier_gateway_id, 'to_dict'):
                props["CarrierGatewayId"] = self.carrier_gateway_id.to_dict()
            elif isinstance(self.carrier_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['CarrierGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.carrier_gateway_id
                ]
            else:
                props["CarrierGatewayId"] = self.carrier_gateway_id

        if self.destination_cidr_block is not None:
            # Serialize destination_cidr_block (handle intrinsic functions)
            if hasattr(self.destination_cidr_block, 'to_dict'):
                props["DestinationCidrBlock"] = self.destination_cidr_block.to_dict()
            elif isinstance(self.destination_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr_block
                ]
            else:
                props["DestinationCidrBlock"] = self.destination_cidr_block

        if self.gateway_id is not None:
            # Serialize gateway_id (handle intrinsic functions)
            if hasattr(self.gateway_id, 'to_dict'):
                props["GatewayId"] = self.gateway_id.to_dict()
            elif isinstance(self.gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['GatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gateway_id
                ]
            else:
                props["GatewayId"] = self.gateway_id

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        if self.vpc_endpoint_id is not None:
            # Serialize vpc_endpoint_id (handle intrinsic functions)
            if hasattr(self.vpc_endpoint_id, 'to_dict'):
                props["VpcEndpointId"] = self.vpc_endpoint_id.to_dict()
            elif isinstance(self.vpc_endpoint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcEndpointId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_endpoint_id
                ]
            else:
                props["VpcEndpointId"] = self.vpc_endpoint_id

        if self.core_network_arn is not None:
            # Serialize core_network_arn (handle intrinsic functions)
            if hasattr(self.core_network_arn, 'to_dict'):
                props["CoreNetworkArn"] = self.core_network_arn.to_dict()
            elif isinstance(self.core_network_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['CoreNetworkArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.core_network_arn
                ]
            else:
                props["CoreNetworkArn"] = self.core_network_arn

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        if self.vpc_peering_connection_id is not None:
            # Serialize vpc_peering_connection_id (handle intrinsic functions)
            if hasattr(self.vpc_peering_connection_id, 'to_dict'):
                props["VpcPeeringConnectionId"] = self.vpc_peering_connection_id.to_dict()
            elif isinstance(self.vpc_peering_connection_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcPeeringConnectionId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_peering_connection_id
                ]
            else:
                props["VpcPeeringConnectionId"] = self.vpc_peering_connection_id

        if self.egress_only_internet_gateway_id is not None:
            # Serialize egress_only_internet_gateway_id (handle intrinsic functions)
            if hasattr(self.egress_only_internet_gateway_id, 'to_dict'):
                props["EgressOnlyInternetGatewayId"] = self.egress_only_internet_gateway_id.to_dict()
            elif isinstance(self.egress_only_internet_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['EgressOnlyInternetGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.egress_only_internet_gateway_id
                ]
            else:
                props["EgressOnlyInternetGatewayId"] = self.egress_only_internet_gateway_id

        if self.destination_prefix_list_id is not None:
            # Serialize destination_prefix_list_id (handle intrinsic functions)
            if hasattr(self.destination_prefix_list_id, 'to_dict'):
                props["DestinationPrefixListId"] = self.destination_prefix_list_id.to_dict()
            elif isinstance(self.destination_prefix_list_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationPrefixListId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_prefix_list_id
                ]
            else:
                props["DestinationPrefixListId"] = self.destination_prefix_list_id

        if self.nat_gateway_id is not None:
            # Serialize nat_gateway_id (handle intrinsic functions)
            if hasattr(self.nat_gateway_id, 'to_dict'):
                props["NatGatewayId"] = self.nat_gateway_id.to_dict()
            elif isinstance(self.nat_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NatGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.nat_gateway_id
                ]
            else:
                props["NatGatewayId"] = self.nat_gateway_id

        return props

    @property
    def attr_cidr_block(self) -> GetAtt:
        """Get the CidrBlock attribute."""
        return self.get_att("CidrBlock")




@dataclass
class RouteServer(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-r"""

    resource_type: ClassVar[str] = "AWS::EC2::RouteServer"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    persist_routes: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sns_notifications_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    persist_routes_duration: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    amazon_side_asn: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.persist_routes is not None:
            # Serialize persist_routes (handle intrinsic functions)
            if hasattr(self.persist_routes, 'to_dict'):
                props["PersistRoutes"] = self.persist_routes.to_dict()
            elif isinstance(self.persist_routes, list):
                # Serialize list items (may contain intrinsic functions)
                props['PersistRoutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.persist_routes
                ]
            else:
                props["PersistRoutes"] = self.persist_routes

        if self.sns_notifications_enabled is not None:
            # Serialize sns_notifications_enabled (handle intrinsic functions)
            if hasattr(self.sns_notifications_enabled, 'to_dict'):
                props["SnsNotificationsEnabled"] = self.sns_notifications_enabled.to_dict()
            elif isinstance(self.sns_notifications_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['SnsNotificationsEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sns_notifications_enabled
                ]
            else:
                props["SnsNotificationsEnabled"] = self.sns_notifications_enabled

        if self.persist_routes_duration is not None:
            # Serialize persist_routes_duration (handle intrinsic functions)
            if hasattr(self.persist_routes_duration, 'to_dict'):
                props["PersistRoutesDuration"] = self.persist_routes_duration.to_dict()
            elif isinstance(self.persist_routes_duration, list):
                # Serialize list items (may contain intrinsic functions)
                props['PersistRoutesDuration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.persist_routes_duration
                ]
            else:
                props["PersistRoutesDuration"] = self.persist_routes_duration

        if self.amazon_side_asn is not None:
            # Serialize amazon_side_asn (handle intrinsic functions)
            if hasattr(self.amazon_side_asn, 'to_dict'):
                props["AmazonSideAsn"] = self.amazon_side_asn.to_dict()
            elif isinstance(self.amazon_side_asn, list):
                # Serialize list items (may contain intrinsic functions)
                props['AmazonSideAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.amazon_side_asn
                ]
            else:
                props["AmazonSideAsn"] = self.amazon_side_asn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class RouteServerAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-r"""

    resource_type: ClassVar[str] = "AWS::EC2::RouteServerAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_server_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.route_server_id is not None:
            # Serialize route_server_id (handle intrinsic functions)
            if hasattr(self.route_server_id, 'to_dict'):
                props["RouteServerId"] = self.route_server_id.to_dict()
            elif isinstance(self.route_server_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteServerId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_server_id
                ]
            else:
                props["RouteServerId"] = self.route_server_id

        return props



@dataclass
class RouteServerEndpoint(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-r"""

    resource_type: ClassVar[str] = "AWS::EC2::RouteServerEndpoint"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_server_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        if self.route_server_id is not None:
            # Serialize route_server_id (handle intrinsic functions)
            if hasattr(self.route_server_id, 'to_dict'):
                props["RouteServerId"] = self.route_server_id.to_dict()
            elif isinstance(self.route_server_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteServerId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_server_id
                ]
            else:
                props["RouteServerId"] = self.route_server_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_vpc_id(self) -> GetAtt:
        """Get the VpcId attribute."""
        return self.get_att("VpcId")

    @property
    def attr_eni_id(self) -> GetAtt:
        """Get the EniId attribute."""
        return self.get_att("EniId")

    @property
    def attr_eni_address(self) -> GetAtt:
        """Get the EniAddress attribute."""
        return self.get_att("EniAddress")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class BgpOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    peer_liveness_detection: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    peer_asn: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.peer_liveness_detection is not None:
            if hasattr(self.peer_liveness_detection, 'to_dict'):
                props['PeerLivenessDetection'] = self.peer_liveness_detection.to_dict()
            elif isinstance(self.peer_liveness_detection, list):
                props['PeerLivenessDetection'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_liveness_detection
                ]
            else:
                props['PeerLivenessDetection'] = self.peer_liveness_detection

        if self.peer_asn is not None:
            if hasattr(self.peer_asn, 'to_dict'):
                props['PeerAsn'] = self.peer_asn.to_dict()
            elif isinstance(self.peer_asn, list):
                props['PeerAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_asn
                ]
            else:
                props['PeerAsn'] = self.peer_asn

        return props


@dataclass
class RouteServerPeer(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-r"""

    resource_type: ClassVar[str] = "AWS::EC2::RouteServerPeer"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    bgp_options: Optional[BgpOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_server_endpoint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.peer_address is not None:
            # Serialize peer_address (handle intrinsic functions)
            if hasattr(self.peer_address, 'to_dict'):
                props["PeerAddress"] = self.peer_address.to_dict()
            elif isinstance(self.peer_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_address
                ]
            else:
                props["PeerAddress"] = self.peer_address

        if self.bgp_options is not None:
            # Serialize bgp_options (handle intrinsic functions)
            if hasattr(self.bgp_options, 'to_dict'):
                props["BgpOptions"] = self.bgp_options.to_dict()
            elif isinstance(self.bgp_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['BgpOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bgp_options
                ]
            else:
                props["BgpOptions"] = self.bgp_options

        if self.route_server_endpoint_id is not None:
            # Serialize route_server_endpoint_id (handle intrinsic functions)
            if hasattr(self.route_server_endpoint_id, 'to_dict'):
                props["RouteServerEndpointId"] = self.route_server_endpoint_id.to_dict()
            elif isinstance(self.route_server_endpoint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteServerEndpointId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_server_endpoint_id
                ]
            else:
                props["RouteServerEndpointId"] = self.route_server_endpoint_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_endpoint_eni_id(self) -> GetAtt:
        """Get the EndpointEniId attribute."""
        return self.get_att("EndpointEniId")

    @property
    def attr_vpc_id(self) -> GetAtt:
        """Get the VpcId attribute."""
        return self.get_att("VpcId")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")

    @property
    def attr_subnet_id(self) -> GetAtt:
        """Get the SubnetId attribute."""
        return self.get_att("SubnetId")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_endpoint_eni_address(self) -> GetAtt:
        """Get the EndpointEniAddress attribute."""
        return self.get_att("EndpointEniAddress")

    @property
    def attr_route_server_id(self) -> GetAtt:
        """Get the RouteServerId attribute."""
        return self.get_att("RouteServerId")




@dataclass
class RouteServerPropagation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-r"""

    resource_type: ClassVar[str] = "AWS::EC2::RouteServerPropagation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_server_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.route_table_id is not None:
            # Serialize route_table_id (handle intrinsic functions)
            if hasattr(self.route_table_id, 'to_dict'):
                props["RouteTableId"] = self.route_table_id.to_dict()
            elif isinstance(self.route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_id
                ]
            else:
                props["RouteTableId"] = self.route_table_id

        if self.route_server_id is not None:
            # Serialize route_server_id (handle intrinsic functions)
            if hasattr(self.route_server_id, 'to_dict'):
                props["RouteServerId"] = self.route_server_id.to_dict()
            elif isinstance(self.route_server_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteServerId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_server_id
                ]
            else:
                props["RouteServerId"] = self.route_server_id

        return props



@dataclass
class RouteTable(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-r"""

    resource_type: ClassVar[str] = "AWS::EC2::RouteTable"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_route_table_id(self) -> GetAtt:
        """Get the RouteTableId attribute."""
        return self.get_att("RouteTableId")




@dataclass
class Egress:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr_ip: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr_ipv6: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ip_protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_security_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_prefix_list_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cidr_ip is not None:
            if hasattr(self.cidr_ip, 'to_dict'):
                props['CidrIp'] = self.cidr_ip.to_dict()
            elif isinstance(self.cidr_ip, list):
                props['CidrIp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_ip
                ]
            else:
                props['CidrIp'] = self.cidr_ip

        if self.cidr_ipv6 is not None:
            if hasattr(self.cidr_ipv6, 'to_dict'):
                props['CidrIpv6'] = self.cidr_ipv6.to_dict()
            elif isinstance(self.cidr_ipv6, list):
                props['CidrIpv6'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_ipv6
                ]
            else:
                props['CidrIpv6'] = self.cidr_ipv6

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.from_port is not None:
            if hasattr(self.from_port, 'to_dict'):
                props['FromPort'] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props['FromPort'] = self.from_port

        if self.to_port is not None:
            if hasattr(self.to_port, 'to_dict'):
                props['ToPort'] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props['ToPort'] = self.to_port

        if self.ip_protocol is not None:
            if hasattr(self.ip_protocol, 'to_dict'):
                props['IpProtocol'] = self.ip_protocol.to_dict()
            elif isinstance(self.ip_protocol, list):
                props['IpProtocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_protocol
                ]
            else:
                props['IpProtocol'] = self.ip_protocol

        if self.destination_security_group_id is not None:
            if hasattr(self.destination_security_group_id, 'to_dict'):
                props['DestinationSecurityGroupId'] = self.destination_security_group_id.to_dict()
            elif isinstance(self.destination_security_group_id, list):
                props['DestinationSecurityGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_security_group_id
                ]
            else:
                props['DestinationSecurityGroupId'] = self.destination_security_group_id

        if self.destination_prefix_list_id is not None:
            if hasattr(self.destination_prefix_list_id, 'to_dict'):
                props['DestinationPrefixListId'] = self.destination_prefix_list_id.to_dict()
            elif isinstance(self.destination_prefix_list_id, list):
                props['DestinationPrefixListId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_prefix_list_id
                ]
            else:
                props['DestinationPrefixListId'] = self.destination_prefix_list_id

        return props


@dataclass
class Ingress:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr_ip: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr_ipv6: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_security_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_security_group_owner_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ip_protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_security_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_prefix_list_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cidr_ip is not None:
            if hasattr(self.cidr_ip, 'to_dict'):
                props['CidrIp'] = self.cidr_ip.to_dict()
            elif isinstance(self.cidr_ip, list):
                props['CidrIp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_ip
                ]
            else:
                props['CidrIp'] = self.cidr_ip

        if self.cidr_ipv6 is not None:
            if hasattr(self.cidr_ipv6, 'to_dict'):
                props['CidrIpv6'] = self.cidr_ipv6.to_dict()
            elif isinstance(self.cidr_ipv6, list):
                props['CidrIpv6'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_ipv6
                ]
            else:
                props['CidrIpv6'] = self.cidr_ipv6

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.from_port is not None:
            if hasattr(self.from_port, 'to_dict'):
                props['FromPort'] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props['FromPort'] = self.from_port

        if self.source_security_group_name is not None:
            if hasattr(self.source_security_group_name, 'to_dict'):
                props['SourceSecurityGroupName'] = self.source_security_group_name.to_dict()
            elif isinstance(self.source_security_group_name, list):
                props['SourceSecurityGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_security_group_name
                ]
            else:
                props['SourceSecurityGroupName'] = self.source_security_group_name

        if self.to_port is not None:
            if hasattr(self.to_port, 'to_dict'):
                props['ToPort'] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props['ToPort'] = self.to_port

        if self.source_security_group_owner_id is not None:
            if hasattr(self.source_security_group_owner_id, 'to_dict'):
                props['SourceSecurityGroupOwnerId'] = self.source_security_group_owner_id.to_dict()
            elif isinstance(self.source_security_group_owner_id, list):
                props['SourceSecurityGroupOwnerId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_security_group_owner_id
                ]
            else:
                props['SourceSecurityGroupOwnerId'] = self.source_security_group_owner_id

        if self.ip_protocol is not None:
            if hasattr(self.ip_protocol, 'to_dict'):
                props['IpProtocol'] = self.ip_protocol.to_dict()
            elif isinstance(self.ip_protocol, list):
                props['IpProtocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_protocol
                ]
            else:
                props['IpProtocol'] = self.ip_protocol

        if self.source_security_group_id is not None:
            if hasattr(self.source_security_group_id, 'to_dict'):
                props['SourceSecurityGroupId'] = self.source_security_group_id.to_dict()
            elif isinstance(self.source_security_group_id, list):
                props['SourceSecurityGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_security_group_id
                ]
            else:
                props['SourceSecurityGroupId'] = self.source_security_group_id

        if self.source_prefix_list_id is not None:
            if hasattr(self.source_prefix_list_id, 'to_dict'):
                props['SourcePrefixListId'] = self.source_prefix_list_id.to_dict()
            elif isinstance(self.source_prefix_list_id, list):
                props['SourcePrefixListId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_prefix_list_id
                ]
            else:
                props['SourcePrefixListId'] = self.source_prefix_list_id

        return props


@dataclass
class SecurityGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SecurityGroup"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_ingress: Optional[list[Ingress]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_egress: Optional[list[Egress]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.group_description is not None:
            # Serialize group_description (handle intrinsic functions)
            if hasattr(self.group_description, 'to_dict'):
                props["GroupDescription"] = self.group_description.to_dict()
            elif isinstance(self.group_description, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupDescription'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_description
                ]
            else:
                props["GroupDescription"] = self.group_description

        if self.group_name is not None:
            # Serialize group_name (handle intrinsic functions)
            if hasattr(self.group_name, 'to_dict'):
                props["GroupName"] = self.group_name.to_dict()
            elif isinstance(self.group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_name
                ]
            else:
                props["GroupName"] = self.group_name

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.security_group_ingress is not None:
            # Serialize security_group_ingress (handle intrinsic functions)
            if hasattr(self.security_group_ingress, 'to_dict'):
                props["SecurityGroupIngress"] = self.security_group_ingress.to_dict()
            elif isinstance(self.security_group_ingress, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupIngress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ingress
                ]
            else:
                props["SecurityGroupIngress"] = self.security_group_ingress

        if self.security_group_egress is not None:
            # Serialize security_group_egress (handle intrinsic functions)
            if hasattr(self.security_group_egress, 'to_dict'):
                props["SecurityGroupEgress"] = self.security_group_egress.to_dict()
            elif isinstance(self.security_group_egress, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupEgress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_egress
                ]
            else:
                props["SecurityGroupEgress"] = self.security_group_egress

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_vpc_id(self) -> GetAtt:
        """Get the VpcId attribute."""
        return self.get_att("VpcId")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")

    @property
    def attr_group_id(self) -> GetAtt:
        """Get the GroupId attribute."""
        return self.get_att("GroupId")




@dataclass
class SecurityGroupEgress(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SecurityGroupEgress"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_ip: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_ipv6: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ip_protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_security_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_prefix_list_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cidr_ip is not None:
            # Serialize cidr_ip (handle intrinsic functions)
            if hasattr(self.cidr_ip, 'to_dict'):
                props["CidrIp"] = self.cidr_ip.to_dict()
            elif isinstance(self.cidr_ip, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrIp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_ip
                ]
            else:
                props["CidrIp"] = self.cidr_ip

        if self.cidr_ipv6 is not None:
            # Serialize cidr_ipv6 (handle intrinsic functions)
            if hasattr(self.cidr_ipv6, 'to_dict'):
                props["CidrIpv6"] = self.cidr_ipv6.to_dict()
            elif isinstance(self.cidr_ipv6, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrIpv6'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_ipv6
                ]
            else:
                props["CidrIpv6"] = self.cidr_ipv6

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.from_port is not None:
            # Serialize from_port (handle intrinsic functions)
            if hasattr(self.from_port, 'to_dict'):
                props["FromPort"] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                # Serialize list items (may contain intrinsic functions)
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props["FromPort"] = self.from_port

        if self.to_port is not None:
            # Serialize to_port (handle intrinsic functions)
            if hasattr(self.to_port, 'to_dict'):
                props["ToPort"] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                # Serialize list items (may contain intrinsic functions)
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props["ToPort"] = self.to_port

        if self.ip_protocol is not None:
            # Serialize ip_protocol (handle intrinsic functions)
            if hasattr(self.ip_protocol, 'to_dict'):
                props["IpProtocol"] = self.ip_protocol.to_dict()
            elif isinstance(self.ip_protocol, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpProtocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_protocol
                ]
            else:
                props["IpProtocol"] = self.ip_protocol

        if self.destination_security_group_id is not None:
            # Serialize destination_security_group_id (handle intrinsic functions)
            if hasattr(self.destination_security_group_id, 'to_dict'):
                props["DestinationSecurityGroupId"] = self.destination_security_group_id.to_dict()
            elif isinstance(self.destination_security_group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationSecurityGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_security_group_id
                ]
            else:
                props["DestinationSecurityGroupId"] = self.destination_security_group_id

        if self.destination_prefix_list_id is not None:
            # Serialize destination_prefix_list_id (handle intrinsic functions)
            if hasattr(self.destination_prefix_list_id, 'to_dict'):
                props["DestinationPrefixListId"] = self.destination_prefix_list_id.to_dict()
            elif isinstance(self.destination_prefix_list_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationPrefixListId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_prefix_list_id
                ]
            else:
                props["DestinationPrefixListId"] = self.destination_prefix_list_id

        if self.group_id is not None:
            # Serialize group_id (handle intrinsic functions)
            if hasattr(self.group_id, 'to_dict'):
                props["GroupId"] = self.group_id.to_dict()
            elif isinstance(self.group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_id
                ]
            else:
                props["GroupId"] = self.group_id

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class SecurityGroupIngress(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SecurityGroupIngress"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_ip: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_ipv6: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_security_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_security_group_owner_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ip_protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_security_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_prefix_list_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.group_name is not None:
            # Serialize group_name (handle intrinsic functions)
            if hasattr(self.group_name, 'to_dict'):
                props["GroupName"] = self.group_name.to_dict()
            elif isinstance(self.group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_name
                ]
            else:
                props["GroupName"] = self.group_name

        if self.cidr_ip is not None:
            # Serialize cidr_ip (handle intrinsic functions)
            if hasattr(self.cidr_ip, 'to_dict'):
                props["CidrIp"] = self.cidr_ip.to_dict()
            elif isinstance(self.cidr_ip, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrIp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_ip
                ]
            else:
                props["CidrIp"] = self.cidr_ip

        if self.cidr_ipv6 is not None:
            # Serialize cidr_ipv6 (handle intrinsic functions)
            if hasattr(self.cidr_ipv6, 'to_dict'):
                props["CidrIpv6"] = self.cidr_ipv6.to_dict()
            elif isinstance(self.cidr_ipv6, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrIpv6'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_ipv6
                ]
            else:
                props["CidrIpv6"] = self.cidr_ipv6

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.from_port is not None:
            # Serialize from_port (handle intrinsic functions)
            if hasattr(self.from_port, 'to_dict'):
                props["FromPort"] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                # Serialize list items (may contain intrinsic functions)
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props["FromPort"] = self.from_port

        if self.source_security_group_name is not None:
            # Serialize source_security_group_name (handle intrinsic functions)
            if hasattr(self.source_security_group_name, 'to_dict'):
                props["SourceSecurityGroupName"] = self.source_security_group_name.to_dict()
            elif isinstance(self.source_security_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceSecurityGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_security_group_name
                ]
            else:
                props["SourceSecurityGroupName"] = self.source_security_group_name

        if self.to_port is not None:
            # Serialize to_port (handle intrinsic functions)
            if hasattr(self.to_port, 'to_dict'):
                props["ToPort"] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                # Serialize list items (may contain intrinsic functions)
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props["ToPort"] = self.to_port

        if self.source_security_group_owner_id is not None:
            # Serialize source_security_group_owner_id (handle intrinsic functions)
            if hasattr(self.source_security_group_owner_id, 'to_dict'):
                props["SourceSecurityGroupOwnerId"] = self.source_security_group_owner_id.to_dict()
            elif isinstance(self.source_security_group_owner_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceSecurityGroupOwnerId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_security_group_owner_id
                ]
            else:
                props["SourceSecurityGroupOwnerId"] = self.source_security_group_owner_id

        if self.ip_protocol is not None:
            # Serialize ip_protocol (handle intrinsic functions)
            if hasattr(self.ip_protocol, 'to_dict'):
                props["IpProtocol"] = self.ip_protocol.to_dict()
            elif isinstance(self.ip_protocol, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpProtocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_protocol
                ]
            else:
                props["IpProtocol"] = self.ip_protocol

        if self.source_security_group_id is not None:
            # Serialize source_security_group_id (handle intrinsic functions)
            if hasattr(self.source_security_group_id, 'to_dict'):
                props["SourceSecurityGroupId"] = self.source_security_group_id.to_dict()
            elif isinstance(self.source_security_group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceSecurityGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_security_group_id
                ]
            else:
                props["SourceSecurityGroupId"] = self.source_security_group_id

        if self.source_prefix_list_id is not None:
            # Serialize source_prefix_list_id (handle intrinsic functions)
            if hasattr(self.source_prefix_list_id, 'to_dict'):
                props["SourcePrefixListId"] = self.source_prefix_list_id.to_dict()
            elif isinstance(self.source_prefix_list_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourcePrefixListId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_prefix_list_id
                ]
            else:
                props["SourcePrefixListId"] = self.source_prefix_list_id

        if self.group_id is not None:
            # Serialize group_id (handle intrinsic functions)
            if hasattr(self.group_id, 'to_dict'):
                props["GroupId"] = self.group_id.to_dict()
            elif isinstance(self.group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_id
                ]
            else:
                props["GroupId"] = self.group_id

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class SecurityGroupVpcAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SecurityGroupVpcAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.group_id is not None:
            # Serialize group_id (handle intrinsic functions)
            if hasattr(self.group_id, 'to_dict'):
                props["GroupId"] = self.group_id.to_dict()
            elif isinstance(self.group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_id
                ]
            else:
                props["GroupId"] = self.group_id

        return props

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_state_reason(self) -> GetAtt:
        """Get the StateReason attribute."""
        return self.get_att("StateReason")

    @property
    def attr_vpc_owner_id(self) -> GetAtt:
        """Get the VpcOwnerId attribute."""
        return self.get_att("VpcOwnerId")




@dataclass
class SnapshotBlockPublicAccess(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SnapshotBlockPublicAccess"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    state: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.state is not None:
            # Serialize state (handle intrinsic functions)
            if hasattr(self.state, 'to_dict'):
                props["State"] = self.state.to_dict()
            elif isinstance(self.state, list):
                # Serialize list items (may contain intrinsic functions)
                props['State'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state
                ]
            else:
                props["State"] = self.state

        return props

    @property
    def attr_account_id(self) -> GetAtt:
        """Get the AccountId attribute."""
        return self.get_att("AccountId")




@dataclass
class AcceleratorCountRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class AcceleratorTotalMemoryMiBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class BaselineEbsBandwidthMbpsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class BaselinePerformanceFactorsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu: Optional[CpuPerformanceFactorRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cpu is not None:
            if hasattr(self.cpu, 'to_dict'):
                props['Cpu'] = self.cpu.to_dict()
            elif isinstance(self.cpu, list):
                props['Cpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu
                ]
            else:
                props['Cpu'] = self.cpu

        return props


@dataclass
class BlockDeviceMapping:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs: Optional[EbsBlockDevice] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    no_device: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    virtual_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ebs is not None:
            if hasattr(self.ebs, 'to_dict'):
                props['Ebs'] = self.ebs.to_dict()
            elif isinstance(self.ebs, list):
                props['Ebs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs
                ]
            else:
                props['Ebs'] = self.ebs

        if self.no_device is not None:
            if hasattr(self.no_device, 'to_dict'):
                props['NoDevice'] = self.no_device.to_dict()
            elif isinstance(self.no_device, list):
                props['NoDevice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.no_device
                ]
            else:
                props['NoDevice'] = self.no_device

        if self.virtual_name is not None:
            if hasattr(self.virtual_name, 'to_dict'):
                props['VirtualName'] = self.virtual_name.to_dict()
            elif isinstance(self.virtual_name, list):
                props['VirtualName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.virtual_name
                ]
            else:
                props['VirtualName'] = self.virtual_name

        if self.device_name is not None:
            if hasattr(self.device_name, 'to_dict'):
                props['DeviceName'] = self.device_name.to_dict()
            elif isinstance(self.device_name, list):
                props['DeviceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_name
                ]
            else:
                props['DeviceName'] = self.device_name

        return props


@dataclass
class ClassicLoadBalancer:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class ClassicLoadBalancersConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    classic_load_balancers: Optional[list[ClassicLoadBalancer]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.classic_load_balancers is not None:
            if hasattr(self.classic_load_balancers, 'to_dict'):
                props['ClassicLoadBalancers'] = self.classic_load_balancers.to_dict()
            elif isinstance(self.classic_load_balancers, list):
                props['ClassicLoadBalancers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.classic_load_balancers
                ]
            else:
                props['ClassicLoadBalancers'] = self.classic_load_balancers

        return props


@dataclass
class CpuPerformanceFactorRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    references: Optional[list[PerformanceFactorReferenceRequest]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.references is not None:
            if hasattr(self.references, 'to_dict'):
                props['References'] = self.references.to_dict()
            elif isinstance(self.references, list):
                props['References'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.references
                ]
            else:
                props['References'] = self.references

        return props


@dataclass
class EbsBlockDevice:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snapshot_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encrypted: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.snapshot_id is not None:
            if hasattr(self.snapshot_id, 'to_dict'):
                props['SnapshotId'] = self.snapshot_id.to_dict()
            elif isinstance(self.snapshot_id, list):
                props['SnapshotId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snapshot_id
                ]
            else:
                props['SnapshotId'] = self.snapshot_id

        if self.volume_type is not None:
            if hasattr(self.volume_type, 'to_dict'):
                props['VolumeType'] = self.volume_type.to_dict()
            elif isinstance(self.volume_type, list):
                props['VolumeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_type
                ]
            else:
                props['VolumeType'] = self.volume_type

        if self.encrypted is not None:
            if hasattr(self.encrypted, 'to_dict'):
                props['Encrypted'] = self.encrypted.to_dict()
            elif isinstance(self.encrypted, list):
                props['Encrypted'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encrypted
                ]
            else:
                props['Encrypted'] = self.encrypted

        if self.iops is not None:
            if hasattr(self.iops, 'to_dict'):
                props['Iops'] = self.iops.to_dict()
            elif isinstance(self.iops, list):
                props['Iops'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iops
                ]
            else:
                props['Iops'] = self.iops

        if self.volume_size is not None:
            if hasattr(self.volume_size, 'to_dict'):
                props['VolumeSize'] = self.volume_size.to_dict()
            elif isinstance(self.volume_size, list):
                props['VolumeSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size
                ]
            else:
                props['VolumeSize'] = self.volume_size

        if self.delete_on_termination is not None:
            if hasattr(self.delete_on_termination, 'to_dict'):
                props['DeleteOnTermination'] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props['DeleteOnTermination'] = self.delete_on_termination

        return props


@dataclass
class FleetLaunchTemplateSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.launch_template_name is not None:
            if hasattr(self.launch_template_name, 'to_dict'):
                props['LaunchTemplateName'] = self.launch_template_name.to_dict()
            elif isinstance(self.launch_template_name, list):
                props['LaunchTemplateName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_name
                ]
            else:
                props['LaunchTemplateName'] = self.launch_template_name

        if self.version is not None:
            if hasattr(self.version, 'to_dict'):
                props['Version'] = self.version.to_dict()
            elif isinstance(self.version, list):
                props['Version'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version
                ]
            else:
                props['Version'] = self.version

        if self.launch_template_id is not None:
            if hasattr(self.launch_template_id, 'to_dict'):
                props['LaunchTemplateId'] = self.launch_template_id.to_dict()
            elif isinstance(self.launch_template_id, list):
                props['LaunchTemplateId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_id
                ]
            else:
                props['LaunchTemplateId'] = self.launch_template_id

        return props


@dataclass
class GroupIdentifier:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.group_id is not None:
            if hasattr(self.group_id, 'to_dict'):
                props['GroupId'] = self.group_id.to_dict()
            elif isinstance(self.group_id, list):
                props['GroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_id
                ]
            else:
                props['GroupId'] = self.group_id

        return props


@dataclass
class IamInstanceProfileSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.arn is not None:
            if hasattr(self.arn, 'to_dict'):
                props['Arn'] = self.arn.to_dict()
            elif isinstance(self.arn, list):
                props['Arn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.arn
                ]
            else:
                props['Arn'] = self.arn

        return props


@dataclass
class InstanceIpv6Address:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_address: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_address is not None:
            if hasattr(self.ipv6_address, 'to_dict'):
                props['Ipv6Address'] = self.ipv6_address.to_dict()
            elif isinstance(self.ipv6_address, list):
                props['Ipv6Address'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address
                ]
            else:
                props['Ipv6Address'] = self.ipv6_address

        return props


@dataclass
class InstanceNetworkInterfaceSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_addresses: Optional[list[PrivateIpAddressSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    secondary_private_ip_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_index: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_addresses: Optional[list[InstanceIpv6Address]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    associate_public_ip_address: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.private_ip_addresses is not None:
            if hasattr(self.private_ip_addresses, 'to_dict'):
                props['PrivateIpAddresses'] = self.private_ip_addresses.to_dict()
            elif isinstance(self.private_ip_addresses, list):
                props['PrivateIpAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_addresses
                ]
            else:
                props['PrivateIpAddresses'] = self.private_ip_addresses

        if self.secondary_private_ip_address_count is not None:
            if hasattr(self.secondary_private_ip_address_count, 'to_dict'):
                props['SecondaryPrivateIpAddressCount'] = self.secondary_private_ip_address_count.to_dict()
            elif isinstance(self.secondary_private_ip_address_count, list):
                props['SecondaryPrivateIpAddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_private_ip_address_count
                ]
            else:
                props['SecondaryPrivateIpAddressCount'] = self.secondary_private_ip_address_count

        if self.device_index is not None:
            if hasattr(self.device_index, 'to_dict'):
                props['DeviceIndex'] = self.device_index.to_dict()
            elif isinstance(self.device_index, list):
                props['DeviceIndex'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_index
                ]
            else:
                props['DeviceIndex'] = self.device_index

        if self.groups is not None:
            if hasattr(self.groups, 'to_dict'):
                props['Groups'] = self.groups.to_dict()
            elif isinstance(self.groups, list):
                props['Groups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.groups
                ]
            else:
                props['Groups'] = self.groups

        if self.ipv6_address_count is not None:
            if hasattr(self.ipv6_address_count, 'to_dict'):
                props['Ipv6AddressCount'] = self.ipv6_address_count.to_dict()
            elif isinstance(self.ipv6_address_count, list):
                props['Ipv6AddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address_count
                ]
            else:
                props['Ipv6AddressCount'] = self.ipv6_address_count

        if self.ipv6_addresses is not None:
            if hasattr(self.ipv6_addresses, 'to_dict'):
                props['Ipv6Addresses'] = self.ipv6_addresses.to_dict()
            elif isinstance(self.ipv6_addresses, list):
                props['Ipv6Addresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_addresses
                ]
            else:
                props['Ipv6Addresses'] = self.ipv6_addresses

        if self.subnet_id is not None:
            if hasattr(self.subnet_id, 'to_dict'):
                props['SubnetId'] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props['SubnetId'] = self.subnet_id

        if self.associate_public_ip_address is not None:
            if hasattr(self.associate_public_ip_address, 'to_dict'):
                props['AssociatePublicIpAddress'] = self.associate_public_ip_address.to_dict()
            elif isinstance(self.associate_public_ip_address, list):
                props['AssociatePublicIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.associate_public_ip_address
                ]
            else:
                props['AssociatePublicIpAddress'] = self.associate_public_ip_address

        if self.network_interface_id is not None:
            if hasattr(self.network_interface_id, 'to_dict'):
                props['NetworkInterfaceId'] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props['NetworkInterfaceId'] = self.network_interface_id

        if self.delete_on_termination is not None:
            if hasattr(self.delete_on_termination, 'to_dict'):
                props['DeleteOnTermination'] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props['DeleteOnTermination'] = self.delete_on_termination

        return props


@dataclass
class InstanceRequirementsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_generations: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    require_encryption_in_transit: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_gi_b_per_v_cpu: Optional[MemoryGiBPerVCpuRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    v_cpu_count: Optional[VCpuCountRangeRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_manufacturers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_storage: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_manufacturers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bare_metal: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    require_hibernate_support: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_max_price_percentage_over_lowest_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_mi_b: Optional[MemoryMiBRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_storage_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_count: Optional[NetworkInterfaceCountRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    excluded_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allowed_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_bandwidth_gbps: Optional[NetworkBandwidthGbpsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_count: Optional[AcceleratorCountRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_performance_factors: Optional[BaselinePerformanceFactorsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_max_price_percentage_over_lowest_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_ebs_bandwidth_mbps: Optional[BaselineEbsBandwidthMbpsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_total_memory_mi_b: Optional[AcceleratorTotalMemoryMiBRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    burstable_performance: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    total_local_storage_gb: Optional[TotalLocalStorageGBRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_generations is not None:
            if hasattr(self.instance_generations, 'to_dict'):
                props['InstanceGenerations'] = self.instance_generations.to_dict()
            elif isinstance(self.instance_generations, list):
                props['InstanceGenerations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_generations
                ]
            else:
                props['InstanceGenerations'] = self.instance_generations

        if self.require_encryption_in_transit is not None:
            if hasattr(self.require_encryption_in_transit, 'to_dict'):
                props['RequireEncryptionInTransit'] = self.require_encryption_in_transit.to_dict()
            elif isinstance(self.require_encryption_in_transit, list):
                props['RequireEncryptionInTransit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.require_encryption_in_transit
                ]
            else:
                props['RequireEncryptionInTransit'] = self.require_encryption_in_transit

        if self.memory_gi_b_per_v_cpu is not None:
            if hasattr(self.memory_gi_b_per_v_cpu, 'to_dict'):
                props['MemoryGiBPerVCpu'] = self.memory_gi_b_per_v_cpu.to_dict()
            elif isinstance(self.memory_gi_b_per_v_cpu, list):
                props['MemoryGiBPerVCpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_gi_b_per_v_cpu
                ]
            else:
                props['MemoryGiBPerVCpu'] = self.memory_gi_b_per_v_cpu

        if self.accelerator_types is not None:
            if hasattr(self.accelerator_types, 'to_dict'):
                props['AcceleratorTypes'] = self.accelerator_types.to_dict()
            elif isinstance(self.accelerator_types, list):
                props['AcceleratorTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_types
                ]
            else:
                props['AcceleratorTypes'] = self.accelerator_types

        if self.v_cpu_count is not None:
            if hasattr(self.v_cpu_count, 'to_dict'):
                props['VCpuCount'] = self.v_cpu_count.to_dict()
            elif isinstance(self.v_cpu_count, list):
                props['VCpuCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.v_cpu_count
                ]
            else:
                props['VCpuCount'] = self.v_cpu_count

        if self.accelerator_manufacturers is not None:
            if hasattr(self.accelerator_manufacturers, 'to_dict'):
                props['AcceleratorManufacturers'] = self.accelerator_manufacturers.to_dict()
            elif isinstance(self.accelerator_manufacturers, list):
                props['AcceleratorManufacturers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_manufacturers
                ]
            else:
                props['AcceleratorManufacturers'] = self.accelerator_manufacturers

        if self.local_storage is not None:
            if hasattr(self.local_storage, 'to_dict'):
                props['LocalStorage'] = self.local_storage.to_dict()
            elif isinstance(self.local_storage, list):
                props['LocalStorage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_storage
                ]
            else:
                props['LocalStorage'] = self.local_storage

        if self.cpu_manufacturers is not None:
            if hasattr(self.cpu_manufacturers, 'to_dict'):
                props['CpuManufacturers'] = self.cpu_manufacturers.to_dict()
            elif isinstance(self.cpu_manufacturers, list):
                props['CpuManufacturers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_manufacturers
                ]
            else:
                props['CpuManufacturers'] = self.cpu_manufacturers

        if self.bare_metal is not None:
            if hasattr(self.bare_metal, 'to_dict'):
                props['BareMetal'] = self.bare_metal.to_dict()
            elif isinstance(self.bare_metal, list):
                props['BareMetal'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bare_metal
                ]
            else:
                props['BareMetal'] = self.bare_metal

        if self.require_hibernate_support is not None:
            if hasattr(self.require_hibernate_support, 'to_dict'):
                props['RequireHibernateSupport'] = self.require_hibernate_support.to_dict()
            elif isinstance(self.require_hibernate_support, list):
                props['RequireHibernateSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.require_hibernate_support
                ]
            else:
                props['RequireHibernateSupport'] = self.require_hibernate_support

        if self.max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            if hasattr(self.max_spot_price_as_percentage_of_optimal_on_demand_price, 'to_dict'):
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = self.max_spot_price_as_percentage_of_optimal_on_demand_price.to_dict()
            elif isinstance(self.max_spot_price_as_percentage_of_optimal_on_demand_price, list):
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_spot_price_as_percentage_of_optimal_on_demand_price
                ]
            else:
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = self.max_spot_price_as_percentage_of_optimal_on_demand_price

        if self.on_demand_max_price_percentage_over_lowest_price is not None:
            if hasattr(self.on_demand_max_price_percentage_over_lowest_price, 'to_dict'):
                props['OnDemandMaxPricePercentageOverLowestPrice'] = self.on_demand_max_price_percentage_over_lowest_price.to_dict()
            elif isinstance(self.on_demand_max_price_percentage_over_lowest_price, list):
                props['OnDemandMaxPricePercentageOverLowestPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_max_price_percentage_over_lowest_price
                ]
            else:
                props['OnDemandMaxPricePercentageOverLowestPrice'] = self.on_demand_max_price_percentage_over_lowest_price

        if self.memory_mi_b is not None:
            if hasattr(self.memory_mi_b, 'to_dict'):
                props['MemoryMiB'] = self.memory_mi_b.to_dict()
            elif isinstance(self.memory_mi_b, list):
                props['MemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_mi_b
                ]
            else:
                props['MemoryMiB'] = self.memory_mi_b

        if self.local_storage_types is not None:
            if hasattr(self.local_storage_types, 'to_dict'):
                props['LocalStorageTypes'] = self.local_storage_types.to_dict()
            elif isinstance(self.local_storage_types, list):
                props['LocalStorageTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_storage_types
                ]
            else:
                props['LocalStorageTypes'] = self.local_storage_types

        if self.network_interface_count is not None:
            if hasattr(self.network_interface_count, 'to_dict'):
                props['NetworkInterfaceCount'] = self.network_interface_count.to_dict()
            elif isinstance(self.network_interface_count, list):
                props['NetworkInterfaceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_count
                ]
            else:
                props['NetworkInterfaceCount'] = self.network_interface_count

        if self.excluded_instance_types is not None:
            if hasattr(self.excluded_instance_types, 'to_dict'):
                props['ExcludedInstanceTypes'] = self.excluded_instance_types.to_dict()
            elif isinstance(self.excluded_instance_types, list):
                props['ExcludedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.excluded_instance_types
                ]
            else:
                props['ExcludedInstanceTypes'] = self.excluded_instance_types

        if self.allowed_instance_types is not None:
            if hasattr(self.allowed_instance_types, 'to_dict'):
                props['AllowedInstanceTypes'] = self.allowed_instance_types.to_dict()
            elif isinstance(self.allowed_instance_types, list):
                props['AllowedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_instance_types
                ]
            else:
                props['AllowedInstanceTypes'] = self.allowed_instance_types

        if self.network_bandwidth_gbps is not None:
            if hasattr(self.network_bandwidth_gbps, 'to_dict'):
                props['NetworkBandwidthGbps'] = self.network_bandwidth_gbps.to_dict()
            elif isinstance(self.network_bandwidth_gbps, list):
                props['NetworkBandwidthGbps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_bandwidth_gbps
                ]
            else:
                props['NetworkBandwidthGbps'] = self.network_bandwidth_gbps

        if self.accelerator_count is not None:
            if hasattr(self.accelerator_count, 'to_dict'):
                props['AcceleratorCount'] = self.accelerator_count.to_dict()
            elif isinstance(self.accelerator_count, list):
                props['AcceleratorCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_count
                ]
            else:
                props['AcceleratorCount'] = self.accelerator_count

        if self.baseline_performance_factors is not None:
            if hasattr(self.baseline_performance_factors, 'to_dict'):
                props['BaselinePerformanceFactors'] = self.baseline_performance_factors.to_dict()
            elif isinstance(self.baseline_performance_factors, list):
                props['BaselinePerformanceFactors'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baseline_performance_factors
                ]
            else:
                props['BaselinePerformanceFactors'] = self.baseline_performance_factors

        if self.spot_max_price_percentage_over_lowest_price is not None:
            if hasattr(self.spot_max_price_percentage_over_lowest_price, 'to_dict'):
                props['SpotMaxPricePercentageOverLowestPrice'] = self.spot_max_price_percentage_over_lowest_price.to_dict()
            elif isinstance(self.spot_max_price_percentage_over_lowest_price, list):
                props['SpotMaxPricePercentageOverLowestPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_max_price_percentage_over_lowest_price
                ]
            else:
                props['SpotMaxPricePercentageOverLowestPrice'] = self.spot_max_price_percentage_over_lowest_price

        if self.baseline_ebs_bandwidth_mbps is not None:
            if hasattr(self.baseline_ebs_bandwidth_mbps, 'to_dict'):
                props['BaselineEbsBandwidthMbps'] = self.baseline_ebs_bandwidth_mbps.to_dict()
            elif isinstance(self.baseline_ebs_bandwidth_mbps, list):
                props['BaselineEbsBandwidthMbps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baseline_ebs_bandwidth_mbps
                ]
            else:
                props['BaselineEbsBandwidthMbps'] = self.baseline_ebs_bandwidth_mbps

        if self.accelerator_names is not None:
            if hasattr(self.accelerator_names, 'to_dict'):
                props['AcceleratorNames'] = self.accelerator_names.to_dict()
            elif isinstance(self.accelerator_names, list):
                props['AcceleratorNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_names
                ]
            else:
                props['AcceleratorNames'] = self.accelerator_names

        if self.accelerator_total_memory_mi_b is not None:
            if hasattr(self.accelerator_total_memory_mi_b, 'to_dict'):
                props['AcceleratorTotalMemoryMiB'] = self.accelerator_total_memory_mi_b.to_dict()
            elif isinstance(self.accelerator_total_memory_mi_b, list):
                props['AcceleratorTotalMemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_total_memory_mi_b
                ]
            else:
                props['AcceleratorTotalMemoryMiB'] = self.accelerator_total_memory_mi_b

        if self.burstable_performance is not None:
            if hasattr(self.burstable_performance, 'to_dict'):
                props['BurstablePerformance'] = self.burstable_performance.to_dict()
            elif isinstance(self.burstable_performance, list):
                props['BurstablePerformance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.burstable_performance
                ]
            else:
                props['BurstablePerformance'] = self.burstable_performance

        if self.total_local_storage_gb is not None:
            if hasattr(self.total_local_storage_gb, 'to_dict'):
                props['TotalLocalStorageGB'] = self.total_local_storage_gb.to_dict()
            elif isinstance(self.total_local_storage_gb, list):
                props['TotalLocalStorageGB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_local_storage_gb
                ]
            else:
                props['TotalLocalStorageGB'] = self.total_local_storage_gb

        return props


@dataclass
class LaunchTemplateConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_specification: Optional[FleetLaunchTemplateSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    overrides: Optional[list[LaunchTemplateOverrides]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.launch_template_specification is not None:
            if hasattr(self.launch_template_specification, 'to_dict'):
                props['LaunchTemplateSpecification'] = self.launch_template_specification.to_dict()
            elif isinstance(self.launch_template_specification, list):
                props['LaunchTemplateSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_specification
                ]
            else:
                props['LaunchTemplateSpecification'] = self.launch_template_specification

        if self.overrides is not None:
            if hasattr(self.overrides, 'to_dict'):
                props['Overrides'] = self.overrides.to_dict()
            elif isinstance(self.overrides, list):
                props['Overrides'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.overrides
                ]
            else:
                props['Overrides'] = self.overrides

        return props


@dataclass
class LaunchTemplateOverrides:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    weighted_capacity: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    priority: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_requirements: Optional[InstanceRequirementsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.spot_price is not None:
            if hasattr(self.spot_price, 'to_dict'):
                props['SpotPrice'] = self.spot_price.to_dict()
            elif isinstance(self.spot_price, list):
                props['SpotPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_price
                ]
            else:
                props['SpotPrice'] = self.spot_price

        if self.weighted_capacity is not None:
            if hasattr(self.weighted_capacity, 'to_dict'):
                props['WeightedCapacity'] = self.weighted_capacity.to_dict()
            elif isinstance(self.weighted_capacity, list):
                props['WeightedCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weighted_capacity
                ]
            else:
                props['WeightedCapacity'] = self.weighted_capacity

        if self.priority is not None:
            if hasattr(self.priority, 'to_dict'):
                props['Priority'] = self.priority.to_dict()
            elif isinstance(self.priority, list):
                props['Priority'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.priority
                ]
            else:
                props['Priority'] = self.priority

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        if self.subnet_id is not None:
            if hasattr(self.subnet_id, 'to_dict'):
                props['SubnetId'] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props['SubnetId'] = self.subnet_id

        if self.instance_requirements is not None:
            if hasattr(self.instance_requirements, 'to_dict'):
                props['InstanceRequirements'] = self.instance_requirements.to_dict()
            elif isinstance(self.instance_requirements, list):
                props['InstanceRequirements'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_requirements
                ]
            else:
                props['InstanceRequirements'] = self.instance_requirements

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        return props


@dataclass
class LoadBalancersConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    classic_load_balancers_config: Optional[ClassicLoadBalancersConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_groups_config: Optional[TargetGroupsConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.classic_load_balancers_config is not None:
            if hasattr(self.classic_load_balancers_config, 'to_dict'):
                props['ClassicLoadBalancersConfig'] = self.classic_load_balancers_config.to_dict()
            elif isinstance(self.classic_load_balancers_config, list):
                props['ClassicLoadBalancersConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.classic_load_balancers_config
                ]
            else:
                props['ClassicLoadBalancersConfig'] = self.classic_load_balancers_config

        if self.target_groups_config is not None:
            if hasattr(self.target_groups_config, 'to_dict'):
                props['TargetGroupsConfig'] = self.target_groups_config.to_dict()
            elif isinstance(self.target_groups_config, list):
                props['TargetGroupsConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_groups_config
                ]
            else:
                props['TargetGroupsConfig'] = self.target_groups_config

        return props


@dataclass
class MemoryGiBPerVCpuRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class MemoryMiBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class NetworkBandwidthGbpsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class NetworkInterfaceCountRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class PerformanceFactorReferenceRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_family: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_family is not None:
            if hasattr(self.instance_family, 'to_dict'):
                props['InstanceFamily'] = self.instance_family.to_dict()
            elif isinstance(self.instance_family, list):
                props['InstanceFamily'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_family
                ]
            else:
                props['InstanceFamily'] = self.instance_family

        return props


@dataclass
class PrivateIpAddressSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    primary: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.private_ip_address is not None:
            if hasattr(self.private_ip_address, 'to_dict'):
                props['PrivateIpAddress'] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props['PrivateIpAddress'] = self.private_ip_address

        if self.primary is not None:
            if hasattr(self.primary, 'to_dict'):
                props['Primary'] = self.primary.to_dict()
            elif isinstance(self.primary, list):
                props['Primary'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.primary
                ]
            else:
                props['Primary'] = self.primary

        return props


@dataclass
class SpotCapacityRebalance:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    termination_delay: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    replacement_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.termination_delay is not None:
            if hasattr(self.termination_delay, 'to_dict'):
                props['TerminationDelay'] = self.termination_delay.to_dict()
            elif isinstance(self.termination_delay, list):
                props['TerminationDelay'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.termination_delay
                ]
            else:
                props['TerminationDelay'] = self.termination_delay

        if self.replacement_strategy is not None:
            if hasattr(self.replacement_strategy, 'to_dict'):
                props['ReplacementStrategy'] = self.replacement_strategy.to_dict()
            elif isinstance(self.replacement_strategy, list):
                props['ReplacementStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.replacement_strategy
                ]
            else:
                props['ReplacementStrategy'] = self.replacement_strategy

        return props


@dataclass
class SpotFleetLaunchSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_groups: Optional[list[GroupIdentifier]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_specifications: Optional[list[SpotFleetTagSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    block_device_mappings: Optional[list[BlockDeviceMapping]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iam_instance_profile: Optional[IamInstanceProfileSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kernel_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs_optimized: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ramdisk_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    weighted_capacity: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    placement: Optional[SpotPlacement] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interfaces: Optional[list[InstanceNetworkInterfaceSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_requirements: Optional[InstanceRequirementsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring: Optional[SpotFleetMonitoring] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.security_groups is not None:
            if hasattr(self.security_groups, 'to_dict'):
                props['SecurityGroups'] = self.security_groups.to_dict()
            elif isinstance(self.security_groups, list):
                props['SecurityGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_groups
                ]
            else:
                props['SecurityGroups'] = self.security_groups

        if self.tag_specifications is not None:
            if hasattr(self.tag_specifications, 'to_dict'):
                props['TagSpecifications'] = self.tag_specifications.to_dict()
            elif isinstance(self.tag_specifications, list):
                props['TagSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_specifications
                ]
            else:
                props['TagSpecifications'] = self.tag_specifications

        if self.user_data is not None:
            if hasattr(self.user_data, 'to_dict'):
                props['UserData'] = self.user_data.to_dict()
            elif isinstance(self.user_data, list):
                props['UserData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_data
                ]
            else:
                props['UserData'] = self.user_data

        if self.block_device_mappings is not None:
            if hasattr(self.block_device_mappings, 'to_dict'):
                props['BlockDeviceMappings'] = self.block_device_mappings.to_dict()
            elif isinstance(self.block_device_mappings, list):
                props['BlockDeviceMappings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.block_device_mappings
                ]
            else:
                props['BlockDeviceMappings'] = self.block_device_mappings

        if self.iam_instance_profile is not None:
            if hasattr(self.iam_instance_profile, 'to_dict'):
                props['IamInstanceProfile'] = self.iam_instance_profile.to_dict()
            elif isinstance(self.iam_instance_profile, list):
                props['IamInstanceProfile'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iam_instance_profile
                ]
            else:
                props['IamInstanceProfile'] = self.iam_instance_profile

        if self.kernel_id is not None:
            if hasattr(self.kernel_id, 'to_dict'):
                props['KernelId'] = self.kernel_id.to_dict()
            elif isinstance(self.kernel_id, list):
                props['KernelId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kernel_id
                ]
            else:
                props['KernelId'] = self.kernel_id

        if self.subnet_id is not None:
            if hasattr(self.subnet_id, 'to_dict'):
                props['SubnetId'] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props['SubnetId'] = self.subnet_id

        if self.ebs_optimized is not None:
            if hasattr(self.ebs_optimized, 'to_dict'):
                props['EbsOptimized'] = self.ebs_optimized.to_dict()
            elif isinstance(self.ebs_optimized, list):
                props['EbsOptimized'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_optimized
                ]
            else:
                props['EbsOptimized'] = self.ebs_optimized

        if self.key_name is not None:
            if hasattr(self.key_name, 'to_dict'):
                props['KeyName'] = self.key_name.to_dict()
            elif isinstance(self.key_name, list):
                props['KeyName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_name
                ]
            else:
                props['KeyName'] = self.key_name

        if self.ramdisk_id is not None:
            if hasattr(self.ramdisk_id, 'to_dict'):
                props['RamdiskId'] = self.ramdisk_id.to_dict()
            elif isinstance(self.ramdisk_id, list):
                props['RamdiskId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ramdisk_id
                ]
            else:
                props['RamdiskId'] = self.ramdisk_id

        if self.spot_price is not None:
            if hasattr(self.spot_price, 'to_dict'):
                props['SpotPrice'] = self.spot_price.to_dict()
            elif isinstance(self.spot_price, list):
                props['SpotPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_price
                ]
            else:
                props['SpotPrice'] = self.spot_price

        if self.weighted_capacity is not None:
            if hasattr(self.weighted_capacity, 'to_dict'):
                props['WeightedCapacity'] = self.weighted_capacity.to_dict()
            elif isinstance(self.weighted_capacity, list):
                props['WeightedCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weighted_capacity
                ]
            else:
                props['WeightedCapacity'] = self.weighted_capacity

        if self.placement is not None:
            if hasattr(self.placement, 'to_dict'):
                props['Placement'] = self.placement.to_dict()
            elif isinstance(self.placement, list):
                props['Placement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.placement
                ]
            else:
                props['Placement'] = self.placement

        if self.network_interfaces is not None:
            if hasattr(self.network_interfaces, 'to_dict'):
                props['NetworkInterfaces'] = self.network_interfaces.to_dict()
            elif isinstance(self.network_interfaces, list):
                props['NetworkInterfaces'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interfaces
                ]
            else:
                props['NetworkInterfaces'] = self.network_interfaces

        if self.image_id is not None:
            if hasattr(self.image_id, 'to_dict'):
                props['ImageId'] = self.image_id.to_dict()
            elif isinstance(self.image_id, list):
                props['ImageId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_id
                ]
            else:
                props['ImageId'] = self.image_id

        if self.instance_requirements is not None:
            if hasattr(self.instance_requirements, 'to_dict'):
                props['InstanceRequirements'] = self.instance_requirements.to_dict()
            elif isinstance(self.instance_requirements, list):
                props['InstanceRequirements'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_requirements
                ]
            else:
                props['InstanceRequirements'] = self.instance_requirements

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        if self.monitoring is not None:
            if hasattr(self.monitoring, 'to_dict'):
                props['Monitoring'] = self.monitoring.to_dict()
            elif isinstance(self.monitoring, list):
                props['Monitoring'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring
                ]
            else:
                props['Monitoring'] = self.monitoring

        return props


@dataclass
class SpotFleetMonitoring:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class SpotFleetRequestConfigData:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    context: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_max_total_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    excess_capacity_termination_policy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_specifications: Optional[list[SpotFleetTagSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_pools_to_use_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_configs: Optional[list[LaunchTemplateConfig]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_capacity_unit_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iam_fleet_role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_maintenance_strategies: Optional[SpotMaintenanceStrategies] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    terminate_instances_with_expiration: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    valid_until: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_max_total_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_allocation_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allocation_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_target_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_specifications: Optional[list[SpotFleetLaunchSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_interruption_behavior: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancers_config: Optional[LoadBalancersConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    valid_from: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    replace_unhealthy_instances: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.context is not None:
            if hasattr(self.context, 'to_dict'):
                props['Context'] = self.context.to_dict()
            elif isinstance(self.context, list):
                props['Context'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.context
                ]
            else:
                props['Context'] = self.context

        if self.spot_max_total_price is not None:
            if hasattr(self.spot_max_total_price, 'to_dict'):
                props['SpotMaxTotalPrice'] = self.spot_max_total_price.to_dict()
            elif isinstance(self.spot_max_total_price, list):
                props['SpotMaxTotalPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_max_total_price
                ]
            else:
                props['SpotMaxTotalPrice'] = self.spot_max_total_price

        if self.excess_capacity_termination_policy is not None:
            if hasattr(self.excess_capacity_termination_policy, 'to_dict'):
                props['ExcessCapacityTerminationPolicy'] = self.excess_capacity_termination_policy.to_dict()
            elif isinstance(self.excess_capacity_termination_policy, list):
                props['ExcessCapacityTerminationPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.excess_capacity_termination_policy
                ]
            else:
                props['ExcessCapacityTerminationPolicy'] = self.excess_capacity_termination_policy

        if self.tag_specifications is not None:
            if hasattr(self.tag_specifications, 'to_dict'):
                props['TagSpecifications'] = self.tag_specifications.to_dict()
            elif isinstance(self.tag_specifications, list):
                props['TagSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_specifications
                ]
            else:
                props['TagSpecifications'] = self.tag_specifications

        if self.instance_pools_to_use_count is not None:
            if hasattr(self.instance_pools_to_use_count, 'to_dict'):
                props['InstancePoolsToUseCount'] = self.instance_pools_to_use_count.to_dict()
            elif isinstance(self.instance_pools_to_use_count, list):
                props['InstancePoolsToUseCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_pools_to_use_count
                ]
            else:
                props['InstancePoolsToUseCount'] = self.instance_pools_to_use_count

        if self.launch_template_configs is not None:
            if hasattr(self.launch_template_configs, 'to_dict'):
                props['LaunchTemplateConfigs'] = self.launch_template_configs.to_dict()
            elif isinstance(self.launch_template_configs, list):
                props['LaunchTemplateConfigs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_configs
                ]
            else:
                props['LaunchTemplateConfigs'] = self.launch_template_configs

        if self.target_capacity_unit_type is not None:
            if hasattr(self.target_capacity_unit_type, 'to_dict'):
                props['TargetCapacityUnitType'] = self.target_capacity_unit_type.to_dict()
            elif isinstance(self.target_capacity_unit_type, list):
                props['TargetCapacityUnitType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_capacity_unit_type
                ]
            else:
                props['TargetCapacityUnitType'] = self.target_capacity_unit_type

        if self.iam_fleet_role is not None:
            if hasattr(self.iam_fleet_role, 'to_dict'):
                props['IamFleetRole'] = self.iam_fleet_role.to_dict()
            elif isinstance(self.iam_fleet_role, list):
                props['IamFleetRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iam_fleet_role
                ]
            else:
                props['IamFleetRole'] = self.iam_fleet_role

        if self.spot_maintenance_strategies is not None:
            if hasattr(self.spot_maintenance_strategies, 'to_dict'):
                props['SpotMaintenanceStrategies'] = self.spot_maintenance_strategies.to_dict()
            elif isinstance(self.spot_maintenance_strategies, list):
                props['SpotMaintenanceStrategies'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_maintenance_strategies
                ]
            else:
                props['SpotMaintenanceStrategies'] = self.spot_maintenance_strategies

        if self.terminate_instances_with_expiration is not None:
            if hasattr(self.terminate_instances_with_expiration, 'to_dict'):
                props['TerminateInstancesWithExpiration'] = self.terminate_instances_with_expiration.to_dict()
            elif isinstance(self.terminate_instances_with_expiration, list):
                props['TerminateInstancesWithExpiration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.terminate_instances_with_expiration
                ]
            else:
                props['TerminateInstancesWithExpiration'] = self.terminate_instances_with_expiration

        if self.valid_until is not None:
            if hasattr(self.valid_until, 'to_dict'):
                props['ValidUntil'] = self.valid_until.to_dict()
            elif isinstance(self.valid_until, list):
                props['ValidUntil'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.valid_until
                ]
            else:
                props['ValidUntil'] = self.valid_until

        if self.on_demand_max_total_price is not None:
            if hasattr(self.on_demand_max_total_price, 'to_dict'):
                props['OnDemandMaxTotalPrice'] = self.on_demand_max_total_price.to_dict()
            elif isinstance(self.on_demand_max_total_price, list):
                props['OnDemandMaxTotalPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_max_total_price
                ]
            else:
                props['OnDemandMaxTotalPrice'] = self.on_demand_max_total_price

        if self.on_demand_allocation_strategy is not None:
            if hasattr(self.on_demand_allocation_strategy, 'to_dict'):
                props['OnDemandAllocationStrategy'] = self.on_demand_allocation_strategy.to_dict()
            elif isinstance(self.on_demand_allocation_strategy, list):
                props['OnDemandAllocationStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_allocation_strategy
                ]
            else:
                props['OnDemandAllocationStrategy'] = self.on_demand_allocation_strategy

        if self.spot_price is not None:
            if hasattr(self.spot_price, 'to_dict'):
                props['SpotPrice'] = self.spot_price.to_dict()
            elif isinstance(self.spot_price, list):
                props['SpotPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_price
                ]
            else:
                props['SpotPrice'] = self.spot_price

        if self.allocation_strategy is not None:
            if hasattr(self.allocation_strategy, 'to_dict'):
                props['AllocationStrategy'] = self.allocation_strategy.to_dict()
            elif isinstance(self.allocation_strategy, list):
                props['AllocationStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_strategy
                ]
            else:
                props['AllocationStrategy'] = self.allocation_strategy

        if self.on_demand_target_capacity is not None:
            if hasattr(self.on_demand_target_capacity, 'to_dict'):
                props['OnDemandTargetCapacity'] = self.on_demand_target_capacity.to_dict()
            elif isinstance(self.on_demand_target_capacity, list):
                props['OnDemandTargetCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_target_capacity
                ]
            else:
                props['OnDemandTargetCapacity'] = self.on_demand_target_capacity

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.launch_specifications is not None:
            if hasattr(self.launch_specifications, 'to_dict'):
                props['LaunchSpecifications'] = self.launch_specifications.to_dict()
            elif isinstance(self.launch_specifications, list):
                props['LaunchSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_specifications
                ]
            else:
                props['LaunchSpecifications'] = self.launch_specifications

        if self.instance_interruption_behavior is not None:
            if hasattr(self.instance_interruption_behavior, 'to_dict'):
                props['InstanceInterruptionBehavior'] = self.instance_interruption_behavior.to_dict()
            elif isinstance(self.instance_interruption_behavior, list):
                props['InstanceInterruptionBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_interruption_behavior
                ]
            else:
                props['InstanceInterruptionBehavior'] = self.instance_interruption_behavior

        if self.load_balancers_config is not None:
            if hasattr(self.load_balancers_config, 'to_dict'):
                props['LoadBalancersConfig'] = self.load_balancers_config.to_dict()
            elif isinstance(self.load_balancers_config, list):
                props['LoadBalancersConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancers_config
                ]
            else:
                props['LoadBalancersConfig'] = self.load_balancers_config

        if self.valid_from is not None:
            if hasattr(self.valid_from, 'to_dict'):
                props['ValidFrom'] = self.valid_from.to_dict()
            elif isinstance(self.valid_from, list):
                props['ValidFrom'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.valid_from
                ]
            else:
                props['ValidFrom'] = self.valid_from

        if self.replace_unhealthy_instances is not None:
            if hasattr(self.replace_unhealthy_instances, 'to_dict'):
                props['ReplaceUnhealthyInstances'] = self.replace_unhealthy_instances.to_dict()
            elif isinstance(self.replace_unhealthy_instances, list):
                props['ReplaceUnhealthyInstances'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.replace_unhealthy_instances
                ]
            else:
                props['ReplaceUnhealthyInstances'] = self.replace_unhealthy_instances

        if self.target_capacity is not None:
            if hasattr(self.target_capacity, 'to_dict'):
                props['TargetCapacity'] = self.target_capacity.to_dict()
            elif isinstance(self.target_capacity, list):
                props['TargetCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_capacity
                ]
            else:
                props['TargetCapacity'] = self.target_capacity

        return props


@dataclass
class SpotFleetTagSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tags: Optional[list[Tag]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        if self.tags is not None:
            if hasattr(self.tags, 'to_dict'):
                props['Tags'] = self.tags.to_dict()
            elif isinstance(self.tags, list):
                props['Tags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tags
                ]
            else:
                props['Tags'] = self.tags

        return props


@dataclass
class SpotMaintenanceStrategies:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_rebalance: Optional[SpotCapacityRebalance] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capacity_rebalance is not None:
            if hasattr(self.capacity_rebalance, 'to_dict'):
                props['CapacityRebalance'] = self.capacity_rebalance.to_dict()
            elif isinstance(self.capacity_rebalance, list):
                props['CapacityRebalance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_rebalance
                ]
            else:
                props['CapacityRebalance'] = self.capacity_rebalance

        return props


@dataclass
class SpotPlacement:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tenancy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.group_name is not None:
            if hasattr(self.group_name, 'to_dict'):
                props['GroupName'] = self.group_name.to_dict()
            elif isinstance(self.group_name, list):
                props['GroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_name
                ]
            else:
                props['GroupName'] = self.group_name

        if self.tenancy is not None:
            if hasattr(self.tenancy, 'to_dict'):
                props['Tenancy'] = self.tenancy.to_dict()
            elif isinstance(self.tenancy, list):
                props['Tenancy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tenancy
                ]
            else:
                props['Tenancy'] = self.tenancy

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        return props


@dataclass
class TargetGroup:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.arn is not None:
            if hasattr(self.arn, 'to_dict'):
                props['Arn'] = self.arn.to_dict()
            elif isinstance(self.arn, list):
                props['Arn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.arn
                ]
            else:
                props['Arn'] = self.arn

        return props


@dataclass
class TargetGroupsConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_groups: Optional[list[TargetGroup]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.target_groups is not None:
            if hasattr(self.target_groups, 'to_dict'):
                props['TargetGroups'] = self.target_groups.to_dict()
            elif isinstance(self.target_groups, list):
                props['TargetGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_groups
                ]
            else:
                props['TargetGroups'] = self.target_groups

        return props


@dataclass
class TotalLocalStorageGBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class VCpuCountRangeRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class SpotFleet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SpotFleet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    spot_fleet_request_config_data: Optional[SpotFleetRequestConfigData] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.spot_fleet_request_config_data is not None:
            # Serialize spot_fleet_request_config_data (handle intrinsic functions)
            if hasattr(self.spot_fleet_request_config_data, 'to_dict'):
                props["SpotFleetRequestConfigData"] = self.spot_fleet_request_config_data.to_dict()
            elif isinstance(self.spot_fleet_request_config_data, list):
                # Serialize list items (may contain intrinsic functions)
                props['SpotFleetRequestConfigData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_fleet_request_config_data
                ]
            else:
                props["SpotFleetRequestConfigData"] = self.spot_fleet_request_config_data

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class BlockPublicAccessStates:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    internet_gateway_block_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.internet_gateway_block_mode is not None:
            if hasattr(self.internet_gateway_block_mode, 'to_dict'):
                props['InternetGatewayBlockMode'] = self.internet_gateway_block_mode.to_dict()
            elif isinstance(self.internet_gateway_block_mode, list):
                props['InternetGatewayBlockMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internet_gateway_block_mode
                ]
            else:
                props['InternetGatewayBlockMode'] = self.internet_gateway_block_mode

        return props


@dataclass
class PrivateDnsNameOptionsOnLaunch:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_resource_name_dns_a_record: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hostname_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_resource_name_dns_aaaa_record: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enable_resource_name_dns_a_record is not None:
            if hasattr(self.enable_resource_name_dns_a_record, 'to_dict'):
                props['EnableResourceNameDnsARecord'] = self.enable_resource_name_dns_a_record.to_dict()
            elif isinstance(self.enable_resource_name_dns_a_record, list):
                props['EnableResourceNameDnsARecord'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_resource_name_dns_a_record
                ]
            else:
                props['EnableResourceNameDnsARecord'] = self.enable_resource_name_dns_a_record

        if self.hostname_type is not None:
            if hasattr(self.hostname_type, 'to_dict'):
                props['HostnameType'] = self.hostname_type.to_dict()
            elif isinstance(self.hostname_type, list):
                props['HostnameType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hostname_type
                ]
            else:
                props['HostnameType'] = self.hostname_type

        if self.enable_resource_name_dns_aaaa_record is not None:
            if hasattr(self.enable_resource_name_dns_aaaa_record, 'to_dict'):
                props['EnableResourceNameDnsAAAARecord'] = self.enable_resource_name_dns_aaaa_record.to_dict()
            elif isinstance(self.enable_resource_name_dns_aaaa_record, list):
                props['EnableResourceNameDnsAAAARecord'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_resource_name_dns_aaaa_record
                ]
            else:
                props['EnableResourceNameDnsAAAARecord'] = self.enable_resource_name_dns_aaaa_record

        return props


@dataclass
class Subnet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::Subnet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    map_public_ip_on_launch: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_dns64: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    outpost_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_lni_at_device_index: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    assign_ipv6_address_on_creation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv4_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_dns_name_options_on_launch: Optional[PrivateDnsNameOptionsOnLaunch] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv4_ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_native: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.map_public_ip_on_launch is not None:
            # Serialize map_public_ip_on_launch (handle intrinsic functions)
            if hasattr(self.map_public_ip_on_launch, 'to_dict'):
                props["MapPublicIpOnLaunch"] = self.map_public_ip_on_launch.to_dict()
            elif isinstance(self.map_public_ip_on_launch, list):
                # Serialize list items (may contain intrinsic functions)
                props['MapPublicIpOnLaunch'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.map_public_ip_on_launch
                ]
            else:
                props["MapPublicIpOnLaunch"] = self.map_public_ip_on_launch

        if self.enable_dns64 is not None:
            # Serialize enable_dns64 (handle intrinsic functions)
            if hasattr(self.enable_dns64, 'to_dict'):
                props["EnableDns64"] = self.enable_dns64.to_dict()
            elif isinstance(self.enable_dns64, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableDns64'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_dns64
                ]
            else:
                props["EnableDns64"] = self.enable_dns64

        if self.availability_zone_id is not None:
            # Serialize availability_zone_id (handle intrinsic functions)
            if hasattr(self.availability_zone_id, 'to_dict'):
                props["AvailabilityZoneId"] = self.availability_zone_id.to_dict()
            elif isinstance(self.availability_zone_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZoneId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone_id
                ]
            else:
                props["AvailabilityZoneId"] = self.availability_zone_id

        if self.outpost_arn is not None:
            # Serialize outpost_arn (handle intrinsic functions)
            if hasattr(self.outpost_arn, 'to_dict'):
                props["OutpostArn"] = self.outpost_arn.to_dict()
            elif isinstance(self.outpost_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutpostArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.outpost_arn
                ]
            else:
                props["OutpostArn"] = self.outpost_arn

        if self.availability_zone is not None:
            # Serialize availability_zone (handle intrinsic functions)
            if hasattr(self.availability_zone, 'to_dict'):
                props["AvailabilityZone"] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props["AvailabilityZone"] = self.availability_zone

        if self.cidr_block is not None:
            # Serialize cidr_block (handle intrinsic functions)
            if hasattr(self.cidr_block, 'to_dict'):
                props["CidrBlock"] = self.cidr_block.to_dict()
            elif isinstance(self.cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_block
                ]
            else:
                props["CidrBlock"] = self.cidr_block

        if self.enable_lni_at_device_index is not None:
            # Serialize enable_lni_at_device_index (handle intrinsic functions)
            if hasattr(self.enable_lni_at_device_index, 'to_dict'):
                props["EnableLniAtDeviceIndex"] = self.enable_lni_at_device_index.to_dict()
            elif isinstance(self.enable_lni_at_device_index, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableLniAtDeviceIndex'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_lni_at_device_index
                ]
            else:
                props["EnableLniAtDeviceIndex"] = self.enable_lni_at_device_index

        if self.ipv6_netmask_length is not None:
            # Serialize ipv6_netmask_length (handle intrinsic functions)
            if hasattr(self.ipv6_netmask_length, 'to_dict'):
                props["Ipv6NetmaskLength"] = self.ipv6_netmask_length.to_dict()
            elif isinstance(self.ipv6_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6NetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_netmask_length
                ]
            else:
                props["Ipv6NetmaskLength"] = self.ipv6_netmask_length

        if self.ipv6_ipam_pool_id is not None:
            # Serialize ipv6_ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipv6_ipam_pool_id, 'to_dict'):
                props["Ipv6IpamPoolId"] = self.ipv6_ipam_pool_id.to_dict()
            elif isinstance(self.ipv6_ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_ipam_pool_id
                ]
            else:
                props["Ipv6IpamPoolId"] = self.ipv6_ipam_pool_id

        if self.assign_ipv6_address_on_creation is not None:
            # Serialize assign_ipv6_address_on_creation (handle intrinsic functions)
            if hasattr(self.assign_ipv6_address_on_creation, 'to_dict'):
                props["AssignIpv6AddressOnCreation"] = self.assign_ipv6_address_on_creation.to_dict()
            elif isinstance(self.assign_ipv6_address_on_creation, list):
                # Serialize list items (may contain intrinsic functions)
                props['AssignIpv6AddressOnCreation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.assign_ipv6_address_on_creation
                ]
            else:
                props["AssignIpv6AddressOnCreation"] = self.assign_ipv6_address_on_creation

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.ipv4_netmask_length is not None:
            # Serialize ipv4_netmask_length (handle intrinsic functions)
            if hasattr(self.ipv4_netmask_length, 'to_dict'):
                props["Ipv4NetmaskLength"] = self.ipv4_netmask_length.to_dict()
            elif isinstance(self.ipv4_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv4NetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_netmask_length
                ]
            else:
                props["Ipv4NetmaskLength"] = self.ipv4_netmask_length

        if self.private_dns_name_options_on_launch is not None:
            # Serialize private_dns_name_options_on_launch (handle intrinsic functions)
            if hasattr(self.private_dns_name_options_on_launch, 'to_dict'):
                props["PrivateDnsNameOptionsOnLaunch"] = self.private_dns_name_options_on_launch.to_dict()
            elif isinstance(self.private_dns_name_options_on_launch, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateDnsNameOptionsOnLaunch'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_dns_name_options_on_launch
                ]
            else:
                props["PrivateDnsNameOptionsOnLaunch"] = self.private_dns_name_options_on_launch

        if self.ipv4_ipam_pool_id is not None:
            # Serialize ipv4_ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipv4_ipam_pool_id, 'to_dict'):
                props["Ipv4IpamPoolId"] = self.ipv4_ipam_pool_id.to_dict()
            elif isinstance(self.ipv4_ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv4IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_ipam_pool_id
                ]
            else:
                props["Ipv4IpamPoolId"] = self.ipv4_ipam_pool_id

        if self.ipv6_native is not None:
            # Serialize ipv6_native (handle intrinsic functions)
            if hasattr(self.ipv6_native, 'to_dict'):
                props["Ipv6Native"] = self.ipv6_native.to_dict()
            elif isinstance(self.ipv6_native, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6Native'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_native
                ]
            else:
                props["Ipv6Native"] = self.ipv6_native

        if self.ipv6_cidr_block is not None:
            # Serialize ipv6_cidr_block (handle intrinsic functions)
            if hasattr(self.ipv6_cidr_block, 'to_dict'):
                props["Ipv6CidrBlock"] = self.ipv6_cidr_block.to_dict()
            elif isinstance(self.ipv6_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_cidr_block
                ]
            else:
                props["Ipv6CidrBlock"] = self.ipv6_cidr_block

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_block_public_access_states__internet_gateway_block_mode(self) -> GetAtt:
        """Get the BlockPublicAccessStates.InternetGatewayBlockMode attribute."""
        return self.get_att("BlockPublicAccessStates.InternetGatewayBlockMode")

    @property
    def attr_vpc_id(self) -> GetAtt:
        """Get the VpcId attribute."""
        return self.get_att("VpcId")

    @property
    def attr_network_acl_association_id(self) -> GetAtt:
        """Get the NetworkAclAssociationId attribute."""
        return self.get_att("NetworkAclAssociationId")

    @property
    def attr_availability_zone_id(self) -> GetAtt:
        """Get the AvailabilityZoneId attribute."""
        return self.get_att("AvailabilityZoneId")

    @property
    def attr_outpost_arn(self) -> GetAtt:
        """Get the OutpostArn attribute."""
        return self.get_att("OutpostArn")

    @property
    def attr_availability_zone(self) -> GetAtt:
        """Get the AvailabilityZone attribute."""
        return self.get_att("AvailabilityZone")

    @property
    def attr_cidr_block(self) -> GetAtt:
        """Get the CidrBlock attribute."""
        return self.get_att("CidrBlock")

    @property
    def attr_subnet_id(self) -> GetAtt:
        """Get the SubnetId attribute."""
        return self.get_att("SubnetId")

    @property
    def attr_block_public_access_states(self) -> GetAtt:
        """Get the BlockPublicAccessStates attribute."""
        return self.get_att("BlockPublicAccessStates")

    @property
    def attr_ipv6_cidr_blocks(self) -> GetAtt:
        """Get the Ipv6CidrBlocks attribute."""
        return self.get_att("Ipv6CidrBlocks")




@dataclass
class SubnetCidrBlock(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SubnetCidrBlock"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_netmask_length is not None:
            # Serialize ipv6_netmask_length (handle intrinsic functions)
            if hasattr(self.ipv6_netmask_length, 'to_dict'):
                props["Ipv6NetmaskLength"] = self.ipv6_netmask_length.to_dict()
            elif isinstance(self.ipv6_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6NetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_netmask_length
                ]
            else:
                props["Ipv6NetmaskLength"] = self.ipv6_netmask_length

        if self.ipv6_ipam_pool_id is not None:
            # Serialize ipv6_ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipv6_ipam_pool_id, 'to_dict'):
                props["Ipv6IpamPoolId"] = self.ipv6_ipam_pool_id.to_dict()
            elif isinstance(self.ipv6_ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_ipam_pool_id
                ]
            else:
                props["Ipv6IpamPoolId"] = self.ipv6_ipam_pool_id

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        if self.ipv6_cidr_block is not None:
            # Serialize ipv6_cidr_block (handle intrinsic functions)
            if hasattr(self.ipv6_cidr_block, 'to_dict'):
                props["Ipv6CidrBlock"] = self.ipv6_cidr_block.to_dict()
            elif isinstance(self.ipv6_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_cidr_block
                ]
            else:
                props["Ipv6CidrBlock"] = self.ipv6_cidr_block

        return props

    @property
    def attr_ipv6_address_attribute(self) -> GetAtt:
        """Get the Ipv6AddressAttribute attribute."""
        return self.get_att("Ipv6AddressAttribute")

    @property
    def attr_ip_source(self) -> GetAtt:
        """Get the IpSource attribute."""
        return self.get_att("IpSource")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class SubnetNetworkAclAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SubnetNetworkAclAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_acl_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.network_acl_id is not None:
            # Serialize network_acl_id (handle intrinsic functions)
            if hasattr(self.network_acl_id, 'to_dict'):
                props["NetworkAclId"] = self.network_acl_id.to_dict()
            elif isinstance(self.network_acl_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkAclId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_acl_id
                ]
            else:
                props["NetworkAclId"] = self.network_acl_id

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        return props

    @property
    def attr_association_id(self) -> GetAtt:
        """Get the AssociationId attribute."""
        return self.get_att("AssociationId")




@dataclass
class SubnetRouteTableAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SubnetRouteTableAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.route_table_id is not None:
            # Serialize route_table_id (handle intrinsic functions)
            if hasattr(self.route_table_id, 'to_dict'):
                props["RouteTableId"] = self.route_table_id.to_dict()
            elif isinstance(self.route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_id
                ]
            else:
                props["RouteTableId"] = self.route_table_id

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class TrafficMirrorFilter(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TrafficMirrorFilter"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_services: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.network_services is not None:
            # Serialize network_services (handle intrinsic functions)
            if hasattr(self.network_services, 'to_dict'):
                props["NetworkServices"] = self.network_services.to_dict()
            elif isinstance(self.network_services, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkServices'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_services
                ]
            else:
                props["NetworkServices"] = self.network_services

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class TrafficMirrorPortRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.from_port is not None:
            if hasattr(self.from_port, 'to_dict'):
                props['FromPort'] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props['FromPort'] = self.from_port

        if self.to_port is not None:
            if hasattr(self.to_port, 'to_dict'):
                props['ToPort'] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props['ToPort'] = self.to_port

        return props


@dataclass
class TrafficMirrorFilterRule(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TrafficMirrorFilterRule"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_port_range: Optional[TrafficMirrorPortRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_port_range: Optional[TrafficMirrorPortRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rule_action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rule_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    traffic_mirror_filter_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    traffic_direction: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    protocol: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination_port_range is not None:
            # Serialize destination_port_range (handle intrinsic functions)
            if hasattr(self.destination_port_range, 'to_dict'):
                props["DestinationPortRange"] = self.destination_port_range.to_dict()
            elif isinstance(self.destination_port_range, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationPortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_port_range
                ]
            else:
                props["DestinationPortRange"] = self.destination_port_range

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.source_port_range is not None:
            # Serialize source_port_range (handle intrinsic functions)
            if hasattr(self.source_port_range, 'to_dict'):
                props["SourcePortRange"] = self.source_port_range.to_dict()
            elif isinstance(self.source_port_range, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourcePortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_port_range
                ]
            else:
                props["SourcePortRange"] = self.source_port_range

        if self.rule_action is not None:
            # Serialize rule_action (handle intrinsic functions)
            if hasattr(self.rule_action, 'to_dict'):
                props["RuleAction"] = self.rule_action.to_dict()
            elif isinstance(self.rule_action, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuleAction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_action
                ]
            else:
                props["RuleAction"] = self.rule_action

        if self.source_cidr_block is not None:
            # Serialize source_cidr_block (handle intrinsic functions)
            if hasattr(self.source_cidr_block, 'to_dict'):
                props["SourceCidrBlock"] = self.source_cidr_block.to_dict()
            elif isinstance(self.source_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_cidr_block
                ]
            else:
                props["SourceCidrBlock"] = self.source_cidr_block

        if self.rule_number is not None:
            # Serialize rule_number (handle intrinsic functions)
            if hasattr(self.rule_number, 'to_dict'):
                props["RuleNumber"] = self.rule_number.to_dict()
            elif isinstance(self.rule_number, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuleNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_number
                ]
            else:
                props["RuleNumber"] = self.rule_number

        if self.destination_cidr_block is not None:
            # Serialize destination_cidr_block (handle intrinsic functions)
            if hasattr(self.destination_cidr_block, 'to_dict'):
                props["DestinationCidrBlock"] = self.destination_cidr_block.to_dict()
            elif isinstance(self.destination_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr_block
                ]
            else:
                props["DestinationCidrBlock"] = self.destination_cidr_block

        if self.traffic_mirror_filter_id is not None:
            # Serialize traffic_mirror_filter_id (handle intrinsic functions)
            if hasattr(self.traffic_mirror_filter_id, 'to_dict'):
                props["TrafficMirrorFilterId"] = self.traffic_mirror_filter_id.to_dict()
            elif isinstance(self.traffic_mirror_filter_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TrafficMirrorFilterId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.traffic_mirror_filter_id
                ]
            else:
                props["TrafficMirrorFilterId"] = self.traffic_mirror_filter_id

        if self.traffic_direction is not None:
            # Serialize traffic_direction (handle intrinsic functions)
            if hasattr(self.traffic_direction, 'to_dict'):
                props["TrafficDirection"] = self.traffic_direction.to_dict()
            elif isinstance(self.traffic_direction, list):
                # Serialize list items (may contain intrinsic functions)
                props['TrafficDirection'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.traffic_direction
                ]
            else:
                props["TrafficDirection"] = self.traffic_direction

        if self.protocol is not None:
            # Serialize protocol (handle intrinsic functions)
            if hasattr(self.protocol, 'to_dict'):
                props["Protocol"] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                # Serialize list items (may contain intrinsic functions)
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props["Protocol"] = self.protocol

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_traffic_mirror_filter_rule_id(self) -> GetAtt:
        """Get the TrafficMirrorFilterRuleId attribute."""
        return self.get_att("TrafficMirrorFilterRuleId")




@dataclass
class TrafficMirrorSession(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TrafficMirrorSession"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    traffic_mirror_target_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    owner_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    session_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    virtual_network_id: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    packet_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    traffic_mirror_filter_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.traffic_mirror_target_id is not None:
            # Serialize traffic_mirror_target_id (handle intrinsic functions)
            if hasattr(self.traffic_mirror_target_id, 'to_dict'):
                props["TrafficMirrorTargetId"] = self.traffic_mirror_target_id.to_dict()
            elif isinstance(self.traffic_mirror_target_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TrafficMirrorTargetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.traffic_mirror_target_id
                ]
            else:
                props["TrafficMirrorTargetId"] = self.traffic_mirror_target_id

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.owner_id is not None:
            # Serialize owner_id (handle intrinsic functions)
            if hasattr(self.owner_id, 'to_dict'):
                props["OwnerId"] = self.owner_id.to_dict()
            elif isinstance(self.owner_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['OwnerId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.owner_id
                ]
            else:
                props["OwnerId"] = self.owner_id

        if self.session_number is not None:
            # Serialize session_number (handle intrinsic functions)
            if hasattr(self.session_number, 'to_dict'):
                props["SessionNumber"] = self.session_number.to_dict()
            elif isinstance(self.session_number, list):
                # Serialize list items (may contain intrinsic functions)
                props['SessionNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.session_number
                ]
            else:
                props["SessionNumber"] = self.session_number

        if self.virtual_network_id is not None:
            # Serialize virtual_network_id (handle intrinsic functions)
            if hasattr(self.virtual_network_id, 'to_dict'):
                props["VirtualNetworkId"] = self.virtual_network_id.to_dict()
            elif isinstance(self.virtual_network_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VirtualNetworkId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.virtual_network_id
                ]
            else:
                props["VirtualNetworkId"] = self.virtual_network_id

        if self.packet_length is not None:
            # Serialize packet_length (handle intrinsic functions)
            if hasattr(self.packet_length, 'to_dict'):
                props["PacketLength"] = self.packet_length.to_dict()
            elif isinstance(self.packet_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['PacketLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.packet_length
                ]
            else:
                props["PacketLength"] = self.packet_length

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        if self.traffic_mirror_filter_id is not None:
            # Serialize traffic_mirror_filter_id (handle intrinsic functions)
            if hasattr(self.traffic_mirror_filter_id, 'to_dict'):
                props["TrafficMirrorFilterId"] = self.traffic_mirror_filter_id.to_dict()
            elif isinstance(self.traffic_mirror_filter_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TrafficMirrorFilterId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.traffic_mirror_filter_id
                ]
            else:
                props["TrafficMirrorFilterId"] = self.traffic_mirror_filter_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class TrafficMirrorTarget(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TrafficMirrorTarget"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_load_balancer_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    gateway_load_balancer_endpoint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.network_load_balancer_arn is not None:
            # Serialize network_load_balancer_arn (handle intrinsic functions)
            if hasattr(self.network_load_balancer_arn, 'to_dict'):
                props["NetworkLoadBalancerArn"] = self.network_load_balancer_arn.to_dict()
            elif isinstance(self.network_load_balancer_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkLoadBalancerArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_load_balancer_arn
                ]
            else:
                props["NetworkLoadBalancerArn"] = self.network_load_balancer_arn

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        if self.gateway_load_balancer_endpoint_id is not None:
            # Serialize gateway_load_balancer_endpoint_id (handle intrinsic functions)
            if hasattr(self.gateway_load_balancer_endpoint_id, 'to_dict'):
                props["GatewayLoadBalancerEndpointId"] = self.gateway_load_balancer_endpoint_id.to_dict()
            elif isinstance(self.gateway_load_balancer_endpoint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['GatewayLoadBalancerEndpointId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gateway_load_balancer_endpoint_id
                ]
            else:
                props["GatewayLoadBalancerEndpointId"] = self.gateway_load_balancer_endpoint_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class TransitGateway(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGateway"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    association_default_route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_accept_shared_attachments: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_route_table_propagation: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_cidr_blocks: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    propagation_default_route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_route_table_association: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpn_ecmp_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_referencing_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    dns_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    multicast_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    amazon_side_asn: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    encryption_support: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.association_default_route_table_id is not None:
            # Serialize association_default_route_table_id (handle intrinsic functions)
            if hasattr(self.association_default_route_table_id, 'to_dict'):
                props["AssociationDefaultRouteTableId"] = self.association_default_route_table_id.to_dict()
            elif isinstance(self.association_default_route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AssociationDefaultRouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.association_default_route_table_id
                ]
            else:
                props["AssociationDefaultRouteTableId"] = self.association_default_route_table_id

        if self.auto_accept_shared_attachments is not None:
            # Serialize auto_accept_shared_attachments (handle intrinsic functions)
            if hasattr(self.auto_accept_shared_attachments, 'to_dict'):
                props["AutoAcceptSharedAttachments"] = self.auto_accept_shared_attachments.to_dict()
            elif isinstance(self.auto_accept_shared_attachments, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoAcceptSharedAttachments'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_accept_shared_attachments
                ]
            else:
                props["AutoAcceptSharedAttachments"] = self.auto_accept_shared_attachments

        if self.default_route_table_propagation is not None:
            # Serialize default_route_table_propagation (handle intrinsic functions)
            if hasattr(self.default_route_table_propagation, 'to_dict'):
                props["DefaultRouteTablePropagation"] = self.default_route_table_propagation.to_dict()
            elif isinstance(self.default_route_table_propagation, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultRouteTablePropagation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_route_table_propagation
                ]
            else:
                props["DefaultRouteTablePropagation"] = self.default_route_table_propagation

        if self.transit_gateway_cidr_blocks is not None:
            # Serialize transit_gateway_cidr_blocks (handle intrinsic functions)
            if hasattr(self.transit_gateway_cidr_blocks, 'to_dict'):
                props["TransitGatewayCidrBlocks"] = self.transit_gateway_cidr_blocks.to_dict()
            elif isinstance(self.transit_gateway_cidr_blocks, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayCidrBlocks'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_cidr_blocks
                ]
            else:
                props["TransitGatewayCidrBlocks"] = self.transit_gateway_cidr_blocks

        if self.propagation_default_route_table_id is not None:
            # Serialize propagation_default_route_table_id (handle intrinsic functions)
            if hasattr(self.propagation_default_route_table_id, 'to_dict'):
                props["PropagationDefaultRouteTableId"] = self.propagation_default_route_table_id.to_dict()
            elif isinstance(self.propagation_default_route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['PropagationDefaultRouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.propagation_default_route_table_id
                ]
            else:
                props["PropagationDefaultRouteTableId"] = self.propagation_default_route_table_id

        if self.default_route_table_association is not None:
            # Serialize default_route_table_association (handle intrinsic functions)
            if hasattr(self.default_route_table_association, 'to_dict'):
                props["DefaultRouteTableAssociation"] = self.default_route_table_association.to_dict()
            elif isinstance(self.default_route_table_association, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultRouteTableAssociation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_route_table_association
                ]
            else:
                props["DefaultRouteTableAssociation"] = self.default_route_table_association

        if self.vpn_ecmp_support is not None:
            # Serialize vpn_ecmp_support (handle intrinsic functions)
            if hasattr(self.vpn_ecmp_support, 'to_dict'):
                props["VpnEcmpSupport"] = self.vpn_ecmp_support.to_dict()
            elif isinstance(self.vpn_ecmp_support, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpnEcmpSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_ecmp_support
                ]
            else:
                props["VpnEcmpSupport"] = self.vpn_ecmp_support

        if self.security_group_referencing_support is not None:
            # Serialize security_group_referencing_support (handle intrinsic functions)
            if hasattr(self.security_group_referencing_support, 'to_dict'):
                props["SecurityGroupReferencingSupport"] = self.security_group_referencing_support.to_dict()
            elif isinstance(self.security_group_referencing_support, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupReferencingSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_referencing_support
                ]
            else:
                props["SecurityGroupReferencingSupport"] = self.security_group_referencing_support

        if self.dns_support is not None:
            # Serialize dns_support (handle intrinsic functions)
            if hasattr(self.dns_support, 'to_dict'):
                props["DnsSupport"] = self.dns_support.to_dict()
            elif isinstance(self.dns_support, list):
                # Serialize list items (may contain intrinsic functions)
                props['DnsSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dns_support
                ]
            else:
                props["DnsSupport"] = self.dns_support

        if self.multicast_support is not None:
            # Serialize multicast_support (handle intrinsic functions)
            if hasattr(self.multicast_support, 'to_dict'):
                props["MulticastSupport"] = self.multicast_support.to_dict()
            elif isinstance(self.multicast_support, list):
                # Serialize list items (may contain intrinsic functions)
                props['MulticastSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.multicast_support
                ]
            else:
                props["MulticastSupport"] = self.multicast_support

        if self.amazon_side_asn is not None:
            # Serialize amazon_side_asn (handle intrinsic functions)
            if hasattr(self.amazon_side_asn, 'to_dict'):
                props["AmazonSideAsn"] = self.amazon_side_asn.to_dict()
            elif isinstance(self.amazon_side_asn, list):
                # Serialize list items (may contain intrinsic functions)
                props['AmazonSideAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.amazon_side_asn
                ]
            else:
                props["AmazonSideAsn"] = self.amazon_side_asn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.encryption_support is not None:
            # Serialize encryption_support (handle intrinsic functions)
            if hasattr(self.encryption_support, 'to_dict'):
                props["EncryptionSupport"] = self.encryption_support.to_dict()
            elif isinstance(self.encryption_support, list):
                # Serialize list items (may contain intrinsic functions)
                props['EncryptionSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encryption_support
                ]
            else:
                props["EncryptionSupport"] = self.encryption_support

        return props

    @property
    def attr_encryption_support_state(self) -> GetAtt:
        """Get the EncryptionSupportState attribute."""
        return self.get_att("EncryptionSupportState")

    @property
    def attr_transit_gateway_arn(self) -> GetAtt:
        """Get the TransitGatewayArn attribute."""
        return self.get_att("TransitGatewayArn")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class Options:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    appliance_mode_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_referencing_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dns_support: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_support is not None:
            if hasattr(self.ipv6_support, 'to_dict'):
                props['Ipv6Support'] = self.ipv6_support.to_dict()
            elif isinstance(self.ipv6_support, list):
                props['Ipv6Support'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_support
                ]
            else:
                props['Ipv6Support'] = self.ipv6_support

        if self.appliance_mode_support is not None:
            if hasattr(self.appliance_mode_support, 'to_dict'):
                props['ApplianceModeSupport'] = self.appliance_mode_support.to_dict()
            elif isinstance(self.appliance_mode_support, list):
                props['ApplianceModeSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.appliance_mode_support
                ]
            else:
                props['ApplianceModeSupport'] = self.appliance_mode_support

        if self.security_group_referencing_support is not None:
            if hasattr(self.security_group_referencing_support, 'to_dict'):
                props['SecurityGroupReferencingSupport'] = self.security_group_referencing_support.to_dict()
            elif isinstance(self.security_group_referencing_support, list):
                props['SecurityGroupReferencingSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_referencing_support
                ]
            else:
                props['SecurityGroupReferencingSupport'] = self.security_group_referencing_support

        if self.dns_support is not None:
            if hasattr(self.dns_support, 'to_dict'):
                props['DnsSupport'] = self.dns_support.to_dict()
            elif isinstance(self.dns_support, list):
                props['DnsSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dns_support
                ]
            else:
                props['DnsSupport'] = self.dns_support

        return props


@dataclass
class TransitGatewayAttachment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayAttachment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    options: Optional[Options] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.options is not None:
            # Serialize options (handle intrinsic functions)
            if hasattr(self.options, 'to_dict'):
                props["Options"] = self.options.to_dict()
            elif isinstance(self.options, list):
                # Serialize list items (may contain intrinsic functions)
                props['Options'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.options
                ]
            else:
                props["Options"] = self.options

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.subnet_ids is not None:
            # Serialize subnet_ids (handle intrinsic functions)
            if hasattr(self.subnet_ids, 'to_dict'):
                props["SubnetIds"] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props["SubnetIds"] = self.subnet_ids

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class TransitGatewayConnectOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        return props


@dataclass
class TransitGatewayConnect(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayConnect"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    options: Optional[TransitGatewayConnectOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transport_transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.options is not None:
            # Serialize options (handle intrinsic functions)
            if hasattr(self.options, 'to_dict'):
                props["Options"] = self.options.to_dict()
            elif isinstance(self.options, list):
                # Serialize list items (may contain intrinsic functions)
                props['Options'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.options
                ]
            else:
                props["Options"] = self.options

        if self.transport_transit_gateway_attachment_id is not None:
            # Serialize transport_transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.transport_transit_gateway_attachment_id, 'to_dict'):
                props["TransportTransitGatewayAttachmentId"] = self.transport_transit_gateway_attachment_id.to_dict()
            elif isinstance(self.transport_transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransportTransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transport_transit_gateway_attachment_id
                ]
            else:
                props["TransportTransitGatewayAttachmentId"] = self.transport_transit_gateway_attachment_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_transit_gateway_id(self) -> GetAtt:
        """Get the TransitGatewayId attribute."""
        return self.get_att("TransitGatewayId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_transit_gateway_attachment_id(self) -> GetAtt:
        """Get the TransitGatewayAttachmentId attribute."""
        return self.get_att("TransitGatewayAttachmentId")




@dataclass
class TransitGatewayAttachmentBgpConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    peer_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bgp_status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    peer_asn: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway_asn: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_address is not None:
            if hasattr(self.transit_gateway_address, 'to_dict'):
                props['TransitGatewayAddress'] = self.transit_gateway_address.to_dict()
            elif isinstance(self.transit_gateway_address, list):
                props['TransitGatewayAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_address
                ]
            else:
                props['TransitGatewayAddress'] = self.transit_gateway_address

        if self.peer_address is not None:
            if hasattr(self.peer_address, 'to_dict'):
                props['PeerAddress'] = self.peer_address.to_dict()
            elif isinstance(self.peer_address, list):
                props['PeerAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_address
                ]
            else:
                props['PeerAddress'] = self.peer_address

        if self.bgp_status is not None:
            if hasattr(self.bgp_status, 'to_dict'):
                props['BgpStatus'] = self.bgp_status.to_dict()
            elif isinstance(self.bgp_status, list):
                props['BgpStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bgp_status
                ]
            else:
                props['BgpStatus'] = self.bgp_status

        if self.peer_asn is not None:
            if hasattr(self.peer_asn, 'to_dict'):
                props['PeerAsn'] = self.peer_asn.to_dict()
            elif isinstance(self.peer_asn, list):
                props['PeerAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_asn
                ]
            else:
                props['PeerAsn'] = self.peer_asn

        if self.transit_gateway_asn is not None:
            if hasattr(self.transit_gateway_asn, 'to_dict'):
                props['TransitGatewayAsn'] = self.transit_gateway_asn.to_dict()
            elif isinstance(self.transit_gateway_asn, list):
                props['TransitGatewayAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_asn
                ]
            else:
                props['TransitGatewayAsn'] = self.transit_gateway_asn

        return props


@dataclass
class TransitGatewayConnectPeerConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bgp_configurations: Optional[list[TransitGatewayAttachmentBgpConfiguration]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    peer_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inside_cidr_blocks: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_address is not None:
            if hasattr(self.transit_gateway_address, 'to_dict'):
                props['TransitGatewayAddress'] = self.transit_gateway_address.to_dict()
            elif isinstance(self.transit_gateway_address, list):
                props['TransitGatewayAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_address
                ]
            else:
                props['TransitGatewayAddress'] = self.transit_gateway_address

        if self.bgp_configurations is not None:
            if hasattr(self.bgp_configurations, 'to_dict'):
                props['BgpConfigurations'] = self.bgp_configurations.to_dict()
            elif isinstance(self.bgp_configurations, list):
                props['BgpConfigurations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bgp_configurations
                ]
            else:
                props['BgpConfigurations'] = self.bgp_configurations

        if self.peer_address is not None:
            if hasattr(self.peer_address, 'to_dict'):
                props['PeerAddress'] = self.peer_address.to_dict()
            elif isinstance(self.peer_address, list):
                props['PeerAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_address
                ]
            else:
                props['PeerAddress'] = self.peer_address

        if self.inside_cidr_blocks is not None:
            if hasattr(self.inside_cidr_blocks, 'to_dict'):
                props['InsideCidrBlocks'] = self.inside_cidr_blocks.to_dict()
            elif isinstance(self.inside_cidr_blocks, list):
                props['InsideCidrBlocks'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inside_cidr_blocks
                ]
            else:
                props['InsideCidrBlocks'] = self.inside_cidr_blocks

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        return props


@dataclass
class TransitGatewayConnectPeer(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayConnectPeer"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connect_peer_configuration: Optional[TransitGatewayConnectPeerConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.connect_peer_configuration is not None:
            # Serialize connect_peer_configuration (handle intrinsic functions)
            if hasattr(self.connect_peer_configuration, 'to_dict'):
                props["ConnectPeerConfiguration"] = self.connect_peer_configuration.to_dict()
            elif isinstance(self.connect_peer_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConnectPeerConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connect_peer_configuration
                ]
            else:
                props["ConnectPeerConfiguration"] = self.connect_peer_configuration

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.transit_gateway_attachment_id is not None:
            # Serialize transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_attachment_id, 'to_dict'):
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id.to_dict()
            elif isinstance(self.transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_attachment_id
                ]
            else:
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id

        return props

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_transit_gateway_connect_peer_id(self) -> GetAtt:
        """Get the TransitGatewayConnectPeerId attribute."""
        return self.get_att("TransitGatewayConnectPeerId")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_connect_peer_configuration__protocol(self) -> GetAtt:
        """Get the ConnectPeerConfiguration.Protocol attribute."""
        return self.get_att("ConnectPeerConfiguration.Protocol")

    @property
    def attr_connect_peer_configuration__bgp_configurations(self) -> GetAtt:
        """Get the ConnectPeerConfiguration.BgpConfigurations attribute."""
        return self.get_att("ConnectPeerConfiguration.BgpConfigurations")




@dataclass
class TransitGatewayMeteringPolicy(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayMeteringPolicy"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    middlebox_attachment_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        if self.middlebox_attachment_ids is not None:
            # Serialize middlebox_attachment_ids (handle intrinsic functions)
            if hasattr(self.middlebox_attachment_ids, 'to_dict'):
                props["MiddleboxAttachmentIds"] = self.middlebox_attachment_ids.to_dict()
            elif isinstance(self.middlebox_attachment_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['MiddleboxAttachmentIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.middlebox_attachment_ids
                ]
            else:
                props["MiddleboxAttachmentIds"] = self.middlebox_attachment_ids

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_update_effective_at(self) -> GetAtt:
        """Get the UpdateEffectiveAt attribute."""
        return self.get_att("UpdateEffectiveAt")

    @property
    def attr_transit_gateway_metering_policy_id(self) -> GetAtt:
        """Get the TransitGatewayMeteringPolicyId attribute."""
        return self.get_att("TransitGatewayMeteringPolicyId")




@dataclass
class TransitGatewayMeteringPolicyEntry(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayMeteringPolicyEntry"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_port_range: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metered_account: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_port_range: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_rule_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_transit_gateway_attachment_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_metering_policy_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_transit_gateway_attachment_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination_port_range is not None:
            # Serialize destination_port_range (handle intrinsic functions)
            if hasattr(self.destination_port_range, 'to_dict'):
                props["DestinationPortRange"] = self.destination_port_range.to_dict()
            elif isinstance(self.destination_port_range, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationPortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_port_range
                ]
            else:
                props["DestinationPortRange"] = self.destination_port_range

        if self.destination_transit_gateway_attachment_id is not None:
            # Serialize destination_transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.destination_transit_gateway_attachment_id, 'to_dict'):
                props["DestinationTransitGatewayAttachmentId"] = self.destination_transit_gateway_attachment_id.to_dict()
            elif isinstance(self.destination_transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationTransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_transit_gateway_attachment_id
                ]
            else:
                props["DestinationTransitGatewayAttachmentId"] = self.destination_transit_gateway_attachment_id

        if self.metered_account is not None:
            # Serialize metered_account (handle intrinsic functions)
            if hasattr(self.metered_account, 'to_dict'):
                props["MeteredAccount"] = self.metered_account.to_dict()
            elif isinstance(self.metered_account, list):
                # Serialize list items (may contain intrinsic functions)
                props['MeteredAccount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metered_account
                ]
            else:
                props["MeteredAccount"] = self.metered_account

        if self.source_port_range is not None:
            # Serialize source_port_range (handle intrinsic functions)
            if hasattr(self.source_port_range, 'to_dict'):
                props["SourcePortRange"] = self.source_port_range.to_dict()
            elif isinstance(self.source_port_range, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourcePortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_port_range
                ]
            else:
                props["SourcePortRange"] = self.source_port_range

        if self.policy_rule_number is not None:
            # Serialize policy_rule_number (handle intrinsic functions)
            if hasattr(self.policy_rule_number, 'to_dict'):
                props["PolicyRuleNumber"] = self.policy_rule_number.to_dict()
            elif isinstance(self.policy_rule_number, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyRuleNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_rule_number
                ]
            else:
                props["PolicyRuleNumber"] = self.policy_rule_number

        if self.destination_transit_gateway_attachment_type is not None:
            # Serialize destination_transit_gateway_attachment_type (handle intrinsic functions)
            if hasattr(self.destination_transit_gateway_attachment_type, 'to_dict'):
                props["DestinationTransitGatewayAttachmentType"] = self.destination_transit_gateway_attachment_type.to_dict()
            elif isinstance(self.destination_transit_gateway_attachment_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationTransitGatewayAttachmentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_transit_gateway_attachment_type
                ]
            else:
                props["DestinationTransitGatewayAttachmentType"] = self.destination_transit_gateway_attachment_type

        if self.source_cidr_block is not None:
            # Serialize source_cidr_block (handle intrinsic functions)
            if hasattr(self.source_cidr_block, 'to_dict'):
                props["SourceCidrBlock"] = self.source_cidr_block.to_dict()
            elif isinstance(self.source_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_cidr_block
                ]
            else:
                props["SourceCidrBlock"] = self.source_cidr_block

        if self.destination_cidr_block is not None:
            # Serialize destination_cidr_block (handle intrinsic functions)
            if hasattr(self.destination_cidr_block, 'to_dict'):
                props["DestinationCidrBlock"] = self.destination_cidr_block.to_dict()
            elif isinstance(self.destination_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr_block
                ]
            else:
                props["DestinationCidrBlock"] = self.destination_cidr_block

        if self.protocol is not None:
            # Serialize protocol (handle intrinsic functions)
            if hasattr(self.protocol, 'to_dict'):
                props["Protocol"] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                # Serialize list items (may contain intrinsic functions)
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props["Protocol"] = self.protocol

        if self.transit_gateway_metering_policy_id is not None:
            # Serialize transit_gateway_metering_policy_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_metering_policy_id, 'to_dict'):
                props["TransitGatewayMeteringPolicyId"] = self.transit_gateway_metering_policy_id.to_dict()
            elif isinstance(self.transit_gateway_metering_policy_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayMeteringPolicyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_metering_policy_id
                ]
            else:
                props["TransitGatewayMeteringPolicyId"] = self.transit_gateway_metering_policy_id

        if self.source_transit_gateway_attachment_id is not None:
            # Serialize source_transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.source_transit_gateway_attachment_id, 'to_dict'):
                props["SourceTransitGatewayAttachmentId"] = self.source_transit_gateway_attachment_id.to_dict()
            elif isinstance(self.source_transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceTransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_transit_gateway_attachment_id
                ]
            else:
                props["SourceTransitGatewayAttachmentId"] = self.source_transit_gateway_attachment_id

        if self.source_transit_gateway_attachment_type is not None:
            # Serialize source_transit_gateway_attachment_type (handle intrinsic functions)
            if hasattr(self.source_transit_gateway_attachment_type, 'to_dict'):
                props["SourceTransitGatewayAttachmentType"] = self.source_transit_gateway_attachment_type.to_dict()
            elif isinstance(self.source_transit_gateway_attachment_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceTransitGatewayAttachmentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_transit_gateway_attachment_type
                ]
            else:
                props["SourceTransitGatewayAttachmentType"] = self.source_transit_gateway_attachment_type

        return props

    @property
    def attr_update_effective_at(self) -> GetAtt:
        """Get the UpdateEffectiveAt attribute."""
        return self.get_att("UpdateEffectiveAt")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")




@dataclass
class Options:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    static_sources_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auto_accept_shared_associations: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    igmpv2_support: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.static_sources_support is not None:
            if hasattr(self.static_sources_support, 'to_dict'):
                props['StaticSourcesSupport'] = self.static_sources_support.to_dict()
            elif isinstance(self.static_sources_support, list):
                props['StaticSourcesSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.static_sources_support
                ]
            else:
                props['StaticSourcesSupport'] = self.static_sources_support

        if self.auto_accept_shared_associations is not None:
            if hasattr(self.auto_accept_shared_associations, 'to_dict'):
                props['AutoAcceptSharedAssociations'] = self.auto_accept_shared_associations.to_dict()
            elif isinstance(self.auto_accept_shared_associations, list):
                props['AutoAcceptSharedAssociations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_accept_shared_associations
                ]
            else:
                props['AutoAcceptSharedAssociations'] = self.auto_accept_shared_associations

        if self.igmpv2_support is not None:
            if hasattr(self.igmpv2_support, 'to_dict'):
                props['Igmpv2Support'] = self.igmpv2_support.to_dict()
            elif isinstance(self.igmpv2_support, list):
                props['Igmpv2Support'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.igmpv2_support
                ]
            else:
                props['Igmpv2Support'] = self.igmpv2_support

        return props


@dataclass
class TransitGatewayMulticastDomain(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayMulticastDomain"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    options: Optional[Options] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.options is not None:
            # Serialize options (handle intrinsic functions)
            if hasattr(self.options, 'to_dict'):
                props["Options"] = self.options.to_dict()
            elif isinstance(self.options, list):
                # Serialize list items (may contain intrinsic functions)
                props['Options'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.options
                ]
            else:
                props["Options"] = self.options

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_transit_gateway_multicast_domain_arn(self) -> GetAtt:
        """Get the TransitGatewayMulticastDomainArn attribute."""
        return self.get_att("TransitGatewayMulticastDomainArn")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_transit_gateway_multicast_domain_id(self) -> GetAtt:
        """Get the TransitGatewayMulticastDomainId attribute."""
        return self.get_att("TransitGatewayMulticastDomainId")




@dataclass
class TransitGatewayMulticastDomainAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayMulticastDomainAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_multicast_domain_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_multicast_domain_id is not None:
            # Serialize transit_gateway_multicast_domain_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_multicast_domain_id, 'to_dict'):
                props["TransitGatewayMulticastDomainId"] = self.transit_gateway_multicast_domain_id.to_dict()
            elif isinstance(self.transit_gateway_multicast_domain_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayMulticastDomainId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_multicast_domain_id
                ]
            else:
                props["TransitGatewayMulticastDomainId"] = self.transit_gateway_multicast_domain_id

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        if self.transit_gateway_attachment_id is not None:
            # Serialize transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_attachment_id, 'to_dict'):
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id.to_dict()
            elif isinstance(self.transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_attachment_id
                ]
            else:
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id

        return props

    @property
    def attr_resource_id(self) -> GetAtt:
        """Get the ResourceId attribute."""
        return self.get_att("ResourceId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_resource_type(self) -> GetAtt:
        """Get the ResourceType attribute."""
        return self.get_att("ResourceType")




@dataclass
class TransitGatewayMulticastGroupMember(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayMulticastGroupMember"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_multicast_domain_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_multicast_domain_id is not None:
            # Serialize transit_gateway_multicast_domain_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_multicast_domain_id, 'to_dict'):
                props["TransitGatewayMulticastDomainId"] = self.transit_gateway_multicast_domain_id.to_dict()
            elif isinstance(self.transit_gateway_multicast_domain_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayMulticastDomainId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_multicast_domain_id
                ]
            else:
                props["TransitGatewayMulticastDomainId"] = self.transit_gateway_multicast_domain_id

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        if self.group_ip_address is not None:
            # Serialize group_ip_address (handle intrinsic functions)
            if hasattr(self.group_ip_address, 'to_dict'):
                props["GroupIpAddress"] = self.group_ip_address.to_dict()
            elif isinstance(self.group_ip_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_ip_address
                ]
            else:
                props["GroupIpAddress"] = self.group_ip_address

        return props

    @property
    def attr_group_member(self) -> GetAtt:
        """Get the GroupMember attribute."""
        return self.get_att("GroupMember")

    @property
    def attr_resource_id(self) -> GetAtt:
        """Get the ResourceId attribute."""
        return self.get_att("ResourceId")

    @property
    def attr_member_type(self) -> GetAtt:
        """Get the MemberType attribute."""
        return self.get_att("MemberType")

    @property
    def attr_resource_type(self) -> GetAtt:
        """Get the ResourceType attribute."""
        return self.get_att("ResourceType")

    @property
    def attr_subnet_id(self) -> GetAtt:
        """Get the SubnetId attribute."""
        return self.get_att("SubnetId")

    @property
    def attr_group_source(self) -> GetAtt:
        """Get the GroupSource attribute."""
        return self.get_att("GroupSource")

    @property
    def attr_transit_gateway_attachment_id(self) -> GetAtt:
        """Get the TransitGatewayAttachmentId attribute."""
        return self.get_att("TransitGatewayAttachmentId")




@dataclass
class TransitGatewayMulticastGroupSource(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayMulticastGroupSource"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_multicast_domain_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_multicast_domain_id is not None:
            # Serialize transit_gateway_multicast_domain_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_multicast_domain_id, 'to_dict'):
                props["TransitGatewayMulticastDomainId"] = self.transit_gateway_multicast_domain_id.to_dict()
            elif isinstance(self.transit_gateway_multicast_domain_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayMulticastDomainId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_multicast_domain_id
                ]
            else:
                props["TransitGatewayMulticastDomainId"] = self.transit_gateway_multicast_domain_id

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        if self.group_ip_address is not None:
            # Serialize group_ip_address (handle intrinsic functions)
            if hasattr(self.group_ip_address, 'to_dict'):
                props["GroupIpAddress"] = self.group_ip_address.to_dict()
            elif isinstance(self.group_ip_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_ip_address
                ]
            else:
                props["GroupIpAddress"] = self.group_ip_address

        return props

    @property
    def attr_group_member(self) -> GetAtt:
        """Get the GroupMember attribute."""
        return self.get_att("GroupMember")

    @property
    def attr_resource_id(self) -> GetAtt:
        """Get the ResourceId attribute."""
        return self.get_att("ResourceId")

    @property
    def attr_source_type(self) -> GetAtt:
        """Get the SourceType attribute."""
        return self.get_att("SourceType")

    @property
    def attr_resource_type(self) -> GetAtt:
        """Get the ResourceType attribute."""
        return self.get_att("ResourceType")

    @property
    def attr_subnet_id(self) -> GetAtt:
        """Get the SubnetId attribute."""
        return self.get_att("SubnetId")

    @property
    def attr_group_source(self) -> GetAtt:
        """Get the GroupSource attribute."""
        return self.get_att("GroupSource")

    @property
    def attr_transit_gateway_attachment_id(self) -> GetAtt:
        """Get the TransitGatewayAttachmentId attribute."""
        return self.get_att("TransitGatewayAttachmentId")




@dataclass
class PeeringAttachmentStatus:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    message: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    code: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.message is not None:
            if hasattr(self.message, 'to_dict'):
                props['Message'] = self.message.to_dict()
            elif isinstance(self.message, list):
                props['Message'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.message
                ]
            else:
                props['Message'] = self.message

        if self.code is not None:
            if hasattr(self.code, 'to_dict'):
                props['Code'] = self.code.to_dict()
            elif isinstance(self.code, list):
                props['Code'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code
                ]
            else:
                props['Code'] = self.code

        return props


@dataclass
class TransitGatewayPeeringAttachment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayPeeringAttachment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_account_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        if self.peer_transit_gateway_id is not None:
            # Serialize peer_transit_gateway_id (handle intrinsic functions)
            if hasattr(self.peer_transit_gateway_id, 'to_dict'):
                props["PeerTransitGatewayId"] = self.peer_transit_gateway_id.to_dict()
            elif isinstance(self.peer_transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerTransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_transit_gateway_id
                ]
            else:
                props["PeerTransitGatewayId"] = self.peer_transit_gateway_id

        if self.peer_account_id is not None:
            # Serialize peer_account_id (handle intrinsic functions)
            if hasattr(self.peer_account_id, 'to_dict'):
                props["PeerAccountId"] = self.peer_account_id.to_dict()
            elif isinstance(self.peer_account_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerAccountId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_account_id
                ]
            else:
                props["PeerAccountId"] = self.peer_account_id

        if self.peer_region is not None:
            # Serialize peer_region (handle intrinsic functions)
            if hasattr(self.peer_region, 'to_dict'):
                props["PeerRegion"] = self.peer_region.to_dict()
            elif isinstance(self.peer_region, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_region
                ]
            else:
                props["PeerRegion"] = self.peer_region

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_status__message(self) -> GetAtt:
        """Get the Status.Message attribute."""
        return self.get_att("Status.Message")

    @property
    def attr_status__code(self) -> GetAtt:
        """Get the Status.Code attribute."""
        return self.get_att("Status.Code")

    @property
    def attr_transit_gateway_attachment_id(self) -> GetAtt:
        """Get the TransitGatewayAttachmentId attribute."""
        return self.get_att("TransitGatewayAttachmentId")




@dataclass
class TransitGatewayRoute(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayRoute"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    blackhole: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_route_table_id is not None:
            # Serialize transit_gateway_route_table_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_route_table_id, 'to_dict'):
                props["TransitGatewayRouteTableId"] = self.transit_gateway_route_table_id.to_dict()
            elif isinstance(self.transit_gateway_route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayRouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_route_table_id
                ]
            else:
                props["TransitGatewayRouteTableId"] = self.transit_gateway_route_table_id

        if self.destination_cidr_block is not None:
            # Serialize destination_cidr_block (handle intrinsic functions)
            if hasattr(self.destination_cidr_block, 'to_dict'):
                props["DestinationCidrBlock"] = self.destination_cidr_block.to_dict()
            elif isinstance(self.destination_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr_block
                ]
            else:
                props["DestinationCidrBlock"] = self.destination_cidr_block

        if self.blackhole is not None:
            # Serialize blackhole (handle intrinsic functions)
            if hasattr(self.blackhole, 'to_dict'):
                props["Blackhole"] = self.blackhole.to_dict()
            elif isinstance(self.blackhole, list):
                # Serialize list items (may contain intrinsic functions)
                props['Blackhole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.blackhole
                ]
            else:
                props["Blackhole"] = self.blackhole

        if self.transit_gateway_attachment_id is not None:
            # Serialize transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_attachment_id, 'to_dict'):
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id.to_dict()
            elif isinstance(self.transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_attachment_id
                ]
            else:
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id

        return props



@dataclass
class TransitGatewayRouteTable(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayRouteTable"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_transit_gateway_route_table_id(self) -> GetAtt:
        """Get the TransitGatewayRouteTableId attribute."""
        return self.get_att("TransitGatewayRouteTableId")




@dataclass
class TransitGatewayRouteTableAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayRouteTableAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_route_table_id is not None:
            # Serialize transit_gateway_route_table_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_route_table_id, 'to_dict'):
                props["TransitGatewayRouteTableId"] = self.transit_gateway_route_table_id.to_dict()
            elif isinstance(self.transit_gateway_route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayRouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_route_table_id
                ]
            else:
                props["TransitGatewayRouteTableId"] = self.transit_gateway_route_table_id

        if self.transit_gateway_attachment_id is not None:
            # Serialize transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_attachment_id, 'to_dict'):
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id.to_dict()
            elif isinstance(self.transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_attachment_id
                ]
            else:
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id

        return props



@dataclass
class TransitGatewayRouteTablePropagation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayRouteTablePropagation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_route_table_id is not None:
            # Serialize transit_gateway_route_table_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_route_table_id, 'to_dict'):
                props["TransitGatewayRouteTableId"] = self.transit_gateway_route_table_id.to_dict()
            elif isinstance(self.transit_gateway_route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayRouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_route_table_id
                ]
            else:
                props["TransitGatewayRouteTableId"] = self.transit_gateway_route_table_id

        if self.transit_gateway_attachment_id is not None:
            # Serialize transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_attachment_id, 'to_dict'):
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id.to_dict()
            elif isinstance(self.transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_attachment_id
                ]
            else:
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id

        return props



@dataclass
class Options:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    appliance_mode_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_referencing_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dns_support: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_support is not None:
            if hasattr(self.ipv6_support, 'to_dict'):
                props['Ipv6Support'] = self.ipv6_support.to_dict()
            elif isinstance(self.ipv6_support, list):
                props['Ipv6Support'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_support
                ]
            else:
                props['Ipv6Support'] = self.ipv6_support

        if self.appliance_mode_support is not None:
            if hasattr(self.appliance_mode_support, 'to_dict'):
                props['ApplianceModeSupport'] = self.appliance_mode_support.to_dict()
            elif isinstance(self.appliance_mode_support, list):
                props['ApplianceModeSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.appliance_mode_support
                ]
            else:
                props['ApplianceModeSupport'] = self.appliance_mode_support

        if self.security_group_referencing_support is not None:
            if hasattr(self.security_group_referencing_support, 'to_dict'):
                props['SecurityGroupReferencingSupport'] = self.security_group_referencing_support.to_dict()
            elif isinstance(self.security_group_referencing_support, list):
                props['SecurityGroupReferencingSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_referencing_support
                ]
            else:
                props['SecurityGroupReferencingSupport'] = self.security_group_referencing_support

        if self.dns_support is not None:
            if hasattr(self.dns_support, 'to_dict'):
                props['DnsSupport'] = self.dns_support.to_dict()
            elif isinstance(self.dns_support, list):
                props['DnsSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dns_support
                ]
            else:
                props['DnsSupport'] = self.dns_support

        return props


@dataclass
class TransitGatewayVpcAttachment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayVpcAttachment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    options: Optional[Options] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    remove_subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    add_subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.options is not None:
            # Serialize options (handle intrinsic functions)
            if hasattr(self.options, 'to_dict'):
                props["Options"] = self.options.to_dict()
            elif isinstance(self.options, list):
                # Serialize list items (may contain intrinsic functions)
                props['Options'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.options
                ]
            else:
                props["Options"] = self.options

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.remove_subnet_ids is not None:
            # Serialize remove_subnet_ids (handle intrinsic functions)
            if hasattr(self.remove_subnet_ids, 'to_dict'):
                props["RemoveSubnetIds"] = self.remove_subnet_ids.to_dict()
            elif isinstance(self.remove_subnet_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['RemoveSubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.remove_subnet_ids
                ]
            else:
                props["RemoveSubnetIds"] = self.remove_subnet_ids

        if self.subnet_ids is not None:
            # Serialize subnet_ids (handle intrinsic functions)
            if hasattr(self.subnet_ids, 'to_dict'):
                props["SubnetIds"] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props["SubnetIds"] = self.subnet_ids

        if self.add_subnet_ids is not None:
            # Serialize add_subnet_ids (handle intrinsic functions)
            if hasattr(self.add_subnet_ids, 'to_dict'):
                props["AddSubnetIds"] = self.add_subnet_ids.to_dict()
            elif isinstance(self.add_subnet_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['AddSubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.add_subnet_ids
                ]
            else:
                props["AddSubnetIds"] = self.add_subnet_ids

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class VPC(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPC"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_tenancy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv4_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv4_ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_dns_support: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_dns_hostnames: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_tenancy is not None:
            # Serialize instance_tenancy (handle intrinsic functions)
            if hasattr(self.instance_tenancy, 'to_dict'):
                props["InstanceTenancy"] = self.instance_tenancy.to_dict()
            elif isinstance(self.instance_tenancy, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceTenancy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_tenancy
                ]
            else:
                props["InstanceTenancy"] = self.instance_tenancy

        if self.ipv4_netmask_length is not None:
            # Serialize ipv4_netmask_length (handle intrinsic functions)
            if hasattr(self.ipv4_netmask_length, 'to_dict'):
                props["Ipv4NetmaskLength"] = self.ipv4_netmask_length.to_dict()
            elif isinstance(self.ipv4_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv4NetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_netmask_length
                ]
            else:
                props["Ipv4NetmaskLength"] = self.ipv4_netmask_length

        if self.cidr_block is not None:
            # Serialize cidr_block (handle intrinsic functions)
            if hasattr(self.cidr_block, 'to_dict'):
                props["CidrBlock"] = self.cidr_block.to_dict()
            elif isinstance(self.cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_block
                ]
            else:
                props["CidrBlock"] = self.cidr_block

        if self.ipv4_ipam_pool_id is not None:
            # Serialize ipv4_ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipv4_ipam_pool_id, 'to_dict'):
                props["Ipv4IpamPoolId"] = self.ipv4_ipam_pool_id.to_dict()
            elif isinstance(self.ipv4_ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv4IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_ipam_pool_id
                ]
            else:
                props["Ipv4IpamPoolId"] = self.ipv4_ipam_pool_id

        if self.enable_dns_support is not None:
            # Serialize enable_dns_support (handle intrinsic functions)
            if hasattr(self.enable_dns_support, 'to_dict'):
                props["EnableDnsSupport"] = self.enable_dns_support.to_dict()
            elif isinstance(self.enable_dns_support, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableDnsSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_dns_support
                ]
            else:
                props["EnableDnsSupport"] = self.enable_dns_support

        if self.enable_dns_hostnames is not None:
            # Serialize enable_dns_hostnames (handle intrinsic functions)
            if hasattr(self.enable_dns_hostnames, 'to_dict'):
                props["EnableDnsHostnames"] = self.enable_dns_hostnames.to_dict()
            elif isinstance(self.enable_dns_hostnames, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableDnsHostnames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_dns_hostnames
                ]
            else:
                props["EnableDnsHostnames"] = self.enable_dns_hostnames

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_vpc_id(self) -> GetAtt:
        """Get the VpcId attribute."""
        return self.get_att("VpcId")

    @property
    def attr_cidr_block_associations(self) -> GetAtt:
        """Get the CidrBlockAssociations attribute."""
        return self.get_att("CidrBlockAssociations")

    @property
    def attr_cidr_block(self) -> GetAtt:
        """Get the CidrBlock attribute."""
        return self.get_att("CidrBlock")

    @property
    def attr_default_network_acl(self) -> GetAtt:
        """Get the DefaultNetworkAcl attribute."""
        return self.get_att("DefaultNetworkAcl")

    @property
    def attr_ipv6_cidr_blocks(self) -> GetAtt:
        """Get the Ipv6CidrBlocks attribute."""
        return self.get_att("Ipv6CidrBlocks")

    @property
    def attr_default_security_group(self) -> GetAtt:
        """Get the DefaultSecurityGroup attribute."""
        return self.get_att("DefaultSecurityGroup")




@dataclass
class VPCBlockPublicAccessExclusion(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCBlockPublicAccessExclusion"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    internet_gateway_exclusion_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.internet_gateway_exclusion_mode is not None:
            # Serialize internet_gateway_exclusion_mode (handle intrinsic functions)
            if hasattr(self.internet_gateway_exclusion_mode, 'to_dict'):
                props["InternetGatewayExclusionMode"] = self.internet_gateway_exclusion_mode.to_dict()
            elif isinstance(self.internet_gateway_exclusion_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['InternetGatewayExclusionMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internet_gateway_exclusion_mode
                ]
            else:
                props["InternetGatewayExclusionMode"] = self.internet_gateway_exclusion_mode

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_exclusion_id(self) -> GetAtt:
        """Get the ExclusionId attribute."""
        return self.get_att("ExclusionId")




@dataclass
class VPCBlockPublicAccessOptions(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCBlockPublicAccessOptions"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    internet_gateway_block_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.internet_gateway_block_mode is not None:
            # Serialize internet_gateway_block_mode (handle intrinsic functions)
            if hasattr(self.internet_gateway_block_mode, 'to_dict'):
                props["InternetGatewayBlockMode"] = self.internet_gateway_block_mode.to_dict()
            elif isinstance(self.internet_gateway_block_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['InternetGatewayBlockMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internet_gateway_block_mode
                ]
            else:
                props["InternetGatewayBlockMode"] = self.internet_gateway_block_mode

        return props

    @property
    def attr_account_id(self) -> GetAtt:
        """Get the AccountId attribute."""
        return self.get_att("AccountId")

    @property
    def attr_exclusions_allowed(self) -> GetAtt:
        """Get the ExclusionsAllowed attribute."""
        return self.get_att("ExclusionsAllowed")




@dataclass
class VPCCidrBlock(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCCidrBlock"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv4_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_cidr_block_network_border_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_pool: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv4_ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    amazon_provided_ipv6_cidr_block: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_netmask_length is not None:
            # Serialize ipv6_netmask_length (handle intrinsic functions)
            if hasattr(self.ipv6_netmask_length, 'to_dict'):
                props["Ipv6NetmaskLength"] = self.ipv6_netmask_length.to_dict()
            elif isinstance(self.ipv6_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6NetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_netmask_length
                ]
            else:
                props["Ipv6NetmaskLength"] = self.ipv6_netmask_length

        if self.ipv6_ipam_pool_id is not None:
            # Serialize ipv6_ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipv6_ipam_pool_id, 'to_dict'):
                props["Ipv6IpamPoolId"] = self.ipv6_ipam_pool_id.to_dict()
            elif isinstance(self.ipv6_ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_ipam_pool_id
                ]
            else:
                props["Ipv6IpamPoolId"] = self.ipv6_ipam_pool_id

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.ipv4_netmask_length is not None:
            # Serialize ipv4_netmask_length (handle intrinsic functions)
            if hasattr(self.ipv4_netmask_length, 'to_dict'):
                props["Ipv4NetmaskLength"] = self.ipv4_netmask_length.to_dict()
            elif isinstance(self.ipv4_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv4NetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_netmask_length
                ]
            else:
                props["Ipv4NetmaskLength"] = self.ipv4_netmask_length

        if self.ipv6_cidr_block_network_border_group is not None:
            # Serialize ipv6_cidr_block_network_border_group (handle intrinsic functions)
            if hasattr(self.ipv6_cidr_block_network_border_group, 'to_dict'):
                props["Ipv6CidrBlockNetworkBorderGroup"] = self.ipv6_cidr_block_network_border_group.to_dict()
            elif isinstance(self.ipv6_cidr_block_network_border_group, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6CidrBlockNetworkBorderGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_cidr_block_network_border_group
                ]
            else:
                props["Ipv6CidrBlockNetworkBorderGroup"] = self.ipv6_cidr_block_network_border_group

        if self.cidr_block is not None:
            # Serialize cidr_block (handle intrinsic functions)
            if hasattr(self.cidr_block, 'to_dict'):
                props["CidrBlock"] = self.cidr_block.to_dict()
            elif isinstance(self.cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_block
                ]
            else:
                props["CidrBlock"] = self.cidr_block

        if self.ipv6_pool is not None:
            # Serialize ipv6_pool (handle intrinsic functions)
            if hasattr(self.ipv6_pool, 'to_dict'):
                props["Ipv6Pool"] = self.ipv6_pool.to_dict()
            elif isinstance(self.ipv6_pool, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6Pool'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_pool
                ]
            else:
                props["Ipv6Pool"] = self.ipv6_pool

        if self.ipv4_ipam_pool_id is not None:
            # Serialize ipv4_ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipv4_ipam_pool_id, 'to_dict'):
                props["Ipv4IpamPoolId"] = self.ipv4_ipam_pool_id.to_dict()
            elif isinstance(self.ipv4_ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv4IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_ipam_pool_id
                ]
            else:
                props["Ipv4IpamPoolId"] = self.ipv4_ipam_pool_id

        if self.ipv6_cidr_block is not None:
            # Serialize ipv6_cidr_block (handle intrinsic functions)
            if hasattr(self.ipv6_cidr_block, 'to_dict'):
                props["Ipv6CidrBlock"] = self.ipv6_cidr_block.to_dict()
            elif isinstance(self.ipv6_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_cidr_block
                ]
            else:
                props["Ipv6CidrBlock"] = self.ipv6_cidr_block

        if self.amazon_provided_ipv6_cidr_block is not None:
            # Serialize amazon_provided_ipv6_cidr_block (handle intrinsic functions)
            if hasattr(self.amazon_provided_ipv6_cidr_block, 'to_dict'):
                props["AmazonProvidedIpv6CidrBlock"] = self.amazon_provided_ipv6_cidr_block.to_dict()
            elif isinstance(self.amazon_provided_ipv6_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['AmazonProvidedIpv6CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.amazon_provided_ipv6_cidr_block
                ]
            else:
                props["AmazonProvidedIpv6CidrBlock"] = self.amazon_provided_ipv6_cidr_block

        return props

    @property
    def attr_ipv6_address_attribute(self) -> GetAtt:
        """Get the Ipv6AddressAttribute attribute."""
        return self.get_att("Ipv6AddressAttribute")

    @property
    def attr_ip_source(self) -> GetAtt:
        """Get the IpSource attribute."""
        return self.get_att("IpSource")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class VPCDHCPOptionsAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCDHCPOptionsAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    dhcp_options_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.dhcp_options_id is not None:
            # Serialize dhcp_options_id (handle intrinsic functions)
            if hasattr(self.dhcp_options_id, 'to_dict'):
                props["DhcpOptionsId"] = self.dhcp_options_id.to_dict()
            elif isinstance(self.dhcp_options_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DhcpOptionsId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dhcp_options_id
                ]
            else:
                props["DhcpOptionsId"] = self.dhcp_options_id

        return props



@dataclass
class ResourceExclusions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    elastic_file_system: Optional[VpcEncryptionControlExclusion] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_lattice: Optional[VpcEncryptionControlExclusion] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_peering: Optional[VpcEncryptionControlExclusion] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    internet_gateway: Optional[VpcEncryptionControlExclusion] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    egress_only_internet_gateway: Optional[VpcEncryptionControlExclusion] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    virtual_private_gateway: Optional[VpcEncryptionControlExclusion] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    nat_gateway: Optional[VpcEncryptionControlExclusion] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lambda_: Optional[VpcEncryptionControlExclusion] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.elastic_file_system is not None:
            if hasattr(self.elastic_file_system, 'to_dict'):
                props['ElasticFileSystem'] = self.elastic_file_system.to_dict()
            elif isinstance(self.elastic_file_system, list):
                props['ElasticFileSystem'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.elastic_file_system
                ]
            else:
                props['ElasticFileSystem'] = self.elastic_file_system

        if self.vpc_lattice is not None:
            if hasattr(self.vpc_lattice, 'to_dict'):
                props['VpcLattice'] = self.vpc_lattice.to_dict()
            elif isinstance(self.vpc_lattice, list):
                props['VpcLattice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_lattice
                ]
            else:
                props['VpcLattice'] = self.vpc_lattice

        if self.vpc_peering is not None:
            if hasattr(self.vpc_peering, 'to_dict'):
                props['VpcPeering'] = self.vpc_peering.to_dict()
            elif isinstance(self.vpc_peering, list):
                props['VpcPeering'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_peering
                ]
            else:
                props['VpcPeering'] = self.vpc_peering

        if self.internet_gateway is not None:
            if hasattr(self.internet_gateway, 'to_dict'):
                props['InternetGateway'] = self.internet_gateway.to_dict()
            elif isinstance(self.internet_gateway, list):
                props['InternetGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internet_gateway
                ]
            else:
                props['InternetGateway'] = self.internet_gateway

        if self.egress_only_internet_gateway is not None:
            if hasattr(self.egress_only_internet_gateway, 'to_dict'):
                props['EgressOnlyInternetGateway'] = self.egress_only_internet_gateway.to_dict()
            elif isinstance(self.egress_only_internet_gateway, list):
                props['EgressOnlyInternetGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.egress_only_internet_gateway
                ]
            else:
                props['EgressOnlyInternetGateway'] = self.egress_only_internet_gateway

        if self.virtual_private_gateway is not None:
            if hasattr(self.virtual_private_gateway, 'to_dict'):
                props['VirtualPrivateGateway'] = self.virtual_private_gateway.to_dict()
            elif isinstance(self.virtual_private_gateway, list):
                props['VirtualPrivateGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.virtual_private_gateway
                ]
            else:
                props['VirtualPrivateGateway'] = self.virtual_private_gateway

        if self.nat_gateway is not None:
            if hasattr(self.nat_gateway, 'to_dict'):
                props['NatGateway'] = self.nat_gateway.to_dict()
            elif isinstance(self.nat_gateway, list):
                props['NatGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.nat_gateway
                ]
            else:
                props['NatGateway'] = self.nat_gateway

        if self.lambda_ is not None:
            if hasattr(self.lambda_, 'to_dict'):
                props['Lambda'] = self.lambda_.to_dict()
            elif isinstance(self.lambda_, list):
                props['Lambda'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lambda_
                ]
            else:
                props['Lambda'] = self.lambda_

        return props


@dataclass
class VpcEncryptionControlExclusion:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    state: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    state_message: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.state is not None:
            if hasattr(self.state, 'to_dict'):
                props['State'] = self.state.to_dict()
            elif isinstance(self.state, list):
                props['State'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state
                ]
            else:
                props['State'] = self.state

        if self.state_message is not None:
            if hasattr(self.state_message, 'to_dict'):
                props['StateMessage'] = self.state_message.to_dict()
            elif isinstance(self.state_message, list):
                props['StateMessage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state_message
                ]
            else:
                props['StateMessage'] = self.state_message

        return props


@dataclass
class VPCEncryptionControl(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCEncryptionControl"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_peering_exclusion_input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    elastic_file_system_exclusion_input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_lattice_exclusion_input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    nat_gateway_exclusion_input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    egress_only_internet_gateway_exclusion_input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    virtual_private_gateway_exclusion_input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    internet_gateway_exclusion_input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    lambda_exclusion_input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_peering_exclusion_input is not None:
            # Serialize vpc_peering_exclusion_input (handle intrinsic functions)
            if hasattr(self.vpc_peering_exclusion_input, 'to_dict'):
                props["VpcPeeringExclusionInput"] = self.vpc_peering_exclusion_input.to_dict()
            elif isinstance(self.vpc_peering_exclusion_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcPeeringExclusionInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_peering_exclusion_input
                ]
            else:
                props["VpcPeeringExclusionInput"] = self.vpc_peering_exclusion_input

        if self.elastic_file_system_exclusion_input is not None:
            # Serialize elastic_file_system_exclusion_input (handle intrinsic functions)
            if hasattr(self.elastic_file_system_exclusion_input, 'to_dict'):
                props["ElasticFileSystemExclusionInput"] = self.elastic_file_system_exclusion_input.to_dict()
            elif isinstance(self.elastic_file_system_exclusion_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['ElasticFileSystemExclusionInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.elastic_file_system_exclusion_input
                ]
            else:
                props["ElasticFileSystemExclusionInput"] = self.elastic_file_system_exclusion_input

        if self.vpc_lattice_exclusion_input is not None:
            # Serialize vpc_lattice_exclusion_input (handle intrinsic functions)
            if hasattr(self.vpc_lattice_exclusion_input, 'to_dict'):
                props["VpcLatticeExclusionInput"] = self.vpc_lattice_exclusion_input.to_dict()
            elif isinstance(self.vpc_lattice_exclusion_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcLatticeExclusionInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_lattice_exclusion_input
                ]
            else:
                props["VpcLatticeExclusionInput"] = self.vpc_lattice_exclusion_input

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.nat_gateway_exclusion_input is not None:
            # Serialize nat_gateway_exclusion_input (handle intrinsic functions)
            if hasattr(self.nat_gateway_exclusion_input, 'to_dict'):
                props["NatGatewayExclusionInput"] = self.nat_gateway_exclusion_input.to_dict()
            elif isinstance(self.nat_gateway_exclusion_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['NatGatewayExclusionInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.nat_gateway_exclusion_input
                ]
            else:
                props["NatGatewayExclusionInput"] = self.nat_gateway_exclusion_input

        if self.egress_only_internet_gateway_exclusion_input is not None:
            # Serialize egress_only_internet_gateway_exclusion_input (handle intrinsic functions)
            if hasattr(self.egress_only_internet_gateway_exclusion_input, 'to_dict'):
                props["EgressOnlyInternetGatewayExclusionInput"] = self.egress_only_internet_gateway_exclusion_input.to_dict()
            elif isinstance(self.egress_only_internet_gateway_exclusion_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['EgressOnlyInternetGatewayExclusionInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.egress_only_internet_gateway_exclusion_input
                ]
            else:
                props["EgressOnlyInternetGatewayExclusionInput"] = self.egress_only_internet_gateway_exclusion_input

        if self.virtual_private_gateway_exclusion_input is not None:
            # Serialize virtual_private_gateway_exclusion_input (handle intrinsic functions)
            if hasattr(self.virtual_private_gateway_exclusion_input, 'to_dict'):
                props["VirtualPrivateGatewayExclusionInput"] = self.virtual_private_gateway_exclusion_input.to_dict()
            elif isinstance(self.virtual_private_gateway_exclusion_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['VirtualPrivateGatewayExclusionInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.virtual_private_gateway_exclusion_input
                ]
            else:
                props["VirtualPrivateGatewayExclusionInput"] = self.virtual_private_gateway_exclusion_input

        if self.mode is not None:
            # Serialize mode (handle intrinsic functions)
            if hasattr(self.mode, 'to_dict'):
                props["Mode"] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props["Mode"] = self.mode

        if self.internet_gateway_exclusion_input is not None:
            # Serialize internet_gateway_exclusion_input (handle intrinsic functions)
            if hasattr(self.internet_gateway_exclusion_input, 'to_dict'):
                props["InternetGatewayExclusionInput"] = self.internet_gateway_exclusion_input.to_dict()
            elif isinstance(self.internet_gateway_exclusion_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['InternetGatewayExclusionInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internet_gateway_exclusion_input
                ]
            else:
                props["InternetGatewayExclusionInput"] = self.internet_gateway_exclusion_input

        if self.lambda_exclusion_input is not None:
            # Serialize lambda_exclusion_input (handle intrinsic functions)
            if hasattr(self.lambda_exclusion_input, 'to_dict'):
                props["LambdaExclusionInput"] = self.lambda_exclusion_input.to_dict()
            elif isinstance(self.lambda_exclusion_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['LambdaExclusionInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lambda_exclusion_input
                ]
            else:
                props["LambdaExclusionInput"] = self.lambda_exclusion_input

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_resource_exclusions__elastic_file_system__state(self) -> GetAtt:
        """Get the ResourceExclusions.ElasticFileSystem.State attribute."""
        return self.get_att("ResourceExclusions.ElasticFileSystem.State")

    @property
    def attr_resource_exclusions__vpc_lattice__state(self) -> GetAtt:
        """Get the ResourceExclusions.VpcLattice.State attribute."""
        return self.get_att("ResourceExclusions.VpcLattice.State")

    @property
    def attr_resource_exclusions__virtual_private_gateway__state_message(self) -> GetAtt:
        """Get the ResourceExclusions.VirtualPrivateGateway.StateMessage attribute."""
        return self.get_att("ResourceExclusions.VirtualPrivateGateway.StateMessage")

    @property
    def attr_vpc_encryption_control_id(self) -> GetAtt:
        """Get the VpcEncryptionControlId attribute."""
        return self.get_att("VpcEncryptionControlId")

    @property
    def attr_resource_exclusions__vpc_lattice(self) -> GetAtt:
        """Get the ResourceExclusions.VpcLattice attribute."""
        return self.get_att("ResourceExclusions.VpcLattice")

    @property
    def attr_resource_exclusions__lambda(self) -> GetAtt:
        """Get the ResourceExclusions.Lambda attribute."""
        return self.get_att("ResourceExclusions.Lambda")

    @property
    def attr_resource_exclusions__nat_gateway__state(self) -> GetAtt:
        """Get the ResourceExclusions.NatGateway.State attribute."""
        return self.get_att("ResourceExclusions.NatGateway.State")

    @property
    def attr_resource_exclusions__internet_gateway(self) -> GetAtt:
        """Get the ResourceExclusions.InternetGateway attribute."""
        return self.get_att("ResourceExclusions.InternetGateway")

    @property
    def attr_resource_exclusions__virtual_private_gateway(self) -> GetAtt:
        """Get the ResourceExclusions.VirtualPrivateGateway attribute."""
        return self.get_att("ResourceExclusions.VirtualPrivateGateway")

    @property
    def attr_state_message(self) -> GetAtt:
        """Get the StateMessage attribute."""
        return self.get_att("StateMessage")

    @property
    def attr_resource_exclusions__egress_only_internet_gateway__state_message(self) -> GetAtt:
        """Get the ResourceExclusions.EgressOnlyInternetGateway.StateMessage attribute."""
        return self.get_att("ResourceExclusions.EgressOnlyInternetGateway.StateMessage")

    @property
    def attr_resource_exclusions__nat_gateway(self) -> GetAtt:
        """Get the ResourceExclusions.NatGateway attribute."""
        return self.get_att("ResourceExclusions.NatGateway")

    @property
    def attr_resource_exclusions__vpc_peering(self) -> GetAtt:
        """Get the ResourceExclusions.VpcPeering attribute."""
        return self.get_att("ResourceExclusions.VpcPeering")

    @property
    def attr_resource_exclusions__egress_only_internet_gateway(self) -> GetAtt:
        """Get the ResourceExclusions.EgressOnlyInternetGateway attribute."""
        return self.get_att("ResourceExclusions.EgressOnlyInternetGateway")

    @property
    def attr_resource_exclusions__internet_gateway__state(self) -> GetAtt:
        """Get the ResourceExclusions.InternetGateway.State attribute."""
        return self.get_att("ResourceExclusions.InternetGateway.State")

    @property
    def attr_resource_exclusions__elastic_file_system__state_message(self) -> GetAtt:
        """Get the ResourceExclusions.ElasticFileSystem.StateMessage attribute."""
        return self.get_att("ResourceExclusions.ElasticFileSystem.StateMessage")

    @property
    def attr_resource_exclusions__elastic_file_system(self) -> GetAtt:
        """Get the ResourceExclusions.ElasticFileSystem attribute."""
        return self.get_att("ResourceExclusions.ElasticFileSystem")

    @property
    def attr_resource_exclusions__egress_only_internet_gateway__state(self) -> GetAtt:
        """Get the ResourceExclusions.EgressOnlyInternetGateway.State attribute."""
        return self.get_att("ResourceExclusions.EgressOnlyInternetGateway.State")

    @property
    def attr_resource_exclusions__nat_gateway__state_message(self) -> GetAtt:
        """Get the ResourceExclusions.NatGateway.StateMessage attribute."""
        return self.get_att("ResourceExclusions.NatGateway.StateMessage")

    @property
    def attr_resource_exclusions__lambda__state(self) -> GetAtt:
        """Get the ResourceExclusions.Lambda.State attribute."""
        return self.get_att("ResourceExclusions.Lambda.State")

    @property
    def attr_resource_exclusions__internet_gateway__state_message(self) -> GetAtt:
        """Get the ResourceExclusions.InternetGateway.StateMessage attribute."""
        return self.get_att("ResourceExclusions.InternetGateway.StateMessage")

    @property
    def attr_resource_exclusions__lambda__state_message(self) -> GetAtt:
        """Get the ResourceExclusions.Lambda.StateMessage attribute."""
        return self.get_att("ResourceExclusions.Lambda.StateMessage")

    @property
    def attr_resource_exclusions__vpc_peering__state(self) -> GetAtt:
        """Get the ResourceExclusions.VpcPeering.State attribute."""
        return self.get_att("ResourceExclusions.VpcPeering.State")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_resource_exclusions__vpc_peering__state_message(self) -> GetAtt:
        """Get the ResourceExclusions.VpcPeering.StateMessage attribute."""
        return self.get_att("ResourceExclusions.VpcPeering.StateMessage")

    @property
    def attr_resource_exclusions__vpc_lattice__state_message(self) -> GetAtt:
        """Get the ResourceExclusions.VpcLattice.StateMessage attribute."""
        return self.get_att("ResourceExclusions.VpcLattice.StateMessage")

    @property
    def attr_resource_exclusions(self) -> GetAtt:
        """Get the ResourceExclusions attribute."""
        return self.get_att("ResourceExclusions")

    @property
    def attr_resource_exclusions__virtual_private_gateway__state(self) -> GetAtt:
        """Get the ResourceExclusions.VirtualPrivateGateway.State attribute."""
        return self.get_att("ResourceExclusions.VirtualPrivateGateway.State")




@dataclass
class DnsOptionsSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_dns_only_for_inbound_resolver_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_dns_specified_domains: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dns_record_ip_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_dns_preference: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.private_dns_only_for_inbound_resolver_endpoint is not None:
            if hasattr(self.private_dns_only_for_inbound_resolver_endpoint, 'to_dict'):
                props['PrivateDnsOnlyForInboundResolverEndpoint'] = self.private_dns_only_for_inbound_resolver_endpoint.to_dict()
            elif isinstance(self.private_dns_only_for_inbound_resolver_endpoint, list):
                props['PrivateDnsOnlyForInboundResolverEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_dns_only_for_inbound_resolver_endpoint
                ]
            else:
                props['PrivateDnsOnlyForInboundResolverEndpoint'] = self.private_dns_only_for_inbound_resolver_endpoint

        if self.private_dns_specified_domains is not None:
            if hasattr(self.private_dns_specified_domains, 'to_dict'):
                props['PrivateDnsSpecifiedDomains'] = self.private_dns_specified_domains.to_dict()
            elif isinstance(self.private_dns_specified_domains, list):
                props['PrivateDnsSpecifiedDomains'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_dns_specified_domains
                ]
            else:
                props['PrivateDnsSpecifiedDomains'] = self.private_dns_specified_domains

        if self.dns_record_ip_type is not None:
            if hasattr(self.dns_record_ip_type, 'to_dict'):
                props['DnsRecordIpType'] = self.dns_record_ip_type.to_dict()
            elif isinstance(self.dns_record_ip_type, list):
                props['DnsRecordIpType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dns_record_ip_type
                ]
            else:
                props['DnsRecordIpType'] = self.dns_record_ip_type

        if self.private_dns_preference is not None:
            if hasattr(self.private_dns_preference, 'to_dict'):
                props['PrivateDnsPreference'] = self.private_dns_preference.to_dict()
            elif isinstance(self.private_dns_preference, list):
                props['PrivateDnsPreference'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_dns_preference
                ]
            else:
                props['PrivateDnsPreference'] = self.private_dns_preference

        return props


@dataclass
class VPCEndpoint(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCEndpoint"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_dns_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ip_address_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    dns_options: Optional[DnsOptionsSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_configuration_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_network_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_table_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_document: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_endpoint_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.private_dns_enabled is not None:
            # Serialize private_dns_enabled (handle intrinsic functions)
            if hasattr(self.private_dns_enabled, 'to_dict'):
                props["PrivateDnsEnabled"] = self.private_dns_enabled.to_dict()
            elif isinstance(self.private_dns_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateDnsEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_dns_enabled
                ]
            else:
                props["PrivateDnsEnabled"] = self.private_dns_enabled

        if self.ip_address_type is not None:
            # Serialize ip_address_type (handle intrinsic functions)
            if hasattr(self.ip_address_type, 'to_dict'):
                props["IpAddressType"] = self.ip_address_type.to_dict()
            elif isinstance(self.ip_address_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpAddressType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_address_type
                ]
            else:
                props["IpAddressType"] = self.ip_address_type

        if self.service_region is not None:
            # Serialize service_region (handle intrinsic functions)
            if hasattr(self.service_region, 'to_dict'):
                props["ServiceRegion"] = self.service_region.to_dict()
            elif isinstance(self.service_region, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_region
                ]
            else:
                props["ServiceRegion"] = self.service_region

        if self.dns_options is not None:
            # Serialize dns_options (handle intrinsic functions)
            if hasattr(self.dns_options, 'to_dict'):
                props["DnsOptions"] = self.dns_options.to_dict()
            elif isinstance(self.dns_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['DnsOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dns_options
                ]
            else:
                props["DnsOptions"] = self.dns_options

        if self.resource_configuration_arn is not None:
            # Serialize resource_configuration_arn (handle intrinsic functions)
            if hasattr(self.resource_configuration_arn, 'to_dict'):
                props["ResourceConfigurationArn"] = self.resource_configuration_arn.to_dict()
            elif isinstance(self.resource_configuration_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceConfigurationArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_configuration_arn
                ]
            else:
                props["ResourceConfigurationArn"] = self.resource_configuration_arn

        if self.security_group_ids is not None:
            # Serialize security_group_ids (handle intrinsic functions)
            if hasattr(self.security_group_ids, 'to_dict'):
                props["SecurityGroupIds"] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props["SecurityGroupIds"] = self.security_group_ids

        if self.subnet_ids is not None:
            # Serialize subnet_ids (handle intrinsic functions)
            if hasattr(self.subnet_ids, 'to_dict'):
                props["SubnetIds"] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props["SubnetIds"] = self.subnet_ids

        if self.service_network_arn is not None:
            # Serialize service_network_arn (handle intrinsic functions)
            if hasattr(self.service_network_arn, 'to_dict'):
                props["ServiceNetworkArn"] = self.service_network_arn.to_dict()
            elif isinstance(self.service_network_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceNetworkArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_network_arn
                ]
            else:
                props["ServiceNetworkArn"] = self.service_network_arn

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.route_table_ids is not None:
            # Serialize route_table_ids (handle intrinsic functions)
            if hasattr(self.route_table_ids, 'to_dict'):
                props["RouteTableIds"] = self.route_table_ids.to_dict()
            elif isinstance(self.route_table_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteTableIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_ids
                ]
            else:
                props["RouteTableIds"] = self.route_table_ids

        if self.service_name is not None:
            # Serialize service_name (handle intrinsic functions)
            if hasattr(self.service_name, 'to_dict'):
                props["ServiceName"] = self.service_name.to_dict()
            elif isinstance(self.service_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_name
                ]
            else:
                props["ServiceName"] = self.service_name

        if self.policy_document is not None:
            # Serialize policy_document (handle intrinsic functions)
            if hasattr(self.policy_document, 'to_dict'):
                props["PolicyDocument"] = self.policy_document.to_dict()
            elif isinstance(self.policy_document, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyDocument'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_document
                ]
            else:
                props["PolicyDocument"] = self.policy_document

        if self.vpc_endpoint_type is not None:
            # Serialize vpc_endpoint_type (handle intrinsic functions)
            if hasattr(self.vpc_endpoint_type, 'to_dict'):
                props["VpcEndpointType"] = self.vpc_endpoint_type.to_dict()
            elif isinstance(self.vpc_endpoint_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcEndpointType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_endpoint_type
                ]
            else:
                props["VpcEndpointType"] = self.vpc_endpoint_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_creation_timestamp(self) -> GetAtt:
        """Get the CreationTimestamp attribute."""
        return self.get_att("CreationTimestamp")

    @property
    def attr_network_interface_ids(self) -> GetAtt:
        """Get the NetworkInterfaceIds attribute."""
        return self.get_att("NetworkInterfaceIds")

    @property
    def attr_dns_entries(self) -> GetAtt:
        """Get the DnsEntries attribute."""
        return self.get_att("DnsEntries")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class VPCEndpointConnectionNotification(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCEndpointConnectionNotification"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connection_events: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_endpoint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connection_notification_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.connection_events is not None:
            # Serialize connection_events (handle intrinsic functions)
            if hasattr(self.connection_events, 'to_dict'):
                props["ConnectionEvents"] = self.connection_events.to_dict()
            elif isinstance(self.connection_events, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConnectionEvents'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connection_events
                ]
            else:
                props["ConnectionEvents"] = self.connection_events

        if self.vpc_endpoint_id is not None:
            # Serialize vpc_endpoint_id (handle intrinsic functions)
            if hasattr(self.vpc_endpoint_id, 'to_dict'):
                props["VPCEndpointId"] = self.vpc_endpoint_id.to_dict()
            elif isinstance(self.vpc_endpoint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VPCEndpointId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_endpoint_id
                ]
            else:
                props["VPCEndpointId"] = self.vpc_endpoint_id

        if self.connection_notification_arn is not None:
            # Serialize connection_notification_arn (handle intrinsic functions)
            if hasattr(self.connection_notification_arn, 'to_dict'):
                props["ConnectionNotificationArn"] = self.connection_notification_arn.to_dict()
            elif isinstance(self.connection_notification_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConnectionNotificationArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connection_notification_arn
                ]
            else:
                props["ConnectionNotificationArn"] = self.connection_notification_arn

        if self.service_id is not None:
            # Serialize service_id (handle intrinsic functions)
            if hasattr(self.service_id, 'to_dict'):
                props["ServiceId"] = self.service_id.to_dict()
            elif isinstance(self.service_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_id
                ]
            else:
                props["ServiceId"] = self.service_id

        return props

    @property
    def attr_vpc_endpoint_connection_notification_id(self) -> GetAtt:
        """Get the VPCEndpointConnectionNotificationId attribute."""
        return self.get_att("VPCEndpointConnectionNotificationId")




@dataclass
class VPCEndpointService(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCEndpointService"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_load_balancer_arns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    payer_responsibility: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    acceptance_required: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    contributor_insights_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    supported_ip_address_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    gateway_load_balancer_arns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    supported_regions: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.network_load_balancer_arns is not None:
            # Serialize network_load_balancer_arns (handle intrinsic functions)
            if hasattr(self.network_load_balancer_arns, 'to_dict'):
                props["NetworkLoadBalancerArns"] = self.network_load_balancer_arns.to_dict()
            elif isinstance(self.network_load_balancer_arns, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkLoadBalancerArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_load_balancer_arns
                ]
            else:
                props["NetworkLoadBalancerArns"] = self.network_load_balancer_arns

        if self.payer_responsibility is not None:
            # Serialize payer_responsibility (handle intrinsic functions)
            if hasattr(self.payer_responsibility, 'to_dict'):
                props["PayerResponsibility"] = self.payer_responsibility.to_dict()
            elif isinstance(self.payer_responsibility, list):
                # Serialize list items (may contain intrinsic functions)
                props['PayerResponsibility'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.payer_responsibility
                ]
            else:
                props["PayerResponsibility"] = self.payer_responsibility

        if self.acceptance_required is not None:
            # Serialize acceptance_required (handle intrinsic functions)
            if hasattr(self.acceptance_required, 'to_dict'):
                props["AcceptanceRequired"] = self.acceptance_required.to_dict()
            elif isinstance(self.acceptance_required, list):
                # Serialize list items (may contain intrinsic functions)
                props['AcceptanceRequired'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.acceptance_required
                ]
            else:
                props["AcceptanceRequired"] = self.acceptance_required

        if self.contributor_insights_enabled is not None:
            # Serialize contributor_insights_enabled (handle intrinsic functions)
            if hasattr(self.contributor_insights_enabled, 'to_dict'):
                props["ContributorInsightsEnabled"] = self.contributor_insights_enabled.to_dict()
            elif isinstance(self.contributor_insights_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['ContributorInsightsEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.contributor_insights_enabled
                ]
            else:
                props["ContributorInsightsEnabled"] = self.contributor_insights_enabled

        if self.supported_ip_address_types is not None:
            # Serialize supported_ip_address_types (handle intrinsic functions)
            if hasattr(self.supported_ip_address_types, 'to_dict'):
                props["SupportedIpAddressTypes"] = self.supported_ip_address_types.to_dict()
            elif isinstance(self.supported_ip_address_types, list):
                # Serialize list items (may contain intrinsic functions)
                props['SupportedIpAddressTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.supported_ip_address_types
                ]
            else:
                props["SupportedIpAddressTypes"] = self.supported_ip_address_types

        if self.gateway_load_balancer_arns is not None:
            # Serialize gateway_load_balancer_arns (handle intrinsic functions)
            if hasattr(self.gateway_load_balancer_arns, 'to_dict'):
                props["GatewayLoadBalancerArns"] = self.gateway_load_balancer_arns.to_dict()
            elif isinstance(self.gateway_load_balancer_arns, list):
                # Serialize list items (may contain intrinsic functions)
                props['GatewayLoadBalancerArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gateway_load_balancer_arns
                ]
            else:
                props["GatewayLoadBalancerArns"] = self.gateway_load_balancer_arns

        if self.supported_regions is not None:
            # Serialize supported_regions (handle intrinsic functions)
            if hasattr(self.supported_regions, 'to_dict'):
                props["SupportedRegions"] = self.supported_regions.to_dict()
            elif isinstance(self.supported_regions, list):
                # Serialize list items (may contain intrinsic functions)
                props['SupportedRegions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.supported_regions
                ]
            else:
                props["SupportedRegions"] = self.supported_regions

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_service_id(self) -> GetAtt:
        """Get the ServiceId attribute."""
        return self.get_att("ServiceId")




@dataclass
class VPCEndpointServicePermissions(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCEndpointServicePermissions"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allowed_principals: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.allowed_principals is not None:
            # Serialize allowed_principals (handle intrinsic functions)
            if hasattr(self.allowed_principals, 'to_dict'):
                props["AllowedPrincipals"] = self.allowed_principals.to_dict()
            elif isinstance(self.allowed_principals, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllowedPrincipals'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_principals
                ]
            else:
                props["AllowedPrincipals"] = self.allowed_principals

        if self.service_id is not None:
            # Serialize service_id (handle intrinsic functions)
            if hasattr(self.service_id, 'to_dict'):
                props["ServiceId"] = self.service_id.to_dict()
            elif isinstance(self.service_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_id
                ]
            else:
                props["ServiceId"] = self.service_id

        return props



@dataclass
class VPCGatewayAttachment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCGatewayAttachment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    internet_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpn_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.internet_gateway_id is not None:
            # Serialize internet_gateway_id (handle intrinsic functions)
            if hasattr(self.internet_gateway_id, 'to_dict'):
                props["InternetGatewayId"] = self.internet_gateway_id.to_dict()
            elif isinstance(self.internet_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['InternetGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internet_gateway_id
                ]
            else:
                props["InternetGatewayId"] = self.internet_gateway_id

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.vpn_gateway_id is not None:
            # Serialize vpn_gateway_id (handle intrinsic functions)
            if hasattr(self.vpn_gateway_id, 'to_dict'):
                props["VpnGatewayId"] = self.vpn_gateway_id.to_dict()
            elif isinstance(self.vpn_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpnGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_gateway_id
                ]
            else:
                props["VpnGatewayId"] = self.vpn_gateway_id

        return props

    @property
    def attr_attachment_type(self) -> GetAtt:
        """Get the AttachmentType attribute."""
        return self.get_att("AttachmentType")




@dataclass
class VPCPeeringConnection(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCPeeringConnection"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_owner_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.peer_role_arn is not None:
            # Serialize peer_role_arn (handle intrinsic functions)
            if hasattr(self.peer_role_arn, 'to_dict'):
                props["PeerRoleArn"] = self.peer_role_arn.to_dict()
            elif isinstance(self.peer_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_role_arn
                ]
            else:
                props["PeerRoleArn"] = self.peer_role_arn

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.peer_vpc_id is not None:
            # Serialize peer_vpc_id (handle intrinsic functions)
            if hasattr(self.peer_vpc_id, 'to_dict'):
                props["PeerVpcId"] = self.peer_vpc_id.to_dict()
            elif isinstance(self.peer_vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerVpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_vpc_id
                ]
            else:
                props["PeerVpcId"] = self.peer_vpc_id

        if self.peer_region is not None:
            # Serialize peer_region (handle intrinsic functions)
            if hasattr(self.peer_region, 'to_dict'):
                props["PeerRegion"] = self.peer_region.to_dict()
            elif isinstance(self.peer_region, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_region
                ]
            else:
                props["PeerRegion"] = self.peer_region

        if self.peer_owner_id is not None:
            # Serialize peer_owner_id (handle intrinsic functions)
            if hasattr(self.peer_owner_id, 'to_dict'):
                props["PeerOwnerId"] = self.peer_owner_id.to_dict()
            elif isinstance(self.peer_owner_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerOwnerId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_owner_id
                ]
            else:
                props["PeerOwnerId"] = self.peer_owner_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class VPNConcentrator(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPNConcentrator"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_vpn_concentrator_id(self) -> GetAtt:
        """Get the VpnConcentratorId attribute."""
        return self.get_att("VpnConcentratorId")

    @property
    def attr_transit_gateway_attachment_id(self) -> GetAtt:
        """Get the TransitGatewayAttachmentId attribute."""
        return self.get_att("TransitGatewayAttachmentId")




@dataclass
class CloudwatchLogOptionsSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bgp_log_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_output_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bgp_log_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bgp_log_output_format: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.bgp_log_enabled is not None:
            if hasattr(self.bgp_log_enabled, 'to_dict'):
                props['BgpLogEnabled'] = self.bgp_log_enabled.to_dict()
            elif isinstance(self.bgp_log_enabled, list):
                props['BgpLogEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bgp_log_enabled
                ]
            else:
                props['BgpLogEnabled'] = self.bgp_log_enabled

        if self.log_enabled is not None:
            if hasattr(self.log_enabled, 'to_dict'):
                props['LogEnabled'] = self.log_enabled.to_dict()
            elif isinstance(self.log_enabled, list):
                props['LogEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_enabled
                ]
            else:
                props['LogEnabled'] = self.log_enabled

        if self.log_output_format is not None:
            if hasattr(self.log_output_format, 'to_dict'):
                props['LogOutputFormat'] = self.log_output_format.to_dict()
            elif isinstance(self.log_output_format, list):
                props['LogOutputFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_output_format
                ]
            else:
                props['LogOutputFormat'] = self.log_output_format

        if self.bgp_log_group_arn is not None:
            if hasattr(self.bgp_log_group_arn, 'to_dict'):
                props['BgpLogGroupArn'] = self.bgp_log_group_arn.to_dict()
            elif isinstance(self.bgp_log_group_arn, list):
                props['BgpLogGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bgp_log_group_arn
                ]
            else:
                props['BgpLogGroupArn'] = self.bgp_log_group_arn

        if self.log_group_arn is not None:
            if hasattr(self.log_group_arn, 'to_dict'):
                props['LogGroupArn'] = self.log_group_arn.to_dict()
            elif isinstance(self.log_group_arn, list):
                props['LogGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_arn
                ]
            else:
                props['LogGroupArn'] = self.log_group_arn

        if self.bgp_log_output_format is not None:
            if hasattr(self.bgp_log_output_format, 'to_dict'):
                props['BgpLogOutputFormat'] = self.bgp_log_output_format.to_dict()
            elif isinstance(self.bgp_log_output_format, list):
                props['BgpLogOutputFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bgp_log_output_format
                ]
            else:
                props['BgpLogOutputFormat'] = self.bgp_log_output_format

        return props


@dataclass
class IKEVersionsRequestListValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class Phase1DHGroupNumbersRequestListValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class Phase1EncryptionAlgorithmsRequestListValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class Phase1IntegrityAlgorithmsRequestListValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class Phase2DHGroupNumbersRequestListValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class Phase2EncryptionAlgorithmsRequestListValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class Phase2IntegrityAlgorithmsRequestListValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class VpnTunnelLogOptionsSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloudwatch_log_options: Optional[CloudwatchLogOptionsSpecification] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cloudwatch_log_options is not None:
            if hasattr(self.cloudwatch_log_options, 'to_dict'):
                props['CloudwatchLogOptions'] = self.cloudwatch_log_options.to_dict()
            elif isinstance(self.cloudwatch_log_options, list):
                props['CloudwatchLogOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cloudwatch_log_options
                ]
            else:
                props['CloudwatchLogOptions'] = self.cloudwatch_log_options

        return props


@dataclass
class VpnTunnelOptionsSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    phase2_encryption_algorithms: Optional[list[Phase2EncryptionAlgorithmsRequestListValue]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    phase2_dh_group_numbers: Optional[list[Phase2DHGroupNumbersRequestListValue]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tunnel_inside_ipv6_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    startup_action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tunnel_inside_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ike_versions: Optional[list[IKEVersionsRequestListValue]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_options: Optional[VpnTunnelLogOptionsSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    phase1_dh_group_numbers: Optional[list[Phase1DHGroupNumbersRequestListValue]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    replay_window_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_tunnel_lifecycle_control: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rekey_margin_time_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dpd_timeout_action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    phase2_lifetime_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    phase2_integrity_algorithms: Optional[list[Phase2IntegrityAlgorithmsRequestListValue]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    phase1_integrity_algorithms: Optional[list[Phase1IntegrityAlgorithmsRequestListValue]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    pre_shared_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    phase1_lifetime_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rekey_fuzz_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    phase1_encryption_algorithms: Optional[list[Phase1EncryptionAlgorithmsRequestListValue]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dpd_timeout_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.phase2_encryption_algorithms is not None:
            if hasattr(self.phase2_encryption_algorithms, 'to_dict'):
                props['Phase2EncryptionAlgorithms'] = self.phase2_encryption_algorithms.to_dict()
            elif isinstance(self.phase2_encryption_algorithms, list):
                props['Phase2EncryptionAlgorithms'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.phase2_encryption_algorithms
                ]
            else:
                props['Phase2EncryptionAlgorithms'] = self.phase2_encryption_algorithms

        if self.phase2_dh_group_numbers is not None:
            if hasattr(self.phase2_dh_group_numbers, 'to_dict'):
                props['Phase2DHGroupNumbers'] = self.phase2_dh_group_numbers.to_dict()
            elif isinstance(self.phase2_dh_group_numbers, list):
                props['Phase2DHGroupNumbers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.phase2_dh_group_numbers
                ]
            else:
                props['Phase2DHGroupNumbers'] = self.phase2_dh_group_numbers

        if self.tunnel_inside_ipv6_cidr is not None:
            if hasattr(self.tunnel_inside_ipv6_cidr, 'to_dict'):
                props['TunnelInsideIpv6Cidr'] = self.tunnel_inside_ipv6_cidr.to_dict()
            elif isinstance(self.tunnel_inside_ipv6_cidr, list):
                props['TunnelInsideIpv6Cidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tunnel_inside_ipv6_cidr
                ]
            else:
                props['TunnelInsideIpv6Cidr'] = self.tunnel_inside_ipv6_cidr

        if self.startup_action is not None:
            if hasattr(self.startup_action, 'to_dict'):
                props['StartupAction'] = self.startup_action.to_dict()
            elif isinstance(self.startup_action, list):
                props['StartupAction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.startup_action
                ]
            else:
                props['StartupAction'] = self.startup_action

        if self.tunnel_inside_cidr is not None:
            if hasattr(self.tunnel_inside_cidr, 'to_dict'):
                props['TunnelInsideCidr'] = self.tunnel_inside_cidr.to_dict()
            elif isinstance(self.tunnel_inside_cidr, list):
                props['TunnelInsideCidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tunnel_inside_cidr
                ]
            else:
                props['TunnelInsideCidr'] = self.tunnel_inside_cidr

        if self.ike_versions is not None:
            if hasattr(self.ike_versions, 'to_dict'):
                props['IKEVersions'] = self.ike_versions.to_dict()
            elif isinstance(self.ike_versions, list):
                props['IKEVersions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ike_versions
                ]
            else:
                props['IKEVersions'] = self.ike_versions

        if self.log_options is not None:
            if hasattr(self.log_options, 'to_dict'):
                props['LogOptions'] = self.log_options.to_dict()
            elif isinstance(self.log_options, list):
                props['LogOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_options
                ]
            else:
                props['LogOptions'] = self.log_options

        if self.phase1_dh_group_numbers is not None:
            if hasattr(self.phase1_dh_group_numbers, 'to_dict'):
                props['Phase1DHGroupNumbers'] = self.phase1_dh_group_numbers.to_dict()
            elif isinstance(self.phase1_dh_group_numbers, list):
                props['Phase1DHGroupNumbers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.phase1_dh_group_numbers
                ]
            else:
                props['Phase1DHGroupNumbers'] = self.phase1_dh_group_numbers

        if self.replay_window_size is not None:
            if hasattr(self.replay_window_size, 'to_dict'):
                props['ReplayWindowSize'] = self.replay_window_size.to_dict()
            elif isinstance(self.replay_window_size, list):
                props['ReplayWindowSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.replay_window_size
                ]
            else:
                props['ReplayWindowSize'] = self.replay_window_size

        if self.enable_tunnel_lifecycle_control is not None:
            if hasattr(self.enable_tunnel_lifecycle_control, 'to_dict'):
                props['EnableTunnelLifecycleControl'] = self.enable_tunnel_lifecycle_control.to_dict()
            elif isinstance(self.enable_tunnel_lifecycle_control, list):
                props['EnableTunnelLifecycleControl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_tunnel_lifecycle_control
                ]
            else:
                props['EnableTunnelLifecycleControl'] = self.enable_tunnel_lifecycle_control

        if self.rekey_margin_time_seconds is not None:
            if hasattr(self.rekey_margin_time_seconds, 'to_dict'):
                props['RekeyMarginTimeSeconds'] = self.rekey_margin_time_seconds.to_dict()
            elif isinstance(self.rekey_margin_time_seconds, list):
                props['RekeyMarginTimeSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rekey_margin_time_seconds
                ]
            else:
                props['RekeyMarginTimeSeconds'] = self.rekey_margin_time_seconds

        if self.dpd_timeout_action is not None:
            if hasattr(self.dpd_timeout_action, 'to_dict'):
                props['DPDTimeoutAction'] = self.dpd_timeout_action.to_dict()
            elif isinstance(self.dpd_timeout_action, list):
                props['DPDTimeoutAction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dpd_timeout_action
                ]
            else:
                props['DPDTimeoutAction'] = self.dpd_timeout_action

        if self.phase2_lifetime_seconds is not None:
            if hasattr(self.phase2_lifetime_seconds, 'to_dict'):
                props['Phase2LifetimeSeconds'] = self.phase2_lifetime_seconds.to_dict()
            elif isinstance(self.phase2_lifetime_seconds, list):
                props['Phase2LifetimeSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.phase2_lifetime_seconds
                ]
            else:
                props['Phase2LifetimeSeconds'] = self.phase2_lifetime_seconds

        if self.phase2_integrity_algorithms is not None:
            if hasattr(self.phase2_integrity_algorithms, 'to_dict'):
                props['Phase2IntegrityAlgorithms'] = self.phase2_integrity_algorithms.to_dict()
            elif isinstance(self.phase2_integrity_algorithms, list):
                props['Phase2IntegrityAlgorithms'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.phase2_integrity_algorithms
                ]
            else:
                props['Phase2IntegrityAlgorithms'] = self.phase2_integrity_algorithms

        if self.phase1_integrity_algorithms is not None:
            if hasattr(self.phase1_integrity_algorithms, 'to_dict'):
                props['Phase1IntegrityAlgorithms'] = self.phase1_integrity_algorithms.to_dict()
            elif isinstance(self.phase1_integrity_algorithms, list):
                props['Phase1IntegrityAlgorithms'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.phase1_integrity_algorithms
                ]
            else:
                props['Phase1IntegrityAlgorithms'] = self.phase1_integrity_algorithms

        if self.pre_shared_key is not None:
            if hasattr(self.pre_shared_key, 'to_dict'):
                props['PreSharedKey'] = self.pre_shared_key.to_dict()
            elif isinstance(self.pre_shared_key, list):
                props['PreSharedKey'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pre_shared_key
                ]
            else:
                props['PreSharedKey'] = self.pre_shared_key

        if self.phase1_lifetime_seconds is not None:
            if hasattr(self.phase1_lifetime_seconds, 'to_dict'):
                props['Phase1LifetimeSeconds'] = self.phase1_lifetime_seconds.to_dict()
            elif isinstance(self.phase1_lifetime_seconds, list):
                props['Phase1LifetimeSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.phase1_lifetime_seconds
                ]
            else:
                props['Phase1LifetimeSeconds'] = self.phase1_lifetime_seconds

        if self.rekey_fuzz_percentage is not None:
            if hasattr(self.rekey_fuzz_percentage, 'to_dict'):
                props['RekeyFuzzPercentage'] = self.rekey_fuzz_percentage.to_dict()
            elif isinstance(self.rekey_fuzz_percentage, list):
                props['RekeyFuzzPercentage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rekey_fuzz_percentage
                ]
            else:
                props['RekeyFuzzPercentage'] = self.rekey_fuzz_percentage

        if self.phase1_encryption_algorithms is not None:
            if hasattr(self.phase1_encryption_algorithms, 'to_dict'):
                props['Phase1EncryptionAlgorithms'] = self.phase1_encryption_algorithms.to_dict()
            elif isinstance(self.phase1_encryption_algorithms, list):
                props['Phase1EncryptionAlgorithms'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.phase1_encryption_algorithms
                ]
            else:
                props['Phase1EncryptionAlgorithms'] = self.phase1_encryption_algorithms

        if self.dpd_timeout_seconds is not None:
            if hasattr(self.dpd_timeout_seconds, 'to_dict'):
                props['DPDTimeoutSeconds'] = self.dpd_timeout_seconds.to_dict()
            elif isinstance(self.dpd_timeout_seconds, list):
                props['DPDTimeoutSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dpd_timeout_seconds
                ]
            else:
                props['DPDTimeoutSeconds'] = self.dpd_timeout_seconds

        return props


@dataclass
class VPNConnection(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPNConnection"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    remote_ipv6_network_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    remote_ipv4_network_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpn_tunnel_options_specifications: Optional[list[VpnTunnelOptionsSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    customer_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    outside_ip_address_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    static_routes_only: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_acceleration: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tunnel_bandwidth: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_ipv4_network_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpn_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpn_concentrator_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    pre_shared_key_storage: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transport_transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_ipv6_network_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tunnel_inside_ip_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.remote_ipv6_network_cidr is not None:
            # Serialize remote_ipv6_network_cidr (handle intrinsic functions)
            if hasattr(self.remote_ipv6_network_cidr, 'to_dict'):
                props["RemoteIpv6NetworkCidr"] = self.remote_ipv6_network_cidr.to_dict()
            elif isinstance(self.remote_ipv6_network_cidr, list):
                # Serialize list items (may contain intrinsic functions)
                props['RemoteIpv6NetworkCidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.remote_ipv6_network_cidr
                ]
            else:
                props["RemoteIpv6NetworkCidr"] = self.remote_ipv6_network_cidr

        if self.remote_ipv4_network_cidr is not None:
            # Serialize remote_ipv4_network_cidr (handle intrinsic functions)
            if hasattr(self.remote_ipv4_network_cidr, 'to_dict'):
                props["RemoteIpv4NetworkCidr"] = self.remote_ipv4_network_cidr.to_dict()
            elif isinstance(self.remote_ipv4_network_cidr, list):
                # Serialize list items (may contain intrinsic functions)
                props['RemoteIpv4NetworkCidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.remote_ipv4_network_cidr
                ]
            else:
                props["RemoteIpv4NetworkCidr"] = self.remote_ipv4_network_cidr

        if self.vpn_tunnel_options_specifications is not None:
            # Serialize vpn_tunnel_options_specifications (handle intrinsic functions)
            if hasattr(self.vpn_tunnel_options_specifications, 'to_dict'):
                props["VpnTunnelOptionsSpecifications"] = self.vpn_tunnel_options_specifications.to_dict()
            elif isinstance(self.vpn_tunnel_options_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpnTunnelOptionsSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_tunnel_options_specifications
                ]
            else:
                props["VpnTunnelOptionsSpecifications"] = self.vpn_tunnel_options_specifications

        if self.customer_gateway_id is not None:
            # Serialize customer_gateway_id (handle intrinsic functions)
            if hasattr(self.customer_gateway_id, 'to_dict'):
                props["CustomerGatewayId"] = self.customer_gateway_id.to_dict()
            elif isinstance(self.customer_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['CustomerGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customer_gateway_id
                ]
            else:
                props["CustomerGatewayId"] = self.customer_gateway_id

        if self.outside_ip_address_type is not None:
            # Serialize outside_ip_address_type (handle intrinsic functions)
            if hasattr(self.outside_ip_address_type, 'to_dict'):
                props["OutsideIpAddressType"] = self.outside_ip_address_type.to_dict()
            elif isinstance(self.outside_ip_address_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutsideIpAddressType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.outside_ip_address_type
                ]
            else:
                props["OutsideIpAddressType"] = self.outside_ip_address_type

        if self.static_routes_only is not None:
            # Serialize static_routes_only (handle intrinsic functions)
            if hasattr(self.static_routes_only, 'to_dict'):
                props["StaticRoutesOnly"] = self.static_routes_only.to_dict()
            elif isinstance(self.static_routes_only, list):
                # Serialize list items (may contain intrinsic functions)
                props['StaticRoutesOnly'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.static_routes_only
                ]
            else:
                props["StaticRoutesOnly"] = self.static_routes_only

        if self.enable_acceleration is not None:
            # Serialize enable_acceleration (handle intrinsic functions)
            if hasattr(self.enable_acceleration, 'to_dict'):
                props["EnableAcceleration"] = self.enable_acceleration.to_dict()
            elif isinstance(self.enable_acceleration, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableAcceleration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_acceleration
                ]
            else:
                props["EnableAcceleration"] = self.enable_acceleration

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.tunnel_bandwidth is not None:
            # Serialize tunnel_bandwidth (handle intrinsic functions)
            if hasattr(self.tunnel_bandwidth, 'to_dict'):
                props["TunnelBandwidth"] = self.tunnel_bandwidth.to_dict()
            elif isinstance(self.tunnel_bandwidth, list):
                # Serialize list items (may contain intrinsic functions)
                props['TunnelBandwidth'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tunnel_bandwidth
                ]
            else:
                props["TunnelBandwidth"] = self.tunnel_bandwidth

        if self.local_ipv4_network_cidr is not None:
            # Serialize local_ipv4_network_cidr (handle intrinsic functions)
            if hasattr(self.local_ipv4_network_cidr, 'to_dict'):
                props["LocalIpv4NetworkCidr"] = self.local_ipv4_network_cidr.to_dict()
            elif isinstance(self.local_ipv4_network_cidr, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalIpv4NetworkCidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_ipv4_network_cidr
                ]
            else:
                props["LocalIpv4NetworkCidr"] = self.local_ipv4_network_cidr

        if self.vpn_gateway_id is not None:
            # Serialize vpn_gateway_id (handle intrinsic functions)
            if hasattr(self.vpn_gateway_id, 'to_dict'):
                props["VpnGatewayId"] = self.vpn_gateway_id.to_dict()
            elif isinstance(self.vpn_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpnGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_gateway_id
                ]
            else:
                props["VpnGatewayId"] = self.vpn_gateway_id

        if self.vpn_concentrator_id is not None:
            # Serialize vpn_concentrator_id (handle intrinsic functions)
            if hasattr(self.vpn_concentrator_id, 'to_dict'):
                props["VpnConcentratorId"] = self.vpn_concentrator_id.to_dict()
            elif isinstance(self.vpn_concentrator_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpnConcentratorId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_concentrator_id
                ]
            else:
                props["VpnConcentratorId"] = self.vpn_concentrator_id

        if self.pre_shared_key_storage is not None:
            # Serialize pre_shared_key_storage (handle intrinsic functions)
            if hasattr(self.pre_shared_key_storage, 'to_dict'):
                props["PreSharedKeyStorage"] = self.pre_shared_key_storage.to_dict()
            elif isinstance(self.pre_shared_key_storage, list):
                # Serialize list items (may contain intrinsic functions)
                props['PreSharedKeyStorage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pre_shared_key_storage
                ]
            else:
                props["PreSharedKeyStorage"] = self.pre_shared_key_storage

        if self.transport_transit_gateway_attachment_id is not None:
            # Serialize transport_transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.transport_transit_gateway_attachment_id, 'to_dict'):
                props["TransportTransitGatewayAttachmentId"] = self.transport_transit_gateway_attachment_id.to_dict()
            elif isinstance(self.transport_transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransportTransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transport_transit_gateway_attachment_id
                ]
            else:
                props["TransportTransitGatewayAttachmentId"] = self.transport_transit_gateway_attachment_id

        if self.local_ipv6_network_cidr is not None:
            # Serialize local_ipv6_network_cidr (handle intrinsic functions)
            if hasattr(self.local_ipv6_network_cidr, 'to_dict'):
                props["LocalIpv6NetworkCidr"] = self.local_ipv6_network_cidr.to_dict()
            elif isinstance(self.local_ipv6_network_cidr, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalIpv6NetworkCidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_ipv6_network_cidr
                ]
            else:
                props["LocalIpv6NetworkCidr"] = self.local_ipv6_network_cidr

        if self.tunnel_inside_ip_version is not None:
            # Serialize tunnel_inside_ip_version (handle intrinsic functions)
            if hasattr(self.tunnel_inside_ip_version, 'to_dict'):
                props["TunnelInsideIpVersion"] = self.tunnel_inside_ip_version.to_dict()
            elif isinstance(self.tunnel_inside_ip_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['TunnelInsideIpVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tunnel_inside_ip_version
                ]
            else:
                props["TunnelInsideIpVersion"] = self.tunnel_inside_ip_version

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_vpn_connection_id(self) -> GetAtt:
        """Get the VpnConnectionId attribute."""
        return self.get_att("VpnConnectionId")




@dataclass
class VPNConnectionRoute(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPNConnectionRoute"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpn_connection_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination_cidr_block is not None:
            # Serialize destination_cidr_block (handle intrinsic functions)
            if hasattr(self.destination_cidr_block, 'to_dict'):
                props["DestinationCidrBlock"] = self.destination_cidr_block.to_dict()
            elif isinstance(self.destination_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr_block
                ]
            else:
                props["DestinationCidrBlock"] = self.destination_cidr_block

        if self.vpn_connection_id is not None:
            # Serialize vpn_connection_id (handle intrinsic functions)
            if hasattr(self.vpn_connection_id, 'to_dict'):
                props["VpnConnectionId"] = self.vpn_connection_id.to_dict()
            elif isinstance(self.vpn_connection_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpnConnectionId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_connection_id
                ]
            else:
                props["VpnConnectionId"] = self.vpn_connection_id

        return props



@dataclass
class VPNGateway(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPNGateway"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    amazon_side_asn: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.amazon_side_asn is not None:
            # Serialize amazon_side_asn (handle intrinsic functions)
            if hasattr(self.amazon_side_asn, 'to_dict'):
                props["AmazonSideAsn"] = self.amazon_side_asn.to_dict()
            elif isinstance(self.amazon_side_asn, list):
                # Serialize list items (may contain intrinsic functions)
                props['AmazonSideAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.amazon_side_asn
                ]
            else:
                props["AmazonSideAsn"] = self.amazon_side_asn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_vpn_gateway_id(self) -> GetAtt:
        """Get the VPNGatewayId attribute."""
        return self.get_att("VPNGatewayId")




@dataclass
class VPNGatewayRoutePropagation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPNGatewayRoutePropagation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_table_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpn_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.route_table_ids is not None:
            # Serialize route_table_ids (handle intrinsic functions)
            if hasattr(self.route_table_ids, 'to_dict'):
                props["RouteTableIds"] = self.route_table_ids.to_dict()
            elif isinstance(self.route_table_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteTableIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_ids
                ]
            else:
                props["RouteTableIds"] = self.route_table_ids

        if self.vpn_gateway_id is not None:
            # Serialize vpn_gateway_id (handle intrinsic functions)
            if hasattr(self.vpn_gateway_id, 'to_dict'):
                props["VpnGatewayId"] = self.vpn_gateway_id.to_dict()
            elif isinstance(self.vpn_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpnGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_gateway_id
                ]
            else:
                props["VpnGatewayId"] = self.vpn_gateway_id

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class CidrOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port_ranges: Optional[list[PortRange]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cidr is not None:
            if hasattr(self.cidr, 'to_dict'):
                props['Cidr'] = self.cidr.to_dict()
            elif isinstance(self.cidr, list):
                props['Cidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr
                ]
            else:
                props['Cidr'] = self.cidr

        if self.port_ranges is not None:
            if hasattr(self.port_ranges, 'to_dict'):
                props['PortRanges'] = self.port_ranges.to_dict()
            elif isinstance(self.port_ranges, list):
                props['PortRanges'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port_ranges
                ]
            else:
                props['PortRanges'] = self.port_ranges

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        if self.subnet_ids is not None:
            if hasattr(self.subnet_ids, 'to_dict'):
                props['SubnetIds'] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props['SubnetIds'] = self.subnet_ids

        return props


@dataclass
class LoadBalancerOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancer_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port_ranges: Optional[list[PortRange]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.load_balancer_arn is not None:
            if hasattr(self.load_balancer_arn, 'to_dict'):
                props['LoadBalancerArn'] = self.load_balancer_arn.to_dict()
            elif isinstance(self.load_balancer_arn, list):
                props['LoadBalancerArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_arn
                ]
            else:
                props['LoadBalancerArn'] = self.load_balancer_arn

        if self.port is not None:
            if hasattr(self.port, 'to_dict'):
                props['Port'] = self.port.to_dict()
            elif isinstance(self.port, list):
                props['Port'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port
                ]
            else:
                props['Port'] = self.port

        if self.port_ranges is not None:
            if hasattr(self.port_ranges, 'to_dict'):
                props['PortRanges'] = self.port_ranges.to_dict()
            elif isinstance(self.port_ranges, list):
                props['PortRanges'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port_ranges
                ]
            else:
                props['PortRanges'] = self.port_ranges

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        if self.subnet_ids is not None:
            if hasattr(self.subnet_ids, 'to_dict'):
                props['SubnetIds'] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props['SubnetIds'] = self.subnet_ids

        return props


@dataclass
class NetworkInterfaceOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port_ranges: Optional[list[PortRange]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.port is not None:
            if hasattr(self.port, 'to_dict'):
                props['Port'] = self.port.to_dict()
            elif isinstance(self.port, list):
                props['Port'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port
                ]
            else:
                props['Port'] = self.port

        if self.port_ranges is not None:
            if hasattr(self.port_ranges, 'to_dict'):
                props['PortRanges'] = self.port_ranges.to_dict()
            elif isinstance(self.port_ranges, list):
                props['PortRanges'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port_ranges
                ]
            else:
                props['PortRanges'] = self.port_ranges

        if self.network_interface_id is not None:
            if hasattr(self.network_interface_id, 'to_dict'):
                props['NetworkInterfaceId'] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props['NetworkInterfaceId'] = self.network_interface_id

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        return props


@dataclass
class PortRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.from_port is not None:
            if hasattr(self.from_port, 'to_dict'):
                props['FromPort'] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props['FromPort'] = self.from_port

        if self.to_port is not None:
            if hasattr(self.to_port, 'to_dict'):
                props['ToPort'] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props['ToPort'] = self.to_port

        return props


@dataclass
class RdsOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rds_db_proxy_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rds_db_cluster_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rds_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rds_db_instance_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.rds_db_proxy_arn is not None:
            if hasattr(self.rds_db_proxy_arn, 'to_dict'):
                props['RdsDbProxyArn'] = self.rds_db_proxy_arn.to_dict()
            elif isinstance(self.rds_db_proxy_arn, list):
                props['RdsDbProxyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rds_db_proxy_arn
                ]
            else:
                props['RdsDbProxyArn'] = self.rds_db_proxy_arn

        if self.rds_db_cluster_arn is not None:
            if hasattr(self.rds_db_cluster_arn, 'to_dict'):
                props['RdsDbClusterArn'] = self.rds_db_cluster_arn.to_dict()
            elif isinstance(self.rds_db_cluster_arn, list):
                props['RdsDbClusterArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rds_db_cluster_arn
                ]
            else:
                props['RdsDbClusterArn'] = self.rds_db_cluster_arn

        if self.rds_endpoint is not None:
            if hasattr(self.rds_endpoint, 'to_dict'):
                props['RdsEndpoint'] = self.rds_endpoint.to_dict()
            elif isinstance(self.rds_endpoint, list):
                props['RdsEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rds_endpoint
                ]
            else:
                props['RdsEndpoint'] = self.rds_endpoint

        if self.port is not None:
            if hasattr(self.port, 'to_dict'):
                props['Port'] = self.port.to_dict()
            elif isinstance(self.port, list):
                props['Port'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port
                ]
            else:
                props['Port'] = self.port

        if self.rds_db_instance_arn is not None:
            if hasattr(self.rds_db_instance_arn, 'to_dict'):
                props['RdsDbInstanceArn'] = self.rds_db_instance_arn.to_dict()
            elif isinstance(self.rds_db_instance_arn, list):
                props['RdsDbInstanceArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rds_db_instance_arn
                ]
            else:
                props['RdsDbInstanceArn'] = self.rds_db_instance_arn

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        if self.subnet_ids is not None:
            if hasattr(self.subnet_ids, 'to_dict'):
                props['SubnetIds'] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props['SubnetIds'] = self.subnet_ids

        return props


@dataclass
class SseSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customer_managed_key_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.customer_managed_key_enabled is not None:
            if hasattr(self.customer_managed_key_enabled, 'to_dict'):
                props['CustomerManagedKeyEnabled'] = self.customer_managed_key_enabled.to_dict()
            elif isinstance(self.customer_managed_key_enabled, list):
                props['CustomerManagedKeyEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customer_managed_key_enabled
                ]
            else:
                props['CustomerManagedKeyEnabled'] = self.customer_managed_key_enabled

        if self.kms_key_arn is not None:
            if hasattr(self.kms_key_arn, 'to_dict'):
                props['KmsKeyArn'] = self.kms_key_arn.to_dict()
            elif isinstance(self.kms_key_arn, list):
                props['KmsKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_arn
                ]
            else:
                props['KmsKeyArn'] = self.kms_key_arn

        return props


@dataclass
class VerifiedAccessEndpoint(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VerifiedAccessEndpoint"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    attachment_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_certificate_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    verified_access_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    load_balancer_options: Optional[LoadBalancerOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    application_domain: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_options: Optional[CidrOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    endpoint_domain_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    endpoint_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_document: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rds_options: Optional[RdsOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sse_specification: Optional[SseSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_options: Optional[NetworkInterfaceOptions] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.attachment_type is not None:
            # Serialize attachment_type (handle intrinsic functions)
            if hasattr(self.attachment_type, 'to_dict'):
                props["AttachmentType"] = self.attachment_type.to_dict()
            elif isinstance(self.attachment_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['AttachmentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attachment_type
                ]
            else:
                props["AttachmentType"] = self.attachment_type

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.domain_certificate_arn is not None:
            # Serialize domain_certificate_arn (handle intrinsic functions)
            if hasattr(self.domain_certificate_arn, 'to_dict'):
                props["DomainCertificateArn"] = self.domain_certificate_arn.to_dict()
            elif isinstance(self.domain_certificate_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainCertificateArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_certificate_arn
                ]
            else:
                props["DomainCertificateArn"] = self.domain_certificate_arn

        if self.verified_access_group_id is not None:
            # Serialize verified_access_group_id (handle intrinsic functions)
            if hasattr(self.verified_access_group_id, 'to_dict'):
                props["VerifiedAccessGroupId"] = self.verified_access_group_id.to_dict()
            elif isinstance(self.verified_access_group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VerifiedAccessGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.verified_access_group_id
                ]
            else:
                props["VerifiedAccessGroupId"] = self.verified_access_group_id

        if self.security_group_ids is not None:
            # Serialize security_group_ids (handle intrinsic functions)
            if hasattr(self.security_group_ids, 'to_dict'):
                props["SecurityGroupIds"] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props["SecurityGroupIds"] = self.security_group_ids

        if self.load_balancer_options is not None:
            # Serialize load_balancer_options (handle intrinsic functions)
            if hasattr(self.load_balancer_options, 'to_dict'):
                props["LoadBalancerOptions"] = self.load_balancer_options.to_dict()
            elif isinstance(self.load_balancer_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['LoadBalancerOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_options
                ]
            else:
                props["LoadBalancerOptions"] = self.load_balancer_options

        if self.application_domain is not None:
            # Serialize application_domain (handle intrinsic functions)
            if hasattr(self.application_domain, 'to_dict'):
                props["ApplicationDomain"] = self.application_domain.to_dict()
            elif isinstance(self.application_domain, list):
                # Serialize list items (may contain intrinsic functions)
                props['ApplicationDomain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.application_domain
                ]
            else:
                props["ApplicationDomain"] = self.application_domain

        if self.policy_enabled is not None:
            # Serialize policy_enabled (handle intrinsic functions)
            if hasattr(self.policy_enabled, 'to_dict'):
                props["PolicyEnabled"] = self.policy_enabled.to_dict()
            elif isinstance(self.policy_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_enabled
                ]
            else:
                props["PolicyEnabled"] = self.policy_enabled

        if self.cidr_options is not None:
            # Serialize cidr_options (handle intrinsic functions)
            if hasattr(self.cidr_options, 'to_dict'):
                props["CidrOptions"] = self.cidr_options.to_dict()
            elif isinstance(self.cidr_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_options
                ]
            else:
                props["CidrOptions"] = self.cidr_options

        if self.endpoint_domain_prefix is not None:
            # Serialize endpoint_domain_prefix (handle intrinsic functions)
            if hasattr(self.endpoint_domain_prefix, 'to_dict'):
                props["EndpointDomainPrefix"] = self.endpoint_domain_prefix.to_dict()
            elif isinstance(self.endpoint_domain_prefix, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndpointDomainPrefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_domain_prefix
                ]
            else:
                props["EndpointDomainPrefix"] = self.endpoint_domain_prefix

        if self.endpoint_type is not None:
            # Serialize endpoint_type (handle intrinsic functions)
            if hasattr(self.endpoint_type, 'to_dict'):
                props["EndpointType"] = self.endpoint_type.to_dict()
            elif isinstance(self.endpoint_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndpointType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_type
                ]
            else:
                props["EndpointType"] = self.endpoint_type

        if self.policy_document is not None:
            # Serialize policy_document (handle intrinsic functions)
            if hasattr(self.policy_document, 'to_dict'):
                props["PolicyDocument"] = self.policy_document.to_dict()
            elif isinstance(self.policy_document, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyDocument'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_document
                ]
            else:
                props["PolicyDocument"] = self.policy_document

        if self.rds_options is not None:
            # Serialize rds_options (handle intrinsic functions)
            if hasattr(self.rds_options, 'to_dict'):
                props["RdsOptions"] = self.rds_options.to_dict()
            elif isinstance(self.rds_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['RdsOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rds_options
                ]
            else:
                props["RdsOptions"] = self.rds_options

        if self.sse_specification is not None:
            # Serialize sse_specification (handle intrinsic functions)
            if hasattr(self.sse_specification, 'to_dict'):
                props["SseSpecification"] = self.sse_specification.to_dict()
            elif isinstance(self.sse_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['SseSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sse_specification
                ]
            else:
                props["SseSpecification"] = self.sse_specification

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.network_interface_options is not None:
            # Serialize network_interface_options (handle intrinsic functions)
            if hasattr(self.network_interface_options, 'to_dict'):
                props["NetworkInterfaceOptions"] = self.network_interface_options.to_dict()
            elif isinstance(self.network_interface_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_options
                ]
            else:
                props["NetworkInterfaceOptions"] = self.network_interface_options

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_endpoint_domain(self) -> GetAtt:
        """Get the EndpointDomain attribute."""
        return self.get_att("EndpointDomain")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_last_updated_time(self) -> GetAtt:
        """Get the LastUpdatedTime attribute."""
        return self.get_att("LastUpdatedTime")

    @property
    def attr_device_validation_domain(self) -> GetAtt:
        """Get the DeviceValidationDomain attribute."""
        return self.get_att("DeviceValidationDomain")

    @property
    def attr_verified_access_instance_id(self) -> GetAtt:
        """Get the VerifiedAccessInstanceId attribute."""
        return self.get_att("VerifiedAccessInstanceId")

    @property
    def attr_verified_access_endpoint_id(self) -> GetAtt:
        """Get the VerifiedAccessEndpointId attribute."""
        return self.get_att("VerifiedAccessEndpointId")




@dataclass
class SseSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customer_managed_key_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.customer_managed_key_enabled is not None:
            if hasattr(self.customer_managed_key_enabled, 'to_dict'):
                props['CustomerManagedKeyEnabled'] = self.customer_managed_key_enabled.to_dict()
            elif isinstance(self.customer_managed_key_enabled, list):
                props['CustomerManagedKeyEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customer_managed_key_enabled
                ]
            else:
                props['CustomerManagedKeyEnabled'] = self.customer_managed_key_enabled

        if self.kms_key_arn is not None:
            if hasattr(self.kms_key_arn, 'to_dict'):
                props['KmsKeyArn'] = self.kms_key_arn.to_dict()
            elif isinstance(self.kms_key_arn, list):
                props['KmsKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_arn
                ]
            else:
                props['KmsKeyArn'] = self.kms_key_arn

        return props


@dataclass
class VerifiedAccessGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VerifiedAccessGroup"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_document: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sse_specification: Optional[SseSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    verified_access_instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.policy_document is not None:
            # Serialize policy_document (handle intrinsic functions)
            if hasattr(self.policy_document, 'to_dict'):
                props["PolicyDocument"] = self.policy_document.to_dict()
            elif isinstance(self.policy_document, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyDocument'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_document
                ]
            else:
                props["PolicyDocument"] = self.policy_document

        if self.sse_specification is not None:
            # Serialize sse_specification (handle intrinsic functions)
            if hasattr(self.sse_specification, 'to_dict'):
                props["SseSpecification"] = self.sse_specification.to_dict()
            elif isinstance(self.sse_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['SseSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sse_specification
                ]
            else:
                props["SseSpecification"] = self.sse_specification

        if self.verified_access_instance_id is not None:
            # Serialize verified_access_instance_id (handle intrinsic functions)
            if hasattr(self.verified_access_instance_id, 'to_dict'):
                props["VerifiedAccessInstanceId"] = self.verified_access_instance_id.to_dict()
            elif isinstance(self.verified_access_instance_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VerifiedAccessInstanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.verified_access_instance_id
                ]
            else:
                props["VerifiedAccessInstanceId"] = self.verified_access_instance_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.policy_enabled is not None:
            # Serialize policy_enabled (handle intrinsic functions)
            if hasattr(self.policy_enabled, 'to_dict'):
                props["PolicyEnabled"] = self.policy_enabled.to_dict()
            elif isinstance(self.policy_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_enabled
                ]
            else:
                props["PolicyEnabled"] = self.policy_enabled

        return props

    @property
    def attr_owner(self) -> GetAtt:
        """Get the Owner attribute."""
        return self.get_att("Owner")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_last_updated_time(self) -> GetAtt:
        """Get the LastUpdatedTime attribute."""
        return self.get_att("LastUpdatedTime")

    @property
    def attr_verified_access_group_id(self) -> GetAtt:
        """Get the VerifiedAccessGroupId attribute."""
        return self.get_att("VerifiedAccessGroupId")

    @property
    def attr_verified_access_group_arn(self) -> GetAtt:
        """Get the VerifiedAccessGroupArn attribute."""
        return self.get_att("VerifiedAccessGroupArn")




@dataclass
class CloudWatchLogs:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.log_group is not None:
            if hasattr(self.log_group, 'to_dict'):
                props['LogGroup'] = self.log_group.to_dict()
            elif isinstance(self.log_group, list):
                props['LogGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group
                ]
            else:
                props['LogGroup'] = self.log_group

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class KinesisDataFirehose:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delivery_stream: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.delivery_stream is not None:
            if hasattr(self.delivery_stream, 'to_dict'):
                props['DeliveryStream'] = self.delivery_stream.to_dict()
            elif isinstance(self.delivery_stream, list):
                props['DeliveryStream'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delivery_stream
                ]
            else:
                props['DeliveryStream'] = self.delivery_stream

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class S3:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket_owner: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.bucket_name is not None:
            if hasattr(self.bucket_name, 'to_dict'):
                props['BucketName'] = self.bucket_name.to_dict()
            elif isinstance(self.bucket_name, list):
                props['BucketName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket_name
                ]
            else:
                props['BucketName'] = self.bucket_name

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        if self.prefix is not None:
            if hasattr(self.prefix, 'to_dict'):
                props['Prefix'] = self.prefix.to_dict()
            elif isinstance(self.prefix, list):
                props['Prefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.prefix
                ]
            else:
                props['Prefix'] = self.prefix

        if self.bucket_owner is not None:
            if hasattr(self.bucket_owner, 'to_dict'):
                props['BucketOwner'] = self.bucket_owner.to_dict()
            elif isinstance(self.bucket_owner, list):
                props['BucketOwner'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket_owner
                ]
            else:
                props['BucketOwner'] = self.bucket_owner

        return props


@dataclass
class VerifiedAccessLogs:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3: Optional[S3] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kinesis_data_firehose: Optional[KinesisDataFirehose] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logs: Optional[CloudWatchLogs] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    include_trust_context: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3 is not None:
            if hasattr(self.s3, 'to_dict'):
                props['S3'] = self.s3.to_dict()
            elif isinstance(self.s3, list):
                props['S3'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3
                ]
            else:
                props['S3'] = self.s3

        if self.log_version is not None:
            if hasattr(self.log_version, 'to_dict'):
                props['LogVersion'] = self.log_version.to_dict()
            elif isinstance(self.log_version, list):
                props['LogVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_version
                ]
            else:
                props['LogVersion'] = self.log_version

        if self.kinesis_data_firehose is not None:
            if hasattr(self.kinesis_data_firehose, 'to_dict'):
                props['KinesisDataFirehose'] = self.kinesis_data_firehose.to_dict()
            elif isinstance(self.kinesis_data_firehose, list):
                props['KinesisDataFirehose'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kinesis_data_firehose
                ]
            else:
                props['KinesisDataFirehose'] = self.kinesis_data_firehose

        if self.cloud_watch_logs is not None:
            if hasattr(self.cloud_watch_logs, 'to_dict'):
                props['CloudWatchLogs'] = self.cloud_watch_logs.to_dict()
            elif isinstance(self.cloud_watch_logs, list):
                props['CloudWatchLogs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cloud_watch_logs
                ]
            else:
                props['CloudWatchLogs'] = self.cloud_watch_logs

        if self.include_trust_context is not None:
            if hasattr(self.include_trust_context, 'to_dict'):
                props['IncludeTrustContext'] = self.include_trust_context.to_dict()
            elif isinstance(self.include_trust_context, list):
                props['IncludeTrustContext'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.include_trust_context
                ]
            else:
                props['IncludeTrustContext'] = self.include_trust_context

        return props


@dataclass
class VerifiedAccessTrustProvider:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_trust_provider_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    verified_access_trust_provider_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    trust_provider_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_trust_provider_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.device_trust_provider_type is not None:
            if hasattr(self.device_trust_provider_type, 'to_dict'):
                props['DeviceTrustProviderType'] = self.device_trust_provider_type.to_dict()
            elif isinstance(self.device_trust_provider_type, list):
                props['DeviceTrustProviderType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_trust_provider_type
                ]
            else:
                props['DeviceTrustProviderType'] = self.device_trust_provider_type

        if self.verified_access_trust_provider_id is not None:
            if hasattr(self.verified_access_trust_provider_id, 'to_dict'):
                props['VerifiedAccessTrustProviderId'] = self.verified_access_trust_provider_id.to_dict()
            elif isinstance(self.verified_access_trust_provider_id, list):
                props['VerifiedAccessTrustProviderId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.verified_access_trust_provider_id
                ]
            else:
                props['VerifiedAccessTrustProviderId'] = self.verified_access_trust_provider_id

        if self.trust_provider_type is not None:
            if hasattr(self.trust_provider_type, 'to_dict'):
                props['TrustProviderType'] = self.trust_provider_type.to_dict()
            elif isinstance(self.trust_provider_type, list):
                props['TrustProviderType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.trust_provider_type
                ]
            else:
                props['TrustProviderType'] = self.trust_provider_type

        if self.user_trust_provider_type is not None:
            if hasattr(self.user_trust_provider_type, 'to_dict'):
                props['UserTrustProviderType'] = self.user_trust_provider_type.to_dict()
            elif isinstance(self.user_trust_provider_type, list):
                props['UserTrustProviderType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_trust_provider_type
                ]
            else:
                props['UserTrustProviderType'] = self.user_trust_provider_type

        return props


@dataclass
class VerifiedAccessInstance(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VerifiedAccessInstance"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    verified_access_trust_providers: Optional[list[VerifiedAccessTrustProvider]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    fips_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    logging_configurations: Optional[VerifiedAccessLogs] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_endpoints_custom_sub_domain: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    verified_access_trust_provider_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.verified_access_trust_providers is not None:
            # Serialize verified_access_trust_providers (handle intrinsic functions)
            if hasattr(self.verified_access_trust_providers, 'to_dict'):
                props["VerifiedAccessTrustProviders"] = self.verified_access_trust_providers.to_dict()
            elif isinstance(self.verified_access_trust_providers, list):
                # Serialize list items (may contain intrinsic functions)
                props['VerifiedAccessTrustProviders'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.verified_access_trust_providers
                ]
            else:
                props["VerifiedAccessTrustProviders"] = self.verified_access_trust_providers

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.fips_enabled is not None:
            # Serialize fips_enabled (handle intrinsic functions)
            if hasattr(self.fips_enabled, 'to_dict'):
                props["FipsEnabled"] = self.fips_enabled.to_dict()
            elif isinstance(self.fips_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['FipsEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fips_enabled
                ]
            else:
                props["FipsEnabled"] = self.fips_enabled

        if self.logging_configurations is not None:
            # Serialize logging_configurations (handle intrinsic functions)
            if hasattr(self.logging_configurations, 'to_dict'):
                props["LoggingConfigurations"] = self.logging_configurations.to_dict()
            elif isinstance(self.logging_configurations, list):
                # Serialize list items (may contain intrinsic functions)
                props['LoggingConfigurations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.logging_configurations
                ]
            else:
                props["LoggingConfigurations"] = self.logging_configurations

        if self.cidr_endpoints_custom_sub_domain is not None:
            # Serialize cidr_endpoints_custom_sub_domain (handle intrinsic functions)
            if hasattr(self.cidr_endpoints_custom_sub_domain, 'to_dict'):
                props["CidrEndpointsCustomSubDomain"] = self.cidr_endpoints_custom_sub_domain.to_dict()
            elif isinstance(self.cidr_endpoints_custom_sub_domain, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrEndpointsCustomSubDomain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_endpoints_custom_sub_domain
                ]
            else:
                props["CidrEndpointsCustomSubDomain"] = self.cidr_endpoints_custom_sub_domain

        if self.verified_access_trust_provider_ids is not None:
            # Serialize verified_access_trust_provider_ids (handle intrinsic functions)
            if hasattr(self.verified_access_trust_provider_ids, 'to_dict'):
                props["VerifiedAccessTrustProviderIds"] = self.verified_access_trust_provider_ids.to_dict()
            elif isinstance(self.verified_access_trust_provider_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['VerifiedAccessTrustProviderIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.verified_access_trust_provider_ids
                ]
            else:
                props["VerifiedAccessTrustProviderIds"] = self.verified_access_trust_provider_ids

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_cidr_endpoints_custom_sub_domain_name_servers(self) -> GetAtt:
        """Get the CidrEndpointsCustomSubDomainNameServers attribute."""
        return self.get_att("CidrEndpointsCustomSubDomainNameServers")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_last_updated_time(self) -> GetAtt:
        """Get the LastUpdatedTime attribute."""
        return self.get_att("LastUpdatedTime")

    @property
    def attr_verified_access_instance_id(self) -> GetAtt:
        """Get the VerifiedAccessInstanceId attribute."""
        return self.get_att("VerifiedAccessInstanceId")




@dataclass
class DeviceOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tenant_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    public_signing_key_url: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.tenant_id is not None:
            if hasattr(self.tenant_id, 'to_dict'):
                props['TenantId'] = self.tenant_id.to_dict()
            elif isinstance(self.tenant_id, list):
                props['TenantId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tenant_id
                ]
            else:
                props['TenantId'] = self.tenant_id

        if self.public_signing_key_url is not None:
            if hasattr(self.public_signing_key_url, 'to_dict'):
                props['PublicSigningKeyUrl'] = self.public_signing_key_url.to_dict()
            elif isinstance(self.public_signing_key_url, list):
                props['PublicSigningKeyUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_signing_key_url
                ]
            else:
                props['PublicSigningKeyUrl'] = self.public_signing_key_url

        return props


@dataclass
class NativeApplicationOidcOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    token_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scope: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    issuer: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    client_secret: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_info_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    client_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    authorization_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    public_signing_key_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.token_endpoint is not None:
            if hasattr(self.token_endpoint, 'to_dict'):
                props['TokenEndpoint'] = self.token_endpoint.to_dict()
            elif isinstance(self.token_endpoint, list):
                props['TokenEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.token_endpoint
                ]
            else:
                props['TokenEndpoint'] = self.token_endpoint

        if self.scope is not None:
            if hasattr(self.scope, 'to_dict'):
                props['Scope'] = self.scope.to_dict()
            elif isinstance(self.scope, list):
                props['Scope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scope
                ]
            else:
                props['Scope'] = self.scope

        if self.issuer is not None:
            if hasattr(self.issuer, 'to_dict'):
                props['Issuer'] = self.issuer.to_dict()
            elif isinstance(self.issuer, list):
                props['Issuer'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.issuer
                ]
            else:
                props['Issuer'] = self.issuer

        if self.client_secret is not None:
            if hasattr(self.client_secret, 'to_dict'):
                props['ClientSecret'] = self.client_secret.to_dict()
            elif isinstance(self.client_secret, list):
                props['ClientSecret'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_secret
                ]
            else:
                props['ClientSecret'] = self.client_secret

        if self.user_info_endpoint is not None:
            if hasattr(self.user_info_endpoint, 'to_dict'):
                props['UserInfoEndpoint'] = self.user_info_endpoint.to_dict()
            elif isinstance(self.user_info_endpoint, list):
                props['UserInfoEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_info_endpoint
                ]
            else:
                props['UserInfoEndpoint'] = self.user_info_endpoint

        if self.client_id is not None:
            if hasattr(self.client_id, 'to_dict'):
                props['ClientId'] = self.client_id.to_dict()
            elif isinstance(self.client_id, list):
                props['ClientId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_id
                ]
            else:
                props['ClientId'] = self.client_id

        if self.authorization_endpoint is not None:
            if hasattr(self.authorization_endpoint, 'to_dict'):
                props['AuthorizationEndpoint'] = self.authorization_endpoint.to_dict()
            elif isinstance(self.authorization_endpoint, list):
                props['AuthorizationEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.authorization_endpoint
                ]
            else:
                props['AuthorizationEndpoint'] = self.authorization_endpoint

        if self.public_signing_key_endpoint is not None:
            if hasattr(self.public_signing_key_endpoint, 'to_dict'):
                props['PublicSigningKeyEndpoint'] = self.public_signing_key_endpoint.to_dict()
            elif isinstance(self.public_signing_key_endpoint, list):
                props['PublicSigningKeyEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_signing_key_endpoint
                ]
            else:
                props['PublicSigningKeyEndpoint'] = self.public_signing_key_endpoint

        return props


@dataclass
class OidcOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    token_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scope: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    issuer: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    client_secret: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_info_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    client_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    authorization_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.token_endpoint is not None:
            if hasattr(self.token_endpoint, 'to_dict'):
                props['TokenEndpoint'] = self.token_endpoint.to_dict()
            elif isinstance(self.token_endpoint, list):
                props['TokenEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.token_endpoint
                ]
            else:
                props['TokenEndpoint'] = self.token_endpoint

        if self.scope is not None:
            if hasattr(self.scope, 'to_dict'):
                props['Scope'] = self.scope.to_dict()
            elif isinstance(self.scope, list):
                props['Scope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scope
                ]
            else:
                props['Scope'] = self.scope

        if self.issuer is not None:
            if hasattr(self.issuer, 'to_dict'):
                props['Issuer'] = self.issuer.to_dict()
            elif isinstance(self.issuer, list):
                props['Issuer'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.issuer
                ]
            else:
                props['Issuer'] = self.issuer

        if self.client_secret is not None:
            if hasattr(self.client_secret, 'to_dict'):
                props['ClientSecret'] = self.client_secret.to_dict()
            elif isinstance(self.client_secret, list):
                props['ClientSecret'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_secret
                ]
            else:
                props['ClientSecret'] = self.client_secret

        if self.user_info_endpoint is not None:
            if hasattr(self.user_info_endpoint, 'to_dict'):
                props['UserInfoEndpoint'] = self.user_info_endpoint.to_dict()
            elif isinstance(self.user_info_endpoint, list):
                props['UserInfoEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_info_endpoint
                ]
            else:
                props['UserInfoEndpoint'] = self.user_info_endpoint

        if self.client_id is not None:
            if hasattr(self.client_id, 'to_dict'):
                props['ClientId'] = self.client_id.to_dict()
            elif isinstance(self.client_id, list):
                props['ClientId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_id
                ]
            else:
                props['ClientId'] = self.client_id

        if self.authorization_endpoint is not None:
            if hasattr(self.authorization_endpoint, 'to_dict'):
                props['AuthorizationEndpoint'] = self.authorization_endpoint.to_dict()
            elif isinstance(self.authorization_endpoint, list):
                props['AuthorizationEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.authorization_endpoint
                ]
            else:
                props['AuthorizationEndpoint'] = self.authorization_endpoint

        return props


@dataclass
class SseSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customer_managed_key_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.customer_managed_key_enabled is not None:
            if hasattr(self.customer_managed_key_enabled, 'to_dict'):
                props['CustomerManagedKeyEnabled'] = self.customer_managed_key_enabled.to_dict()
            elif isinstance(self.customer_managed_key_enabled, list):
                props['CustomerManagedKeyEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customer_managed_key_enabled
                ]
            else:
                props['CustomerManagedKeyEnabled'] = self.customer_managed_key_enabled

        if self.kms_key_arn is not None:
            if hasattr(self.kms_key_arn, 'to_dict'):
                props['KmsKeyArn'] = self.kms_key_arn.to_dict()
            elif isinstance(self.kms_key_arn, list):
                props['KmsKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_arn
                ]
            else:
                props['KmsKeyArn'] = self.kms_key_arn

        return props


@dataclass
class VerifiedAccessTrustProvider(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VerifiedAccessTrustProvider"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_reference_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    device_options: Optional[DeviceOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    native_application_oidc_options: Optional[NativeApplicationOidcOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    device_trust_provider_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    oidc_options: Optional[OidcOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    trust_provider_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sse_specification: Optional[SseSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    user_trust_provider_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.policy_reference_name is not None:
            # Serialize policy_reference_name (handle intrinsic functions)
            if hasattr(self.policy_reference_name, 'to_dict'):
                props["PolicyReferenceName"] = self.policy_reference_name.to_dict()
            elif isinstance(self.policy_reference_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyReferenceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_reference_name
                ]
            else:
                props["PolicyReferenceName"] = self.policy_reference_name

        if self.device_options is not None:
            # Serialize device_options (handle intrinsic functions)
            if hasattr(self.device_options, 'to_dict'):
                props["DeviceOptions"] = self.device_options.to_dict()
            elif isinstance(self.device_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeviceOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_options
                ]
            else:
                props["DeviceOptions"] = self.device_options

        if self.native_application_oidc_options is not None:
            # Serialize native_application_oidc_options (handle intrinsic functions)
            if hasattr(self.native_application_oidc_options, 'to_dict'):
                props["NativeApplicationOidcOptions"] = self.native_application_oidc_options.to_dict()
            elif isinstance(self.native_application_oidc_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['NativeApplicationOidcOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.native_application_oidc_options
                ]
            else:
                props["NativeApplicationOidcOptions"] = self.native_application_oidc_options

        if self.device_trust_provider_type is not None:
            # Serialize device_trust_provider_type (handle intrinsic functions)
            if hasattr(self.device_trust_provider_type, 'to_dict'):
                props["DeviceTrustProviderType"] = self.device_trust_provider_type.to_dict()
            elif isinstance(self.device_trust_provider_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeviceTrustProviderType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_trust_provider_type
                ]
            else:
                props["DeviceTrustProviderType"] = self.device_trust_provider_type

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.oidc_options is not None:
            # Serialize oidc_options (handle intrinsic functions)
            if hasattr(self.oidc_options, 'to_dict'):
                props["OidcOptions"] = self.oidc_options.to_dict()
            elif isinstance(self.oidc_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['OidcOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.oidc_options
                ]
            else:
                props["OidcOptions"] = self.oidc_options

        if self.trust_provider_type is not None:
            # Serialize trust_provider_type (handle intrinsic functions)
            if hasattr(self.trust_provider_type, 'to_dict'):
                props["TrustProviderType"] = self.trust_provider_type.to_dict()
            elif isinstance(self.trust_provider_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['TrustProviderType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.trust_provider_type
                ]
            else:
                props["TrustProviderType"] = self.trust_provider_type

        if self.sse_specification is not None:
            # Serialize sse_specification (handle intrinsic functions)
            if hasattr(self.sse_specification, 'to_dict'):
                props["SseSpecification"] = self.sse_specification.to_dict()
            elif isinstance(self.sse_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['SseSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sse_specification
                ]
            else:
                props["SseSpecification"] = self.sse_specification

        if self.user_trust_provider_type is not None:
            # Serialize user_trust_provider_type (handle intrinsic functions)
            if hasattr(self.user_trust_provider_type, 'to_dict'):
                props["UserTrustProviderType"] = self.user_trust_provider_type.to_dict()
            elif isinstance(self.user_trust_provider_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['UserTrustProviderType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_trust_provider_type
                ]
            else:
                props["UserTrustProviderType"] = self.user_trust_provider_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_verified_access_trust_provider_id(self) -> GetAtt:
        """Get the VerifiedAccessTrustProviderId attribute."""
        return self.get_att("VerifiedAccessTrustProviderId")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_last_updated_time(self) -> GetAtt:
        """Get the LastUpdatedTime attribute."""
        return self.get_att("LastUpdatedTime")




@dataclass
class Volume(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::Volume"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    multi_attach_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    encrypted: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_enable_io: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    outpost_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    throughput: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    volume_initialization_rate: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    snapshot_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    volume_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_volume_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.multi_attach_enabled is not None:
            # Serialize multi_attach_enabled (handle intrinsic functions)
            if hasattr(self.multi_attach_enabled, 'to_dict'):
                props["MultiAttachEnabled"] = self.multi_attach_enabled.to_dict()
            elif isinstance(self.multi_attach_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['MultiAttachEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.multi_attach_enabled
                ]
            else:
                props["MultiAttachEnabled"] = self.multi_attach_enabled

        if self.kms_key_id is not None:
            # Serialize kms_key_id (handle intrinsic functions)
            if hasattr(self.kms_key_id, 'to_dict'):
                props["KmsKeyId"] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props["KmsKeyId"] = self.kms_key_id

        if self.encrypted is not None:
            # Serialize encrypted (handle intrinsic functions)
            if hasattr(self.encrypted, 'to_dict'):
                props["Encrypted"] = self.encrypted.to_dict()
            elif isinstance(self.encrypted, list):
                # Serialize list items (may contain intrinsic functions)
                props['Encrypted'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encrypted
                ]
            else:
                props["Encrypted"] = self.encrypted

        if self.size is not None:
            # Serialize size (handle intrinsic functions)
            if hasattr(self.size, 'to_dict'):
                props["Size"] = self.size.to_dict()
            elif isinstance(self.size, list):
                # Serialize list items (may contain intrinsic functions)
                props['Size'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.size
                ]
            else:
                props["Size"] = self.size

        if self.auto_enable_io is not None:
            # Serialize auto_enable_io (handle intrinsic functions)
            if hasattr(self.auto_enable_io, 'to_dict'):
                props["AutoEnableIO"] = self.auto_enable_io.to_dict()
            elif isinstance(self.auto_enable_io, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoEnableIO'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_enable_io
                ]
            else:
                props["AutoEnableIO"] = self.auto_enable_io

        if self.outpost_arn is not None:
            # Serialize outpost_arn (handle intrinsic functions)
            if hasattr(self.outpost_arn, 'to_dict'):
                props["OutpostArn"] = self.outpost_arn.to_dict()
            elif isinstance(self.outpost_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutpostArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.outpost_arn
                ]
            else:
                props["OutpostArn"] = self.outpost_arn

        if self.availability_zone_id is not None:
            # Serialize availability_zone_id (handle intrinsic functions)
            if hasattr(self.availability_zone_id, 'to_dict'):
                props["AvailabilityZoneId"] = self.availability_zone_id.to_dict()
            elif isinstance(self.availability_zone_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZoneId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone_id
                ]
            else:
                props["AvailabilityZoneId"] = self.availability_zone_id

        if self.availability_zone is not None:
            # Serialize availability_zone (handle intrinsic functions)
            if hasattr(self.availability_zone, 'to_dict'):
                props["AvailabilityZone"] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props["AvailabilityZone"] = self.availability_zone

        if self.throughput is not None:
            # Serialize throughput (handle intrinsic functions)
            if hasattr(self.throughput, 'to_dict'):
                props["Throughput"] = self.throughput.to_dict()
            elif isinstance(self.throughput, list):
                # Serialize list items (may contain intrinsic functions)
                props['Throughput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.throughput
                ]
            else:
                props["Throughput"] = self.throughput

        if self.iops is not None:
            # Serialize iops (handle intrinsic functions)
            if hasattr(self.iops, 'to_dict'):
                props["Iops"] = self.iops.to_dict()
            elif isinstance(self.iops, list):
                # Serialize list items (may contain intrinsic functions)
                props['Iops'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iops
                ]
            else:
                props["Iops"] = self.iops

        if self.volume_initialization_rate is not None:
            # Serialize volume_initialization_rate (handle intrinsic functions)
            if hasattr(self.volume_initialization_rate, 'to_dict'):
                props["VolumeInitializationRate"] = self.volume_initialization_rate.to_dict()
            elif isinstance(self.volume_initialization_rate, list):
                # Serialize list items (may contain intrinsic functions)
                props['VolumeInitializationRate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_initialization_rate
                ]
            else:
                props["VolumeInitializationRate"] = self.volume_initialization_rate

        if self.snapshot_id is not None:
            # Serialize snapshot_id (handle intrinsic functions)
            if hasattr(self.snapshot_id, 'to_dict'):
                props["SnapshotId"] = self.snapshot_id.to_dict()
            elif isinstance(self.snapshot_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SnapshotId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snapshot_id
                ]
            else:
                props["SnapshotId"] = self.snapshot_id

        if self.volume_type is not None:
            # Serialize volume_type (handle intrinsic functions)
            if hasattr(self.volume_type, 'to_dict'):
                props["VolumeType"] = self.volume_type.to_dict()
            elif isinstance(self.volume_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['VolumeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_type
                ]
            else:
                props["VolumeType"] = self.volume_type

        if self.source_volume_id is not None:
            # Serialize source_volume_id (handle intrinsic functions)
            if hasattr(self.source_volume_id, 'to_dict'):
                props["SourceVolumeId"] = self.source_volume_id.to_dict()
            elif isinstance(self.source_volume_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceVolumeId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_volume_id
                ]
            else:
                props["SourceVolumeId"] = self.source_volume_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_volume_id(self) -> GetAtt:
        """Get the VolumeId attribute."""
        return self.get_att("VolumeId")




@dataclass
class VolumeAttachment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VolumeAttachment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    volume_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    device: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.volume_id is not None:
            # Serialize volume_id (handle intrinsic functions)
            if hasattr(self.volume_id, 'to_dict'):
                props["VolumeId"] = self.volume_id.to_dict()
            elif isinstance(self.volume_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VolumeId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_id
                ]
            else:
                props["VolumeId"] = self.volume_id

        if self.instance_id is not None:
            # Serialize instance_id (handle intrinsic functions)
            if hasattr(self.instance_id, 'to_dict'):
                props["InstanceId"] = self.instance_id.to_dict()
            elif isinstance(self.instance_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_id
                ]
            else:
                props["InstanceId"] = self.instance_id

        if self.device is not None:
            # Serialize device (handle intrinsic functions)
            if hasattr(self.device, 'to_dict'):
                props["Device"] = self.device.to_dict()
            elif isinstance(self.device, list):
                # Serialize list items (may contain intrinsic functions)
                props['Device'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device
                ]
            else:
                props["Device"] = self.device

        return props


