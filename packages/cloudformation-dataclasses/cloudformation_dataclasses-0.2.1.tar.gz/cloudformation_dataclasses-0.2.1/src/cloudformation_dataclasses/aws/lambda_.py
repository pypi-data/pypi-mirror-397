"""
AWS CloudFormation Lambda Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 227.0.0
  Generator Version: 1.0.0
  Combined: spec-227.0.0_gen-1.0.0
  Generated: 2025-12-15 17:57:26

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service Lambda
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


@dataclass
class AliasRoutingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    additional_version_weights: Optional[list[VersionWeight]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.additional_version_weights is not None:
            if hasattr(self.additional_version_weights, 'to_dict'):
                props['AdditionalVersionWeights'] = self.additional_version_weights.to_dict()
            elif isinstance(self.additional_version_weights, list):
                props['AdditionalVersionWeights'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_version_weights
                ]
            else:
                props['AdditionalVersionWeights'] = self.additional_version_weights

        return props


@dataclass
class ProvisionedConcurrencyConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provisioned_concurrent_executions: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.provisioned_concurrent_executions is not None:
            if hasattr(self.provisioned_concurrent_executions, 'to_dict'):
                props['ProvisionedConcurrentExecutions'] = self.provisioned_concurrent_executions.to_dict()
            elif isinstance(self.provisioned_concurrent_executions, list):
                props['ProvisionedConcurrentExecutions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.provisioned_concurrent_executions
                ]
            else:
                props['ProvisionedConcurrentExecutions'] = self.provisioned_concurrent_executions

        return props


@dataclass
class VersionWeight:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    function_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    function_weight: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.function_version is not None:
            if hasattr(self.function_version, 'to_dict'):
                props['FunctionVersion'] = self.function_version.to_dict()
            elif isinstance(self.function_version, list):
                props['FunctionVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.function_version
                ]
            else:
                props['FunctionVersion'] = self.function_version

        if self.function_weight is not None:
            if hasattr(self.function_weight, 'to_dict'):
                props['FunctionWeight'] = self.function_weight.to_dict()
            elif isinstance(self.function_weight, list):
                props['FunctionWeight'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.function_weight
                ]
            else:
                props['FunctionWeight'] = self.function_weight

        return props


@dataclass
class Alias(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::Alias"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    function_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    provisioned_concurrency_config: Optional[ProvisionedConcurrencyConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    function_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    routing_config: Optional[AliasRoutingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.function_name is not None:
            # Serialize function_name (handle intrinsic functions)
            if hasattr(self.function_name, 'to_dict'):
                props["FunctionName"] = self.function_name.to_dict()
            elif isinstance(self.function_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['FunctionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.function_name
                ]
            else:
                props["FunctionName"] = self.function_name

        if self.provisioned_concurrency_config is not None:
            # Serialize provisioned_concurrency_config (handle intrinsic functions)
            if hasattr(self.provisioned_concurrency_config, 'to_dict'):
                props["ProvisionedConcurrencyConfig"] = self.provisioned_concurrency_config.to_dict()
            elif isinstance(self.provisioned_concurrency_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProvisionedConcurrencyConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.provisioned_concurrency_config
                ]
            else:
                props["ProvisionedConcurrencyConfig"] = self.provisioned_concurrency_config

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.function_version is not None:
            # Serialize function_version (handle intrinsic functions)
            if hasattr(self.function_version, 'to_dict'):
                props["FunctionVersion"] = self.function_version.to_dict()
            elif isinstance(self.function_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['FunctionVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.function_version
                ]
            else:
                props["FunctionVersion"] = self.function_version

        if self.routing_config is not None:
            # Serialize routing_config (handle intrinsic functions)
            if hasattr(self.routing_config, 'to_dict'):
                props["RoutingConfig"] = self.routing_config.to_dict()
            elif isinstance(self.routing_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoutingConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.routing_config
                ]
            else:
                props["RoutingConfig"] = self.routing_config

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_alias_arn(self) -> GetAtt:
        """Get the AliasArn attribute."""
        return self.get_att("AliasArn")




@dataclass
class CapacityProviderPermissionsConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_provider_operator_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capacity_provider_operator_role_arn is not None:
            if hasattr(self.capacity_provider_operator_role_arn, 'to_dict'):
                props['CapacityProviderOperatorRoleArn'] = self.capacity_provider_operator_role_arn.to_dict()
            elif isinstance(self.capacity_provider_operator_role_arn, list):
                props['CapacityProviderOperatorRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_provider_operator_role_arn
                ]
            else:
                props['CapacityProviderOperatorRoleArn'] = self.capacity_provider_operator_role_arn

        return props


@dataclass
class CapacityProviderScalingConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scaling_policies: Optional[list[TargetTrackingScalingPolicy]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scaling_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_v_cpu_count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.scaling_policies is not None:
            if hasattr(self.scaling_policies, 'to_dict'):
                props['ScalingPolicies'] = self.scaling_policies.to_dict()
            elif isinstance(self.scaling_policies, list):
                props['ScalingPolicies'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scaling_policies
                ]
            else:
                props['ScalingPolicies'] = self.scaling_policies

        if self.scaling_mode is not None:
            if hasattr(self.scaling_mode, 'to_dict'):
                props['ScalingMode'] = self.scaling_mode.to_dict()
            elif isinstance(self.scaling_mode, list):
                props['ScalingMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scaling_mode
                ]
            else:
                props['ScalingMode'] = self.scaling_mode

        if self.max_v_cpu_count is not None:
            if hasattr(self.max_v_cpu_count, 'to_dict'):
                props['MaxVCpuCount'] = self.max_v_cpu_count.to_dict()
            elif isinstance(self.max_v_cpu_count, list):
                props['MaxVCpuCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_v_cpu_count
                ]
            else:
                props['MaxVCpuCount'] = self.max_v_cpu_count

        return props


@dataclass
class CapacityProviderVpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnet_ids is not None:
            if hasattr(self.subnet_ids, 'to_dict'):
                props['SubnetIds'] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props['SubnetIds'] = self.subnet_ids

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class InstanceRequirements:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allowed_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    excluded_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    architectures: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.allowed_instance_types is not None:
            if hasattr(self.allowed_instance_types, 'to_dict'):
                props['AllowedInstanceTypes'] = self.allowed_instance_types.to_dict()
            elif isinstance(self.allowed_instance_types, list):
                props['AllowedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_instance_types
                ]
            else:
                props['AllowedInstanceTypes'] = self.allowed_instance_types

        if self.excluded_instance_types is not None:
            if hasattr(self.excluded_instance_types, 'to_dict'):
                props['ExcludedInstanceTypes'] = self.excluded_instance_types.to_dict()
            elif isinstance(self.excluded_instance_types, list):
                props['ExcludedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.excluded_instance_types
                ]
            else:
                props['ExcludedInstanceTypes'] = self.excluded_instance_types

        if self.architectures is not None:
            if hasattr(self.architectures, 'to_dict'):
                props['Architectures'] = self.architectures.to_dict()
            elif isinstance(self.architectures, list):
                props['Architectures'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.architectures
                ]
            else:
                props['Architectures'] = self.architectures

        return props


@dataclass
class TargetTrackingScalingPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_value: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.predefined_metric_type is not None:
            if hasattr(self.predefined_metric_type, 'to_dict'):
                props['PredefinedMetricType'] = self.predefined_metric_type.to_dict()
            elif isinstance(self.predefined_metric_type, list):
                props['PredefinedMetricType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_metric_type
                ]
            else:
                props['PredefinedMetricType'] = self.predefined_metric_type

        if self.target_value is not None:
            if hasattr(self.target_value, 'to_dict'):
                props['TargetValue'] = self.target_value.to_dict()
            elif isinstance(self.target_value, list):
                props['TargetValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_value
                ]
            else:
                props['TargetValue'] = self.target_value

        return props


@dataclass
class CapacityProvider(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::CapacityProvider"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    capacity_provider_scaling_config: Optional[CapacityProviderScalingConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_config: Optional[CapacityProviderVpcConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    capacity_provider_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_requirements: Optional[InstanceRequirements] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    permissions_config: Optional[CapacityProviderPermissionsConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capacity_provider_scaling_config is not None:
            # Serialize capacity_provider_scaling_config (handle intrinsic functions)
            if hasattr(self.capacity_provider_scaling_config, 'to_dict'):
                props["CapacityProviderScalingConfig"] = self.capacity_provider_scaling_config.to_dict()
            elif isinstance(self.capacity_provider_scaling_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['CapacityProviderScalingConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_provider_scaling_config
                ]
            else:
                props["CapacityProviderScalingConfig"] = self.capacity_provider_scaling_config

        if self.kms_key_arn is not None:
            # Serialize kms_key_arn (handle intrinsic functions)
            if hasattr(self.kms_key_arn, 'to_dict'):
                props["KmsKeyArn"] = self.kms_key_arn.to_dict()
            elif isinstance(self.kms_key_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_arn
                ]
            else:
                props["KmsKeyArn"] = self.kms_key_arn

        if self.vpc_config is not None:
            # Serialize vpc_config (handle intrinsic functions)
            if hasattr(self.vpc_config, 'to_dict'):
                props["VpcConfig"] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props["VpcConfig"] = self.vpc_config

        if self.capacity_provider_name is not None:
            # Serialize capacity_provider_name (handle intrinsic functions)
            if hasattr(self.capacity_provider_name, 'to_dict'):
                props["CapacityProviderName"] = self.capacity_provider_name.to_dict()
            elif isinstance(self.capacity_provider_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['CapacityProviderName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_provider_name
                ]
            else:
                props["CapacityProviderName"] = self.capacity_provider_name

        if self.instance_requirements is not None:
            # Serialize instance_requirements (handle intrinsic functions)
            if hasattr(self.instance_requirements, 'to_dict'):
                props["InstanceRequirements"] = self.instance_requirements.to_dict()
            elif isinstance(self.instance_requirements, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceRequirements'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_requirements
                ]
            else:
                props["InstanceRequirements"] = self.instance_requirements

        if self.permissions_config is not None:
            # Serialize permissions_config (handle intrinsic functions)
            if hasattr(self.permissions_config, 'to_dict'):
                props["PermissionsConfig"] = self.permissions_config.to_dict()
            elif isinstance(self.permissions_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['PermissionsConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.permissions_config
                ]
            else:
                props["PermissionsConfig"] = self.permissions_config

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class AllowedPublishers:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    signing_profile_version_arns: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.signing_profile_version_arns is not None:
            if hasattr(self.signing_profile_version_arns, 'to_dict'):
                props['SigningProfileVersionArns'] = self.signing_profile_version_arns.to_dict()
            elif isinstance(self.signing_profile_version_arns, list):
                props['SigningProfileVersionArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.signing_profile_version_arns
                ]
            else:
                props['SigningProfileVersionArns'] = self.signing_profile_version_arns

        return props


@dataclass
class CodeSigningPolicies:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    untrusted_artifact_on_deployment: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.untrusted_artifact_on_deployment is not None:
            if hasattr(self.untrusted_artifact_on_deployment, 'to_dict'):
                props['UntrustedArtifactOnDeployment'] = self.untrusted_artifact_on_deployment.to_dict()
            elif isinstance(self.untrusted_artifact_on_deployment, list):
                props['UntrustedArtifactOnDeployment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.untrusted_artifact_on_deployment
                ]
            else:
                props['UntrustedArtifactOnDeployment'] = self.untrusted_artifact_on_deployment

        return props


@dataclass
class CodeSigningConfig(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::CodeSigningConfig"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allowed_publishers: Optional[AllowedPublishers] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    code_signing_policies: Optional[CodeSigningPolicies] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.allowed_publishers is not None:
            # Serialize allowed_publishers (handle intrinsic functions)
            if hasattr(self.allowed_publishers, 'to_dict'):
                props["AllowedPublishers"] = self.allowed_publishers.to_dict()
            elif isinstance(self.allowed_publishers, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllowedPublishers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_publishers
                ]
            else:
                props["AllowedPublishers"] = self.allowed_publishers

        if self.code_signing_policies is not None:
            # Serialize code_signing_policies (handle intrinsic functions)
            if hasattr(self.code_signing_policies, 'to_dict'):
                props["CodeSigningPolicies"] = self.code_signing_policies.to_dict()
            elif isinstance(self.code_signing_policies, list):
                # Serialize list items (may contain intrinsic functions)
                props['CodeSigningPolicies'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code_signing_policies
                ]
            else:
                props["CodeSigningPolicies"] = self.code_signing_policies

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_code_signing_config_id(self) -> GetAtt:
        """Get the CodeSigningConfigId attribute."""
        return self.get_att("CodeSigningConfigId")

    @property
    def attr_code_signing_config_arn(self) -> GetAtt:
        """Get the CodeSigningConfigArn attribute."""
        return self.get_att("CodeSigningConfigArn")




@dataclass
class DestinationConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_success: Optional[OnSuccess] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_failure: Optional[OnFailure] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.on_success is not None:
            if hasattr(self.on_success, 'to_dict'):
                props['OnSuccess'] = self.on_success.to_dict()
            elif isinstance(self.on_success, list):
                props['OnSuccess'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_success
                ]
            else:
                props['OnSuccess'] = self.on_success

        if self.on_failure is not None:
            if hasattr(self.on_failure, 'to_dict'):
                props['OnFailure'] = self.on_failure.to_dict()
            elif isinstance(self.on_failure, list):
                props['OnFailure'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_failure
                ]
            else:
                props['OnFailure'] = self.on_failure

        return props


@dataclass
class OnFailure:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination is not None:
            if hasattr(self.destination, 'to_dict'):
                props['Destination'] = self.destination.to_dict()
            elif isinstance(self.destination, list):
                props['Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination
                ]
            else:
                props['Destination'] = self.destination

        return props


@dataclass
class OnSuccess:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination is not None:
            if hasattr(self.destination, 'to_dict'):
                props['Destination'] = self.destination.to_dict()
            elif isinstance(self.destination, list):
                props['Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination
                ]
            else:
                props['Destination'] = self.destination

        return props


@dataclass
class EventInvokeConfig(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::EventInvokeConfig"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    function_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    maximum_retry_attempts: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_config: Optional[DestinationConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    qualifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    maximum_event_age_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.function_name is not None:
            # Serialize function_name (handle intrinsic functions)
            if hasattr(self.function_name, 'to_dict'):
                props["FunctionName"] = self.function_name.to_dict()
            elif isinstance(self.function_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['FunctionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.function_name
                ]
            else:
                props["FunctionName"] = self.function_name

        if self.maximum_retry_attempts is not None:
            # Serialize maximum_retry_attempts (handle intrinsic functions)
            if hasattr(self.maximum_retry_attempts, 'to_dict'):
                props["MaximumRetryAttempts"] = self.maximum_retry_attempts.to_dict()
            elif isinstance(self.maximum_retry_attempts, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaximumRetryAttempts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_retry_attempts
                ]
            else:
                props["MaximumRetryAttempts"] = self.maximum_retry_attempts

        if self.destination_config is not None:
            # Serialize destination_config (handle intrinsic functions)
            if hasattr(self.destination_config, 'to_dict'):
                props["DestinationConfig"] = self.destination_config.to_dict()
            elif isinstance(self.destination_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_config
                ]
            else:
                props["DestinationConfig"] = self.destination_config

        if self.qualifier is not None:
            # Serialize qualifier (handle intrinsic functions)
            if hasattr(self.qualifier, 'to_dict'):
                props["Qualifier"] = self.qualifier.to_dict()
            elif isinstance(self.qualifier, list):
                # Serialize list items (may contain intrinsic functions)
                props['Qualifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.qualifier
                ]
            else:
                props["Qualifier"] = self.qualifier

        if self.maximum_event_age_in_seconds is not None:
            # Serialize maximum_event_age_in_seconds (handle intrinsic functions)
            if hasattr(self.maximum_event_age_in_seconds, 'to_dict'):
                props["MaximumEventAgeInSeconds"] = self.maximum_event_age_in_seconds.to_dict()
            elif isinstance(self.maximum_event_age_in_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaximumEventAgeInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_event_age_in_seconds
                ]
            else:
                props["MaximumEventAgeInSeconds"] = self.maximum_event_age_in_seconds

        return props



@dataclass
class AmazonManagedKafkaEventSourceConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    consumer_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    schema_registry_config: Optional[SchemaRegistryConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.consumer_group_id is not None:
            if hasattr(self.consumer_group_id, 'to_dict'):
                props['ConsumerGroupId'] = self.consumer_group_id.to_dict()
            elif isinstance(self.consumer_group_id, list):
                props['ConsumerGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.consumer_group_id
                ]
            else:
                props['ConsumerGroupId'] = self.consumer_group_id

        if self.schema_registry_config is not None:
            if hasattr(self.schema_registry_config, 'to_dict'):
                props['SchemaRegistryConfig'] = self.schema_registry_config.to_dict()
            elif isinstance(self.schema_registry_config, list):
                props['SchemaRegistryConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schema_registry_config
                ]
            else:
                props['SchemaRegistryConfig'] = self.schema_registry_config

        return props


@dataclass
class DestinationConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_failure: Optional[OnFailure] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.on_failure is not None:
            if hasattr(self.on_failure, 'to_dict'):
                props['OnFailure'] = self.on_failure.to_dict()
            elif isinstance(self.on_failure, list):
                props['OnFailure'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_failure
                ]
            else:
                props['OnFailure'] = self.on_failure

        return props


@dataclass
class DocumentDBEventSourceConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    full_document: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    collection_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.full_document is not None:
            if hasattr(self.full_document, 'to_dict'):
                props['FullDocument'] = self.full_document.to_dict()
            elif isinstance(self.full_document, list):
                props['FullDocument'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.full_document
                ]
            else:
                props['FullDocument'] = self.full_document

        if self.collection_name is not None:
            if hasattr(self.collection_name, 'to_dict'):
                props['CollectionName'] = self.collection_name.to_dict()
            elif isinstance(self.collection_name, list):
                props['CollectionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.collection_name
                ]
            else:
                props['CollectionName'] = self.collection_name

        if self.database_name is not None:
            if hasattr(self.database_name, 'to_dict'):
                props['DatabaseName'] = self.database_name.to_dict()
            elif isinstance(self.database_name, list):
                props['DatabaseName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.database_name
                ]
            else:
                props['DatabaseName'] = self.database_name

        return props


@dataclass
class Endpoints:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kafka_bootstrap_servers: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kafka_bootstrap_servers is not None:
            if hasattr(self.kafka_bootstrap_servers, 'to_dict'):
                props['KafkaBootstrapServers'] = self.kafka_bootstrap_servers.to_dict()
            elif isinstance(self.kafka_bootstrap_servers, list):
                props['KafkaBootstrapServers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kafka_bootstrap_servers
                ]
            else:
                props['KafkaBootstrapServers'] = self.kafka_bootstrap_servers

        return props


@dataclass
class Filter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    pattern: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.pattern is not None:
            if hasattr(self.pattern, 'to_dict'):
                props['Pattern'] = self.pattern.to_dict()
            elif isinstance(self.pattern, list):
                props['Pattern'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pattern
                ]
            else:
                props['Pattern'] = self.pattern

        return props


@dataclass
class FilterCriteria:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    filters: Optional[list[Filter]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.filters is not None:
            if hasattr(self.filters, 'to_dict'):
                props['Filters'] = self.filters.to_dict()
            elif isinstance(self.filters, list):
                props['Filters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filters
                ]
            else:
                props['Filters'] = self.filters

        return props


@dataclass
class LoggingConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    system_log_level: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.system_log_level is not None:
            if hasattr(self.system_log_level, 'to_dict'):
                props['SystemLogLevel'] = self.system_log_level.to_dict()
            elif isinstance(self.system_log_level, list):
                props['SystemLogLevel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.system_log_level
                ]
            else:
                props['SystemLogLevel'] = self.system_log_level

        return props


@dataclass
class MetricsConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metrics: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metrics is not None:
            if hasattr(self.metrics, 'to_dict'):
                props['Metrics'] = self.metrics.to_dict()
            elif isinstance(self.metrics, list):
                props['Metrics'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metrics
                ]
            else:
                props['Metrics'] = self.metrics

        return props


@dataclass
class OnFailure:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination is not None:
            if hasattr(self.destination, 'to_dict'):
                props['Destination'] = self.destination.to_dict()
            elif isinstance(self.destination, list):
                props['Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination
                ]
            else:
                props['Destination'] = self.destination

        return props


@dataclass
class ProvisionedPollerConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    poller_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    minimum_pollers: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_pollers: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.poller_group_name is not None:
            if hasattr(self.poller_group_name, 'to_dict'):
                props['PollerGroupName'] = self.poller_group_name.to_dict()
            elif isinstance(self.poller_group_name, list):
                props['PollerGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.poller_group_name
                ]
            else:
                props['PollerGroupName'] = self.poller_group_name

        if self.minimum_pollers is not None:
            if hasattr(self.minimum_pollers, 'to_dict'):
                props['MinimumPollers'] = self.minimum_pollers.to_dict()
            elif isinstance(self.minimum_pollers, list):
                props['MinimumPollers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.minimum_pollers
                ]
            else:
                props['MinimumPollers'] = self.minimum_pollers

        if self.maximum_pollers is not None:
            if hasattr(self.maximum_pollers, 'to_dict'):
                props['MaximumPollers'] = self.maximum_pollers.to_dict()
            elif isinstance(self.maximum_pollers, list):
                props['MaximumPollers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_pollers
                ]
            else:
                props['MaximumPollers'] = self.maximum_pollers

        return props


@dataclass
class ScalingConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_concurrency: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.maximum_concurrency is not None:
            if hasattr(self.maximum_concurrency, 'to_dict'):
                props['MaximumConcurrency'] = self.maximum_concurrency.to_dict()
            elif isinstance(self.maximum_concurrency, list):
                props['MaximumConcurrency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_concurrency
                ]
            else:
                props['MaximumConcurrency'] = self.maximum_concurrency

        return props


@dataclass
class SchemaRegistryAccessConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.uri is not None:
            if hasattr(self.uri, 'to_dict'):
                props['URI'] = self.uri.to_dict()
            elif isinstance(self.uri, list):
                props['URI'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.uri
                ]
            else:
                props['URI'] = self.uri

        return props


@dataclass
class SchemaRegistryConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    schema_validation_configs: Optional[list[SchemaValidationConfig]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    schema_registry_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    event_record_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    access_configs: Optional[list[SchemaRegistryAccessConfig]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.schema_validation_configs is not None:
            if hasattr(self.schema_validation_configs, 'to_dict'):
                props['SchemaValidationConfigs'] = self.schema_validation_configs.to_dict()
            elif isinstance(self.schema_validation_configs, list):
                props['SchemaValidationConfigs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schema_validation_configs
                ]
            else:
                props['SchemaValidationConfigs'] = self.schema_validation_configs

        if self.schema_registry_uri is not None:
            if hasattr(self.schema_registry_uri, 'to_dict'):
                props['SchemaRegistryURI'] = self.schema_registry_uri.to_dict()
            elif isinstance(self.schema_registry_uri, list):
                props['SchemaRegistryURI'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schema_registry_uri
                ]
            else:
                props['SchemaRegistryURI'] = self.schema_registry_uri

        if self.event_record_format is not None:
            if hasattr(self.event_record_format, 'to_dict'):
                props['EventRecordFormat'] = self.event_record_format.to_dict()
            elif isinstance(self.event_record_format, list):
                props['EventRecordFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.event_record_format
                ]
            else:
                props['EventRecordFormat'] = self.event_record_format

        if self.access_configs is not None:
            if hasattr(self.access_configs, 'to_dict'):
                props['AccessConfigs'] = self.access_configs.to_dict()
            elif isinstance(self.access_configs, list):
                props['AccessConfigs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.access_configs
                ]
            else:
                props['AccessConfigs'] = self.access_configs

        return props


@dataclass
class SchemaValidationConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.attribute is not None:
            if hasattr(self.attribute, 'to_dict'):
                props['Attribute'] = self.attribute.to_dict()
            elif isinstance(self.attribute, list):
                props['Attribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attribute
                ]
            else:
                props['Attribute'] = self.attribute

        return props


@dataclass
class SelfManagedEventSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoints: Optional[Endpoints] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.endpoints is not None:
            if hasattr(self.endpoints, 'to_dict'):
                props['Endpoints'] = self.endpoints.to_dict()
            elif isinstance(self.endpoints, list):
                props['Endpoints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoints
                ]
            else:
                props['Endpoints'] = self.endpoints

        return props


@dataclass
class SelfManagedKafkaEventSourceConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    consumer_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    schema_registry_config: Optional[SchemaRegistryConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.consumer_group_id is not None:
            if hasattr(self.consumer_group_id, 'to_dict'):
                props['ConsumerGroupId'] = self.consumer_group_id.to_dict()
            elif isinstance(self.consumer_group_id, list):
                props['ConsumerGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.consumer_group_id
                ]
            else:
                props['ConsumerGroupId'] = self.consumer_group_id

        if self.schema_registry_config is not None:
            if hasattr(self.schema_registry_config, 'to_dict'):
                props['SchemaRegistryConfig'] = self.schema_registry_config.to_dict()
            elif isinstance(self.schema_registry_config, list):
                props['SchemaRegistryConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schema_registry_config
                ]
            else:
                props['SchemaRegistryConfig'] = self.schema_registry_config

        return props


@dataclass
class SourceAccessConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.uri is not None:
            if hasattr(self.uri, 'to_dict'):
                props['URI'] = self.uri.to_dict()
            elif isinstance(self.uri, list):
                props['URI'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.uri
                ]
            else:
                props['URI'] = self.uri

        return props


@dataclass
class EventSourceMapping(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::EventSourceMapping"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    starting_position: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    self_managed_event_source: Optional[SelfManagedEventSource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    parallelization_factor: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    filter_criteria: Optional[FilterCriteria] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    provisioned_poller_config: Optional[ProvisionedPollerConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metrics_config: Optional[MetricsConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    function_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_config: Optional[DestinationConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    amazon_managed_kafka_event_source_config: Optional[AmazonManagedKafkaEventSourceConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_access_configurations: Optional[list[SourceAccessConfiguration]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    maximum_batching_window_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    batch_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    maximum_retry_attempts: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    topics: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    scaling_config: Optional[ScalingConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    event_source_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    self_managed_kafka_event_source_config: Optional[SelfManagedKafkaEventSourceConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    document_db_event_source_config: Optional[DocumentDBEventSourceConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tumbling_window_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    bisect_batch_on_function_error: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    maximum_record_age_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    starting_position_timestamp: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    logging_config: Optional[LoggingConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    queues: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    function_response_types: Optional[Union[list[str], Ref]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.starting_position is not None:
            # Serialize starting_position (handle intrinsic functions)
            if hasattr(self.starting_position, 'to_dict'):
                props["StartingPosition"] = self.starting_position.to_dict()
            elif isinstance(self.starting_position, list):
                # Serialize list items (may contain intrinsic functions)
                props['StartingPosition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.starting_position
                ]
            else:
                props["StartingPosition"] = self.starting_position

        if self.self_managed_event_source is not None:
            # Serialize self_managed_event_source (handle intrinsic functions)
            if hasattr(self.self_managed_event_source, 'to_dict'):
                props["SelfManagedEventSource"] = self.self_managed_event_source.to_dict()
            elif isinstance(self.self_managed_event_source, list):
                # Serialize list items (may contain intrinsic functions)
                props['SelfManagedEventSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.self_managed_event_source
                ]
            else:
                props["SelfManagedEventSource"] = self.self_managed_event_source

        if self.parallelization_factor is not None:
            # Serialize parallelization_factor (handle intrinsic functions)
            if hasattr(self.parallelization_factor, 'to_dict'):
                props["ParallelizationFactor"] = self.parallelization_factor.to_dict()
            elif isinstance(self.parallelization_factor, list):
                # Serialize list items (may contain intrinsic functions)
                props['ParallelizationFactor'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parallelization_factor
                ]
            else:
                props["ParallelizationFactor"] = self.parallelization_factor

        if self.filter_criteria is not None:
            # Serialize filter_criteria (handle intrinsic functions)
            if hasattr(self.filter_criteria, 'to_dict'):
                props["FilterCriteria"] = self.filter_criteria.to_dict()
            elif isinstance(self.filter_criteria, list):
                # Serialize list items (may contain intrinsic functions)
                props['FilterCriteria'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter_criteria
                ]
            else:
                props["FilterCriteria"] = self.filter_criteria

        if self.provisioned_poller_config is not None:
            # Serialize provisioned_poller_config (handle intrinsic functions)
            if hasattr(self.provisioned_poller_config, 'to_dict'):
                props["ProvisionedPollerConfig"] = self.provisioned_poller_config.to_dict()
            elif isinstance(self.provisioned_poller_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProvisionedPollerConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.provisioned_poller_config
                ]
            else:
                props["ProvisionedPollerConfig"] = self.provisioned_poller_config

        if self.metrics_config is not None:
            # Serialize metrics_config (handle intrinsic functions)
            if hasattr(self.metrics_config, 'to_dict'):
                props["MetricsConfig"] = self.metrics_config.to_dict()
            elif isinstance(self.metrics_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['MetricsConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metrics_config
                ]
            else:
                props["MetricsConfig"] = self.metrics_config

        if self.function_name is not None:
            # Serialize function_name (handle intrinsic functions)
            if hasattr(self.function_name, 'to_dict'):
                props["FunctionName"] = self.function_name.to_dict()
            elif isinstance(self.function_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['FunctionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.function_name
                ]
            else:
                props["FunctionName"] = self.function_name

        if self.destination_config is not None:
            # Serialize destination_config (handle intrinsic functions)
            if hasattr(self.destination_config, 'to_dict'):
                props["DestinationConfig"] = self.destination_config.to_dict()
            elif isinstance(self.destination_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_config
                ]
            else:
                props["DestinationConfig"] = self.destination_config

        if self.kms_key_arn is not None:
            # Serialize kms_key_arn (handle intrinsic functions)
            if hasattr(self.kms_key_arn, 'to_dict'):
                props["KmsKeyArn"] = self.kms_key_arn.to_dict()
            elif isinstance(self.kms_key_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_arn
                ]
            else:
                props["KmsKeyArn"] = self.kms_key_arn

        if self.amazon_managed_kafka_event_source_config is not None:
            # Serialize amazon_managed_kafka_event_source_config (handle intrinsic functions)
            if hasattr(self.amazon_managed_kafka_event_source_config, 'to_dict'):
                props["AmazonManagedKafkaEventSourceConfig"] = self.amazon_managed_kafka_event_source_config.to_dict()
            elif isinstance(self.amazon_managed_kafka_event_source_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['AmazonManagedKafkaEventSourceConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.amazon_managed_kafka_event_source_config
                ]
            else:
                props["AmazonManagedKafkaEventSourceConfig"] = self.amazon_managed_kafka_event_source_config

        if self.source_access_configurations is not None:
            # Serialize source_access_configurations (handle intrinsic functions)
            if hasattr(self.source_access_configurations, 'to_dict'):
                props["SourceAccessConfigurations"] = self.source_access_configurations.to_dict()
            elif isinstance(self.source_access_configurations, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceAccessConfigurations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_access_configurations
                ]
            else:
                props["SourceAccessConfigurations"] = self.source_access_configurations

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.maximum_batching_window_in_seconds is not None:
            # Serialize maximum_batching_window_in_seconds (handle intrinsic functions)
            if hasattr(self.maximum_batching_window_in_seconds, 'to_dict'):
                props["MaximumBatchingWindowInSeconds"] = self.maximum_batching_window_in_seconds.to_dict()
            elif isinstance(self.maximum_batching_window_in_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaximumBatchingWindowInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_batching_window_in_seconds
                ]
            else:
                props["MaximumBatchingWindowInSeconds"] = self.maximum_batching_window_in_seconds

        if self.batch_size is not None:
            # Serialize batch_size (handle intrinsic functions)
            if hasattr(self.batch_size, 'to_dict'):
                props["BatchSize"] = self.batch_size.to_dict()
            elif isinstance(self.batch_size, list):
                # Serialize list items (may contain intrinsic functions)
                props['BatchSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.batch_size
                ]
            else:
                props["BatchSize"] = self.batch_size

        if self.maximum_retry_attempts is not None:
            # Serialize maximum_retry_attempts (handle intrinsic functions)
            if hasattr(self.maximum_retry_attempts, 'to_dict'):
                props["MaximumRetryAttempts"] = self.maximum_retry_attempts.to_dict()
            elif isinstance(self.maximum_retry_attempts, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaximumRetryAttempts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_retry_attempts
                ]
            else:
                props["MaximumRetryAttempts"] = self.maximum_retry_attempts

        if self.topics is not None:
            # Serialize topics (handle intrinsic functions)
            if hasattr(self.topics, 'to_dict'):
                props["Topics"] = self.topics.to_dict()
            elif isinstance(self.topics, list):
                # Serialize list items (may contain intrinsic functions)
                props['Topics'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.topics
                ]
            else:
                props["Topics"] = self.topics

        if self.scaling_config is not None:
            # Serialize scaling_config (handle intrinsic functions)
            if hasattr(self.scaling_config, 'to_dict'):
                props["ScalingConfig"] = self.scaling_config.to_dict()
            elif isinstance(self.scaling_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ScalingConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scaling_config
                ]
            else:
                props["ScalingConfig"] = self.scaling_config

        if self.enabled is not None:
            # Serialize enabled (handle intrinsic functions)
            if hasattr(self.enabled, 'to_dict'):
                props["Enabled"] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props["Enabled"] = self.enabled

        if self.event_source_arn is not None:
            # Serialize event_source_arn (handle intrinsic functions)
            if hasattr(self.event_source_arn, 'to_dict'):
                props["EventSourceArn"] = self.event_source_arn.to_dict()
            elif isinstance(self.event_source_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['EventSourceArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.event_source_arn
                ]
            else:
                props["EventSourceArn"] = self.event_source_arn

        if self.self_managed_kafka_event_source_config is not None:
            # Serialize self_managed_kafka_event_source_config (handle intrinsic functions)
            if hasattr(self.self_managed_kafka_event_source_config, 'to_dict'):
                props["SelfManagedKafkaEventSourceConfig"] = self.self_managed_kafka_event_source_config.to_dict()
            elif isinstance(self.self_managed_kafka_event_source_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['SelfManagedKafkaEventSourceConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.self_managed_kafka_event_source_config
                ]
            else:
                props["SelfManagedKafkaEventSourceConfig"] = self.self_managed_kafka_event_source_config

        if self.document_db_event_source_config is not None:
            # Serialize document_db_event_source_config (handle intrinsic functions)
            if hasattr(self.document_db_event_source_config, 'to_dict'):
                props["DocumentDBEventSourceConfig"] = self.document_db_event_source_config.to_dict()
            elif isinstance(self.document_db_event_source_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['DocumentDBEventSourceConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_db_event_source_config
                ]
            else:
                props["DocumentDBEventSourceConfig"] = self.document_db_event_source_config

        if self.tumbling_window_in_seconds is not None:
            # Serialize tumbling_window_in_seconds (handle intrinsic functions)
            if hasattr(self.tumbling_window_in_seconds, 'to_dict'):
                props["TumblingWindowInSeconds"] = self.tumbling_window_in_seconds.to_dict()
            elif isinstance(self.tumbling_window_in_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['TumblingWindowInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tumbling_window_in_seconds
                ]
            else:
                props["TumblingWindowInSeconds"] = self.tumbling_window_in_seconds

        if self.bisect_batch_on_function_error is not None:
            # Serialize bisect_batch_on_function_error (handle intrinsic functions)
            if hasattr(self.bisect_batch_on_function_error, 'to_dict'):
                props["BisectBatchOnFunctionError"] = self.bisect_batch_on_function_error.to_dict()
            elif isinstance(self.bisect_batch_on_function_error, list):
                # Serialize list items (may contain intrinsic functions)
                props['BisectBatchOnFunctionError'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bisect_batch_on_function_error
                ]
            else:
                props["BisectBatchOnFunctionError"] = self.bisect_batch_on_function_error

        if self.maximum_record_age_in_seconds is not None:
            # Serialize maximum_record_age_in_seconds (handle intrinsic functions)
            if hasattr(self.maximum_record_age_in_seconds, 'to_dict'):
                props["MaximumRecordAgeInSeconds"] = self.maximum_record_age_in_seconds.to_dict()
            elif isinstance(self.maximum_record_age_in_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaximumRecordAgeInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_record_age_in_seconds
                ]
            else:
                props["MaximumRecordAgeInSeconds"] = self.maximum_record_age_in_seconds

        if self.starting_position_timestamp is not None:
            # Serialize starting_position_timestamp (handle intrinsic functions)
            if hasattr(self.starting_position_timestamp, 'to_dict'):
                props["StartingPositionTimestamp"] = self.starting_position_timestamp.to_dict()
            elif isinstance(self.starting_position_timestamp, list):
                # Serialize list items (may contain intrinsic functions)
                props['StartingPositionTimestamp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.starting_position_timestamp
                ]
            else:
                props["StartingPositionTimestamp"] = self.starting_position_timestamp

        if self.logging_config is not None:
            # Serialize logging_config (handle intrinsic functions)
            if hasattr(self.logging_config, 'to_dict'):
                props["LoggingConfig"] = self.logging_config.to_dict()
            elif isinstance(self.logging_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['LoggingConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.logging_config
                ]
            else:
                props["LoggingConfig"] = self.logging_config

        if self.queues is not None:
            # Serialize queues (handle intrinsic functions)
            if hasattr(self.queues, 'to_dict'):
                props["Queues"] = self.queues.to_dict()
            elif isinstance(self.queues, list):
                # Serialize list items (may contain intrinsic functions)
                props['Queues'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.queues
                ]
            else:
                props["Queues"] = self.queues

        if self.function_response_types is not None:
            # Serialize function_response_types (handle intrinsic functions)
            if hasattr(self.function_response_types, 'to_dict'):
                props["FunctionResponseTypes"] = self.function_response_types.to_dict()
            elif isinstance(self.function_response_types, list):
                # Serialize list items (may contain intrinsic functions)
                props['FunctionResponseTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.function_response_types
                ]
            else:
                props["FunctionResponseTypes"] = self.function_response_types

        return props

    @property
    def attr_event_source_mapping_arn(self) -> GetAtt:
        """Get the EventSourceMappingArn attribute."""
        return self.get_att("EventSourceMappingArn")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class CapacityProviderConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lambda_managed_instances_capacity_provider_config: Optional[LambdaManagedInstancesCapacityProviderConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.lambda_managed_instances_capacity_provider_config is not None:
            if hasattr(self.lambda_managed_instances_capacity_provider_config, 'to_dict'):
                props['LambdaManagedInstancesCapacityProviderConfig'] = self.lambda_managed_instances_capacity_provider_config.to_dict()
            elif isinstance(self.lambda_managed_instances_capacity_provider_config, list):
                props['LambdaManagedInstancesCapacityProviderConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lambda_managed_instances_capacity_provider_config
                ]
            else:
                props['LambdaManagedInstancesCapacityProviderConfig'] = self.lambda_managed_instances_capacity_provider_config

        return props


@dataclass
class Code:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_object_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    zip_file: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.source_kms_key_arn is not None:
            if hasattr(self.source_kms_key_arn, 'to_dict'):
                props['SourceKMSKeyArn'] = self.source_kms_key_arn.to_dict()
            elif isinstance(self.source_kms_key_arn, list):
                props['SourceKMSKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_kms_key_arn
                ]
            else:
                props['SourceKMSKeyArn'] = self.source_kms_key_arn

        if self.s3_object_version is not None:
            if hasattr(self.s3_object_version, 'to_dict'):
                props['S3ObjectVersion'] = self.s3_object_version.to_dict()
            elif isinstance(self.s3_object_version, list):
                props['S3ObjectVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_object_version
                ]
            else:
                props['S3ObjectVersion'] = self.s3_object_version

        if self.s3_bucket is not None:
            if hasattr(self.s3_bucket, 'to_dict'):
                props['S3Bucket'] = self.s3_bucket.to_dict()
            elif isinstance(self.s3_bucket, list):
                props['S3Bucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_bucket
                ]
            else:
                props['S3Bucket'] = self.s3_bucket

        if self.zip_file is not None:
            if hasattr(self.zip_file, 'to_dict'):
                props['ZipFile'] = self.zip_file.to_dict()
            elif isinstance(self.zip_file, list):
                props['ZipFile'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.zip_file
                ]
            else:
                props['ZipFile'] = self.zip_file

        if self.s3_key is not None:
            if hasattr(self.s3_key, 'to_dict'):
                props['S3Key'] = self.s3_key.to_dict()
            elif isinstance(self.s3_key, list):
                props['S3Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_key
                ]
            else:
                props['S3Key'] = self.s3_key

        if self.image_uri is not None:
            if hasattr(self.image_uri, 'to_dict'):
                props['ImageUri'] = self.image_uri.to_dict()
            elif isinstance(self.image_uri, list):
                props['ImageUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_uri
                ]
            else:
                props['ImageUri'] = self.image_uri

        return props


@dataclass
class DeadLetterConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.target_arn is not None:
            if hasattr(self.target_arn, 'to_dict'):
                props['TargetArn'] = self.target_arn.to_dict()
            elif isinstance(self.target_arn, list):
                props['TargetArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_arn
                ]
            else:
                props['TargetArn'] = self.target_arn

        return props


@dataclass
class DurableConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    execution_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    retention_period_in_days: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.execution_timeout is not None:
            if hasattr(self.execution_timeout, 'to_dict'):
                props['ExecutionTimeout'] = self.execution_timeout.to_dict()
            elif isinstance(self.execution_timeout, list):
                props['ExecutionTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_timeout
                ]
            else:
                props['ExecutionTimeout'] = self.execution_timeout

        if self.retention_period_in_days is not None:
            if hasattr(self.retention_period_in_days, 'to_dict'):
                props['RetentionPeriodInDays'] = self.retention_period_in_days.to_dict()
            elif isinstance(self.retention_period_in_days, list):
                props['RetentionPeriodInDays'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.retention_period_in_days
                ]
            else:
                props['RetentionPeriodInDays'] = self.retention_period_in_days

        return props


@dataclass
class Environment:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    variables: Optional[dict[str, str]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.variables is not None:
            if hasattr(self.variables, 'to_dict'):
                props['Variables'] = self.variables.to_dict()
            elif isinstance(self.variables, list):
                props['Variables'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.variables
                ]
            else:
                props['Variables'] = self.variables

        return props


@dataclass
class EphemeralStorage:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    size: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.size is not None:
            if hasattr(self.size, 'to_dict'):
                props['Size'] = self.size.to_dict()
            elif isinstance(self.size, list):
                props['Size'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.size
                ]
            else:
                props['Size'] = self.size

        return props


@dataclass
class FileSystemConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_mount_path: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.arn is not None:
            if hasattr(self.arn, 'to_dict'):
                props['Arn'] = self.arn.to_dict()
            elif isinstance(self.arn, list):
                props['Arn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.arn
                ]
            else:
                props['Arn'] = self.arn

        if self.local_mount_path is not None:
            if hasattr(self.local_mount_path, 'to_dict'):
                props['LocalMountPath'] = self.local_mount_path.to_dict()
            elif isinstance(self.local_mount_path, list):
                props['LocalMountPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_mount_path
                ]
            else:
                props['LocalMountPath'] = self.local_mount_path

        return props


@dataclass
class FunctionScalingConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_execution_environments: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_execution_environments: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min_execution_environments is not None:
            if hasattr(self.min_execution_environments, 'to_dict'):
                props['MinExecutionEnvironments'] = self.min_execution_environments.to_dict()
            elif isinstance(self.min_execution_environments, list):
                props['MinExecutionEnvironments'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_execution_environments
                ]
            else:
                props['MinExecutionEnvironments'] = self.min_execution_environments

        if self.max_execution_environments is not None:
            if hasattr(self.max_execution_environments, 'to_dict'):
                props['MaxExecutionEnvironments'] = self.max_execution_environments.to_dict()
            elif isinstance(self.max_execution_environments, list):
                props['MaxExecutionEnvironments'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_execution_environments
                ]
            else:
                props['MaxExecutionEnvironments'] = self.max_execution_environments

        return props


@dataclass
class ImageConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    working_directory: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    command: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    entry_point: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.working_directory is not None:
            if hasattr(self.working_directory, 'to_dict'):
                props['WorkingDirectory'] = self.working_directory.to_dict()
            elif isinstance(self.working_directory, list):
                props['WorkingDirectory'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.working_directory
                ]
            else:
                props['WorkingDirectory'] = self.working_directory

        if self.command is not None:
            if hasattr(self.command, 'to_dict'):
                props['Command'] = self.command.to_dict()
            elif isinstance(self.command, list):
                props['Command'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.command
                ]
            else:
                props['Command'] = self.command

        if self.entry_point is not None:
            if hasattr(self.entry_point, 'to_dict'):
                props['EntryPoint'] = self.entry_point.to_dict()
            elif isinstance(self.entry_point, list):
                props['EntryPoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.entry_point
                ]
            else:
                props['EntryPoint'] = self.entry_point

        return props


@dataclass
class LambdaManagedInstancesCapacityProviderConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    execution_environment_memory_gi_b_per_v_cpu: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_provider_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    per_execution_environment_max_concurrency: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.execution_environment_memory_gi_b_per_v_cpu is not None:
            if hasattr(self.execution_environment_memory_gi_b_per_v_cpu, 'to_dict'):
                props['ExecutionEnvironmentMemoryGiBPerVCpu'] = self.execution_environment_memory_gi_b_per_v_cpu.to_dict()
            elif isinstance(self.execution_environment_memory_gi_b_per_v_cpu, list):
                props['ExecutionEnvironmentMemoryGiBPerVCpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_environment_memory_gi_b_per_v_cpu
                ]
            else:
                props['ExecutionEnvironmentMemoryGiBPerVCpu'] = self.execution_environment_memory_gi_b_per_v_cpu

        if self.capacity_provider_arn is not None:
            if hasattr(self.capacity_provider_arn, 'to_dict'):
                props['CapacityProviderArn'] = self.capacity_provider_arn.to_dict()
            elif isinstance(self.capacity_provider_arn, list):
                props['CapacityProviderArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_provider_arn
                ]
            else:
                props['CapacityProviderArn'] = self.capacity_provider_arn

        if self.per_execution_environment_max_concurrency is not None:
            if hasattr(self.per_execution_environment_max_concurrency, 'to_dict'):
                props['PerExecutionEnvironmentMaxConcurrency'] = self.per_execution_environment_max_concurrency.to_dict()
            elif isinstance(self.per_execution_environment_max_concurrency, list):
                props['PerExecutionEnvironmentMaxConcurrency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.per_execution_environment_max_concurrency
                ]
            else:
                props['PerExecutionEnvironmentMaxConcurrency'] = self.per_execution_environment_max_concurrency

        return props


@dataclass
class LoggingConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    application_log_level: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    system_log_level: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.log_format is not None:
            if hasattr(self.log_format, 'to_dict'):
                props['LogFormat'] = self.log_format.to_dict()
            elif isinstance(self.log_format, list):
                props['LogFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_format
                ]
            else:
                props['LogFormat'] = self.log_format

        if self.application_log_level is not None:
            if hasattr(self.application_log_level, 'to_dict'):
                props['ApplicationLogLevel'] = self.application_log_level.to_dict()
            elif isinstance(self.application_log_level, list):
                props['ApplicationLogLevel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.application_log_level
                ]
            else:
                props['ApplicationLogLevel'] = self.application_log_level

        if self.log_group is not None:
            if hasattr(self.log_group, 'to_dict'):
                props['LogGroup'] = self.log_group.to_dict()
            elif isinstance(self.log_group, list):
                props['LogGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group
                ]
            else:
                props['LogGroup'] = self.log_group

        if self.system_log_level is not None:
            if hasattr(self.system_log_level, 'to_dict'):
                props['SystemLogLevel'] = self.system_log_level.to_dict()
            elif isinstance(self.system_log_level, list):
                props['SystemLogLevel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.system_log_level
                ]
            else:
                props['SystemLogLevel'] = self.system_log_level

        return props


@dataclass
class RuntimeManagementConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    update_runtime_on: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    runtime_version_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.update_runtime_on is not None:
            if hasattr(self.update_runtime_on, 'to_dict'):
                props['UpdateRuntimeOn'] = self.update_runtime_on.to_dict()
            elif isinstance(self.update_runtime_on, list):
                props['UpdateRuntimeOn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.update_runtime_on
                ]
            else:
                props['UpdateRuntimeOn'] = self.update_runtime_on

        if self.runtime_version_arn is not None:
            if hasattr(self.runtime_version_arn, 'to_dict'):
                props['RuntimeVersionArn'] = self.runtime_version_arn.to_dict()
            elif isinstance(self.runtime_version_arn, list):
                props['RuntimeVersionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.runtime_version_arn
                ]
            else:
                props['RuntimeVersionArn'] = self.runtime_version_arn

        return props


@dataclass
class SnapStart:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    apply_on: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.apply_on is not None:
            if hasattr(self.apply_on, 'to_dict'):
                props['ApplyOn'] = self.apply_on.to_dict()
            elif isinstance(self.apply_on, list):
                props['ApplyOn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.apply_on
                ]
            else:
                props['ApplyOn'] = self.apply_on

        return props


@dataclass
class SnapStartResponse:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    optimization_status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    apply_on: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.optimization_status is not None:
            if hasattr(self.optimization_status, 'to_dict'):
                props['OptimizationStatus'] = self.optimization_status.to_dict()
            elif isinstance(self.optimization_status, list):
                props['OptimizationStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.optimization_status
                ]
            else:
                props['OptimizationStatus'] = self.optimization_status

        if self.apply_on is not None:
            if hasattr(self.apply_on, 'to_dict'):
                props['ApplyOn'] = self.apply_on.to_dict()
            elif isinstance(self.apply_on, list):
                props['ApplyOn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.apply_on
                ]
            else:
                props['ApplyOn'] = self.apply_on

        return props


@dataclass
class TenancyConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tenant_isolation_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.tenant_isolation_mode is not None:
            if hasattr(self.tenant_isolation_mode, 'to_dict'):
                props['TenantIsolationMode'] = self.tenant_isolation_mode.to_dict()
            elif isinstance(self.tenant_isolation_mode, list):
                props['TenantIsolationMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tenant_isolation_mode
                ]
            else:
                props['TenantIsolationMode'] = self.tenant_isolation_mode

        return props


@dataclass
class TracingConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mode: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mode is not None:
            if hasattr(self.mode, 'to_dict'):
                props['Mode'] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props['Mode'] = self.mode

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_allowed_for_dual_stack: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_allowed_for_dual_stack is not None:
            if hasattr(self.ipv6_allowed_for_dual_stack, 'to_dict'):
                props['Ipv6AllowedForDualStack'] = self.ipv6_allowed_for_dual_stack.to_dict()
            elif isinstance(self.ipv6_allowed_for_dual_stack, list):
                props['Ipv6AllowedForDualStack'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_allowed_for_dual_stack
                ]
            else:
                props['Ipv6AllowedForDualStack'] = self.ipv6_allowed_for_dual_stack

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        if self.subnet_ids is not None:
            if hasattr(self.subnet_ids, 'to_dict'):
                props['SubnetIds'] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props['SubnetIds'] = self.subnet_ids

        return props


@dataclass
class Function(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::Function"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    function_scaling_config: Optional[FunctionScalingConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tracing_config: Optional[TracingConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_config: Optional[VpcConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    runtime_management_config: Optional[RuntimeManagementConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    durable_config: Optional[DurableConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    reserved_concurrent_executions: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    snap_start: Optional[SnapStart] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    file_system_configs: Optional[list[FileSystemConfig]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    function_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    runtime: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    publish_to_latest_published: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    package_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    code_signing_config_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    layers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tenancy_config: Optional[TenancyConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    image_config: Optional[ImageConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    memory_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    dead_letter_config: Optional[DeadLetterConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    capacity_provider_config: Optional[CapacityProviderConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    handler: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    code: Optional[Code] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    logging_config: Optional[LoggingConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    recursive_loop: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    environment: Optional[Environment] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ephemeral_storage: Optional[EphemeralStorage] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    architectures: Optional[Union[list[str], Ref]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.function_scaling_config is not None:
            # Serialize function_scaling_config (handle intrinsic functions)
            if hasattr(self.function_scaling_config, 'to_dict'):
                props["FunctionScalingConfig"] = self.function_scaling_config.to_dict()
            elif isinstance(self.function_scaling_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['FunctionScalingConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.function_scaling_config
                ]
            else:
                props["FunctionScalingConfig"] = self.function_scaling_config

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.tracing_config is not None:
            # Serialize tracing_config (handle intrinsic functions)
            if hasattr(self.tracing_config, 'to_dict'):
                props["TracingConfig"] = self.tracing_config.to_dict()
            elif isinstance(self.tracing_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['TracingConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tracing_config
                ]
            else:
                props["TracingConfig"] = self.tracing_config

        if self.vpc_config is not None:
            # Serialize vpc_config (handle intrinsic functions)
            if hasattr(self.vpc_config, 'to_dict'):
                props["VpcConfig"] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props["VpcConfig"] = self.vpc_config

        if self.runtime_management_config is not None:
            # Serialize runtime_management_config (handle intrinsic functions)
            if hasattr(self.runtime_management_config, 'to_dict'):
                props["RuntimeManagementConfig"] = self.runtime_management_config.to_dict()
            elif isinstance(self.runtime_management_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuntimeManagementConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.runtime_management_config
                ]
            else:
                props["RuntimeManagementConfig"] = self.runtime_management_config

        if self.durable_config is not None:
            # Serialize durable_config (handle intrinsic functions)
            if hasattr(self.durable_config, 'to_dict'):
                props["DurableConfig"] = self.durable_config.to_dict()
            elif isinstance(self.durable_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['DurableConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.durable_config
                ]
            else:
                props["DurableConfig"] = self.durable_config

        if self.reserved_concurrent_executions is not None:
            # Serialize reserved_concurrent_executions (handle intrinsic functions)
            if hasattr(self.reserved_concurrent_executions, 'to_dict'):
                props["ReservedConcurrentExecutions"] = self.reserved_concurrent_executions.to_dict()
            elif isinstance(self.reserved_concurrent_executions, list):
                # Serialize list items (may contain intrinsic functions)
                props['ReservedConcurrentExecutions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.reserved_concurrent_executions
                ]
            else:
                props["ReservedConcurrentExecutions"] = self.reserved_concurrent_executions

        if self.snap_start is not None:
            # Serialize snap_start (handle intrinsic functions)
            if hasattr(self.snap_start, 'to_dict'):
                props["SnapStart"] = self.snap_start.to_dict()
            elif isinstance(self.snap_start, list):
                # Serialize list items (may contain intrinsic functions)
                props['SnapStart'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snap_start
                ]
            else:
                props["SnapStart"] = self.snap_start

        if self.file_system_configs is not None:
            # Serialize file_system_configs (handle intrinsic functions)
            if hasattr(self.file_system_configs, 'to_dict'):
                props["FileSystemConfigs"] = self.file_system_configs.to_dict()
            elif isinstance(self.file_system_configs, list):
                # Serialize list items (may contain intrinsic functions)
                props['FileSystemConfigs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_configs
                ]
            else:
                props["FileSystemConfigs"] = self.file_system_configs

        if self.function_name is not None:
            # Serialize function_name (handle intrinsic functions)
            if hasattr(self.function_name, 'to_dict'):
                props["FunctionName"] = self.function_name.to_dict()
            elif isinstance(self.function_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['FunctionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.function_name
                ]
            else:
                props["FunctionName"] = self.function_name

        if self.runtime is not None:
            # Serialize runtime (handle intrinsic functions)
            if hasattr(self.runtime, 'to_dict'):
                props["Runtime"] = self.runtime.to_dict()
            elif isinstance(self.runtime, list):
                # Serialize list items (may contain intrinsic functions)
                props['Runtime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.runtime
                ]
            else:
                props["Runtime"] = self.runtime

        if self.kms_key_arn is not None:
            # Serialize kms_key_arn (handle intrinsic functions)
            if hasattr(self.kms_key_arn, 'to_dict'):
                props["KmsKeyArn"] = self.kms_key_arn.to_dict()
            elif isinstance(self.kms_key_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_arn
                ]
            else:
                props["KmsKeyArn"] = self.kms_key_arn

        if self.publish_to_latest_published is not None:
            # Serialize publish_to_latest_published (handle intrinsic functions)
            if hasattr(self.publish_to_latest_published, 'to_dict'):
                props["PublishToLatestPublished"] = self.publish_to_latest_published.to_dict()
            elif isinstance(self.publish_to_latest_published, list):
                # Serialize list items (may contain intrinsic functions)
                props['PublishToLatestPublished'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.publish_to_latest_published
                ]
            else:
                props["PublishToLatestPublished"] = self.publish_to_latest_published

        if self.package_type is not None:
            # Serialize package_type (handle intrinsic functions)
            if hasattr(self.package_type, 'to_dict'):
                props["PackageType"] = self.package_type.to_dict()
            elif isinstance(self.package_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['PackageType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.package_type
                ]
            else:
                props["PackageType"] = self.package_type

        if self.code_signing_config_arn is not None:
            # Serialize code_signing_config_arn (handle intrinsic functions)
            if hasattr(self.code_signing_config_arn, 'to_dict'):
                props["CodeSigningConfigArn"] = self.code_signing_config_arn.to_dict()
            elif isinstance(self.code_signing_config_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['CodeSigningConfigArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code_signing_config_arn
                ]
            else:
                props["CodeSigningConfigArn"] = self.code_signing_config_arn

        if self.layers is not None:
            # Serialize layers (handle intrinsic functions)
            if hasattr(self.layers, 'to_dict'):
                props["Layers"] = self.layers.to_dict()
            elif isinstance(self.layers, list):
                # Serialize list items (may contain intrinsic functions)
                props['Layers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.layers
                ]
            else:
                props["Layers"] = self.layers

        if self.tenancy_config is not None:
            # Serialize tenancy_config (handle intrinsic functions)
            if hasattr(self.tenancy_config, 'to_dict'):
                props["TenancyConfig"] = self.tenancy_config.to_dict()
            elif isinstance(self.tenancy_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['TenancyConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tenancy_config
                ]
            else:
                props["TenancyConfig"] = self.tenancy_config

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.image_config is not None:
            # Serialize image_config (handle intrinsic functions)
            if hasattr(self.image_config, 'to_dict'):
                props["ImageConfig"] = self.image_config.to_dict()
            elif isinstance(self.image_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ImageConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_config
                ]
            else:
                props["ImageConfig"] = self.image_config

        if self.memory_size is not None:
            # Serialize memory_size (handle intrinsic functions)
            if hasattr(self.memory_size, 'to_dict'):
                props["MemorySize"] = self.memory_size.to_dict()
            elif isinstance(self.memory_size, list):
                # Serialize list items (may contain intrinsic functions)
                props['MemorySize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_size
                ]
            else:
                props["MemorySize"] = self.memory_size

        if self.dead_letter_config is not None:
            # Serialize dead_letter_config (handle intrinsic functions)
            if hasattr(self.dead_letter_config, 'to_dict'):
                props["DeadLetterConfig"] = self.dead_letter_config.to_dict()
            elif isinstance(self.dead_letter_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeadLetterConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dead_letter_config
                ]
            else:
                props["DeadLetterConfig"] = self.dead_letter_config

        if self.timeout is not None:
            # Serialize timeout (handle intrinsic functions)
            if hasattr(self.timeout, 'to_dict'):
                props["Timeout"] = self.timeout.to_dict()
            elif isinstance(self.timeout, list):
                # Serialize list items (may contain intrinsic functions)
                props['Timeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.timeout
                ]
            else:
                props["Timeout"] = self.timeout

        if self.capacity_provider_config is not None:
            # Serialize capacity_provider_config (handle intrinsic functions)
            if hasattr(self.capacity_provider_config, 'to_dict'):
                props["CapacityProviderConfig"] = self.capacity_provider_config.to_dict()
            elif isinstance(self.capacity_provider_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['CapacityProviderConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_provider_config
                ]
            else:
                props["CapacityProviderConfig"] = self.capacity_provider_config

        if self.handler is not None:
            # Serialize handler (handle intrinsic functions)
            if hasattr(self.handler, 'to_dict'):
                props["Handler"] = self.handler.to_dict()
            elif isinstance(self.handler, list):
                # Serialize list items (may contain intrinsic functions)
                props['Handler'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.handler
                ]
            else:
                props["Handler"] = self.handler

        if self.code is not None:
            # Serialize code (handle intrinsic functions)
            if hasattr(self.code, 'to_dict'):
                props["Code"] = self.code.to_dict()
            elif isinstance(self.code, list):
                # Serialize list items (may contain intrinsic functions)
                props['Code'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code
                ]
            else:
                props["Code"] = self.code

        if self.role is not None:
            # Serialize role (handle intrinsic functions)
            if hasattr(self.role, 'to_dict'):
                props["Role"] = self.role.to_dict()
            elif isinstance(self.role, list):
                # Serialize list items (may contain intrinsic functions)
                props['Role'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role
                ]
            else:
                props["Role"] = self.role

        if self.logging_config is not None:
            # Serialize logging_config (handle intrinsic functions)
            if hasattr(self.logging_config, 'to_dict'):
                props["LoggingConfig"] = self.logging_config.to_dict()
            elif isinstance(self.logging_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['LoggingConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.logging_config
                ]
            else:
                props["LoggingConfig"] = self.logging_config

        if self.recursive_loop is not None:
            # Serialize recursive_loop (handle intrinsic functions)
            if hasattr(self.recursive_loop, 'to_dict'):
                props["RecursiveLoop"] = self.recursive_loop.to_dict()
            elif isinstance(self.recursive_loop, list):
                # Serialize list items (may contain intrinsic functions)
                props['RecursiveLoop'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.recursive_loop
                ]
            else:
                props["RecursiveLoop"] = self.recursive_loop

        if self.environment is not None:
            # Serialize environment (handle intrinsic functions)
            if hasattr(self.environment, 'to_dict'):
                props["Environment"] = self.environment.to_dict()
            elif isinstance(self.environment, list):
                # Serialize list items (may contain intrinsic functions)
                props['Environment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment
                ]
            else:
                props["Environment"] = self.environment

        if self.ephemeral_storage is not None:
            # Serialize ephemeral_storage (handle intrinsic functions)
            if hasattr(self.ephemeral_storage, 'to_dict'):
                props["EphemeralStorage"] = self.ephemeral_storage.to_dict()
            elif isinstance(self.ephemeral_storage, list):
                # Serialize list items (may contain intrinsic functions)
                props['EphemeralStorage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ephemeral_storage
                ]
            else:
                props["EphemeralStorage"] = self.ephemeral_storage

        if self.architectures is not None:
            # Serialize architectures (handle intrinsic functions)
            if hasattr(self.architectures, 'to_dict'):
                props["Architectures"] = self.architectures.to_dict()
            elif isinstance(self.architectures, list):
                # Serialize list items (may contain intrinsic functions)
                props['Architectures'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.architectures
                ]
            else:
                props["Architectures"] = self.architectures

        return props

    @property
    def attr_snap_start_response__optimization_status(self) -> GetAtt:
        """Get the SnapStartResponse.OptimizationStatus attribute."""
        return self.get_att("SnapStartResponse.OptimizationStatus")

    @property
    def attr_snap_start_response__apply_on(self) -> GetAtt:
        """Get the SnapStartResponse.ApplyOn attribute."""
        return self.get_att("SnapStartResponse.ApplyOn")

    @property
    def attr_snap_start_response(self) -> GetAtt:
        """Get the SnapStartResponse attribute."""
        return self.get_att("SnapStartResponse")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class Content:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_object_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_object_version is not None:
            if hasattr(self.s3_object_version, 'to_dict'):
                props['S3ObjectVersion'] = self.s3_object_version.to_dict()
            elif isinstance(self.s3_object_version, list):
                props['S3ObjectVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_object_version
                ]
            else:
                props['S3ObjectVersion'] = self.s3_object_version

        if self.s3_bucket is not None:
            if hasattr(self.s3_bucket, 'to_dict'):
                props['S3Bucket'] = self.s3_bucket.to_dict()
            elif isinstance(self.s3_bucket, list):
                props['S3Bucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_bucket
                ]
            else:
                props['S3Bucket'] = self.s3_bucket

        if self.s3_key is not None:
            if hasattr(self.s3_key, 'to_dict'):
                props['S3Key'] = self.s3_key.to_dict()
            elif isinstance(self.s3_key, list):
                props['S3Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_key
                ]
            else:
                props['S3Key'] = self.s3_key

        return props


@dataclass
class LayerVersion(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::LayerVersion"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    compatible_runtimes: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    license_info: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    layer_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    content: Optional[Content] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    compatible_architectures: Optional[Union[list[str], Ref]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.compatible_runtimes is not None:
            # Serialize compatible_runtimes (handle intrinsic functions)
            if hasattr(self.compatible_runtimes, 'to_dict'):
                props["CompatibleRuntimes"] = self.compatible_runtimes.to_dict()
            elif isinstance(self.compatible_runtimes, list):
                # Serialize list items (may contain intrinsic functions)
                props['CompatibleRuntimes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compatible_runtimes
                ]
            else:
                props["CompatibleRuntimes"] = self.compatible_runtimes

        if self.license_info is not None:
            # Serialize license_info (handle intrinsic functions)
            if hasattr(self.license_info, 'to_dict'):
                props["LicenseInfo"] = self.license_info.to_dict()
            elif isinstance(self.license_info, list):
                # Serialize list items (may contain intrinsic functions)
                props['LicenseInfo'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.license_info
                ]
            else:
                props["LicenseInfo"] = self.license_info

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.layer_name is not None:
            # Serialize layer_name (handle intrinsic functions)
            if hasattr(self.layer_name, 'to_dict'):
                props["LayerName"] = self.layer_name.to_dict()
            elif isinstance(self.layer_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LayerName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.layer_name
                ]
            else:
                props["LayerName"] = self.layer_name

        if self.content is not None:
            # Serialize content (handle intrinsic functions)
            if hasattr(self.content, 'to_dict'):
                props["Content"] = self.content.to_dict()
            elif isinstance(self.content, list):
                # Serialize list items (may contain intrinsic functions)
                props['Content'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.content
                ]
            else:
                props["Content"] = self.content

        if self.compatible_architectures is not None:
            # Serialize compatible_architectures (handle intrinsic functions)
            if hasattr(self.compatible_architectures, 'to_dict'):
                props["CompatibleArchitectures"] = self.compatible_architectures.to_dict()
            elif isinstance(self.compatible_architectures, list):
                # Serialize list items (may contain intrinsic functions)
                props['CompatibleArchitectures'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compatible_architectures
                ]
            else:
                props["CompatibleArchitectures"] = self.compatible_architectures

        return props

    @property
    def attr_layer_version_arn(self) -> GetAtt:
        """Get the LayerVersionArn attribute."""
        return self.get_att("LayerVersionArn")




@dataclass
class LayerVersionPermission(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::LayerVersionPermission"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    layer_version_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    organization_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    principal: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.action is not None:
            # Serialize action (handle intrinsic functions)
            if hasattr(self.action, 'to_dict'):
                props["Action"] = self.action.to_dict()
            elif isinstance(self.action, list):
                # Serialize list items (may contain intrinsic functions)
                props['Action'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.action
                ]
            else:
                props["Action"] = self.action

        if self.layer_version_arn is not None:
            # Serialize layer_version_arn (handle intrinsic functions)
            if hasattr(self.layer_version_arn, 'to_dict'):
                props["LayerVersionArn"] = self.layer_version_arn.to_dict()
            elif isinstance(self.layer_version_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['LayerVersionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.layer_version_arn
                ]
            else:
                props["LayerVersionArn"] = self.layer_version_arn

        if self.organization_id is not None:
            # Serialize organization_id (handle intrinsic functions)
            if hasattr(self.organization_id, 'to_dict'):
                props["OrganizationId"] = self.organization_id.to_dict()
            elif isinstance(self.organization_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['OrganizationId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organization_id
                ]
            else:
                props["OrganizationId"] = self.organization_id

        if self.principal is not None:
            # Serialize principal (handle intrinsic functions)
            if hasattr(self.principal, 'to_dict'):
                props["Principal"] = self.principal.to_dict()
            elif isinstance(self.principal, list):
                # Serialize list items (may contain intrinsic functions)
                props['Principal'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.principal
                ]
            else:
                props["Principal"] = self.principal

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class Permission(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::Permission"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    function_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    invoked_via_function_url: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    event_source_token: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    function_url_auth_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_account: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    principal_org_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    principal: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.function_name is not None:
            # Serialize function_name (handle intrinsic functions)
            if hasattr(self.function_name, 'to_dict'):
                props["FunctionName"] = self.function_name.to_dict()
            elif isinstance(self.function_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['FunctionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.function_name
                ]
            else:
                props["FunctionName"] = self.function_name

        if self.action is not None:
            # Serialize action (handle intrinsic functions)
            if hasattr(self.action, 'to_dict'):
                props["Action"] = self.action.to_dict()
            elif isinstance(self.action, list):
                # Serialize list items (may contain intrinsic functions)
                props['Action'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.action
                ]
            else:
                props["Action"] = self.action

        if self.invoked_via_function_url is not None:
            # Serialize invoked_via_function_url (handle intrinsic functions)
            if hasattr(self.invoked_via_function_url, 'to_dict'):
                props["InvokedViaFunctionUrl"] = self.invoked_via_function_url.to_dict()
            elif isinstance(self.invoked_via_function_url, list):
                # Serialize list items (may contain intrinsic functions)
                props['InvokedViaFunctionUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.invoked_via_function_url
                ]
            else:
                props["InvokedViaFunctionUrl"] = self.invoked_via_function_url

        if self.event_source_token is not None:
            # Serialize event_source_token (handle intrinsic functions)
            if hasattr(self.event_source_token, 'to_dict'):
                props["EventSourceToken"] = self.event_source_token.to_dict()
            elif isinstance(self.event_source_token, list):
                # Serialize list items (may contain intrinsic functions)
                props['EventSourceToken'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.event_source_token
                ]
            else:
                props["EventSourceToken"] = self.event_source_token

        if self.function_url_auth_type is not None:
            # Serialize function_url_auth_type (handle intrinsic functions)
            if hasattr(self.function_url_auth_type, 'to_dict'):
                props["FunctionUrlAuthType"] = self.function_url_auth_type.to_dict()
            elif isinstance(self.function_url_auth_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['FunctionUrlAuthType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.function_url_auth_type
                ]
            else:
                props["FunctionUrlAuthType"] = self.function_url_auth_type

        if self.source_arn is not None:
            # Serialize source_arn (handle intrinsic functions)
            if hasattr(self.source_arn, 'to_dict'):
                props["SourceArn"] = self.source_arn.to_dict()
            elif isinstance(self.source_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_arn
                ]
            else:
                props["SourceArn"] = self.source_arn

        if self.source_account is not None:
            # Serialize source_account (handle intrinsic functions)
            if hasattr(self.source_account, 'to_dict'):
                props["SourceAccount"] = self.source_account.to_dict()
            elif isinstance(self.source_account, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceAccount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_account
                ]
            else:
                props["SourceAccount"] = self.source_account

        if self.principal_org_id is not None:
            # Serialize principal_org_id (handle intrinsic functions)
            if hasattr(self.principal_org_id, 'to_dict'):
                props["PrincipalOrgID"] = self.principal_org_id.to_dict()
            elif isinstance(self.principal_org_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrincipalOrgID'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.principal_org_id
                ]
            else:
                props["PrincipalOrgID"] = self.principal_org_id

        if self.principal is not None:
            # Serialize principal (handle intrinsic functions)
            if hasattr(self.principal, 'to_dict'):
                props["Principal"] = self.principal.to_dict()
            elif isinstance(self.principal, list):
                # Serialize list items (may contain intrinsic functions)
                props['Principal'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.principal
                ]
            else:
                props["Principal"] = self.principal

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class Cors:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allow_credentials: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allow_origins: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    expose_headers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allow_headers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_age: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allow_methods: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.allow_credentials is not None:
            if hasattr(self.allow_credentials, 'to_dict'):
                props['AllowCredentials'] = self.allow_credentials.to_dict()
            elif isinstance(self.allow_credentials, list):
                props['AllowCredentials'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allow_credentials
                ]
            else:
                props['AllowCredentials'] = self.allow_credentials

        if self.allow_origins is not None:
            if hasattr(self.allow_origins, 'to_dict'):
                props['AllowOrigins'] = self.allow_origins.to_dict()
            elif isinstance(self.allow_origins, list):
                props['AllowOrigins'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allow_origins
                ]
            else:
                props['AllowOrigins'] = self.allow_origins

        if self.expose_headers is not None:
            if hasattr(self.expose_headers, 'to_dict'):
                props['ExposeHeaders'] = self.expose_headers.to_dict()
            elif isinstance(self.expose_headers, list):
                props['ExposeHeaders'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.expose_headers
                ]
            else:
                props['ExposeHeaders'] = self.expose_headers

        if self.allow_headers is not None:
            if hasattr(self.allow_headers, 'to_dict'):
                props['AllowHeaders'] = self.allow_headers.to_dict()
            elif isinstance(self.allow_headers, list):
                props['AllowHeaders'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allow_headers
                ]
            else:
                props['AllowHeaders'] = self.allow_headers

        if self.max_age is not None:
            if hasattr(self.max_age, 'to_dict'):
                props['MaxAge'] = self.max_age.to_dict()
            elif isinstance(self.max_age, list):
                props['MaxAge'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_age
                ]
            else:
                props['MaxAge'] = self.max_age

        if self.allow_methods is not None:
            if hasattr(self.allow_methods, 'to_dict'):
                props['AllowMethods'] = self.allow_methods.to_dict()
            elif isinstance(self.allow_methods, list):
                props['AllowMethods'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allow_methods
                ]
            else:
                props['AllowMethods'] = self.allow_methods

        return props


@dataclass
class Url(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::Url"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    qualifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    invoke_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auth_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_function_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cors: Optional[Cors] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.qualifier is not None:
            # Serialize qualifier (handle intrinsic functions)
            if hasattr(self.qualifier, 'to_dict'):
                props["Qualifier"] = self.qualifier.to_dict()
            elif isinstance(self.qualifier, list):
                # Serialize list items (may contain intrinsic functions)
                props['Qualifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.qualifier
                ]
            else:
                props["Qualifier"] = self.qualifier

        if self.invoke_mode is not None:
            # Serialize invoke_mode (handle intrinsic functions)
            if hasattr(self.invoke_mode, 'to_dict'):
                props["InvokeMode"] = self.invoke_mode.to_dict()
            elif isinstance(self.invoke_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['InvokeMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.invoke_mode
                ]
            else:
                props["InvokeMode"] = self.invoke_mode

        if self.auth_type is not None:
            # Serialize auth_type (handle intrinsic functions)
            if hasattr(self.auth_type, 'to_dict'):
                props["AuthType"] = self.auth_type.to_dict()
            elif isinstance(self.auth_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['AuthType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auth_type
                ]
            else:
                props["AuthType"] = self.auth_type

        if self.target_function_arn is not None:
            # Serialize target_function_arn (handle intrinsic functions)
            if hasattr(self.target_function_arn, 'to_dict'):
                props["TargetFunctionArn"] = self.target_function_arn.to_dict()
            elif isinstance(self.target_function_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetFunctionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_function_arn
                ]
            else:
                props["TargetFunctionArn"] = self.target_function_arn

        if self.cors is not None:
            # Serialize cors (handle intrinsic functions)
            if hasattr(self.cors, 'to_dict'):
                props["Cors"] = self.cors.to_dict()
            elif isinstance(self.cors, list):
                # Serialize list items (may contain intrinsic functions)
                props['Cors'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cors
                ]
            else:
                props["Cors"] = self.cors

        return props

    @property
    def attr_function_arn(self) -> GetAtt:
        """Get the FunctionArn attribute."""
        return self.get_att("FunctionArn")

    @property
    def attr_function_url(self) -> GetAtt:
        """Get the FunctionUrl attribute."""
        return self.get_att("FunctionUrl")




@dataclass
class FunctionScalingConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_execution_environments: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_execution_environments: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min_execution_environments is not None:
            if hasattr(self.min_execution_environments, 'to_dict'):
                props['MinExecutionEnvironments'] = self.min_execution_environments.to_dict()
            elif isinstance(self.min_execution_environments, list):
                props['MinExecutionEnvironments'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_execution_environments
                ]
            else:
                props['MinExecutionEnvironments'] = self.min_execution_environments

        if self.max_execution_environments is not None:
            if hasattr(self.max_execution_environments, 'to_dict'):
                props['MaxExecutionEnvironments'] = self.max_execution_environments.to_dict()
            elif isinstance(self.max_execution_environments, list):
                props['MaxExecutionEnvironments'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_execution_environments
                ]
            else:
                props['MaxExecutionEnvironments'] = self.max_execution_environments

        return props


@dataclass
class ProvisionedConcurrencyConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provisioned_concurrent_executions: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.provisioned_concurrent_executions is not None:
            if hasattr(self.provisioned_concurrent_executions, 'to_dict'):
                props['ProvisionedConcurrentExecutions'] = self.provisioned_concurrent_executions.to_dict()
            elif isinstance(self.provisioned_concurrent_executions, list):
                props['ProvisionedConcurrentExecutions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.provisioned_concurrent_executions
                ]
            else:
                props['ProvisionedConcurrentExecutions'] = self.provisioned_concurrent_executions

        return props


@dataclass
class RuntimePolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lam"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    update_runtime_on: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    runtime_version_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.update_runtime_on is not None:
            if hasattr(self.update_runtime_on, 'to_dict'):
                props['UpdateRuntimeOn'] = self.update_runtime_on.to_dict()
            elif isinstance(self.update_runtime_on, list):
                props['UpdateRuntimeOn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.update_runtime_on
                ]
            else:
                props['UpdateRuntimeOn'] = self.update_runtime_on

        if self.runtime_version_arn is not None:
            if hasattr(self.runtime_version_arn, 'to_dict'):
                props['RuntimeVersionArn'] = self.runtime_version_arn.to_dict()
            elif isinstance(self.runtime_version_arn, list):
                props['RuntimeVersionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.runtime_version_arn
                ]
            else:
                props['RuntimeVersionArn'] = self.runtime_version_arn

        return props


@dataclass
class Version(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambd"""

    resource_type: ClassVar[str] = "AWS::Lambda::Version"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    function_scaling_config: Optional[FunctionScalingConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    function_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    provisioned_concurrency_config: Optional[ProvisionedConcurrencyConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    runtime_policy: Optional[RuntimePolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    code_sha256: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.function_scaling_config is not None:
            # Serialize function_scaling_config (handle intrinsic functions)
            if hasattr(self.function_scaling_config, 'to_dict'):
                props["FunctionScalingConfig"] = self.function_scaling_config.to_dict()
            elif isinstance(self.function_scaling_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['FunctionScalingConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.function_scaling_config
                ]
            else:
                props["FunctionScalingConfig"] = self.function_scaling_config

        if self.function_name is not None:
            # Serialize function_name (handle intrinsic functions)
            if hasattr(self.function_name, 'to_dict'):
                props["FunctionName"] = self.function_name.to_dict()
            elif isinstance(self.function_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['FunctionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.function_name
                ]
            else:
                props["FunctionName"] = self.function_name

        if self.provisioned_concurrency_config is not None:
            # Serialize provisioned_concurrency_config (handle intrinsic functions)
            if hasattr(self.provisioned_concurrency_config, 'to_dict'):
                props["ProvisionedConcurrencyConfig"] = self.provisioned_concurrency_config.to_dict()
            elif isinstance(self.provisioned_concurrency_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProvisionedConcurrencyConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.provisioned_concurrency_config
                ]
            else:
                props["ProvisionedConcurrencyConfig"] = self.provisioned_concurrency_config

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.runtime_policy is not None:
            # Serialize runtime_policy (handle intrinsic functions)
            if hasattr(self.runtime_policy, 'to_dict'):
                props["RuntimePolicy"] = self.runtime_policy.to_dict()
            elif isinstance(self.runtime_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuntimePolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.runtime_policy
                ]
            else:
                props["RuntimePolicy"] = self.runtime_policy

        if self.code_sha256 is not None:
            # Serialize code_sha256 (handle intrinsic functions)
            if hasattr(self.code_sha256, 'to_dict'):
                props["CodeSha256"] = self.code_sha256.to_dict()
            elif isinstance(self.code_sha256, list):
                # Serialize list items (may contain intrinsic functions)
                props['CodeSha256'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code_sha256
                ]
            else:
                props["CodeSha256"] = self.code_sha256

        return props

    @property
    def attr_function_arn(self) -> GetAtt:
        """Get the FunctionArn attribute."""
        return self.get_att("FunctionArn")

    @property
    def attr_version(self) -> GetAtt:
        """Get the Version attribute."""
        return self.get_att("Version")



