"""
AWS CloudFormation AutoScaling Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 227.0.0
  Generator Version: 1.0.0
  Combined: spec-227.0.0_gen-1.0.0
  Generated: 2025-12-15 17:57:11

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service AutoScaling
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


@dataclass
class AcceleratorCountRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class AcceleratorTotalMemoryMiBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class AvailabilityZoneDistribution:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_distribution_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capacity_distribution_strategy is not None:
            if hasattr(self.capacity_distribution_strategy, 'to_dict'):
                props['CapacityDistributionStrategy'] = self.capacity_distribution_strategy.to_dict()
            elif isinstance(self.capacity_distribution_strategy, list):
                props['CapacityDistributionStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_distribution_strategy
                ]
            else:
                props['CapacityDistributionStrategy'] = self.capacity_distribution_strategy

        return props


@dataclass
class AvailabilityZoneImpairmentPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    zonal_shift_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    impaired_zone_health_check_behavior: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.zonal_shift_enabled is not None:
            if hasattr(self.zonal_shift_enabled, 'to_dict'):
                props['ZonalShiftEnabled'] = self.zonal_shift_enabled.to_dict()
            elif isinstance(self.zonal_shift_enabled, list):
                props['ZonalShiftEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.zonal_shift_enabled
                ]
            else:
                props['ZonalShiftEnabled'] = self.zonal_shift_enabled

        if self.impaired_zone_health_check_behavior is not None:
            if hasattr(self.impaired_zone_health_check_behavior, 'to_dict'):
                props['ImpairedZoneHealthCheckBehavior'] = self.impaired_zone_health_check_behavior.to_dict()
            elif isinstance(self.impaired_zone_health_check_behavior, list):
                props['ImpairedZoneHealthCheckBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.impaired_zone_health_check_behavior
                ]
            else:
                props['ImpairedZoneHealthCheckBehavior'] = self.impaired_zone_health_check_behavior

        return props


@dataclass
class BaselineEbsBandwidthMbpsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class BaselinePerformanceFactorsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu: Optional[CpuPerformanceFactorRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cpu is not None:
            if hasattr(self.cpu, 'to_dict'):
                props['Cpu'] = self.cpu.to_dict()
            elif isinstance(self.cpu, list):
                props['Cpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu
                ]
            else:
                props['Cpu'] = self.cpu

        return props


@dataclass
class CapacityReservationSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_preference: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_target: Optional[CapacityReservationTarget] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capacity_reservation_preference is not None:
            if hasattr(self.capacity_reservation_preference, 'to_dict'):
                props['CapacityReservationPreference'] = self.capacity_reservation_preference.to_dict()
            elif isinstance(self.capacity_reservation_preference, list):
                props['CapacityReservationPreference'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_preference
                ]
            else:
                props['CapacityReservationPreference'] = self.capacity_reservation_preference

        if self.capacity_reservation_target is not None:
            if hasattr(self.capacity_reservation_target, 'to_dict'):
                props['CapacityReservationTarget'] = self.capacity_reservation_target.to_dict()
            elif isinstance(self.capacity_reservation_target, list):
                props['CapacityReservationTarget'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_target
                ]
            else:
                props['CapacityReservationTarget'] = self.capacity_reservation_target

        return props


@dataclass
class CapacityReservationTarget:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_resource_group_arns: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capacity_reservation_ids is not None:
            if hasattr(self.capacity_reservation_ids, 'to_dict'):
                props['CapacityReservationIds'] = self.capacity_reservation_ids.to_dict()
            elif isinstance(self.capacity_reservation_ids, list):
                props['CapacityReservationIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_ids
                ]
            else:
                props['CapacityReservationIds'] = self.capacity_reservation_ids

        if self.capacity_reservation_resource_group_arns is not None:
            if hasattr(self.capacity_reservation_resource_group_arns, 'to_dict'):
                props['CapacityReservationResourceGroupArns'] = self.capacity_reservation_resource_group_arns.to_dict()
            elif isinstance(self.capacity_reservation_resource_group_arns, list):
                props['CapacityReservationResourceGroupArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_resource_group_arns
                ]
            else:
                props['CapacityReservationResourceGroupArns'] = self.capacity_reservation_resource_group_arns

        return props


@dataclass
class CpuPerformanceFactorRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    references: Optional[list[PerformanceFactorReferenceRequest]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.references is not None:
            if hasattr(self.references, 'to_dict'):
                props['References'] = self.references.to_dict()
            elif isinstance(self.references, list):
                props['References'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.references
                ]
            else:
                props['References'] = self.references

        return props


@dataclass
class InstanceMaintenancePolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_healthy_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_healthy_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_healthy_percentage is not None:
            if hasattr(self.max_healthy_percentage, 'to_dict'):
                props['MaxHealthyPercentage'] = self.max_healthy_percentage.to_dict()
            elif isinstance(self.max_healthy_percentage, list):
                props['MaxHealthyPercentage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_healthy_percentage
                ]
            else:
                props['MaxHealthyPercentage'] = self.max_healthy_percentage

        if self.min_healthy_percentage is not None:
            if hasattr(self.min_healthy_percentage, 'to_dict'):
                props['MinHealthyPercentage'] = self.min_healthy_percentage.to_dict()
            elif isinstance(self.min_healthy_percentage, list):
                props['MinHealthyPercentage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_healthy_percentage
                ]
            else:
                props['MinHealthyPercentage'] = self.min_healthy_percentage

        return props


@dataclass
class InstanceRequirements:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_generations: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_gi_b_per_v_cpu: Optional[MemoryGiBPerVCpuRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_manufacturers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    v_cpu_count: Optional[VCpuCountRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_storage: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_manufacturers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bare_metal: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    require_hibernate_support: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_max_price_percentage_over_lowest_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_mi_b: Optional[MemoryMiBRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_storage_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_count: Optional[NetworkInterfaceCountRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    excluded_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allowed_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_count: Optional[AcceleratorCountRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_bandwidth_gbps: Optional[NetworkBandwidthGbpsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_performance_factors: Optional[BaselinePerformanceFactorsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_ebs_bandwidth_mbps: Optional[BaselineEbsBandwidthMbpsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_max_price_percentage_over_lowest_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_total_memory_mi_b: Optional[AcceleratorTotalMemoryMiBRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    burstable_performance: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    total_local_storage_gb: Optional[TotalLocalStorageGBRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_generations is not None:
            if hasattr(self.instance_generations, 'to_dict'):
                props['InstanceGenerations'] = self.instance_generations.to_dict()
            elif isinstance(self.instance_generations, list):
                props['InstanceGenerations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_generations
                ]
            else:
                props['InstanceGenerations'] = self.instance_generations

        if self.accelerator_types is not None:
            if hasattr(self.accelerator_types, 'to_dict'):
                props['AcceleratorTypes'] = self.accelerator_types.to_dict()
            elif isinstance(self.accelerator_types, list):
                props['AcceleratorTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_types
                ]
            else:
                props['AcceleratorTypes'] = self.accelerator_types

        if self.memory_gi_b_per_v_cpu is not None:
            if hasattr(self.memory_gi_b_per_v_cpu, 'to_dict'):
                props['MemoryGiBPerVCpu'] = self.memory_gi_b_per_v_cpu.to_dict()
            elif isinstance(self.memory_gi_b_per_v_cpu, list):
                props['MemoryGiBPerVCpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_gi_b_per_v_cpu
                ]
            else:
                props['MemoryGiBPerVCpu'] = self.memory_gi_b_per_v_cpu

        if self.accelerator_manufacturers is not None:
            if hasattr(self.accelerator_manufacturers, 'to_dict'):
                props['AcceleratorManufacturers'] = self.accelerator_manufacturers.to_dict()
            elif isinstance(self.accelerator_manufacturers, list):
                props['AcceleratorManufacturers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_manufacturers
                ]
            else:
                props['AcceleratorManufacturers'] = self.accelerator_manufacturers

        if self.v_cpu_count is not None:
            if hasattr(self.v_cpu_count, 'to_dict'):
                props['VCpuCount'] = self.v_cpu_count.to_dict()
            elif isinstance(self.v_cpu_count, list):
                props['VCpuCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.v_cpu_count
                ]
            else:
                props['VCpuCount'] = self.v_cpu_count

        if self.local_storage is not None:
            if hasattr(self.local_storage, 'to_dict'):
                props['LocalStorage'] = self.local_storage.to_dict()
            elif isinstance(self.local_storage, list):
                props['LocalStorage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_storage
                ]
            else:
                props['LocalStorage'] = self.local_storage

        if self.cpu_manufacturers is not None:
            if hasattr(self.cpu_manufacturers, 'to_dict'):
                props['CpuManufacturers'] = self.cpu_manufacturers.to_dict()
            elif isinstance(self.cpu_manufacturers, list):
                props['CpuManufacturers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_manufacturers
                ]
            else:
                props['CpuManufacturers'] = self.cpu_manufacturers

        if self.bare_metal is not None:
            if hasattr(self.bare_metal, 'to_dict'):
                props['BareMetal'] = self.bare_metal.to_dict()
            elif isinstance(self.bare_metal, list):
                props['BareMetal'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bare_metal
                ]
            else:
                props['BareMetal'] = self.bare_metal

        if self.require_hibernate_support is not None:
            if hasattr(self.require_hibernate_support, 'to_dict'):
                props['RequireHibernateSupport'] = self.require_hibernate_support.to_dict()
            elif isinstance(self.require_hibernate_support, list):
                props['RequireHibernateSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.require_hibernate_support
                ]
            else:
                props['RequireHibernateSupport'] = self.require_hibernate_support

        if self.max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            if hasattr(self.max_spot_price_as_percentage_of_optimal_on_demand_price, 'to_dict'):
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = self.max_spot_price_as_percentage_of_optimal_on_demand_price.to_dict()
            elif isinstance(self.max_spot_price_as_percentage_of_optimal_on_demand_price, list):
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_spot_price_as_percentage_of_optimal_on_demand_price
                ]
            else:
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = self.max_spot_price_as_percentage_of_optimal_on_demand_price

        if self.on_demand_max_price_percentage_over_lowest_price is not None:
            if hasattr(self.on_demand_max_price_percentage_over_lowest_price, 'to_dict'):
                props['OnDemandMaxPricePercentageOverLowestPrice'] = self.on_demand_max_price_percentage_over_lowest_price.to_dict()
            elif isinstance(self.on_demand_max_price_percentage_over_lowest_price, list):
                props['OnDemandMaxPricePercentageOverLowestPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_max_price_percentage_over_lowest_price
                ]
            else:
                props['OnDemandMaxPricePercentageOverLowestPrice'] = self.on_demand_max_price_percentage_over_lowest_price

        if self.memory_mi_b is not None:
            if hasattr(self.memory_mi_b, 'to_dict'):
                props['MemoryMiB'] = self.memory_mi_b.to_dict()
            elif isinstance(self.memory_mi_b, list):
                props['MemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_mi_b
                ]
            else:
                props['MemoryMiB'] = self.memory_mi_b

        if self.local_storage_types is not None:
            if hasattr(self.local_storage_types, 'to_dict'):
                props['LocalStorageTypes'] = self.local_storage_types.to_dict()
            elif isinstance(self.local_storage_types, list):
                props['LocalStorageTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_storage_types
                ]
            else:
                props['LocalStorageTypes'] = self.local_storage_types

        if self.network_interface_count is not None:
            if hasattr(self.network_interface_count, 'to_dict'):
                props['NetworkInterfaceCount'] = self.network_interface_count.to_dict()
            elif isinstance(self.network_interface_count, list):
                props['NetworkInterfaceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_count
                ]
            else:
                props['NetworkInterfaceCount'] = self.network_interface_count

        if self.excluded_instance_types is not None:
            if hasattr(self.excluded_instance_types, 'to_dict'):
                props['ExcludedInstanceTypes'] = self.excluded_instance_types.to_dict()
            elif isinstance(self.excluded_instance_types, list):
                props['ExcludedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.excluded_instance_types
                ]
            else:
                props['ExcludedInstanceTypes'] = self.excluded_instance_types

        if self.allowed_instance_types is not None:
            if hasattr(self.allowed_instance_types, 'to_dict'):
                props['AllowedInstanceTypes'] = self.allowed_instance_types.to_dict()
            elif isinstance(self.allowed_instance_types, list):
                props['AllowedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_instance_types
                ]
            else:
                props['AllowedInstanceTypes'] = self.allowed_instance_types

        if self.accelerator_count is not None:
            if hasattr(self.accelerator_count, 'to_dict'):
                props['AcceleratorCount'] = self.accelerator_count.to_dict()
            elif isinstance(self.accelerator_count, list):
                props['AcceleratorCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_count
                ]
            else:
                props['AcceleratorCount'] = self.accelerator_count

        if self.network_bandwidth_gbps is not None:
            if hasattr(self.network_bandwidth_gbps, 'to_dict'):
                props['NetworkBandwidthGbps'] = self.network_bandwidth_gbps.to_dict()
            elif isinstance(self.network_bandwidth_gbps, list):
                props['NetworkBandwidthGbps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_bandwidth_gbps
                ]
            else:
                props['NetworkBandwidthGbps'] = self.network_bandwidth_gbps

        if self.baseline_performance_factors is not None:
            if hasattr(self.baseline_performance_factors, 'to_dict'):
                props['BaselinePerformanceFactors'] = self.baseline_performance_factors.to_dict()
            elif isinstance(self.baseline_performance_factors, list):
                props['BaselinePerformanceFactors'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baseline_performance_factors
                ]
            else:
                props['BaselinePerformanceFactors'] = self.baseline_performance_factors

        if self.baseline_ebs_bandwidth_mbps is not None:
            if hasattr(self.baseline_ebs_bandwidth_mbps, 'to_dict'):
                props['BaselineEbsBandwidthMbps'] = self.baseline_ebs_bandwidth_mbps.to_dict()
            elif isinstance(self.baseline_ebs_bandwidth_mbps, list):
                props['BaselineEbsBandwidthMbps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baseline_ebs_bandwidth_mbps
                ]
            else:
                props['BaselineEbsBandwidthMbps'] = self.baseline_ebs_bandwidth_mbps

        if self.spot_max_price_percentage_over_lowest_price is not None:
            if hasattr(self.spot_max_price_percentage_over_lowest_price, 'to_dict'):
                props['SpotMaxPricePercentageOverLowestPrice'] = self.spot_max_price_percentage_over_lowest_price.to_dict()
            elif isinstance(self.spot_max_price_percentage_over_lowest_price, list):
                props['SpotMaxPricePercentageOverLowestPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_max_price_percentage_over_lowest_price
                ]
            else:
                props['SpotMaxPricePercentageOverLowestPrice'] = self.spot_max_price_percentage_over_lowest_price

        if self.accelerator_names is not None:
            if hasattr(self.accelerator_names, 'to_dict'):
                props['AcceleratorNames'] = self.accelerator_names.to_dict()
            elif isinstance(self.accelerator_names, list):
                props['AcceleratorNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_names
                ]
            else:
                props['AcceleratorNames'] = self.accelerator_names

        if self.accelerator_total_memory_mi_b is not None:
            if hasattr(self.accelerator_total_memory_mi_b, 'to_dict'):
                props['AcceleratorTotalMemoryMiB'] = self.accelerator_total_memory_mi_b.to_dict()
            elif isinstance(self.accelerator_total_memory_mi_b, list):
                props['AcceleratorTotalMemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_total_memory_mi_b
                ]
            else:
                props['AcceleratorTotalMemoryMiB'] = self.accelerator_total_memory_mi_b

        if self.burstable_performance is not None:
            if hasattr(self.burstable_performance, 'to_dict'):
                props['BurstablePerformance'] = self.burstable_performance.to_dict()
            elif isinstance(self.burstable_performance, list):
                props['BurstablePerformance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.burstable_performance
                ]
            else:
                props['BurstablePerformance'] = self.burstable_performance

        if self.total_local_storage_gb is not None:
            if hasattr(self.total_local_storage_gb, 'to_dict'):
                props['TotalLocalStorageGB'] = self.total_local_storage_gb.to_dict()
            elif isinstance(self.total_local_storage_gb, list):
                props['TotalLocalStorageGB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_local_storage_gb
                ]
            else:
                props['TotalLocalStorageGB'] = self.total_local_storage_gb

        return props


@dataclass
class InstancesDistribution:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_allocation_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_base_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_percentage_above_base_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_instance_pools: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_allocation_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_max_price: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.on_demand_allocation_strategy is not None:
            if hasattr(self.on_demand_allocation_strategy, 'to_dict'):
                props['OnDemandAllocationStrategy'] = self.on_demand_allocation_strategy.to_dict()
            elif isinstance(self.on_demand_allocation_strategy, list):
                props['OnDemandAllocationStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_allocation_strategy
                ]
            else:
                props['OnDemandAllocationStrategy'] = self.on_demand_allocation_strategy

        if self.on_demand_base_capacity is not None:
            if hasattr(self.on_demand_base_capacity, 'to_dict'):
                props['OnDemandBaseCapacity'] = self.on_demand_base_capacity.to_dict()
            elif isinstance(self.on_demand_base_capacity, list):
                props['OnDemandBaseCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_base_capacity
                ]
            else:
                props['OnDemandBaseCapacity'] = self.on_demand_base_capacity

        if self.on_demand_percentage_above_base_capacity is not None:
            if hasattr(self.on_demand_percentage_above_base_capacity, 'to_dict'):
                props['OnDemandPercentageAboveBaseCapacity'] = self.on_demand_percentage_above_base_capacity.to_dict()
            elif isinstance(self.on_demand_percentage_above_base_capacity, list):
                props['OnDemandPercentageAboveBaseCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_percentage_above_base_capacity
                ]
            else:
                props['OnDemandPercentageAboveBaseCapacity'] = self.on_demand_percentage_above_base_capacity

        if self.spot_instance_pools is not None:
            if hasattr(self.spot_instance_pools, 'to_dict'):
                props['SpotInstancePools'] = self.spot_instance_pools.to_dict()
            elif isinstance(self.spot_instance_pools, list):
                props['SpotInstancePools'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_instance_pools
                ]
            else:
                props['SpotInstancePools'] = self.spot_instance_pools

        if self.spot_allocation_strategy is not None:
            if hasattr(self.spot_allocation_strategy, 'to_dict'):
                props['SpotAllocationStrategy'] = self.spot_allocation_strategy.to_dict()
            elif isinstance(self.spot_allocation_strategy, list):
                props['SpotAllocationStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_allocation_strategy
                ]
            else:
                props['SpotAllocationStrategy'] = self.spot_allocation_strategy

        if self.spot_max_price is not None:
            if hasattr(self.spot_max_price, 'to_dict'):
                props['SpotMaxPrice'] = self.spot_max_price.to_dict()
            elif isinstance(self.spot_max_price, list):
                props['SpotMaxPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_max_price
                ]
            else:
                props['SpotMaxPrice'] = self.spot_max_price

        return props


@dataclass
class LaunchTemplate:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_specification: Optional[LaunchTemplateSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    overrides: Optional[list[LaunchTemplateOverrides]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.launch_template_specification is not None:
            if hasattr(self.launch_template_specification, 'to_dict'):
                props['LaunchTemplateSpecification'] = self.launch_template_specification.to_dict()
            elif isinstance(self.launch_template_specification, list):
                props['LaunchTemplateSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_specification
                ]
            else:
                props['LaunchTemplateSpecification'] = self.launch_template_specification

        if self.overrides is not None:
            if hasattr(self.overrides, 'to_dict'):
                props['Overrides'] = self.overrides.to_dict()
            elif isinstance(self.overrides, list):
                props['Overrides'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.overrides
                ]
            else:
                props['Overrides'] = self.overrides

        return props


@dataclass
class LaunchTemplateOverrides:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_specification: Optional[LaunchTemplateSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    weighted_capacity: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_requirements: Optional[InstanceRequirements] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.launch_template_specification is not None:
            if hasattr(self.launch_template_specification, 'to_dict'):
                props['LaunchTemplateSpecification'] = self.launch_template_specification.to_dict()
            elif isinstance(self.launch_template_specification, list):
                props['LaunchTemplateSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_specification
                ]
            else:
                props['LaunchTemplateSpecification'] = self.launch_template_specification

        if self.weighted_capacity is not None:
            if hasattr(self.weighted_capacity, 'to_dict'):
                props['WeightedCapacity'] = self.weighted_capacity.to_dict()
            elif isinstance(self.weighted_capacity, list):
                props['WeightedCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weighted_capacity
                ]
            else:
                props['WeightedCapacity'] = self.weighted_capacity

        if self.instance_requirements is not None:
            if hasattr(self.instance_requirements, 'to_dict'):
                props['InstanceRequirements'] = self.instance_requirements.to_dict()
            elif isinstance(self.instance_requirements, list):
                props['InstanceRequirements'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_requirements
                ]
            else:
                props['InstanceRequirements'] = self.instance_requirements

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        return props


@dataclass
class LaunchTemplateSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.launch_template_name is not None:
            if hasattr(self.launch_template_name, 'to_dict'):
                props['LaunchTemplateName'] = self.launch_template_name.to_dict()
            elif isinstance(self.launch_template_name, list):
                props['LaunchTemplateName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_name
                ]
            else:
                props['LaunchTemplateName'] = self.launch_template_name

        if self.version is not None:
            if hasattr(self.version, 'to_dict'):
                props['Version'] = self.version.to_dict()
            elif isinstance(self.version, list):
                props['Version'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version
                ]
            else:
                props['Version'] = self.version

        if self.launch_template_id is not None:
            if hasattr(self.launch_template_id, 'to_dict'):
                props['LaunchTemplateId'] = self.launch_template_id.to_dict()
            elif isinstance(self.launch_template_id, list):
                props['LaunchTemplateId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_id
                ]
            else:
                props['LaunchTemplateId'] = self.launch_template_id

        return props


@dataclass
class LifecycleHookSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_hook_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_transition: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    heartbeat_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notification_metadata: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_result: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notification_target_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.lifecycle_hook_name is not None:
            if hasattr(self.lifecycle_hook_name, 'to_dict'):
                props['LifecycleHookName'] = self.lifecycle_hook_name.to_dict()
            elif isinstance(self.lifecycle_hook_name, list):
                props['LifecycleHookName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_hook_name
                ]
            else:
                props['LifecycleHookName'] = self.lifecycle_hook_name

        if self.lifecycle_transition is not None:
            if hasattr(self.lifecycle_transition, 'to_dict'):
                props['LifecycleTransition'] = self.lifecycle_transition.to_dict()
            elif isinstance(self.lifecycle_transition, list):
                props['LifecycleTransition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_transition
                ]
            else:
                props['LifecycleTransition'] = self.lifecycle_transition

        if self.heartbeat_timeout is not None:
            if hasattr(self.heartbeat_timeout, 'to_dict'):
                props['HeartbeatTimeout'] = self.heartbeat_timeout.to_dict()
            elif isinstance(self.heartbeat_timeout, list):
                props['HeartbeatTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.heartbeat_timeout
                ]
            else:
                props['HeartbeatTimeout'] = self.heartbeat_timeout

        if self.notification_metadata is not None:
            if hasattr(self.notification_metadata, 'to_dict'):
                props['NotificationMetadata'] = self.notification_metadata.to_dict()
            elif isinstance(self.notification_metadata, list):
                props['NotificationMetadata'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_metadata
                ]
            else:
                props['NotificationMetadata'] = self.notification_metadata

        if self.default_result is not None:
            if hasattr(self.default_result, 'to_dict'):
                props['DefaultResult'] = self.default_result.to_dict()
            elif isinstance(self.default_result, list):
                props['DefaultResult'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_result
                ]
            else:
                props['DefaultResult'] = self.default_result

        if self.notification_target_arn is not None:
            if hasattr(self.notification_target_arn, 'to_dict'):
                props['NotificationTargetARN'] = self.notification_target_arn.to_dict()
            elif isinstance(self.notification_target_arn, list):
                props['NotificationTargetARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_target_arn
                ]
            else:
                props['NotificationTargetARN'] = self.notification_target_arn

        if self.role_arn is not None:
            if hasattr(self.role_arn, 'to_dict'):
                props['RoleARN'] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                props['RoleARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props['RoleARN'] = self.role_arn

        return props


@dataclass
class MemoryGiBPerVCpuRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class MemoryMiBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class MetricsCollection:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metrics: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    granularity: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metrics is not None:
            if hasattr(self.metrics, 'to_dict'):
                props['Metrics'] = self.metrics.to_dict()
            elif isinstance(self.metrics, list):
                props['Metrics'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metrics
                ]
            else:
                props['Metrics'] = self.metrics

        if self.granularity is not None:
            if hasattr(self.granularity, 'to_dict'):
                props['Granularity'] = self.granularity.to_dict()
            elif isinstance(self.granularity, list):
                props['Granularity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.granularity
                ]
            else:
                props['Granularity'] = self.granularity

        return props


@dataclass
class MixedInstancesPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instances_distribution: Optional[InstancesDistribution] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template: Optional[LaunchTemplate] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instances_distribution is not None:
            if hasattr(self.instances_distribution, 'to_dict'):
                props['InstancesDistribution'] = self.instances_distribution.to_dict()
            elif isinstance(self.instances_distribution, list):
                props['InstancesDistribution'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instances_distribution
                ]
            else:
                props['InstancesDistribution'] = self.instances_distribution

        if self.launch_template is not None:
            if hasattr(self.launch_template, 'to_dict'):
                props['LaunchTemplate'] = self.launch_template.to_dict()
            elif isinstance(self.launch_template, list):
                props['LaunchTemplate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template
                ]
            else:
                props['LaunchTemplate'] = self.launch_template

        return props


@dataclass
class NetworkBandwidthGbpsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class NetworkInterfaceCountRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class NotificationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    topic_arn: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notification_types: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.topic_arn is not None:
            if hasattr(self.topic_arn, 'to_dict'):
                props['TopicARN'] = self.topic_arn.to_dict()
            elif isinstance(self.topic_arn, list):
                props['TopicARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.topic_arn
                ]
            else:
                props['TopicARN'] = self.topic_arn

        if self.notification_types is not None:
            if hasattr(self.notification_types, 'to_dict'):
                props['NotificationTypes'] = self.notification_types.to_dict()
            elif isinstance(self.notification_types, list):
                props['NotificationTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_types
                ]
            else:
                props['NotificationTypes'] = self.notification_types

        return props


@dataclass
class PerformanceFactorReferenceRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_family: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_family is not None:
            if hasattr(self.instance_family, 'to_dict'):
                props['InstanceFamily'] = self.instance_family.to_dict()
            elif isinstance(self.instance_family, list):
                props['InstanceFamily'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_family
                ]
            else:
                props['InstanceFamily'] = self.instance_family

        return props


@dataclass
class TagProperty:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    propagate_at_launch: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        if self.propagate_at_launch is not None:
            if hasattr(self.propagate_at_launch, 'to_dict'):
                props['PropagateAtLaunch'] = self.propagate_at_launch.to_dict()
            elif isinstance(self.propagate_at_launch, list):
                props['PropagateAtLaunch'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.propagate_at_launch
                ]
            else:
                props['PropagateAtLaunch'] = self.propagate_at_launch

        return props


@dataclass
class TotalLocalStorageGBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class TrafficSourceIdentifier:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.identifier is not None:
            if hasattr(self.identifier, 'to_dict'):
                props['Identifier'] = self.identifier.to_dict()
            elif isinstance(self.identifier, list):
                props['Identifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.identifier
                ]
            else:
                props['Identifier'] = self.identifier

        return props


@dataclass
class VCpuCountRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class AutoScalingGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autos"""

    resource_type: ClassVar[str] = "AWS::AutoScaling::AutoScalingGroup"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    lifecycle_hook_specification_list: Optional[list[LifecycleHookSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    load_balancer_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_configuration_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_linked_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone_impairment_policy: Optional[AvailabilityZoneImpairmentPolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_group_ar_ns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cooldown: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    notification_configurations: Optional[list[NotificationConfiguration]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    desired_capacity: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    health_check_grace_period: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_instance_warmup: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    skip_zonal_shift_validation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    new_instances_protected_from_scale_in: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_template: Optional[LaunchTemplateSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    mixed_instances_policy: Optional[MixedInstancesPolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_zone_identifier: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[TagProperty]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    context: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    capacity_rebalance: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zones: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone_distribution: Optional[AvailabilityZoneDistribution] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metrics_collection: Optional[list[MetricsCollection]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_maintenance_policy: Optional[InstanceMaintenancePolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_size: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    min_size: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    termination_policies: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_scaling_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    traffic_sources: Optional[list[TrafficSourceIdentifier]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    desired_capacity_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    placement_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    capacity_reservation_specification: Optional[CapacityReservationSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    health_check_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_instance_lifetime: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.lifecycle_hook_specification_list is not None:
            # Serialize lifecycle_hook_specification_list (handle intrinsic functions)
            if hasattr(self.lifecycle_hook_specification_list, 'to_dict'):
                props["LifecycleHookSpecificationList"] = self.lifecycle_hook_specification_list.to_dict()
            elif isinstance(self.lifecycle_hook_specification_list, list):
                # Serialize list items (may contain intrinsic functions)
                props['LifecycleHookSpecificationList'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_hook_specification_list
                ]
            else:
                props["LifecycleHookSpecificationList"] = self.lifecycle_hook_specification_list

        if self.load_balancer_names is not None:
            # Serialize load_balancer_names (handle intrinsic functions)
            if hasattr(self.load_balancer_names, 'to_dict'):
                props["LoadBalancerNames"] = self.load_balancer_names.to_dict()
            elif isinstance(self.load_balancer_names, list):
                # Serialize list items (may contain intrinsic functions)
                props['LoadBalancerNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_names
                ]
            else:
                props["LoadBalancerNames"] = self.load_balancer_names

        if self.launch_configuration_name is not None:
            # Serialize launch_configuration_name (handle intrinsic functions)
            if hasattr(self.launch_configuration_name, 'to_dict'):
                props["LaunchConfigurationName"] = self.launch_configuration_name.to_dict()
            elif isinstance(self.launch_configuration_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LaunchConfigurationName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_configuration_name
                ]
            else:
                props["LaunchConfigurationName"] = self.launch_configuration_name

        if self.service_linked_role_arn is not None:
            # Serialize service_linked_role_arn (handle intrinsic functions)
            if hasattr(self.service_linked_role_arn, 'to_dict'):
                props["ServiceLinkedRoleARN"] = self.service_linked_role_arn.to_dict()
            elif isinstance(self.service_linked_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceLinkedRoleARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_linked_role_arn
                ]
            else:
                props["ServiceLinkedRoleARN"] = self.service_linked_role_arn

        if self.availability_zone_impairment_policy is not None:
            # Serialize availability_zone_impairment_policy (handle intrinsic functions)
            if hasattr(self.availability_zone_impairment_policy, 'to_dict'):
                props["AvailabilityZoneImpairmentPolicy"] = self.availability_zone_impairment_policy.to_dict()
            elif isinstance(self.availability_zone_impairment_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZoneImpairmentPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone_impairment_policy
                ]
            else:
                props["AvailabilityZoneImpairmentPolicy"] = self.availability_zone_impairment_policy

        if self.target_group_ar_ns is not None:
            # Serialize target_group_ar_ns (handle intrinsic functions)
            if hasattr(self.target_group_ar_ns, 'to_dict'):
                props["TargetGroupARNs"] = self.target_group_ar_ns.to_dict()
            elif isinstance(self.target_group_ar_ns, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetGroupARNs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_group_ar_ns
                ]
            else:
                props["TargetGroupARNs"] = self.target_group_ar_ns

        if self.cooldown is not None:
            # Serialize cooldown (handle intrinsic functions)
            if hasattr(self.cooldown, 'to_dict'):
                props["Cooldown"] = self.cooldown.to_dict()
            elif isinstance(self.cooldown, list):
                # Serialize list items (may contain intrinsic functions)
                props['Cooldown'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cooldown
                ]
            else:
                props["Cooldown"] = self.cooldown

        if self.notification_configurations is not None:
            # Serialize notification_configurations (handle intrinsic functions)
            if hasattr(self.notification_configurations, 'to_dict'):
                props["NotificationConfigurations"] = self.notification_configurations.to_dict()
            elif isinstance(self.notification_configurations, list):
                # Serialize list items (may contain intrinsic functions)
                props['NotificationConfigurations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_configurations
                ]
            else:
                props["NotificationConfigurations"] = self.notification_configurations

        if self.desired_capacity is not None:
            # Serialize desired_capacity (handle intrinsic functions)
            if hasattr(self.desired_capacity, 'to_dict'):
                props["DesiredCapacity"] = self.desired_capacity.to_dict()
            elif isinstance(self.desired_capacity, list):
                # Serialize list items (may contain intrinsic functions)
                props['DesiredCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.desired_capacity
                ]
            else:
                props["DesiredCapacity"] = self.desired_capacity

        if self.health_check_grace_period is not None:
            # Serialize health_check_grace_period (handle intrinsic functions)
            if hasattr(self.health_check_grace_period, 'to_dict'):
                props["HealthCheckGracePeriod"] = self.health_check_grace_period.to_dict()
            elif isinstance(self.health_check_grace_period, list):
                # Serialize list items (may contain intrinsic functions)
                props['HealthCheckGracePeriod'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.health_check_grace_period
                ]
            else:
                props["HealthCheckGracePeriod"] = self.health_check_grace_period

        if self.default_instance_warmup is not None:
            # Serialize default_instance_warmup (handle intrinsic functions)
            if hasattr(self.default_instance_warmup, 'to_dict'):
                props["DefaultInstanceWarmup"] = self.default_instance_warmup.to_dict()
            elif isinstance(self.default_instance_warmup, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultInstanceWarmup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_instance_warmup
                ]
            else:
                props["DefaultInstanceWarmup"] = self.default_instance_warmup

        if self.skip_zonal_shift_validation is not None:
            # Serialize skip_zonal_shift_validation (handle intrinsic functions)
            if hasattr(self.skip_zonal_shift_validation, 'to_dict'):
                props["SkipZonalShiftValidation"] = self.skip_zonal_shift_validation.to_dict()
            elif isinstance(self.skip_zonal_shift_validation, list):
                # Serialize list items (may contain intrinsic functions)
                props['SkipZonalShiftValidation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.skip_zonal_shift_validation
                ]
            else:
                props["SkipZonalShiftValidation"] = self.skip_zonal_shift_validation

        if self.new_instances_protected_from_scale_in is not None:
            # Serialize new_instances_protected_from_scale_in (handle intrinsic functions)
            if hasattr(self.new_instances_protected_from_scale_in, 'to_dict'):
                props["NewInstancesProtectedFromScaleIn"] = self.new_instances_protected_from_scale_in.to_dict()
            elif isinstance(self.new_instances_protected_from_scale_in, list):
                # Serialize list items (may contain intrinsic functions)
                props['NewInstancesProtectedFromScaleIn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.new_instances_protected_from_scale_in
                ]
            else:
                props["NewInstancesProtectedFromScaleIn"] = self.new_instances_protected_from_scale_in

        if self.launch_template is not None:
            # Serialize launch_template (handle intrinsic functions)
            if hasattr(self.launch_template, 'to_dict'):
                props["LaunchTemplate"] = self.launch_template.to_dict()
            elif isinstance(self.launch_template, list):
                # Serialize list items (may contain intrinsic functions)
                props['LaunchTemplate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template
                ]
            else:
                props["LaunchTemplate"] = self.launch_template

        if self.mixed_instances_policy is not None:
            # Serialize mixed_instances_policy (handle intrinsic functions)
            if hasattr(self.mixed_instances_policy, 'to_dict'):
                props["MixedInstancesPolicy"] = self.mixed_instances_policy.to_dict()
            elif isinstance(self.mixed_instances_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['MixedInstancesPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mixed_instances_policy
                ]
            else:
                props["MixedInstancesPolicy"] = self.mixed_instances_policy

        if self.vpc_zone_identifier is not None:
            # Serialize vpc_zone_identifier (handle intrinsic functions)
            if hasattr(self.vpc_zone_identifier, 'to_dict'):
                props["VPCZoneIdentifier"] = self.vpc_zone_identifier.to_dict()
            elif isinstance(self.vpc_zone_identifier, list):
                # Serialize list items (may contain intrinsic functions)
                props['VPCZoneIdentifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_zone_identifier
                ]
            else:
                props["VPCZoneIdentifier"] = self.vpc_zone_identifier

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.context is not None:
            # Serialize context (handle intrinsic functions)
            if hasattr(self.context, 'to_dict'):
                props["Context"] = self.context.to_dict()
            elif isinstance(self.context, list):
                # Serialize list items (may contain intrinsic functions)
                props['Context'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.context
                ]
            else:
                props["Context"] = self.context

        if self.capacity_rebalance is not None:
            # Serialize capacity_rebalance (handle intrinsic functions)
            if hasattr(self.capacity_rebalance, 'to_dict'):
                props["CapacityRebalance"] = self.capacity_rebalance.to_dict()
            elif isinstance(self.capacity_rebalance, list):
                # Serialize list items (may contain intrinsic functions)
                props['CapacityRebalance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_rebalance
                ]
            else:
                props["CapacityRebalance"] = self.capacity_rebalance

        if self.instance_id is not None:
            # Serialize instance_id (handle intrinsic functions)
            if hasattr(self.instance_id, 'to_dict'):
                props["InstanceId"] = self.instance_id.to_dict()
            elif isinstance(self.instance_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_id
                ]
            else:
                props["InstanceId"] = self.instance_id

        if self.availability_zones is not None:
            # Serialize availability_zones (handle intrinsic functions)
            if hasattr(self.availability_zones, 'to_dict'):
                props["AvailabilityZones"] = self.availability_zones.to_dict()
            elif isinstance(self.availability_zones, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZones'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zones
                ]
            else:
                props["AvailabilityZones"] = self.availability_zones

        if self.availability_zone_distribution is not None:
            # Serialize availability_zone_distribution (handle intrinsic functions)
            if hasattr(self.availability_zone_distribution, 'to_dict'):
                props["AvailabilityZoneDistribution"] = self.availability_zone_distribution.to_dict()
            elif isinstance(self.availability_zone_distribution, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZoneDistribution'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone_distribution
                ]
            else:
                props["AvailabilityZoneDistribution"] = self.availability_zone_distribution

        if self.metrics_collection is not None:
            # Serialize metrics_collection (handle intrinsic functions)
            if hasattr(self.metrics_collection, 'to_dict'):
                props["MetricsCollection"] = self.metrics_collection.to_dict()
            elif isinstance(self.metrics_collection, list):
                # Serialize list items (may contain intrinsic functions)
                props['MetricsCollection'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metrics_collection
                ]
            else:
                props["MetricsCollection"] = self.metrics_collection

        if self.instance_maintenance_policy is not None:
            # Serialize instance_maintenance_policy (handle intrinsic functions)
            if hasattr(self.instance_maintenance_policy, 'to_dict'):
                props["InstanceMaintenancePolicy"] = self.instance_maintenance_policy.to_dict()
            elif isinstance(self.instance_maintenance_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceMaintenancePolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_maintenance_policy
                ]
            else:
                props["InstanceMaintenancePolicy"] = self.instance_maintenance_policy

        if self.max_size is not None:
            # Serialize max_size (handle intrinsic functions)
            if hasattr(self.max_size, 'to_dict'):
                props["MaxSize"] = self.max_size.to_dict()
            elif isinstance(self.max_size, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_size
                ]
            else:
                props["MaxSize"] = self.max_size

        if self.min_size is not None:
            # Serialize min_size (handle intrinsic functions)
            if hasattr(self.min_size, 'to_dict'):
                props["MinSize"] = self.min_size.to_dict()
            elif isinstance(self.min_size, list):
                # Serialize list items (may contain intrinsic functions)
                props['MinSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_size
                ]
            else:
                props["MinSize"] = self.min_size

        if self.termination_policies is not None:
            # Serialize termination_policies (handle intrinsic functions)
            if hasattr(self.termination_policies, 'to_dict'):
                props["TerminationPolicies"] = self.termination_policies.to_dict()
            elif isinstance(self.termination_policies, list):
                # Serialize list items (may contain intrinsic functions)
                props['TerminationPolicies'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.termination_policies
                ]
            else:
                props["TerminationPolicies"] = self.termination_policies

        if self.auto_scaling_group_name is not None:
            # Serialize auto_scaling_group_name (handle intrinsic functions)
            if hasattr(self.auto_scaling_group_name, 'to_dict'):
                props["AutoScalingGroupName"] = self.auto_scaling_group_name.to_dict()
            elif isinstance(self.auto_scaling_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoScalingGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_scaling_group_name
                ]
            else:
                props["AutoScalingGroupName"] = self.auto_scaling_group_name

        if self.traffic_sources is not None:
            # Serialize traffic_sources (handle intrinsic functions)
            if hasattr(self.traffic_sources, 'to_dict'):
                props["TrafficSources"] = self.traffic_sources.to_dict()
            elif isinstance(self.traffic_sources, list):
                # Serialize list items (may contain intrinsic functions)
                props['TrafficSources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.traffic_sources
                ]
            else:
                props["TrafficSources"] = self.traffic_sources

        if self.desired_capacity_type is not None:
            # Serialize desired_capacity_type (handle intrinsic functions)
            if hasattr(self.desired_capacity_type, 'to_dict'):
                props["DesiredCapacityType"] = self.desired_capacity_type.to_dict()
            elif isinstance(self.desired_capacity_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['DesiredCapacityType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.desired_capacity_type
                ]
            else:
                props["DesiredCapacityType"] = self.desired_capacity_type

        if self.placement_group is not None:
            # Serialize placement_group (handle intrinsic functions)
            if hasattr(self.placement_group, 'to_dict'):
                props["PlacementGroup"] = self.placement_group.to_dict()
            elif isinstance(self.placement_group, list):
                # Serialize list items (may contain intrinsic functions)
                props['PlacementGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.placement_group
                ]
            else:
                props["PlacementGroup"] = self.placement_group

        if self.capacity_reservation_specification is not None:
            # Serialize capacity_reservation_specification (handle intrinsic functions)
            if hasattr(self.capacity_reservation_specification, 'to_dict'):
                props["CapacityReservationSpecification"] = self.capacity_reservation_specification.to_dict()
            elif isinstance(self.capacity_reservation_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['CapacityReservationSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_specification
                ]
            else:
                props["CapacityReservationSpecification"] = self.capacity_reservation_specification

        if self.health_check_type is not None:
            # Serialize health_check_type (handle intrinsic functions)
            if hasattr(self.health_check_type, 'to_dict'):
                props["HealthCheckType"] = self.health_check_type.to_dict()
            elif isinstance(self.health_check_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['HealthCheckType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.health_check_type
                ]
            else:
                props["HealthCheckType"] = self.health_check_type

        if self.max_instance_lifetime is not None:
            # Serialize max_instance_lifetime (handle intrinsic functions)
            if hasattr(self.max_instance_lifetime, 'to_dict'):
                props["MaxInstanceLifetime"] = self.max_instance_lifetime.to_dict()
            elif isinstance(self.max_instance_lifetime, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxInstanceLifetime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_instance_lifetime
                ]
            else:
                props["MaxInstanceLifetime"] = self.max_instance_lifetime

        return props

    @property
    def attr_auto_scaling_group_arn(self) -> GetAtt:
        """Get the AutoScalingGroupARN attribute."""
        return self.get_att("AutoScalingGroupARN")




@dataclass
class BlockDevice:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snapshot_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encrypted: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    throughput: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.snapshot_id is not None:
            if hasattr(self.snapshot_id, 'to_dict'):
                props['SnapshotId'] = self.snapshot_id.to_dict()
            elif isinstance(self.snapshot_id, list):
                props['SnapshotId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snapshot_id
                ]
            else:
                props['SnapshotId'] = self.snapshot_id

        if self.volume_type is not None:
            if hasattr(self.volume_type, 'to_dict'):
                props['VolumeType'] = self.volume_type.to_dict()
            elif isinstance(self.volume_type, list):
                props['VolumeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_type
                ]
            else:
                props['VolumeType'] = self.volume_type

        if self.encrypted is not None:
            if hasattr(self.encrypted, 'to_dict'):
                props['Encrypted'] = self.encrypted.to_dict()
            elif isinstance(self.encrypted, list):
                props['Encrypted'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encrypted
                ]
            else:
                props['Encrypted'] = self.encrypted

        if self.throughput is not None:
            if hasattr(self.throughput, 'to_dict'):
                props['Throughput'] = self.throughput.to_dict()
            elif isinstance(self.throughput, list):
                props['Throughput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.throughput
                ]
            else:
                props['Throughput'] = self.throughput

        if self.iops is not None:
            if hasattr(self.iops, 'to_dict'):
                props['Iops'] = self.iops.to_dict()
            elif isinstance(self.iops, list):
                props['Iops'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iops
                ]
            else:
                props['Iops'] = self.iops

        if self.volume_size is not None:
            if hasattr(self.volume_size, 'to_dict'):
                props['VolumeSize'] = self.volume_size.to_dict()
            elif isinstance(self.volume_size, list):
                props['VolumeSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size
                ]
            else:
                props['VolumeSize'] = self.volume_size

        if self.delete_on_termination is not None:
            if hasattr(self.delete_on_termination, 'to_dict'):
                props['DeleteOnTermination'] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props['DeleteOnTermination'] = self.delete_on_termination

        return props


@dataclass
class BlockDeviceMapping:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs: Optional[BlockDevice] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    no_device: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    virtual_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ebs is not None:
            if hasattr(self.ebs, 'to_dict'):
                props['Ebs'] = self.ebs.to_dict()
            elif isinstance(self.ebs, list):
                props['Ebs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs
                ]
            else:
                props['Ebs'] = self.ebs

        if self.no_device is not None:
            if hasattr(self.no_device, 'to_dict'):
                props['NoDevice'] = self.no_device.to_dict()
            elif isinstance(self.no_device, list):
                props['NoDevice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.no_device
                ]
            else:
                props['NoDevice'] = self.no_device

        if self.virtual_name is not None:
            if hasattr(self.virtual_name, 'to_dict'):
                props['VirtualName'] = self.virtual_name.to_dict()
            elif isinstance(self.virtual_name, list):
                props['VirtualName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.virtual_name
                ]
            else:
                props['VirtualName'] = self.virtual_name

        if self.device_name is not None:
            if hasattr(self.device_name, 'to_dict'):
                props['DeviceName'] = self.device_name.to_dict()
            elif isinstance(self.device_name, list):
                props['DeviceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_name
                ]
            else:
                props['DeviceName'] = self.device_name

        return props


@dataclass
class MetadataOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_put_response_hop_limit: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_tokens: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.http_put_response_hop_limit is not None:
            if hasattr(self.http_put_response_hop_limit, 'to_dict'):
                props['HttpPutResponseHopLimit'] = self.http_put_response_hop_limit.to_dict()
            elif isinstance(self.http_put_response_hop_limit, list):
                props['HttpPutResponseHopLimit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_put_response_hop_limit
                ]
            else:
                props['HttpPutResponseHopLimit'] = self.http_put_response_hop_limit

        if self.http_tokens is not None:
            if hasattr(self.http_tokens, 'to_dict'):
                props['HttpTokens'] = self.http_tokens.to_dict()
            elif isinstance(self.http_tokens, list):
                props['HttpTokens'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_tokens
                ]
            else:
                props['HttpTokens'] = self.http_tokens

        if self.http_endpoint is not None:
            if hasattr(self.http_endpoint, 'to_dict'):
                props['HttpEndpoint'] = self.http_endpoint.to_dict()
            elif isinstance(self.http_endpoint, list):
                props['HttpEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_endpoint
                ]
            else:
                props['HttpEndpoint'] = self.http_endpoint

        return props


@dataclass
class LaunchConfiguration(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autos"""

    resource_type: ClassVar[str] = "AWS::AutoScaling::LaunchConfiguration"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    placement_tenancy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_configuration_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metadata_options: Optional[MetadataOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    user_data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    classic_link_vpc_security_groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    block_device_mappings: Optional[list[BlockDeviceMapping]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    iam_instance_profile: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kernel_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    associate_public_ip_address: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    classic_link_vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ebs_optimized: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    key_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    spot_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    image_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ram_disk_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_monitoring: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.placement_tenancy is not None:
            # Serialize placement_tenancy (handle intrinsic functions)
            if hasattr(self.placement_tenancy, 'to_dict'):
                props["PlacementTenancy"] = self.placement_tenancy.to_dict()
            elif isinstance(self.placement_tenancy, list):
                # Serialize list items (may contain intrinsic functions)
                props['PlacementTenancy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.placement_tenancy
                ]
            else:
                props["PlacementTenancy"] = self.placement_tenancy

        if self.security_groups is not None:
            # Serialize security_groups (handle intrinsic functions)
            if hasattr(self.security_groups, 'to_dict'):
                props["SecurityGroups"] = self.security_groups.to_dict()
            elif isinstance(self.security_groups, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_groups
                ]
            else:
                props["SecurityGroups"] = self.security_groups

        if self.launch_configuration_name is not None:
            # Serialize launch_configuration_name (handle intrinsic functions)
            if hasattr(self.launch_configuration_name, 'to_dict'):
                props["LaunchConfigurationName"] = self.launch_configuration_name.to_dict()
            elif isinstance(self.launch_configuration_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LaunchConfigurationName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_configuration_name
                ]
            else:
                props["LaunchConfigurationName"] = self.launch_configuration_name

        if self.metadata_options is not None:
            # Serialize metadata_options (handle intrinsic functions)
            if hasattr(self.metadata_options, 'to_dict'):
                props["MetadataOptions"] = self.metadata_options.to_dict()
            elif isinstance(self.metadata_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['MetadataOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metadata_options
                ]
            else:
                props["MetadataOptions"] = self.metadata_options

        if self.instance_id is not None:
            # Serialize instance_id (handle intrinsic functions)
            if hasattr(self.instance_id, 'to_dict'):
                props["InstanceId"] = self.instance_id.to_dict()
            elif isinstance(self.instance_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_id
                ]
            else:
                props["InstanceId"] = self.instance_id

        if self.user_data is not None:
            # Serialize user_data (handle intrinsic functions)
            if hasattr(self.user_data, 'to_dict'):
                props["UserData"] = self.user_data.to_dict()
            elif isinstance(self.user_data, list):
                # Serialize list items (may contain intrinsic functions)
                props['UserData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_data
                ]
            else:
                props["UserData"] = self.user_data

        if self.classic_link_vpc_security_groups is not None:
            # Serialize classic_link_vpc_security_groups (handle intrinsic functions)
            if hasattr(self.classic_link_vpc_security_groups, 'to_dict'):
                props["ClassicLinkVPCSecurityGroups"] = self.classic_link_vpc_security_groups.to_dict()
            elif isinstance(self.classic_link_vpc_security_groups, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClassicLinkVPCSecurityGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.classic_link_vpc_security_groups
                ]
            else:
                props["ClassicLinkVPCSecurityGroups"] = self.classic_link_vpc_security_groups

        if self.block_device_mappings is not None:
            # Serialize block_device_mappings (handle intrinsic functions)
            if hasattr(self.block_device_mappings, 'to_dict'):
                props["BlockDeviceMappings"] = self.block_device_mappings.to_dict()
            elif isinstance(self.block_device_mappings, list):
                # Serialize list items (may contain intrinsic functions)
                props['BlockDeviceMappings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.block_device_mappings
                ]
            else:
                props["BlockDeviceMappings"] = self.block_device_mappings

        if self.iam_instance_profile is not None:
            # Serialize iam_instance_profile (handle intrinsic functions)
            if hasattr(self.iam_instance_profile, 'to_dict'):
                props["IamInstanceProfile"] = self.iam_instance_profile.to_dict()
            elif isinstance(self.iam_instance_profile, list):
                # Serialize list items (may contain intrinsic functions)
                props['IamInstanceProfile'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iam_instance_profile
                ]
            else:
                props["IamInstanceProfile"] = self.iam_instance_profile

        if self.kernel_id is not None:
            # Serialize kernel_id (handle intrinsic functions)
            if hasattr(self.kernel_id, 'to_dict'):
                props["KernelId"] = self.kernel_id.to_dict()
            elif isinstance(self.kernel_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['KernelId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kernel_id
                ]
            else:
                props["KernelId"] = self.kernel_id

        if self.associate_public_ip_address is not None:
            # Serialize associate_public_ip_address (handle intrinsic functions)
            if hasattr(self.associate_public_ip_address, 'to_dict'):
                props["AssociatePublicIpAddress"] = self.associate_public_ip_address.to_dict()
            elif isinstance(self.associate_public_ip_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['AssociatePublicIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.associate_public_ip_address
                ]
            else:
                props["AssociatePublicIpAddress"] = self.associate_public_ip_address

        if self.classic_link_vpc_id is not None:
            # Serialize classic_link_vpc_id (handle intrinsic functions)
            if hasattr(self.classic_link_vpc_id, 'to_dict'):
                props["ClassicLinkVPCId"] = self.classic_link_vpc_id.to_dict()
            elif isinstance(self.classic_link_vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClassicLinkVPCId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.classic_link_vpc_id
                ]
            else:
                props["ClassicLinkVPCId"] = self.classic_link_vpc_id

        if self.ebs_optimized is not None:
            # Serialize ebs_optimized (handle intrinsic functions)
            if hasattr(self.ebs_optimized, 'to_dict'):
                props["EbsOptimized"] = self.ebs_optimized.to_dict()
            elif isinstance(self.ebs_optimized, list):
                # Serialize list items (may contain intrinsic functions)
                props['EbsOptimized'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_optimized
                ]
            else:
                props["EbsOptimized"] = self.ebs_optimized

        if self.key_name is not None:
            # Serialize key_name (handle intrinsic functions)
            if hasattr(self.key_name, 'to_dict'):
                props["KeyName"] = self.key_name.to_dict()
            elif isinstance(self.key_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['KeyName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_name
                ]
            else:
                props["KeyName"] = self.key_name

        if self.spot_price is not None:
            # Serialize spot_price (handle intrinsic functions)
            if hasattr(self.spot_price, 'to_dict'):
                props["SpotPrice"] = self.spot_price.to_dict()
            elif isinstance(self.spot_price, list):
                # Serialize list items (may contain intrinsic functions)
                props['SpotPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_price
                ]
            else:
                props["SpotPrice"] = self.spot_price

        if self.image_id is not None:
            # Serialize image_id (handle intrinsic functions)
            if hasattr(self.image_id, 'to_dict'):
                props["ImageId"] = self.image_id.to_dict()
            elif isinstance(self.image_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ImageId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_id
                ]
            else:
                props["ImageId"] = self.image_id

        if self.instance_type is not None:
            # Serialize instance_type (handle intrinsic functions)
            if hasattr(self.instance_type, 'to_dict'):
                props["InstanceType"] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props["InstanceType"] = self.instance_type

        if self.ram_disk_id is not None:
            # Serialize ram_disk_id (handle intrinsic functions)
            if hasattr(self.ram_disk_id, 'to_dict'):
                props["RamDiskId"] = self.ram_disk_id.to_dict()
            elif isinstance(self.ram_disk_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RamDiskId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ram_disk_id
                ]
            else:
                props["RamDiskId"] = self.ram_disk_id

        if self.instance_monitoring is not None:
            # Serialize instance_monitoring (handle intrinsic functions)
            if hasattr(self.instance_monitoring, 'to_dict'):
                props["InstanceMonitoring"] = self.instance_monitoring.to_dict()
            elif isinstance(self.instance_monitoring, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceMonitoring'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_monitoring
                ]
            else:
                props["InstanceMonitoring"] = self.instance_monitoring

        return props



@dataclass
class LifecycleHook(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autos"""

    resource_type: ClassVar[str] = "AWS::AutoScaling::LifecycleHook"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    lifecycle_hook_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    lifecycle_transition: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_scaling_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    heartbeat_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    notification_metadata: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_result: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    notification_target_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.lifecycle_hook_name is not None:
            # Serialize lifecycle_hook_name (handle intrinsic functions)
            if hasattr(self.lifecycle_hook_name, 'to_dict'):
                props["LifecycleHookName"] = self.lifecycle_hook_name.to_dict()
            elif isinstance(self.lifecycle_hook_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LifecycleHookName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_hook_name
                ]
            else:
                props["LifecycleHookName"] = self.lifecycle_hook_name

        if self.lifecycle_transition is not None:
            # Serialize lifecycle_transition (handle intrinsic functions)
            if hasattr(self.lifecycle_transition, 'to_dict'):
                props["LifecycleTransition"] = self.lifecycle_transition.to_dict()
            elif isinstance(self.lifecycle_transition, list):
                # Serialize list items (may contain intrinsic functions)
                props['LifecycleTransition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_transition
                ]
            else:
                props["LifecycleTransition"] = self.lifecycle_transition

        if self.auto_scaling_group_name is not None:
            # Serialize auto_scaling_group_name (handle intrinsic functions)
            if hasattr(self.auto_scaling_group_name, 'to_dict'):
                props["AutoScalingGroupName"] = self.auto_scaling_group_name.to_dict()
            elif isinstance(self.auto_scaling_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoScalingGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_scaling_group_name
                ]
            else:
                props["AutoScalingGroupName"] = self.auto_scaling_group_name

        if self.heartbeat_timeout is not None:
            # Serialize heartbeat_timeout (handle intrinsic functions)
            if hasattr(self.heartbeat_timeout, 'to_dict'):
                props["HeartbeatTimeout"] = self.heartbeat_timeout.to_dict()
            elif isinstance(self.heartbeat_timeout, list):
                # Serialize list items (may contain intrinsic functions)
                props['HeartbeatTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.heartbeat_timeout
                ]
            else:
                props["HeartbeatTimeout"] = self.heartbeat_timeout

        if self.notification_metadata is not None:
            # Serialize notification_metadata (handle intrinsic functions)
            if hasattr(self.notification_metadata, 'to_dict'):
                props["NotificationMetadata"] = self.notification_metadata.to_dict()
            elif isinstance(self.notification_metadata, list):
                # Serialize list items (may contain intrinsic functions)
                props['NotificationMetadata'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_metadata
                ]
            else:
                props["NotificationMetadata"] = self.notification_metadata

        if self.default_result is not None:
            # Serialize default_result (handle intrinsic functions)
            if hasattr(self.default_result, 'to_dict'):
                props["DefaultResult"] = self.default_result.to_dict()
            elif isinstance(self.default_result, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultResult'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_result
                ]
            else:
                props["DefaultResult"] = self.default_result

        if self.notification_target_arn is not None:
            # Serialize notification_target_arn (handle intrinsic functions)
            if hasattr(self.notification_target_arn, 'to_dict'):
                props["NotificationTargetARN"] = self.notification_target_arn.to_dict()
            elif isinstance(self.notification_target_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['NotificationTargetARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_target_arn
                ]
            else:
                props["NotificationTargetARN"] = self.notification_target_arn

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleARN"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleARN"] = self.role_arn

        return props



@dataclass
class CustomizedMetricSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metrics: Optional[list[TargetTrackingMetricDataQuery]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    statistic: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dimensions: Optional[list[MetricDimension]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    period: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    namespace: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_name is not None:
            if hasattr(self.metric_name, 'to_dict'):
                props['MetricName'] = self.metric_name.to_dict()
            elif isinstance(self.metric_name, list):
                props['MetricName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_name
                ]
            else:
                props['MetricName'] = self.metric_name

        if self.metrics is not None:
            if hasattr(self.metrics, 'to_dict'):
                props['Metrics'] = self.metrics.to_dict()
            elif isinstance(self.metrics, list):
                props['Metrics'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metrics
                ]
            else:
                props['Metrics'] = self.metrics

        if self.statistic is not None:
            if hasattr(self.statistic, 'to_dict'):
                props['Statistic'] = self.statistic.to_dict()
            elif isinstance(self.statistic, list):
                props['Statistic'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.statistic
                ]
            else:
                props['Statistic'] = self.statistic

        if self.dimensions is not None:
            if hasattr(self.dimensions, 'to_dict'):
                props['Dimensions'] = self.dimensions.to_dict()
            elif isinstance(self.dimensions, list):
                props['Dimensions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dimensions
                ]
            else:
                props['Dimensions'] = self.dimensions

        if self.period is not None:
            if hasattr(self.period, 'to_dict'):
                props['Period'] = self.period.to_dict()
            elif isinstance(self.period, list):
                props['Period'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.period
                ]
            else:
                props['Period'] = self.period

        if self.unit is not None:
            if hasattr(self.unit, 'to_dict'):
                props['Unit'] = self.unit.to_dict()
            elif isinstance(self.unit, list):
                props['Unit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unit
                ]
            else:
                props['Unit'] = self.unit

        if self.namespace is not None:
            if hasattr(self.namespace, 'to_dict'):
                props['Namespace'] = self.namespace.to_dict()
            elif isinstance(self.namespace, list):
                props['Namespace'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.namespace
                ]
            else:
                props['Namespace'] = self.namespace

        return props


@dataclass
class Metric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dimensions: Optional[list[MetricDimension]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    namespace: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_name is not None:
            if hasattr(self.metric_name, 'to_dict'):
                props['MetricName'] = self.metric_name.to_dict()
            elif isinstance(self.metric_name, list):
                props['MetricName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_name
                ]
            else:
                props['MetricName'] = self.metric_name

        if self.dimensions is not None:
            if hasattr(self.dimensions, 'to_dict'):
                props['Dimensions'] = self.dimensions.to_dict()
            elif isinstance(self.dimensions, list):
                props['Dimensions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dimensions
                ]
            else:
                props['Dimensions'] = self.dimensions

        if self.namespace is not None:
            if hasattr(self.namespace, 'to_dict'):
                props['Namespace'] = self.namespace.to_dict()
            elif isinstance(self.namespace, list):
                props['Namespace'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.namespace
                ]
            else:
                props['Namespace'] = self.namespace

        return props


@dataclass
class MetricDataQuery:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    return_data: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    expression: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    label: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_stat: Optional[MetricStat] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.return_data is not None:
            if hasattr(self.return_data, 'to_dict'):
                props['ReturnData'] = self.return_data.to_dict()
            elif isinstance(self.return_data, list):
                props['ReturnData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.return_data
                ]
            else:
                props['ReturnData'] = self.return_data

        if self.expression is not None:
            if hasattr(self.expression, 'to_dict'):
                props['Expression'] = self.expression.to_dict()
            elif isinstance(self.expression, list):
                props['Expression'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.expression
                ]
            else:
                props['Expression'] = self.expression

        if self.label is not None:
            if hasattr(self.label, 'to_dict'):
                props['Label'] = self.label.to_dict()
            elif isinstance(self.label, list):
                props['Label'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.label
                ]
            else:
                props['Label'] = self.label

        if self.metric_stat is not None:
            if hasattr(self.metric_stat, 'to_dict'):
                props['MetricStat'] = self.metric_stat.to_dict()
            elif isinstance(self.metric_stat, list):
                props['MetricStat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_stat
                ]
            else:
                props['MetricStat'] = self.metric_stat

        if self.id is not None:
            if hasattr(self.id, 'to_dict'):
                props['Id'] = self.id.to_dict()
            elif isinstance(self.id, list):
                props['Id'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.id
                ]
            else:
                props['Id'] = self.id

        return props


@dataclass
class MetricDimension:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class MetricStat:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    stat: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric: Optional[Metric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.stat is not None:
            if hasattr(self.stat, 'to_dict'):
                props['Stat'] = self.stat.to_dict()
            elif isinstance(self.stat, list):
                props['Stat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stat
                ]
            else:
                props['Stat'] = self.stat

        if self.metric is not None:
            if hasattr(self.metric, 'to_dict'):
                props['Metric'] = self.metric.to_dict()
            elif isinstance(self.metric, list):
                props['Metric'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric
                ]
            else:
                props['Metric'] = self.metric

        if self.unit is not None:
            if hasattr(self.unit, 'to_dict'):
                props['Unit'] = self.unit.to_dict()
            elif isinstance(self.unit, list):
                props['Unit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unit
                ]
            else:
                props['Unit'] = self.unit

        return props


@dataclass
class PredefinedMetricSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_label: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.predefined_metric_type is not None:
            if hasattr(self.predefined_metric_type, 'to_dict'):
                props['PredefinedMetricType'] = self.predefined_metric_type.to_dict()
            elif isinstance(self.predefined_metric_type, list):
                props['PredefinedMetricType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_metric_type
                ]
            else:
                props['PredefinedMetricType'] = self.predefined_metric_type

        if self.resource_label is not None:
            if hasattr(self.resource_label, 'to_dict'):
                props['ResourceLabel'] = self.resource_label.to_dict()
            elif isinstance(self.resource_label, list):
                props['ResourceLabel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_label
                ]
            else:
                props['ResourceLabel'] = self.resource_label

        return props


@dataclass
class PredictiveScalingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_capacity_breach_behavior: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_capacity_buffer: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_specifications: Optional[list[PredictiveScalingMetricSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scheduling_buffer_time: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_capacity_breach_behavior is not None:
            if hasattr(self.max_capacity_breach_behavior, 'to_dict'):
                props['MaxCapacityBreachBehavior'] = self.max_capacity_breach_behavior.to_dict()
            elif isinstance(self.max_capacity_breach_behavior, list):
                props['MaxCapacityBreachBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_capacity_breach_behavior
                ]
            else:
                props['MaxCapacityBreachBehavior'] = self.max_capacity_breach_behavior

        if self.max_capacity_buffer is not None:
            if hasattr(self.max_capacity_buffer, 'to_dict'):
                props['MaxCapacityBuffer'] = self.max_capacity_buffer.to_dict()
            elif isinstance(self.max_capacity_buffer, list):
                props['MaxCapacityBuffer'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_capacity_buffer
                ]
            else:
                props['MaxCapacityBuffer'] = self.max_capacity_buffer

        if self.mode is not None:
            if hasattr(self.mode, 'to_dict'):
                props['Mode'] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props['Mode'] = self.mode

        if self.metric_specifications is not None:
            if hasattr(self.metric_specifications, 'to_dict'):
                props['MetricSpecifications'] = self.metric_specifications.to_dict()
            elif isinstance(self.metric_specifications, list):
                props['MetricSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_specifications
                ]
            else:
                props['MetricSpecifications'] = self.metric_specifications

        if self.scheduling_buffer_time is not None:
            if hasattr(self.scheduling_buffer_time, 'to_dict'):
                props['SchedulingBufferTime'] = self.scheduling_buffer_time.to_dict()
            elif isinstance(self.scheduling_buffer_time, list):
                props['SchedulingBufferTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scheduling_buffer_time
                ]
            else:
                props['SchedulingBufferTime'] = self.scheduling_buffer_time

        return props


@dataclass
class PredictiveScalingCustomizedCapacityMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_data_queries: Optional[list[MetricDataQuery]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_data_queries is not None:
            if hasattr(self.metric_data_queries, 'to_dict'):
                props['MetricDataQueries'] = self.metric_data_queries.to_dict()
            elif isinstance(self.metric_data_queries, list):
                props['MetricDataQueries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_data_queries
                ]
            else:
                props['MetricDataQueries'] = self.metric_data_queries

        return props


@dataclass
class PredictiveScalingCustomizedLoadMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_data_queries: Optional[list[MetricDataQuery]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_data_queries is not None:
            if hasattr(self.metric_data_queries, 'to_dict'):
                props['MetricDataQueries'] = self.metric_data_queries.to_dict()
            elif isinstance(self.metric_data_queries, list):
                props['MetricDataQueries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_data_queries
                ]
            else:
                props['MetricDataQueries'] = self.metric_data_queries

        return props


@dataclass
class PredictiveScalingCustomizedScalingMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_data_queries: Optional[list[MetricDataQuery]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_data_queries is not None:
            if hasattr(self.metric_data_queries, 'to_dict'):
                props['MetricDataQueries'] = self.metric_data_queries.to_dict()
            elif isinstance(self.metric_data_queries, list):
                props['MetricDataQueries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_data_queries
                ]
            else:
                props['MetricDataQueries'] = self.metric_data_queries

        return props


@dataclass
class PredictiveScalingMetricSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customized_load_metric_specification: Optional[PredictiveScalingCustomizedLoadMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_load_metric_specification: Optional[PredictiveScalingPredefinedLoadMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_value: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_scaling_metric_specification: Optional[PredictiveScalingPredefinedScalingMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customized_capacity_metric_specification: Optional[PredictiveScalingCustomizedCapacityMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customized_scaling_metric_specification: Optional[PredictiveScalingCustomizedScalingMetric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_pair_specification: Optional[PredictiveScalingPredefinedMetricPair] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.customized_load_metric_specification is not None:
            if hasattr(self.customized_load_metric_specification, 'to_dict'):
                props['CustomizedLoadMetricSpecification'] = self.customized_load_metric_specification.to_dict()
            elif isinstance(self.customized_load_metric_specification, list):
                props['CustomizedLoadMetricSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customized_load_metric_specification
                ]
            else:
                props['CustomizedLoadMetricSpecification'] = self.customized_load_metric_specification

        if self.predefined_load_metric_specification is not None:
            if hasattr(self.predefined_load_metric_specification, 'to_dict'):
                props['PredefinedLoadMetricSpecification'] = self.predefined_load_metric_specification.to_dict()
            elif isinstance(self.predefined_load_metric_specification, list):
                props['PredefinedLoadMetricSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_load_metric_specification
                ]
            else:
                props['PredefinedLoadMetricSpecification'] = self.predefined_load_metric_specification

        if self.target_value is not None:
            if hasattr(self.target_value, 'to_dict'):
                props['TargetValue'] = self.target_value.to_dict()
            elif isinstance(self.target_value, list):
                props['TargetValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_value
                ]
            else:
                props['TargetValue'] = self.target_value

        if self.predefined_scaling_metric_specification is not None:
            if hasattr(self.predefined_scaling_metric_specification, 'to_dict'):
                props['PredefinedScalingMetricSpecification'] = self.predefined_scaling_metric_specification.to_dict()
            elif isinstance(self.predefined_scaling_metric_specification, list):
                props['PredefinedScalingMetricSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_scaling_metric_specification
                ]
            else:
                props['PredefinedScalingMetricSpecification'] = self.predefined_scaling_metric_specification

        if self.customized_capacity_metric_specification is not None:
            if hasattr(self.customized_capacity_metric_specification, 'to_dict'):
                props['CustomizedCapacityMetricSpecification'] = self.customized_capacity_metric_specification.to_dict()
            elif isinstance(self.customized_capacity_metric_specification, list):
                props['CustomizedCapacityMetricSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customized_capacity_metric_specification
                ]
            else:
                props['CustomizedCapacityMetricSpecification'] = self.customized_capacity_metric_specification

        if self.customized_scaling_metric_specification is not None:
            if hasattr(self.customized_scaling_metric_specification, 'to_dict'):
                props['CustomizedScalingMetricSpecification'] = self.customized_scaling_metric_specification.to_dict()
            elif isinstance(self.customized_scaling_metric_specification, list):
                props['CustomizedScalingMetricSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customized_scaling_metric_specification
                ]
            else:
                props['CustomizedScalingMetricSpecification'] = self.customized_scaling_metric_specification

        if self.predefined_metric_pair_specification is not None:
            if hasattr(self.predefined_metric_pair_specification, 'to_dict'):
                props['PredefinedMetricPairSpecification'] = self.predefined_metric_pair_specification.to_dict()
            elif isinstance(self.predefined_metric_pair_specification, list):
                props['PredefinedMetricPairSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_metric_pair_specification
                ]
            else:
                props['PredefinedMetricPairSpecification'] = self.predefined_metric_pair_specification

        return props


@dataclass
class PredictiveScalingPredefinedLoadMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_label: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.predefined_metric_type is not None:
            if hasattr(self.predefined_metric_type, 'to_dict'):
                props['PredefinedMetricType'] = self.predefined_metric_type.to_dict()
            elif isinstance(self.predefined_metric_type, list):
                props['PredefinedMetricType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_metric_type
                ]
            else:
                props['PredefinedMetricType'] = self.predefined_metric_type

        if self.resource_label is not None:
            if hasattr(self.resource_label, 'to_dict'):
                props['ResourceLabel'] = self.resource_label.to_dict()
            elif isinstance(self.resource_label, list):
                props['ResourceLabel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_label
                ]
            else:
                props['ResourceLabel'] = self.resource_label

        return props


@dataclass
class PredictiveScalingPredefinedMetricPair:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_label: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.predefined_metric_type is not None:
            if hasattr(self.predefined_metric_type, 'to_dict'):
                props['PredefinedMetricType'] = self.predefined_metric_type.to_dict()
            elif isinstance(self.predefined_metric_type, list):
                props['PredefinedMetricType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_metric_type
                ]
            else:
                props['PredefinedMetricType'] = self.predefined_metric_type

        if self.resource_label is not None:
            if hasattr(self.resource_label, 'to_dict'):
                props['ResourceLabel'] = self.resource_label.to_dict()
            elif isinstance(self.resource_label, list):
                props['ResourceLabel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_label
                ]
            else:
                props['ResourceLabel'] = self.resource_label

        return props


@dataclass
class PredictiveScalingPredefinedScalingMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_label: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.predefined_metric_type is not None:
            if hasattr(self.predefined_metric_type, 'to_dict'):
                props['PredefinedMetricType'] = self.predefined_metric_type.to_dict()
            elif isinstance(self.predefined_metric_type, list):
                props['PredefinedMetricType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_metric_type
                ]
            else:
                props['PredefinedMetricType'] = self.predefined_metric_type

        if self.resource_label is not None:
            if hasattr(self.resource_label, 'to_dict'):
                props['ResourceLabel'] = self.resource_label.to_dict()
            elif isinstance(self.resource_label, list):
                props['ResourceLabel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_label
                ]
            else:
                props['ResourceLabel'] = self.resource_label

        return props


@dataclass
class StepAdjustment:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_interval_upper_bound: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_interval_lower_bound: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scaling_adjustment: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_interval_upper_bound is not None:
            if hasattr(self.metric_interval_upper_bound, 'to_dict'):
                props['MetricIntervalUpperBound'] = self.metric_interval_upper_bound.to_dict()
            elif isinstance(self.metric_interval_upper_bound, list):
                props['MetricIntervalUpperBound'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_interval_upper_bound
                ]
            else:
                props['MetricIntervalUpperBound'] = self.metric_interval_upper_bound

        if self.metric_interval_lower_bound is not None:
            if hasattr(self.metric_interval_lower_bound, 'to_dict'):
                props['MetricIntervalLowerBound'] = self.metric_interval_lower_bound.to_dict()
            elif isinstance(self.metric_interval_lower_bound, list):
                props['MetricIntervalLowerBound'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_interval_lower_bound
                ]
            else:
                props['MetricIntervalLowerBound'] = self.metric_interval_lower_bound

        if self.scaling_adjustment is not None:
            if hasattr(self.scaling_adjustment, 'to_dict'):
                props['ScalingAdjustment'] = self.scaling_adjustment.to_dict()
            elif isinstance(self.scaling_adjustment, list):
                props['ScalingAdjustment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scaling_adjustment
                ]
            else:
                props['ScalingAdjustment'] = self.scaling_adjustment

        return props


@dataclass
class TargetTrackingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_value: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customized_metric_specification: Optional[CustomizedMetricSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    disable_scale_in: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    predefined_metric_specification: Optional[PredefinedMetricSpecification] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.target_value is not None:
            if hasattr(self.target_value, 'to_dict'):
                props['TargetValue'] = self.target_value.to_dict()
            elif isinstance(self.target_value, list):
                props['TargetValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_value
                ]
            else:
                props['TargetValue'] = self.target_value

        if self.customized_metric_specification is not None:
            if hasattr(self.customized_metric_specification, 'to_dict'):
                props['CustomizedMetricSpecification'] = self.customized_metric_specification.to_dict()
            elif isinstance(self.customized_metric_specification, list):
                props['CustomizedMetricSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customized_metric_specification
                ]
            else:
                props['CustomizedMetricSpecification'] = self.customized_metric_specification

        if self.disable_scale_in is not None:
            if hasattr(self.disable_scale_in, 'to_dict'):
                props['DisableScaleIn'] = self.disable_scale_in.to_dict()
            elif isinstance(self.disable_scale_in, list):
                props['DisableScaleIn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disable_scale_in
                ]
            else:
                props['DisableScaleIn'] = self.disable_scale_in

        if self.predefined_metric_specification is not None:
            if hasattr(self.predefined_metric_specification, 'to_dict'):
                props['PredefinedMetricSpecification'] = self.predefined_metric_specification.to_dict()
            elif isinstance(self.predefined_metric_specification, list):
                props['PredefinedMetricSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predefined_metric_specification
                ]
            else:
                props['PredefinedMetricSpecification'] = self.predefined_metric_specification

        return props


@dataclass
class TargetTrackingMetricDataQuery:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    return_data: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    expression: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    label: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_stat: Optional[TargetTrackingMetricStat] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    period: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.return_data is not None:
            if hasattr(self.return_data, 'to_dict'):
                props['ReturnData'] = self.return_data.to_dict()
            elif isinstance(self.return_data, list):
                props['ReturnData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.return_data
                ]
            else:
                props['ReturnData'] = self.return_data

        if self.expression is not None:
            if hasattr(self.expression, 'to_dict'):
                props['Expression'] = self.expression.to_dict()
            elif isinstance(self.expression, list):
                props['Expression'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.expression
                ]
            else:
                props['Expression'] = self.expression

        if self.label is not None:
            if hasattr(self.label, 'to_dict'):
                props['Label'] = self.label.to_dict()
            elif isinstance(self.label, list):
                props['Label'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.label
                ]
            else:
                props['Label'] = self.label

        if self.metric_stat is not None:
            if hasattr(self.metric_stat, 'to_dict'):
                props['MetricStat'] = self.metric_stat.to_dict()
            elif isinstance(self.metric_stat, list):
                props['MetricStat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_stat
                ]
            else:
                props['MetricStat'] = self.metric_stat

        if self.period is not None:
            if hasattr(self.period, 'to_dict'):
                props['Period'] = self.period.to_dict()
            elif isinstance(self.period, list):
                props['Period'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.period
                ]
            else:
                props['Period'] = self.period

        if self.id is not None:
            if hasattr(self.id, 'to_dict'):
                props['Id'] = self.id.to_dict()
            elif isinstance(self.id, list):
                props['Id'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.id
                ]
            else:
                props['Id'] = self.id

        return props


@dataclass
class TargetTrackingMetricStat:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    stat: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    period: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric: Optional[Metric] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.stat is not None:
            if hasattr(self.stat, 'to_dict'):
                props['Stat'] = self.stat.to_dict()
            elif isinstance(self.stat, list):
                props['Stat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stat
                ]
            else:
                props['Stat'] = self.stat

        if self.period is not None:
            if hasattr(self.period, 'to_dict'):
                props['Period'] = self.period.to_dict()
            elif isinstance(self.period, list):
                props['Period'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.period
                ]
            else:
                props['Period'] = self.period

        if self.metric is not None:
            if hasattr(self.metric, 'to_dict'):
                props['Metric'] = self.metric.to_dict()
            elif isinstance(self.metric, list):
                props['Metric'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric
                ]
            else:
                props['Metric'] = self.metric

        if self.unit is not None:
            if hasattr(self.unit, 'to_dict'):
                props['Unit'] = self.unit.to_dict()
            elif isinstance(self.unit, list):
                props['Unit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unit
                ]
            else:
                props['Unit'] = self.unit

        return props


@dataclass
class ScalingPolicy(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autos"""

    resource_type: ClassVar[str] = "AWS::AutoScaling::ScalingPolicy"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metric_aggregation_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    predictive_scaling_configuration: Optional[PredictiveScalingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    scaling_adjustment: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cooldown: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    step_adjustments: Optional[list[StepAdjustment]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_scaling_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    min_adjustment_magnitude: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_tracking_configuration: Optional[TargetTrackingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    estimated_instance_warmup: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    adjustment_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_aggregation_type is not None:
            # Serialize metric_aggregation_type (handle intrinsic functions)
            if hasattr(self.metric_aggregation_type, 'to_dict'):
                props["MetricAggregationType"] = self.metric_aggregation_type.to_dict()
            elif isinstance(self.metric_aggregation_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['MetricAggregationType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_aggregation_type
                ]
            else:
                props["MetricAggregationType"] = self.metric_aggregation_type

        if self.policy_type is not None:
            # Serialize policy_type (handle intrinsic functions)
            if hasattr(self.policy_type, 'to_dict'):
                props["PolicyType"] = self.policy_type.to_dict()
            elif isinstance(self.policy_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_type
                ]
            else:
                props["PolicyType"] = self.policy_type

        if self.predictive_scaling_configuration is not None:
            # Serialize predictive_scaling_configuration (handle intrinsic functions)
            if hasattr(self.predictive_scaling_configuration, 'to_dict'):
                props["PredictiveScalingConfiguration"] = self.predictive_scaling_configuration.to_dict()
            elif isinstance(self.predictive_scaling_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['PredictiveScalingConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predictive_scaling_configuration
                ]
            else:
                props["PredictiveScalingConfiguration"] = self.predictive_scaling_configuration

        if self.scaling_adjustment is not None:
            # Serialize scaling_adjustment (handle intrinsic functions)
            if hasattr(self.scaling_adjustment, 'to_dict'):
                props["ScalingAdjustment"] = self.scaling_adjustment.to_dict()
            elif isinstance(self.scaling_adjustment, list):
                # Serialize list items (may contain intrinsic functions)
                props['ScalingAdjustment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scaling_adjustment
                ]
            else:
                props["ScalingAdjustment"] = self.scaling_adjustment

        if self.cooldown is not None:
            # Serialize cooldown (handle intrinsic functions)
            if hasattr(self.cooldown, 'to_dict'):
                props["Cooldown"] = self.cooldown.to_dict()
            elif isinstance(self.cooldown, list):
                # Serialize list items (may contain intrinsic functions)
                props['Cooldown'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cooldown
                ]
            else:
                props["Cooldown"] = self.cooldown

        if self.step_adjustments is not None:
            # Serialize step_adjustments (handle intrinsic functions)
            if hasattr(self.step_adjustments, 'to_dict'):
                props["StepAdjustments"] = self.step_adjustments.to_dict()
            elif isinstance(self.step_adjustments, list):
                # Serialize list items (may contain intrinsic functions)
                props['StepAdjustments'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.step_adjustments
                ]
            else:
                props["StepAdjustments"] = self.step_adjustments

        if self.auto_scaling_group_name is not None:
            # Serialize auto_scaling_group_name (handle intrinsic functions)
            if hasattr(self.auto_scaling_group_name, 'to_dict'):
                props["AutoScalingGroupName"] = self.auto_scaling_group_name.to_dict()
            elif isinstance(self.auto_scaling_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoScalingGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_scaling_group_name
                ]
            else:
                props["AutoScalingGroupName"] = self.auto_scaling_group_name

        if self.min_adjustment_magnitude is not None:
            # Serialize min_adjustment_magnitude (handle intrinsic functions)
            if hasattr(self.min_adjustment_magnitude, 'to_dict'):
                props["MinAdjustmentMagnitude"] = self.min_adjustment_magnitude.to_dict()
            elif isinstance(self.min_adjustment_magnitude, list):
                # Serialize list items (may contain intrinsic functions)
                props['MinAdjustmentMagnitude'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_adjustment_magnitude
                ]
            else:
                props["MinAdjustmentMagnitude"] = self.min_adjustment_magnitude

        if self.target_tracking_configuration is not None:
            # Serialize target_tracking_configuration (handle intrinsic functions)
            if hasattr(self.target_tracking_configuration, 'to_dict'):
                props["TargetTrackingConfiguration"] = self.target_tracking_configuration.to_dict()
            elif isinstance(self.target_tracking_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetTrackingConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_tracking_configuration
                ]
            else:
                props["TargetTrackingConfiguration"] = self.target_tracking_configuration

        if self.estimated_instance_warmup is not None:
            # Serialize estimated_instance_warmup (handle intrinsic functions)
            if hasattr(self.estimated_instance_warmup, 'to_dict'):
                props["EstimatedInstanceWarmup"] = self.estimated_instance_warmup.to_dict()
            elif isinstance(self.estimated_instance_warmup, list):
                # Serialize list items (may contain intrinsic functions)
                props['EstimatedInstanceWarmup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.estimated_instance_warmup
                ]
            else:
                props["EstimatedInstanceWarmup"] = self.estimated_instance_warmup

        if self.adjustment_type is not None:
            # Serialize adjustment_type (handle intrinsic functions)
            if hasattr(self.adjustment_type, 'to_dict'):
                props["AdjustmentType"] = self.adjustment_type.to_dict()
            elif isinstance(self.adjustment_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['AdjustmentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.adjustment_type
                ]
            else:
                props["AdjustmentType"] = self.adjustment_type

        return props

    @property
    def attr_policy_name(self) -> GetAtt:
        """Get the PolicyName attribute."""
        return self.get_att("PolicyName")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class ScheduledAction(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autos"""

    resource_type: ClassVar[str] = "AWS::AutoScaling::ScheduledAction"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    min_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    recurrence: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    time_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    end_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_scaling_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    start_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    desired_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_size: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min_size is not None:
            # Serialize min_size (handle intrinsic functions)
            if hasattr(self.min_size, 'to_dict'):
                props["MinSize"] = self.min_size.to_dict()
            elif isinstance(self.min_size, list):
                # Serialize list items (may contain intrinsic functions)
                props['MinSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_size
                ]
            else:
                props["MinSize"] = self.min_size

        if self.recurrence is not None:
            # Serialize recurrence (handle intrinsic functions)
            if hasattr(self.recurrence, 'to_dict'):
                props["Recurrence"] = self.recurrence.to_dict()
            elif isinstance(self.recurrence, list):
                # Serialize list items (may contain intrinsic functions)
                props['Recurrence'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.recurrence
                ]
            else:
                props["Recurrence"] = self.recurrence

        if self.time_zone is not None:
            # Serialize time_zone (handle intrinsic functions)
            if hasattr(self.time_zone, 'to_dict'):
                props["TimeZone"] = self.time_zone.to_dict()
            elif isinstance(self.time_zone, list):
                # Serialize list items (may contain intrinsic functions)
                props['TimeZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.time_zone
                ]
            else:
                props["TimeZone"] = self.time_zone

        if self.end_time is not None:
            # Serialize end_time (handle intrinsic functions)
            if hasattr(self.end_time, 'to_dict'):
                props["EndTime"] = self.end_time.to_dict()
            elif isinstance(self.end_time, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.end_time
                ]
            else:
                props["EndTime"] = self.end_time

        if self.auto_scaling_group_name is not None:
            # Serialize auto_scaling_group_name (handle intrinsic functions)
            if hasattr(self.auto_scaling_group_name, 'to_dict'):
                props["AutoScalingGroupName"] = self.auto_scaling_group_name.to_dict()
            elif isinstance(self.auto_scaling_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoScalingGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_scaling_group_name
                ]
            else:
                props["AutoScalingGroupName"] = self.auto_scaling_group_name

        if self.start_time is not None:
            # Serialize start_time (handle intrinsic functions)
            if hasattr(self.start_time, 'to_dict'):
                props["StartTime"] = self.start_time.to_dict()
            elif isinstance(self.start_time, list):
                # Serialize list items (may contain intrinsic functions)
                props['StartTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.start_time
                ]
            else:
                props["StartTime"] = self.start_time

        if self.desired_capacity is not None:
            # Serialize desired_capacity (handle intrinsic functions)
            if hasattr(self.desired_capacity, 'to_dict'):
                props["DesiredCapacity"] = self.desired_capacity.to_dict()
            elif isinstance(self.desired_capacity, list):
                # Serialize list items (may contain intrinsic functions)
                props['DesiredCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.desired_capacity
                ]
            else:
                props["DesiredCapacity"] = self.desired_capacity

        if self.max_size is not None:
            # Serialize max_size (handle intrinsic functions)
            if hasattr(self.max_size, 'to_dict'):
                props["MaxSize"] = self.max_size.to_dict()
            elif isinstance(self.max_size, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_size
                ]
            else:
                props["MaxSize"] = self.max_size

        return props

    @property
    def attr_scheduled_action_name(self) -> GetAtt:
        """Get the ScheduledActionName attribute."""
        return self.get_att("ScheduledActionName")




@dataclass
class InstanceReusePolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-aut"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    reuse_on_scale_in: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.reuse_on_scale_in is not None:
            if hasattr(self.reuse_on_scale_in, 'to_dict'):
                props['ReuseOnScaleIn'] = self.reuse_on_scale_in.to_dict()
            elif isinstance(self.reuse_on_scale_in, list):
                props['ReuseOnScaleIn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.reuse_on_scale_in
                ]
            else:
                props['ReuseOnScaleIn'] = self.reuse_on_scale_in

        return props


@dataclass
class WarmPool(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-autos"""

    resource_type: ClassVar[str] = "AWS::AutoScaling::WarmPool"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    min_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_group_prepared_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_scaling_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    pool_state: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_reuse_policy: Optional[InstanceReusePolicy] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min_size is not None:
            # Serialize min_size (handle intrinsic functions)
            if hasattr(self.min_size, 'to_dict'):
                props["MinSize"] = self.min_size.to_dict()
            elif isinstance(self.min_size, list):
                # Serialize list items (may contain intrinsic functions)
                props['MinSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_size
                ]
            else:
                props["MinSize"] = self.min_size

        if self.max_group_prepared_capacity is not None:
            # Serialize max_group_prepared_capacity (handle intrinsic functions)
            if hasattr(self.max_group_prepared_capacity, 'to_dict'):
                props["MaxGroupPreparedCapacity"] = self.max_group_prepared_capacity.to_dict()
            elif isinstance(self.max_group_prepared_capacity, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxGroupPreparedCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_group_prepared_capacity
                ]
            else:
                props["MaxGroupPreparedCapacity"] = self.max_group_prepared_capacity

        if self.auto_scaling_group_name is not None:
            # Serialize auto_scaling_group_name (handle intrinsic functions)
            if hasattr(self.auto_scaling_group_name, 'to_dict'):
                props["AutoScalingGroupName"] = self.auto_scaling_group_name.to_dict()
            elif isinstance(self.auto_scaling_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoScalingGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_scaling_group_name
                ]
            else:
                props["AutoScalingGroupName"] = self.auto_scaling_group_name

        if self.pool_state is not None:
            # Serialize pool_state (handle intrinsic functions)
            if hasattr(self.pool_state, 'to_dict'):
                props["PoolState"] = self.pool_state.to_dict()
            elif isinstance(self.pool_state, list):
                # Serialize list items (may contain intrinsic functions)
                props['PoolState'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pool_state
                ]
            else:
                props["PoolState"] = self.pool_state

        if self.instance_reuse_policy is not None:
            # Serialize instance_reuse_policy (handle intrinsic functions)
            if hasattr(self.instance_reuse_policy, 'to_dict'):
                props["InstanceReusePolicy"] = self.instance_reuse_policy.to_dict()
            elif isinstance(self.instance_reuse_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceReusePolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_reuse_policy
                ]
            else:
                props["InstanceReusePolicy"] = self.instance_reuse_policy

        return props


