"""
AWS CloudFormation StepFunctions Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:39

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service StepFunctions
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class EncryptionType:
    """EncryptionType enum values."""

    AWS_OWNED_KEY = "AWS_OWNED_KEY"
    CUSTOMER_MANAGED_KMS_KEY = "CUSTOMER_MANAGED_KMS_KEY"


class ExecutionRedriveFilter:
    """ExecutionRedriveFilter enum values."""

    REDRIVEN = "REDRIVEN"
    NOT_REDRIVEN = "NOT_REDRIVEN"


class ExecutionRedriveStatus:
    """ExecutionRedriveStatus enum values."""

    REDRIVABLE = "REDRIVABLE"
    NOT_REDRIVABLE = "NOT_REDRIVABLE"
    REDRIVABLE_BY_MAP_RUN = "REDRIVABLE_BY_MAP_RUN"


class ExecutionStatus:
    """ExecutionStatus enum values."""

    RUNNING = "RUNNING"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    TIMED_OUT = "TIMED_OUT"
    ABORTED = "ABORTED"
    PENDING_REDRIVE = "PENDING_REDRIVE"


class HistoryEventType:
    """HistoryEventType enum values."""

    ACTIVITYFAILED = "ActivityFailed"
    ACTIVITYSCHEDULED = "ActivityScheduled"
    ACTIVITYSCHEDULEFAILED = "ActivityScheduleFailed"
    ACTIVITYSTARTED = "ActivityStarted"
    ACTIVITYSUCCEEDED = "ActivitySucceeded"
    ACTIVITYTIMEDOUT = "ActivityTimedOut"
    CHOICESTATEENTERED = "ChoiceStateEntered"
    CHOICESTATEEXITED = "ChoiceStateExited"
    EXECUTIONABORTED = "ExecutionAborted"
    EXECUTIONFAILED = "ExecutionFailed"
    EXECUTIONSTARTED = "ExecutionStarted"
    EXECUTIONSUCCEEDED = "ExecutionSucceeded"
    EXECUTIONTIMEDOUT = "ExecutionTimedOut"
    FAILSTATEENTERED = "FailStateEntered"
    LAMBDAFUNCTIONFAILED = "LambdaFunctionFailed"
    LAMBDAFUNCTIONSCHEDULED = "LambdaFunctionScheduled"
    LAMBDAFUNCTIONSCHEDULEFAILED = "LambdaFunctionScheduleFailed"
    LAMBDAFUNCTIONSTARTED = "LambdaFunctionStarted"
    LAMBDAFUNCTIONSTARTFAILED = "LambdaFunctionStartFailed"
    LAMBDAFUNCTIONSUCCEEDED = "LambdaFunctionSucceeded"
    LAMBDAFUNCTIONTIMEDOUT = "LambdaFunctionTimedOut"
    MAPITERATIONABORTED = "MapIterationAborted"
    MAPITERATIONFAILED = "MapIterationFailed"
    MAPITERATIONSTARTED = "MapIterationStarted"
    MAPITERATIONSUCCEEDED = "MapIterationSucceeded"
    MAPSTATEABORTED = "MapStateAborted"
    MAPSTATEENTERED = "MapStateEntered"
    MAPSTATEEXITED = "MapStateExited"
    MAPSTATEFAILED = "MapStateFailed"
    MAPSTATESTARTED = "MapStateStarted"
    MAPSTATESUCCEEDED = "MapStateSucceeded"
    PARALLELSTATEABORTED = "ParallelStateAborted"
    PARALLELSTATEENTERED = "ParallelStateEntered"
    PARALLELSTATEEXITED = "ParallelStateExited"
    PARALLELSTATEFAILED = "ParallelStateFailed"
    PARALLELSTATESTARTED = "ParallelStateStarted"
    PARALLELSTATESUCCEEDED = "ParallelStateSucceeded"
    PASSSTATEENTERED = "PassStateEntered"
    PASSSTATEEXITED = "PassStateExited"
    SUCCEEDSTATEENTERED = "SucceedStateEntered"
    SUCCEEDSTATEEXITED = "SucceedStateExited"
    TASKFAILED = "TaskFailed"
    TASKSCHEDULED = "TaskScheduled"
    TASKSTARTED = "TaskStarted"
    TASKSTARTFAILED = "TaskStartFailed"
    TASKSTATEABORTED = "TaskStateAborted"
    TASKSTATEENTERED = "TaskStateEntered"
    TASKSTATEEXITED = "TaskStateExited"
    TASKSUBMITFAILED = "TaskSubmitFailed"
    TASKSUBMITTED = "TaskSubmitted"
    TASKSUCCEEDED = "TaskSucceeded"
    TASKTIMEDOUT = "TaskTimedOut"
    WAITSTATEABORTED = "WaitStateAborted"
    WAITSTATEENTERED = "WaitStateEntered"
    WAITSTATEEXITED = "WaitStateExited"
    MAPRUNABORTED = "MapRunAborted"
    MAPRUNFAILED = "MapRunFailed"
    MAPRUNSTARTED = "MapRunStarted"
    MAPRUNSUCCEEDED = "MapRunSucceeded"
    EXECUTIONREDRIVEN = "ExecutionRedriven"
    MAPRUNREDRIVEN = "MapRunRedriven"
    EVALUATIONFAILED = "EvaluationFailed"


class IncludedData:
    """IncludedData enum values."""

    ALL_DATA = "ALL_DATA"
    METADATA_ONLY = "METADATA_ONLY"


class InspectionLevel:
    """InspectionLevel enum values."""

    INFO = "INFO"
    DEBUG = "DEBUG"
    TRACE = "TRACE"


class KmsKeyState:
    """KmsKeyState enum values."""

    DISABLED = "DISABLED"
    PENDING_DELETION = "PENDING_DELETION"
    PENDING_IMPORT = "PENDING_IMPORT"
    UNAVAILABLE = "UNAVAILABLE"
    CREATING = "CREATING"


class LogLevel:
    """LogLevel enum values."""

    ALL = "ALL"
    ERROR = "ERROR"
    FATAL = "FATAL"
    OFF = "OFF"


class MapRunStatus:
    """MapRunStatus enum values."""

    RUNNING = "RUNNING"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    ABORTED = "ABORTED"


class MockResponseValidationMode:
    """MockResponseValidationMode enum values."""

    STRICT = "STRICT"
    PRESENT = "PRESENT"
    NONE = "NONE"


class StateMachineStatus:
    """StateMachineStatus enum values."""

    ACTIVE = "ACTIVE"
    DELETING = "DELETING"


class StateMachineType:
    """StateMachineType enum values."""

    STANDARD = "STANDARD"
    EXPRESS = "EXPRESS"


class SyncExecutionStatus:
    """SyncExecutionStatus enum values."""

    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    TIMED_OUT = "TIMED_OUT"


class TestExecutionStatus:
    """TestExecutionStatus enum values."""

    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    RETRIABLE = "RETRIABLE"
    CAUGHT_ERROR = "CAUGHT_ERROR"


class ValidateStateMachineDefinitionResultCode:
    """ValidateStateMachineDefinitionResultCode enum values."""

    OK = "OK"
    FAIL = "FAIL"


class ValidateStateMachineDefinitionSeverity:
    """ValidateStateMachineDefinitionSeverity enum values."""

    ERROR = "ERROR"
    WARNING = "WARNING"


class ValidationExceptionReason:
    """ValidationExceptionReason enum values."""

    API_DOES_NOT_SUPPORT_LABELED_ARNS = "API_DOES_NOT_SUPPORT_LABELED_ARNS"
    MISSING_REQUIRED_PARAMETER = "MISSING_REQUIRED_PARAMETER"
    CANNOT_UPDATE_COMPLETED_MAP_RUN = "CANNOT_UPDATE_COMPLETED_MAP_RUN"
    INVALID_ROUTING_CONFIGURATION = "INVALID_ROUTING_CONFIGURATION"


# Convenient aliases for enum values
AWS_OWNED_KEY = EncryptionType.AWS_OWNED_KEY
CUSTOMER_MANAGED_KMS_KEY = EncryptionType.CUSTOMER_MANAGED_KMS_KEY
REDRIVEN = ExecutionRedriveFilter.REDRIVEN
NOT_REDRIVEN = ExecutionRedriveFilter.NOT_REDRIVEN
REDRIVABLE = ExecutionRedriveStatus.REDRIVABLE
NOT_REDRIVABLE = ExecutionRedriveStatus.NOT_REDRIVABLE
REDRIVABLE_BY_MAP_RUN = ExecutionRedriveStatus.REDRIVABLE_BY_MAP_RUN
RUNNING = ExecutionStatus.RUNNING
SUCCEEDED = ExecutionStatus.SUCCEEDED
FAILED = ExecutionStatus.FAILED
TIMED_OUT = ExecutionStatus.TIMED_OUT
ABORTED = ExecutionStatus.ABORTED
PENDING_REDRIVE = ExecutionStatus.PENDING_REDRIVE
ACTIVITYFAILED = HistoryEventType.ACTIVITYFAILED
ACTIVITYSCHEDULED = HistoryEventType.ACTIVITYSCHEDULED
ACTIVITYSCHEDULEFAILED = HistoryEventType.ACTIVITYSCHEDULEFAILED
ACTIVITYSTARTED = HistoryEventType.ACTIVITYSTARTED
ACTIVITYSUCCEEDED = HistoryEventType.ACTIVITYSUCCEEDED
ACTIVITYTIMEDOUT = HistoryEventType.ACTIVITYTIMEDOUT
CHOICESTATEENTERED = HistoryEventType.CHOICESTATEENTERED
CHOICESTATEEXITED = HistoryEventType.CHOICESTATEEXITED
EXECUTIONABORTED = HistoryEventType.EXECUTIONABORTED
EXECUTIONFAILED = HistoryEventType.EXECUTIONFAILED
EXECUTIONSTARTED = HistoryEventType.EXECUTIONSTARTED
EXECUTIONSUCCEEDED = HistoryEventType.EXECUTIONSUCCEEDED
EXECUTIONTIMEDOUT = HistoryEventType.EXECUTIONTIMEDOUT
FAILSTATEENTERED = HistoryEventType.FAILSTATEENTERED
LAMBDAFUNCTIONFAILED = HistoryEventType.LAMBDAFUNCTIONFAILED
LAMBDAFUNCTIONSCHEDULED = HistoryEventType.LAMBDAFUNCTIONSCHEDULED
LAMBDAFUNCTIONSCHEDULEFAILED = HistoryEventType.LAMBDAFUNCTIONSCHEDULEFAILED
LAMBDAFUNCTIONSTARTED = HistoryEventType.LAMBDAFUNCTIONSTARTED
LAMBDAFUNCTIONSTARTFAILED = HistoryEventType.LAMBDAFUNCTIONSTARTFAILED
LAMBDAFUNCTIONSUCCEEDED = HistoryEventType.LAMBDAFUNCTIONSUCCEEDED
LAMBDAFUNCTIONTIMEDOUT = HistoryEventType.LAMBDAFUNCTIONTIMEDOUT
MAPITERATIONABORTED = HistoryEventType.MAPITERATIONABORTED
MAPITERATIONFAILED = HistoryEventType.MAPITERATIONFAILED
MAPITERATIONSTARTED = HistoryEventType.MAPITERATIONSTARTED
MAPITERATIONSUCCEEDED = HistoryEventType.MAPITERATIONSUCCEEDED
MAPSTATEABORTED = HistoryEventType.MAPSTATEABORTED
MAPSTATEENTERED = HistoryEventType.MAPSTATEENTERED
MAPSTATEEXITED = HistoryEventType.MAPSTATEEXITED
MAPSTATEFAILED = HistoryEventType.MAPSTATEFAILED
MAPSTATESTARTED = HistoryEventType.MAPSTATESTARTED
MAPSTATESUCCEEDED = HistoryEventType.MAPSTATESUCCEEDED
PARALLELSTATEABORTED = HistoryEventType.PARALLELSTATEABORTED
PARALLELSTATEENTERED = HistoryEventType.PARALLELSTATEENTERED
PARALLELSTATEEXITED = HistoryEventType.PARALLELSTATEEXITED
PARALLELSTATEFAILED = HistoryEventType.PARALLELSTATEFAILED
PARALLELSTATESTARTED = HistoryEventType.PARALLELSTATESTARTED
PARALLELSTATESUCCEEDED = HistoryEventType.PARALLELSTATESUCCEEDED
PASSSTATEENTERED = HistoryEventType.PASSSTATEENTERED
PASSSTATEEXITED = HistoryEventType.PASSSTATEEXITED
SUCCEEDSTATEENTERED = HistoryEventType.SUCCEEDSTATEENTERED
SUCCEEDSTATEEXITED = HistoryEventType.SUCCEEDSTATEEXITED
TASKFAILED = HistoryEventType.TASKFAILED
TASKSCHEDULED = HistoryEventType.TASKSCHEDULED
TASKSTARTED = HistoryEventType.TASKSTARTED
TASKSTARTFAILED = HistoryEventType.TASKSTARTFAILED
TASKSTATEABORTED = HistoryEventType.TASKSTATEABORTED
TASKSTATEENTERED = HistoryEventType.TASKSTATEENTERED
TASKSTATEEXITED = HistoryEventType.TASKSTATEEXITED
TASKSUBMITFAILED = HistoryEventType.TASKSUBMITFAILED
TASKSUBMITTED = HistoryEventType.TASKSUBMITTED
TASKSUCCEEDED = HistoryEventType.TASKSUCCEEDED
TASKTIMEDOUT = HistoryEventType.TASKTIMEDOUT
WAITSTATEABORTED = HistoryEventType.WAITSTATEABORTED
WAITSTATEENTERED = HistoryEventType.WAITSTATEENTERED
WAITSTATEEXITED = HistoryEventType.WAITSTATEEXITED
MAPRUNABORTED = HistoryEventType.MAPRUNABORTED
MAPRUNFAILED = HistoryEventType.MAPRUNFAILED
MAPRUNSTARTED = HistoryEventType.MAPRUNSTARTED
MAPRUNSUCCEEDED = HistoryEventType.MAPRUNSUCCEEDED
EXECUTIONREDRIVEN = HistoryEventType.EXECUTIONREDRIVEN
MAPRUNREDRIVEN = HistoryEventType.MAPRUNREDRIVEN
EVALUATIONFAILED = HistoryEventType.EVALUATIONFAILED
ALL_DATA = IncludedData.ALL_DATA
METADATA_ONLY = IncludedData.METADATA_ONLY
INFO = InspectionLevel.INFO
DEBUG = InspectionLevel.DEBUG
TRACE = InspectionLevel.TRACE
DISABLED = KmsKeyState.DISABLED
PENDING_DELETION = KmsKeyState.PENDING_DELETION
PENDING_IMPORT = KmsKeyState.PENDING_IMPORT
UNAVAILABLE = KmsKeyState.UNAVAILABLE
CREATING = KmsKeyState.CREATING
ALL = LogLevel.ALL
ERROR = LogLevel.ERROR
FATAL = LogLevel.FATAL
OFF = LogLevel.OFF
RUNNING = MapRunStatus.RUNNING
SUCCEEDED = MapRunStatus.SUCCEEDED
FAILED = MapRunStatus.FAILED
ABORTED = MapRunStatus.ABORTED
STRICT = MockResponseValidationMode.STRICT
PRESENT = MockResponseValidationMode.PRESENT
NONE = MockResponseValidationMode.NONE
ACTIVE = StateMachineStatus.ACTIVE
DELETING = StateMachineStatus.DELETING
STANDARD = StateMachineType.STANDARD
EXPRESS = StateMachineType.EXPRESS
SUCCEEDED = SyncExecutionStatus.SUCCEEDED
FAILED = SyncExecutionStatus.FAILED
TIMED_OUT = SyncExecutionStatus.TIMED_OUT
SUCCEEDED = TestExecutionStatus.SUCCEEDED
FAILED = TestExecutionStatus.FAILED
RETRIABLE = TestExecutionStatus.RETRIABLE
CAUGHT_ERROR = TestExecutionStatus.CAUGHT_ERROR
OK = ValidateStateMachineDefinitionResultCode.OK
FAIL = ValidateStateMachineDefinitionResultCode.FAIL
ERROR = ValidateStateMachineDefinitionSeverity.ERROR
WARNING = ValidateStateMachineDefinitionSeverity.WARNING
API_DOES_NOT_SUPPORT_LABELED_ARNS = ValidationExceptionReason.API_DOES_NOT_SUPPORT_LABELED_ARNS
MISSING_REQUIRED_PARAMETER = ValidationExceptionReason.MISSING_REQUIRED_PARAMETER
CANNOT_UPDATE_COMPLETED_MAP_RUN = ValidationExceptionReason.CANNOT_UPDATE_COMPLETED_MAP_RUN
INVALID_ROUTING_CONFIGURATION = ValidationExceptionReason.INVALID_ROUTING_CONFIGURATION


@dataclass
class EncryptionConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ste"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_data_key_reuse_period_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.kms_data_key_reuse_period_seconds is not None:
            if hasattr(self.kms_data_key_reuse_period_seconds, 'to_dict'):
                props['KmsDataKeyReusePeriodSeconds'] = self.kms_data_key_reuse_period_seconds.to_dict()
            elif isinstance(self.kms_data_key_reuse_period_seconds, list):
                props['KmsDataKeyReusePeriodSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_data_key_reuse_period_seconds
                ]
            else:
                props['KmsDataKeyReusePeriodSeconds'] = self.kms_data_key_reuse_period_seconds

        return props


@dataclass
class TagsEntry:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ste"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class Activity(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-stepf"""

    resource_type: ClassVar[str] = "AWS::StepFunctions::Activity"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    encryption_configuration: Optional[EncryptionConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[TagsEntry]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.encryption_configuration is not None:
            # Serialize encryption_configuration (handle intrinsic functions)
            if hasattr(self.encryption_configuration, 'to_dict'):
                props["EncryptionConfiguration"] = self.encryption_configuration.to_dict()
            elif isinstance(self.encryption_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['EncryptionConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encryption_configuration
                ]
            else:
                props["EncryptionConfiguration"] = self.encryption_configuration

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_name(self) -> GetAtt:
        """Get the Name attribute."""
        return self.get_att("Name")




@dataclass
class CloudWatchLogsLogGroup:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ste"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.log_group_arn is not None:
            if hasattr(self.log_group_arn, 'to_dict'):
                props['LogGroupArn'] = self.log_group_arn.to_dict()
            elif isinstance(self.log_group_arn, list):
                props['LogGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_arn
                ]
            else:
                props['LogGroupArn'] = self.log_group_arn

        return props


@dataclass
class EncryptionConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ste"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_data_key_reuse_period_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.kms_data_key_reuse_period_seconds is not None:
            if hasattr(self.kms_data_key_reuse_period_seconds, 'to_dict'):
                props['KmsDataKeyReusePeriodSeconds'] = self.kms_data_key_reuse_period_seconds.to_dict()
            elif isinstance(self.kms_data_key_reuse_period_seconds, list):
                props['KmsDataKeyReusePeriodSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_data_key_reuse_period_seconds
                ]
            else:
                props['KmsDataKeyReusePeriodSeconds'] = self.kms_data_key_reuse_period_seconds

        return props


@dataclass
class LogDestination:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ste"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logs_log_group: Optional[CloudWatchLogsLogGroup] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cloud_watch_logs_log_group is not None:
            if hasattr(self.cloud_watch_logs_log_group, 'to_dict'):
                props['CloudWatchLogsLogGroup'] = self.cloud_watch_logs_log_group.to_dict()
            elif isinstance(self.cloud_watch_logs_log_group, list):
                props['CloudWatchLogsLogGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cloud_watch_logs_log_group
                ]
            else:
                props['CloudWatchLogsLogGroup'] = self.cloud_watch_logs_log_group

        return props


@dataclass
class LoggingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ste"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    include_execution_data: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destinations: Optional[list[LogDestination]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    level: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.include_execution_data is not None:
            if hasattr(self.include_execution_data, 'to_dict'):
                props['IncludeExecutionData'] = self.include_execution_data.to_dict()
            elif isinstance(self.include_execution_data, list):
                props['IncludeExecutionData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.include_execution_data
                ]
            else:
                props['IncludeExecutionData'] = self.include_execution_data

        if self.destinations is not None:
            if hasattr(self.destinations, 'to_dict'):
                props['Destinations'] = self.destinations.to_dict()
            elif isinstance(self.destinations, list):
                props['Destinations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destinations
                ]
            else:
                props['Destinations'] = self.destinations

        if self.level is not None:
            if hasattr(self.level, 'to_dict'):
                props['Level'] = self.level.to_dict()
            elif isinstance(self.level, list):
                props['Level'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.level
                ]
            else:
                props['Level'] = self.level

        return props


@dataclass
class S3Location:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ste"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.bucket is not None:
            if hasattr(self.bucket, 'to_dict'):
                props['Bucket'] = self.bucket.to_dict()
            elif isinstance(self.bucket, list):
                props['Bucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket
                ]
            else:
                props['Bucket'] = self.bucket

        if self.version is not None:
            if hasattr(self.version, 'to_dict'):
                props['Version'] = self.version.to_dict()
            elif isinstance(self.version, list):
                props['Version'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version
                ]
            else:
                props['Version'] = self.version

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class TagsEntry:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ste"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class TracingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ste"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class StateMachine(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-stepf"""

    resource_type: ClassVar[str] = "AWS::StepFunctions::StateMachine"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    encryption_configuration: Optional[EncryptionConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    definition_string: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    logging_configuration: Optional[LoggingConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    definition_substitutions: Optional[dict[str, dict[str, Any]]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    definition: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    definition_s3_location: Optional[S3Location] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    state_machine_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[TagsEntry]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    state_machine_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tracing_configuration: Optional[TracingConfiguration] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.encryption_configuration is not None:
            # Serialize encryption_configuration (handle intrinsic functions)
            if hasattr(self.encryption_configuration, 'to_dict'):
                props["EncryptionConfiguration"] = self.encryption_configuration.to_dict()
            elif isinstance(self.encryption_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['EncryptionConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encryption_configuration
                ]
            else:
                props["EncryptionConfiguration"] = self.encryption_configuration

        if self.definition_string is not None:
            # Serialize definition_string (handle intrinsic functions)
            if hasattr(self.definition_string, 'to_dict'):
                props["DefinitionString"] = self.definition_string.to_dict()
            elif isinstance(self.definition_string, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefinitionString'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.definition_string
                ]
            else:
                props["DefinitionString"] = self.definition_string

        if self.logging_configuration is not None:
            # Serialize logging_configuration (handle intrinsic functions)
            if hasattr(self.logging_configuration, 'to_dict'):
                props["LoggingConfiguration"] = self.logging_configuration.to_dict()
            elif isinstance(self.logging_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['LoggingConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.logging_configuration
                ]
            else:
                props["LoggingConfiguration"] = self.logging_configuration

        if self.definition_substitutions is not None:
            # Serialize definition_substitutions (handle intrinsic functions)
            if hasattr(self.definition_substitutions, 'to_dict'):
                props["DefinitionSubstitutions"] = self.definition_substitutions.to_dict()
            elif isinstance(self.definition_substitutions, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefinitionSubstitutions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.definition_substitutions
                ]
            else:
                props["DefinitionSubstitutions"] = self.definition_substitutions

        if self.definition is not None:
            # Serialize definition (handle intrinsic functions)
            if hasattr(self.definition, 'to_dict'):
                props["Definition"] = self.definition.to_dict()
            elif isinstance(self.definition, list):
                # Serialize list items (may contain intrinsic functions)
                props['Definition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.definition
                ]
            else:
                props["Definition"] = self.definition

        if self.definition_s3_location is not None:
            # Serialize definition_s3_location (handle intrinsic functions)
            if hasattr(self.definition_s3_location, 'to_dict'):
                props["DefinitionS3Location"] = self.definition_s3_location.to_dict()
            elif isinstance(self.definition_s3_location, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefinitionS3Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.definition_s3_location
                ]
            else:
                props["DefinitionS3Location"] = self.definition_s3_location

        if self.state_machine_name is not None:
            # Serialize state_machine_name (handle intrinsic functions)
            if hasattr(self.state_machine_name, 'to_dict'):
                props["StateMachineName"] = self.state_machine_name.to_dict()
            elif isinstance(self.state_machine_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['StateMachineName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state_machine_name
                ]
            else:
                props["StateMachineName"] = self.state_machine_name

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.state_machine_type is not None:
            # Serialize state_machine_type (handle intrinsic functions)
            if hasattr(self.state_machine_type, 'to_dict'):
                props["StateMachineType"] = self.state_machine_type.to_dict()
            elif isinstance(self.state_machine_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['StateMachineType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state_machine_type
                ]
            else:
                props["StateMachineType"] = self.state_machine_type

        if self.tracing_configuration is not None:
            # Serialize tracing_configuration (handle intrinsic functions)
            if hasattr(self.tracing_configuration, 'to_dict'):
                props["TracingConfiguration"] = self.tracing_configuration.to_dict()
            elif isinstance(self.tracing_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['TracingConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tracing_configuration
                ]
            else:
                props["TracingConfiguration"] = self.tracing_configuration

        return props

    @property
    def attr_state_machine_revision_id(self) -> GetAtt:
        """Get the StateMachineRevisionId attribute."""
        return self.get_att("StateMachineRevisionId")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_name(self) -> GetAtt:
        """Get the Name attribute."""
        return self.get_att("Name")




@dataclass
class DeploymentPreference:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ste"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    state_machine_version_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    alarms: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    interval: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.state_machine_version_arn is not None:
            if hasattr(self.state_machine_version_arn, 'to_dict'):
                props['StateMachineVersionArn'] = self.state_machine_version_arn.to_dict()
            elif isinstance(self.state_machine_version_arn, list):
                props['StateMachineVersionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state_machine_version_arn
                ]
            else:
                props['StateMachineVersionArn'] = self.state_machine_version_arn

        if self.percentage is not None:
            if hasattr(self.percentage, 'to_dict'):
                props['Percentage'] = self.percentage.to_dict()
            elif isinstance(self.percentage, list):
                props['Percentage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.percentage
                ]
            else:
                props['Percentage'] = self.percentage

        if self.alarms is not None:
            if hasattr(self.alarms, 'to_dict'):
                props['Alarms'] = self.alarms.to_dict()
            elif isinstance(self.alarms, list):
                props['Alarms'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.alarms
                ]
            else:
                props['Alarms'] = self.alarms

        if self.interval is not None:
            if hasattr(self.interval, 'to_dict'):
                props['Interval'] = self.interval.to_dict()
            elif isinstance(self.interval, list):
                props['Interval'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.interval
                ]
            else:
                props['Interval'] = self.interval

        return props


@dataclass
class RoutingConfigurationVersion:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ste"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    state_machine_version_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    weight: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.state_machine_version_arn is not None:
            if hasattr(self.state_machine_version_arn, 'to_dict'):
                props['StateMachineVersionArn'] = self.state_machine_version_arn.to_dict()
            elif isinstance(self.state_machine_version_arn, list):
                props['StateMachineVersionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state_machine_version_arn
                ]
            else:
                props['StateMachineVersionArn'] = self.state_machine_version_arn

        if self.weight is not None:
            if hasattr(self.weight, 'to_dict'):
                props['Weight'] = self.weight.to_dict()
            elif isinstance(self.weight, list):
                props['Weight'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weight
                ]
            else:
                props['Weight'] = self.weight

        return props


@dataclass
class StateMachineAlias(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-stepf"""

    resource_type: ClassVar[str] = "AWS::StepFunctions::StateMachineAlias"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    routing_configuration: Optional[list[RoutingConfigurationVersion]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    deployment_preference: Optional[DeploymentPreference] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.routing_configuration is not None:
            # Serialize routing_configuration (handle intrinsic functions)
            if hasattr(self.routing_configuration, 'to_dict'):
                props["RoutingConfiguration"] = self.routing_configuration.to_dict()
            elif isinstance(self.routing_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoutingConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.routing_configuration
                ]
            else:
                props["RoutingConfiguration"] = self.routing_configuration

        if self.deployment_preference is not None:
            # Serialize deployment_preference (handle intrinsic functions)
            if hasattr(self.deployment_preference, 'to_dict'):
                props["DeploymentPreference"] = self.deployment_preference.to_dict()
            elif isinstance(self.deployment_preference, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeploymentPreference'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.deployment_preference
                ]
            else:
                props["DeploymentPreference"] = self.deployment_preference

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class StateMachineVersion(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-stepf"""

    resource_type: ClassVar[str] = "AWS::StepFunctions::StateMachineVersion"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    state_machine_revision_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    state_machine_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.state_machine_revision_id is not None:
            # Serialize state_machine_revision_id (handle intrinsic functions)
            if hasattr(self.state_machine_revision_id, 'to_dict'):
                props["StateMachineRevisionId"] = self.state_machine_revision_id.to_dict()
            elif isinstance(self.state_machine_revision_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['StateMachineRevisionId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state_machine_revision_id
                ]
            else:
                props["StateMachineRevisionId"] = self.state_machine_revision_id

        if self.state_machine_arn is not None:
            # Serialize state_machine_arn (handle intrinsic functions)
            if hasattr(self.state_machine_arn, 'to_dict'):
                props["StateMachineArn"] = self.state_machine_arn.to_dict()
            elif isinstance(self.state_machine_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['StateMachineArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state_machine_arn
                ]
            else:
                props["StateMachineArn"] = self.state_machine_arn

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")



