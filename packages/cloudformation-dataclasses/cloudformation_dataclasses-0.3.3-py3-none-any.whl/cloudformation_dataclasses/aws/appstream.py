"""
AWS CloudFormation AppStream Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:34

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service AppStream
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AccessEndpointType:
    """AccessEndpointType enum values."""

    STREAMING = "STREAMING"


class Action:
    """Action enum values."""

    CLIPBOARD_COPY_FROM_LOCAL_DEVICE = "CLIPBOARD_COPY_FROM_LOCAL_DEVICE"
    CLIPBOARD_COPY_TO_LOCAL_DEVICE = "CLIPBOARD_COPY_TO_LOCAL_DEVICE"
    FILE_UPLOAD = "FILE_UPLOAD"
    FILE_DOWNLOAD = "FILE_DOWNLOAD"
    PRINTING_TO_LOCAL_DEVICE = "PRINTING_TO_LOCAL_DEVICE"
    DOMAIN_PASSWORD_SIGNIN = "DOMAIN_PASSWORD_SIGNIN"
    DOMAIN_SMART_CARD_SIGNIN = "DOMAIN_SMART_CARD_SIGNIN"
    AUTO_TIME_ZONE_REDIRECTION = "AUTO_TIME_ZONE_REDIRECTION"


class AgentSoftwareVersion:
    """AgentSoftwareVersion enum values."""

    CURRENT_LATEST = "CURRENT_LATEST"
    ALWAYS_LATEST = "ALWAYS_LATEST"


class AppBlockBuilderAttribute:
    """AppBlockBuilderAttribute enum values."""

    IAM_ROLE_ARN = "IAM_ROLE_ARN"
    ACCESS_ENDPOINTS = "ACCESS_ENDPOINTS"
    VPC_CONFIGURATION_SECURITY_GROUP_IDS = "VPC_CONFIGURATION_SECURITY_GROUP_IDS"


class AppBlockBuilderPlatformType:
    """AppBlockBuilderPlatformType enum values."""

    WINDOWS_SERVER_2019 = "WINDOWS_SERVER_2019"


class AppBlockBuilderState:
    """AppBlockBuilderState enum values."""

    STARTING = "STARTING"
    RUNNING = "RUNNING"
    STOPPING = "STOPPING"
    STOPPED = "STOPPED"


class AppBlockBuilderStateChangeReasonCode:
    """AppBlockBuilderStateChangeReasonCode enum values."""

    INTERNAL_ERROR = "INTERNAL_ERROR"


class AppBlockState:
    """AppBlockState enum values."""

    INACTIVE = "INACTIVE"
    ACTIVE = "ACTIVE"


class AppVisibility:
    """AppVisibility enum values."""

    ALL = "ALL"
    ASSOCIATED = "ASSOCIATED"


class ApplicationAttribute:
    """ApplicationAttribute enum values."""

    LAUNCH_PARAMETERS = "LAUNCH_PARAMETERS"
    WORKING_DIRECTORY = "WORKING_DIRECTORY"


class AuthenticationType:
    """AuthenticationType enum values."""

    API = "API"
    SAML = "SAML"
    USERPOOL = "USERPOOL"
    AWS_AD = "AWS_AD"


class CertificateBasedAuthStatus:
    """CertificateBasedAuthStatus enum values."""

    DISABLED = "DISABLED"
    ENABLED = "ENABLED"
    ENABLED_NO_DIRECTORY_LOGIN_FALLBACK = "ENABLED_NO_DIRECTORY_LOGIN_FALLBACK"


class DynamicAppProvidersEnabled:
    """DynamicAppProvidersEnabled enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class ExportImageTaskState:
    """ExportImageTaskState enum values."""

    EXPORTING = "EXPORTING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"


class FleetAttribute:
    """FleetAttribute enum values."""

    VPC_CONFIGURATION = "VPC_CONFIGURATION"
    VPC_CONFIGURATION_SECURITY_GROUP_IDS = "VPC_CONFIGURATION_SECURITY_GROUP_IDS"
    DOMAIN_JOIN_INFO = "DOMAIN_JOIN_INFO"
    IAM_ROLE_ARN = "IAM_ROLE_ARN"
    USB_DEVICE_FILTER_STRINGS = "USB_DEVICE_FILTER_STRINGS"
    SESSION_SCRIPT_S3_LOCATION = "SESSION_SCRIPT_S3_LOCATION"
    MAX_SESSIONS_PER_INSTANCE = "MAX_SESSIONS_PER_INSTANCE"
    VOLUME_CONFIGURATION = "VOLUME_CONFIGURATION"


class FleetErrorCode:
    """FleetErrorCode enum values."""

    IAM_SERVICE_ROLE_MISSING_ENI_DESCRIBE_ACTION = "IAM_SERVICE_ROLE_MISSING_ENI_DESCRIBE_ACTION"
    IAM_SERVICE_ROLE_MISSING_ENI_CREATE_ACTION = "IAM_SERVICE_ROLE_MISSING_ENI_CREATE_ACTION"
    IAM_SERVICE_ROLE_MISSING_ENI_DELETE_ACTION = "IAM_SERVICE_ROLE_MISSING_ENI_DELETE_ACTION"
    NETWORK_INTERFACE_LIMIT_EXCEEDED = "NETWORK_INTERFACE_LIMIT_EXCEEDED"
    INTERNAL_SERVICE_ERROR = "INTERNAL_SERVICE_ERROR"
    IAM_SERVICE_ROLE_IS_MISSING = "IAM_SERVICE_ROLE_IS_MISSING"
    MACHINE_ROLE_IS_MISSING = "MACHINE_ROLE_IS_MISSING"
    STS_DISABLED_IN_REGION = "STS_DISABLED_IN_REGION"
    SUBNET_HAS_INSUFFICIENT_IP_ADDRESSES = "SUBNET_HAS_INSUFFICIENT_IP_ADDRESSES"
    IAM_SERVICE_ROLE_MISSING_DESCRIBE_SUBNET_ACTION = "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SUBNET_ACTION"
    SUBNET_NOT_FOUND = "SUBNET_NOT_FOUND"
    IMAGE_NOT_FOUND = "IMAGE_NOT_FOUND"
    INVALID_SUBNET_CONFIGURATION = "INVALID_SUBNET_CONFIGURATION"
    SECURITY_GROUPS_NOT_FOUND = "SECURITY_GROUPS_NOT_FOUND"
    IGW_NOT_ATTACHED = "IGW_NOT_ATTACHED"
    IAM_SERVICE_ROLE_MISSING_DESCRIBE_SECURITY_GROUPS_ACTION = "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SECURITY_GROUPS_ACTION"
    FLEET_STOPPED = "FLEET_STOPPED"
    FLEET_INSTANCE_PROVISIONING_FAILURE = "FLEET_INSTANCE_PROVISIONING_FAILURE"
    DOMAIN_JOIN_ERROR_FILE_NOT_FOUND = "DOMAIN_JOIN_ERROR_FILE_NOT_FOUND"
    DOMAIN_JOIN_ERROR_ACCESS_DENIED = "DOMAIN_JOIN_ERROR_ACCESS_DENIED"
    DOMAIN_JOIN_ERROR_LOGON_FAILURE = "DOMAIN_JOIN_ERROR_LOGON_FAILURE"
    DOMAIN_JOIN_ERROR_INVALID_PARAMETER = "DOMAIN_JOIN_ERROR_INVALID_PARAMETER"
    DOMAIN_JOIN_ERROR_MORE_DATA = "DOMAIN_JOIN_ERROR_MORE_DATA"
    DOMAIN_JOIN_ERROR_NO_SUCH_DOMAIN = "DOMAIN_JOIN_ERROR_NO_SUCH_DOMAIN"
    DOMAIN_JOIN_ERROR_NOT_SUPPORTED = "DOMAIN_JOIN_ERROR_NOT_SUPPORTED"
    DOMAIN_JOIN_NERR_INVALID_WORKGROUP_NAME = "DOMAIN_JOIN_NERR_INVALID_WORKGROUP_NAME"
    DOMAIN_JOIN_NERR_WORKSTATION_NOT_STARTED = "DOMAIN_JOIN_NERR_WORKSTATION_NOT_STARTED"
    DOMAIN_JOIN_ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED = "DOMAIN_JOIN_ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED"
    DOMAIN_JOIN_NERR_PASSWORD_EXPIRED = "DOMAIN_JOIN_NERR_PASSWORD_EXPIRED"
    DOMAIN_JOIN_INTERNAL_SERVICE_ERROR = "DOMAIN_JOIN_INTERNAL_SERVICE_ERROR"
    VALIDATION_ERROR = "VALIDATION_ERROR"


class FleetState:
    """FleetState enum values."""

    STARTING = "STARTING"
    RUNNING = "RUNNING"
    STOPPING = "STOPPING"
    STOPPED = "STOPPED"


class FleetType:
    """FleetType enum values."""

    ALWAYS_ON = "ALWAYS_ON"
    ON_DEMAND = "ON_DEMAND"
    ELASTIC = "ELASTIC"


class ImageBuilderState:
    """ImageBuilderState enum values."""

    PENDING = "PENDING"
    UPDATING_AGENT = "UPDATING_AGENT"
    RUNNING = "RUNNING"
    STOPPING = "STOPPING"
    STOPPED = "STOPPED"
    REBOOTING = "REBOOTING"
    SNAPSHOTTING = "SNAPSHOTTING"
    DELETING = "DELETING"
    FAILED = "FAILED"
    UPDATING = "UPDATING"
    PENDING_QUALIFICATION = "PENDING_QUALIFICATION"
    PENDING_SYNCING_APPS = "PENDING_SYNCING_APPS"
    SYNCING_APPS = "SYNCING_APPS"
    PENDING_IMAGE_IMPORT = "PENDING_IMAGE_IMPORT"


class ImageBuilderStateChangeReasonCode:
    """ImageBuilderStateChangeReasonCode enum values."""

    INTERNAL_ERROR = "INTERNAL_ERROR"
    IMAGE_UNAVAILABLE = "IMAGE_UNAVAILABLE"


class ImageSharedWithOthers:
    """ImageSharedWithOthers enum values."""

    TRUE = "TRUE"
    FALSE = "FALSE"


class ImageState:
    """ImageState enum values."""

    PENDING = "PENDING"
    AVAILABLE = "AVAILABLE"
    FAILED = "FAILED"
    COPYING = "COPYING"
    DELETING = "DELETING"
    CREATING = "CREATING"
    IMPORTING = "IMPORTING"
    VALIDATING = "VALIDATING"


class ImageStateChangeReasonCode:
    """ImageStateChangeReasonCode enum values."""

    INTERNAL_ERROR = "INTERNAL_ERROR"
    IMAGE_BUILDER_NOT_AVAILABLE = "IMAGE_BUILDER_NOT_AVAILABLE"
    IMAGE_COPY_FAILURE = "IMAGE_COPY_FAILURE"
    IMAGE_UPDATE_FAILURE = "IMAGE_UPDATE_FAILURE"
    IMAGE_IMPORT_FAILURE = "IMAGE_IMPORT_FAILURE"


class ImageType:
    """ImageType enum values."""

    CUSTOM = "CUSTOM"
    NATIVE = "NATIVE"


class LatestAppstreamAgentVersion:
    """LatestAppstreamAgentVersion enum values."""

    TRUE = "TRUE"
    FALSE = "FALSE"


class MessageAction:
    """MessageAction enum values."""

    SUPPRESS = "SUPPRESS"
    RESEND = "RESEND"


class PackagingType:
    """PackagingType enum values."""

    CUSTOM = "CUSTOM"
    APPSTREAM2 = "APPSTREAM2"


class Permission:
    """Permission enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class PlatformType:
    """PlatformType enum values."""

    WINDOWS = "WINDOWS"
    WINDOWS_SERVER_2016 = "WINDOWS_SERVER_2016"
    WINDOWS_SERVER_2019 = "WINDOWS_SERVER_2019"
    WINDOWS_SERVER_2022 = "WINDOWS_SERVER_2022"
    AMAZON_LINUX2 = "AMAZON_LINUX2"
    RHEL8 = "RHEL8"
    ROCKY_LINUX8 = "ROCKY_LINUX8"


class PreferredProtocol:
    """PreferredProtocol enum values."""

    TCP = "TCP"
    UDP = "UDP"


class SessionConnectionState:
    """SessionConnectionState enum values."""

    CONNECTED = "CONNECTED"
    NOT_CONNECTED = "NOT_CONNECTED"


class SessionState:
    """SessionState enum values."""

    ACTIVE = "ACTIVE"
    PENDING = "PENDING"
    EXPIRED = "EXPIRED"


class SoftwareDeploymentStatus:
    """SoftwareDeploymentStatus enum values."""

    STAGED_FOR_INSTALLATION = "STAGED_FOR_INSTALLATION"
    PENDING_INSTALLATION = "PENDING_INSTALLATION"
    INSTALLED = "INSTALLED"
    STAGED_FOR_UNINSTALLATION = "STAGED_FOR_UNINSTALLATION"
    PENDING_UNINSTALLATION = "PENDING_UNINSTALLATION"
    FAILED_TO_INSTALL = "FAILED_TO_INSTALL"
    FAILED_TO_UNINSTALL = "FAILED_TO_UNINSTALL"


class StackAttribute:
    """StackAttribute enum values."""

    STORAGE_CONNECTORS = "STORAGE_CONNECTORS"
    STORAGE_CONNECTOR_HOMEFOLDERS = "STORAGE_CONNECTOR_HOMEFOLDERS"
    STORAGE_CONNECTOR_GOOGLE_DRIVE = "STORAGE_CONNECTOR_GOOGLE_DRIVE"
    STORAGE_CONNECTOR_ONE_DRIVE = "STORAGE_CONNECTOR_ONE_DRIVE"
    REDIRECT_URL = "REDIRECT_URL"
    FEEDBACK_URL = "FEEDBACK_URL"
    THEME_NAME = "THEME_NAME"
    USER_SETTINGS = "USER_SETTINGS"
    EMBED_HOST_DOMAINS = "EMBED_HOST_DOMAINS"
    IAM_ROLE_ARN = "IAM_ROLE_ARN"
    ACCESS_ENDPOINTS = "ACCESS_ENDPOINTS"
    STREAMING_EXPERIENCE_SETTINGS = "STREAMING_EXPERIENCE_SETTINGS"


class StackErrorCode:
    """StackErrorCode enum values."""

    STORAGE_CONNECTOR_ERROR = "STORAGE_CONNECTOR_ERROR"
    INTERNAL_SERVICE_ERROR = "INTERNAL_SERVICE_ERROR"


class StorageConnectorType:
    """StorageConnectorType enum values."""

    HOMEFOLDERS = "HOMEFOLDERS"
    GOOGLE_DRIVE = "GOOGLE_DRIVE"
    ONE_DRIVE = "ONE_DRIVE"


class StreamView:
    """StreamView enum values."""

    APP = "APP"
    DESKTOP = "DESKTOP"


class ThemeAttribute:
    """ThemeAttribute enum values."""

    FOOTER_LINKS = "FOOTER_LINKS"


class ThemeState:
    """ThemeState enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class ThemeStyling:
    """ThemeStyling enum values."""

    LIGHT_BLUE = "LIGHT_BLUE"
    BLUE = "BLUE"
    PINK = "PINK"
    RED = "RED"


class UsageReportExecutionErrorCode:
    """UsageReportExecutionErrorCode enum values."""

    RESOURCE_NOT_FOUND = "RESOURCE_NOT_FOUND"
    ACCESS_DENIED = "ACCESS_DENIED"
    INTERNAL_SERVICE_ERROR = "INTERNAL_SERVICE_ERROR"


class UsageReportSchedule:
    """UsageReportSchedule enum values."""

    DAILY = "DAILY"


class UserStackAssociationErrorCode:
    """UserStackAssociationErrorCode enum values."""

    STACK_NOT_FOUND = "STACK_NOT_FOUND"
    USER_NAME_NOT_FOUND = "USER_NAME_NOT_FOUND"
    DIRECTORY_NOT_FOUND = "DIRECTORY_NOT_FOUND"
    INTERNAL_ERROR = "INTERNAL_ERROR"


class VisibilityType:
    """VisibilityType enum values."""

    PUBLIC = "PUBLIC"
    PRIVATE = "PRIVATE"
    SHARED = "SHARED"


# Convenient aliases for enum values
STREAMING = AccessEndpointType.STREAMING
CLIPBOARD_COPY_FROM_LOCAL_DEVICE = Action.CLIPBOARD_COPY_FROM_LOCAL_DEVICE
CLIPBOARD_COPY_TO_LOCAL_DEVICE = Action.CLIPBOARD_COPY_TO_LOCAL_DEVICE
FILE_UPLOAD = Action.FILE_UPLOAD
FILE_DOWNLOAD = Action.FILE_DOWNLOAD
PRINTING_TO_LOCAL_DEVICE = Action.PRINTING_TO_LOCAL_DEVICE
DOMAIN_PASSWORD_SIGNIN = Action.DOMAIN_PASSWORD_SIGNIN
DOMAIN_SMART_CARD_SIGNIN = Action.DOMAIN_SMART_CARD_SIGNIN
AUTO_TIME_ZONE_REDIRECTION = Action.AUTO_TIME_ZONE_REDIRECTION
CURRENT_LATEST = AgentSoftwareVersion.CURRENT_LATEST
ALWAYS_LATEST = AgentSoftwareVersion.ALWAYS_LATEST
IAM_ROLE_ARN = AppBlockBuilderAttribute.IAM_ROLE_ARN
ACCESS_ENDPOINTS = AppBlockBuilderAttribute.ACCESS_ENDPOINTS
VPC_CONFIGURATION_SECURITY_GROUP_IDS = AppBlockBuilderAttribute.VPC_CONFIGURATION_SECURITY_GROUP_IDS
WINDOWS_SERVER_2019 = AppBlockBuilderPlatformType.WINDOWS_SERVER_2019
STARTING = AppBlockBuilderState.STARTING
RUNNING = AppBlockBuilderState.RUNNING
STOPPING = AppBlockBuilderState.STOPPING
STOPPED = AppBlockBuilderState.STOPPED
INTERNAL_ERROR = AppBlockBuilderStateChangeReasonCode.INTERNAL_ERROR
INACTIVE = AppBlockState.INACTIVE
ACTIVE = AppBlockState.ACTIVE
ALL = AppVisibility.ALL
ASSOCIATED = AppVisibility.ASSOCIATED
LAUNCH_PARAMETERS = ApplicationAttribute.LAUNCH_PARAMETERS
WORKING_DIRECTORY = ApplicationAttribute.WORKING_DIRECTORY
API = AuthenticationType.API
SAML = AuthenticationType.SAML
USERPOOL = AuthenticationType.USERPOOL
AWS_AD = AuthenticationType.AWS_AD
DISABLED = CertificateBasedAuthStatus.DISABLED
ENABLED = CertificateBasedAuthStatus.ENABLED
ENABLED_NO_DIRECTORY_LOGIN_FALLBACK = CertificateBasedAuthStatus.ENABLED_NO_DIRECTORY_LOGIN_FALLBACK
ENABLED = DynamicAppProvidersEnabled.ENABLED
DISABLED = DynamicAppProvidersEnabled.DISABLED
EXPORTING = ExportImageTaskState.EXPORTING
COMPLETED = ExportImageTaskState.COMPLETED
FAILED = ExportImageTaskState.FAILED
VPC_CONFIGURATION = FleetAttribute.VPC_CONFIGURATION
VPC_CONFIGURATION_SECURITY_GROUP_IDS = FleetAttribute.VPC_CONFIGURATION_SECURITY_GROUP_IDS
DOMAIN_JOIN_INFO = FleetAttribute.DOMAIN_JOIN_INFO
IAM_ROLE_ARN = FleetAttribute.IAM_ROLE_ARN
USB_DEVICE_FILTER_STRINGS = FleetAttribute.USB_DEVICE_FILTER_STRINGS
SESSION_SCRIPT_S3_LOCATION = FleetAttribute.SESSION_SCRIPT_S3_LOCATION
MAX_SESSIONS_PER_INSTANCE = FleetAttribute.MAX_SESSIONS_PER_INSTANCE
VOLUME_CONFIGURATION = FleetAttribute.VOLUME_CONFIGURATION
IAM_SERVICE_ROLE_MISSING_ENI_DESCRIBE_ACTION = FleetErrorCode.IAM_SERVICE_ROLE_MISSING_ENI_DESCRIBE_ACTION
IAM_SERVICE_ROLE_MISSING_ENI_CREATE_ACTION = FleetErrorCode.IAM_SERVICE_ROLE_MISSING_ENI_CREATE_ACTION
IAM_SERVICE_ROLE_MISSING_ENI_DELETE_ACTION = FleetErrorCode.IAM_SERVICE_ROLE_MISSING_ENI_DELETE_ACTION
NETWORK_INTERFACE_LIMIT_EXCEEDED = FleetErrorCode.NETWORK_INTERFACE_LIMIT_EXCEEDED
INTERNAL_SERVICE_ERROR = FleetErrorCode.INTERNAL_SERVICE_ERROR
IAM_SERVICE_ROLE_IS_MISSING = FleetErrorCode.IAM_SERVICE_ROLE_IS_MISSING
MACHINE_ROLE_IS_MISSING = FleetErrorCode.MACHINE_ROLE_IS_MISSING
STS_DISABLED_IN_REGION = FleetErrorCode.STS_DISABLED_IN_REGION
SUBNET_HAS_INSUFFICIENT_IP_ADDRESSES = FleetErrorCode.SUBNET_HAS_INSUFFICIENT_IP_ADDRESSES
IAM_SERVICE_ROLE_MISSING_DESCRIBE_SUBNET_ACTION = FleetErrorCode.IAM_SERVICE_ROLE_MISSING_DESCRIBE_SUBNET_ACTION
SUBNET_NOT_FOUND = FleetErrorCode.SUBNET_NOT_FOUND
IMAGE_NOT_FOUND = FleetErrorCode.IMAGE_NOT_FOUND
INVALID_SUBNET_CONFIGURATION = FleetErrorCode.INVALID_SUBNET_CONFIGURATION
SECURITY_GROUPS_NOT_FOUND = FleetErrorCode.SECURITY_GROUPS_NOT_FOUND
IGW_NOT_ATTACHED = FleetErrorCode.IGW_NOT_ATTACHED
IAM_SERVICE_ROLE_MISSING_DESCRIBE_SECURITY_GROUPS_ACTION = FleetErrorCode.IAM_SERVICE_ROLE_MISSING_DESCRIBE_SECURITY_GROUPS_ACTION
FLEET_STOPPED = FleetErrorCode.FLEET_STOPPED
FLEET_INSTANCE_PROVISIONING_FAILURE = FleetErrorCode.FLEET_INSTANCE_PROVISIONING_FAILURE
DOMAIN_JOIN_ERROR_FILE_NOT_FOUND = FleetErrorCode.DOMAIN_JOIN_ERROR_FILE_NOT_FOUND
DOMAIN_JOIN_ERROR_ACCESS_DENIED = FleetErrorCode.DOMAIN_JOIN_ERROR_ACCESS_DENIED
DOMAIN_JOIN_ERROR_LOGON_FAILURE = FleetErrorCode.DOMAIN_JOIN_ERROR_LOGON_FAILURE
DOMAIN_JOIN_ERROR_INVALID_PARAMETER = FleetErrorCode.DOMAIN_JOIN_ERROR_INVALID_PARAMETER
DOMAIN_JOIN_ERROR_MORE_DATA = FleetErrorCode.DOMAIN_JOIN_ERROR_MORE_DATA
DOMAIN_JOIN_ERROR_NO_SUCH_DOMAIN = FleetErrorCode.DOMAIN_JOIN_ERROR_NO_SUCH_DOMAIN
DOMAIN_JOIN_ERROR_NOT_SUPPORTED = FleetErrorCode.DOMAIN_JOIN_ERROR_NOT_SUPPORTED
DOMAIN_JOIN_NERR_INVALID_WORKGROUP_NAME = FleetErrorCode.DOMAIN_JOIN_NERR_INVALID_WORKGROUP_NAME
DOMAIN_JOIN_NERR_WORKSTATION_NOT_STARTED = FleetErrorCode.DOMAIN_JOIN_NERR_WORKSTATION_NOT_STARTED
DOMAIN_JOIN_ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED = FleetErrorCode.DOMAIN_JOIN_ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED
DOMAIN_JOIN_NERR_PASSWORD_EXPIRED = FleetErrorCode.DOMAIN_JOIN_NERR_PASSWORD_EXPIRED
DOMAIN_JOIN_INTERNAL_SERVICE_ERROR = FleetErrorCode.DOMAIN_JOIN_INTERNAL_SERVICE_ERROR
VALIDATION_ERROR = FleetErrorCode.VALIDATION_ERROR
STARTING = FleetState.STARTING
RUNNING = FleetState.RUNNING
STOPPING = FleetState.STOPPING
STOPPED = FleetState.STOPPED
ALWAYS_ON = FleetType.ALWAYS_ON
ON_DEMAND = FleetType.ON_DEMAND
ELASTIC = FleetType.ELASTIC
PENDING = ImageBuilderState.PENDING
UPDATING_AGENT = ImageBuilderState.UPDATING_AGENT
RUNNING = ImageBuilderState.RUNNING
STOPPING = ImageBuilderState.STOPPING
STOPPED = ImageBuilderState.STOPPED
REBOOTING = ImageBuilderState.REBOOTING
SNAPSHOTTING = ImageBuilderState.SNAPSHOTTING
DELETING = ImageBuilderState.DELETING
FAILED = ImageBuilderState.FAILED
UPDATING = ImageBuilderState.UPDATING
PENDING_QUALIFICATION = ImageBuilderState.PENDING_QUALIFICATION
PENDING_SYNCING_APPS = ImageBuilderState.PENDING_SYNCING_APPS
SYNCING_APPS = ImageBuilderState.SYNCING_APPS
PENDING_IMAGE_IMPORT = ImageBuilderState.PENDING_IMAGE_IMPORT
INTERNAL_ERROR = ImageBuilderStateChangeReasonCode.INTERNAL_ERROR
IMAGE_UNAVAILABLE = ImageBuilderStateChangeReasonCode.IMAGE_UNAVAILABLE
TRUE = ImageSharedWithOthers.TRUE
FALSE = ImageSharedWithOthers.FALSE
PENDING = ImageState.PENDING
AVAILABLE = ImageState.AVAILABLE
FAILED = ImageState.FAILED
COPYING = ImageState.COPYING
DELETING = ImageState.DELETING
CREATING = ImageState.CREATING
IMPORTING = ImageState.IMPORTING
VALIDATING = ImageState.VALIDATING
INTERNAL_ERROR = ImageStateChangeReasonCode.INTERNAL_ERROR
IMAGE_BUILDER_NOT_AVAILABLE = ImageStateChangeReasonCode.IMAGE_BUILDER_NOT_AVAILABLE
IMAGE_COPY_FAILURE = ImageStateChangeReasonCode.IMAGE_COPY_FAILURE
IMAGE_UPDATE_FAILURE = ImageStateChangeReasonCode.IMAGE_UPDATE_FAILURE
IMAGE_IMPORT_FAILURE = ImageStateChangeReasonCode.IMAGE_IMPORT_FAILURE
CUSTOM = ImageType.CUSTOM
NATIVE = ImageType.NATIVE
TRUE = LatestAppstreamAgentVersion.TRUE
FALSE = LatestAppstreamAgentVersion.FALSE
SUPPRESS = MessageAction.SUPPRESS
RESEND = MessageAction.RESEND
CUSTOM = PackagingType.CUSTOM
APPSTREAM2 = PackagingType.APPSTREAM2
ENABLED = Permission.ENABLED
DISABLED = Permission.DISABLED
WINDOWS = PlatformType.WINDOWS
WINDOWS_SERVER_2016 = PlatformType.WINDOWS_SERVER_2016
WINDOWS_SERVER_2019 = PlatformType.WINDOWS_SERVER_2019
WINDOWS_SERVER_2022 = PlatformType.WINDOWS_SERVER_2022
AMAZON_LINUX2 = PlatformType.AMAZON_LINUX2
RHEL8 = PlatformType.RHEL8
ROCKY_LINUX8 = PlatformType.ROCKY_LINUX8
TCP = PreferredProtocol.TCP
UDP = PreferredProtocol.UDP
CONNECTED = SessionConnectionState.CONNECTED
NOT_CONNECTED = SessionConnectionState.NOT_CONNECTED
ACTIVE = SessionState.ACTIVE
PENDING = SessionState.PENDING
EXPIRED = SessionState.EXPIRED
STAGED_FOR_INSTALLATION = SoftwareDeploymentStatus.STAGED_FOR_INSTALLATION
PENDING_INSTALLATION = SoftwareDeploymentStatus.PENDING_INSTALLATION
INSTALLED = SoftwareDeploymentStatus.INSTALLED
STAGED_FOR_UNINSTALLATION = SoftwareDeploymentStatus.STAGED_FOR_UNINSTALLATION
PENDING_UNINSTALLATION = SoftwareDeploymentStatus.PENDING_UNINSTALLATION
FAILED_TO_INSTALL = SoftwareDeploymentStatus.FAILED_TO_INSTALL
FAILED_TO_UNINSTALL = SoftwareDeploymentStatus.FAILED_TO_UNINSTALL
STORAGE_CONNECTORS = StackAttribute.STORAGE_CONNECTORS
STORAGE_CONNECTOR_HOMEFOLDERS = StackAttribute.STORAGE_CONNECTOR_HOMEFOLDERS
STORAGE_CONNECTOR_GOOGLE_DRIVE = StackAttribute.STORAGE_CONNECTOR_GOOGLE_DRIVE
STORAGE_CONNECTOR_ONE_DRIVE = StackAttribute.STORAGE_CONNECTOR_ONE_DRIVE
REDIRECT_URL = StackAttribute.REDIRECT_URL
FEEDBACK_URL = StackAttribute.FEEDBACK_URL
THEME_NAME = StackAttribute.THEME_NAME
USER_SETTINGS = StackAttribute.USER_SETTINGS
EMBED_HOST_DOMAINS = StackAttribute.EMBED_HOST_DOMAINS
IAM_ROLE_ARN = StackAttribute.IAM_ROLE_ARN
ACCESS_ENDPOINTS = StackAttribute.ACCESS_ENDPOINTS
STREAMING_EXPERIENCE_SETTINGS = StackAttribute.STREAMING_EXPERIENCE_SETTINGS
STORAGE_CONNECTOR_ERROR = StackErrorCode.STORAGE_CONNECTOR_ERROR
INTERNAL_SERVICE_ERROR = StackErrorCode.INTERNAL_SERVICE_ERROR
HOMEFOLDERS = StorageConnectorType.HOMEFOLDERS
GOOGLE_DRIVE = StorageConnectorType.GOOGLE_DRIVE
ONE_DRIVE = StorageConnectorType.ONE_DRIVE
APP = StreamView.APP
DESKTOP = StreamView.DESKTOP
FOOTER_LINKS = ThemeAttribute.FOOTER_LINKS
ENABLED = ThemeState.ENABLED
DISABLED = ThemeState.DISABLED
LIGHT_BLUE = ThemeStyling.LIGHT_BLUE
BLUE = ThemeStyling.BLUE
PINK = ThemeStyling.PINK
RED = ThemeStyling.RED
RESOURCE_NOT_FOUND = UsageReportExecutionErrorCode.RESOURCE_NOT_FOUND
ACCESS_DENIED = UsageReportExecutionErrorCode.ACCESS_DENIED
INTERNAL_SERVICE_ERROR = UsageReportExecutionErrorCode.INTERNAL_SERVICE_ERROR
DAILY = UsageReportSchedule.DAILY
STACK_NOT_FOUND = UserStackAssociationErrorCode.STACK_NOT_FOUND
USER_NAME_NOT_FOUND = UserStackAssociationErrorCode.USER_NAME_NOT_FOUND
DIRECTORY_NOT_FOUND = UserStackAssociationErrorCode.DIRECTORY_NOT_FOUND
INTERNAL_ERROR = UserStackAssociationErrorCode.INTERNAL_ERROR
PUBLIC = VisibilityType.PUBLIC
PRIVATE = VisibilityType.PRIVATE
SHARED = VisibilityType.SHARED


@dataclass
class S3Location:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_bucket is not None:
            if hasattr(self.s3_bucket, 'to_dict'):
                props['S3Bucket'] = self.s3_bucket.to_dict()
            elif isinstance(self.s3_bucket, list):
                props['S3Bucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_bucket
                ]
            else:
                props['S3Bucket'] = self.s3_bucket

        if self.s3_key is not None:
            if hasattr(self.s3_key, 'to_dict'):
                props['S3Key'] = self.s3_key.to_dict()
            elif isinstance(self.s3_key, list):
                props['S3Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_key
                ]
            else:
                props['S3Key'] = self.s3_key

        return props


@dataclass
class ScriptDetails:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    timeout_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    script_s3_location: Optional[S3Location] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    executable_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    executable_parameters: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.timeout_in_seconds is not None:
            if hasattr(self.timeout_in_seconds, 'to_dict'):
                props['TimeoutInSeconds'] = self.timeout_in_seconds.to_dict()
            elif isinstance(self.timeout_in_seconds, list):
                props['TimeoutInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.timeout_in_seconds
                ]
            else:
                props['TimeoutInSeconds'] = self.timeout_in_seconds

        if self.script_s3_location is not None:
            if hasattr(self.script_s3_location, 'to_dict'):
                props['ScriptS3Location'] = self.script_s3_location.to_dict()
            elif isinstance(self.script_s3_location, list):
                props['ScriptS3Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.script_s3_location
                ]
            else:
                props['ScriptS3Location'] = self.script_s3_location

        if self.executable_path is not None:
            if hasattr(self.executable_path, 'to_dict'):
                props['ExecutablePath'] = self.executable_path.to_dict()
            elif isinstance(self.executable_path, list):
                props['ExecutablePath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.executable_path
                ]
            else:
                props['ExecutablePath'] = self.executable_path

        if self.executable_parameters is not None:
            if hasattr(self.executable_parameters, 'to_dict'):
                props['ExecutableParameters'] = self.executable_parameters.to_dict()
            elif isinstance(self.executable_parameters, list):
                props['ExecutableParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.executable_parameters
                ]
            else:
                props['ExecutableParameters'] = self.executable_parameters

        return props


@dataclass
class AppBlock(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appst"""

    resource_type: ClassVar[str] = "AWS::AppStream::AppBlock"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    setup_script_details: Optional[ScriptDetails] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    post_setup_script_details: Optional[ScriptDetails] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_s3_location: Optional[S3Location] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    packaging_type: Optional[Union[str, PackagingType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.setup_script_details is not None:
            # Serialize setup_script_details (handle intrinsic functions)
            if hasattr(self.setup_script_details, 'to_dict'):
                props["SetupScriptDetails"] = self.setup_script_details.to_dict()
            elif isinstance(self.setup_script_details, list):
                # Serialize list items (may contain intrinsic functions)
                props['SetupScriptDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.setup_script_details
                ]
            else:
                props["SetupScriptDetails"] = self.setup_script_details

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.post_setup_script_details is not None:
            # Serialize post_setup_script_details (handle intrinsic functions)
            if hasattr(self.post_setup_script_details, 'to_dict'):
                props["PostSetupScriptDetails"] = self.post_setup_script_details.to_dict()
            elif isinstance(self.post_setup_script_details, list):
                # Serialize list items (may contain intrinsic functions)
                props['PostSetupScriptDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.post_setup_script_details
                ]
            else:
                props["PostSetupScriptDetails"] = self.post_setup_script_details

        if self.display_name is not None:
            # Serialize display_name (handle intrinsic functions)
            if hasattr(self.display_name, 'to_dict'):
                props["DisplayName"] = self.display_name.to_dict()
            elif isinstance(self.display_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.display_name
                ]
            else:
                props["DisplayName"] = self.display_name

        if self.source_s3_location is not None:
            # Serialize source_s3_location (handle intrinsic functions)
            if hasattr(self.source_s3_location, 'to_dict'):
                props["SourceS3Location"] = self.source_s3_location.to_dict()
            elif isinstance(self.source_s3_location, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceS3Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_s3_location
                ]
            else:
                props["SourceS3Location"] = self.source_s3_location

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.packaging_type is not None:
            # Serialize packaging_type (handle intrinsic functions)
            if hasattr(self.packaging_type, 'to_dict'):
                props["PackagingType"] = self.packaging_type.to_dict()
            elif isinstance(self.packaging_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['PackagingType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.packaging_type
                ]
            else:
                props["PackagingType"] = self.packaging_type

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_created_time(self) -> GetAtt:
        """Get the CreatedTime attribute."""
        return self.get_att("CreatedTime")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class AccessEndpoint:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_type: Optional[Union[str, AccessEndpointType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpce_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.endpoint_type is not None:
            if hasattr(self.endpoint_type, 'to_dict'):
                props['EndpointType'] = self.endpoint_type.to_dict()
            elif isinstance(self.endpoint_type, list):
                props['EndpointType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_type
                ]
            else:
                props['EndpointType'] = self.endpoint_type

        if self.vpce_id is not None:
            if hasattr(self.vpce_id, 'to_dict'):
                props['VpceId'] = self.vpce_id.to_dict()
            elif isinstance(self.vpce_id, list):
                props['VpceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpce_id
                ]
            else:
                props['VpceId'] = self.vpce_id

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        if self.subnet_ids is not None:
            if hasattr(self.subnet_ids, 'to_dict'):
                props['SubnetIds'] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props['SubnetIds'] = self.subnet_ids

        return props


@dataclass
class AppBlockBuilder(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appst"""

    resource_type: ClassVar[str] = "AWS::AppStream::AppBlockBuilder"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    platform: Optional[Union[str, AppBlockBuilderPlatformType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_config: Optional[VpcConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    app_block_arns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_default_internet_access: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    iam_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    access_endpoints: Optional[list[AccessEndpoint]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.platform is not None:
            # Serialize platform (handle intrinsic functions)
            if hasattr(self.platform, 'to_dict'):
                props["Platform"] = self.platform.to_dict()
            elif isinstance(self.platform, list):
                # Serialize list items (may contain intrinsic functions)
                props['Platform'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.platform
                ]
            else:
                props["Platform"] = self.platform

        if self.vpc_config is not None:
            # Serialize vpc_config (handle intrinsic functions)
            if hasattr(self.vpc_config, 'to_dict'):
                props["VpcConfig"] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props["VpcConfig"] = self.vpc_config

        if self.app_block_arns is not None:
            # Serialize app_block_arns (handle intrinsic functions)
            if hasattr(self.app_block_arns, 'to_dict'):
                props["AppBlockArns"] = self.app_block_arns.to_dict()
            elif isinstance(self.app_block_arns, list):
                # Serialize list items (may contain intrinsic functions)
                props['AppBlockArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_block_arns
                ]
            else:
                props["AppBlockArns"] = self.app_block_arns

        if self.enable_default_internet_access is not None:
            # Serialize enable_default_internet_access (handle intrinsic functions)
            if hasattr(self.enable_default_internet_access, 'to_dict'):
                props["EnableDefaultInternetAccess"] = self.enable_default_internet_access.to_dict()
            elif isinstance(self.enable_default_internet_access, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableDefaultInternetAccess'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_default_internet_access
                ]
            else:
                props["EnableDefaultInternetAccess"] = self.enable_default_internet_access

        if self.display_name is not None:
            # Serialize display_name (handle intrinsic functions)
            if hasattr(self.display_name, 'to_dict'):
                props["DisplayName"] = self.display_name.to_dict()
            elif isinstance(self.display_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.display_name
                ]
            else:
                props["DisplayName"] = self.display_name

        if self.iam_role_arn is not None:
            # Serialize iam_role_arn (handle intrinsic functions)
            if hasattr(self.iam_role_arn, 'to_dict'):
                props["IamRoleArn"] = self.iam_role_arn.to_dict()
            elif isinstance(self.iam_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['IamRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iam_role_arn
                ]
            else:
                props["IamRoleArn"] = self.iam_role_arn

        if self.instance_type is not None:
            # Serialize instance_type (handle intrinsic functions)
            if hasattr(self.instance_type, 'to_dict'):
                props["InstanceType"] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props["InstanceType"] = self.instance_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.access_endpoints is not None:
            # Serialize access_endpoints (handle intrinsic functions)
            if hasattr(self.access_endpoints, 'to_dict'):
                props["AccessEndpoints"] = self.access_endpoints.to_dict()
            elif isinstance(self.access_endpoints, list):
                # Serialize list items (may contain intrinsic functions)
                props['AccessEndpoints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.access_endpoints
                ]
            else:
                props["AccessEndpoints"] = self.access_endpoints

        return props

    @property
    def attr_created_time(self) -> GetAtt:
        """Get the CreatedTime attribute."""
        return self.get_att("CreatedTime")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class S3Location:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_bucket is not None:
            if hasattr(self.s3_bucket, 'to_dict'):
                props['S3Bucket'] = self.s3_bucket.to_dict()
            elif isinstance(self.s3_bucket, list):
                props['S3Bucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_bucket
                ]
            else:
                props['S3Bucket'] = self.s3_bucket

        if self.s3_key is not None:
            if hasattr(self.s3_key, 'to_dict'):
                props['S3Key'] = self.s3_key.to_dict()
            elif isinstance(self.s3_key, list):
                props['S3Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_key
                ]
            else:
                props['S3Key'] = self.s3_key

        return props


@dataclass
class Application(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appst"""

    resource_type: ClassVar[str] = "AWS::AppStream::Application"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    working_directory: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    platforms: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    app_block_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_families: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    attributes_to_delete: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_parameters: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    icon_s3_location: Optional[S3Location] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.working_directory is not None:
            # Serialize working_directory (handle intrinsic functions)
            if hasattr(self.working_directory, 'to_dict'):
                props["WorkingDirectory"] = self.working_directory.to_dict()
            elif isinstance(self.working_directory, list):
                # Serialize list items (may contain intrinsic functions)
                props['WorkingDirectory'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.working_directory
                ]
            else:
                props["WorkingDirectory"] = self.working_directory

        if self.platforms is not None:
            # Serialize platforms (handle intrinsic functions)
            if hasattr(self.platforms, 'to_dict'):
                props["Platforms"] = self.platforms.to_dict()
            elif isinstance(self.platforms, list):
                # Serialize list items (may contain intrinsic functions)
                props['Platforms'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.platforms
                ]
            else:
                props["Platforms"] = self.platforms

        if self.app_block_arn is not None:
            # Serialize app_block_arn (handle intrinsic functions)
            if hasattr(self.app_block_arn, 'to_dict'):
                props["AppBlockArn"] = self.app_block_arn.to_dict()
            elif isinstance(self.app_block_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['AppBlockArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_block_arn
                ]
            else:
                props["AppBlockArn"] = self.app_block_arn

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.instance_families is not None:
            # Serialize instance_families (handle intrinsic functions)
            if hasattr(self.instance_families, 'to_dict'):
                props["InstanceFamilies"] = self.instance_families.to_dict()
            elif isinstance(self.instance_families, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceFamilies'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_families
                ]
            else:
                props["InstanceFamilies"] = self.instance_families

        if self.attributes_to_delete is not None:
            # Serialize attributes_to_delete (handle intrinsic functions)
            if hasattr(self.attributes_to_delete, 'to_dict'):
                props["AttributesToDelete"] = self.attributes_to_delete.to_dict()
            elif isinstance(self.attributes_to_delete, list):
                # Serialize list items (may contain intrinsic functions)
                props['AttributesToDelete'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attributes_to_delete
                ]
            else:
                props["AttributesToDelete"] = self.attributes_to_delete

        if self.display_name is not None:
            # Serialize display_name (handle intrinsic functions)
            if hasattr(self.display_name, 'to_dict'):
                props["DisplayName"] = self.display_name.to_dict()
            elif isinstance(self.display_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.display_name
                ]
            else:
                props["DisplayName"] = self.display_name

        if self.launch_path is not None:
            # Serialize launch_path (handle intrinsic functions)
            if hasattr(self.launch_path, 'to_dict'):
                props["LaunchPath"] = self.launch_path.to_dict()
            elif isinstance(self.launch_path, list):
                # Serialize list items (may contain intrinsic functions)
                props['LaunchPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_path
                ]
            else:
                props["LaunchPath"] = self.launch_path

        if self.launch_parameters is not None:
            # Serialize launch_parameters (handle intrinsic functions)
            if hasattr(self.launch_parameters, 'to_dict'):
                props["LaunchParameters"] = self.launch_parameters.to_dict()
            elif isinstance(self.launch_parameters, list):
                # Serialize list items (may contain intrinsic functions)
                props['LaunchParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_parameters
                ]
            else:
                props["LaunchParameters"] = self.launch_parameters

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.icon_s3_location is not None:
            # Serialize icon_s3_location (handle intrinsic functions)
            if hasattr(self.icon_s3_location, 'to_dict'):
                props["IconS3Location"] = self.icon_s3_location.to_dict()
            elif isinstance(self.icon_s3_location, list):
                # Serialize list items (may contain intrinsic functions)
                props['IconS3Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.icon_s3_location
                ]
            else:
                props["IconS3Location"] = self.icon_s3_location

        return props

    @property
    def attr_created_time(self) -> GetAtt:
        """Get the CreatedTime attribute."""
        return self.get_att("CreatedTime")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class ApplicationEntitlementAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appst"""

    resource_type: ClassVar[str] = "AWS::AppStream::ApplicationEntitlementAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    entitlement_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    application_identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    stack_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.entitlement_name is not None:
            # Serialize entitlement_name (handle intrinsic functions)
            if hasattr(self.entitlement_name, 'to_dict'):
                props["EntitlementName"] = self.entitlement_name.to_dict()
            elif isinstance(self.entitlement_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['EntitlementName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.entitlement_name
                ]
            else:
                props["EntitlementName"] = self.entitlement_name

        if self.application_identifier is not None:
            # Serialize application_identifier (handle intrinsic functions)
            if hasattr(self.application_identifier, 'to_dict'):
                props["ApplicationIdentifier"] = self.application_identifier.to_dict()
            elif isinstance(self.application_identifier, list):
                # Serialize list items (may contain intrinsic functions)
                props['ApplicationIdentifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.application_identifier
                ]
            else:
                props["ApplicationIdentifier"] = self.application_identifier

        if self.stack_name is not None:
            # Serialize stack_name (handle intrinsic functions)
            if hasattr(self.stack_name, 'to_dict'):
                props["StackName"] = self.stack_name.to_dict()
            elif isinstance(self.stack_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['StackName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stack_name
                ]
            else:
                props["StackName"] = self.stack_name

        return props



@dataclass
class ApplicationFleetAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appst"""

    resource_type: ClassVar[str] = "AWS::AppStream::ApplicationFleetAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    fleet_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    application_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.fleet_name is not None:
            # Serialize fleet_name (handle intrinsic functions)
            if hasattr(self.fleet_name, 'to_dict'):
                props["FleetName"] = self.fleet_name.to_dict()
            elif isinstance(self.fleet_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['FleetName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fleet_name
                ]
            else:
                props["FleetName"] = self.fleet_name

        if self.application_arn is not None:
            # Serialize application_arn (handle intrinsic functions)
            if hasattr(self.application_arn, 'to_dict'):
                props["ApplicationArn"] = self.application_arn.to_dict()
            elif isinstance(self.application_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ApplicationArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.application_arn
                ]
            else:
                props["ApplicationArn"] = self.application_arn

        return props



@dataclass
class CertificateBasedAuthProperties:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    status: Optional[Union[str, CertificateBasedAuthStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    certificate_authority_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.status is not None:
            if hasattr(self.status, 'to_dict'):
                props['Status'] = self.status.to_dict()
            elif isinstance(self.status, list):
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props['Status'] = self.status

        if self.certificate_authority_arn is not None:
            if hasattr(self.certificate_authority_arn, 'to_dict'):
                props['CertificateAuthorityArn'] = self.certificate_authority_arn.to_dict()
            elif isinstance(self.certificate_authority_arn, list):
                props['CertificateAuthorityArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_authority_arn
                ]
            else:
                props['CertificateAuthorityArn'] = self.certificate_authority_arn

        return props


@dataclass
class ServiceAccountCredentials:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    account_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    account_password: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.account_name is not None:
            if hasattr(self.account_name, 'to_dict'):
                props['AccountName'] = self.account_name.to_dict()
            elif isinstance(self.account_name, list):
                props['AccountName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.account_name
                ]
            else:
                props['AccountName'] = self.account_name

        if self.account_password is not None:
            if hasattr(self.account_password, 'to_dict'):
                props['AccountPassword'] = self.account_password.to_dict()
            elif isinstance(self.account_password, list):
                props['AccountPassword'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.account_password
                ]
            else:
                props['AccountPassword'] = self.account_password

        return props


@dataclass
class DirectoryConfig(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appst"""

    resource_type: ClassVar[str] = "AWS::AppStream::DirectoryConfig"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    organizational_unit_distinguished_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_account_credentials: Optional[ServiceAccountCredentials] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    certificate_based_auth_properties: Optional[CertificateBasedAuthProperties] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    directory_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.organizational_unit_distinguished_names is not None:
            # Serialize organizational_unit_distinguished_names (handle intrinsic functions)
            if hasattr(self.organizational_unit_distinguished_names, 'to_dict'):
                props["OrganizationalUnitDistinguishedNames"] = self.organizational_unit_distinguished_names.to_dict()
            elif isinstance(self.organizational_unit_distinguished_names, list):
                # Serialize list items (may contain intrinsic functions)
                props['OrganizationalUnitDistinguishedNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organizational_unit_distinguished_names
                ]
            else:
                props["OrganizationalUnitDistinguishedNames"] = self.organizational_unit_distinguished_names

        if self.service_account_credentials is not None:
            # Serialize service_account_credentials (handle intrinsic functions)
            if hasattr(self.service_account_credentials, 'to_dict'):
                props["ServiceAccountCredentials"] = self.service_account_credentials.to_dict()
            elif isinstance(self.service_account_credentials, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceAccountCredentials'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_account_credentials
                ]
            else:
                props["ServiceAccountCredentials"] = self.service_account_credentials

        if self.certificate_based_auth_properties is not None:
            # Serialize certificate_based_auth_properties (handle intrinsic functions)
            if hasattr(self.certificate_based_auth_properties, 'to_dict'):
                props["CertificateBasedAuthProperties"] = self.certificate_based_auth_properties.to_dict()
            elif isinstance(self.certificate_based_auth_properties, list):
                # Serialize list items (may contain intrinsic functions)
                props['CertificateBasedAuthProperties'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_based_auth_properties
                ]
            else:
                props["CertificateBasedAuthProperties"] = self.certificate_based_auth_properties

        if self.directory_name is not None:
            # Serialize directory_name (handle intrinsic functions)
            if hasattr(self.directory_name, 'to_dict'):
                props["DirectoryName"] = self.directory_name.to_dict()
            elif isinstance(self.directory_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DirectoryName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.directory_name
                ]
            else:
                props["DirectoryName"] = self.directory_name

        return props



@dataclass
class Attribute:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class Entitlement(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appst"""

    resource_type: ClassVar[str] = "AWS::AppStream::Entitlement"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    app_visibility: Optional[Union[str, AppVisibility, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    attributes: Optional[list[Attribute]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    stack_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.app_visibility is not None:
            # Serialize app_visibility (handle intrinsic functions)
            if hasattr(self.app_visibility, 'to_dict'):
                props["AppVisibility"] = self.app_visibility.to_dict()
            elif isinstance(self.app_visibility, list):
                # Serialize list items (may contain intrinsic functions)
                props['AppVisibility'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_visibility
                ]
            else:
                props["AppVisibility"] = self.app_visibility

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.attributes is not None:
            # Serialize attributes (handle intrinsic functions)
            if hasattr(self.attributes, 'to_dict'):
                props["Attributes"] = self.attributes.to_dict()
            elif isinstance(self.attributes, list):
                # Serialize list items (may contain intrinsic functions)
                props['Attributes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attributes
                ]
            else:
                props["Attributes"] = self.attributes

        if self.stack_name is not None:
            # Serialize stack_name (handle intrinsic functions)
            if hasattr(self.stack_name, 'to_dict'):
                props["StackName"] = self.stack_name.to_dict()
            elif isinstance(self.stack_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['StackName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stack_name
                ]
            else:
                props["StackName"] = self.stack_name

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_created_time(self) -> GetAtt:
        """Get the CreatedTime attribute."""
        return self.get_att("CreatedTime")

    @property
    def attr_last_modified_time(self) -> GetAtt:
        """Get the LastModifiedTime attribute."""
        return self.get_att("LastModifiedTime")




@dataclass
class ComputeCapacity:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    desired_instances: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    desired_sessions: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.desired_instances is not None:
            if hasattr(self.desired_instances, 'to_dict'):
                props['DesiredInstances'] = self.desired_instances.to_dict()
            elif isinstance(self.desired_instances, list):
                props['DesiredInstances'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.desired_instances
                ]
            else:
                props['DesiredInstances'] = self.desired_instances

        if self.desired_sessions is not None:
            if hasattr(self.desired_sessions, 'to_dict'):
                props['DesiredSessions'] = self.desired_sessions.to_dict()
            elif isinstance(self.desired_sessions, list):
                props['DesiredSessions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.desired_sessions
                ]
            else:
                props['DesiredSessions'] = self.desired_sessions

        return props


@dataclass
class DomainJoinInfo:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    organizational_unit_distinguished_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    directory_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.organizational_unit_distinguished_name is not None:
            if hasattr(self.organizational_unit_distinguished_name, 'to_dict'):
                props['OrganizationalUnitDistinguishedName'] = self.organizational_unit_distinguished_name.to_dict()
            elif isinstance(self.organizational_unit_distinguished_name, list):
                props['OrganizationalUnitDistinguishedName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organizational_unit_distinguished_name
                ]
            else:
                props['OrganizationalUnitDistinguishedName'] = self.organizational_unit_distinguished_name

        if self.directory_name is not None:
            if hasattr(self.directory_name, 'to_dict'):
                props['DirectoryName'] = self.directory_name.to_dict()
            elif isinstance(self.directory_name, list):
                props['DirectoryName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.directory_name
                ]
            else:
                props['DirectoryName'] = self.directory_name

        return props


@dataclass
class S3Location:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_bucket is not None:
            if hasattr(self.s3_bucket, 'to_dict'):
                props['S3Bucket'] = self.s3_bucket.to_dict()
            elif isinstance(self.s3_bucket, list):
                props['S3Bucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_bucket
                ]
            else:
                props['S3Bucket'] = self.s3_bucket

        if self.s3_key is not None:
            if hasattr(self.s3_key, 'to_dict'):
                props['S3Key'] = self.s3_key.to_dict()
            elif isinstance(self.s3_key, list):
                props['S3Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_key
                ]
            else:
                props['S3Key'] = self.s3_key

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnet_ids is not None:
            if hasattr(self.subnet_ids, 'to_dict'):
                props['SubnetIds'] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props['SubnetIds'] = self.subnet_ids

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class Fleet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appst"""

    resource_type: ClassVar[str] = "AWS::AppStream::Fleet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    compute_capacity: Optional[ComputeCapacity] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    platform: Optional[Union[str, PlatformType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_config: Optional[VpcConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    fleet_type: Optional[Union[str, FleetType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_default_internet_access: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_join_info: Optional[DomainJoinInfo] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    session_script_s3_location: Optional[S3Location] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    image_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_user_duration_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    idle_disconnect_timeout_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    usb_device_filter_strings: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    disconnect_timeout_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    stream_view: Optional[Union[str, StreamView, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    iam_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_sessions_per_instance: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_concurrent_sessions: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    image_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.compute_capacity is not None:
            # Serialize compute_capacity (handle intrinsic functions)
            if hasattr(self.compute_capacity, 'to_dict'):
                props["ComputeCapacity"] = self.compute_capacity.to_dict()
            elif isinstance(self.compute_capacity, list):
                # Serialize list items (may contain intrinsic functions)
                props['ComputeCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compute_capacity
                ]
            else:
                props["ComputeCapacity"] = self.compute_capacity

        if self.platform is not None:
            # Serialize platform (handle intrinsic functions)
            if hasattr(self.platform, 'to_dict'):
                props["Platform"] = self.platform.to_dict()
            elif isinstance(self.platform, list):
                # Serialize list items (may contain intrinsic functions)
                props['Platform'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.platform
                ]
            else:
                props["Platform"] = self.platform

        if self.vpc_config is not None:
            # Serialize vpc_config (handle intrinsic functions)
            if hasattr(self.vpc_config, 'to_dict'):
                props["VpcConfig"] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props["VpcConfig"] = self.vpc_config

        if self.fleet_type is not None:
            # Serialize fleet_type (handle intrinsic functions)
            if hasattr(self.fleet_type, 'to_dict'):
                props["FleetType"] = self.fleet_type.to_dict()
            elif isinstance(self.fleet_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['FleetType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fleet_type
                ]
            else:
                props["FleetType"] = self.fleet_type

        if self.enable_default_internet_access is not None:
            # Serialize enable_default_internet_access (handle intrinsic functions)
            if hasattr(self.enable_default_internet_access, 'to_dict'):
                props["EnableDefaultInternetAccess"] = self.enable_default_internet_access.to_dict()
            elif isinstance(self.enable_default_internet_access, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableDefaultInternetAccess'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_default_internet_access
                ]
            else:
                props["EnableDefaultInternetAccess"] = self.enable_default_internet_access

        if self.domain_join_info is not None:
            # Serialize domain_join_info (handle intrinsic functions)
            if hasattr(self.domain_join_info, 'to_dict'):
                props["DomainJoinInfo"] = self.domain_join_info.to_dict()
            elif isinstance(self.domain_join_info, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainJoinInfo'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_join_info
                ]
            else:
                props["DomainJoinInfo"] = self.domain_join_info

        if self.session_script_s3_location is not None:
            # Serialize session_script_s3_location (handle intrinsic functions)
            if hasattr(self.session_script_s3_location, 'to_dict'):
                props["SessionScriptS3Location"] = self.session_script_s3_location.to_dict()
            elif isinstance(self.session_script_s3_location, list):
                # Serialize list items (may contain intrinsic functions)
                props['SessionScriptS3Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.session_script_s3_location
                ]
            else:
                props["SessionScriptS3Location"] = self.session_script_s3_location

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.image_name is not None:
            # Serialize image_name (handle intrinsic functions)
            if hasattr(self.image_name, 'to_dict'):
                props["ImageName"] = self.image_name.to_dict()
            elif isinstance(self.image_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ImageName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_name
                ]
            else:
                props["ImageName"] = self.image_name

        if self.max_user_duration_in_seconds is not None:
            # Serialize max_user_duration_in_seconds (handle intrinsic functions)
            if hasattr(self.max_user_duration_in_seconds, 'to_dict'):
                props["MaxUserDurationInSeconds"] = self.max_user_duration_in_seconds.to_dict()
            elif isinstance(self.max_user_duration_in_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxUserDurationInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_user_duration_in_seconds
                ]
            else:
                props["MaxUserDurationInSeconds"] = self.max_user_duration_in_seconds

        if self.idle_disconnect_timeout_in_seconds is not None:
            # Serialize idle_disconnect_timeout_in_seconds (handle intrinsic functions)
            if hasattr(self.idle_disconnect_timeout_in_seconds, 'to_dict'):
                props["IdleDisconnectTimeoutInSeconds"] = self.idle_disconnect_timeout_in_seconds.to_dict()
            elif isinstance(self.idle_disconnect_timeout_in_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['IdleDisconnectTimeoutInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.idle_disconnect_timeout_in_seconds
                ]
            else:
                props["IdleDisconnectTimeoutInSeconds"] = self.idle_disconnect_timeout_in_seconds

        if self.usb_device_filter_strings is not None:
            # Serialize usb_device_filter_strings (handle intrinsic functions)
            if hasattr(self.usb_device_filter_strings, 'to_dict'):
                props["UsbDeviceFilterStrings"] = self.usb_device_filter_strings.to_dict()
            elif isinstance(self.usb_device_filter_strings, list):
                # Serialize list items (may contain intrinsic functions)
                props['UsbDeviceFilterStrings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.usb_device_filter_strings
                ]
            else:
                props["UsbDeviceFilterStrings"] = self.usb_device_filter_strings

        if self.disconnect_timeout_in_seconds is not None:
            # Serialize disconnect_timeout_in_seconds (handle intrinsic functions)
            if hasattr(self.disconnect_timeout_in_seconds, 'to_dict'):
                props["DisconnectTimeoutInSeconds"] = self.disconnect_timeout_in_seconds.to_dict()
            elif isinstance(self.disconnect_timeout_in_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisconnectTimeoutInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disconnect_timeout_in_seconds
                ]
            else:
                props["DisconnectTimeoutInSeconds"] = self.disconnect_timeout_in_seconds

        if self.display_name is not None:
            # Serialize display_name (handle intrinsic functions)
            if hasattr(self.display_name, 'to_dict'):
                props["DisplayName"] = self.display_name.to_dict()
            elif isinstance(self.display_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.display_name
                ]
            else:
                props["DisplayName"] = self.display_name

        if self.stream_view is not None:
            # Serialize stream_view (handle intrinsic functions)
            if hasattr(self.stream_view, 'to_dict'):
                props["StreamView"] = self.stream_view.to_dict()
            elif isinstance(self.stream_view, list):
                # Serialize list items (may contain intrinsic functions)
                props['StreamView'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stream_view
                ]
            else:
                props["StreamView"] = self.stream_view

        if self.iam_role_arn is not None:
            # Serialize iam_role_arn (handle intrinsic functions)
            if hasattr(self.iam_role_arn, 'to_dict'):
                props["IamRoleArn"] = self.iam_role_arn.to_dict()
            elif isinstance(self.iam_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['IamRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iam_role_arn
                ]
            else:
                props["IamRoleArn"] = self.iam_role_arn

        if self.max_sessions_per_instance is not None:
            # Serialize max_sessions_per_instance (handle intrinsic functions)
            if hasattr(self.max_sessions_per_instance, 'to_dict'):
                props["MaxSessionsPerInstance"] = self.max_sessions_per_instance.to_dict()
            elif isinstance(self.max_sessions_per_instance, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxSessionsPerInstance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_sessions_per_instance
                ]
            else:
                props["MaxSessionsPerInstance"] = self.max_sessions_per_instance

        if self.instance_type is not None:
            # Serialize instance_type (handle intrinsic functions)
            if hasattr(self.instance_type, 'to_dict'):
                props["InstanceType"] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props["InstanceType"] = self.instance_type

        if self.max_concurrent_sessions is not None:
            # Serialize max_concurrent_sessions (handle intrinsic functions)
            if hasattr(self.max_concurrent_sessions, 'to_dict'):
                props["MaxConcurrentSessions"] = self.max_concurrent_sessions.to_dict()
            elif isinstance(self.max_concurrent_sessions, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxConcurrentSessions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_concurrent_sessions
                ]
            else:
                props["MaxConcurrentSessions"] = self.max_concurrent_sessions

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.image_arn is not None:
            # Serialize image_arn (handle intrinsic functions)
            if hasattr(self.image_arn, 'to_dict'):
                props["ImageArn"] = self.image_arn.to_dict()
            elif isinstance(self.image_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ImageArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_arn
                ]
            else:
                props["ImageArn"] = self.image_arn

        return props



@dataclass
class AccessEndpoint:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_type: Optional[Union[str, AccessEndpointType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpce_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.endpoint_type is not None:
            if hasattr(self.endpoint_type, 'to_dict'):
                props['EndpointType'] = self.endpoint_type.to_dict()
            elif isinstance(self.endpoint_type, list):
                props['EndpointType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_type
                ]
            else:
                props['EndpointType'] = self.endpoint_type

        if self.vpce_id is not None:
            if hasattr(self.vpce_id, 'to_dict'):
                props['VpceId'] = self.vpce_id.to_dict()
            elif isinstance(self.vpce_id, list):
                props['VpceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpce_id
                ]
            else:
                props['VpceId'] = self.vpce_id

        return props


@dataclass
class DomainJoinInfo:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    organizational_unit_distinguished_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    directory_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.organizational_unit_distinguished_name is not None:
            if hasattr(self.organizational_unit_distinguished_name, 'to_dict'):
                props['OrganizationalUnitDistinguishedName'] = self.organizational_unit_distinguished_name.to_dict()
            elif isinstance(self.organizational_unit_distinguished_name, list):
                props['OrganizationalUnitDistinguishedName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organizational_unit_distinguished_name
                ]
            else:
                props['OrganizationalUnitDistinguishedName'] = self.organizational_unit_distinguished_name

        if self.directory_name is not None:
            if hasattr(self.directory_name, 'to_dict'):
                props['DirectoryName'] = self.directory_name.to_dict()
            elif isinstance(self.directory_name, list):
                props['DirectoryName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.directory_name
                ]
            else:
                props['DirectoryName'] = self.directory_name

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        if self.subnet_ids is not None:
            if hasattr(self.subnet_ids, 'to_dict'):
                props['SubnetIds'] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props['SubnetIds'] = self.subnet_ids

        return props


@dataclass
class ImageBuilder(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appst"""

    resource_type: ClassVar[str] = "AWS::AppStream::ImageBuilder"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_config: Optional[VpcConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_default_internet_access: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_join_info: Optional[DomainJoinInfo] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    appstream_agent_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    image_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    iam_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    image_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    access_endpoints: Optional[list[AccessEndpoint]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.vpc_config is not None:
            # Serialize vpc_config (handle intrinsic functions)
            if hasattr(self.vpc_config, 'to_dict'):
                props["VpcConfig"] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props["VpcConfig"] = self.vpc_config

        if self.enable_default_internet_access is not None:
            # Serialize enable_default_internet_access (handle intrinsic functions)
            if hasattr(self.enable_default_internet_access, 'to_dict'):
                props["EnableDefaultInternetAccess"] = self.enable_default_internet_access.to_dict()
            elif isinstance(self.enable_default_internet_access, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableDefaultInternetAccess'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_default_internet_access
                ]
            else:
                props["EnableDefaultInternetAccess"] = self.enable_default_internet_access

        if self.domain_join_info is not None:
            # Serialize domain_join_info (handle intrinsic functions)
            if hasattr(self.domain_join_info, 'to_dict'):
                props["DomainJoinInfo"] = self.domain_join_info.to_dict()
            elif isinstance(self.domain_join_info, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainJoinInfo'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_join_info
                ]
            else:
                props["DomainJoinInfo"] = self.domain_join_info

        if self.appstream_agent_version is not None:
            # Serialize appstream_agent_version (handle intrinsic functions)
            if hasattr(self.appstream_agent_version, 'to_dict'):
                props["AppstreamAgentVersion"] = self.appstream_agent_version.to_dict()
            elif isinstance(self.appstream_agent_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['AppstreamAgentVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.appstream_agent_version
                ]
            else:
                props["AppstreamAgentVersion"] = self.appstream_agent_version

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.image_name is not None:
            # Serialize image_name (handle intrinsic functions)
            if hasattr(self.image_name, 'to_dict'):
                props["ImageName"] = self.image_name.to_dict()
            elif isinstance(self.image_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ImageName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_name
                ]
            else:
                props["ImageName"] = self.image_name

        if self.display_name is not None:
            # Serialize display_name (handle intrinsic functions)
            if hasattr(self.display_name, 'to_dict'):
                props["DisplayName"] = self.display_name.to_dict()
            elif isinstance(self.display_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.display_name
                ]
            else:
                props["DisplayName"] = self.display_name

        if self.iam_role_arn is not None:
            # Serialize iam_role_arn (handle intrinsic functions)
            if hasattr(self.iam_role_arn, 'to_dict'):
                props["IamRoleArn"] = self.iam_role_arn.to_dict()
            elif isinstance(self.iam_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['IamRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iam_role_arn
                ]
            else:
                props["IamRoleArn"] = self.iam_role_arn

        if self.instance_type is not None:
            # Serialize instance_type (handle intrinsic functions)
            if hasattr(self.instance_type, 'to_dict'):
                props["InstanceType"] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props["InstanceType"] = self.instance_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.image_arn is not None:
            # Serialize image_arn (handle intrinsic functions)
            if hasattr(self.image_arn, 'to_dict'):
                props["ImageArn"] = self.image_arn.to_dict()
            elif isinstance(self.image_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ImageArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_arn
                ]
            else:
                props["ImageArn"] = self.image_arn

        if self.access_endpoints is not None:
            # Serialize access_endpoints (handle intrinsic functions)
            if hasattr(self.access_endpoints, 'to_dict'):
                props["AccessEndpoints"] = self.access_endpoints.to_dict()
            elif isinstance(self.access_endpoints, list):
                # Serialize list items (may contain intrinsic functions)
                props['AccessEndpoints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.access_endpoints
                ]
            else:
                props["AccessEndpoints"] = self.access_endpoints

        return props

    @property
    def attr_streaming_url(self) -> GetAtt:
        """Get the StreamingUrl attribute."""
        return self.get_att("StreamingUrl")




@dataclass
class AccessEndpoint:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_type: Optional[Union[str, AccessEndpointType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpce_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.endpoint_type is not None:
            if hasattr(self.endpoint_type, 'to_dict'):
                props['EndpointType'] = self.endpoint_type.to_dict()
            elif isinstance(self.endpoint_type, list):
                props['EndpointType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_type
                ]
            else:
                props['EndpointType'] = self.endpoint_type

        if self.vpce_id is not None:
            if hasattr(self.vpce_id, 'to_dict'):
                props['VpceId'] = self.vpce_id.to_dict()
            elif isinstance(self.vpce_id, list):
                props['VpceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpce_id
                ]
            else:
                props['VpceId'] = self.vpce_id

        return props


@dataclass
class ApplicationSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    settings_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.settings_group is not None:
            if hasattr(self.settings_group, 'to_dict'):
                props['SettingsGroup'] = self.settings_group.to_dict()
            elif isinstance(self.settings_group, list):
                props['SettingsGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.settings_group
                ]
            else:
                props['SettingsGroup'] = self.settings_group

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class StorageConnector:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    domains: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    connector_type: Optional[Union[str, StorageConnectorType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.domains is not None:
            if hasattr(self.domains, 'to_dict'):
                props['Domains'] = self.domains.to_dict()
            elif isinstance(self.domains, list):
                props['Domains'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domains
                ]
            else:
                props['Domains'] = self.domains

        if self.resource_identifier is not None:
            if hasattr(self.resource_identifier, 'to_dict'):
                props['ResourceIdentifier'] = self.resource_identifier.to_dict()
            elif isinstance(self.resource_identifier, list):
                props['ResourceIdentifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_identifier
                ]
            else:
                props['ResourceIdentifier'] = self.resource_identifier

        if self.connector_type is not None:
            if hasattr(self.connector_type, 'to_dict'):
                props['ConnectorType'] = self.connector_type.to_dict()
            elif isinstance(self.connector_type, list):
                props['ConnectorType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connector_type
                ]
            else:
                props['ConnectorType'] = self.connector_type

        return props


@dataclass
class StreamingExperienceSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    preferred_protocol: Optional[Union[str, PreferredProtocol, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.preferred_protocol is not None:
            if hasattr(self.preferred_protocol, 'to_dict'):
                props['PreferredProtocol'] = self.preferred_protocol.to_dict()
            elif isinstance(self.preferred_protocol, list):
                props['PreferredProtocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.preferred_protocol
                ]
            else:
                props['PreferredProtocol'] = self.preferred_protocol

        return props


@dataclass
class UserSetting:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-app"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    action: Optional[Union[str, Action, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    permission: Optional[Union[str, Permission, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.action is not None:
            if hasattr(self.action, 'to_dict'):
                props['Action'] = self.action.to_dict()
            elif isinstance(self.action, list):
                props['Action'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.action
                ]
            else:
                props['Action'] = self.action

        if self.maximum_length is not None:
            if hasattr(self.maximum_length, 'to_dict'):
                props['MaximumLength'] = self.maximum_length.to_dict()
            elif isinstance(self.maximum_length, list):
                props['MaximumLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_length
                ]
            else:
                props['MaximumLength'] = self.maximum_length

        if self.permission is not None:
            if hasattr(self.permission, 'to_dict'):
                props['Permission'] = self.permission.to_dict()
            elif isinstance(self.permission, list):
                props['Permission'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.permission
                ]
            else:
                props['Permission'] = self.permission

        return props


@dataclass
class Stack(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appst"""

    resource_type: ClassVar[str] = "AWS::AppStream::Stack"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    storage_connectors: Optional[list[StorageConnector]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delete_storage_connectors: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    embed_host_domains: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    user_settings: Optional[list[UserSetting]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    attributes_to_delete: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    redirect_url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    streaming_experience_settings: Optional[StreamingExperienceSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    feedback_url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    application_settings: Optional[ApplicationSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    access_endpoints: Optional[list[AccessEndpoint]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.storage_connectors is not None:
            # Serialize storage_connectors (handle intrinsic functions)
            if hasattr(self.storage_connectors, 'to_dict'):
                props["StorageConnectors"] = self.storage_connectors.to_dict()
            elif isinstance(self.storage_connectors, list):
                # Serialize list items (may contain intrinsic functions)
                props['StorageConnectors'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_connectors
                ]
            else:
                props["StorageConnectors"] = self.storage_connectors

        if self.delete_storage_connectors is not None:
            # Serialize delete_storage_connectors (handle intrinsic functions)
            if hasattr(self.delete_storage_connectors, 'to_dict'):
                props["DeleteStorageConnectors"] = self.delete_storage_connectors.to_dict()
            elif isinstance(self.delete_storage_connectors, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeleteStorageConnectors'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_storage_connectors
                ]
            else:
                props["DeleteStorageConnectors"] = self.delete_storage_connectors

        if self.embed_host_domains is not None:
            # Serialize embed_host_domains (handle intrinsic functions)
            if hasattr(self.embed_host_domains, 'to_dict'):
                props["EmbedHostDomains"] = self.embed_host_domains.to_dict()
            elif isinstance(self.embed_host_domains, list):
                # Serialize list items (may contain intrinsic functions)
                props['EmbedHostDomains'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.embed_host_domains
                ]
            else:
                props["EmbedHostDomains"] = self.embed_host_domains

        if self.user_settings is not None:
            # Serialize user_settings (handle intrinsic functions)
            if hasattr(self.user_settings, 'to_dict'):
                props["UserSettings"] = self.user_settings.to_dict()
            elif isinstance(self.user_settings, list):
                # Serialize list items (may contain intrinsic functions)
                props['UserSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_settings
                ]
            else:
                props["UserSettings"] = self.user_settings

        if self.attributes_to_delete is not None:
            # Serialize attributes_to_delete (handle intrinsic functions)
            if hasattr(self.attributes_to_delete, 'to_dict'):
                props["AttributesToDelete"] = self.attributes_to_delete.to_dict()
            elif isinstance(self.attributes_to_delete, list):
                # Serialize list items (may contain intrinsic functions)
                props['AttributesToDelete'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attributes_to_delete
                ]
            else:
                props["AttributesToDelete"] = self.attributes_to_delete

        if self.redirect_url is not None:
            # Serialize redirect_url (handle intrinsic functions)
            if hasattr(self.redirect_url, 'to_dict'):
                props["RedirectURL"] = self.redirect_url.to_dict()
            elif isinstance(self.redirect_url, list):
                # Serialize list items (may contain intrinsic functions)
                props['RedirectURL'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.redirect_url
                ]
            else:
                props["RedirectURL"] = self.redirect_url

        if self.streaming_experience_settings is not None:
            # Serialize streaming_experience_settings (handle intrinsic functions)
            if hasattr(self.streaming_experience_settings, 'to_dict'):
                props["StreamingExperienceSettings"] = self.streaming_experience_settings.to_dict()
            elif isinstance(self.streaming_experience_settings, list):
                # Serialize list items (may contain intrinsic functions)
                props['StreamingExperienceSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.streaming_experience_settings
                ]
            else:
                props["StreamingExperienceSettings"] = self.streaming_experience_settings

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.feedback_url is not None:
            # Serialize feedback_url (handle intrinsic functions)
            if hasattr(self.feedback_url, 'to_dict'):
                props["FeedbackURL"] = self.feedback_url.to_dict()
            elif isinstance(self.feedback_url, list):
                # Serialize list items (may contain intrinsic functions)
                props['FeedbackURL'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.feedback_url
                ]
            else:
                props["FeedbackURL"] = self.feedback_url

        if self.application_settings is not None:
            # Serialize application_settings (handle intrinsic functions)
            if hasattr(self.application_settings, 'to_dict'):
                props["ApplicationSettings"] = self.application_settings.to_dict()
            elif isinstance(self.application_settings, list):
                # Serialize list items (may contain intrinsic functions)
                props['ApplicationSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.application_settings
                ]
            else:
                props["ApplicationSettings"] = self.application_settings

        if self.display_name is not None:
            # Serialize display_name (handle intrinsic functions)
            if hasattr(self.display_name, 'to_dict'):
                props["DisplayName"] = self.display_name.to_dict()
            elif isinstance(self.display_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.display_name
                ]
            else:
                props["DisplayName"] = self.display_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.access_endpoints is not None:
            # Serialize access_endpoints (handle intrinsic functions)
            if hasattr(self.access_endpoints, 'to_dict'):
                props["AccessEndpoints"] = self.access_endpoints.to_dict()
            elif isinstance(self.access_endpoints, list):
                # Serialize list items (may contain intrinsic functions)
                props['AccessEndpoints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.access_endpoints
                ]
            else:
                props["AccessEndpoints"] = self.access_endpoints

        return props



@dataclass
class StackFleetAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appst"""

    resource_type: ClassVar[str] = "AWS::AppStream::StackFleetAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    fleet_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    stack_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.fleet_name is not None:
            # Serialize fleet_name (handle intrinsic functions)
            if hasattr(self.fleet_name, 'to_dict'):
                props["FleetName"] = self.fleet_name.to_dict()
            elif isinstance(self.fleet_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['FleetName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fleet_name
                ]
            else:
                props["FleetName"] = self.fleet_name

        if self.stack_name is not None:
            # Serialize stack_name (handle intrinsic functions)
            if hasattr(self.stack_name, 'to_dict'):
                props["StackName"] = self.stack_name.to_dict()
            elif isinstance(self.stack_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['StackName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stack_name
                ]
            else:
                props["StackName"] = self.stack_name

        return props



@dataclass
class StackUserAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appst"""

    resource_type: ClassVar[str] = "AWS::AppStream::StackUserAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    send_email_notification: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    user_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    stack_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    authentication_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.send_email_notification is not None:
            # Serialize send_email_notification (handle intrinsic functions)
            if hasattr(self.send_email_notification, 'to_dict'):
                props["SendEmailNotification"] = self.send_email_notification.to_dict()
            elif isinstance(self.send_email_notification, list):
                # Serialize list items (may contain intrinsic functions)
                props['SendEmailNotification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.send_email_notification
                ]
            else:
                props["SendEmailNotification"] = self.send_email_notification

        if self.user_name is not None:
            # Serialize user_name (handle intrinsic functions)
            if hasattr(self.user_name, 'to_dict'):
                props["UserName"] = self.user_name.to_dict()
            elif isinstance(self.user_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['UserName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_name
                ]
            else:
                props["UserName"] = self.user_name

        if self.stack_name is not None:
            # Serialize stack_name (handle intrinsic functions)
            if hasattr(self.stack_name, 'to_dict'):
                props["StackName"] = self.stack_name.to_dict()
            elif isinstance(self.stack_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['StackName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stack_name
                ]
            else:
                props["StackName"] = self.stack_name

        if self.authentication_type is not None:
            # Serialize authentication_type (handle intrinsic functions)
            if hasattr(self.authentication_type, 'to_dict'):
                props["AuthenticationType"] = self.authentication_type.to_dict()
            elif isinstance(self.authentication_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['AuthenticationType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.authentication_type
                ]
            else:
                props["AuthenticationType"] = self.authentication_type

        return props



@dataclass
class User(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-appst"""

    resource_type: ClassVar[str] = "AWS::AppStream::User"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    user_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    first_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    message_action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    last_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    authentication_type: Optional[Union[str, AuthenticationType, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.user_name is not None:
            # Serialize user_name (handle intrinsic functions)
            if hasattr(self.user_name, 'to_dict'):
                props["UserName"] = self.user_name.to_dict()
            elif isinstance(self.user_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['UserName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_name
                ]
            else:
                props["UserName"] = self.user_name

        if self.first_name is not None:
            # Serialize first_name (handle intrinsic functions)
            if hasattr(self.first_name, 'to_dict'):
                props["FirstName"] = self.first_name.to_dict()
            elif isinstance(self.first_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['FirstName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.first_name
                ]
            else:
                props["FirstName"] = self.first_name

        if self.message_action is not None:
            # Serialize message_action (handle intrinsic functions)
            if hasattr(self.message_action, 'to_dict'):
                props["MessageAction"] = self.message_action.to_dict()
            elif isinstance(self.message_action, list):
                # Serialize list items (may contain intrinsic functions)
                props['MessageAction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.message_action
                ]
            else:
                props["MessageAction"] = self.message_action

        if self.last_name is not None:
            # Serialize last_name (handle intrinsic functions)
            if hasattr(self.last_name, 'to_dict'):
                props["LastName"] = self.last_name.to_dict()
            elif isinstance(self.last_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LastName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.last_name
                ]
            else:
                props["LastName"] = self.last_name

        if self.authentication_type is not None:
            # Serialize authentication_type (handle intrinsic functions)
            if hasattr(self.authentication_type, 'to_dict'):
                props["AuthenticationType"] = self.authentication_type.to_dict()
            elif isinstance(self.authentication_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['AuthenticationType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.authentication_type
                ]
            else:
                props["AuthenticationType"] = self.authentication_type

        return props


