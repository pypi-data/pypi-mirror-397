"""
AWS CloudFormation ResilienceHub Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:38

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service ResilienceHub
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AlarmType:
    """AlarmType enum values."""

    METRIC = "Metric"
    COMPOSITE = "Composite"
    CANARY = "Canary"
    LOGS = "Logs"
    EVENT = "Event"


class AppAssessmentScheduleType:
    """AppAssessmentScheduleType enum values."""

    DISABLED = "Disabled"
    DAILY = "Daily"


class AppComplianceStatusType:
    """AppComplianceStatusType enum values."""

    POLICYBREACHED = "PolicyBreached"
    POLICYMET = "PolicyMet"
    NOTASSESSED = "NotAssessed"
    CHANGESDETECTED = "ChangesDetected"
    NOTAPPLICABLE = "NotApplicable"
    MISSINGPOLICY = "MissingPolicy"


class AppDriftStatusType:
    """AppDriftStatusType enum values."""

    NOTCHECKED = "NotChecked"
    NOTDETECTED = "NotDetected"
    DETECTED = "Detected"


class AppStatusType:
    """AppStatusType enum values."""

    ACTIVE = "Active"
    DELETING = "Deleting"


class AssessmentInvoker:
    """AssessmentInvoker enum values."""

    USER = "User"
    SYSTEM = "System"


class AssessmentStatus:
    """AssessmentStatus enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    FAILED = "Failed"
    SUCCESS = "Success"


class ComplianceStatus:
    """ComplianceStatus enum values."""

    POLICYBREACHED = "PolicyBreached"
    POLICYMET = "PolicyMet"
    NOTAPPLICABLE = "NotApplicable"
    MISSINGPOLICY = "MissingPolicy"


class ConditionOperatorType:
    """ConditionOperatorType enum values."""

    EQUALS = "Equals"
    NOTEQUALS = "NotEquals"
    GREATERTHEN = "GreaterThen"
    GREATEROREQUALS = "GreaterOrEquals"
    LESSTHEN = "LessThen"
    LESSOREQUALS = "LessOrEquals"


class ConfigRecommendationOptimizationType:
    """ConfigRecommendationOptimizationType enum values."""

    LEASTCOST = "LeastCost"
    LEASTCHANGE = "LeastChange"
    BESTAZRECOVERY = "BestAZRecovery"
    LEASTERRORS = "LeastErrors"
    BESTATTAINABLE = "BestAttainable"
    BESTREGIONRECOVERY = "BestRegionRecovery"


class CostFrequency:
    """CostFrequency enum values."""

    HOURLY = "Hourly"
    DAILY = "Daily"
    MONTHLY = "Monthly"
    YEARLY = "Yearly"


class DataLocationConstraint:
    """DataLocationConstraint enum values."""

    ANYLOCATION = "AnyLocation"
    SAMECONTINENT = "SameContinent"
    SAMECOUNTRY = "SameCountry"


class DifferenceType:
    """DifferenceType enum values."""

    NOTEQUAL = "NotEqual"
    ADDED = "Added"
    REMOVED = "Removed"


class DisruptionType:
    """DisruptionType enum values."""

    SOFTWARE = "Software"
    HARDWARE = "Hardware"
    AZ = "AZ"
    REGION = "Region"


class DriftStatus:
    """DriftStatus enum values."""

    NOTCHECKED = "NotChecked"
    NOTDETECTED = "NotDetected"
    DETECTED = "Detected"


class DriftType:
    """DriftType enum values."""

    APPLICATIONCOMPLIANCE = "ApplicationCompliance"
    APPCOMPONENTRESILIENCYCOMPLIANCESTATUS = "AppComponentResiliencyComplianceStatus"


class EstimatedCostTier:
    """EstimatedCostTier enum values."""

    L1 = "L1"
    L2 = "L2"
    L3 = "L3"
    L4 = "L4"


class EventType:
    """EventType enum values."""

    SCHEDULEDASSESSMENTFAILURE = "ScheduledAssessmentFailure"
    DRIFTDETECTED = "DriftDetected"


class ExcludeRecommendationReason:
    """ExcludeRecommendationReason enum values."""

    ALREADYIMPLEMENTED = "AlreadyImplemented"
    NOTRELEVANT = "NotRelevant"
    COMPLEXITYOFIMPLEMENTATION = "ComplexityOfImplementation"


class FieldAggregationType:
    """FieldAggregationType enum values."""

    MIN = "Min"
    MAX = "Max"
    SUM = "Sum"
    AVG = "Avg"
    COUNT = "Count"


class GroupingRecommendationConfidenceLevel:
    """GroupingRecommendationConfidenceLevel enum values."""

    HIGH = "High"
    MEDIUM = "Medium"


class GroupingRecommendationRejectionReason:
    """GroupingRecommendationRejectionReason enum values."""

    DISTINCTBUSINESSPURPOSE = "DistinctBusinessPurpose"
    SEPARATEDATACONCERN = "SeparateDataConcern"
    DISTINCTUSERGROUPHANDLING = "DistinctUserGroupHandling"
    OTHER = "Other"


class GroupingRecommendationStatusType:
    """GroupingRecommendationStatusType enum values."""

    ACCEPTED = "Accepted"
    REJECTED = "Rejected"
    PENDINGDECISION = "PendingDecision"


class HaArchitecture:
    """HaArchitecture enum values."""

    MULTISITE = "MultiSite"
    WARMSTANDBY = "WarmStandby"
    PILOTLIGHT = "PilotLight"
    BACKUPANDRESTORE = "BackupAndRestore"
    NORECOVERYPLAN = "NoRecoveryPlan"


class MetricsExportStatusType:
    """MetricsExportStatusType enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    FAILED = "Failed"
    SUCCESS = "Success"


class PermissionModelType:
    """PermissionModelType enum values."""

    LEGACYIAMUSER = "LegacyIAMUser"
    ROLEBASED = "RoleBased"


class PhysicalIdentifierType:
    """PhysicalIdentifierType enum values."""

    ARN = "Arn"
    NATIVE = "Native"


class RecommendationComplianceStatus:
    """RecommendationComplianceStatus enum values."""

    BREACHEDUNATTAINABLE = "BreachedUnattainable"
    BREACHEDCANMEET = "BreachedCanMeet"
    METCANIMPROVE = "MetCanImprove"
    MISSINGPOLICY = "MissingPolicy"


class RecommendationStatus:
    """RecommendationStatus enum values."""

    IMPLEMENTED = "Implemented"
    INACTIVE = "Inactive"
    NOTIMPLEMENTED = "NotImplemented"
    EXCLUDED = "Excluded"


class RecommendationTemplateStatus:
    """RecommendationTemplateStatus enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    FAILED = "Failed"
    SUCCESS = "Success"


class RenderRecommendationType:
    """RenderRecommendationType enum values."""

    ALARM = "Alarm"
    SOP = "Sop"
    TEST = "Test"


class ResiliencyPolicyTier:
    """ResiliencyPolicyTier enum values."""

    MISSIONCRITICAL = "MissionCritical"
    CRITICAL = "Critical"
    IMPORTANT = "Important"
    CORESERVICES = "CoreServices"
    NONCRITICAL = "NonCritical"
    NOTAPPLICABLE = "NotApplicable"


class ResiliencyScoreType:
    """ResiliencyScoreType enum values."""

    COMPLIANCE = "Compliance"
    TEST = "Test"
    ALARM = "Alarm"
    SOP = "Sop"


class ResourceImportStatusType:
    """ResourceImportStatusType enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    FAILED = "Failed"
    SUCCESS = "Success"


class ResourceImportStrategyType:
    """ResourceImportStrategyType enum values."""

    ADDONLY = "AddOnly"
    REPLACEALL = "ReplaceAll"


class ResourceMappingType:
    """ResourceMappingType enum values."""

    CFNSTACK = "CfnStack"
    RESOURCE = "Resource"
    APPREGISTRYAPP = "AppRegistryApp"
    RESOURCEGROUP = "ResourceGroup"
    TERRAFORM = "Terraform"
    EKS = "EKS"


class ResourceResolutionStatusType:
    """ResourceResolutionStatusType enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    FAILED = "Failed"
    SUCCESS = "Success"


class ResourceSourceType:
    """ResourceSourceType enum values."""

    APPTEMPLATE = "AppTemplate"
    DISCOVERED = "Discovered"


class ResourcesGroupingRecGenStatusType:
    """ResourcesGroupingRecGenStatusType enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    FAILED = "Failed"
    SUCCESS = "Success"


class SopServiceType:
    """SopServiceType enum values."""

    SSM = "SSM"


class TemplateFormat:
    """TemplateFormat enum values."""

    CFNYAML = "CfnYaml"
    CFNJSON = "CfnJson"


class TestRisk:
    """TestRisk enum values."""

    SMALL = "Small"
    MEDIUM = "Medium"
    HIGH = "High"


class TestType:
    """TestType enum values."""

    SOFTWARE = "Software"
    HARDWARE = "Hardware"
    AZ = "AZ"
    REGION = "Region"


# Convenient aliases for enum values
METRIC = AlarmType.METRIC
COMPOSITE = AlarmType.COMPOSITE
CANARY = AlarmType.CANARY
LOGS = AlarmType.LOGS
EVENT = AlarmType.EVENT
DISABLED = AppAssessmentScheduleType.DISABLED
DAILY = AppAssessmentScheduleType.DAILY
POLICYBREACHED = AppComplianceStatusType.POLICYBREACHED
POLICYMET = AppComplianceStatusType.POLICYMET
NOTASSESSED = AppComplianceStatusType.NOTASSESSED
CHANGESDETECTED = AppComplianceStatusType.CHANGESDETECTED
NOTAPPLICABLE = AppComplianceStatusType.NOTAPPLICABLE
MISSINGPOLICY = AppComplianceStatusType.MISSINGPOLICY
NOTCHECKED = AppDriftStatusType.NOTCHECKED
NOTDETECTED = AppDriftStatusType.NOTDETECTED
DETECTED = AppDriftStatusType.DETECTED
ACTIVE = AppStatusType.ACTIVE
DELETING = AppStatusType.DELETING
USER = AssessmentInvoker.USER
SYSTEM = AssessmentInvoker.SYSTEM
PENDING = AssessmentStatus.PENDING
INPROGRESS = AssessmentStatus.INPROGRESS
FAILED = AssessmentStatus.FAILED
SUCCESS = AssessmentStatus.SUCCESS
POLICYBREACHED = ComplianceStatus.POLICYBREACHED
POLICYMET = ComplianceStatus.POLICYMET
NOTAPPLICABLE = ComplianceStatus.NOTAPPLICABLE
MISSINGPOLICY = ComplianceStatus.MISSINGPOLICY
EQUALS = ConditionOperatorType.EQUALS
NOTEQUALS = ConditionOperatorType.NOTEQUALS
GREATERTHEN = ConditionOperatorType.GREATERTHEN
GREATEROREQUALS = ConditionOperatorType.GREATEROREQUALS
LESSTHEN = ConditionOperatorType.LESSTHEN
LESSOREQUALS = ConditionOperatorType.LESSOREQUALS
LEASTCOST = ConfigRecommendationOptimizationType.LEASTCOST
LEASTCHANGE = ConfigRecommendationOptimizationType.LEASTCHANGE
BESTAZRECOVERY = ConfigRecommendationOptimizationType.BESTAZRECOVERY
LEASTERRORS = ConfigRecommendationOptimizationType.LEASTERRORS
BESTATTAINABLE = ConfigRecommendationOptimizationType.BESTATTAINABLE
BESTREGIONRECOVERY = ConfigRecommendationOptimizationType.BESTREGIONRECOVERY
HOURLY = CostFrequency.HOURLY
DAILY = CostFrequency.DAILY
MONTHLY = CostFrequency.MONTHLY
YEARLY = CostFrequency.YEARLY
ANYLOCATION = DataLocationConstraint.ANYLOCATION
SAMECONTINENT = DataLocationConstraint.SAMECONTINENT
SAMECOUNTRY = DataLocationConstraint.SAMECOUNTRY
NOTEQUAL = DifferenceType.NOTEQUAL
ADDED = DifferenceType.ADDED
REMOVED = DifferenceType.REMOVED
SOFTWARE = DisruptionType.SOFTWARE
HARDWARE = DisruptionType.HARDWARE
AZ = DisruptionType.AZ
REGION = DisruptionType.REGION
NOTCHECKED = DriftStatus.NOTCHECKED
NOTDETECTED = DriftStatus.NOTDETECTED
DETECTED = DriftStatus.DETECTED
APPLICATIONCOMPLIANCE = DriftType.APPLICATIONCOMPLIANCE
APPCOMPONENTRESILIENCYCOMPLIANCESTATUS = DriftType.APPCOMPONENTRESILIENCYCOMPLIANCESTATUS
L1 = EstimatedCostTier.L1
L2 = EstimatedCostTier.L2
L3 = EstimatedCostTier.L3
L4 = EstimatedCostTier.L4
SCHEDULEDASSESSMENTFAILURE = EventType.SCHEDULEDASSESSMENTFAILURE
DRIFTDETECTED = EventType.DRIFTDETECTED
ALREADYIMPLEMENTED = ExcludeRecommendationReason.ALREADYIMPLEMENTED
NOTRELEVANT = ExcludeRecommendationReason.NOTRELEVANT
COMPLEXITYOFIMPLEMENTATION = ExcludeRecommendationReason.COMPLEXITYOFIMPLEMENTATION
MIN = FieldAggregationType.MIN
MAX = FieldAggregationType.MAX
SUM = FieldAggregationType.SUM
AVG = FieldAggregationType.AVG
COUNT = FieldAggregationType.COUNT
HIGH = GroupingRecommendationConfidenceLevel.HIGH
MEDIUM = GroupingRecommendationConfidenceLevel.MEDIUM
DISTINCTBUSINESSPURPOSE = GroupingRecommendationRejectionReason.DISTINCTBUSINESSPURPOSE
SEPARATEDATACONCERN = GroupingRecommendationRejectionReason.SEPARATEDATACONCERN
DISTINCTUSERGROUPHANDLING = GroupingRecommendationRejectionReason.DISTINCTUSERGROUPHANDLING
OTHER = GroupingRecommendationRejectionReason.OTHER
ACCEPTED = GroupingRecommendationStatusType.ACCEPTED
REJECTED = GroupingRecommendationStatusType.REJECTED
PENDINGDECISION = GroupingRecommendationStatusType.PENDINGDECISION
MULTISITE = HaArchitecture.MULTISITE
WARMSTANDBY = HaArchitecture.WARMSTANDBY
PILOTLIGHT = HaArchitecture.PILOTLIGHT
BACKUPANDRESTORE = HaArchitecture.BACKUPANDRESTORE
NORECOVERYPLAN = HaArchitecture.NORECOVERYPLAN
PENDING = MetricsExportStatusType.PENDING
INPROGRESS = MetricsExportStatusType.INPROGRESS
FAILED = MetricsExportStatusType.FAILED
SUCCESS = MetricsExportStatusType.SUCCESS
LEGACYIAMUSER = PermissionModelType.LEGACYIAMUSER
ROLEBASED = PermissionModelType.ROLEBASED
ARN = PhysicalIdentifierType.ARN
NATIVE = PhysicalIdentifierType.NATIVE
BREACHEDUNATTAINABLE = RecommendationComplianceStatus.BREACHEDUNATTAINABLE
BREACHEDCANMEET = RecommendationComplianceStatus.BREACHEDCANMEET
METCANIMPROVE = RecommendationComplianceStatus.METCANIMPROVE
MISSINGPOLICY = RecommendationComplianceStatus.MISSINGPOLICY
IMPLEMENTED = RecommendationStatus.IMPLEMENTED
INACTIVE = RecommendationStatus.INACTIVE
NOTIMPLEMENTED = RecommendationStatus.NOTIMPLEMENTED
EXCLUDED = RecommendationStatus.EXCLUDED
PENDING = RecommendationTemplateStatus.PENDING
INPROGRESS = RecommendationTemplateStatus.INPROGRESS
FAILED = RecommendationTemplateStatus.FAILED
SUCCESS = RecommendationTemplateStatus.SUCCESS
ALARM = RenderRecommendationType.ALARM
SOP = RenderRecommendationType.SOP
TEST = RenderRecommendationType.TEST
MISSIONCRITICAL = ResiliencyPolicyTier.MISSIONCRITICAL
CRITICAL = ResiliencyPolicyTier.CRITICAL
IMPORTANT = ResiliencyPolicyTier.IMPORTANT
CORESERVICES = ResiliencyPolicyTier.CORESERVICES
NONCRITICAL = ResiliencyPolicyTier.NONCRITICAL
NOTAPPLICABLE = ResiliencyPolicyTier.NOTAPPLICABLE
COMPLIANCE = ResiliencyScoreType.COMPLIANCE
TEST = ResiliencyScoreType.TEST
ALARM = ResiliencyScoreType.ALARM
SOP = ResiliencyScoreType.SOP
PENDING = ResourceImportStatusType.PENDING
INPROGRESS = ResourceImportStatusType.INPROGRESS
FAILED = ResourceImportStatusType.FAILED
SUCCESS = ResourceImportStatusType.SUCCESS
ADDONLY = ResourceImportStrategyType.ADDONLY
REPLACEALL = ResourceImportStrategyType.REPLACEALL
CFNSTACK = ResourceMappingType.CFNSTACK
RESOURCE = ResourceMappingType.RESOURCE
APPREGISTRYAPP = ResourceMappingType.APPREGISTRYAPP
RESOURCEGROUP = ResourceMappingType.RESOURCEGROUP
TERRAFORM = ResourceMappingType.TERRAFORM
EKS = ResourceMappingType.EKS
PENDING = ResourceResolutionStatusType.PENDING
INPROGRESS = ResourceResolutionStatusType.INPROGRESS
FAILED = ResourceResolutionStatusType.FAILED
SUCCESS = ResourceResolutionStatusType.SUCCESS
APPTEMPLATE = ResourceSourceType.APPTEMPLATE
DISCOVERED = ResourceSourceType.DISCOVERED
PENDING = ResourcesGroupingRecGenStatusType.PENDING
INPROGRESS = ResourcesGroupingRecGenStatusType.INPROGRESS
FAILED = ResourcesGroupingRecGenStatusType.FAILED
SUCCESS = ResourcesGroupingRecGenStatusType.SUCCESS
SSM = SopServiceType.SSM
CFNYAML = TemplateFormat.CFNYAML
CFNJSON = TemplateFormat.CFNJSON
SMALL = TestRisk.SMALL
MEDIUM = TestRisk.MEDIUM
HIGH = TestRisk.HIGH
SOFTWARE = TestType.SOFTWARE
HARDWARE = TestType.HARDWARE
AZ = TestType.AZ
REGION = TestType.REGION


@dataclass
class EventSubscription:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-res"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    event_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sns_topic_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.event_type is not None:
            if hasattr(self.event_type, 'to_dict'):
                props['EventType'] = self.event_type.to_dict()
            elif isinstance(self.event_type, list):
                props['EventType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.event_type
                ]
            else:
                props['EventType'] = self.event_type

        if self.sns_topic_arn is not None:
            if hasattr(self.sns_topic_arn, 'to_dict'):
                props['SnsTopicArn'] = self.sns_topic_arn.to_dict()
            elif isinstance(self.sns_topic_arn, list):
                props['SnsTopicArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sns_topic_arn
                ]
            else:
                props['SnsTopicArn'] = self.sns_topic_arn

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class PermissionModel:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-res"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cross_account_role_arns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    invoker_role_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.cross_account_role_arns is not None:
            if hasattr(self.cross_account_role_arns, 'to_dict'):
                props['CrossAccountRoleArns'] = self.cross_account_role_arns.to_dict()
            elif isinstance(self.cross_account_role_arns, list):
                props['CrossAccountRoleArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cross_account_role_arns
                ]
            else:
                props['CrossAccountRoleArns'] = self.cross_account_role_arns

        if self.invoker_role_name is not None:
            if hasattr(self.invoker_role_name, 'to_dict'):
                props['InvokerRoleName'] = self.invoker_role_name.to_dict()
            elif isinstance(self.invoker_role_name, list):
                props['InvokerRoleName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.invoker_role_name
                ]
            else:
                props['InvokerRoleName'] = self.invoker_role_name

        return props


@dataclass
class PhysicalResourceId:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-res"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    aws_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    aws_account_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.identifier is not None:
            if hasattr(self.identifier, 'to_dict'):
                props['Identifier'] = self.identifier.to_dict()
            elif isinstance(self.identifier, list):
                props['Identifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.identifier
                ]
            else:
                props['Identifier'] = self.identifier

        if self.aws_region is not None:
            if hasattr(self.aws_region, 'to_dict'):
                props['AwsRegion'] = self.aws_region.to_dict()
            elif isinstance(self.aws_region, list):
                props['AwsRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.aws_region
                ]
            else:
                props['AwsRegion'] = self.aws_region

        if self.aws_account_id is not None:
            if hasattr(self.aws_account_id, 'to_dict'):
                props['AwsAccountId'] = self.aws_account_id.to_dict()
            elif isinstance(self.aws_account_id, list):
                props['AwsAccountId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.aws_account_id
                ]
            else:
                props['AwsAccountId'] = self.aws_account_id

        return props


@dataclass
class ResourceMapping:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-res"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mapping_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    logical_stack_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    terraform_source_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    physical_resource_id: Optional[PhysicalResourceId] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    eks_source_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mapping_type is not None:
            if hasattr(self.mapping_type, 'to_dict'):
                props['MappingType'] = self.mapping_type.to_dict()
            elif isinstance(self.mapping_type, list):
                props['MappingType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mapping_type
                ]
            else:
                props['MappingType'] = self.mapping_type

        if self.logical_stack_name is not None:
            if hasattr(self.logical_stack_name, 'to_dict'):
                props['LogicalStackName'] = self.logical_stack_name.to_dict()
            elif isinstance(self.logical_stack_name, list):
                props['LogicalStackName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.logical_stack_name
                ]
            else:
                props['LogicalStackName'] = self.logical_stack_name

        if self.resource_name is not None:
            if hasattr(self.resource_name, 'to_dict'):
                props['ResourceName'] = self.resource_name.to_dict()
            elif isinstance(self.resource_name, list):
                props['ResourceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_name
                ]
            else:
                props['ResourceName'] = self.resource_name

        if self.terraform_source_name is not None:
            if hasattr(self.terraform_source_name, 'to_dict'):
                props['TerraformSourceName'] = self.terraform_source_name.to_dict()
            elif isinstance(self.terraform_source_name, list):
                props['TerraformSourceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.terraform_source_name
                ]
            else:
                props['TerraformSourceName'] = self.terraform_source_name

        if self.physical_resource_id is not None:
            if hasattr(self.physical_resource_id, 'to_dict'):
                props['PhysicalResourceId'] = self.physical_resource_id.to_dict()
            elif isinstance(self.physical_resource_id, list):
                props['PhysicalResourceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.physical_resource_id
                ]
            else:
                props['PhysicalResourceId'] = self.physical_resource_id

        if self.eks_source_name is not None:
            if hasattr(self.eks_source_name, 'to_dict'):
                props['EksSourceName'] = self.eks_source_name.to_dict()
            elif isinstance(self.eks_source_name, list):
                props['EksSourceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.eks_source_name
                ]
            else:
                props['EksSourceName'] = self.eks_source_name

        return props


@dataclass
class App(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-resil"""

    resource_type: ClassVar[str] = "AWS::ResilienceHub::App"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    app_template_body: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    app_assessment_schedule: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    permission_model: Optional[PermissionModel] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_mappings: Optional[list[ResourceMapping]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    event_subscriptions: Optional[list[EventSubscription]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resiliency_policy_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.app_template_body is not None:
            # Serialize app_template_body (handle intrinsic functions)
            if hasattr(self.app_template_body, 'to_dict'):
                props["AppTemplateBody"] = self.app_template_body.to_dict()
            elif isinstance(self.app_template_body, list):
                # Serialize list items (may contain intrinsic functions)
                props['AppTemplateBody'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_template_body
                ]
            else:
                props["AppTemplateBody"] = self.app_template_body

        if self.app_assessment_schedule is not None:
            # Serialize app_assessment_schedule (handle intrinsic functions)
            if hasattr(self.app_assessment_schedule, 'to_dict'):
                props["AppAssessmentSchedule"] = self.app_assessment_schedule.to_dict()
            elif isinstance(self.app_assessment_schedule, list):
                # Serialize list items (may contain intrinsic functions)
                props['AppAssessmentSchedule'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_assessment_schedule
                ]
            else:
                props["AppAssessmentSchedule"] = self.app_assessment_schedule

        if self.permission_model is not None:
            # Serialize permission_model (handle intrinsic functions)
            if hasattr(self.permission_model, 'to_dict'):
                props["PermissionModel"] = self.permission_model.to_dict()
            elif isinstance(self.permission_model, list):
                # Serialize list items (may contain intrinsic functions)
                props['PermissionModel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.permission_model
                ]
            else:
                props["PermissionModel"] = self.permission_model

        if self.resource_mappings is not None:
            # Serialize resource_mappings (handle intrinsic functions)
            if hasattr(self.resource_mappings, 'to_dict'):
                props["ResourceMappings"] = self.resource_mappings.to_dict()
            elif isinstance(self.resource_mappings, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceMappings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_mappings
                ]
            else:
                props["ResourceMappings"] = self.resource_mappings

        if self.event_subscriptions is not None:
            # Serialize event_subscriptions (handle intrinsic functions)
            if hasattr(self.event_subscriptions, 'to_dict'):
                props["EventSubscriptions"] = self.event_subscriptions.to_dict()
            elif isinstance(self.event_subscriptions, list):
                # Serialize list items (may contain intrinsic functions)
                props['EventSubscriptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.event_subscriptions
                ]
            else:
                props["EventSubscriptions"] = self.event_subscriptions

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.resiliency_policy_arn is not None:
            # Serialize resiliency_policy_arn (handle intrinsic functions)
            if hasattr(self.resiliency_policy_arn, 'to_dict'):
                props["ResiliencyPolicyArn"] = self.resiliency_policy_arn.to_dict()
            elif isinstance(self.resiliency_policy_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResiliencyPolicyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resiliency_policy_arn
                ]
            else:
                props["ResiliencyPolicyArn"] = self.resiliency_policy_arn

        return props

    @property
    def attr_app_arn(self) -> GetAtt:
        """Get the AppArn attribute."""
        return self.get_att("AppArn")

    @property
    def attr_drift_status(self) -> GetAtt:
        """Get the DriftStatus attribute."""
        return self.get_att("DriftStatus")




@dataclass
class FailurePolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-res"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rpo_in_secs: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rto_in_secs: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.rpo_in_secs is not None:
            if hasattr(self.rpo_in_secs, 'to_dict'):
                props['RpoInSecs'] = self.rpo_in_secs.to_dict()
            elif isinstance(self.rpo_in_secs, list):
                props['RpoInSecs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rpo_in_secs
                ]
            else:
                props['RpoInSecs'] = self.rpo_in_secs

        if self.rto_in_secs is not None:
            if hasattr(self.rto_in_secs, 'to_dict'):
                props['RtoInSecs'] = self.rto_in_secs.to_dict()
            elif isinstance(self.rto_in_secs, list):
                props['RtoInSecs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rto_in_secs
                ]
            else:
                props['RtoInSecs'] = self.rto_in_secs

        return props


@dataclass
class PolicyMap:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-res"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    az: Optional[FailurePolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    region: Optional[FailurePolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hardware: Optional[FailurePolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    software: Optional[FailurePolicy] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.az is not None:
            if hasattr(self.az, 'to_dict'):
                props['AZ'] = self.az.to_dict()
            elif isinstance(self.az, list):
                props['AZ'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.az
                ]
            else:
                props['AZ'] = self.az

        if self.region is not None:
            if hasattr(self.region, 'to_dict'):
                props['Region'] = self.region.to_dict()
            elif isinstance(self.region, list):
                props['Region'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.region
                ]
            else:
                props['Region'] = self.region

        if self.hardware is not None:
            if hasattr(self.hardware, 'to_dict'):
                props['Hardware'] = self.hardware.to_dict()
            elif isinstance(self.hardware, list):
                props['Hardware'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hardware
                ]
            else:
                props['Hardware'] = self.hardware

        if self.software is not None:
            if hasattr(self.software, 'to_dict'):
                props['Software'] = self.software.to_dict()
            elif isinstance(self.software, list):
                props['Software'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.software
                ]
            else:
                props['Software'] = self.software

        return props


@dataclass
class ResiliencyPolicy(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-resil"""

    resource_type: ClassVar[str] = "AWS::ResilienceHub::ResiliencyPolicy"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy: Optional[PolicyMap] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_location_constraint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[dict[str, str]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.policy is not None:
            # Serialize policy (handle intrinsic functions)
            if hasattr(self.policy, 'to_dict'):
                props["Policy"] = self.policy.to_dict()
            elif isinstance(self.policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['Policy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy
                ]
            else:
                props["Policy"] = self.policy

        if self.policy_description is not None:
            # Serialize policy_description (handle intrinsic functions)
            if hasattr(self.policy_description, 'to_dict'):
                props["PolicyDescription"] = self.policy_description.to_dict()
            elif isinstance(self.policy_description, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyDescription'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_description
                ]
            else:
                props["PolicyDescription"] = self.policy_description

        if self.tier is not None:
            # Serialize tier (handle intrinsic functions)
            if hasattr(self.tier, 'to_dict'):
                props["Tier"] = self.tier.to_dict()
            elif isinstance(self.tier, list):
                # Serialize list items (may contain intrinsic functions)
                props['Tier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tier
                ]
            else:
                props["Tier"] = self.tier

        if self.policy_name is not None:
            # Serialize policy_name (handle intrinsic functions)
            if hasattr(self.policy_name, 'to_dict'):
                props["PolicyName"] = self.policy_name.to_dict()
            elif isinstance(self.policy_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_name
                ]
            else:
                props["PolicyName"] = self.policy_name

        if self.data_location_constraint is not None:
            # Serialize data_location_constraint (handle intrinsic functions)
            if hasattr(self.data_location_constraint, 'to_dict'):
                props["DataLocationConstraint"] = self.data_location_constraint.to_dict()
            elif isinstance(self.data_location_constraint, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataLocationConstraint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_location_constraint
                ]
            else:
                props["DataLocationConstraint"] = self.data_location_constraint

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_policy_arn(self) -> GetAtt:
        """Get the PolicyArn attribute."""
        return self.get_att("PolicyArn")



