"""
AWS CloudFormation CodeBuild Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:35

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service CodeBuild
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class ArtifactNamespace:
    """ArtifactNamespace enum values."""

    NONE = "NONE"
    BUILD_ID = "BUILD_ID"


class ArtifactPackaging:
    """ArtifactPackaging enum values."""

    NONE = "NONE"
    ZIP = "ZIP"


class ArtifactsType:
    """ArtifactsType enum values."""

    CODEPIPELINE = "CODEPIPELINE"
    S3 = "S3"
    NO_ARTIFACTS = "NO_ARTIFACTS"


class AuthType:
    """AuthType enum values."""

    OAUTH = "OAUTH"
    BASIC_AUTH = "BASIC_AUTH"
    PERSONAL_ACCESS_TOKEN = "PERSONAL_ACCESS_TOKEN"
    CODECONNECTIONS = "CODECONNECTIONS"
    SECRETS_MANAGER = "SECRETS_MANAGER"


class BatchReportModeType:
    """BatchReportModeType enum values."""

    REPORT_INDIVIDUAL_BUILDS = "REPORT_INDIVIDUAL_BUILDS"
    REPORT_AGGREGATED_BATCH = "REPORT_AGGREGATED_BATCH"


class BucketOwnerAccess:
    """BucketOwnerAccess enum values."""

    NONE = "NONE"
    READ_ONLY = "READ_ONLY"
    FULL = "FULL"


class BuildBatchPhaseType:
    """BuildBatchPhaseType enum values."""

    SUBMITTED = "SUBMITTED"
    DOWNLOAD_BATCHSPEC = "DOWNLOAD_BATCHSPEC"
    IN_PROGRESS = "IN_PROGRESS"
    COMBINE_ARTIFACTS = "COMBINE_ARTIFACTS"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    STOPPED = "STOPPED"


class BuildPhaseType:
    """BuildPhaseType enum values."""

    SUBMITTED = "SUBMITTED"
    QUEUED = "QUEUED"
    PROVISIONING = "PROVISIONING"
    DOWNLOAD_SOURCE = "DOWNLOAD_SOURCE"
    INSTALL = "INSTALL"
    PRE_BUILD = "PRE_BUILD"
    BUILD = "BUILD"
    POST_BUILD = "POST_BUILD"
    UPLOAD_ARTIFACTS = "UPLOAD_ARTIFACTS"
    FINALIZING = "FINALIZING"
    COMPLETED = "COMPLETED"


class CacheMode:
    """CacheMode enum values."""

    LOCAL_DOCKER_LAYER_CACHE = "LOCAL_DOCKER_LAYER_CACHE"
    LOCAL_SOURCE_CACHE = "LOCAL_SOURCE_CACHE"
    LOCAL_CUSTOM_CACHE = "LOCAL_CUSTOM_CACHE"


class CacheType:
    """CacheType enum values."""

    NO_CACHE = "NO_CACHE"
    S3 = "S3"
    LOCAL = "LOCAL"


class CommandType:
    """CommandType enum values."""

    SHELL = "SHELL"


class ComputeType:
    """ComputeType enum values."""

    BUILD_GENERAL1_SMALL = "BUILD_GENERAL1_SMALL"
    BUILD_GENERAL1_MEDIUM = "BUILD_GENERAL1_MEDIUM"
    BUILD_GENERAL1_LARGE = "BUILD_GENERAL1_LARGE"
    BUILD_GENERAL1_XLARGE = "BUILD_GENERAL1_XLARGE"
    BUILD_GENERAL1_2XLARGE = "BUILD_GENERAL1_2XLARGE"
    BUILD_LAMBDA_1GB = "BUILD_LAMBDA_1GB"
    BUILD_LAMBDA_2GB = "BUILD_LAMBDA_2GB"
    BUILD_LAMBDA_4GB = "BUILD_LAMBDA_4GB"
    BUILD_LAMBDA_8GB = "BUILD_LAMBDA_8GB"
    BUILD_LAMBDA_10GB = "BUILD_LAMBDA_10GB"
    ATTRIBUTE_BASED_COMPUTE = "ATTRIBUTE_BASED_COMPUTE"
    CUSTOM_INSTANCE_TYPE = "CUSTOM_INSTANCE_TYPE"


class CredentialProviderType:
    """CredentialProviderType enum values."""

    SECRETS_MANAGER = "SECRETS_MANAGER"


class EnvironmentType:
    """EnvironmentType enum values."""

    WINDOWS_CONTAINER = "WINDOWS_CONTAINER"
    LINUX_CONTAINER = "LINUX_CONTAINER"
    LINUX_GPU_CONTAINER = "LINUX_GPU_CONTAINER"
    ARM_CONTAINER = "ARM_CONTAINER"
    WINDOWS_SERVER_2019_CONTAINER = "WINDOWS_SERVER_2019_CONTAINER"
    WINDOWS_SERVER_2022_CONTAINER = "WINDOWS_SERVER_2022_CONTAINER"
    LINUX_LAMBDA_CONTAINER = "LINUX_LAMBDA_CONTAINER"
    ARM_LAMBDA_CONTAINER = "ARM_LAMBDA_CONTAINER"
    LINUX_EC2 = "LINUX_EC2"
    ARM_EC2 = "ARM_EC2"
    WINDOWS_EC2 = "WINDOWS_EC2"
    MAC_ARM = "MAC_ARM"


class EnvironmentVariableType:
    """EnvironmentVariableType enum values."""

    PLAINTEXT = "PLAINTEXT"
    PARAMETER_STORE = "PARAMETER_STORE"
    SECRETS_MANAGER = "SECRETS_MANAGER"


class FileSystemType:
    """FileSystemType enum values."""

    EFS = "EFS"


class FleetContextCode:
    """FleetContextCode enum values."""

    CREATE_FAILED = "CREATE_FAILED"
    UPDATE_FAILED = "UPDATE_FAILED"
    ACTION_REQUIRED = "ACTION_REQUIRED"
    PENDING_DELETION = "PENDING_DELETION"
    INSUFFICIENT_CAPACITY = "INSUFFICIENT_CAPACITY"


class FleetOverflowBehavior:
    """FleetOverflowBehavior enum values."""

    QUEUE = "QUEUE"
    ON_DEMAND = "ON_DEMAND"


class FleetProxyRuleBehavior:
    """FleetProxyRuleBehavior enum values."""

    ALLOW_ALL = "ALLOW_ALL"
    DENY_ALL = "DENY_ALL"


class FleetProxyRuleEffectType:
    """FleetProxyRuleEffectType enum values."""

    ALLOW = "ALLOW"
    DENY = "DENY"


class FleetProxyRuleType:
    """FleetProxyRuleType enum values."""

    DOMAIN = "DOMAIN"
    IP = "IP"


class FleetScalingMetricType:
    """FleetScalingMetricType enum values."""

    FLEET_UTILIZATION_RATE = "FLEET_UTILIZATION_RATE"


class FleetScalingType:
    """FleetScalingType enum values."""

    TARGET_TRACKING_SCALING = "TARGET_TRACKING_SCALING"


class FleetSortByType:
    """FleetSortByType enum values."""

    NAME = "NAME"
    CREATED_TIME = "CREATED_TIME"
    LAST_MODIFIED_TIME = "LAST_MODIFIED_TIME"


class FleetStatusCode:
    """FleetStatusCode enum values."""

    CREATING = "CREATING"
    UPDATING = "UPDATING"
    ROTATING = "ROTATING"
    PENDING_DELETION = "PENDING_DELETION"
    DELETING = "DELETING"
    CREATE_FAILED = "CREATE_FAILED"
    UPDATE_ROLLBACK_FAILED = "UPDATE_ROLLBACK_FAILED"
    ACTIVE = "ACTIVE"


class ImagePullCredentialsType:
    """ImagePullCredentialsType enum values."""

    CODEBUILD = "CODEBUILD"
    SERVICE_ROLE = "SERVICE_ROLE"


class LanguageType:
    """LanguageType enum values."""

    JAVA = "JAVA"
    PYTHON = "PYTHON"
    NODE_JS = "NODE_JS"
    RUBY = "RUBY"
    GOLANG = "GOLANG"
    DOCKER = "DOCKER"
    ANDROID = "ANDROID"
    DOTNET = "DOTNET"
    BASE = "BASE"
    PHP = "PHP"


class LogsConfigStatusType:
    """LogsConfigStatusType enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class MachineType:
    """MachineType enum values."""

    GENERAL = "GENERAL"
    NVME = "NVME"


class PlatformType:
    """PlatformType enum values."""

    DEBIAN = "DEBIAN"
    AMAZON_LINUX = "AMAZON_LINUX"
    UBUNTU = "UBUNTU"
    WINDOWS_SERVER = "WINDOWS_SERVER"


class ProjectSortByType:
    """ProjectSortByType enum values."""

    NAME = "NAME"
    CREATED_TIME = "CREATED_TIME"
    LAST_MODIFIED_TIME = "LAST_MODIFIED_TIME"


class ProjectVisibilityType:
    """ProjectVisibilityType enum values."""

    PUBLIC_READ = "PUBLIC_READ"
    PRIVATE = "PRIVATE"


class PullRequestBuildApproverRole:
    """PullRequestBuildApproverRole enum values."""

    GITHUB_READ = "GITHUB_READ"
    GITHUB_TRIAGE = "GITHUB_TRIAGE"
    GITHUB_WRITE = "GITHUB_WRITE"
    GITHUB_MAINTAIN = "GITHUB_MAINTAIN"
    GITHUB_ADMIN = "GITHUB_ADMIN"
    GITLAB_GUEST = "GITLAB_GUEST"
    GITLAB_PLANNER = "GITLAB_PLANNER"
    GITLAB_REPORTER = "GITLAB_REPORTER"
    GITLAB_DEVELOPER = "GITLAB_DEVELOPER"
    GITLAB_MAINTAINER = "GITLAB_MAINTAINER"
    GITLAB_OWNER = "GITLAB_OWNER"
    BITBUCKET_READ = "BITBUCKET_READ"
    BITBUCKET_WRITE = "BITBUCKET_WRITE"
    BITBUCKET_ADMIN = "BITBUCKET_ADMIN"


class PullRequestBuildCommentApproval:
    """PullRequestBuildCommentApproval enum values."""

    DISABLED = "DISABLED"
    ALL_PULL_REQUESTS = "ALL_PULL_REQUESTS"
    FORK_PULL_REQUESTS = "FORK_PULL_REQUESTS"


class ReportCodeCoverageSortByType:
    """ReportCodeCoverageSortByType enum values."""

    LINE_COVERAGE_PERCENTAGE = "LINE_COVERAGE_PERCENTAGE"
    FILE_PATH = "FILE_PATH"


class ReportExportConfigType:
    """ReportExportConfigType enum values."""

    S3 = "S3"
    NO_EXPORT = "NO_EXPORT"


class ReportGroupSortByType:
    """ReportGroupSortByType enum values."""

    NAME = "NAME"
    CREATED_TIME = "CREATED_TIME"
    LAST_MODIFIED_TIME = "LAST_MODIFIED_TIME"


class ReportGroupStatusType:
    """ReportGroupStatusType enum values."""

    ACTIVE = "ACTIVE"
    DELETING = "DELETING"


class ReportGroupTrendFieldType:
    """ReportGroupTrendFieldType enum values."""

    PASS_RATE = "PASS_RATE"
    DURATION = "DURATION"
    TOTAL = "TOTAL"
    LINE_COVERAGE = "LINE_COVERAGE"
    LINES_COVERED = "LINES_COVERED"
    LINES_MISSED = "LINES_MISSED"
    BRANCH_COVERAGE = "BRANCH_COVERAGE"
    BRANCHES_COVERED = "BRANCHES_COVERED"
    BRANCHES_MISSED = "BRANCHES_MISSED"


class ReportPackagingType:
    """ReportPackagingType enum values."""

    ZIP = "ZIP"
    NONE = "NONE"


class ReportStatusType:
    """ReportStatusType enum values."""

    GENERATING = "GENERATING"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    INCOMPLETE = "INCOMPLETE"
    DELETING = "DELETING"


class ReportType:
    """ReportType enum values."""

    TEST = "TEST"
    CODE_COVERAGE = "CODE_COVERAGE"


class RetryBuildBatchType:
    """RetryBuildBatchType enum values."""

    RETRY_ALL_BUILDS = "RETRY_ALL_BUILDS"
    RETRY_FAILED_BUILDS = "RETRY_FAILED_BUILDS"


class ServerType:
    """ServerType enum values."""

    GITHUB = "GITHUB"
    BITBUCKET = "BITBUCKET"
    GITHUB_ENTERPRISE = "GITHUB_ENTERPRISE"
    GITLAB = "GITLAB"
    GITLAB_SELF_MANAGED = "GITLAB_SELF_MANAGED"


class SharedResourceSortByType:
    """SharedResourceSortByType enum values."""

    ARN = "ARN"
    MODIFIED_TIME = "MODIFIED_TIME"


class SortOrderType:
    """SortOrderType enum values."""

    ASCENDING = "ASCENDING"
    DESCENDING = "DESCENDING"


class SourceAuthType:
    """SourceAuthType enum values."""

    OAUTH = "OAUTH"
    CODECONNECTIONS = "CODECONNECTIONS"
    SECRETS_MANAGER = "SECRETS_MANAGER"


class SourceType:
    """SourceType enum values."""

    CODECOMMIT = "CODECOMMIT"
    CODEPIPELINE = "CODEPIPELINE"
    GITHUB = "GITHUB"
    GITLAB = "GITLAB"
    GITLAB_SELF_MANAGED = "GITLAB_SELF_MANAGED"
    S3 = "S3"
    BITBUCKET = "BITBUCKET"
    GITHUB_ENTERPRISE = "GITHUB_ENTERPRISE"
    NO_SOURCE = "NO_SOURCE"


class StatusType:
    """StatusType enum values."""

    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    FAULT = "FAULT"
    TIMED_OUT = "TIMED_OUT"
    IN_PROGRESS = "IN_PROGRESS"
    STOPPED = "STOPPED"


class WebhookBuildType:
    """WebhookBuildType enum values."""

    BUILD = "BUILD"
    BUILD_BATCH = "BUILD_BATCH"
    RUNNER_BUILDKITE_BUILD = "RUNNER_BUILDKITE_BUILD"


class WebhookFilterType:
    """WebhookFilterType enum values."""

    EVENT = "EVENT"
    BASE_REF = "BASE_REF"
    HEAD_REF = "HEAD_REF"
    ACTOR_ACCOUNT_ID = "ACTOR_ACCOUNT_ID"
    FILE_PATH = "FILE_PATH"
    COMMIT_MESSAGE = "COMMIT_MESSAGE"
    WORKFLOW_NAME = "WORKFLOW_NAME"
    TAG_NAME = "TAG_NAME"
    RELEASE_NAME = "RELEASE_NAME"
    REPOSITORY_NAME = "REPOSITORY_NAME"
    ORGANIZATION_NAME = "ORGANIZATION_NAME"


class WebhookScopeType:
    """WebhookScopeType enum values."""

    GITHUB_ORGANIZATION = "GITHUB_ORGANIZATION"
    GITHUB_GLOBAL = "GITHUB_GLOBAL"
    GITLAB_GROUP = "GITLAB_GROUP"


class WebhookStatus:
    """WebhookStatus enum values."""

    CREATING = "CREATING"
    CREATE_FAILED = "CREATE_FAILED"
    ACTIVE = "ACTIVE"
    DELETING = "DELETING"


# Convenient aliases for enum values
NONE = ArtifactNamespace.NONE
BUILD_ID = ArtifactNamespace.BUILD_ID
NONE = ArtifactPackaging.NONE
ZIP = ArtifactPackaging.ZIP
CODEPIPELINE = ArtifactsType.CODEPIPELINE
S3 = ArtifactsType.S3
NO_ARTIFACTS = ArtifactsType.NO_ARTIFACTS
OAUTH = AuthType.OAUTH
BASIC_AUTH = AuthType.BASIC_AUTH
PERSONAL_ACCESS_TOKEN = AuthType.PERSONAL_ACCESS_TOKEN
CODECONNECTIONS = AuthType.CODECONNECTIONS
SECRETS_MANAGER = AuthType.SECRETS_MANAGER
REPORT_INDIVIDUAL_BUILDS = BatchReportModeType.REPORT_INDIVIDUAL_BUILDS
REPORT_AGGREGATED_BATCH = BatchReportModeType.REPORT_AGGREGATED_BATCH
NONE = BucketOwnerAccess.NONE
READ_ONLY = BucketOwnerAccess.READ_ONLY
FULL = BucketOwnerAccess.FULL
SUBMITTED = BuildBatchPhaseType.SUBMITTED
DOWNLOAD_BATCHSPEC = BuildBatchPhaseType.DOWNLOAD_BATCHSPEC
IN_PROGRESS = BuildBatchPhaseType.IN_PROGRESS
COMBINE_ARTIFACTS = BuildBatchPhaseType.COMBINE_ARTIFACTS
SUCCEEDED = BuildBatchPhaseType.SUCCEEDED
FAILED = BuildBatchPhaseType.FAILED
STOPPED = BuildBatchPhaseType.STOPPED
SUBMITTED = BuildPhaseType.SUBMITTED
QUEUED = BuildPhaseType.QUEUED
PROVISIONING = BuildPhaseType.PROVISIONING
DOWNLOAD_SOURCE = BuildPhaseType.DOWNLOAD_SOURCE
INSTALL = BuildPhaseType.INSTALL
PRE_BUILD = BuildPhaseType.PRE_BUILD
BUILD = BuildPhaseType.BUILD
POST_BUILD = BuildPhaseType.POST_BUILD
UPLOAD_ARTIFACTS = BuildPhaseType.UPLOAD_ARTIFACTS
FINALIZING = BuildPhaseType.FINALIZING
COMPLETED = BuildPhaseType.COMPLETED
LOCAL_DOCKER_LAYER_CACHE = CacheMode.LOCAL_DOCKER_LAYER_CACHE
LOCAL_SOURCE_CACHE = CacheMode.LOCAL_SOURCE_CACHE
LOCAL_CUSTOM_CACHE = CacheMode.LOCAL_CUSTOM_CACHE
NO_CACHE = CacheType.NO_CACHE
S3 = CacheType.S3
LOCAL = CacheType.LOCAL
SHELL = CommandType.SHELL
BUILD_GENERAL1_SMALL = ComputeType.BUILD_GENERAL1_SMALL
BUILD_GENERAL1_MEDIUM = ComputeType.BUILD_GENERAL1_MEDIUM
BUILD_GENERAL1_LARGE = ComputeType.BUILD_GENERAL1_LARGE
BUILD_GENERAL1_XLARGE = ComputeType.BUILD_GENERAL1_XLARGE
BUILD_GENERAL1_2XLARGE = ComputeType.BUILD_GENERAL1_2XLARGE
BUILD_LAMBDA_1GB = ComputeType.BUILD_LAMBDA_1GB
BUILD_LAMBDA_2GB = ComputeType.BUILD_LAMBDA_2GB
BUILD_LAMBDA_4GB = ComputeType.BUILD_LAMBDA_4GB
BUILD_LAMBDA_8GB = ComputeType.BUILD_LAMBDA_8GB
BUILD_LAMBDA_10GB = ComputeType.BUILD_LAMBDA_10GB
ATTRIBUTE_BASED_COMPUTE = ComputeType.ATTRIBUTE_BASED_COMPUTE
CUSTOM_INSTANCE_TYPE = ComputeType.CUSTOM_INSTANCE_TYPE
SECRETS_MANAGER = CredentialProviderType.SECRETS_MANAGER
WINDOWS_CONTAINER = EnvironmentType.WINDOWS_CONTAINER
LINUX_CONTAINER = EnvironmentType.LINUX_CONTAINER
LINUX_GPU_CONTAINER = EnvironmentType.LINUX_GPU_CONTAINER
ARM_CONTAINER = EnvironmentType.ARM_CONTAINER
WINDOWS_SERVER_2019_CONTAINER = EnvironmentType.WINDOWS_SERVER_2019_CONTAINER
WINDOWS_SERVER_2022_CONTAINER = EnvironmentType.WINDOWS_SERVER_2022_CONTAINER
LINUX_LAMBDA_CONTAINER = EnvironmentType.LINUX_LAMBDA_CONTAINER
ARM_LAMBDA_CONTAINER = EnvironmentType.ARM_LAMBDA_CONTAINER
LINUX_EC2 = EnvironmentType.LINUX_EC2
ARM_EC2 = EnvironmentType.ARM_EC2
WINDOWS_EC2 = EnvironmentType.WINDOWS_EC2
MAC_ARM = EnvironmentType.MAC_ARM
PLAINTEXT = EnvironmentVariableType.PLAINTEXT
PARAMETER_STORE = EnvironmentVariableType.PARAMETER_STORE
SECRETS_MANAGER = EnvironmentVariableType.SECRETS_MANAGER
EFS = FileSystemType.EFS
CREATE_FAILED = FleetContextCode.CREATE_FAILED
UPDATE_FAILED = FleetContextCode.UPDATE_FAILED
ACTION_REQUIRED = FleetContextCode.ACTION_REQUIRED
PENDING_DELETION = FleetContextCode.PENDING_DELETION
INSUFFICIENT_CAPACITY = FleetContextCode.INSUFFICIENT_CAPACITY
QUEUE = FleetOverflowBehavior.QUEUE
ON_DEMAND = FleetOverflowBehavior.ON_DEMAND
ALLOW_ALL = FleetProxyRuleBehavior.ALLOW_ALL
DENY_ALL = FleetProxyRuleBehavior.DENY_ALL
ALLOW = FleetProxyRuleEffectType.ALLOW
DENY = FleetProxyRuleEffectType.DENY
DOMAIN = FleetProxyRuleType.DOMAIN
IP = FleetProxyRuleType.IP
FLEET_UTILIZATION_RATE = FleetScalingMetricType.FLEET_UTILIZATION_RATE
TARGET_TRACKING_SCALING = FleetScalingType.TARGET_TRACKING_SCALING
NAME = FleetSortByType.NAME
CREATED_TIME = FleetSortByType.CREATED_TIME
LAST_MODIFIED_TIME = FleetSortByType.LAST_MODIFIED_TIME
CREATING = FleetStatusCode.CREATING
UPDATING = FleetStatusCode.UPDATING
ROTATING = FleetStatusCode.ROTATING
PENDING_DELETION = FleetStatusCode.PENDING_DELETION
DELETING = FleetStatusCode.DELETING
CREATE_FAILED = FleetStatusCode.CREATE_FAILED
UPDATE_ROLLBACK_FAILED = FleetStatusCode.UPDATE_ROLLBACK_FAILED
ACTIVE = FleetStatusCode.ACTIVE
CODEBUILD = ImagePullCredentialsType.CODEBUILD
SERVICE_ROLE = ImagePullCredentialsType.SERVICE_ROLE
JAVA = LanguageType.JAVA
PYTHON = LanguageType.PYTHON
NODE_JS = LanguageType.NODE_JS
RUBY = LanguageType.RUBY
GOLANG = LanguageType.GOLANG
DOCKER = LanguageType.DOCKER
ANDROID = LanguageType.ANDROID
DOTNET = LanguageType.DOTNET
BASE = LanguageType.BASE
PHP = LanguageType.PHP
ENABLED = LogsConfigStatusType.ENABLED
DISABLED = LogsConfigStatusType.DISABLED
GENERAL = MachineType.GENERAL
NVME = MachineType.NVME
DEBIAN = PlatformType.DEBIAN
AMAZON_LINUX = PlatformType.AMAZON_LINUX
UBUNTU = PlatformType.UBUNTU
WINDOWS_SERVER = PlatformType.WINDOWS_SERVER
NAME = ProjectSortByType.NAME
CREATED_TIME = ProjectSortByType.CREATED_TIME
LAST_MODIFIED_TIME = ProjectSortByType.LAST_MODIFIED_TIME
PUBLIC_READ = ProjectVisibilityType.PUBLIC_READ
PRIVATE = ProjectVisibilityType.PRIVATE
GITHUB_READ = PullRequestBuildApproverRole.GITHUB_READ
GITHUB_TRIAGE = PullRequestBuildApproverRole.GITHUB_TRIAGE
GITHUB_WRITE = PullRequestBuildApproverRole.GITHUB_WRITE
GITHUB_MAINTAIN = PullRequestBuildApproverRole.GITHUB_MAINTAIN
GITHUB_ADMIN = PullRequestBuildApproverRole.GITHUB_ADMIN
GITLAB_GUEST = PullRequestBuildApproverRole.GITLAB_GUEST
GITLAB_PLANNER = PullRequestBuildApproverRole.GITLAB_PLANNER
GITLAB_REPORTER = PullRequestBuildApproverRole.GITLAB_REPORTER
GITLAB_DEVELOPER = PullRequestBuildApproverRole.GITLAB_DEVELOPER
GITLAB_MAINTAINER = PullRequestBuildApproverRole.GITLAB_MAINTAINER
GITLAB_OWNER = PullRequestBuildApproverRole.GITLAB_OWNER
BITBUCKET_READ = PullRequestBuildApproverRole.BITBUCKET_READ
BITBUCKET_WRITE = PullRequestBuildApproverRole.BITBUCKET_WRITE
BITBUCKET_ADMIN = PullRequestBuildApproverRole.BITBUCKET_ADMIN
DISABLED = PullRequestBuildCommentApproval.DISABLED
ALL_PULL_REQUESTS = PullRequestBuildCommentApproval.ALL_PULL_REQUESTS
FORK_PULL_REQUESTS = PullRequestBuildCommentApproval.FORK_PULL_REQUESTS
LINE_COVERAGE_PERCENTAGE = ReportCodeCoverageSortByType.LINE_COVERAGE_PERCENTAGE
FILE_PATH = ReportCodeCoverageSortByType.FILE_PATH
S3 = ReportExportConfigType.S3
NO_EXPORT = ReportExportConfigType.NO_EXPORT
NAME = ReportGroupSortByType.NAME
CREATED_TIME = ReportGroupSortByType.CREATED_TIME
LAST_MODIFIED_TIME = ReportGroupSortByType.LAST_MODIFIED_TIME
ACTIVE = ReportGroupStatusType.ACTIVE
DELETING = ReportGroupStatusType.DELETING
PASS_RATE = ReportGroupTrendFieldType.PASS_RATE
DURATION = ReportGroupTrendFieldType.DURATION
TOTAL = ReportGroupTrendFieldType.TOTAL
LINE_COVERAGE = ReportGroupTrendFieldType.LINE_COVERAGE
LINES_COVERED = ReportGroupTrendFieldType.LINES_COVERED
LINES_MISSED = ReportGroupTrendFieldType.LINES_MISSED
BRANCH_COVERAGE = ReportGroupTrendFieldType.BRANCH_COVERAGE
BRANCHES_COVERED = ReportGroupTrendFieldType.BRANCHES_COVERED
BRANCHES_MISSED = ReportGroupTrendFieldType.BRANCHES_MISSED
ZIP = ReportPackagingType.ZIP
NONE = ReportPackagingType.NONE
GENERATING = ReportStatusType.GENERATING
SUCCEEDED = ReportStatusType.SUCCEEDED
FAILED = ReportStatusType.FAILED
INCOMPLETE = ReportStatusType.INCOMPLETE
DELETING = ReportStatusType.DELETING
TEST = ReportType.TEST
CODE_COVERAGE = ReportType.CODE_COVERAGE
RETRY_ALL_BUILDS = RetryBuildBatchType.RETRY_ALL_BUILDS
RETRY_FAILED_BUILDS = RetryBuildBatchType.RETRY_FAILED_BUILDS
GITHUB = ServerType.GITHUB
BITBUCKET = ServerType.BITBUCKET
GITHUB_ENTERPRISE = ServerType.GITHUB_ENTERPRISE
GITLAB = ServerType.GITLAB
GITLAB_SELF_MANAGED = ServerType.GITLAB_SELF_MANAGED
ARN = SharedResourceSortByType.ARN
MODIFIED_TIME = SharedResourceSortByType.MODIFIED_TIME
ASCENDING = SortOrderType.ASCENDING
DESCENDING = SortOrderType.DESCENDING
OAUTH = SourceAuthType.OAUTH
CODECONNECTIONS = SourceAuthType.CODECONNECTIONS
SECRETS_MANAGER = SourceAuthType.SECRETS_MANAGER
CODECOMMIT = SourceType.CODECOMMIT
CODEPIPELINE = SourceType.CODEPIPELINE
GITHUB = SourceType.GITHUB
GITLAB = SourceType.GITLAB
GITLAB_SELF_MANAGED = SourceType.GITLAB_SELF_MANAGED
S3 = SourceType.S3
BITBUCKET = SourceType.BITBUCKET
GITHUB_ENTERPRISE = SourceType.GITHUB_ENTERPRISE
NO_SOURCE = SourceType.NO_SOURCE
SUCCEEDED = StatusType.SUCCEEDED
FAILED = StatusType.FAILED
FAULT = StatusType.FAULT
TIMED_OUT = StatusType.TIMED_OUT
IN_PROGRESS = StatusType.IN_PROGRESS
STOPPED = StatusType.STOPPED
BUILD = WebhookBuildType.BUILD
BUILD_BATCH = WebhookBuildType.BUILD_BATCH
RUNNER_BUILDKITE_BUILD = WebhookBuildType.RUNNER_BUILDKITE_BUILD
EVENT = WebhookFilterType.EVENT
BASE_REF = WebhookFilterType.BASE_REF
HEAD_REF = WebhookFilterType.HEAD_REF
ACTOR_ACCOUNT_ID = WebhookFilterType.ACTOR_ACCOUNT_ID
FILE_PATH = WebhookFilterType.FILE_PATH
COMMIT_MESSAGE = WebhookFilterType.COMMIT_MESSAGE
WORKFLOW_NAME = WebhookFilterType.WORKFLOW_NAME
TAG_NAME = WebhookFilterType.TAG_NAME
RELEASE_NAME = WebhookFilterType.RELEASE_NAME
REPOSITORY_NAME = WebhookFilterType.REPOSITORY_NAME
ORGANIZATION_NAME = WebhookFilterType.ORGANIZATION_NAME
GITHUB_ORGANIZATION = WebhookScopeType.GITHUB_ORGANIZATION
GITHUB_GLOBAL = WebhookScopeType.GITHUB_GLOBAL
GITLAB_GROUP = WebhookScopeType.GITLAB_GROUP
CREATING = WebhookStatus.CREATING
CREATE_FAILED = WebhookStatus.CREATE_FAILED
ACTIVE = WebhookStatus.ACTIVE
DELETING = WebhookStatus.DELETING


@dataclass
class ComputeConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    disk: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    v_cpu: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    machine_type: Optional[Union[str, MachineType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.disk is not None:
            if hasattr(self.disk, 'to_dict'):
                props['disk'] = self.disk.to_dict()
            elif isinstance(self.disk, list):
                props['disk'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disk
                ]
            else:
                props['disk'] = self.disk

        if self.memory is not None:
            if hasattr(self.memory, 'to_dict'):
                props['memory'] = self.memory.to_dict()
            elif isinstance(self.memory, list):
                props['memory'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory
                ]
            else:
                props['memory'] = self.memory

        if self.v_cpu is not None:
            if hasattr(self.v_cpu, 'to_dict'):
                props['vCpu'] = self.v_cpu.to_dict()
            elif isinstance(self.v_cpu, list):
                props['vCpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.v_cpu
                ]
            else:
                props['vCpu'] = self.v_cpu

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['instanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['instanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['instanceType'] = self.instance_type

        if self.machine_type is not None:
            if hasattr(self.machine_type, 'to_dict'):
                props['machineType'] = self.machine_type.to_dict()
            elif isinstance(self.machine_type, list):
                props['machineType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.machine_type
                ]
            else:
                props['machineType'] = self.machine_type

        return props


@dataclass
class FleetProxyRule:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    effect: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    entities: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.effect is not None:
            if hasattr(self.effect, 'to_dict'):
                props['Effect'] = self.effect.to_dict()
            elif isinstance(self.effect, list):
                props['Effect'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.effect
                ]
            else:
                props['Effect'] = self.effect

        if self.entities is not None:
            if hasattr(self.entities, 'to_dict'):
                props['Entities'] = self.entities.to_dict()
            elif isinstance(self.entities, list):
                props['Entities'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.entities
                ]
            else:
                props['Entities'] = self.entities

        return props


@dataclass
class ProxyConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_behavior: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ordered_proxy_rules: Optional[list[FleetProxyRule]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_behavior is not None:
            if hasattr(self.default_behavior, 'to_dict'):
                props['DefaultBehavior'] = self.default_behavior.to_dict()
            elif isinstance(self.default_behavior, list):
                props['DefaultBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_behavior
                ]
            else:
                props['DefaultBehavior'] = self.default_behavior

        if self.ordered_proxy_rules is not None:
            if hasattr(self.ordered_proxy_rules, 'to_dict'):
                props['OrderedProxyRules'] = self.ordered_proxy_rules.to_dict()
            elif isinstance(self.ordered_proxy_rules, list):
                props['OrderedProxyRules'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ordered_proxy_rules
                ]
            else:
                props['OrderedProxyRules'] = self.ordered_proxy_rules

        return props


@dataclass
class ScalingConfigurationInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_tracking_scaling_configs: Optional[list[TargetTrackingScalingConfiguration]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scaling_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.target_tracking_scaling_configs is not None:
            if hasattr(self.target_tracking_scaling_configs, 'to_dict'):
                props['TargetTrackingScalingConfigs'] = self.target_tracking_scaling_configs.to_dict()
            elif isinstance(self.target_tracking_scaling_configs, list):
                props['TargetTrackingScalingConfigs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_tracking_scaling_configs
                ]
            else:
                props['TargetTrackingScalingConfigs'] = self.target_tracking_scaling_configs

        if self.scaling_type is not None:
            if hasattr(self.scaling_type, 'to_dict'):
                props['ScalingType'] = self.scaling_type.to_dict()
            elif isinstance(self.scaling_type, list):
                props['ScalingType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scaling_type
                ]
            else:
                props['ScalingType'] = self.scaling_type

        if self.max_capacity is not None:
            if hasattr(self.max_capacity, 'to_dict'):
                props['MaxCapacity'] = self.max_capacity.to_dict()
            elif isinstance(self.max_capacity, list):
                props['MaxCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_capacity
                ]
            else:
                props['MaxCapacity'] = self.max_capacity

        return props


@dataclass
class TargetTrackingScalingConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_value: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.target_value is not None:
            if hasattr(self.target_value, 'to_dict'):
                props['TargetValue'] = self.target_value.to_dict()
            elif isinstance(self.target_value, list):
                props['TargetValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_value
                ]
            else:
                props['TargetValue'] = self.target_value

        if self.metric_type is not None:
            if hasattr(self.metric_type, 'to_dict'):
                props['MetricType'] = self.metric_type.to_dict()
            elif isinstance(self.metric_type, list):
                props['MetricType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_type
                ]
            else:
                props['MetricType'] = self.metric_type

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnets: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnets is not None:
            if hasattr(self.subnets, 'to_dict'):
                props['Subnets'] = self.subnets.to_dict()
            elif isinstance(self.subnets, list):
                props['Subnets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnets
                ]
            else:
                props['Subnets'] = self.subnets

        if self.vpc_id is not None:
            if hasattr(self.vpc_id, 'to_dict'):
                props['VpcId'] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props['VpcId'] = self.vpc_id

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class Fleet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codeb"""

    resource_type: ClassVar[str] = "AWS::CodeBuild::Fleet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    fleet_service_role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    environment_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    overflow_behavior: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    image_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    scaling_configuration: Optional[ScalingConfigurationInput] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    base_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    fleet_proxy_configuration: Optional[ProxyConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    compute_configuration: Optional[ComputeConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    compute_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    fleet_vpc_config: Optional[VpcConfig] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.fleet_service_role is not None:
            # Serialize fleet_service_role (handle intrinsic functions)
            if hasattr(self.fleet_service_role, 'to_dict'):
                props["FleetServiceRole"] = self.fleet_service_role.to_dict()
            elif isinstance(self.fleet_service_role, list):
                # Serialize list items (may contain intrinsic functions)
                props['FleetServiceRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fleet_service_role
                ]
            else:
                props["FleetServiceRole"] = self.fleet_service_role

        if self.environment_type is not None:
            # Serialize environment_type (handle intrinsic functions)
            if hasattr(self.environment_type, 'to_dict'):
                props["EnvironmentType"] = self.environment_type.to_dict()
            elif isinstance(self.environment_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnvironmentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment_type
                ]
            else:
                props["EnvironmentType"] = self.environment_type

        if self.overflow_behavior is not None:
            # Serialize overflow_behavior (handle intrinsic functions)
            if hasattr(self.overflow_behavior, 'to_dict'):
                props["OverflowBehavior"] = self.overflow_behavior.to_dict()
            elif isinstance(self.overflow_behavior, list):
                # Serialize list items (may contain intrinsic functions)
                props['OverflowBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.overflow_behavior
                ]
            else:
                props["OverflowBehavior"] = self.overflow_behavior

        if self.image_id is not None:
            # Serialize image_id (handle intrinsic functions)
            if hasattr(self.image_id, 'to_dict'):
                props["ImageId"] = self.image_id.to_dict()
            elif isinstance(self.image_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ImageId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_id
                ]
            else:
                props["ImageId"] = self.image_id

        if self.scaling_configuration is not None:
            # Serialize scaling_configuration (handle intrinsic functions)
            if hasattr(self.scaling_configuration, 'to_dict'):
                props["ScalingConfiguration"] = self.scaling_configuration.to_dict()
            elif isinstance(self.scaling_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['ScalingConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scaling_configuration
                ]
            else:
                props["ScalingConfiguration"] = self.scaling_configuration

        if self.base_capacity is not None:
            # Serialize base_capacity (handle intrinsic functions)
            if hasattr(self.base_capacity, 'to_dict'):
                props["BaseCapacity"] = self.base_capacity.to_dict()
            elif isinstance(self.base_capacity, list):
                # Serialize list items (may contain intrinsic functions)
                props['BaseCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.base_capacity
                ]
            else:
                props["BaseCapacity"] = self.base_capacity

        if self.fleet_proxy_configuration is not None:
            # Serialize fleet_proxy_configuration (handle intrinsic functions)
            if hasattr(self.fleet_proxy_configuration, 'to_dict'):
                props["FleetProxyConfiguration"] = self.fleet_proxy_configuration.to_dict()
            elif isinstance(self.fleet_proxy_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['FleetProxyConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fleet_proxy_configuration
                ]
            else:
                props["FleetProxyConfiguration"] = self.fleet_proxy_configuration

        if self.compute_configuration is not None:
            # Serialize compute_configuration (handle intrinsic functions)
            if hasattr(self.compute_configuration, 'to_dict'):
                props["ComputeConfiguration"] = self.compute_configuration.to_dict()
            elif isinstance(self.compute_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['ComputeConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compute_configuration
                ]
            else:
                props["ComputeConfiguration"] = self.compute_configuration

        if self.compute_type is not None:
            # Serialize compute_type (handle intrinsic functions)
            if hasattr(self.compute_type, 'to_dict'):
                props["ComputeType"] = self.compute_type.to_dict()
            elif isinstance(self.compute_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['ComputeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compute_type
                ]
            else:
                props["ComputeType"] = self.compute_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.fleet_vpc_config is not None:
            # Serialize fleet_vpc_config (handle intrinsic functions)
            if hasattr(self.fleet_vpc_config, 'to_dict'):
                props["FleetVpcConfig"] = self.fleet_vpc_config.to_dict()
            elif isinstance(self.fleet_vpc_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['FleetVpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fleet_vpc_config
                ]
            else:
                props["FleetVpcConfig"] = self.fleet_vpc_config

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class Artifacts:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    artifact_identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    override_artifact_name: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    packaging: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encryption_disabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    location: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    namespace_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.path is not None:
            if hasattr(self.path, 'to_dict'):
                props['Path'] = self.path.to_dict()
            elif isinstance(self.path, list):
                props['Path'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.path
                ]
            else:
                props['Path'] = self.path

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.artifact_identifier is not None:
            if hasattr(self.artifact_identifier, 'to_dict'):
                props['ArtifactIdentifier'] = self.artifact_identifier.to_dict()
            elif isinstance(self.artifact_identifier, list):
                props['ArtifactIdentifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.artifact_identifier
                ]
            else:
                props['ArtifactIdentifier'] = self.artifact_identifier

        if self.override_artifact_name is not None:
            if hasattr(self.override_artifact_name, 'to_dict'):
                props['OverrideArtifactName'] = self.override_artifact_name.to_dict()
            elif isinstance(self.override_artifact_name, list):
                props['OverrideArtifactName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.override_artifact_name
                ]
            else:
                props['OverrideArtifactName'] = self.override_artifact_name

        if self.packaging is not None:
            if hasattr(self.packaging, 'to_dict'):
                props['Packaging'] = self.packaging.to_dict()
            elif isinstance(self.packaging, list):
                props['Packaging'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.packaging
                ]
            else:
                props['Packaging'] = self.packaging

        if self.encryption_disabled is not None:
            if hasattr(self.encryption_disabled, 'to_dict'):
                props['EncryptionDisabled'] = self.encryption_disabled.to_dict()
            elif isinstance(self.encryption_disabled, list):
                props['EncryptionDisabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encryption_disabled
                ]
            else:
                props['EncryptionDisabled'] = self.encryption_disabled

        if self.location is not None:
            if hasattr(self.location, 'to_dict'):
                props['Location'] = self.location.to_dict()
            elif isinstance(self.location, list):
                props['Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location
                ]
            else:
                props['Location'] = self.location

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        if self.namespace_type is not None:
            if hasattr(self.namespace_type, 'to_dict'):
                props['NamespaceType'] = self.namespace_type.to_dict()
            elif isinstance(self.namespace_type, list):
                props['NamespaceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.namespace_type
                ]
            else:
                props['NamespaceType'] = self.namespace_type

        return props


@dataclass
class BatchRestrictions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    compute_types_allowed: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_builds_allowed: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.compute_types_allowed is not None:
            if hasattr(self.compute_types_allowed, 'to_dict'):
                props['ComputeTypesAllowed'] = self.compute_types_allowed.to_dict()
            elif isinstance(self.compute_types_allowed, list):
                props['ComputeTypesAllowed'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compute_types_allowed
                ]
            else:
                props['ComputeTypesAllowed'] = self.compute_types_allowed

        if self.maximum_builds_allowed is not None:
            if hasattr(self.maximum_builds_allowed, 'to_dict'):
                props['MaximumBuildsAllowed'] = self.maximum_builds_allowed.to_dict()
            elif isinstance(self.maximum_builds_allowed, list):
                props['MaximumBuildsAllowed'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_builds_allowed
                ]
            else:
                props['MaximumBuildsAllowed'] = self.maximum_builds_allowed

        return props


@dataclass
class BuildStatusConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    context: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_url: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.context is not None:
            if hasattr(self.context, 'to_dict'):
                props['Context'] = self.context.to_dict()
            elif isinstance(self.context, list):
                props['Context'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.context
                ]
            else:
                props['Context'] = self.context

        if self.target_url is not None:
            if hasattr(self.target_url, 'to_dict'):
                props['TargetUrl'] = self.target_url.to_dict()
            elif isinstance(self.target_url, list):
                props['TargetUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_url
                ]
            else:
                props['TargetUrl'] = self.target_url

        return props


@dataclass
class CloudWatchLogsConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    stream_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.status is not None:
            if hasattr(self.status, 'to_dict'):
                props['Status'] = self.status.to_dict()
            elif isinstance(self.status, list):
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props['Status'] = self.status

        if self.group_name is not None:
            if hasattr(self.group_name, 'to_dict'):
                props['GroupName'] = self.group_name.to_dict()
            elif isinstance(self.group_name, list):
                props['GroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_name
                ]
            else:
                props['GroupName'] = self.group_name

        if self.stream_name is not None:
            if hasattr(self.stream_name, 'to_dict'):
                props['StreamName'] = self.stream_name.to_dict()
            elif isinstance(self.stream_name, list):
                props['StreamName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stream_name
                ]
            else:
                props['StreamName'] = self.stream_name

        return props


@dataclass
class DockerServer:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    compute_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.compute_type is not None:
            if hasattr(self.compute_type, 'to_dict'):
                props['ComputeType'] = self.compute_type.to_dict()
            elif isinstance(self.compute_type, list):
                props['ComputeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compute_type
                ]
            else:
                props['ComputeType'] = self.compute_type

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class Environment:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    environment_variables: Optional[list[EnvironmentVariable]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    fleet: Optional[ProjectFleet] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    privileged_mode: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_pull_credentials_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    registry_credential: Optional[RegistryCredential] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    compute_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    docker_server: Optional[DockerServer] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    certificate: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.environment_variables is not None:
            if hasattr(self.environment_variables, 'to_dict'):
                props['EnvironmentVariables'] = self.environment_variables.to_dict()
            elif isinstance(self.environment_variables, list):
                props['EnvironmentVariables'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment_variables
                ]
            else:
                props['EnvironmentVariables'] = self.environment_variables

        if self.fleet is not None:
            if hasattr(self.fleet, 'to_dict'):
                props['Fleet'] = self.fleet.to_dict()
            elif isinstance(self.fleet, list):
                props['Fleet'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fleet
                ]
            else:
                props['Fleet'] = self.fleet

        if self.privileged_mode is not None:
            if hasattr(self.privileged_mode, 'to_dict'):
                props['PrivilegedMode'] = self.privileged_mode.to_dict()
            elif isinstance(self.privileged_mode, list):
                props['PrivilegedMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.privileged_mode
                ]
            else:
                props['PrivilegedMode'] = self.privileged_mode

        if self.image_pull_credentials_type is not None:
            if hasattr(self.image_pull_credentials_type, 'to_dict'):
                props['ImagePullCredentialsType'] = self.image_pull_credentials_type.to_dict()
            elif isinstance(self.image_pull_credentials_type, list):
                props['ImagePullCredentialsType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_pull_credentials_type
                ]
            else:
                props['ImagePullCredentialsType'] = self.image_pull_credentials_type

        if self.image is not None:
            if hasattr(self.image, 'to_dict'):
                props['Image'] = self.image.to_dict()
            elif isinstance(self.image, list):
                props['Image'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image
                ]
            else:
                props['Image'] = self.image

        if self.registry_credential is not None:
            if hasattr(self.registry_credential, 'to_dict'):
                props['RegistryCredential'] = self.registry_credential.to_dict()
            elif isinstance(self.registry_credential, list):
                props['RegistryCredential'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.registry_credential
                ]
            else:
                props['RegistryCredential'] = self.registry_credential

        if self.compute_type is not None:
            if hasattr(self.compute_type, 'to_dict'):
                props['ComputeType'] = self.compute_type.to_dict()
            elif isinstance(self.compute_type, list):
                props['ComputeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compute_type
                ]
            else:
                props['ComputeType'] = self.compute_type

        if self.docker_server is not None:
            if hasattr(self.docker_server, 'to_dict'):
                props['DockerServer'] = self.docker_server.to_dict()
            elif isinstance(self.docker_server, list):
                props['DockerServer'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.docker_server
                ]
            else:
                props['DockerServer'] = self.docker_server

        if self.certificate is not None:
            if hasattr(self.certificate, 'to_dict'):
                props['Certificate'] = self.certificate.to_dict()
            elif isinstance(self.certificate, list):
                props['Certificate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate
                ]
            else:
                props['Certificate'] = self.certificate

        return props


@dataclass
class EnvironmentVariable:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class FilterGroup:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    pass


@dataclass
class GitSubmodulesConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    fetch_submodules: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.fetch_submodules is not None:
            if hasattr(self.fetch_submodules, 'to_dict'):
                props['FetchSubmodules'] = self.fetch_submodules.to_dict()
            elif isinstance(self.fetch_submodules, list):
                props['FetchSubmodules'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fetch_submodules
                ]
            else:
                props['FetchSubmodules'] = self.fetch_submodules

        return props


@dataclass
class LogsConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logs: Optional[CloudWatchLogsConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_logs: Optional[S3LogsConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cloud_watch_logs is not None:
            if hasattr(self.cloud_watch_logs, 'to_dict'):
                props['CloudWatchLogs'] = self.cloud_watch_logs.to_dict()
            elif isinstance(self.cloud_watch_logs, list):
                props['CloudWatchLogs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cloud_watch_logs
                ]
            else:
                props['CloudWatchLogs'] = self.cloud_watch_logs

        if self.s3_logs is not None:
            if hasattr(self.s3_logs, 'to_dict'):
                props['S3Logs'] = self.s3_logs.to_dict()
            elif isinstance(self.s3_logs, list):
                props['S3Logs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_logs
                ]
            else:
                props['S3Logs'] = self.s3_logs

        return props


@dataclass
class ProjectBuildBatchConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    combine_artifacts: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    service_role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    batch_report_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    timeout_in_mins: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    restrictions: Optional[BatchRestrictions] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.combine_artifacts is not None:
            if hasattr(self.combine_artifacts, 'to_dict'):
                props['CombineArtifacts'] = self.combine_artifacts.to_dict()
            elif isinstance(self.combine_artifacts, list):
                props['CombineArtifacts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.combine_artifacts
                ]
            else:
                props['CombineArtifacts'] = self.combine_artifacts

        if self.service_role is not None:
            if hasattr(self.service_role, 'to_dict'):
                props['ServiceRole'] = self.service_role.to_dict()
            elif isinstance(self.service_role, list):
                props['ServiceRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_role
                ]
            else:
                props['ServiceRole'] = self.service_role

        if self.batch_report_mode is not None:
            if hasattr(self.batch_report_mode, 'to_dict'):
                props['BatchReportMode'] = self.batch_report_mode.to_dict()
            elif isinstance(self.batch_report_mode, list):
                props['BatchReportMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.batch_report_mode
                ]
            else:
                props['BatchReportMode'] = self.batch_report_mode

        if self.timeout_in_mins is not None:
            if hasattr(self.timeout_in_mins, 'to_dict'):
                props['TimeoutInMins'] = self.timeout_in_mins.to_dict()
            elif isinstance(self.timeout_in_mins, list):
                props['TimeoutInMins'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.timeout_in_mins
                ]
            else:
                props['TimeoutInMins'] = self.timeout_in_mins

        if self.restrictions is not None:
            if hasattr(self.restrictions, 'to_dict'):
                props['Restrictions'] = self.restrictions.to_dict()
            elif isinstance(self.restrictions, list):
                props['Restrictions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.restrictions
                ]
            else:
                props['Restrictions'] = self.restrictions

        return props


@dataclass
class ProjectCache:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    modes: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cache_namespace: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    location: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.modes is not None:
            if hasattr(self.modes, 'to_dict'):
                props['Modes'] = self.modes.to_dict()
            elif isinstance(self.modes, list):
                props['Modes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.modes
                ]
            else:
                props['Modes'] = self.modes

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.cache_namespace is not None:
            if hasattr(self.cache_namespace, 'to_dict'):
                props['CacheNamespace'] = self.cache_namespace.to_dict()
            elif isinstance(self.cache_namespace, list):
                props['CacheNamespace'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cache_namespace
                ]
            else:
                props['CacheNamespace'] = self.cache_namespace

        if self.location is not None:
            if hasattr(self.location, 'to_dict'):
                props['Location'] = self.location.to_dict()
            elif isinstance(self.location, list):
                props['Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location
                ]
            else:
                props['Location'] = self.location

        return props


@dataclass
class ProjectFileSystemLocation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mount_point: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mount_options: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    location: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mount_point is not None:
            if hasattr(self.mount_point, 'to_dict'):
                props['MountPoint'] = self.mount_point.to_dict()
            elif isinstance(self.mount_point, list):
                props['MountPoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mount_point
                ]
            else:
                props['MountPoint'] = self.mount_point

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.identifier is not None:
            if hasattr(self.identifier, 'to_dict'):
                props['Identifier'] = self.identifier.to_dict()
            elif isinstance(self.identifier, list):
                props['Identifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.identifier
                ]
            else:
                props['Identifier'] = self.identifier

        if self.mount_options is not None:
            if hasattr(self.mount_options, 'to_dict'):
                props['MountOptions'] = self.mount_options.to_dict()
            elif isinstance(self.mount_options, list):
                props['MountOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mount_options
                ]
            else:
                props['MountOptions'] = self.mount_options

        if self.location is not None:
            if hasattr(self.location, 'to_dict'):
                props['Location'] = self.location.to_dict()
            elif isinstance(self.location, list):
                props['Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location
                ]
            else:
                props['Location'] = self.location

        return props


@dataclass
class ProjectFleet:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    fleet_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.fleet_arn is not None:
            if hasattr(self.fleet_arn, 'to_dict'):
                props['FleetArn'] = self.fleet_arn.to_dict()
            elif isinstance(self.fleet_arn, list):
                props['FleetArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fleet_arn
                ]
            else:
                props['FleetArn'] = self.fleet_arn

        return props


@dataclass
class ProjectSourceVersion:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_version: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.source_identifier is not None:
            if hasattr(self.source_identifier, 'to_dict'):
                props['SourceIdentifier'] = self.source_identifier.to_dict()
            elif isinstance(self.source_identifier, list):
                props['SourceIdentifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_identifier
                ]
            else:
                props['SourceIdentifier'] = self.source_identifier

        if self.source_version is not None:
            if hasattr(self.source_version, 'to_dict'):
                props['SourceVersion'] = self.source_version.to_dict()
            elif isinstance(self.source_version, list):
                props['SourceVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_version
                ]
            else:
                props['SourceVersion'] = self.source_version

        return props


@dataclass
class ProjectTriggers:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    filter_groups: Optional[list[FilterGroup]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    build_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    webhook: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scope_configuration: Optional[ScopeConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    pull_request_build_policy: Optional[PullRequestBuildPolicy] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.filter_groups is not None:
            if hasattr(self.filter_groups, 'to_dict'):
                props['FilterGroups'] = self.filter_groups.to_dict()
            elif isinstance(self.filter_groups, list):
                props['FilterGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter_groups
                ]
            else:
                props['FilterGroups'] = self.filter_groups

        if self.build_type is not None:
            if hasattr(self.build_type, 'to_dict'):
                props['BuildType'] = self.build_type.to_dict()
            elif isinstance(self.build_type, list):
                props['BuildType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.build_type
                ]
            else:
                props['BuildType'] = self.build_type

        if self.webhook is not None:
            if hasattr(self.webhook, 'to_dict'):
                props['Webhook'] = self.webhook.to_dict()
            elif isinstance(self.webhook, list):
                props['Webhook'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.webhook
                ]
            else:
                props['Webhook'] = self.webhook

        if self.scope_configuration is not None:
            if hasattr(self.scope_configuration, 'to_dict'):
                props['ScopeConfiguration'] = self.scope_configuration.to_dict()
            elif isinstance(self.scope_configuration, list):
                props['ScopeConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scope_configuration
                ]
            else:
                props['ScopeConfiguration'] = self.scope_configuration

        if self.pull_request_build_policy is not None:
            if hasattr(self.pull_request_build_policy, 'to_dict'):
                props['PullRequestBuildPolicy'] = self.pull_request_build_policy.to_dict()
            elif isinstance(self.pull_request_build_policy, list):
                props['PullRequestBuildPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pull_request_build_policy
                ]
            else:
                props['PullRequestBuildPolicy'] = self.pull_request_build_policy

        return props


@dataclass
class PullRequestBuildPolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    requires_comment_approval: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    approver_roles: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.requires_comment_approval is not None:
            if hasattr(self.requires_comment_approval, 'to_dict'):
                props['RequiresCommentApproval'] = self.requires_comment_approval.to_dict()
            elif isinstance(self.requires_comment_approval, list):
                props['RequiresCommentApproval'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.requires_comment_approval
                ]
            else:
                props['RequiresCommentApproval'] = self.requires_comment_approval

        if self.approver_roles is not None:
            if hasattr(self.approver_roles, 'to_dict'):
                props['ApproverRoles'] = self.approver_roles.to_dict()
            elif isinstance(self.approver_roles, list):
                props['ApproverRoles'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.approver_roles
                ]
            else:
                props['ApproverRoles'] = self.approver_roles

        return props


@dataclass
class RegistryCredential:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    credential: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    credential_provider: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.credential is not None:
            if hasattr(self.credential, 'to_dict'):
                props['Credential'] = self.credential.to_dict()
            elif isinstance(self.credential, list):
                props['Credential'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.credential
                ]
            else:
                props['Credential'] = self.credential

        if self.credential_provider is not None:
            if hasattr(self.credential_provider, 'to_dict'):
                props['CredentialProvider'] = self.credential_provider.to_dict()
            elif isinstance(self.credential_provider, list):
                props['CredentialProvider'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.credential_provider
                ]
            else:
                props['CredentialProvider'] = self.credential_provider

        return props


@dataclass
class S3LogsConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encryption_disabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    location: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.status is not None:
            if hasattr(self.status, 'to_dict'):
                props['Status'] = self.status.to_dict()
            elif isinstance(self.status, list):
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props['Status'] = self.status

        if self.encryption_disabled is not None:
            if hasattr(self.encryption_disabled, 'to_dict'):
                props['EncryptionDisabled'] = self.encryption_disabled.to_dict()
            elif isinstance(self.encryption_disabled, list):
                props['EncryptionDisabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encryption_disabled
                ]
            else:
                props['EncryptionDisabled'] = self.encryption_disabled

        if self.location is not None:
            if hasattr(self.location, 'to_dict'):
                props['Location'] = self.location.to_dict()
            elif isinstance(self.location, list):
                props['Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location
                ]
            else:
                props['Location'] = self.location

        return props


@dataclass
class ScopeConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scope: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    domain: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.scope is not None:
            if hasattr(self.scope, 'to_dict'):
                props['Scope'] = self.scope.to_dict()
            elif isinstance(self.scope, list):
                props['Scope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scope
                ]
            else:
                props['Scope'] = self.scope

        if self.domain is not None:
            if hasattr(self.domain, 'to_dict'):
                props['Domain'] = self.domain.to_dict()
            elif isinstance(self.domain, list):
                props['Domain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain
                ]
            else:
                props['Domain'] = self.domain

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class Source:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    report_build_status: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auth: Optional[SourceAuth] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    build_spec: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    git_clone_depth: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    build_status_config: Optional[BuildStatusConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    git_submodules_config: Optional[GitSubmodulesConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    insecure_ssl: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    location: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.report_build_status is not None:
            if hasattr(self.report_build_status, 'to_dict'):
                props['ReportBuildStatus'] = self.report_build_status.to_dict()
            elif isinstance(self.report_build_status, list):
                props['ReportBuildStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.report_build_status
                ]
            else:
                props['ReportBuildStatus'] = self.report_build_status

        if self.auth is not None:
            if hasattr(self.auth, 'to_dict'):
                props['Auth'] = self.auth.to_dict()
            elif isinstance(self.auth, list):
                props['Auth'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auth
                ]
            else:
                props['Auth'] = self.auth

        if self.source_identifier is not None:
            if hasattr(self.source_identifier, 'to_dict'):
                props['SourceIdentifier'] = self.source_identifier.to_dict()
            elif isinstance(self.source_identifier, list):
                props['SourceIdentifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_identifier
                ]
            else:
                props['SourceIdentifier'] = self.source_identifier

        if self.build_spec is not None:
            if hasattr(self.build_spec, 'to_dict'):
                props['BuildSpec'] = self.build_spec.to_dict()
            elif isinstance(self.build_spec, list):
                props['BuildSpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.build_spec
                ]
            else:
                props['BuildSpec'] = self.build_spec

        if self.git_clone_depth is not None:
            if hasattr(self.git_clone_depth, 'to_dict'):
                props['GitCloneDepth'] = self.git_clone_depth.to_dict()
            elif isinstance(self.git_clone_depth, list):
                props['GitCloneDepth'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.git_clone_depth
                ]
            else:
                props['GitCloneDepth'] = self.git_clone_depth

        if self.build_status_config is not None:
            if hasattr(self.build_status_config, 'to_dict'):
                props['BuildStatusConfig'] = self.build_status_config.to_dict()
            elif isinstance(self.build_status_config, list):
                props['BuildStatusConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.build_status_config
                ]
            else:
                props['BuildStatusConfig'] = self.build_status_config

        if self.git_submodules_config is not None:
            if hasattr(self.git_submodules_config, 'to_dict'):
                props['GitSubmodulesConfig'] = self.git_submodules_config.to_dict()
            elif isinstance(self.git_submodules_config, list):
                props['GitSubmodulesConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.git_submodules_config
                ]
            else:
                props['GitSubmodulesConfig'] = self.git_submodules_config

        if self.insecure_ssl is not None:
            if hasattr(self.insecure_ssl, 'to_dict'):
                props['InsecureSsl'] = self.insecure_ssl.to_dict()
            elif isinstance(self.insecure_ssl, list):
                props['InsecureSsl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.insecure_ssl
                ]
            else:
                props['InsecureSsl'] = self.insecure_ssl

        if self.location is not None:
            if hasattr(self.location, 'to_dict'):
                props['Location'] = self.location.to_dict()
            elif isinstance(self.location, list):
                props['Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location
                ]
            else:
                props['Location'] = self.location

        return props


@dataclass
class SourceAuth:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.resource is not None:
            if hasattr(self.resource, 'to_dict'):
                props['Resource'] = self.resource.to_dict()
            elif isinstance(self.resource, list):
                props['Resource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource
                ]
            else:
                props['Resource'] = self.resource

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnets: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnets is not None:
            if hasattr(self.subnets, 'to_dict'):
                props['Subnets'] = self.subnets.to_dict()
            elif isinstance(self.subnets, list):
                props['Subnets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnets
                ]
            else:
                props['Subnets'] = self.subnets

        if self.vpc_id is not None:
            if hasattr(self.vpc_id, 'to_dict'):
                props['VpcId'] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props['VpcId'] = self.vpc_id

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class WebhookFilter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    pattern: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    exclude_matched_pattern: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.pattern is not None:
            if hasattr(self.pattern, 'to_dict'):
                props['Pattern'] = self.pattern.to_dict()
            elif isinstance(self.pattern, list):
                props['Pattern'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pattern
                ]
            else:
                props['Pattern'] = self.pattern

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.exclude_matched_pattern is not None:
            if hasattr(self.exclude_matched_pattern, 'to_dict'):
                props['ExcludeMatchedPattern'] = self.exclude_matched_pattern.to_dict()
            elif isinstance(self.exclude_matched_pattern, list):
                props['ExcludeMatchedPattern'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.exclude_matched_pattern
                ]
            else:
                props['ExcludeMatchedPattern'] = self.exclude_matched_pattern

        return props


@dataclass
class Project(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codeb"""

    resource_type: ClassVar[str] = "AWS::CodeBuild::Project"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_access_role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_config: Optional[VpcConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    secondary_sources: Optional[list[Source]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    encryption_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    secondary_artifacts: Optional[list[Artifacts]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source: Optional[Source] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    logs_config: Optional[LogsConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    queued_timeout_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    secondary_source_versions: Optional[list[ProjectSourceVersion]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_retry_limit: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    triggers: Optional[ProjectTriggers] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    artifacts: Optional[Artifacts] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    badge_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    file_system_locations: Optional[list[ProjectFileSystemLocation]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    environment: Optional[Environment] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    concurrent_build_limit: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    visibility: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    build_batch_config: Optional[ProjectBuildBatchConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    timeout_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cache: Optional[ProjectCache] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.resource_access_role is not None:
            # Serialize resource_access_role (handle intrinsic functions)
            if hasattr(self.resource_access_role, 'to_dict'):
                props["ResourceAccessRole"] = self.resource_access_role.to_dict()
            elif isinstance(self.resource_access_role, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceAccessRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_access_role
                ]
            else:
                props["ResourceAccessRole"] = self.resource_access_role

        if self.vpc_config is not None:
            # Serialize vpc_config (handle intrinsic functions)
            if hasattr(self.vpc_config, 'to_dict'):
                props["VpcConfig"] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props["VpcConfig"] = self.vpc_config

        if self.secondary_sources is not None:
            # Serialize secondary_sources (handle intrinsic functions)
            if hasattr(self.secondary_sources, 'to_dict'):
                props["SecondarySources"] = self.secondary_sources.to_dict()
            elif isinstance(self.secondary_sources, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecondarySources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_sources
                ]
            else:
                props["SecondarySources"] = self.secondary_sources

        if self.encryption_key is not None:
            # Serialize encryption_key (handle intrinsic functions)
            if hasattr(self.encryption_key, 'to_dict'):
                props["EncryptionKey"] = self.encryption_key.to_dict()
            elif isinstance(self.encryption_key, list):
                # Serialize list items (may contain intrinsic functions)
                props['EncryptionKey'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encryption_key
                ]
            else:
                props["EncryptionKey"] = self.encryption_key

        if self.secondary_artifacts is not None:
            # Serialize secondary_artifacts (handle intrinsic functions)
            if hasattr(self.secondary_artifacts, 'to_dict'):
                props["SecondaryArtifacts"] = self.secondary_artifacts.to_dict()
            elif isinstance(self.secondary_artifacts, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecondaryArtifacts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_artifacts
                ]
            else:
                props["SecondaryArtifacts"] = self.secondary_artifacts

        if self.source is not None:
            # Serialize source (handle intrinsic functions)
            if hasattr(self.source, 'to_dict'):
                props["Source"] = self.source.to_dict()
            elif isinstance(self.source, list):
                # Serialize list items (may contain intrinsic functions)
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props["Source"] = self.source

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.logs_config is not None:
            # Serialize logs_config (handle intrinsic functions)
            if hasattr(self.logs_config, 'to_dict'):
                props["LogsConfig"] = self.logs_config.to_dict()
            elif isinstance(self.logs_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogsConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.logs_config
                ]
            else:
                props["LogsConfig"] = self.logs_config

        if self.service_role is not None:
            # Serialize service_role (handle intrinsic functions)
            if hasattr(self.service_role, 'to_dict'):
                props["ServiceRole"] = self.service_role.to_dict()
            elif isinstance(self.service_role, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_role
                ]
            else:
                props["ServiceRole"] = self.service_role

        if self.queued_timeout_in_minutes is not None:
            # Serialize queued_timeout_in_minutes (handle intrinsic functions)
            if hasattr(self.queued_timeout_in_minutes, 'to_dict'):
                props["QueuedTimeoutInMinutes"] = self.queued_timeout_in_minutes.to_dict()
            elif isinstance(self.queued_timeout_in_minutes, list):
                # Serialize list items (may contain intrinsic functions)
                props['QueuedTimeoutInMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.queued_timeout_in_minutes
                ]
            else:
                props["QueuedTimeoutInMinutes"] = self.queued_timeout_in_minutes

        if self.secondary_source_versions is not None:
            # Serialize secondary_source_versions (handle intrinsic functions)
            if hasattr(self.secondary_source_versions, 'to_dict'):
                props["SecondarySourceVersions"] = self.secondary_source_versions.to_dict()
            elif isinstance(self.secondary_source_versions, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecondarySourceVersions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_source_versions
                ]
            else:
                props["SecondarySourceVersions"] = self.secondary_source_versions

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.auto_retry_limit is not None:
            # Serialize auto_retry_limit (handle intrinsic functions)
            if hasattr(self.auto_retry_limit, 'to_dict'):
                props["AutoRetryLimit"] = self.auto_retry_limit.to_dict()
            elif isinstance(self.auto_retry_limit, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoRetryLimit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_retry_limit
                ]
            else:
                props["AutoRetryLimit"] = self.auto_retry_limit

        if self.source_version is not None:
            # Serialize source_version (handle intrinsic functions)
            if hasattr(self.source_version, 'to_dict'):
                props["SourceVersion"] = self.source_version.to_dict()
            elif isinstance(self.source_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_version
                ]
            else:
                props["SourceVersion"] = self.source_version

        if self.triggers is not None:
            # Serialize triggers (handle intrinsic functions)
            if hasattr(self.triggers, 'to_dict'):
                props["Triggers"] = self.triggers.to_dict()
            elif isinstance(self.triggers, list):
                # Serialize list items (may contain intrinsic functions)
                props['Triggers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.triggers
                ]
            else:
                props["Triggers"] = self.triggers

        if self.artifacts is not None:
            # Serialize artifacts (handle intrinsic functions)
            if hasattr(self.artifacts, 'to_dict'):
                props["Artifacts"] = self.artifacts.to_dict()
            elif isinstance(self.artifacts, list):
                # Serialize list items (may contain intrinsic functions)
                props['Artifacts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.artifacts
                ]
            else:
                props["Artifacts"] = self.artifacts

        if self.badge_enabled is not None:
            # Serialize badge_enabled (handle intrinsic functions)
            if hasattr(self.badge_enabled, 'to_dict'):
                props["BadgeEnabled"] = self.badge_enabled.to_dict()
            elif isinstance(self.badge_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['BadgeEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.badge_enabled
                ]
            else:
                props["BadgeEnabled"] = self.badge_enabled

        if self.file_system_locations is not None:
            # Serialize file_system_locations (handle intrinsic functions)
            if hasattr(self.file_system_locations, 'to_dict'):
                props["FileSystemLocations"] = self.file_system_locations.to_dict()
            elif isinstance(self.file_system_locations, list):
                # Serialize list items (may contain intrinsic functions)
                props['FileSystemLocations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_locations
                ]
            else:
                props["FileSystemLocations"] = self.file_system_locations

        if self.environment is not None:
            # Serialize environment (handle intrinsic functions)
            if hasattr(self.environment, 'to_dict'):
                props["Environment"] = self.environment.to_dict()
            elif isinstance(self.environment, list):
                # Serialize list items (may contain intrinsic functions)
                props['Environment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment
                ]
            else:
                props["Environment"] = self.environment

        if self.concurrent_build_limit is not None:
            # Serialize concurrent_build_limit (handle intrinsic functions)
            if hasattr(self.concurrent_build_limit, 'to_dict'):
                props["ConcurrentBuildLimit"] = self.concurrent_build_limit.to_dict()
            elif isinstance(self.concurrent_build_limit, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConcurrentBuildLimit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.concurrent_build_limit
                ]
            else:
                props["ConcurrentBuildLimit"] = self.concurrent_build_limit

        if self.visibility is not None:
            # Serialize visibility (handle intrinsic functions)
            if hasattr(self.visibility, 'to_dict'):
                props["Visibility"] = self.visibility.to_dict()
            elif isinstance(self.visibility, list):
                # Serialize list items (may contain intrinsic functions)
                props['Visibility'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.visibility
                ]
            else:
                props["Visibility"] = self.visibility

        if self.build_batch_config is not None:
            # Serialize build_batch_config (handle intrinsic functions)
            if hasattr(self.build_batch_config, 'to_dict'):
                props["BuildBatchConfig"] = self.build_batch_config.to_dict()
            elif isinstance(self.build_batch_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['BuildBatchConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.build_batch_config
                ]
            else:
                props["BuildBatchConfig"] = self.build_batch_config

        if self.timeout_in_minutes is not None:
            # Serialize timeout_in_minutes (handle intrinsic functions)
            if hasattr(self.timeout_in_minutes, 'to_dict'):
                props["TimeoutInMinutes"] = self.timeout_in_minutes.to_dict()
            elif isinstance(self.timeout_in_minutes, list):
                # Serialize list items (may contain intrinsic functions)
                props['TimeoutInMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.timeout_in_minutes
                ]
            else:
                props["TimeoutInMinutes"] = self.timeout_in_minutes

        if self.cache is not None:
            # Serialize cache (handle intrinsic functions)
            if hasattr(self.cache, 'to_dict'):
                props["Cache"] = self.cache.to_dict()
            elif isinstance(self.cache, list):
                # Serialize list items (may contain intrinsic functions)
                props['Cache'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cache
                ]
            else:
                props["Cache"] = self.cache

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class ReportExportConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_destination: Optional[S3ReportExportConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    export_config_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_destination is not None:
            if hasattr(self.s3_destination, 'to_dict'):
                props['S3Destination'] = self.s3_destination.to_dict()
            elif isinstance(self.s3_destination, list):
                props['S3Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_destination
                ]
            else:
                props['S3Destination'] = self.s3_destination

        if self.export_config_type is not None:
            if hasattr(self.export_config_type, 'to_dict'):
                props['ExportConfigType'] = self.export_config_type.to_dict()
            elif isinstance(self.export_config_type, list):
                props['ExportConfigType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.export_config_type
                ]
            else:
                props['ExportConfigType'] = self.export_config_type

        return props


@dataclass
class S3ReportExportConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cod"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    packaging: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encryption_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket_owner: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encryption_disabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.path is not None:
            if hasattr(self.path, 'to_dict'):
                props['Path'] = self.path.to_dict()
            elif isinstance(self.path, list):
                props['Path'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.path
                ]
            else:
                props['Path'] = self.path

        if self.bucket is not None:
            if hasattr(self.bucket, 'to_dict'):
                props['Bucket'] = self.bucket.to_dict()
            elif isinstance(self.bucket, list):
                props['Bucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket
                ]
            else:
                props['Bucket'] = self.bucket

        if self.packaging is not None:
            if hasattr(self.packaging, 'to_dict'):
                props['Packaging'] = self.packaging.to_dict()
            elif isinstance(self.packaging, list):
                props['Packaging'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.packaging
                ]
            else:
                props['Packaging'] = self.packaging

        if self.encryption_key is not None:
            if hasattr(self.encryption_key, 'to_dict'):
                props['EncryptionKey'] = self.encryption_key.to_dict()
            elif isinstance(self.encryption_key, list):
                props['EncryptionKey'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encryption_key
                ]
            else:
                props['EncryptionKey'] = self.encryption_key

        if self.bucket_owner is not None:
            if hasattr(self.bucket_owner, 'to_dict'):
                props['BucketOwner'] = self.bucket_owner.to_dict()
            elif isinstance(self.bucket_owner, list):
                props['BucketOwner'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket_owner
                ]
            else:
                props['BucketOwner'] = self.bucket_owner

        if self.encryption_disabled is not None:
            if hasattr(self.encryption_disabled, 'to_dict'):
                props['EncryptionDisabled'] = self.encryption_disabled.to_dict()
            elif isinstance(self.encryption_disabled, list):
                props['EncryptionDisabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encryption_disabled
                ]
            else:
                props['EncryptionDisabled'] = self.encryption_disabled

        return props


@dataclass
class ReportGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codeb"""

    resource_type: ClassVar[str] = "AWS::CodeBuild::ReportGroup"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    export_config: Optional[ReportExportConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delete_reports: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.export_config is not None:
            # Serialize export_config (handle intrinsic functions)
            if hasattr(self.export_config, 'to_dict'):
                props["ExportConfig"] = self.export_config.to_dict()
            elif isinstance(self.export_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExportConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.export_config
                ]
            else:
                props["ExportConfig"] = self.export_config

        if self.delete_reports is not None:
            # Serialize delete_reports (handle intrinsic functions)
            if hasattr(self.delete_reports, 'to_dict'):
                props["DeleteReports"] = self.delete_reports.to_dict()
            elif isinstance(self.delete_reports, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeleteReports'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_reports
                ]
            else:
                props["DeleteReports"] = self.delete_reports

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class SourceCredential(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codeb"""

    resource_type: ClassVar[str] = "AWS::CodeBuild::SourceCredential"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    server_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    username: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    token: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auth_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.server_type is not None:
            # Serialize server_type (handle intrinsic functions)
            if hasattr(self.server_type, 'to_dict'):
                props["ServerType"] = self.server_type.to_dict()
            elif isinstance(self.server_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServerType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.server_type
                ]
            else:
                props["ServerType"] = self.server_type

        if self.username is not None:
            # Serialize username (handle intrinsic functions)
            if hasattr(self.username, 'to_dict'):
                props["Username"] = self.username.to_dict()
            elif isinstance(self.username, list):
                # Serialize list items (may contain intrinsic functions)
                props['Username'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.username
                ]
            else:
                props["Username"] = self.username

        if self.token is not None:
            # Serialize token (handle intrinsic functions)
            if hasattr(self.token, 'to_dict'):
                props["Token"] = self.token.to_dict()
            elif isinstance(self.token, list):
                # Serialize list items (may contain intrinsic functions)
                props['Token'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.token
                ]
            else:
                props["Token"] = self.token

        if self.auth_type is not None:
            # Serialize auth_type (handle intrinsic functions)
            if hasattr(self.auth_type, 'to_dict'):
                props["AuthType"] = self.auth_type.to_dict()
            elif isinstance(self.auth_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['AuthType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auth_type
                ]
            else:
                props["AuthType"] = self.auth_type

        return props


