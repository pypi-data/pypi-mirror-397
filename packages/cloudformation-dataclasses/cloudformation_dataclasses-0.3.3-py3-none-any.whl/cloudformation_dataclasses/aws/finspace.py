"""
AWS CloudFormation FinSpace Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:36

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service FinSpace
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AutoScalingMetric:
    """AutoScalingMetric enum values."""

    CPU_UTILIZATION_PERCENTAGE = "CPU_UTILIZATION_PERCENTAGE"


class ChangeType:
    """ChangeType enum values."""

    PUT = "PUT"
    DELETE = "DELETE"


class ChangesetStatus:
    """ChangesetStatus enum values."""

    PENDING = "PENDING"
    PROCESSING = "PROCESSING"
    FAILED = "FAILED"
    COMPLETED = "COMPLETED"


class EnvironmentStatus:
    """EnvironmentStatus enum values."""

    CREATE_REQUESTED = "CREATE_REQUESTED"
    CREATING = "CREATING"
    CREATED = "CREATED"
    DELETE_REQUESTED = "DELETE_REQUESTED"
    DELETING = "DELETING"
    DELETED = "DELETED"
    FAILED_CREATION = "FAILED_CREATION"
    RETRY_DELETION = "RETRY_DELETION"
    FAILED_DELETION = "FAILED_DELETION"
    UPDATE_NETWORK_REQUESTED = "UPDATE_NETWORK_REQUESTED"
    UPDATING_NETWORK = "UPDATING_NETWORK"
    FAILED_UPDATING_NETWORK = "FAILED_UPDATING_NETWORK"
    SUSPENDED = "SUSPENDED"


class ErrorDetails:
    """ErrorDetails enum values."""

    THE_INPUTS_TO_THIS_REQUEST_ARE_INVALID_ = "The inputs to this request are invalid."
    SERVICE_LIMITS_HAVE_BEEN_EXCEEDED_ = "Service limits have been exceeded."
    MISSING_REQUIRED_PERMISSION_TO_PERFORM_THIS_REQUEST_ = "Missing required permission to perform this request."
    ONE_OR_MORE_INPUTS_TO_THIS_REQUEST_WERE_NOT_FOUND_ = "One or more inputs to this request were not found."
    THE_SYSTEM_TEMPORARILY_LACKS_SUFFICIENT_RESOURCES_TO_PROCESS_THE_REQUEST_ = "The system temporarily lacks sufficient resources to process the request."
    AN_INTERNAL_ERROR_HAS_OCCURRED_ = "An internal error has occurred."
    CANCELLED = "Cancelled"
    A_USER_RECOVERABLE_ERROR_HAS_OCCURRED = "A user recoverable error has occurred"


class FederationMode:
    """FederationMode enum values."""

    FEDERATED = "FEDERATED"
    LOCAL = "LOCAL"


class IPAddressType:
    """IPAddressType enum values."""

    IP_V4 = "IP_V4"


class KxAzMode:
    """KxAzMode enum values."""

    SINGLE = "SINGLE"
    MULTI = "MULTI"


class KxClusterCodeDeploymentStrategy:
    """KxClusterCodeDeploymentStrategy enum values."""

    NO_RESTART = "NO_RESTART"
    ROLLING = "ROLLING"
    FORCE = "FORCE"


class KxClusterStatus:
    """KxClusterStatus enum values."""

    PENDING = "PENDING"
    CREATING = "CREATING"
    CREATE_FAILED = "CREATE_FAILED"
    RUNNING = "RUNNING"
    UPDATING = "UPDATING"
    DELETING = "DELETING"
    DELETED = "DELETED"
    DELETE_FAILED = "DELETE_FAILED"


class KxClusterType:
    """KxClusterType enum values."""

    HDB = "HDB"
    RDB = "RDB"
    GATEWAY = "GATEWAY"
    GP = "GP"
    TICKERPLANT = "TICKERPLANT"


class KxDataviewStatus:
    """KxDataviewStatus enum values."""

    CREATING = "CREATING"
    ACTIVE = "ACTIVE"
    UPDATING = "UPDATING"
    FAILED = "FAILED"
    DELETING = "DELETING"


class KxDeploymentStrategy:
    """KxDeploymentStrategy enum values."""

    NO_RESTART = "NO_RESTART"
    ROLLING = "ROLLING"


class KxNAS1Type:
    """KxNAS1Type enum values."""

    SSD_1000 = "SSD_1000"
    SSD_250 = "SSD_250"
    HDD_12 = "HDD_12"


class KxNodeStatus:
    """KxNodeStatus enum values."""

    RUNNING = "RUNNING"
    PROVISIONING = "PROVISIONING"


class KxSavedownStorageType:
    """KxSavedownStorageType enum values."""

    SDS01 = "SDS01"


class KxScalingGroupStatus:
    """KxScalingGroupStatus enum values."""

    CREATING = "CREATING"
    CREATE_FAILED = "CREATE_FAILED"
    ACTIVE = "ACTIVE"
    DELETING = "DELETING"
    DELETED = "DELETED"
    DELETE_FAILED = "DELETE_FAILED"


class KxVolumeStatus:
    """KxVolumeStatus enum values."""

    CREATING = "CREATING"
    CREATE_FAILED = "CREATE_FAILED"
    ACTIVE = "ACTIVE"
    UPDATING = "UPDATING"
    UPDATED = "UPDATED"
    UPDATE_FAILED = "UPDATE_FAILED"
    DELETING = "DELETING"
    DELETED = "DELETED"
    DELETE_FAILED = "DELETE_FAILED"


class KxVolumeType:
    """KxVolumeType enum values."""

    NAS_1 = "NAS_1"


class RuleAction:
    """RuleAction enum values."""

    ALLOW = "allow"
    DENY = "deny"


class VolumeType:
    """VolumeType enum values."""

    NAS_1 = "NAS_1"


class dnsStatus:
    """dnsStatus enum values."""

    NONE = "NONE"
    UPDATE_REQUESTED = "UPDATE_REQUESTED"
    UPDATING = "UPDATING"
    FAILED_UPDATE = "FAILED_UPDATE"
    SUCCESSFULLY_UPDATED = "SUCCESSFULLY_UPDATED"


class tgwStatus:
    """tgwStatus enum values."""

    NONE = "NONE"
    UPDATE_REQUESTED = "UPDATE_REQUESTED"
    UPDATING = "UPDATING"
    FAILED_UPDATE = "FAILED_UPDATE"
    SUCCESSFULLY_UPDATED = "SUCCESSFULLY_UPDATED"


# Convenient aliases for enum values
CPU_UTILIZATION_PERCENTAGE = AutoScalingMetric.CPU_UTILIZATION_PERCENTAGE
PUT = ChangeType.PUT
DELETE = ChangeType.DELETE
PENDING = ChangesetStatus.PENDING
PROCESSING = ChangesetStatus.PROCESSING
FAILED = ChangesetStatus.FAILED
COMPLETED = ChangesetStatus.COMPLETED
CREATE_REQUESTED = EnvironmentStatus.CREATE_REQUESTED
CREATING = EnvironmentStatus.CREATING
CREATED = EnvironmentStatus.CREATED
DELETE_REQUESTED = EnvironmentStatus.DELETE_REQUESTED
DELETING = EnvironmentStatus.DELETING
DELETED = EnvironmentStatus.DELETED
FAILED_CREATION = EnvironmentStatus.FAILED_CREATION
RETRY_DELETION = EnvironmentStatus.RETRY_DELETION
FAILED_DELETION = EnvironmentStatus.FAILED_DELETION
UPDATE_NETWORK_REQUESTED = EnvironmentStatus.UPDATE_NETWORK_REQUESTED
UPDATING_NETWORK = EnvironmentStatus.UPDATING_NETWORK
FAILED_UPDATING_NETWORK = EnvironmentStatus.FAILED_UPDATING_NETWORK
SUSPENDED = EnvironmentStatus.SUSPENDED
THE_INPUTS_TO_THIS_REQUEST_ARE_INVALID_ = ErrorDetails.THE_INPUTS_TO_THIS_REQUEST_ARE_INVALID_
SERVICE_LIMITS_HAVE_BEEN_EXCEEDED_ = ErrorDetails.SERVICE_LIMITS_HAVE_BEEN_EXCEEDED_
MISSING_REQUIRED_PERMISSION_TO_PERFORM_THIS_REQUEST_ = ErrorDetails.MISSING_REQUIRED_PERMISSION_TO_PERFORM_THIS_REQUEST_
ONE_OR_MORE_INPUTS_TO_THIS_REQUEST_WERE_NOT_FOUND_ = ErrorDetails.ONE_OR_MORE_INPUTS_TO_THIS_REQUEST_WERE_NOT_FOUND_
THE_SYSTEM_TEMPORARILY_LACKS_SUFFICIENT_RESOURCES_TO_PROCESS_THE_REQUEST_ = ErrorDetails.THE_SYSTEM_TEMPORARILY_LACKS_SUFFICIENT_RESOURCES_TO_PROCESS_THE_REQUEST_
AN_INTERNAL_ERROR_HAS_OCCURRED_ = ErrorDetails.AN_INTERNAL_ERROR_HAS_OCCURRED_
CANCELLED = ErrorDetails.CANCELLED
A_USER_RECOVERABLE_ERROR_HAS_OCCURRED = ErrorDetails.A_USER_RECOVERABLE_ERROR_HAS_OCCURRED
FEDERATED = FederationMode.FEDERATED
LOCAL = FederationMode.LOCAL
IP_V4 = IPAddressType.IP_V4
SINGLE = KxAzMode.SINGLE
MULTI = KxAzMode.MULTI
NO_RESTART = KxClusterCodeDeploymentStrategy.NO_RESTART
ROLLING = KxClusterCodeDeploymentStrategy.ROLLING
FORCE = KxClusterCodeDeploymentStrategy.FORCE
PENDING = KxClusterStatus.PENDING
CREATING = KxClusterStatus.CREATING
CREATE_FAILED = KxClusterStatus.CREATE_FAILED
RUNNING = KxClusterStatus.RUNNING
UPDATING = KxClusterStatus.UPDATING
DELETING = KxClusterStatus.DELETING
DELETED = KxClusterStatus.DELETED
DELETE_FAILED = KxClusterStatus.DELETE_FAILED
HDB = KxClusterType.HDB
RDB = KxClusterType.RDB
GATEWAY = KxClusterType.GATEWAY
GP = KxClusterType.GP
TICKERPLANT = KxClusterType.TICKERPLANT
CREATING = KxDataviewStatus.CREATING
ACTIVE = KxDataviewStatus.ACTIVE
UPDATING = KxDataviewStatus.UPDATING
FAILED = KxDataviewStatus.FAILED
DELETING = KxDataviewStatus.DELETING
NO_RESTART = KxDeploymentStrategy.NO_RESTART
ROLLING = KxDeploymentStrategy.ROLLING
SSD_1000 = KxNAS1Type.SSD_1000
SSD_250 = KxNAS1Type.SSD_250
HDD_12 = KxNAS1Type.HDD_12
RUNNING = KxNodeStatus.RUNNING
PROVISIONING = KxNodeStatus.PROVISIONING
SDS01 = KxSavedownStorageType.SDS01
CREATING = KxScalingGroupStatus.CREATING
CREATE_FAILED = KxScalingGroupStatus.CREATE_FAILED
ACTIVE = KxScalingGroupStatus.ACTIVE
DELETING = KxScalingGroupStatus.DELETING
DELETED = KxScalingGroupStatus.DELETED
DELETE_FAILED = KxScalingGroupStatus.DELETE_FAILED
CREATING = KxVolumeStatus.CREATING
CREATE_FAILED = KxVolumeStatus.CREATE_FAILED
ACTIVE = KxVolumeStatus.ACTIVE
UPDATING = KxVolumeStatus.UPDATING
UPDATED = KxVolumeStatus.UPDATED
UPDATE_FAILED = KxVolumeStatus.UPDATE_FAILED
DELETING = KxVolumeStatus.DELETING
DELETED = KxVolumeStatus.DELETED
DELETE_FAILED = KxVolumeStatus.DELETE_FAILED
NAS_1 = KxVolumeType.NAS_1
ALLOW = RuleAction.ALLOW
DENY = RuleAction.DENY
NAS_1 = VolumeType.NAS_1
NONE = dnsStatus.NONE
UPDATE_REQUESTED = dnsStatus.UPDATE_REQUESTED
UPDATING = dnsStatus.UPDATING
FAILED_UPDATE = dnsStatus.FAILED_UPDATE
SUCCESSFULLY_UPDATED = dnsStatus.SUCCESSFULLY_UPDATED
NONE = tgwStatus.NONE
UPDATE_REQUESTED = tgwStatus.UPDATE_REQUESTED
UPDATING = tgwStatus.UPDATING
FAILED_UPDATE = tgwStatus.FAILED_UPDATE
SUCCESSFULLY_UPDATED = tgwStatus.SUCCESSFULLY_UPDATED


@dataclass
class AttributeMapItems:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fin"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class FederationParameters:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fin"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attribute_map: Optional[list[AttributeMapItems]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    federation_provider_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    saml_metadata_url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    federation_urn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    saml_metadata_document: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    application_call_back_url: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.attribute_map is not None:
            if hasattr(self.attribute_map, 'to_dict'):
                props['AttributeMap'] = self.attribute_map.to_dict()
            elif isinstance(self.attribute_map, list):
                props['AttributeMap'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attribute_map
                ]
            else:
                props['AttributeMap'] = self.attribute_map

        if self.federation_provider_name is not None:
            if hasattr(self.federation_provider_name, 'to_dict'):
                props['FederationProviderName'] = self.federation_provider_name.to_dict()
            elif isinstance(self.federation_provider_name, list):
                props['FederationProviderName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.federation_provider_name
                ]
            else:
                props['FederationProviderName'] = self.federation_provider_name

        if self.saml_metadata_url is not None:
            if hasattr(self.saml_metadata_url, 'to_dict'):
                props['SamlMetadataURL'] = self.saml_metadata_url.to_dict()
            elif isinstance(self.saml_metadata_url, list):
                props['SamlMetadataURL'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.saml_metadata_url
                ]
            else:
                props['SamlMetadataURL'] = self.saml_metadata_url

        if self.federation_urn is not None:
            if hasattr(self.federation_urn, 'to_dict'):
                props['FederationURN'] = self.federation_urn.to_dict()
            elif isinstance(self.federation_urn, list):
                props['FederationURN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.federation_urn
                ]
            else:
                props['FederationURN'] = self.federation_urn

        if self.saml_metadata_document is not None:
            if hasattr(self.saml_metadata_document, 'to_dict'):
                props['SamlMetadataDocument'] = self.saml_metadata_document.to_dict()
            elif isinstance(self.saml_metadata_document, list):
                props['SamlMetadataDocument'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.saml_metadata_document
                ]
            else:
                props['SamlMetadataDocument'] = self.saml_metadata_document

        if self.application_call_back_url is not None:
            if hasattr(self.application_call_back_url, 'to_dict'):
                props['ApplicationCallBackURL'] = self.application_call_back_url.to_dict()
            elif isinstance(self.application_call_back_url, list):
                props['ApplicationCallBackURL'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.application_call_back_url
                ]
            else:
                props['ApplicationCallBackURL'] = self.application_call_back_url

        return props


@dataclass
class SuperuserParameters:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-fin"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    first_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    last_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    email_address: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.first_name is not None:
            if hasattr(self.first_name, 'to_dict'):
                props['FirstName'] = self.first_name.to_dict()
            elif isinstance(self.first_name, list):
                props['FirstName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.first_name
                ]
            else:
                props['FirstName'] = self.first_name

        if self.last_name is not None:
            if hasattr(self.last_name, 'to_dict'):
                props['LastName'] = self.last_name.to_dict()
            elif isinstance(self.last_name, list):
                props['LastName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.last_name
                ]
            else:
                props['LastName'] = self.last_name

        if self.email_address is not None:
            if hasattr(self.email_address, 'to_dict'):
                props['EmailAddress'] = self.email_address.to_dict()
            elif isinstance(self.email_address, list):
                props['EmailAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.email_address
                ]
            else:
                props['EmailAddress'] = self.email_address

        return props


@dataclass
class Environment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-finsp"""

    resource_type: ClassVar[str] = "AWS::FinSpace::Environment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    federation_parameters: Optional[FederationParameters] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    federation_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    superuser_parameters: Optional[SuperuserParameters] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.kms_key_id is not None:
            # Serialize kms_key_id (handle intrinsic functions)
            if hasattr(self.kms_key_id, 'to_dict'):
                props["KmsKeyId"] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props["KmsKeyId"] = self.kms_key_id

        if self.federation_parameters is not None:
            # Serialize federation_parameters (handle intrinsic functions)
            if hasattr(self.federation_parameters, 'to_dict'):
                props["FederationParameters"] = self.federation_parameters.to_dict()
            elif isinstance(self.federation_parameters, list):
                # Serialize list items (may contain intrinsic functions)
                props['FederationParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.federation_parameters
                ]
            else:
                props["FederationParameters"] = self.federation_parameters

        if self.federation_mode is not None:
            # Serialize federation_mode (handle intrinsic functions)
            if hasattr(self.federation_mode, 'to_dict'):
                props["FederationMode"] = self.federation_mode.to_dict()
            elif isinstance(self.federation_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['FederationMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.federation_mode
                ]
            else:
                props["FederationMode"] = self.federation_mode

        if self.superuser_parameters is not None:
            # Serialize superuser_parameters (handle intrinsic functions)
            if hasattr(self.superuser_parameters, 'to_dict'):
                props["SuperuserParameters"] = self.superuser_parameters.to_dict()
            elif isinstance(self.superuser_parameters, list):
                # Serialize list items (may contain intrinsic functions)
                props['SuperuserParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.superuser_parameters
                ]
            else:
                props["SuperuserParameters"] = self.superuser_parameters

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_environment_id(self) -> GetAtt:
        """Get the EnvironmentId attribute."""
        return self.get_att("EnvironmentId")

    @property
    def attr_environment_arn(self) -> GetAtt:
        """Get the EnvironmentArn attribute."""
        return self.get_att("EnvironmentArn")

    @property
    def attr_sage_maker_studio_domain_url(self) -> GetAtt:
        """Get the SageMakerStudioDomainUrl attribute."""
        return self.get_att("SageMakerStudioDomainUrl")

    @property
    def attr_environment_url(self) -> GetAtt:
        """Get the EnvironmentUrl attribute."""
        return self.get_att("EnvironmentUrl")

    @property
    def attr_aws_account_id(self) -> GetAtt:
        """Get the AwsAccountId attribute."""
        return self.get_att("AwsAccountId")

    @property
    def attr_dedicated_service_account_id(self) -> GetAtt:
        """Get the DedicatedServiceAccountId attribute."""
        return self.get_att("DedicatedServiceAccountId")



