"""
AWS CloudFormation CE Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:35

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service CE
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AccountScope:
    """AccountScope enum values."""

    PAYER = "PAYER"
    LINKED = "LINKED"


class AnalysisStatus:
    """AnalysisStatus enum values."""

    SUCCEEDED = "SUCCEEDED"
    PROCESSING = "PROCESSING"
    FAILED = "FAILED"


class AnalysisType:
    """AnalysisType enum values."""

    MAX_SAVINGS = "MAX_SAVINGS"
    CUSTOM_COMMITMENT = "CUSTOM_COMMITMENT"


class AnomalyFeedbackType:
    """AnomalyFeedbackType enum values."""

    YES = "YES"
    NO = "NO"
    PLANNED_ACTIVITY = "PLANNED_ACTIVITY"


class AnomalySubscriptionFrequency:
    """AnomalySubscriptionFrequency enum values."""

    DAILY = "DAILY"
    IMMEDIATE = "IMMEDIATE"
    WEEKLY = "WEEKLY"


class ApproximationDimension:
    """ApproximationDimension enum values."""

    SERVICE = "SERVICE"
    RESOURCE = "RESOURCE"


class Context:
    """Context enum values."""

    COST_AND_USAGE = "COST_AND_USAGE"
    RESERVATIONS = "RESERVATIONS"
    SAVINGS_PLANS = "SAVINGS_PLANS"


class CostAllocationTagBackfillStatus:
    """CostAllocationTagBackfillStatus enum values."""

    SUCCEEDED = "SUCCEEDED"
    PROCESSING = "PROCESSING"
    FAILED = "FAILED"


class CostAllocationTagStatus:
    """CostAllocationTagStatus enum values."""

    ACTIVE = "Active"
    INACTIVE = "Inactive"


class CostAllocationTagType:
    """CostAllocationTagType enum values."""

    AWSGENERATED = "AWSGenerated"
    USERDEFINED = "UserDefined"


class CostCategoryInheritedValueDimensionName:
    """CostCategoryInheritedValueDimensionName enum values."""

    LINKED_ACCOUNT_NAME = "LINKED_ACCOUNT_NAME"
    TAG = "TAG"


class CostCategoryRuleType:
    """CostCategoryRuleType enum values."""

    REGULAR = "REGULAR"
    INHERITED_VALUE = "INHERITED_VALUE"


class CostCategoryRuleVersion:
    """CostCategoryRuleVersion enum values."""

    COSTCATEGORYEXPRESSION_V1 = "CostCategoryExpression.v1"


class CostCategorySplitChargeMethod:
    """CostCategorySplitChargeMethod enum values."""

    FIXED = "FIXED"
    PROPORTIONAL = "PROPORTIONAL"
    EVEN = "EVEN"


class CostCategorySplitChargeRuleParameterType:
    """CostCategorySplitChargeRuleParameterType enum values."""

    ALLOCATION_PERCENTAGES = "ALLOCATION_PERCENTAGES"


class CostCategoryStatus:
    """CostCategoryStatus enum values."""

    PROCESSING = "PROCESSING"
    APPLIED = "APPLIED"


class CostCategoryStatusComponent:
    """CostCategoryStatusComponent enum values."""

    COST_EXPLORER = "COST_EXPLORER"


class Dimension:
    """Dimension enum values."""

    AZ = "AZ"
    INSTANCE_TYPE = "INSTANCE_TYPE"
    LINKED_ACCOUNT = "LINKED_ACCOUNT"
    PAYER_ACCOUNT = "PAYER_ACCOUNT"
    LINKED_ACCOUNT_NAME = "LINKED_ACCOUNT_NAME"
    OPERATION = "OPERATION"
    PURCHASE_TYPE = "PURCHASE_TYPE"
    REGION = "REGION"
    SERVICE = "SERVICE"
    SERVICE_CODE = "SERVICE_CODE"
    USAGE_TYPE = "USAGE_TYPE"
    USAGE_TYPE_GROUP = "USAGE_TYPE_GROUP"
    RECORD_TYPE = "RECORD_TYPE"
    OPERATING_SYSTEM = "OPERATING_SYSTEM"
    TENANCY = "TENANCY"
    SCOPE = "SCOPE"
    PLATFORM = "PLATFORM"
    SUBSCRIPTION_ID = "SUBSCRIPTION_ID"
    LEGAL_ENTITY_NAME = "LEGAL_ENTITY_NAME"
    DEPLOYMENT_OPTION = "DEPLOYMENT_OPTION"
    DATABASE_ENGINE = "DATABASE_ENGINE"
    CACHE_ENGINE = "CACHE_ENGINE"
    INSTANCE_TYPE_FAMILY = "INSTANCE_TYPE_FAMILY"
    BILLING_ENTITY = "BILLING_ENTITY"
    RESERVATION_ID = "RESERVATION_ID"
    RESOURCE_ID = "RESOURCE_ID"
    RIGHTSIZING_TYPE = "RIGHTSIZING_TYPE"
    SAVINGS_PLANS_TYPE = "SAVINGS_PLANS_TYPE"
    SAVINGS_PLAN_ARN = "SAVINGS_PLAN_ARN"
    PAYMENT_OPTION = "PAYMENT_OPTION"
    AGREEMENT_END_DATE_TIME_AFTER = "AGREEMENT_END_DATE_TIME_AFTER"
    AGREEMENT_END_DATE_TIME_BEFORE = "AGREEMENT_END_DATE_TIME_BEFORE"
    INVOICING_ENTITY = "INVOICING_ENTITY"
    ANOMALY_TOTAL_IMPACT_ABSOLUTE = "ANOMALY_TOTAL_IMPACT_ABSOLUTE"
    ANOMALY_TOTAL_IMPACT_PERCENTAGE = "ANOMALY_TOTAL_IMPACT_PERCENTAGE"


class ErrorCode:
    """ErrorCode enum values."""

    NO_USAGE_FOUND = "NO_USAGE_FOUND"
    INTERNAL_FAILURE = "INTERNAL_FAILURE"
    INVALID_SAVINGS_PLANS_TO_ADD = "INVALID_SAVINGS_PLANS_TO_ADD"
    INVALID_SAVINGS_PLANS_TO_EXCLUDE = "INVALID_SAVINGS_PLANS_TO_EXCLUDE"
    INVALID_ACCOUNT_ID = "INVALID_ACCOUNT_ID"


class FindingReasonCode:
    """FindingReasonCode enum values."""

    CPU_OVER_PROVISIONED = "CPU_OVER_PROVISIONED"
    CPU_UNDER_PROVISIONED = "CPU_UNDER_PROVISIONED"
    MEMORY_OVER_PROVISIONED = "MEMORY_OVER_PROVISIONED"
    MEMORY_UNDER_PROVISIONED = "MEMORY_UNDER_PROVISIONED"
    EBS_THROUGHPUT_OVER_PROVISIONED = "EBS_THROUGHPUT_OVER_PROVISIONED"
    EBS_THROUGHPUT_UNDER_PROVISIONED = "EBS_THROUGHPUT_UNDER_PROVISIONED"
    EBS_IOPS_OVER_PROVISIONED = "EBS_IOPS_OVER_PROVISIONED"
    EBS_IOPS_UNDER_PROVISIONED = "EBS_IOPS_UNDER_PROVISIONED"
    NETWORK_BANDWIDTH_OVER_PROVISIONED = "NETWORK_BANDWIDTH_OVER_PROVISIONED"
    NETWORK_BANDWIDTH_UNDER_PROVISIONED = "NETWORK_BANDWIDTH_UNDER_PROVISIONED"
    NETWORK_PPS_OVER_PROVISIONED = "NETWORK_PPS_OVER_PROVISIONED"
    NETWORK_PPS_UNDER_PROVISIONED = "NETWORK_PPS_UNDER_PROVISIONED"
    DISK_IOPS_OVER_PROVISIONED = "DISK_IOPS_OVER_PROVISIONED"
    DISK_IOPS_UNDER_PROVISIONED = "DISK_IOPS_UNDER_PROVISIONED"
    DISK_THROUGHPUT_OVER_PROVISIONED = "DISK_THROUGHPUT_OVER_PROVISIONED"
    DISK_THROUGHPUT_UNDER_PROVISIONED = "DISK_THROUGHPUT_UNDER_PROVISIONED"


class GenerationStatus:
    """GenerationStatus enum values."""

    SUCCEEDED = "SUCCEEDED"
    PROCESSING = "PROCESSING"
    FAILED = "FAILED"


class Granularity:
    """Granularity enum values."""

    DAILY = "DAILY"
    MONTHLY = "MONTHLY"
    HOURLY = "HOURLY"


class GroupDefinitionType:
    """GroupDefinitionType enum values."""

    DIMENSION = "DIMENSION"
    TAG = "TAG"
    COST_CATEGORY = "COST_CATEGORY"


class LookbackPeriodInDays:
    """LookbackPeriodInDays enum values."""

    SEVEN_DAYS = "SEVEN_DAYS"
    THIRTY_DAYS = "THIRTY_DAYS"
    SIXTY_DAYS = "SIXTY_DAYS"


class MatchOption:
    """MatchOption enum values."""

    EQUALS = "EQUALS"
    ABSENT = "ABSENT"
    STARTS_WITH = "STARTS_WITH"
    ENDS_WITH = "ENDS_WITH"
    CONTAINS = "CONTAINS"
    CASE_SENSITIVE = "CASE_SENSITIVE"
    CASE_INSENSITIVE = "CASE_INSENSITIVE"
    GREATER_THAN_OR_EQUAL = "GREATER_THAN_OR_EQUAL"


class Metric:
    """Metric enum values."""

    BLENDED_COST = "BLENDED_COST"
    UNBLENDED_COST = "UNBLENDED_COST"
    AMORTIZED_COST = "AMORTIZED_COST"
    NET_UNBLENDED_COST = "NET_UNBLENDED_COST"
    NET_AMORTIZED_COST = "NET_AMORTIZED_COST"
    USAGE_QUANTITY = "USAGE_QUANTITY"
    NORMALIZED_USAGE_AMOUNT = "NORMALIZED_USAGE_AMOUNT"


class MonitorDimension:
    """MonitorDimension enum values."""

    SERVICE = "SERVICE"
    LINKED_ACCOUNT = "LINKED_ACCOUNT"
    TAG = "TAG"
    COST_CATEGORY = "COST_CATEGORY"


class MonitorType:
    """MonitorType enum values."""

    DIMENSIONAL = "DIMENSIONAL"
    CUSTOM = "CUSTOM"


class NumericOperator:
    """NumericOperator enum values."""

    EQUAL = "EQUAL"
    GREATER_THAN_OR_EQUAL = "GREATER_THAN_OR_EQUAL"
    LESS_THAN_OR_EQUAL = "LESS_THAN_OR_EQUAL"
    GREATER_THAN = "GREATER_THAN"
    LESS_THAN = "LESS_THAN"
    BETWEEN = "BETWEEN"


class OfferingClass:
    """OfferingClass enum values."""

    STANDARD = "STANDARD"
    CONVERTIBLE = "CONVERTIBLE"


class PaymentOption:
    """PaymentOption enum values."""

    NO_UPFRONT = "NO_UPFRONT"
    PARTIAL_UPFRONT = "PARTIAL_UPFRONT"
    ALL_UPFRONT = "ALL_UPFRONT"
    LIGHT_UTILIZATION = "LIGHT_UTILIZATION"
    MEDIUM_UTILIZATION = "MEDIUM_UTILIZATION"
    HEAVY_UTILIZATION = "HEAVY_UTILIZATION"


class PlatformDifference:
    """PlatformDifference enum values."""

    HYPERVISOR = "HYPERVISOR"
    NETWORK_INTERFACE = "NETWORK_INTERFACE"
    STORAGE_INTERFACE = "STORAGE_INTERFACE"
    INSTANCE_STORE_AVAILABILITY = "INSTANCE_STORE_AVAILABILITY"
    VIRTUALIZATION_TYPE = "VIRTUALIZATION_TYPE"


class RecommendationTarget:
    """RecommendationTarget enum values."""

    SAME_INSTANCE_FAMILY = "SAME_INSTANCE_FAMILY"
    CROSS_INSTANCE_FAMILY = "CROSS_INSTANCE_FAMILY"


class RightsizingType:
    """RightsizingType enum values."""

    TERMINATE = "TERMINATE"
    MODIFY = "MODIFY"


class SavingsPlansDataType:
    """SavingsPlansDataType enum values."""

    ATTRIBUTES = "ATTRIBUTES"
    UTILIZATION = "UTILIZATION"
    AMORTIZED_COMMITMENT = "AMORTIZED_COMMITMENT"
    SAVINGS = "SAVINGS"


class SortOrder:
    """SortOrder enum values."""

    ASCENDING = "ASCENDING"
    DESCENDING = "DESCENDING"


class SubscriberStatus:
    """SubscriberStatus enum values."""

    CONFIRMED = "CONFIRMED"
    DECLINED = "DECLINED"


class SubscriberType:
    """SubscriberType enum values."""

    EMAIL = "EMAIL"
    SNS = "SNS"


class SupportedSavingsPlansType:
    """SupportedSavingsPlansType enum values."""

    COMPUTE_SP = "COMPUTE_SP"
    EC2_INSTANCE_SP = "EC2_INSTANCE_SP"
    SAGEMAKER_SP = "SAGEMAKER_SP"
    DATABASE_SP = "DATABASE_SP"


class TermInYears:
    """TermInYears enum values."""

    ONE_YEAR = "ONE_YEAR"
    THREE_YEARS = "THREE_YEARS"


# Convenient aliases for enum values
PAYER = AccountScope.PAYER
LINKED = AccountScope.LINKED
SUCCEEDED = AnalysisStatus.SUCCEEDED
PROCESSING = AnalysisStatus.PROCESSING
FAILED = AnalysisStatus.FAILED
MAX_SAVINGS = AnalysisType.MAX_SAVINGS
CUSTOM_COMMITMENT = AnalysisType.CUSTOM_COMMITMENT
YES = AnomalyFeedbackType.YES
NO = AnomalyFeedbackType.NO
PLANNED_ACTIVITY = AnomalyFeedbackType.PLANNED_ACTIVITY
DAILY = AnomalySubscriptionFrequency.DAILY
IMMEDIATE = AnomalySubscriptionFrequency.IMMEDIATE
WEEKLY = AnomalySubscriptionFrequency.WEEKLY
SERVICE = ApproximationDimension.SERVICE
RESOURCE = ApproximationDimension.RESOURCE
COST_AND_USAGE = Context.COST_AND_USAGE
RESERVATIONS = Context.RESERVATIONS
SAVINGS_PLANS = Context.SAVINGS_PLANS
SUCCEEDED = CostAllocationTagBackfillStatus.SUCCEEDED
PROCESSING = CostAllocationTagBackfillStatus.PROCESSING
FAILED = CostAllocationTagBackfillStatus.FAILED
ACTIVE = CostAllocationTagStatus.ACTIVE
INACTIVE = CostAllocationTagStatus.INACTIVE
AWSGENERATED = CostAllocationTagType.AWSGENERATED
USERDEFINED = CostAllocationTagType.USERDEFINED
LINKED_ACCOUNT_NAME = CostCategoryInheritedValueDimensionName.LINKED_ACCOUNT_NAME
TAG = CostCategoryInheritedValueDimensionName.TAG
REGULAR = CostCategoryRuleType.REGULAR
INHERITED_VALUE = CostCategoryRuleType.INHERITED_VALUE
COSTCATEGORYEXPRESSION_V1 = CostCategoryRuleVersion.COSTCATEGORYEXPRESSION_V1
FIXED = CostCategorySplitChargeMethod.FIXED
PROPORTIONAL = CostCategorySplitChargeMethod.PROPORTIONAL
EVEN = CostCategorySplitChargeMethod.EVEN
ALLOCATION_PERCENTAGES = CostCategorySplitChargeRuleParameterType.ALLOCATION_PERCENTAGES
PROCESSING = CostCategoryStatus.PROCESSING
APPLIED = CostCategoryStatus.APPLIED
COST_EXPLORER = CostCategoryStatusComponent.COST_EXPLORER
AZ = Dimension.AZ
INSTANCE_TYPE = Dimension.INSTANCE_TYPE
LINKED_ACCOUNT = Dimension.LINKED_ACCOUNT
PAYER_ACCOUNT = Dimension.PAYER_ACCOUNT
LINKED_ACCOUNT_NAME = Dimension.LINKED_ACCOUNT_NAME
OPERATION = Dimension.OPERATION
PURCHASE_TYPE = Dimension.PURCHASE_TYPE
REGION = Dimension.REGION
SERVICE = Dimension.SERVICE
SERVICE_CODE = Dimension.SERVICE_CODE
USAGE_TYPE = Dimension.USAGE_TYPE
USAGE_TYPE_GROUP = Dimension.USAGE_TYPE_GROUP
RECORD_TYPE = Dimension.RECORD_TYPE
OPERATING_SYSTEM = Dimension.OPERATING_SYSTEM
TENANCY = Dimension.TENANCY
SCOPE = Dimension.SCOPE
PLATFORM = Dimension.PLATFORM
SUBSCRIPTION_ID = Dimension.SUBSCRIPTION_ID
LEGAL_ENTITY_NAME = Dimension.LEGAL_ENTITY_NAME
DEPLOYMENT_OPTION = Dimension.DEPLOYMENT_OPTION
DATABASE_ENGINE = Dimension.DATABASE_ENGINE
CACHE_ENGINE = Dimension.CACHE_ENGINE
INSTANCE_TYPE_FAMILY = Dimension.INSTANCE_TYPE_FAMILY
BILLING_ENTITY = Dimension.BILLING_ENTITY
RESERVATION_ID = Dimension.RESERVATION_ID
RESOURCE_ID = Dimension.RESOURCE_ID
RIGHTSIZING_TYPE = Dimension.RIGHTSIZING_TYPE
SAVINGS_PLANS_TYPE = Dimension.SAVINGS_PLANS_TYPE
SAVINGS_PLAN_ARN = Dimension.SAVINGS_PLAN_ARN
PAYMENT_OPTION = Dimension.PAYMENT_OPTION
AGREEMENT_END_DATE_TIME_AFTER = Dimension.AGREEMENT_END_DATE_TIME_AFTER
AGREEMENT_END_DATE_TIME_BEFORE = Dimension.AGREEMENT_END_DATE_TIME_BEFORE
INVOICING_ENTITY = Dimension.INVOICING_ENTITY
ANOMALY_TOTAL_IMPACT_ABSOLUTE = Dimension.ANOMALY_TOTAL_IMPACT_ABSOLUTE
ANOMALY_TOTAL_IMPACT_PERCENTAGE = Dimension.ANOMALY_TOTAL_IMPACT_PERCENTAGE
NO_USAGE_FOUND = ErrorCode.NO_USAGE_FOUND
INTERNAL_FAILURE = ErrorCode.INTERNAL_FAILURE
INVALID_SAVINGS_PLANS_TO_ADD = ErrorCode.INVALID_SAVINGS_PLANS_TO_ADD
INVALID_SAVINGS_PLANS_TO_EXCLUDE = ErrorCode.INVALID_SAVINGS_PLANS_TO_EXCLUDE
INVALID_ACCOUNT_ID = ErrorCode.INVALID_ACCOUNT_ID
CPU_OVER_PROVISIONED = FindingReasonCode.CPU_OVER_PROVISIONED
CPU_UNDER_PROVISIONED = FindingReasonCode.CPU_UNDER_PROVISIONED
MEMORY_OVER_PROVISIONED = FindingReasonCode.MEMORY_OVER_PROVISIONED
MEMORY_UNDER_PROVISIONED = FindingReasonCode.MEMORY_UNDER_PROVISIONED
EBS_THROUGHPUT_OVER_PROVISIONED = FindingReasonCode.EBS_THROUGHPUT_OVER_PROVISIONED
EBS_THROUGHPUT_UNDER_PROVISIONED = FindingReasonCode.EBS_THROUGHPUT_UNDER_PROVISIONED
EBS_IOPS_OVER_PROVISIONED = FindingReasonCode.EBS_IOPS_OVER_PROVISIONED
EBS_IOPS_UNDER_PROVISIONED = FindingReasonCode.EBS_IOPS_UNDER_PROVISIONED
NETWORK_BANDWIDTH_OVER_PROVISIONED = FindingReasonCode.NETWORK_BANDWIDTH_OVER_PROVISIONED
NETWORK_BANDWIDTH_UNDER_PROVISIONED = FindingReasonCode.NETWORK_BANDWIDTH_UNDER_PROVISIONED
NETWORK_PPS_OVER_PROVISIONED = FindingReasonCode.NETWORK_PPS_OVER_PROVISIONED
NETWORK_PPS_UNDER_PROVISIONED = FindingReasonCode.NETWORK_PPS_UNDER_PROVISIONED
DISK_IOPS_OVER_PROVISIONED = FindingReasonCode.DISK_IOPS_OVER_PROVISIONED
DISK_IOPS_UNDER_PROVISIONED = FindingReasonCode.DISK_IOPS_UNDER_PROVISIONED
DISK_THROUGHPUT_OVER_PROVISIONED = FindingReasonCode.DISK_THROUGHPUT_OVER_PROVISIONED
DISK_THROUGHPUT_UNDER_PROVISIONED = FindingReasonCode.DISK_THROUGHPUT_UNDER_PROVISIONED
SUCCEEDED = GenerationStatus.SUCCEEDED
PROCESSING = GenerationStatus.PROCESSING
FAILED = GenerationStatus.FAILED
DAILY = Granularity.DAILY
MONTHLY = Granularity.MONTHLY
HOURLY = Granularity.HOURLY
DIMENSION = GroupDefinitionType.DIMENSION
TAG = GroupDefinitionType.TAG
COST_CATEGORY = GroupDefinitionType.COST_CATEGORY
SEVEN_DAYS = LookbackPeriodInDays.SEVEN_DAYS
THIRTY_DAYS = LookbackPeriodInDays.THIRTY_DAYS
SIXTY_DAYS = LookbackPeriodInDays.SIXTY_DAYS
EQUALS = MatchOption.EQUALS
ABSENT = MatchOption.ABSENT
STARTS_WITH = MatchOption.STARTS_WITH
ENDS_WITH = MatchOption.ENDS_WITH
CONTAINS = MatchOption.CONTAINS
CASE_SENSITIVE = MatchOption.CASE_SENSITIVE
CASE_INSENSITIVE = MatchOption.CASE_INSENSITIVE
GREATER_THAN_OR_EQUAL = MatchOption.GREATER_THAN_OR_EQUAL
BLENDED_COST = Metric.BLENDED_COST
UNBLENDED_COST = Metric.UNBLENDED_COST
AMORTIZED_COST = Metric.AMORTIZED_COST
NET_UNBLENDED_COST = Metric.NET_UNBLENDED_COST
NET_AMORTIZED_COST = Metric.NET_AMORTIZED_COST
USAGE_QUANTITY = Metric.USAGE_QUANTITY
NORMALIZED_USAGE_AMOUNT = Metric.NORMALIZED_USAGE_AMOUNT
SERVICE = MonitorDimension.SERVICE
LINKED_ACCOUNT = MonitorDimension.LINKED_ACCOUNT
TAG = MonitorDimension.TAG
COST_CATEGORY = MonitorDimension.COST_CATEGORY
DIMENSIONAL = MonitorType.DIMENSIONAL
CUSTOM = MonitorType.CUSTOM
EQUAL = NumericOperator.EQUAL
GREATER_THAN_OR_EQUAL = NumericOperator.GREATER_THAN_OR_EQUAL
LESS_THAN_OR_EQUAL = NumericOperator.LESS_THAN_OR_EQUAL
GREATER_THAN = NumericOperator.GREATER_THAN
LESS_THAN = NumericOperator.LESS_THAN
BETWEEN = NumericOperator.BETWEEN
STANDARD = OfferingClass.STANDARD
CONVERTIBLE = OfferingClass.CONVERTIBLE
NO_UPFRONT = PaymentOption.NO_UPFRONT
PARTIAL_UPFRONT = PaymentOption.PARTIAL_UPFRONT
ALL_UPFRONT = PaymentOption.ALL_UPFRONT
LIGHT_UTILIZATION = PaymentOption.LIGHT_UTILIZATION
MEDIUM_UTILIZATION = PaymentOption.MEDIUM_UTILIZATION
HEAVY_UTILIZATION = PaymentOption.HEAVY_UTILIZATION
HYPERVISOR = PlatformDifference.HYPERVISOR
NETWORK_INTERFACE = PlatformDifference.NETWORK_INTERFACE
STORAGE_INTERFACE = PlatformDifference.STORAGE_INTERFACE
INSTANCE_STORE_AVAILABILITY = PlatformDifference.INSTANCE_STORE_AVAILABILITY
VIRTUALIZATION_TYPE = PlatformDifference.VIRTUALIZATION_TYPE
SAME_INSTANCE_FAMILY = RecommendationTarget.SAME_INSTANCE_FAMILY
CROSS_INSTANCE_FAMILY = RecommendationTarget.CROSS_INSTANCE_FAMILY
TERMINATE = RightsizingType.TERMINATE
MODIFY = RightsizingType.MODIFY
ATTRIBUTES = SavingsPlansDataType.ATTRIBUTES
UTILIZATION = SavingsPlansDataType.UTILIZATION
AMORTIZED_COMMITMENT = SavingsPlansDataType.AMORTIZED_COMMITMENT
SAVINGS = SavingsPlansDataType.SAVINGS
ASCENDING = SortOrder.ASCENDING
DESCENDING = SortOrder.DESCENDING
CONFIRMED = SubscriberStatus.CONFIRMED
DECLINED = SubscriberStatus.DECLINED
EMAIL = SubscriberType.EMAIL
SNS = SubscriberType.SNS
COMPUTE_SP = SupportedSavingsPlansType.COMPUTE_SP
EC2_INSTANCE_SP = SupportedSavingsPlansType.EC2_INSTANCE_SP
SAGEMAKER_SP = SupportedSavingsPlansType.SAGEMAKER_SP
DATABASE_SP = SupportedSavingsPlansType.DATABASE_SP
ONE_YEAR = TermInYears.ONE_YEAR
THREE_YEARS = TermInYears.THREE_YEARS


@dataclass
class ResourceTag:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ce-"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class AnomalyMonitor(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ce-an"""

    resource_type: ClassVar[str] = "AWS::CE::AnomalyMonitor"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    monitor_type: Optional[Union[str, MonitorType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_tags: Optional[list[ResourceTag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    monitor_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    monitor_specification: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    monitor_dimension: Optional[Union[str, MonitorDimension, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.monitor_type is not None:
            # Serialize monitor_type (handle intrinsic functions)
            if hasattr(self.monitor_type, 'to_dict'):
                props["MonitorType"] = self.monitor_type.to_dict()
            elif isinstance(self.monitor_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['MonitorType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitor_type
                ]
            else:
                props["MonitorType"] = self.monitor_type

        if self.resource_tags is not None:
            # Serialize resource_tags (handle intrinsic functions)
            if hasattr(self.resource_tags, 'to_dict'):
                props["ResourceTags"] = self.resource_tags.to_dict()
            elif isinstance(self.resource_tags, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceTags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_tags
                ]
            else:
                props["ResourceTags"] = self.resource_tags

        if self.monitor_name is not None:
            # Serialize monitor_name (handle intrinsic functions)
            if hasattr(self.monitor_name, 'to_dict'):
                props["MonitorName"] = self.monitor_name.to_dict()
            elif isinstance(self.monitor_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['MonitorName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitor_name
                ]
            else:
                props["MonitorName"] = self.monitor_name

        if self.monitor_specification is not None:
            # Serialize monitor_specification (handle intrinsic functions)
            if hasattr(self.monitor_specification, 'to_dict'):
                props["MonitorSpecification"] = self.monitor_specification.to_dict()
            elif isinstance(self.monitor_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['MonitorSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitor_specification
                ]
            else:
                props["MonitorSpecification"] = self.monitor_specification

        if self.monitor_dimension is not None:
            # Serialize monitor_dimension (handle intrinsic functions)
            if hasattr(self.monitor_dimension, 'to_dict'):
                props["MonitorDimension"] = self.monitor_dimension.to_dict()
            elif isinstance(self.monitor_dimension, list):
                # Serialize list items (may contain intrinsic functions)
                props['MonitorDimension'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitor_dimension
                ]
            else:
                props["MonitorDimension"] = self.monitor_dimension

        return props

    @property
    def attr_last_updated_date(self) -> GetAtt:
        """Get the LastUpdatedDate attribute."""
        return self.get_att("LastUpdatedDate")

    @property
    def attr_creation_date(self) -> GetAtt:
        """Get the CreationDate attribute."""
        return self.get_att("CreationDate")

    @property
    def attr_last_evaluated_date(self) -> GetAtt:
        """Get the LastEvaluatedDate attribute."""
        return self.get_att("LastEvaluatedDate")

    @property
    def attr_monitor_arn(self) -> GetAtt:
        """Get the MonitorArn attribute."""
        return self.get_att("MonitorArn")

    @property
    def attr_dimensional_value_count(self) -> GetAtt:
        """Get the DimensionalValueCount attribute."""
        return self.get_att("DimensionalValueCount")




@dataclass
class ResourceTag:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ce-"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class Subscriber:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ce-"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    status: Optional[Union[str, SubscriberStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, SubscriberType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    address: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.status is not None:
            if hasattr(self.status, 'to_dict'):
                props['Status'] = self.status.to_dict()
            elif isinstance(self.status, list):
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props['Status'] = self.status

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.address is not None:
            if hasattr(self.address, 'to_dict'):
                props['Address'] = self.address.to_dict()
            elif isinstance(self.address, list):
                props['Address'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.address
                ]
            else:
                props['Address'] = self.address

        return props


@dataclass
class AnomalySubscription(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ce-an"""

    resource_type: ClassVar[str] = "AWS::CE::AnomalySubscription"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    monitor_arn_list: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_tags: Optional[list[ResourceTag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    frequency: Optional[Union[str, AnomalySubscriptionFrequency, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subscription_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subscribers: Optional[list[Subscriber]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    threshold: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    threshold_expression: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.monitor_arn_list is not None:
            # Serialize monitor_arn_list (handle intrinsic functions)
            if hasattr(self.monitor_arn_list, 'to_dict'):
                props["MonitorArnList"] = self.monitor_arn_list.to_dict()
            elif isinstance(self.monitor_arn_list, list):
                # Serialize list items (may contain intrinsic functions)
                props['MonitorArnList'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitor_arn_list
                ]
            else:
                props["MonitorArnList"] = self.monitor_arn_list

        if self.resource_tags is not None:
            # Serialize resource_tags (handle intrinsic functions)
            if hasattr(self.resource_tags, 'to_dict'):
                props["ResourceTags"] = self.resource_tags.to_dict()
            elif isinstance(self.resource_tags, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceTags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_tags
                ]
            else:
                props["ResourceTags"] = self.resource_tags

        if self.frequency is not None:
            # Serialize frequency (handle intrinsic functions)
            if hasattr(self.frequency, 'to_dict'):
                props["Frequency"] = self.frequency.to_dict()
            elif isinstance(self.frequency, list):
                # Serialize list items (may contain intrinsic functions)
                props['Frequency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.frequency
                ]
            else:
                props["Frequency"] = self.frequency

        if self.subscription_name is not None:
            # Serialize subscription_name (handle intrinsic functions)
            if hasattr(self.subscription_name, 'to_dict'):
                props["SubscriptionName"] = self.subscription_name.to_dict()
            elif isinstance(self.subscription_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubscriptionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subscription_name
                ]
            else:
                props["SubscriptionName"] = self.subscription_name

        if self.subscribers is not None:
            # Serialize subscribers (handle intrinsic functions)
            if hasattr(self.subscribers, 'to_dict'):
                props["Subscribers"] = self.subscribers.to_dict()
            elif isinstance(self.subscribers, list):
                # Serialize list items (may contain intrinsic functions)
                props['Subscribers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subscribers
                ]
            else:
                props["Subscribers"] = self.subscribers

        if self.threshold is not None:
            # Serialize threshold (handle intrinsic functions)
            if hasattr(self.threshold, 'to_dict'):
                props["Threshold"] = self.threshold.to_dict()
            elif isinstance(self.threshold, list):
                # Serialize list items (may contain intrinsic functions)
                props['Threshold'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.threshold
                ]
            else:
                props["Threshold"] = self.threshold

        if self.threshold_expression is not None:
            # Serialize threshold_expression (handle intrinsic functions)
            if hasattr(self.threshold_expression, 'to_dict'):
                props["ThresholdExpression"] = self.threshold_expression.to_dict()
            elif isinstance(self.threshold_expression, list):
                # Serialize list items (may contain intrinsic functions)
                props['ThresholdExpression'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.threshold_expression
                ]
            else:
                props["ThresholdExpression"] = self.threshold_expression

        return props

    @property
    def attr_account_id(self) -> GetAtt:
        """Get the AccountId attribute."""
        return self.get_att("AccountId")

    @property
    def attr_subscription_arn(self) -> GetAtt:
        """Get the SubscriptionArn attribute."""
        return self.get_att("SubscriptionArn")




@dataclass
class ResourceTag:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ce-"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class CostCategory(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ce-co"""

    resource_type: ClassVar[str] = "AWS::CE::CostCategory"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    split_charge_rules: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rule_version: Optional[Union[str, CostCategoryRuleVersion, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rules: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[ResourceTag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_value is not None:
            # Serialize default_value (handle intrinsic functions)
            if hasattr(self.default_value, 'to_dict'):
                props["DefaultValue"] = self.default_value.to_dict()
            elif isinstance(self.default_value, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_value
                ]
            else:
                props["DefaultValue"] = self.default_value

        if self.split_charge_rules is not None:
            # Serialize split_charge_rules (handle intrinsic functions)
            if hasattr(self.split_charge_rules, 'to_dict'):
                props["SplitChargeRules"] = self.split_charge_rules.to_dict()
            elif isinstance(self.split_charge_rules, list):
                # Serialize list items (may contain intrinsic functions)
                props['SplitChargeRules'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.split_charge_rules
                ]
            else:
                props["SplitChargeRules"] = self.split_charge_rules

        if self.rule_version is not None:
            # Serialize rule_version (handle intrinsic functions)
            if hasattr(self.rule_version, 'to_dict'):
                props["RuleVersion"] = self.rule_version.to_dict()
            elif isinstance(self.rule_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuleVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_version
                ]
            else:
                props["RuleVersion"] = self.rule_version

        if self.rules is not None:
            # Serialize rules (handle intrinsic functions)
            if hasattr(self.rules, 'to_dict'):
                props["Rules"] = self.rules.to_dict()
            elif isinstance(self.rules, list):
                # Serialize list items (may contain intrinsic functions)
                props['Rules'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rules
                ]
            else:
                props["Rules"] = self.rules

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_effective_start(self) -> GetAtt:
        """Get the EffectiveStart attribute."""
        return self.get_att("EffectiveStart")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")



