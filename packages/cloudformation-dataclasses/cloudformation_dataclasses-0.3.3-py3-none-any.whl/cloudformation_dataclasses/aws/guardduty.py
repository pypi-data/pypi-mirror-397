"""
AWS CloudFormation GuardDuty Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:36

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service GuardDuty
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AdminStatus:
    """AdminStatus enum values."""

    ENABLED = "ENABLED"
    DISABLE_IN_PROGRESS = "DISABLE_IN_PROGRESS"


class AutoEnableMembers:
    """AutoEnableMembers enum values."""

    NEW = "NEW"
    ALL = "ALL"
    NONE = "NONE"


class ClusterStatus:
    """ClusterStatus enum values."""

    CREATING = "CREATING"
    ACTIVE = "ACTIVE"
    DELETING = "DELETING"
    FAILED = "FAILED"
    UPDATING = "UPDATING"
    PENDING = "PENDING"


class CoverageFilterCriterionKey:
    """CoverageFilterCriterionKey enum values."""

    ACCOUNT_ID = "ACCOUNT_ID"
    CLUSTER_NAME = "CLUSTER_NAME"
    RESOURCE_TYPE = "RESOURCE_TYPE"
    COVERAGE_STATUS = "COVERAGE_STATUS"
    ADDON_VERSION = "ADDON_VERSION"
    MANAGEMENT_TYPE = "MANAGEMENT_TYPE"
    EKS_CLUSTER_NAME = "EKS_CLUSTER_NAME"
    ECS_CLUSTER_NAME = "ECS_CLUSTER_NAME"
    AGENT_VERSION = "AGENT_VERSION"
    INSTANCE_ID = "INSTANCE_ID"
    CLUSTER_ARN = "CLUSTER_ARN"


class CoverageSortKey:
    """CoverageSortKey enum values."""

    ACCOUNT_ID = "ACCOUNT_ID"
    CLUSTER_NAME = "CLUSTER_NAME"
    COVERAGE_STATUS = "COVERAGE_STATUS"
    ISSUE = "ISSUE"
    ADDON_VERSION = "ADDON_VERSION"
    UPDATED_AT = "UPDATED_AT"
    EKS_CLUSTER_NAME = "EKS_CLUSTER_NAME"
    ECS_CLUSTER_NAME = "ECS_CLUSTER_NAME"
    INSTANCE_ID = "INSTANCE_ID"


class CoverageStatisticsType:
    """CoverageStatisticsType enum values."""

    COUNT_BY_RESOURCE_TYPE = "COUNT_BY_RESOURCE_TYPE"
    COUNT_BY_COVERAGE_STATUS = "COUNT_BY_COVERAGE_STATUS"


class CoverageStatus:
    """CoverageStatus enum values."""

    HEALTHY = "HEALTHY"
    UNHEALTHY = "UNHEALTHY"


class CriterionKey:
    """CriterionKey enum values."""

    EC2_INSTANCE_ARN = "EC2_INSTANCE_ARN"
    SCAN_ID = "SCAN_ID"
    ACCOUNT_ID = "ACCOUNT_ID"
    GUARDDUTY_FINDING_ID = "GUARDDUTY_FINDING_ID"
    SCAN_START_TIME = "SCAN_START_TIME"
    SCAN_STATUS = "SCAN_STATUS"
    SCAN_TYPE = "SCAN_TYPE"


class DataSource:
    """DataSource enum values."""

    FLOW_LOGS = "FLOW_LOGS"
    CLOUD_TRAIL = "CLOUD_TRAIL"
    DNS_LOGS = "DNS_LOGS"
    S3_LOGS = "S3_LOGS"
    KUBERNETES_AUDIT_LOGS = "KUBERNETES_AUDIT_LOGS"
    EC2_MALWARE_SCAN = "EC2_MALWARE_SCAN"


class DataSourceStatus:
    """DataSourceStatus enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class DestinationType:
    """DestinationType enum values."""

    S3 = "S3"


class DetectionSource:
    """DetectionSource enum values."""

    AMAZON = "AMAZON"
    BITDEFENDER = "BITDEFENDER"


class DetectorFeature:
    """DetectorFeature enum values."""

    S3_DATA_EVENTS = "S3_DATA_EVENTS"
    EKS_AUDIT_LOGS = "EKS_AUDIT_LOGS"
    EBS_MALWARE_PROTECTION = "EBS_MALWARE_PROTECTION"
    RDS_LOGIN_EVENTS = "RDS_LOGIN_EVENTS"
    EKS_RUNTIME_MONITORING = "EKS_RUNTIME_MONITORING"
    LAMBDA_NETWORK_LOGS = "LAMBDA_NETWORK_LOGS"
    RUNTIME_MONITORING = "RUNTIME_MONITORING"


class DetectorFeatureResult:
    """DetectorFeatureResult enum values."""

    FLOW_LOGS = "FLOW_LOGS"
    CLOUD_TRAIL = "CLOUD_TRAIL"
    DNS_LOGS = "DNS_LOGS"
    S3_DATA_EVENTS = "S3_DATA_EVENTS"
    EKS_AUDIT_LOGS = "EKS_AUDIT_LOGS"
    EBS_MALWARE_PROTECTION = "EBS_MALWARE_PROTECTION"
    RDS_LOGIN_EVENTS = "RDS_LOGIN_EVENTS"
    EKS_RUNTIME_MONITORING = "EKS_RUNTIME_MONITORING"
    LAMBDA_NETWORK_LOGS = "LAMBDA_NETWORK_LOGS"
    RUNTIME_MONITORING = "RUNTIME_MONITORING"


class DetectorStatus:
    """DetectorStatus enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class EbsSnapshotPreservation:
    """EbsSnapshotPreservation enum values."""

    NO_RETENTION = "NO_RETENTION"
    RETENTION_WITH_FINDING = "RETENTION_WITH_FINDING"


class EcsClusterStatus:
    """EcsClusterStatus enum values."""

    ACTIVE = "ACTIVE"
    PROVISIONING = "PROVISIONING"
    DEPROVISIONING = "DEPROVISIONING"
    FAILED = "FAILED"
    INACTIVE = "INACTIVE"


class EcsLaunchType:
    """EcsLaunchType enum values."""

    FARGATE = "FARGATE"
    EC2 = "EC2"


class FeatureAdditionalConfiguration:
    """FeatureAdditionalConfiguration enum values."""

    EKS_ADDON_MANAGEMENT = "EKS_ADDON_MANAGEMENT"
    ECS_FARGATE_AGENT_MANAGEMENT = "ECS_FARGATE_AGENT_MANAGEMENT"
    EC2_AGENT_MANAGEMENT = "EC2_AGENT_MANAGEMENT"


class FeatureStatus:
    """FeatureStatus enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class Feedback:
    """Feedback enum values."""

    USEFUL = "USEFUL"
    NOT_USEFUL = "NOT_USEFUL"


class FilterAction:
    """FilterAction enum values."""

    NOOP = "NOOP"
    ARCHIVE = "ARCHIVE"


class FindingPublishingFrequency:
    """FindingPublishingFrequency enum values."""

    FIFTEEN_MINUTES = "FIFTEEN_MINUTES"
    ONE_HOUR = "ONE_HOUR"
    SIX_HOURS = "SIX_HOURS"


class FindingResourceType:
    """FindingResourceType enum values."""

    EC2_INSTANCE = "EC2_INSTANCE"
    EC2_NETWORK_INTERFACE = "EC2_NETWORK_INTERFACE"
    S3_BUCKET = "S3_BUCKET"
    S3_OBJECT = "S3_OBJECT"
    ACCESS_KEY = "ACCESS_KEY"
    EKS_CLUSTER = "EKS_CLUSTER"
    KUBERNETES_WORKLOAD = "KUBERNETES_WORKLOAD"
    CONTAINER = "CONTAINER"
    ECS_CLUSTER = "ECS_CLUSTER"
    ECS_TASK = "ECS_TASK"
    AUTOSCALING_AUTO_SCALING_GROUP = "AUTOSCALING_AUTO_SCALING_GROUP"
    IAM_INSTANCE_PROFILE = "IAM_INSTANCE_PROFILE"
    CLOUDFORMATION_STACK = "CLOUDFORMATION_STACK"
    EC2_LAUNCH_TEMPLATE = "EC2_LAUNCH_TEMPLATE"
    EC2_VPC = "EC2_VPC"
    EC2_IMAGE = "EC2_IMAGE"


class FindingStatisticType:
    """FindingStatisticType enum values."""

    COUNT_BY_SEVERITY = "COUNT_BY_SEVERITY"


class FreeTrialFeatureResult:
    """FreeTrialFeatureResult enum values."""

    FLOW_LOGS = "FLOW_LOGS"
    CLOUD_TRAIL = "CLOUD_TRAIL"
    DNS_LOGS = "DNS_LOGS"
    S3_DATA_EVENTS = "S3_DATA_EVENTS"
    EKS_AUDIT_LOGS = "EKS_AUDIT_LOGS"
    EBS_MALWARE_PROTECTION = "EBS_MALWARE_PROTECTION"
    RDS_LOGIN_EVENTS = "RDS_LOGIN_EVENTS"
    EKS_RUNTIME_MONITORING = "EKS_RUNTIME_MONITORING"
    LAMBDA_NETWORK_LOGS = "LAMBDA_NETWORK_LOGS"
    FARGATE_RUNTIME_MONITORING = "FARGATE_RUNTIME_MONITORING"
    EC2_RUNTIME_MONITORING = "EC2_RUNTIME_MONITORING"


class GroupByType:
    """GroupByType enum values."""

    ACCOUNT = "ACCOUNT"
    DATE = "DATE"
    FINDING_TYPE = "FINDING_TYPE"
    RESOURCE = "RESOURCE"
    SEVERITY = "SEVERITY"


class IndicatorType:
    """IndicatorType enum values."""

    SUSPICIOUS_USER_AGENT = "SUSPICIOUS_USER_AGENT"
    SUSPICIOUS_NETWORK = "SUSPICIOUS_NETWORK"
    MALICIOUS_IP = "MALICIOUS_IP"
    TOR_IP = "TOR_IP"
    ATTACK_TACTIC = "ATTACK_TACTIC"
    HIGH_RISK_API = "HIGH_RISK_API"
    ATTACK_TECHNIQUE = "ATTACK_TECHNIQUE"
    UNUSUAL_API_FOR_ACCOUNT = "UNUSUAL_API_FOR_ACCOUNT"
    UNUSUAL_ASN_FOR_ACCOUNT = "UNUSUAL_ASN_FOR_ACCOUNT"
    UNUSUAL_ASN_FOR_USER = "UNUSUAL_ASN_FOR_USER"
    SUSPICIOUS_PROCESS = "SUSPICIOUS_PROCESS"
    MALICIOUS_DOMAIN = "MALICIOUS_DOMAIN"
    MALICIOUS_PROCESS = "MALICIOUS_PROCESS"
    CRYPTOMINING_IP = "CRYPTOMINING_IP"
    CRYPTOMINING_DOMAIN = "CRYPTOMINING_DOMAIN"
    CRYPTOMINING_PROCESS = "CRYPTOMINING_PROCESS"


class IpSetFormat:
    """IpSetFormat enum values."""

    TXT = "TXT"
    STIX = "STIX"
    OTX_CSV = "OTX_CSV"
    ALIEN_VAULT = "ALIEN_VAULT"
    PROOF_POINT = "PROOF_POINT"
    FIRE_EYE = "FIRE_EYE"


class IpSetStatus:
    """IpSetStatus enum values."""

    INACTIVE = "INACTIVE"
    ACTIVATING = "ACTIVATING"
    ACTIVE = "ACTIVE"
    DEACTIVATING = "DEACTIVATING"
    ERROR = "ERROR"
    DELETE_PENDING = "DELETE_PENDING"
    DELETED = "DELETED"


class KubernetesResourcesTypes:
    """KubernetesResourcesTypes enum values."""

    PODS = "PODS"
    JOBS = "JOBS"
    CRONJOBS = "CRONJOBS"
    DEPLOYMENTS = "DEPLOYMENTS"
    DAEMONSETS = "DAEMONSETS"
    STATEFULSETS = "STATEFULSETS"
    REPLICASETS = "REPLICASETS"
    REPLICATIONCONTROLLERS = "REPLICATIONCONTROLLERS"


class ListMalwareScansCriterionKey:
    """ListMalwareScansCriterionKey enum values."""

    RESOURCE_ARN = "RESOURCE_ARN"
    SCAN_ID = "SCAN_ID"
    ACCOUNT_ID = "ACCOUNT_ID"
    GUARDDUTY_FINDING_ID = "GUARDDUTY_FINDING_ID"
    RESOURCE_TYPE = "RESOURCE_TYPE"
    SCAN_START_TIME = "SCAN_START_TIME"
    SCAN_STATUS = "SCAN_STATUS"
    SCAN_TYPE = "SCAN_TYPE"


class MalwareProtectionPlanStatus:
    """MalwareProtectionPlanStatus enum values."""

    ACTIVE = "ACTIVE"
    WARNING = "WARNING"
    ERROR = "ERROR"


class MalwareProtectionPlanTaggingActionStatus:
    """MalwareProtectionPlanTaggingActionStatus enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class MalwareProtectionResourceType:
    """MalwareProtectionResourceType enum values."""

    EBS_RECOVERY_POINT = "EBS_RECOVERY_POINT"
    EBS_SNAPSHOT = "EBS_SNAPSHOT"
    EBS_VOLUME = "EBS_VOLUME"
    EC2_AMI = "EC2_AMI"
    EC2_INSTANCE = "EC2_INSTANCE"
    EC2_RECOVERY_POINT = "EC2_RECOVERY_POINT"
    S3_RECOVERY_POINT = "S3_RECOVERY_POINT"
    S3_BUCKET = "S3_BUCKET"


class MalwareProtectionScanStatus:
    """MalwareProtectionScanStatus enum values."""

    RUNNING = "RUNNING"
    COMPLETED = "COMPLETED"
    COMPLETED_WITH_ISSUES = "COMPLETED_WITH_ISSUES"
    FAILED = "FAILED"
    SKIPPED = "SKIPPED"


class MalwareProtectionScanType:
    """MalwareProtectionScanType enum values."""

    BACKUP_INITIATED = "BACKUP_INITIATED"
    ON_DEMAND = "ON_DEMAND"
    GUARDDUTY_INITIATED = "GUARDDUTY_INITIATED"


class ManagementType:
    """ManagementType enum values."""

    AUTO_MANAGED = "AUTO_MANAGED"
    MANUAL = "MANUAL"
    DISABLED = "DISABLED"


class MfaStatus:
    """MfaStatus enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class NetworkDirection:
    """NetworkDirection enum values."""

    INBOUND = "INBOUND"
    OUTBOUND = "OUTBOUND"


class OrderBy:
    """OrderBy enum values."""

    ASC = "ASC"
    DESC = "DESC"


class OrgFeature:
    """OrgFeature enum values."""

    S3_DATA_EVENTS = "S3_DATA_EVENTS"
    EKS_AUDIT_LOGS = "EKS_AUDIT_LOGS"
    EBS_MALWARE_PROTECTION = "EBS_MALWARE_PROTECTION"
    RDS_LOGIN_EVENTS = "RDS_LOGIN_EVENTS"
    EKS_RUNTIME_MONITORING = "EKS_RUNTIME_MONITORING"
    LAMBDA_NETWORK_LOGS = "LAMBDA_NETWORK_LOGS"
    RUNTIME_MONITORING = "RUNTIME_MONITORING"


class OrgFeatureAdditionalConfiguration:
    """OrgFeatureAdditionalConfiguration enum values."""

    EKS_ADDON_MANAGEMENT = "EKS_ADDON_MANAGEMENT"
    ECS_FARGATE_AGENT_MANAGEMENT = "ECS_FARGATE_AGENT_MANAGEMENT"
    EC2_AGENT_MANAGEMENT = "EC2_AGENT_MANAGEMENT"


class OrgFeatureStatus:
    """OrgFeatureStatus enum values."""

    NEW = "NEW"
    NONE = "NONE"
    ALL = "ALL"


class ProfileSubtype:
    """ProfileSubtype enum values."""

    FREQUENT = "FREQUENT"
    INFREQUENT = "INFREQUENT"
    UNSEEN = "UNSEEN"
    RARE = "RARE"


class ProfileType:
    """ProfileType enum values."""

    FREQUENCY = "FREQUENCY"


class PublicAccessStatus:
    """PublicAccessStatus enum values."""

    BLOCKED = "BLOCKED"
    ALLOWED = "ALLOWED"


class PublicAclIgnoreBehavior:
    """PublicAclIgnoreBehavior enum values."""

    IGNORED = "IGNORED"
    NOT_IGNORED = "NOT_IGNORED"


class PublicBucketRestrictBehavior:
    """PublicBucketRestrictBehavior enum values."""

    RESTRICTED = "RESTRICTED"
    NOT_RESTRICTED = "NOT_RESTRICTED"


class PublishingStatus:
    """PublishingStatus enum values."""

    PENDING_VERIFICATION = "PENDING_VERIFICATION"
    PUBLISHING = "PUBLISHING"
    UNABLE_TO_PUBLISH_FIX_DESTINATION_PROPERTY = "UNABLE_TO_PUBLISH_FIX_DESTINATION_PROPERTY"
    STOPPED = "STOPPED"


class ResourceType:
    """ResourceType enum values."""

    EKS = "EKS"
    ECS = "ECS"
    EC2 = "EC2"


class ScanCategory:
    """ScanCategory enum values."""

    FULL_SCAN = "FULL_SCAN"
    INCREMENTAL_SCAN = "INCREMENTAL_SCAN"


class ScanCriterionKey:
    """ScanCriterionKey enum values."""

    EC2_INSTANCE_TAG = "EC2_INSTANCE_TAG"


class ScanResult:
    """ScanResult enum values."""

    CLEAN = "CLEAN"
    INFECTED = "INFECTED"


class ScanResultStatus:
    """ScanResultStatus enum values."""

    NO_THREATS_FOUND = "NO_THREATS_FOUND"
    THREATS_FOUND = "THREATS_FOUND"


class ScanStatus:
    """ScanStatus enum values."""

    RUNNING = "RUNNING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    SKIPPED = "SKIPPED"


class ScanStatusReason:
    """ScanStatusReason enum values."""

    ACCESS_DENIED = "ACCESS_DENIED"
    RESOURCE_NOT_FOUND = "RESOURCE_NOT_FOUND"
    SNAPSHOT_SIZE_LIMIT_EXCEEDED = "SNAPSHOT_SIZE_LIMIT_EXCEEDED"
    RESOURCE_UNAVAILABLE = "RESOURCE_UNAVAILABLE"
    INCONSISTENT_SOURCE = "INCONSISTENT_SOURCE"
    INCREMENTAL_NO_DIFFERENCE = "INCREMENTAL_NO_DIFFERENCE"
    NO_EBS_VOLUMES_FOUND = "NO_EBS_VOLUMES_FOUND"
    UNSUPPORTED_PRODUCT_CODE_TYPE = "UNSUPPORTED_PRODUCT_CODE_TYPE"
    AMI_SNAPSHOT_LIMIT_EXCEEDED = "AMI_SNAPSHOT_LIMIT_EXCEEDED"
    UNRELATED_RESOURCES = "UNRELATED_RESOURCES"
    BASE_RESOURCE_NOT_SCANNED = "BASE_RESOURCE_NOT_SCANNED"
    BASE_CREATED_AFTER_TARGET = "BASE_CREATED_AFTER_TARGET"
    UNSUPPORTED_FOR_INCREMENTAL = "UNSUPPORTED_FOR_INCREMENTAL"
    UNSUPPORTED_AMI = "UNSUPPORTED_AMI"
    UNSUPPORTED_SNAPSHOT = "UNSUPPORTED_SNAPSHOT"
    UNSUPPORTED_COMPOSITE_RECOVERY_POINT = "UNSUPPORTED_COMPOSITE_RECOVERY_POINT"


class ScanType:
    """ScanType enum values."""

    GUARDDUTY_INITIATED = "GUARDDUTY_INITIATED"
    ON_DEMAND = "ON_DEMAND"


class SignalType:
    """SignalType enum values."""

    FINDING = "FINDING"
    CLOUD_TRAIL = "CLOUD_TRAIL"
    S3_DATA_EVENTS = "S3_DATA_EVENTS"
    EKS_AUDIT_LOGS = "EKS_AUDIT_LOGS"
    FLOW_LOGS = "FLOW_LOGS"
    DNS_LOGS = "DNS_LOGS"
    RUNTIME_MONITORING = "RUNTIME_MONITORING"


class ThreatEntitySetFormat:
    """ThreatEntitySetFormat enum values."""

    TXT = "TXT"
    STIX = "STIX"
    OTX_CSV = "OTX_CSV"
    ALIEN_VAULT = "ALIEN_VAULT"
    PROOF_POINT = "PROOF_POINT"
    FIRE_EYE = "FIRE_EYE"


class ThreatEntitySetStatus:
    """ThreatEntitySetStatus enum values."""

    INACTIVE = "INACTIVE"
    ACTIVATING = "ACTIVATING"
    ACTIVE = "ACTIVE"
    DEACTIVATING = "DEACTIVATING"
    ERROR = "ERROR"
    DELETE_PENDING = "DELETE_PENDING"
    DELETED = "DELETED"


class ThreatIntelSetFormat:
    """ThreatIntelSetFormat enum values."""

    TXT = "TXT"
    STIX = "STIX"
    OTX_CSV = "OTX_CSV"
    ALIEN_VAULT = "ALIEN_VAULT"
    PROOF_POINT = "PROOF_POINT"
    FIRE_EYE = "FIRE_EYE"


class ThreatIntelSetStatus:
    """ThreatIntelSetStatus enum values."""

    INACTIVE = "INACTIVE"
    ACTIVATING = "ACTIVATING"
    ACTIVE = "ACTIVE"
    DEACTIVATING = "DEACTIVATING"
    ERROR = "ERROR"
    DELETE_PENDING = "DELETE_PENDING"
    DELETED = "DELETED"


class TriggerType:
    """TriggerType enum values."""

    BACKUP = "BACKUP"
    GUARDDUTY = "GUARDDUTY"


class TrustedEntitySetFormat:
    """TrustedEntitySetFormat enum values."""

    TXT = "TXT"
    STIX = "STIX"
    OTX_CSV = "OTX_CSV"
    ALIEN_VAULT = "ALIEN_VAULT"
    PROOF_POINT = "PROOF_POINT"
    FIRE_EYE = "FIRE_EYE"


class TrustedEntitySetStatus:
    """TrustedEntitySetStatus enum values."""

    INACTIVE = "INACTIVE"
    ACTIVATING = "ACTIVATING"
    ACTIVE = "ACTIVE"
    DEACTIVATING = "DEACTIVATING"
    ERROR = "ERROR"
    DELETE_PENDING = "DELETE_PENDING"
    DELETED = "DELETED"


class UsageFeature:
    """UsageFeature enum values."""

    FLOW_LOGS = "FLOW_LOGS"
    CLOUD_TRAIL = "CLOUD_TRAIL"
    DNS_LOGS = "DNS_LOGS"
    S3_DATA_EVENTS = "S3_DATA_EVENTS"
    EKS_AUDIT_LOGS = "EKS_AUDIT_LOGS"
    EBS_MALWARE_PROTECTION = "EBS_MALWARE_PROTECTION"
    RDS_LOGIN_EVENTS = "RDS_LOGIN_EVENTS"
    LAMBDA_NETWORK_LOGS = "LAMBDA_NETWORK_LOGS"
    EKS_RUNTIME_MONITORING = "EKS_RUNTIME_MONITORING"
    FARGATE_RUNTIME_MONITORING = "FARGATE_RUNTIME_MONITORING"
    EC2_RUNTIME_MONITORING = "EC2_RUNTIME_MONITORING"
    RDS_DBI_PROTECTION_PROVISIONED = "RDS_DBI_PROTECTION_PROVISIONED"
    RDS_DBI_PROTECTION_SERVERLESS = "RDS_DBI_PROTECTION_SERVERLESS"


class UsageStatisticType:
    """UsageStatisticType enum values."""

    SUM_BY_ACCOUNT = "SUM_BY_ACCOUNT"
    SUM_BY_DATA_SOURCE = "SUM_BY_DATA_SOURCE"
    SUM_BY_RESOURCE = "SUM_BY_RESOURCE"
    TOP_RESOURCES = "TOP_RESOURCES"
    SUM_BY_FEATURES = "SUM_BY_FEATURES"
    TOP_ACCOUNTS_BY_FEATURE = "TOP_ACCOUNTS_BY_FEATURE"


# Convenient aliases for enum values
ENABLED = AdminStatus.ENABLED
DISABLE_IN_PROGRESS = AdminStatus.DISABLE_IN_PROGRESS
NEW = AutoEnableMembers.NEW
ALL = AutoEnableMembers.ALL
NONE = AutoEnableMembers.NONE
CREATING = ClusterStatus.CREATING
ACTIVE = ClusterStatus.ACTIVE
DELETING = ClusterStatus.DELETING
FAILED = ClusterStatus.FAILED
UPDATING = ClusterStatus.UPDATING
PENDING = ClusterStatus.PENDING
ACCOUNT_ID = CoverageFilterCriterionKey.ACCOUNT_ID
CLUSTER_NAME = CoverageFilterCriterionKey.CLUSTER_NAME
RESOURCE_TYPE = CoverageFilterCriterionKey.RESOURCE_TYPE
COVERAGE_STATUS = CoverageFilterCriterionKey.COVERAGE_STATUS
ADDON_VERSION = CoverageFilterCriterionKey.ADDON_VERSION
MANAGEMENT_TYPE = CoverageFilterCriterionKey.MANAGEMENT_TYPE
EKS_CLUSTER_NAME = CoverageFilterCriterionKey.EKS_CLUSTER_NAME
ECS_CLUSTER_NAME = CoverageFilterCriterionKey.ECS_CLUSTER_NAME
AGENT_VERSION = CoverageFilterCriterionKey.AGENT_VERSION
INSTANCE_ID = CoverageFilterCriterionKey.INSTANCE_ID
CLUSTER_ARN = CoverageFilterCriterionKey.CLUSTER_ARN
ACCOUNT_ID = CoverageSortKey.ACCOUNT_ID
CLUSTER_NAME = CoverageSortKey.CLUSTER_NAME
COVERAGE_STATUS = CoverageSortKey.COVERAGE_STATUS
ISSUE = CoverageSortKey.ISSUE
ADDON_VERSION = CoverageSortKey.ADDON_VERSION
UPDATED_AT = CoverageSortKey.UPDATED_AT
EKS_CLUSTER_NAME = CoverageSortKey.EKS_CLUSTER_NAME
ECS_CLUSTER_NAME = CoverageSortKey.ECS_CLUSTER_NAME
INSTANCE_ID = CoverageSortKey.INSTANCE_ID
COUNT_BY_RESOURCE_TYPE = CoverageStatisticsType.COUNT_BY_RESOURCE_TYPE
COUNT_BY_COVERAGE_STATUS = CoverageStatisticsType.COUNT_BY_COVERAGE_STATUS
HEALTHY = CoverageStatus.HEALTHY
UNHEALTHY = CoverageStatus.UNHEALTHY
EC2_INSTANCE_ARN = CriterionKey.EC2_INSTANCE_ARN
SCAN_ID = CriterionKey.SCAN_ID
ACCOUNT_ID = CriterionKey.ACCOUNT_ID
GUARDDUTY_FINDING_ID = CriterionKey.GUARDDUTY_FINDING_ID
SCAN_START_TIME = CriterionKey.SCAN_START_TIME
SCAN_STATUS = CriterionKey.SCAN_STATUS
SCAN_TYPE = CriterionKey.SCAN_TYPE
FLOW_LOGS = DataSource.FLOW_LOGS
CLOUD_TRAIL = DataSource.CLOUD_TRAIL
DNS_LOGS = DataSource.DNS_LOGS
S3_LOGS = DataSource.S3_LOGS
KUBERNETES_AUDIT_LOGS = DataSource.KUBERNETES_AUDIT_LOGS
EC2_MALWARE_SCAN = DataSource.EC2_MALWARE_SCAN
ENABLED = DataSourceStatus.ENABLED
DISABLED = DataSourceStatus.DISABLED
S3 = DestinationType.S3
AMAZON = DetectionSource.AMAZON
BITDEFENDER = DetectionSource.BITDEFENDER
S3_DATA_EVENTS = DetectorFeature.S3_DATA_EVENTS
EKS_AUDIT_LOGS = DetectorFeature.EKS_AUDIT_LOGS
EBS_MALWARE_PROTECTION = DetectorFeature.EBS_MALWARE_PROTECTION
RDS_LOGIN_EVENTS = DetectorFeature.RDS_LOGIN_EVENTS
EKS_RUNTIME_MONITORING = DetectorFeature.EKS_RUNTIME_MONITORING
LAMBDA_NETWORK_LOGS = DetectorFeature.LAMBDA_NETWORK_LOGS
RUNTIME_MONITORING = DetectorFeature.RUNTIME_MONITORING
FLOW_LOGS = DetectorFeatureResult.FLOW_LOGS
CLOUD_TRAIL = DetectorFeatureResult.CLOUD_TRAIL
DNS_LOGS = DetectorFeatureResult.DNS_LOGS
S3_DATA_EVENTS = DetectorFeatureResult.S3_DATA_EVENTS
EKS_AUDIT_LOGS = DetectorFeatureResult.EKS_AUDIT_LOGS
EBS_MALWARE_PROTECTION = DetectorFeatureResult.EBS_MALWARE_PROTECTION
RDS_LOGIN_EVENTS = DetectorFeatureResult.RDS_LOGIN_EVENTS
EKS_RUNTIME_MONITORING = DetectorFeatureResult.EKS_RUNTIME_MONITORING
LAMBDA_NETWORK_LOGS = DetectorFeatureResult.LAMBDA_NETWORK_LOGS
RUNTIME_MONITORING = DetectorFeatureResult.RUNTIME_MONITORING
ENABLED = DetectorStatus.ENABLED
DISABLED = DetectorStatus.DISABLED
NO_RETENTION = EbsSnapshotPreservation.NO_RETENTION
RETENTION_WITH_FINDING = EbsSnapshotPreservation.RETENTION_WITH_FINDING
ACTIVE = EcsClusterStatus.ACTIVE
PROVISIONING = EcsClusterStatus.PROVISIONING
DEPROVISIONING = EcsClusterStatus.DEPROVISIONING
FAILED = EcsClusterStatus.FAILED
INACTIVE = EcsClusterStatus.INACTIVE
FARGATE = EcsLaunchType.FARGATE
EC2 = EcsLaunchType.EC2
EKS_ADDON_MANAGEMENT = FeatureAdditionalConfiguration.EKS_ADDON_MANAGEMENT
ECS_FARGATE_AGENT_MANAGEMENT = FeatureAdditionalConfiguration.ECS_FARGATE_AGENT_MANAGEMENT
EC2_AGENT_MANAGEMENT = FeatureAdditionalConfiguration.EC2_AGENT_MANAGEMENT
ENABLED = FeatureStatus.ENABLED
DISABLED = FeatureStatus.DISABLED
USEFUL = Feedback.USEFUL
NOT_USEFUL = Feedback.NOT_USEFUL
NOOP = FilterAction.NOOP
ARCHIVE = FilterAction.ARCHIVE
FIFTEEN_MINUTES = FindingPublishingFrequency.FIFTEEN_MINUTES
ONE_HOUR = FindingPublishingFrequency.ONE_HOUR
SIX_HOURS = FindingPublishingFrequency.SIX_HOURS
EC2_INSTANCE = FindingResourceType.EC2_INSTANCE
EC2_NETWORK_INTERFACE = FindingResourceType.EC2_NETWORK_INTERFACE
S3_BUCKET = FindingResourceType.S3_BUCKET
S3_OBJECT = FindingResourceType.S3_OBJECT
ACCESS_KEY = FindingResourceType.ACCESS_KEY
EKS_CLUSTER = FindingResourceType.EKS_CLUSTER
KUBERNETES_WORKLOAD = FindingResourceType.KUBERNETES_WORKLOAD
CONTAINER = FindingResourceType.CONTAINER
ECS_CLUSTER = FindingResourceType.ECS_CLUSTER
ECS_TASK = FindingResourceType.ECS_TASK
AUTOSCALING_AUTO_SCALING_GROUP = FindingResourceType.AUTOSCALING_AUTO_SCALING_GROUP
IAM_INSTANCE_PROFILE = FindingResourceType.IAM_INSTANCE_PROFILE
CLOUDFORMATION_STACK = FindingResourceType.CLOUDFORMATION_STACK
EC2_LAUNCH_TEMPLATE = FindingResourceType.EC2_LAUNCH_TEMPLATE
EC2_VPC = FindingResourceType.EC2_VPC
EC2_IMAGE = FindingResourceType.EC2_IMAGE
COUNT_BY_SEVERITY = FindingStatisticType.COUNT_BY_SEVERITY
FLOW_LOGS = FreeTrialFeatureResult.FLOW_LOGS
CLOUD_TRAIL = FreeTrialFeatureResult.CLOUD_TRAIL
DNS_LOGS = FreeTrialFeatureResult.DNS_LOGS
S3_DATA_EVENTS = FreeTrialFeatureResult.S3_DATA_EVENTS
EKS_AUDIT_LOGS = FreeTrialFeatureResult.EKS_AUDIT_LOGS
EBS_MALWARE_PROTECTION = FreeTrialFeatureResult.EBS_MALWARE_PROTECTION
RDS_LOGIN_EVENTS = FreeTrialFeatureResult.RDS_LOGIN_EVENTS
EKS_RUNTIME_MONITORING = FreeTrialFeatureResult.EKS_RUNTIME_MONITORING
LAMBDA_NETWORK_LOGS = FreeTrialFeatureResult.LAMBDA_NETWORK_LOGS
FARGATE_RUNTIME_MONITORING = FreeTrialFeatureResult.FARGATE_RUNTIME_MONITORING
EC2_RUNTIME_MONITORING = FreeTrialFeatureResult.EC2_RUNTIME_MONITORING
ACCOUNT = GroupByType.ACCOUNT
DATE = GroupByType.DATE
FINDING_TYPE = GroupByType.FINDING_TYPE
RESOURCE = GroupByType.RESOURCE
SEVERITY = GroupByType.SEVERITY
SUSPICIOUS_USER_AGENT = IndicatorType.SUSPICIOUS_USER_AGENT
SUSPICIOUS_NETWORK = IndicatorType.SUSPICIOUS_NETWORK
MALICIOUS_IP = IndicatorType.MALICIOUS_IP
TOR_IP = IndicatorType.TOR_IP
ATTACK_TACTIC = IndicatorType.ATTACK_TACTIC
HIGH_RISK_API = IndicatorType.HIGH_RISK_API
ATTACK_TECHNIQUE = IndicatorType.ATTACK_TECHNIQUE
UNUSUAL_API_FOR_ACCOUNT = IndicatorType.UNUSUAL_API_FOR_ACCOUNT
UNUSUAL_ASN_FOR_ACCOUNT = IndicatorType.UNUSUAL_ASN_FOR_ACCOUNT
UNUSUAL_ASN_FOR_USER = IndicatorType.UNUSUAL_ASN_FOR_USER
SUSPICIOUS_PROCESS = IndicatorType.SUSPICIOUS_PROCESS
MALICIOUS_DOMAIN = IndicatorType.MALICIOUS_DOMAIN
MALICIOUS_PROCESS = IndicatorType.MALICIOUS_PROCESS
CRYPTOMINING_IP = IndicatorType.CRYPTOMINING_IP
CRYPTOMINING_DOMAIN = IndicatorType.CRYPTOMINING_DOMAIN
CRYPTOMINING_PROCESS = IndicatorType.CRYPTOMINING_PROCESS
TXT = IpSetFormat.TXT
STIX = IpSetFormat.STIX
OTX_CSV = IpSetFormat.OTX_CSV
ALIEN_VAULT = IpSetFormat.ALIEN_VAULT
PROOF_POINT = IpSetFormat.PROOF_POINT
FIRE_EYE = IpSetFormat.FIRE_EYE
INACTIVE = IpSetStatus.INACTIVE
ACTIVATING = IpSetStatus.ACTIVATING
ACTIVE = IpSetStatus.ACTIVE
DEACTIVATING = IpSetStatus.DEACTIVATING
ERROR = IpSetStatus.ERROR
DELETE_PENDING = IpSetStatus.DELETE_PENDING
DELETED = IpSetStatus.DELETED
PODS = KubernetesResourcesTypes.PODS
JOBS = KubernetesResourcesTypes.JOBS
CRONJOBS = KubernetesResourcesTypes.CRONJOBS
DEPLOYMENTS = KubernetesResourcesTypes.DEPLOYMENTS
DAEMONSETS = KubernetesResourcesTypes.DAEMONSETS
STATEFULSETS = KubernetesResourcesTypes.STATEFULSETS
REPLICASETS = KubernetesResourcesTypes.REPLICASETS
REPLICATIONCONTROLLERS = KubernetesResourcesTypes.REPLICATIONCONTROLLERS
RESOURCE_ARN = ListMalwareScansCriterionKey.RESOURCE_ARN
SCAN_ID = ListMalwareScansCriterionKey.SCAN_ID
ACCOUNT_ID = ListMalwareScansCriterionKey.ACCOUNT_ID
GUARDDUTY_FINDING_ID = ListMalwareScansCriterionKey.GUARDDUTY_FINDING_ID
RESOURCE_TYPE = ListMalwareScansCriterionKey.RESOURCE_TYPE
SCAN_START_TIME = ListMalwareScansCriterionKey.SCAN_START_TIME
SCAN_STATUS = ListMalwareScansCriterionKey.SCAN_STATUS
SCAN_TYPE = ListMalwareScansCriterionKey.SCAN_TYPE
ACTIVE = MalwareProtectionPlanStatus.ACTIVE
WARNING = MalwareProtectionPlanStatus.WARNING
ERROR = MalwareProtectionPlanStatus.ERROR
ENABLED = MalwareProtectionPlanTaggingActionStatus.ENABLED
DISABLED = MalwareProtectionPlanTaggingActionStatus.DISABLED
EBS_RECOVERY_POINT = MalwareProtectionResourceType.EBS_RECOVERY_POINT
EBS_SNAPSHOT = MalwareProtectionResourceType.EBS_SNAPSHOT
EBS_VOLUME = MalwareProtectionResourceType.EBS_VOLUME
EC2_AMI = MalwareProtectionResourceType.EC2_AMI
EC2_INSTANCE = MalwareProtectionResourceType.EC2_INSTANCE
EC2_RECOVERY_POINT = MalwareProtectionResourceType.EC2_RECOVERY_POINT
S3_RECOVERY_POINT = MalwareProtectionResourceType.S3_RECOVERY_POINT
S3_BUCKET = MalwareProtectionResourceType.S3_BUCKET
RUNNING = MalwareProtectionScanStatus.RUNNING
COMPLETED = MalwareProtectionScanStatus.COMPLETED
COMPLETED_WITH_ISSUES = MalwareProtectionScanStatus.COMPLETED_WITH_ISSUES
FAILED = MalwareProtectionScanStatus.FAILED
SKIPPED = MalwareProtectionScanStatus.SKIPPED
BACKUP_INITIATED = MalwareProtectionScanType.BACKUP_INITIATED
ON_DEMAND = MalwareProtectionScanType.ON_DEMAND
GUARDDUTY_INITIATED = MalwareProtectionScanType.GUARDDUTY_INITIATED
AUTO_MANAGED = ManagementType.AUTO_MANAGED
MANUAL = ManagementType.MANUAL
DISABLED = ManagementType.DISABLED
ENABLED = MfaStatus.ENABLED
DISABLED = MfaStatus.DISABLED
INBOUND = NetworkDirection.INBOUND
OUTBOUND = NetworkDirection.OUTBOUND
ASC = OrderBy.ASC
DESC = OrderBy.DESC
S3_DATA_EVENTS = OrgFeature.S3_DATA_EVENTS
EKS_AUDIT_LOGS = OrgFeature.EKS_AUDIT_LOGS
EBS_MALWARE_PROTECTION = OrgFeature.EBS_MALWARE_PROTECTION
RDS_LOGIN_EVENTS = OrgFeature.RDS_LOGIN_EVENTS
EKS_RUNTIME_MONITORING = OrgFeature.EKS_RUNTIME_MONITORING
LAMBDA_NETWORK_LOGS = OrgFeature.LAMBDA_NETWORK_LOGS
RUNTIME_MONITORING = OrgFeature.RUNTIME_MONITORING
EKS_ADDON_MANAGEMENT = OrgFeatureAdditionalConfiguration.EKS_ADDON_MANAGEMENT
ECS_FARGATE_AGENT_MANAGEMENT = OrgFeatureAdditionalConfiguration.ECS_FARGATE_AGENT_MANAGEMENT
EC2_AGENT_MANAGEMENT = OrgFeatureAdditionalConfiguration.EC2_AGENT_MANAGEMENT
NEW = OrgFeatureStatus.NEW
NONE = OrgFeatureStatus.NONE
ALL = OrgFeatureStatus.ALL
FREQUENT = ProfileSubtype.FREQUENT
INFREQUENT = ProfileSubtype.INFREQUENT
UNSEEN = ProfileSubtype.UNSEEN
RARE = ProfileSubtype.RARE
FREQUENCY = ProfileType.FREQUENCY
BLOCKED = PublicAccessStatus.BLOCKED
ALLOWED = PublicAccessStatus.ALLOWED
IGNORED = PublicAclIgnoreBehavior.IGNORED
NOT_IGNORED = PublicAclIgnoreBehavior.NOT_IGNORED
RESTRICTED = PublicBucketRestrictBehavior.RESTRICTED
NOT_RESTRICTED = PublicBucketRestrictBehavior.NOT_RESTRICTED
PENDING_VERIFICATION = PublishingStatus.PENDING_VERIFICATION
PUBLISHING = PublishingStatus.PUBLISHING
UNABLE_TO_PUBLISH_FIX_DESTINATION_PROPERTY = PublishingStatus.UNABLE_TO_PUBLISH_FIX_DESTINATION_PROPERTY
STOPPED = PublishingStatus.STOPPED
EKS = ResourceType.EKS
ECS = ResourceType.ECS
EC2 = ResourceType.EC2
FULL_SCAN = ScanCategory.FULL_SCAN
INCREMENTAL_SCAN = ScanCategory.INCREMENTAL_SCAN
EC2_INSTANCE_TAG = ScanCriterionKey.EC2_INSTANCE_TAG
CLEAN = ScanResult.CLEAN
INFECTED = ScanResult.INFECTED
NO_THREATS_FOUND = ScanResultStatus.NO_THREATS_FOUND
THREATS_FOUND = ScanResultStatus.THREATS_FOUND
RUNNING = ScanStatus.RUNNING
COMPLETED = ScanStatus.COMPLETED
FAILED = ScanStatus.FAILED
SKIPPED = ScanStatus.SKIPPED
ACCESS_DENIED = ScanStatusReason.ACCESS_DENIED
RESOURCE_NOT_FOUND = ScanStatusReason.RESOURCE_NOT_FOUND
SNAPSHOT_SIZE_LIMIT_EXCEEDED = ScanStatusReason.SNAPSHOT_SIZE_LIMIT_EXCEEDED
RESOURCE_UNAVAILABLE = ScanStatusReason.RESOURCE_UNAVAILABLE
INCONSISTENT_SOURCE = ScanStatusReason.INCONSISTENT_SOURCE
INCREMENTAL_NO_DIFFERENCE = ScanStatusReason.INCREMENTAL_NO_DIFFERENCE
NO_EBS_VOLUMES_FOUND = ScanStatusReason.NO_EBS_VOLUMES_FOUND
UNSUPPORTED_PRODUCT_CODE_TYPE = ScanStatusReason.UNSUPPORTED_PRODUCT_CODE_TYPE
AMI_SNAPSHOT_LIMIT_EXCEEDED = ScanStatusReason.AMI_SNAPSHOT_LIMIT_EXCEEDED
UNRELATED_RESOURCES = ScanStatusReason.UNRELATED_RESOURCES
BASE_RESOURCE_NOT_SCANNED = ScanStatusReason.BASE_RESOURCE_NOT_SCANNED
BASE_CREATED_AFTER_TARGET = ScanStatusReason.BASE_CREATED_AFTER_TARGET
UNSUPPORTED_FOR_INCREMENTAL = ScanStatusReason.UNSUPPORTED_FOR_INCREMENTAL
UNSUPPORTED_AMI = ScanStatusReason.UNSUPPORTED_AMI
UNSUPPORTED_SNAPSHOT = ScanStatusReason.UNSUPPORTED_SNAPSHOT
UNSUPPORTED_COMPOSITE_RECOVERY_POINT = ScanStatusReason.UNSUPPORTED_COMPOSITE_RECOVERY_POINT
GUARDDUTY_INITIATED = ScanType.GUARDDUTY_INITIATED
ON_DEMAND = ScanType.ON_DEMAND
FINDING = SignalType.FINDING
CLOUD_TRAIL = SignalType.CLOUD_TRAIL
S3_DATA_EVENTS = SignalType.S3_DATA_EVENTS
EKS_AUDIT_LOGS = SignalType.EKS_AUDIT_LOGS
FLOW_LOGS = SignalType.FLOW_LOGS
DNS_LOGS = SignalType.DNS_LOGS
RUNTIME_MONITORING = SignalType.RUNTIME_MONITORING
TXT = ThreatEntitySetFormat.TXT
STIX = ThreatEntitySetFormat.STIX
OTX_CSV = ThreatEntitySetFormat.OTX_CSV
ALIEN_VAULT = ThreatEntitySetFormat.ALIEN_VAULT
PROOF_POINT = ThreatEntitySetFormat.PROOF_POINT
FIRE_EYE = ThreatEntitySetFormat.FIRE_EYE
INACTIVE = ThreatEntitySetStatus.INACTIVE
ACTIVATING = ThreatEntitySetStatus.ACTIVATING
ACTIVE = ThreatEntitySetStatus.ACTIVE
DEACTIVATING = ThreatEntitySetStatus.DEACTIVATING
ERROR = ThreatEntitySetStatus.ERROR
DELETE_PENDING = ThreatEntitySetStatus.DELETE_PENDING
DELETED = ThreatEntitySetStatus.DELETED
TXT = ThreatIntelSetFormat.TXT
STIX = ThreatIntelSetFormat.STIX
OTX_CSV = ThreatIntelSetFormat.OTX_CSV
ALIEN_VAULT = ThreatIntelSetFormat.ALIEN_VAULT
PROOF_POINT = ThreatIntelSetFormat.PROOF_POINT
FIRE_EYE = ThreatIntelSetFormat.FIRE_EYE
INACTIVE = ThreatIntelSetStatus.INACTIVE
ACTIVATING = ThreatIntelSetStatus.ACTIVATING
ACTIVE = ThreatIntelSetStatus.ACTIVE
DEACTIVATING = ThreatIntelSetStatus.DEACTIVATING
ERROR = ThreatIntelSetStatus.ERROR
DELETE_PENDING = ThreatIntelSetStatus.DELETE_PENDING
DELETED = ThreatIntelSetStatus.DELETED
BACKUP = TriggerType.BACKUP
GUARDDUTY = TriggerType.GUARDDUTY
TXT = TrustedEntitySetFormat.TXT
STIX = TrustedEntitySetFormat.STIX
OTX_CSV = TrustedEntitySetFormat.OTX_CSV
ALIEN_VAULT = TrustedEntitySetFormat.ALIEN_VAULT
PROOF_POINT = TrustedEntitySetFormat.PROOF_POINT
FIRE_EYE = TrustedEntitySetFormat.FIRE_EYE
INACTIVE = TrustedEntitySetStatus.INACTIVE
ACTIVATING = TrustedEntitySetStatus.ACTIVATING
ACTIVE = TrustedEntitySetStatus.ACTIVE
DEACTIVATING = TrustedEntitySetStatus.DEACTIVATING
ERROR = TrustedEntitySetStatus.ERROR
DELETE_PENDING = TrustedEntitySetStatus.DELETE_PENDING
DELETED = TrustedEntitySetStatus.DELETED
FLOW_LOGS = UsageFeature.FLOW_LOGS
CLOUD_TRAIL = UsageFeature.CLOUD_TRAIL
DNS_LOGS = UsageFeature.DNS_LOGS
S3_DATA_EVENTS = UsageFeature.S3_DATA_EVENTS
EKS_AUDIT_LOGS = UsageFeature.EKS_AUDIT_LOGS
EBS_MALWARE_PROTECTION = UsageFeature.EBS_MALWARE_PROTECTION
RDS_LOGIN_EVENTS = UsageFeature.RDS_LOGIN_EVENTS
LAMBDA_NETWORK_LOGS = UsageFeature.LAMBDA_NETWORK_LOGS
EKS_RUNTIME_MONITORING = UsageFeature.EKS_RUNTIME_MONITORING
FARGATE_RUNTIME_MONITORING = UsageFeature.FARGATE_RUNTIME_MONITORING
EC2_RUNTIME_MONITORING = UsageFeature.EC2_RUNTIME_MONITORING
RDS_DBI_PROTECTION_PROVISIONED = UsageFeature.RDS_DBI_PROTECTION_PROVISIONED
RDS_DBI_PROTECTION_SERVERLESS = UsageFeature.RDS_DBI_PROTECTION_SERVERLESS
SUM_BY_ACCOUNT = UsageStatisticType.SUM_BY_ACCOUNT
SUM_BY_DATA_SOURCE = UsageStatisticType.SUM_BY_DATA_SOURCE
SUM_BY_RESOURCE = UsageStatisticType.SUM_BY_RESOURCE
TOP_RESOURCES = UsageStatisticType.TOP_RESOURCES
SUM_BY_FEATURES = UsageStatisticType.SUM_BY_FEATURES
TOP_ACCOUNTS_BY_FEATURE = UsageStatisticType.TOP_ACCOUNTS_BY_FEATURE


@dataclass
class CFNDataSourceConfigurations:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    malware_protection: Optional[CFNMalwareProtectionConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_logs: Optional[CFNS3LogsConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kubernetes: Optional[CFNKubernetesConfiguration] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.malware_protection is not None:
            if hasattr(self.malware_protection, 'to_dict'):
                props['MalwareProtection'] = self.malware_protection.to_dict()
            elif isinstance(self.malware_protection, list):
                props['MalwareProtection'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.malware_protection
                ]
            else:
                props['MalwareProtection'] = self.malware_protection

        if self.s3_logs is not None:
            if hasattr(self.s3_logs, 'to_dict'):
                props['S3Logs'] = self.s3_logs.to_dict()
            elif isinstance(self.s3_logs, list):
                props['S3Logs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_logs
                ]
            else:
                props['S3Logs'] = self.s3_logs

        if self.kubernetes is not None:
            if hasattr(self.kubernetes, 'to_dict'):
                props['Kubernetes'] = self.kubernetes.to_dict()
            elif isinstance(self.kubernetes, list):
                props['Kubernetes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kubernetes
                ]
            else:
                props['Kubernetes'] = self.kubernetes

        return props


@dataclass
class CFNFeatureAdditionalConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.status is not None:
            if hasattr(self.status, 'to_dict'):
                props['Status'] = self.status.to_dict()
            elif isinstance(self.status, list):
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props['Status'] = self.status

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class CFNFeatureConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    additional_configuration: Optional[list[CFNFeatureAdditionalConfiguration]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.status is not None:
            if hasattr(self.status, 'to_dict'):
                props['Status'] = self.status.to_dict()
            elif isinstance(self.status, list):
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props['Status'] = self.status

        if self.additional_configuration is not None:
            if hasattr(self.additional_configuration, 'to_dict'):
                props['AdditionalConfiguration'] = self.additional_configuration.to_dict()
            elif isinstance(self.additional_configuration, list):
                props['AdditionalConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_configuration
                ]
            else:
                props['AdditionalConfiguration'] = self.additional_configuration

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class CFNKubernetesAuditLogsConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enable is not None:
            if hasattr(self.enable, 'to_dict'):
                props['Enable'] = self.enable.to_dict()
            elif isinstance(self.enable, list):
                props['Enable'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable
                ]
            else:
                props['Enable'] = self.enable

        return props


@dataclass
class CFNKubernetesConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    audit_logs: Optional[CFNKubernetesAuditLogsConfiguration] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.audit_logs is not None:
            if hasattr(self.audit_logs, 'to_dict'):
                props['AuditLogs'] = self.audit_logs.to_dict()
            elif isinstance(self.audit_logs, list):
                props['AuditLogs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.audit_logs
                ]
            else:
                props['AuditLogs'] = self.audit_logs

        return props


@dataclass
class CFNMalwareProtectionConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scan_ec2_instance_with_findings: Optional[CFNScanEc2InstanceWithFindingsConfiguration] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.scan_ec2_instance_with_findings is not None:
            if hasattr(self.scan_ec2_instance_with_findings, 'to_dict'):
                props['ScanEc2InstanceWithFindings'] = self.scan_ec2_instance_with_findings.to_dict()
            elif isinstance(self.scan_ec2_instance_with_findings, list):
                props['ScanEc2InstanceWithFindings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scan_ec2_instance_with_findings
                ]
            else:
                props['ScanEc2InstanceWithFindings'] = self.scan_ec2_instance_with_findings

        return props


@dataclass
class CFNS3LogsConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enable is not None:
            if hasattr(self.enable, 'to_dict'):
                props['Enable'] = self.enable.to_dict()
            elif isinstance(self.enable, list):
                props['Enable'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable
                ]
            else:
                props['Enable'] = self.enable

        return props


@dataclass
class CFNScanEc2InstanceWithFindingsConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs_volumes: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ebs_volumes is not None:
            if hasattr(self.ebs_volumes, 'to_dict'):
                props['EbsVolumes'] = self.ebs_volumes.to_dict()
            elif isinstance(self.ebs_volumes, list):
                props['EbsVolumes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_volumes
                ]
            else:
                props['EbsVolumes'] = self.ebs_volumes

        return props


@dataclass
class TagItem:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class Detector(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guard"""

    resource_type: ClassVar[str] = "AWS::GuardDuty::Detector"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    finding_publishing_frequency: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_sources: Optional[CFNDataSourceConfigurations] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    features: Optional[list[CFNFeatureConfiguration]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[TagItem]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.finding_publishing_frequency is not None:
            # Serialize finding_publishing_frequency (handle intrinsic functions)
            if hasattr(self.finding_publishing_frequency, 'to_dict'):
                props["FindingPublishingFrequency"] = self.finding_publishing_frequency.to_dict()
            elif isinstance(self.finding_publishing_frequency, list):
                # Serialize list items (may contain intrinsic functions)
                props['FindingPublishingFrequency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.finding_publishing_frequency
                ]
            else:
                props["FindingPublishingFrequency"] = self.finding_publishing_frequency

        if self.data_sources is not None:
            # Serialize data_sources (handle intrinsic functions)
            if hasattr(self.data_sources, 'to_dict'):
                props["DataSources"] = self.data_sources.to_dict()
            elif isinstance(self.data_sources, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataSources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_sources
                ]
            else:
                props["DataSources"] = self.data_sources

        if self.enable is not None:
            # Serialize enable (handle intrinsic functions)
            if hasattr(self.enable, 'to_dict'):
                props["Enable"] = self.enable.to_dict()
            elif isinstance(self.enable, list):
                # Serialize list items (may contain intrinsic functions)
                props['Enable'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable
                ]
            else:
                props["Enable"] = self.enable

        if self.features is not None:
            # Serialize features (handle intrinsic functions)
            if hasattr(self.features, 'to_dict'):
                props["Features"] = self.features.to_dict()
            elif isinstance(self.features, list):
                # Serialize list items (may contain intrinsic functions)
                props['Features'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.features
                ]
            else:
                props["Features"] = self.features

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class Condition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    equals: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    less_than: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    less_than_or_equal: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    greater_than: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lt: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    gte: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    neq: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    greater_than_or_equal: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    eq: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lte: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    gt: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    not_equals: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.equals is not None:
            if hasattr(self.equals, 'to_dict'):
                props['Equals'] = self.equals.to_dict()
            elif isinstance(self.equals, list):
                props['Equals'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.equals
                ]
            else:
                props['Equals'] = self.equals

        if self.less_than is not None:
            if hasattr(self.less_than, 'to_dict'):
                props['LessThan'] = self.less_than.to_dict()
            elif isinstance(self.less_than, list):
                props['LessThan'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.less_than
                ]
            else:
                props['LessThan'] = self.less_than

        if self.less_than_or_equal is not None:
            if hasattr(self.less_than_or_equal, 'to_dict'):
                props['LessThanOrEqual'] = self.less_than_or_equal.to_dict()
            elif isinstance(self.less_than_or_equal, list):
                props['LessThanOrEqual'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.less_than_or_equal
                ]
            else:
                props['LessThanOrEqual'] = self.less_than_or_equal

        if self.greater_than is not None:
            if hasattr(self.greater_than, 'to_dict'):
                props['GreaterThan'] = self.greater_than.to_dict()
            elif isinstance(self.greater_than, list):
                props['GreaterThan'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.greater_than
                ]
            else:
                props['GreaterThan'] = self.greater_than

        if self.lt is not None:
            if hasattr(self.lt, 'to_dict'):
                props['Lt'] = self.lt.to_dict()
            elif isinstance(self.lt, list):
                props['Lt'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lt
                ]
            else:
                props['Lt'] = self.lt

        if self.gte is not None:
            if hasattr(self.gte, 'to_dict'):
                props['Gte'] = self.gte.to_dict()
            elif isinstance(self.gte, list):
                props['Gte'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gte
                ]
            else:
                props['Gte'] = self.gte

        if self.neq is not None:
            if hasattr(self.neq, 'to_dict'):
                props['Neq'] = self.neq.to_dict()
            elif isinstance(self.neq, list):
                props['Neq'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.neq
                ]
            else:
                props['Neq'] = self.neq

        if self.greater_than_or_equal is not None:
            if hasattr(self.greater_than_or_equal, 'to_dict'):
                props['GreaterThanOrEqual'] = self.greater_than_or_equal.to_dict()
            elif isinstance(self.greater_than_or_equal, list):
                props['GreaterThanOrEqual'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.greater_than_or_equal
                ]
            else:
                props['GreaterThanOrEqual'] = self.greater_than_or_equal

        if self.eq is not None:
            if hasattr(self.eq, 'to_dict'):
                props['Eq'] = self.eq.to_dict()
            elif isinstance(self.eq, list):
                props['Eq'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.eq
                ]
            else:
                props['Eq'] = self.eq

        if self.lte is not None:
            if hasattr(self.lte, 'to_dict'):
                props['Lte'] = self.lte.to_dict()
            elif isinstance(self.lte, list):
                props['Lte'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lte
                ]
            else:
                props['Lte'] = self.lte

        if self.gt is not None:
            if hasattr(self.gt, 'to_dict'):
                props['Gt'] = self.gt.to_dict()
            elif isinstance(self.gt, list):
                props['Gt'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gt
                ]
            else:
                props['Gt'] = self.gt

        if self.not_equals is not None:
            if hasattr(self.not_equals, 'to_dict'):
                props['NotEquals'] = self.not_equals.to_dict()
            elif isinstance(self.not_equals, list):
                props['NotEquals'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.not_equals
                ]
            else:
                props['NotEquals'] = self.not_equals

        return props


@dataclass
class FindingCriteria:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    criterion: Optional[dict[str, Any]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.criterion is not None:
            if hasattr(self.criterion, 'to_dict'):
                props['Criterion'] = self.criterion.to_dict()
            elif isinstance(self.criterion, list):
                props['Criterion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.criterion
                ]
            else:
                props['Criterion'] = self.criterion

        return props


@dataclass
class TagItem:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class Filter(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guard"""

    resource_type: ClassVar[str] = "AWS::GuardDuty::Filter"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    detector_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    finding_criteria: Optional[FindingCriteria] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rank: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[TagItem]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.action is not None:
            # Serialize action (handle intrinsic functions)
            if hasattr(self.action, 'to_dict'):
                props["Action"] = self.action.to_dict()
            elif isinstance(self.action, list):
                # Serialize list items (may contain intrinsic functions)
                props['Action'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.action
                ]
            else:
                props["Action"] = self.action

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.detector_id is not None:
            # Serialize detector_id (handle intrinsic functions)
            if hasattr(self.detector_id, 'to_dict'):
                props["DetectorId"] = self.detector_id.to_dict()
            elif isinstance(self.detector_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DetectorId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.detector_id
                ]
            else:
                props["DetectorId"] = self.detector_id

        if self.finding_criteria is not None:
            # Serialize finding_criteria (handle intrinsic functions)
            if hasattr(self.finding_criteria, 'to_dict'):
                props["FindingCriteria"] = self.finding_criteria.to_dict()
            elif isinstance(self.finding_criteria, list):
                # Serialize list items (may contain intrinsic functions)
                props['FindingCriteria'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.finding_criteria
                ]
            else:
                props["FindingCriteria"] = self.finding_criteria

        if self.rank is not None:
            # Serialize rank (handle intrinsic functions)
            if hasattr(self.rank, 'to_dict'):
                props["Rank"] = self.rank.to_dict()
            elif isinstance(self.rank, list):
                # Serialize list items (may contain intrinsic functions)
                props['Rank'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rank
                ]
            else:
                props["Rank"] = self.rank

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props



@dataclass
class TagItem:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class IPSet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guard"""

    resource_type: ClassVar[str] = "AWS::GuardDuty::IPSet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    activate: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    detector_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    expected_bucket_owner: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[TagItem]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    location: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.format is not None:
            # Serialize format (handle intrinsic functions)
            if hasattr(self.format, 'to_dict'):
                props["Format"] = self.format.to_dict()
            elif isinstance(self.format, list):
                # Serialize list items (may contain intrinsic functions)
                props['Format'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.format
                ]
            else:
                props["Format"] = self.format

        if self.activate is not None:
            # Serialize activate (handle intrinsic functions)
            if hasattr(self.activate, 'to_dict'):
                props["Activate"] = self.activate.to_dict()
            elif isinstance(self.activate, list):
                # Serialize list items (may contain intrinsic functions)
                props['Activate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.activate
                ]
            else:
                props["Activate"] = self.activate

        if self.detector_id is not None:
            # Serialize detector_id (handle intrinsic functions)
            if hasattr(self.detector_id, 'to_dict'):
                props["DetectorId"] = self.detector_id.to_dict()
            elif isinstance(self.detector_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DetectorId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.detector_id
                ]
            else:
                props["DetectorId"] = self.detector_id

        if self.expected_bucket_owner is not None:
            # Serialize expected_bucket_owner (handle intrinsic functions)
            if hasattr(self.expected_bucket_owner, 'to_dict'):
                props["ExpectedBucketOwner"] = self.expected_bucket_owner.to_dict()
            elif isinstance(self.expected_bucket_owner, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExpectedBucketOwner'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.expected_bucket_owner
                ]
            else:
                props["ExpectedBucketOwner"] = self.expected_bucket_owner

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.location is not None:
            # Serialize location (handle intrinsic functions)
            if hasattr(self.location, 'to_dict'):
                props["Location"] = self.location.to_dict()
            elif isinstance(self.location, list):
                # Serialize list items (may contain intrinsic functions)
                props['Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location
                ]
            else:
                props["Location"] = self.location

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class CFNActions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tagging: Optional[CFNTagging] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.tagging is not None:
            if hasattr(self.tagging, 'to_dict'):
                props['Tagging'] = self.tagging.to_dict()
            elif isinstance(self.tagging, list):
                props['Tagging'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tagging
                ]
            else:
                props['Tagging'] = self.tagging

        return props


@dataclass
class CFNProtectedResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_bucket: Optional[S3Bucket] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_bucket is not None:
            if hasattr(self.s3_bucket, 'to_dict'):
                props['S3Bucket'] = self.s3_bucket.to_dict()
            elif isinstance(self.s3_bucket, list):
                props['S3Bucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_bucket
                ]
            else:
                props['S3Bucket'] = self.s3_bucket

        return props


@dataclass
class CFNStatusReasons:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    message: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    code: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.message is not None:
            if hasattr(self.message, 'to_dict'):
                props['Message'] = self.message.to_dict()
            elif isinstance(self.message, list):
                props['Message'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.message
                ]
            else:
                props['Message'] = self.message

        if self.code is not None:
            if hasattr(self.code, 'to_dict'):
                props['Code'] = self.code.to_dict()
            elif isinstance(self.code, list):
                props['Code'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code
                ]
            else:
                props['Code'] = self.code

        return props


@dataclass
class CFNTagging:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    status: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.status is not None:
            if hasattr(self.status, 'to_dict'):
                props['Status'] = self.status.to_dict()
            elif isinstance(self.status, list):
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props['Status'] = self.status

        return props


@dataclass
class S3Bucket:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    object_prefixes: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.bucket_name is not None:
            if hasattr(self.bucket_name, 'to_dict'):
                props['BucketName'] = self.bucket_name.to_dict()
            elif isinstance(self.bucket_name, list):
                props['BucketName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket_name
                ]
            else:
                props['BucketName'] = self.bucket_name

        if self.object_prefixes is not None:
            if hasattr(self.object_prefixes, 'to_dict'):
                props['ObjectPrefixes'] = self.object_prefixes.to_dict()
            elif isinstance(self.object_prefixes, list):
                props['ObjectPrefixes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.object_prefixes
                ]
            else:
                props['ObjectPrefixes'] = self.object_prefixes

        return props


@dataclass
class TagItem:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class MalwareProtectionPlan(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guard"""

    resource_type: ClassVar[str] = "AWS::GuardDuty::MalwareProtectionPlan"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    protected_resource: Optional[CFNProtectedResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    actions: Optional[CFNActions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[TagItem]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.role is not None:
            # Serialize role (handle intrinsic functions)
            if hasattr(self.role, 'to_dict'):
                props["Role"] = self.role.to_dict()
            elif isinstance(self.role, list):
                # Serialize list items (may contain intrinsic functions)
                props['Role'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role
                ]
            else:
                props["Role"] = self.role

        if self.protected_resource is not None:
            # Serialize protected_resource (handle intrinsic functions)
            if hasattr(self.protected_resource, 'to_dict'):
                props["ProtectedResource"] = self.protected_resource.to_dict()
            elif isinstance(self.protected_resource, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProtectedResource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protected_resource
                ]
            else:
                props["ProtectedResource"] = self.protected_resource

        if self.actions is not None:
            # Serialize actions (handle intrinsic functions)
            if hasattr(self.actions, 'to_dict'):
                props["Actions"] = self.actions.to_dict()
            elif isinstance(self.actions, list):
                # Serialize list items (may contain intrinsic functions)
                props['Actions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.actions
                ]
            else:
                props["Actions"] = self.actions

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_status_reasons(self) -> GetAtt:
        """Get the StatusReasons attribute."""
        return self.get_att("StatusReasons")

    @property
    def attr_created_at(self) -> GetAtt:
        """Get the CreatedAt attribute."""
        return self.get_att("CreatedAt")

    @property
    def attr_malware_protection_plan_id(self) -> GetAtt:
        """Get the MalwareProtectionPlanId attribute."""
        return self.get_att("MalwareProtectionPlanId")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class Master(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guard"""

    resource_type: ClassVar[str] = "AWS::GuardDuty::Master"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    detector_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    master_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    invitation_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.detector_id is not None:
            # Serialize detector_id (handle intrinsic functions)
            if hasattr(self.detector_id, 'to_dict'):
                props["DetectorId"] = self.detector_id.to_dict()
            elif isinstance(self.detector_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DetectorId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.detector_id
                ]
            else:
                props["DetectorId"] = self.detector_id

        if self.master_id is not None:
            # Serialize master_id (handle intrinsic functions)
            if hasattr(self.master_id, 'to_dict'):
                props["MasterId"] = self.master_id.to_dict()
            elif isinstance(self.master_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['MasterId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.master_id
                ]
            else:
                props["MasterId"] = self.master_id

        if self.invitation_id is not None:
            # Serialize invitation_id (handle intrinsic functions)
            if hasattr(self.invitation_id, 'to_dict'):
                props["InvitationId"] = self.invitation_id.to_dict()
            elif isinstance(self.invitation_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['InvitationId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.invitation_id
                ]
            else:
                props["InvitationId"] = self.invitation_id

        return props



@dataclass
class Member(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guard"""

    resource_type: ClassVar[str] = "AWS::GuardDuty::Member"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    member_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    email: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    message: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    disable_email_notification: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    detector_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.status is not None:
            # Serialize status (handle intrinsic functions)
            if hasattr(self.status, 'to_dict'):
                props["Status"] = self.status.to_dict()
            elif isinstance(self.status, list):
                # Serialize list items (may contain intrinsic functions)
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props["Status"] = self.status

        if self.member_id is not None:
            # Serialize member_id (handle intrinsic functions)
            if hasattr(self.member_id, 'to_dict'):
                props["MemberId"] = self.member_id.to_dict()
            elif isinstance(self.member_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['MemberId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.member_id
                ]
            else:
                props["MemberId"] = self.member_id

        if self.email is not None:
            # Serialize email (handle intrinsic functions)
            if hasattr(self.email, 'to_dict'):
                props["Email"] = self.email.to_dict()
            elif isinstance(self.email, list):
                # Serialize list items (may contain intrinsic functions)
                props['Email'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.email
                ]
            else:
                props["Email"] = self.email

        if self.message is not None:
            # Serialize message (handle intrinsic functions)
            if hasattr(self.message, 'to_dict'):
                props["Message"] = self.message.to_dict()
            elif isinstance(self.message, list):
                # Serialize list items (may contain intrinsic functions)
                props['Message'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.message
                ]
            else:
                props["Message"] = self.message

        if self.disable_email_notification is not None:
            # Serialize disable_email_notification (handle intrinsic functions)
            if hasattr(self.disable_email_notification, 'to_dict'):
                props["DisableEmailNotification"] = self.disable_email_notification.to_dict()
            elif isinstance(self.disable_email_notification, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisableEmailNotification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disable_email_notification
                ]
            else:
                props["DisableEmailNotification"] = self.disable_email_notification

        if self.detector_id is not None:
            # Serialize detector_id (handle intrinsic functions)
            if hasattr(self.detector_id, 'to_dict'):
                props["DetectorId"] = self.detector_id.to_dict()
            elif isinstance(self.detector_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DetectorId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.detector_id
                ]
            else:
                props["DetectorId"] = self.detector_id

        return props



@dataclass
class CFNDestinationProperties:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_arn is not None:
            if hasattr(self.kms_key_arn, 'to_dict'):
                props['KmsKeyArn'] = self.kms_key_arn.to_dict()
            elif isinstance(self.kms_key_arn, list):
                props['KmsKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_arn
                ]
            else:
                props['KmsKeyArn'] = self.kms_key_arn

        if self.destination_arn is not None:
            if hasattr(self.destination_arn, 'to_dict'):
                props['DestinationArn'] = self.destination_arn.to_dict()
            elif isinstance(self.destination_arn, list):
                props['DestinationArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_arn
                ]
            else:
                props['DestinationArn'] = self.destination_arn

        return props


@dataclass
class TagItem:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class PublishingDestination(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guard"""

    resource_type: ClassVar[str] = "AWS::GuardDuty::PublishingDestination"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_properties: Optional[CFNDestinationProperties] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    detector_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[TagItem]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination_properties is not None:
            # Serialize destination_properties (handle intrinsic functions)
            if hasattr(self.destination_properties, 'to_dict'):
                props["DestinationProperties"] = self.destination_properties.to_dict()
            elif isinstance(self.destination_properties, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationProperties'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_properties
                ]
            else:
                props["DestinationProperties"] = self.destination_properties

        if self.detector_id is not None:
            # Serialize detector_id (handle intrinsic functions)
            if hasattr(self.detector_id, 'to_dict'):
                props["DetectorId"] = self.detector_id.to_dict()
            elif isinstance(self.detector_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DetectorId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.detector_id
                ]
            else:
                props["DetectorId"] = self.detector_id

        if self.destination_type is not None:
            # Serialize destination_type (handle intrinsic functions)
            if hasattr(self.destination_type, 'to_dict'):
                props["DestinationType"] = self.destination_type.to_dict()
            elif isinstance(self.destination_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_type
                ]
            else:
                props["DestinationType"] = self.destination_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_publishing_failure_start_timestamp(self) -> GetAtt:
        """Get the PublishingFailureStartTimestamp attribute."""
        return self.get_att("PublishingFailureStartTimestamp")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class TagItem:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class ThreatEntitySet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guard"""

    resource_type: ClassVar[str] = "AWS::GuardDuty::ThreatEntitySet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    activate: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    detector_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    expected_bucket_owner: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[TagItem]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    location: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.format is not None:
            # Serialize format (handle intrinsic functions)
            if hasattr(self.format, 'to_dict'):
                props["Format"] = self.format.to_dict()
            elif isinstance(self.format, list):
                # Serialize list items (may contain intrinsic functions)
                props['Format'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.format
                ]
            else:
                props["Format"] = self.format

        if self.activate is not None:
            # Serialize activate (handle intrinsic functions)
            if hasattr(self.activate, 'to_dict'):
                props["Activate"] = self.activate.to_dict()
            elif isinstance(self.activate, list):
                # Serialize list items (may contain intrinsic functions)
                props['Activate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.activate
                ]
            else:
                props["Activate"] = self.activate

        if self.detector_id is not None:
            # Serialize detector_id (handle intrinsic functions)
            if hasattr(self.detector_id, 'to_dict'):
                props["DetectorId"] = self.detector_id.to_dict()
            elif isinstance(self.detector_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DetectorId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.detector_id
                ]
            else:
                props["DetectorId"] = self.detector_id

        if self.expected_bucket_owner is not None:
            # Serialize expected_bucket_owner (handle intrinsic functions)
            if hasattr(self.expected_bucket_owner, 'to_dict'):
                props["ExpectedBucketOwner"] = self.expected_bucket_owner.to_dict()
            elif isinstance(self.expected_bucket_owner, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExpectedBucketOwner'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.expected_bucket_owner
                ]
            else:
                props["ExpectedBucketOwner"] = self.expected_bucket_owner

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.location is not None:
            # Serialize location (handle intrinsic functions)
            if hasattr(self.location, 'to_dict'):
                props["Location"] = self.location.to_dict()
            elif isinstance(self.location, list):
                # Serialize list items (may contain intrinsic functions)
                props['Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location
                ]
            else:
                props["Location"] = self.location

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_created_at(self) -> GetAtt:
        """Get the CreatedAt attribute."""
        return self.get_att("CreatedAt")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")

    @property
    def attr_error_details(self) -> GetAtt:
        """Get the ErrorDetails attribute."""
        return self.get_att("ErrorDetails")

    @property
    def attr_updated_at(self) -> GetAtt:
        """Get the UpdatedAt attribute."""
        return self.get_att("UpdatedAt")




@dataclass
class TagItem:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class ThreatIntelSet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guard"""

    resource_type: ClassVar[str] = "AWS::GuardDuty::ThreatIntelSet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    activate: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    detector_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    expected_bucket_owner: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[TagItem]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    location: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.format is not None:
            # Serialize format (handle intrinsic functions)
            if hasattr(self.format, 'to_dict'):
                props["Format"] = self.format.to_dict()
            elif isinstance(self.format, list):
                # Serialize list items (may contain intrinsic functions)
                props['Format'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.format
                ]
            else:
                props["Format"] = self.format

        if self.activate is not None:
            # Serialize activate (handle intrinsic functions)
            if hasattr(self.activate, 'to_dict'):
                props["Activate"] = self.activate.to_dict()
            elif isinstance(self.activate, list):
                # Serialize list items (may contain intrinsic functions)
                props['Activate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.activate
                ]
            else:
                props["Activate"] = self.activate

        if self.detector_id is not None:
            # Serialize detector_id (handle intrinsic functions)
            if hasattr(self.detector_id, 'to_dict'):
                props["DetectorId"] = self.detector_id.to_dict()
            elif isinstance(self.detector_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DetectorId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.detector_id
                ]
            else:
                props["DetectorId"] = self.detector_id

        if self.expected_bucket_owner is not None:
            # Serialize expected_bucket_owner (handle intrinsic functions)
            if hasattr(self.expected_bucket_owner, 'to_dict'):
                props["ExpectedBucketOwner"] = self.expected_bucket_owner.to_dict()
            elif isinstance(self.expected_bucket_owner, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExpectedBucketOwner'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.expected_bucket_owner
                ]
            else:
                props["ExpectedBucketOwner"] = self.expected_bucket_owner

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.location is not None:
            # Serialize location (handle intrinsic functions)
            if hasattr(self.location, 'to_dict'):
                props["Location"] = self.location.to_dict()
            elif isinstance(self.location, list):
                # Serialize list items (may contain intrinsic functions)
                props['Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location
                ]
            else:
                props["Location"] = self.location

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class TagItem:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-gua"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class TrustedEntitySet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-guard"""

    resource_type: ClassVar[str] = "AWS::GuardDuty::TrustedEntitySet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    activate: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    detector_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    expected_bucket_owner: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[TagItem]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    location: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.format is not None:
            # Serialize format (handle intrinsic functions)
            if hasattr(self.format, 'to_dict'):
                props["Format"] = self.format.to_dict()
            elif isinstance(self.format, list):
                # Serialize list items (may contain intrinsic functions)
                props['Format'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.format
                ]
            else:
                props["Format"] = self.format

        if self.activate is not None:
            # Serialize activate (handle intrinsic functions)
            if hasattr(self.activate, 'to_dict'):
                props["Activate"] = self.activate.to_dict()
            elif isinstance(self.activate, list):
                # Serialize list items (may contain intrinsic functions)
                props['Activate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.activate
                ]
            else:
                props["Activate"] = self.activate

        if self.detector_id is not None:
            # Serialize detector_id (handle intrinsic functions)
            if hasattr(self.detector_id, 'to_dict'):
                props["DetectorId"] = self.detector_id.to_dict()
            elif isinstance(self.detector_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DetectorId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.detector_id
                ]
            else:
                props["DetectorId"] = self.detector_id

        if self.expected_bucket_owner is not None:
            # Serialize expected_bucket_owner (handle intrinsic functions)
            if hasattr(self.expected_bucket_owner, 'to_dict'):
                props["ExpectedBucketOwner"] = self.expected_bucket_owner.to_dict()
            elif isinstance(self.expected_bucket_owner, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExpectedBucketOwner'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.expected_bucket_owner
                ]
            else:
                props["ExpectedBucketOwner"] = self.expected_bucket_owner

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.location is not None:
            # Serialize location (handle intrinsic functions)
            if hasattr(self.location, 'to_dict'):
                props["Location"] = self.location.to_dict()
            elif isinstance(self.location, list):
                # Serialize list items (may contain intrinsic functions)
                props['Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location
                ]
            else:
                props["Location"] = self.location

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_created_at(self) -> GetAtt:
        """Get the CreatedAt attribute."""
        return self.get_att("CreatedAt")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")

    @property
    def attr_error_details(self) -> GetAtt:
        """Get the ErrorDetails attribute."""
        return self.get_att("ErrorDetails")

    @property
    def attr_updated_at(self) -> GetAtt:
        """Get the UpdatedAt attribute."""
        return self.get_att("UpdatedAt")



