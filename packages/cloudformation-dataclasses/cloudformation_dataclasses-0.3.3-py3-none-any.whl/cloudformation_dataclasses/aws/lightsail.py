"""
AWS CloudFormation Lightsail Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:37

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service Lightsail
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AccessDirection:
    """AccessDirection enum values."""

    INBOUND = "inbound"
    OUTBOUND = "outbound"


class AccessType:
    """AccessType enum values."""

    PUBLIC = "public"
    PRIVATE = "private"


class AccountLevelBpaSyncStatus:
    """AccountLevelBpaSyncStatus enum values."""

    INSYNC = "InSync"
    FAILED = "Failed"
    NEVERSYNCED = "NeverSynced"
    DEFAULTED = "Defaulted"


class AddOnType:
    """AddOnType enum values."""

    AUTOSNAPSHOT = "AutoSnapshot"
    STOPINSTANCEONIDLE = "StopInstanceOnIdle"


class AlarmState:
    """AlarmState enum values."""

    OK = "OK"
    ALARM = "ALARM"
    INSUFFICIENT_DATA = "INSUFFICIENT_DATA"


class AppCategory:
    """AppCategory enum values."""

    LFR = "LfR"


class AutoMountStatus:
    """AutoMountStatus enum values."""

    FAILED = "Failed"
    PENDING = "Pending"
    MOUNTED = "Mounted"
    NOTMOUNTED = "NotMounted"


class AutoSnapshotStatus:
    """AutoSnapshotStatus enum values."""

    SUCCESS = "Success"
    FAILED = "Failed"
    INPROGRESS = "InProgress"
    NOTFOUND = "NotFound"


class BPAStatusMessage:
    """BPAStatusMessage enum values."""

    DEFAULTED_FOR_SLR_MISSING = "DEFAULTED_FOR_SLR_MISSING"
    SYNC_ON_HOLD = "SYNC_ON_HOLD"
    DEFAULTED_FOR_SLR_MISSING_ON_HOLD = "DEFAULTED_FOR_SLR_MISSING_ON_HOLD"
    UNKNOWN = "Unknown"


class BehaviorEnum:
    """BehaviorEnum enum values."""

    DONT_CACHE = "dont-cache"
    CACHE = "cache"


class BlueprintType:
    """BlueprintType enum values."""

    OS = "os"
    APP = "app"


class BucketMetricName:
    """BucketMetricName enum values."""

    BUCKETSIZEBYTES = "BucketSizeBytes"
    NUMBEROFOBJECTS = "NumberOfObjects"


class CertificateDomainValidationStatus:
    """CertificateDomainValidationStatus enum values."""

    PENDING_VALIDATION = "PENDING_VALIDATION"
    FAILED = "FAILED"
    SUCCESS = "SUCCESS"


class CertificateProvider:
    """CertificateProvider enum values."""

    LETSENCRYPT = "LetsEncrypt"


class CertificateStatus:
    """CertificateStatus enum values."""

    PENDING_VALIDATION = "PENDING_VALIDATION"
    ISSUED = "ISSUED"
    INACTIVE = "INACTIVE"
    EXPIRED = "EXPIRED"
    VALIDATION_TIMED_OUT = "VALIDATION_TIMED_OUT"
    REVOKED = "REVOKED"
    FAILED = "FAILED"


class CloudFormationStackRecordSourceType:
    """CloudFormationStackRecordSourceType enum values."""

    EXPORTSNAPSHOTRECORD = "ExportSnapshotRecord"


class ComparisonOperator:
    """ComparisonOperator enum values."""

    GREATERTHANOREQUALTOTHRESHOLD = "GreaterThanOrEqualToThreshold"
    GREATERTHANTHRESHOLD = "GreaterThanThreshold"
    LESSTHANTHRESHOLD = "LessThanThreshold"
    LESSTHANOREQUALTOTHRESHOLD = "LessThanOrEqualToThreshold"


class ContactMethodStatus:
    """ContactMethodStatus enum values."""

    PENDINGVERIFICATION = "PendingVerification"
    VALID = "Valid"
    INVALID = "Invalid"


class ContactMethodVerificationProtocol:
    """ContactMethodVerificationProtocol enum values."""

    EMAIL = "Email"


class ContactProtocol:
    """ContactProtocol enum values."""

    EMAIL = "Email"
    SMS = "SMS"


class ContainerServiceDeploymentState:
    """ContainerServiceDeploymentState enum values."""

    ACTIVATING = "ACTIVATING"
    ACTIVE = "ACTIVE"
    INACTIVE = "INACTIVE"
    FAILED = "FAILED"


class ContainerServiceMetricName:
    """ContainerServiceMetricName enum values."""

    CPUUTILIZATION = "CPUUtilization"
    MEMORYUTILIZATION = "MemoryUtilization"


class ContainerServicePowerName:
    """ContainerServicePowerName enum values."""

    NANO = "nano"
    MICRO = "micro"
    SMALL = "small"
    MEDIUM = "medium"
    LARGE = "large"
    XLARGE = "xlarge"


class ContainerServiceProtocol:
    """ContainerServiceProtocol enum values."""

    HTTP = "HTTP"
    HTTPS = "HTTPS"
    TCP = "TCP"
    UDP = "UDP"


class ContainerServiceState:
    """ContainerServiceState enum values."""

    PENDING = "PENDING"
    READY = "READY"
    RUNNING = "RUNNING"
    UPDATING = "UPDATING"
    DELETING = "DELETING"
    DISABLED = "DISABLED"
    DEPLOYING = "DEPLOYING"


class ContainerServiceStateDetailCode:
    """ContainerServiceStateDetailCode enum values."""

    CREATING_SYSTEM_RESOURCES = "CREATING_SYSTEM_RESOURCES"
    CREATING_NETWORK_INFRASTRUCTURE = "CREATING_NETWORK_INFRASTRUCTURE"
    PROVISIONING_CERTIFICATE = "PROVISIONING_CERTIFICATE"
    PROVISIONING_SERVICE = "PROVISIONING_SERVICE"
    CREATING_DEPLOYMENT = "CREATING_DEPLOYMENT"
    EVALUATING_HEALTH_CHECK = "EVALUATING_HEALTH_CHECK"
    ACTIVATING_DEPLOYMENT = "ACTIVATING_DEPLOYMENT"
    CERTIFICATE_LIMIT_EXCEEDED = "CERTIFICATE_LIMIT_EXCEEDED"
    UNKNOWN_ERROR = "UNKNOWN_ERROR"


class Currency:
    """Currency enum values."""

    USD = "USD"


class DiskSnapshotState:
    """DiskSnapshotState enum values."""

    PENDING = "pending"
    COMPLETED = "completed"
    ERROR = "error"
    UNKNOWN = "unknown"


class DiskState:
    """DiskState enum values."""

    PENDING = "pending"
    ERROR = "error"
    AVAILABLE = "available"
    IN_USE = "in-use"
    UNKNOWN = "unknown"


class DistributionMetricName:
    """DistributionMetricName enum values."""

    REQUESTS = "Requests"
    BYTESDOWNLOADED = "BytesDownloaded"
    BYTESUPLOADED = "BytesUploaded"
    TOTALERRORRATE = "TotalErrorRate"
    HTTP4XXERRORRATE = "Http4xxErrorRate"
    HTTP5XXERRORRATE = "Http5xxErrorRate"


class DnsRecordCreationStateCode:
    """DnsRecordCreationStateCode enum values."""

    SUCCEEDED = "SUCCEEDED"
    STARTED = "STARTED"
    FAILED = "FAILED"


class ExportSnapshotRecordSourceType:
    """ExportSnapshotRecordSourceType enum values."""

    INSTANCESNAPSHOT = "InstanceSnapshot"
    DISKSNAPSHOT = "DiskSnapshot"


class ForwardValues:
    """ForwardValues enum values."""

    NONE = "none"
    ALLOW_LIST = "allow-list"
    ALL = "all"


class HeaderEnum:
    """HeaderEnum enum values."""

    ACCEPT = "Accept"
    ACCEPT_CHARSET = "Accept-Charset"
    ACCEPT_DATETIME = "Accept-Datetime"
    ACCEPT_ENCODING = "Accept-Encoding"
    ACCEPT_LANGUAGE = "Accept-Language"
    AUTHORIZATION = "Authorization"
    CLOUDFRONT_FORWARDED_PROTO = "CloudFront-Forwarded-Proto"
    CLOUDFRONT_IS_DESKTOP_VIEWER = "CloudFront-Is-Desktop-Viewer"
    CLOUDFRONT_IS_MOBILE_VIEWER = "CloudFront-Is-Mobile-Viewer"
    CLOUDFRONT_IS_SMARTTV_VIEWER = "CloudFront-Is-SmartTV-Viewer"
    CLOUDFRONT_IS_TABLET_VIEWER = "CloudFront-Is-Tablet-Viewer"
    CLOUDFRONT_VIEWER_COUNTRY = "CloudFront-Viewer-Country"
    HOST = "Host"
    ORIGIN = "Origin"
    REFERER = "Referer"


class HttpEndpoint:
    """HttpEndpoint enum values."""

    DISABLED = "disabled"
    ENABLED = "enabled"


class HttpProtocolIpv6:
    """HttpProtocolIpv6 enum values."""

    DISABLED = "disabled"
    ENABLED = "enabled"


class HttpTokens:
    """HttpTokens enum values."""

    OPTIONAL = "optional"
    REQUIRED = "required"


class InstanceAccessProtocol:
    """InstanceAccessProtocol enum values."""

    SSH = "ssh"
    RDP = "rdp"


class InstanceHealthReason:
    """InstanceHealthReason enum values."""

    LB_REGISTRATIONINPROGRESS = "Lb.RegistrationInProgress"
    LB_INITIALHEALTHCHECKING = "Lb.InitialHealthChecking"
    LB_INTERNALERROR = "Lb.InternalError"
    INSTANCE_RESPONSECODEMISMATCH = "Instance.ResponseCodeMismatch"
    INSTANCE_TIMEOUT = "Instance.Timeout"
    INSTANCE_FAILEDHEALTHCHECKS = "Instance.FailedHealthChecks"
    INSTANCE_NOTREGISTERED = "Instance.NotRegistered"
    INSTANCE_NOTINUSE = "Instance.NotInUse"
    INSTANCE_DEREGISTRATIONINPROGRESS = "Instance.DeregistrationInProgress"
    INSTANCE_INVALIDSTATE = "Instance.InvalidState"
    INSTANCE_IPUNUSABLE = "Instance.IpUnusable"


class InstanceHealthState:
    """InstanceHealthState enum values."""

    INITIAL = "initial"
    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    UNUSED = "unused"
    DRAINING = "draining"
    UNAVAILABLE = "unavailable"


class InstanceMetadataState:
    """InstanceMetadataState enum values."""

    PENDING = "pending"
    APPLIED = "applied"


class InstanceMetricName:
    """InstanceMetricName enum values."""

    CPUUTILIZATION = "CPUUtilization"
    NETWORKIN = "NetworkIn"
    NETWORKOUT = "NetworkOut"
    STATUSCHECKFAILED = "StatusCheckFailed"
    STATUSCHECKFAILED_INSTANCE = "StatusCheckFailed_Instance"
    STATUSCHECKFAILED_SYSTEM = "StatusCheckFailed_System"
    BURSTCAPACITYTIME = "BurstCapacityTime"
    BURSTCAPACITYPERCENTAGE = "BurstCapacityPercentage"
    METADATANOTOKEN = "MetadataNoToken"


class InstancePlatform:
    """InstancePlatform enum values."""

    LINUX_UNIX = "LINUX_UNIX"
    WINDOWS = "WINDOWS"


class InstanceSnapshotState:
    """InstanceSnapshotState enum values."""

    PENDING = "pending"
    ERROR = "error"
    AVAILABLE = "available"


class IpAddressType:
    """IpAddressType enum values."""

    DUALSTACK = "dualstack"
    IPV4 = "ipv4"
    IPV6 = "ipv6"


class LoadBalancerAttributeName:
    """LoadBalancerAttributeName enum values."""

    HEALTHCHECKPATH = "HealthCheckPath"
    SESSIONSTICKINESSENABLED = "SessionStickinessEnabled"
    SESSIONSTICKINESS_LB_COOKIEDURATIONSECONDS = "SessionStickiness_LB_CookieDurationSeconds"
    HTTPSREDIRECTIONENABLED = "HttpsRedirectionEnabled"
    TLSPOLICYNAME = "TlsPolicyName"


class LoadBalancerMetricName:
    """LoadBalancerMetricName enum values."""

    CLIENTTLSNEGOTIATIONERRORCOUNT = "ClientTLSNegotiationErrorCount"
    HEALTHYHOSTCOUNT = "HealthyHostCount"
    UNHEALTHYHOSTCOUNT = "UnhealthyHostCount"
    HTTPCODE_LB_4XX_COUNT = "HTTPCode_LB_4XX_Count"
    HTTPCODE_LB_5XX_COUNT = "HTTPCode_LB_5XX_Count"
    HTTPCODE_INSTANCE_2XX_COUNT = "HTTPCode_Instance_2XX_Count"
    HTTPCODE_INSTANCE_3XX_COUNT = "HTTPCode_Instance_3XX_Count"
    HTTPCODE_INSTANCE_4XX_COUNT = "HTTPCode_Instance_4XX_Count"
    HTTPCODE_INSTANCE_5XX_COUNT = "HTTPCode_Instance_5XX_Count"
    INSTANCERESPONSETIME = "InstanceResponseTime"
    REJECTEDCONNECTIONCOUNT = "RejectedConnectionCount"
    REQUESTCOUNT = "RequestCount"


class LoadBalancerProtocol:
    """LoadBalancerProtocol enum values."""

    HTTP_HTTPS = "HTTP_HTTPS"
    HTTP = "HTTP"


class LoadBalancerState:
    """LoadBalancerState enum values."""

    ACTIVE = "active"
    PROVISIONING = "provisioning"
    ACTIVE_IMPAIRED = "active_impaired"
    FAILED = "failed"
    UNKNOWN = "unknown"


class LoadBalancerTlsCertificateDnsRecordCreationStateCode:
    """LoadBalancerTlsCertificateDnsRecordCreationStateCode enum values."""

    SUCCEEDED = "SUCCEEDED"
    STARTED = "STARTED"
    FAILED = "FAILED"


class LoadBalancerTlsCertificateDomainStatus:
    """LoadBalancerTlsCertificateDomainStatus enum values."""

    PENDING_VALIDATION = "PENDING_VALIDATION"
    FAILED = "FAILED"
    SUCCESS = "SUCCESS"


class LoadBalancerTlsCertificateFailureReason:
    """LoadBalancerTlsCertificateFailureReason enum values."""

    NO_AVAILABLE_CONTACTS = "NO_AVAILABLE_CONTACTS"
    ADDITIONAL_VERIFICATION_REQUIRED = "ADDITIONAL_VERIFICATION_REQUIRED"
    DOMAIN_NOT_ALLOWED = "DOMAIN_NOT_ALLOWED"
    INVALID_PUBLIC_DOMAIN = "INVALID_PUBLIC_DOMAIN"
    OTHER = "OTHER"


class LoadBalancerTlsCertificateRenewalStatus:
    """LoadBalancerTlsCertificateRenewalStatus enum values."""

    PENDING_AUTO_RENEWAL = "PENDING_AUTO_RENEWAL"
    PENDING_VALIDATION = "PENDING_VALIDATION"
    SUCCESS = "SUCCESS"
    FAILED = "FAILED"


class LoadBalancerTlsCertificateRevocationReason:
    """LoadBalancerTlsCertificateRevocationReason enum values."""

    UNSPECIFIED = "UNSPECIFIED"
    KEY_COMPROMISE = "KEY_COMPROMISE"
    CA_COMPROMISE = "CA_COMPROMISE"
    AFFILIATION_CHANGED = "AFFILIATION_CHANGED"
    SUPERCEDED = "SUPERCEDED"
    CESSATION_OF_OPERATION = "CESSATION_OF_OPERATION"
    CERTIFICATE_HOLD = "CERTIFICATE_HOLD"
    REMOVE_FROM_CRL = "REMOVE_FROM_CRL"
    PRIVILEGE_WITHDRAWN = "PRIVILEGE_WITHDRAWN"
    A_A_COMPROMISE = "A_A_COMPROMISE"


class LoadBalancerTlsCertificateStatus:
    """LoadBalancerTlsCertificateStatus enum values."""

    PENDING_VALIDATION = "PENDING_VALIDATION"
    ISSUED = "ISSUED"
    INACTIVE = "INACTIVE"
    EXPIRED = "EXPIRED"
    VALIDATION_TIMED_OUT = "VALIDATION_TIMED_OUT"
    REVOKED = "REVOKED"
    FAILED = "FAILED"
    UNKNOWN = "UNKNOWN"


class MetricName:
    """MetricName enum values."""

    CPUUTILIZATION = "CPUUtilization"
    NETWORKIN = "NetworkIn"
    NETWORKOUT = "NetworkOut"
    STATUSCHECKFAILED = "StatusCheckFailed"
    STATUSCHECKFAILED_INSTANCE = "StatusCheckFailed_Instance"
    STATUSCHECKFAILED_SYSTEM = "StatusCheckFailed_System"
    CLIENTTLSNEGOTIATIONERRORCOUNT = "ClientTLSNegotiationErrorCount"
    HEALTHYHOSTCOUNT = "HealthyHostCount"
    UNHEALTHYHOSTCOUNT = "UnhealthyHostCount"
    HTTPCODE_LB_4XX_COUNT = "HTTPCode_LB_4XX_Count"
    HTTPCODE_LB_5XX_COUNT = "HTTPCode_LB_5XX_Count"
    HTTPCODE_INSTANCE_2XX_COUNT = "HTTPCode_Instance_2XX_Count"
    HTTPCODE_INSTANCE_3XX_COUNT = "HTTPCode_Instance_3XX_Count"
    HTTPCODE_INSTANCE_4XX_COUNT = "HTTPCode_Instance_4XX_Count"
    HTTPCODE_INSTANCE_5XX_COUNT = "HTTPCode_Instance_5XX_Count"
    INSTANCERESPONSETIME = "InstanceResponseTime"
    REJECTEDCONNECTIONCOUNT = "RejectedConnectionCount"
    REQUESTCOUNT = "RequestCount"
    DATABASECONNECTIONS = "DatabaseConnections"
    DISKQUEUEDEPTH = "DiskQueueDepth"
    FREESTORAGESPACE = "FreeStorageSpace"
    NETWORKRECEIVETHROUGHPUT = "NetworkReceiveThroughput"
    NETWORKTRANSMITTHROUGHPUT = "NetworkTransmitThroughput"
    BURSTCAPACITYTIME = "BurstCapacityTime"
    BURSTCAPACITYPERCENTAGE = "BurstCapacityPercentage"


class MetricStatistic:
    """MetricStatistic enum values."""

    MINIMUM = "Minimum"
    MAXIMUM = "Maximum"
    SUM = "Sum"
    AVERAGE = "Average"
    SAMPLECOUNT = "SampleCount"


class MetricUnit:
    """MetricUnit enum values."""

    SECONDS = "Seconds"
    MICROSECONDS = "Microseconds"
    MILLISECONDS = "Milliseconds"
    BYTES = "Bytes"
    KILOBYTES = "Kilobytes"
    MEGABYTES = "Megabytes"
    GIGABYTES = "Gigabytes"
    TERABYTES = "Terabytes"
    BITS = "Bits"
    KILOBITS = "Kilobits"
    MEGABITS = "Megabits"
    GIGABITS = "Gigabits"
    TERABITS = "Terabits"
    PERCENT = "Percent"
    COUNT = "Count"
    BYTES_SECOND = "Bytes/Second"
    KILOBYTES_SECOND = "Kilobytes/Second"
    MEGABYTES_SECOND = "Megabytes/Second"
    GIGABYTES_SECOND = "Gigabytes/Second"
    TERABYTES_SECOND = "Terabytes/Second"
    BITS_SECOND = "Bits/Second"
    KILOBITS_SECOND = "Kilobits/Second"
    MEGABITS_SECOND = "Megabits/Second"
    GIGABITS_SECOND = "Gigabits/Second"
    TERABITS_SECOND = "Terabits/Second"
    COUNT_SECOND = "Count/Second"
    NONE = "None"


class NameServersUpdateStateCode:
    """NameServersUpdateStateCode enum values."""

    SUCCEEDED = "SUCCEEDED"
    PENDING = "PENDING"
    FAILED = "FAILED"
    STARTED = "STARTED"


class NetworkProtocol:
    """NetworkProtocol enum values."""

    TCP = "tcp"
    ALL = "all"
    UDP = "udp"
    ICMP = "icmp"
    ICMPV6 = "icmpv6"


class OperationStatus:
    """OperationStatus enum values."""

    NOTSTARTED = "NotStarted"
    STARTED = "Started"
    FAILED = "Failed"
    COMPLETED = "Completed"
    SUCCEEDED = "Succeeded"


class OperationType:
    """OperationType enum values."""

    DELETEKNOWNHOSTKEYS = "DeleteKnownHostKeys"
    DELETEINSTANCE = "DeleteInstance"
    CREATEINSTANCE = "CreateInstance"
    STOPINSTANCE = "StopInstance"
    STARTINSTANCE = "StartInstance"
    REBOOTINSTANCE = "RebootInstance"
    OPENINSTANCEPUBLICPORTS = "OpenInstancePublicPorts"
    PUTINSTANCEPUBLICPORTS = "PutInstancePublicPorts"
    CLOSEINSTANCEPUBLICPORTS = "CloseInstancePublicPorts"
    ALLOCATESTATICIP = "AllocateStaticIp"
    RELEASESTATICIP = "ReleaseStaticIp"
    ATTACHSTATICIP = "AttachStaticIp"
    DETACHSTATICIP = "DetachStaticIp"
    UPDATEDOMAINENTRY = "UpdateDomainEntry"
    DELETEDOMAINENTRY = "DeleteDomainEntry"
    CREATEDOMAIN = "CreateDomain"
    DELETEDOMAIN = "DeleteDomain"
    CREATEINSTANCESNAPSHOT = "CreateInstanceSnapshot"
    DELETEINSTANCESNAPSHOT = "DeleteInstanceSnapshot"
    CREATEINSTANCESFROMSNAPSHOT = "CreateInstancesFromSnapshot"
    CREATELOADBALANCER = "CreateLoadBalancer"
    DELETELOADBALANCER = "DeleteLoadBalancer"
    ATTACHINSTANCESTOLOADBALANCER = "AttachInstancesToLoadBalancer"
    DETACHINSTANCESFROMLOADBALANCER = "DetachInstancesFromLoadBalancer"
    UPDATELOADBALANCERATTRIBUTE = "UpdateLoadBalancerAttribute"
    CREATELOADBALANCERTLSCERTIFICATE = "CreateLoadBalancerTlsCertificate"
    DELETELOADBALANCERTLSCERTIFICATE = "DeleteLoadBalancerTlsCertificate"
    ATTACHLOADBALANCERTLSCERTIFICATE = "AttachLoadBalancerTlsCertificate"
    CREATEDISK = "CreateDisk"
    DELETEDISK = "DeleteDisk"
    ATTACHDISK = "AttachDisk"
    DETACHDISK = "DetachDisk"
    CREATEDISKSNAPSHOT = "CreateDiskSnapshot"
    DELETEDISKSNAPSHOT = "DeleteDiskSnapshot"
    CREATEDISKFROMSNAPSHOT = "CreateDiskFromSnapshot"
    CREATERELATIONALDATABASE = "CreateRelationalDatabase"
    UPDATERELATIONALDATABASE = "UpdateRelationalDatabase"
    DELETERELATIONALDATABASE = "DeleteRelationalDatabase"
    CREATERELATIONALDATABASEFROMSNAPSHOT = "CreateRelationalDatabaseFromSnapshot"
    CREATERELATIONALDATABASESNAPSHOT = "CreateRelationalDatabaseSnapshot"
    DELETERELATIONALDATABASESNAPSHOT = "DeleteRelationalDatabaseSnapshot"
    UPDATERELATIONALDATABASEPARAMETERS = "UpdateRelationalDatabaseParameters"
    STARTRELATIONALDATABASE = "StartRelationalDatabase"
    REBOOTRELATIONALDATABASE = "RebootRelationalDatabase"
    STOPRELATIONALDATABASE = "StopRelationalDatabase"
    ENABLEADDON = "EnableAddOn"
    DISABLEADDON = "DisableAddOn"
    PUTALARM = "PutAlarm"
    GETALARMS = "GetAlarms"
    DELETEALARM = "DeleteAlarm"
    TESTALARM = "TestAlarm"
    CREATECONTACTMETHOD = "CreateContactMethod"
    GETCONTACTMETHODS = "GetContactMethods"
    SENDCONTACTMETHODVERIFICATION = "SendContactMethodVerification"
    DELETECONTACTMETHOD = "DeleteContactMethod"
    CREATEDISTRIBUTION = "CreateDistribution"
    UPDATEDISTRIBUTION = "UpdateDistribution"
    DELETEDISTRIBUTION = "DeleteDistribution"
    RESETDISTRIBUTIONCACHE = "ResetDistributionCache"
    ATTACHCERTIFICATETODISTRIBUTION = "AttachCertificateToDistribution"
    DETACHCERTIFICATEFROMDISTRIBUTION = "DetachCertificateFromDistribution"
    UPDATEDISTRIBUTIONBUNDLE = "UpdateDistributionBundle"
    SETIPADDRESSTYPE = "SetIpAddressType"
    CREATECERTIFICATE = "CreateCertificate"
    DELETECERTIFICATE = "DeleteCertificate"
    CREATECONTAINERSERVICE = "CreateContainerService"
    UPDATECONTAINERSERVICE = "UpdateContainerService"
    DELETECONTAINERSERVICE = "DeleteContainerService"
    CREATECONTAINERSERVICEDEPLOYMENT = "CreateContainerServiceDeployment"
    CREATECONTAINERSERVICEREGISTRYLOGIN = "CreateContainerServiceRegistryLogin"
    REGISTERCONTAINERIMAGE = "RegisterContainerImage"
    DELETECONTAINERIMAGE = "DeleteContainerImage"
    CREATEBUCKET = "CreateBucket"
    DELETEBUCKET = "DeleteBucket"
    CREATEBUCKETACCESSKEY = "CreateBucketAccessKey"
    DELETEBUCKETACCESSKEY = "DeleteBucketAccessKey"
    UPDATEBUCKETBUNDLE = "UpdateBucketBundle"
    UPDATEBUCKET = "UpdateBucket"
    SETRESOURCEACCESSFORBUCKET = "SetResourceAccessForBucket"
    UPDATEINSTANCEMETADATAOPTIONS = "UpdateInstanceMetadataOptions"
    STARTGUISESSION = "StartGUISession"
    STOPGUISESSION = "StopGUISession"
    SETUPINSTANCEHTTPS = "SetupInstanceHttps"


class OriginProtocolPolicyEnum:
    """OriginProtocolPolicyEnum enum values."""

    HTTP_ONLY = "http-only"
    HTTPS_ONLY = "https-only"


class PortAccessType:
    """PortAccessType enum values."""

    PUBLIC = "Public"
    PRIVATE = "Private"


class PortInfoSourceType:
    """PortInfoSourceType enum values."""

    DEFAULT = "DEFAULT"
    INSTANCE = "INSTANCE"
    NONE = "NONE"
    CLOSED = "CLOSED"


class PortState:
    """PortState enum values."""

    OPEN = "open"
    CLOSED = "closed"


class PricingUnit:
    """PricingUnit enum values."""

    GB = "GB"
    HRS = "Hrs"
    GB_MO = "GB-Mo"
    BUNDLES = "Bundles"
    QUERIES = "Queries"


class R53HostedZoneDeletionStateCode:
    """R53HostedZoneDeletionStateCode enum values."""

    SUCCEEDED = "SUCCEEDED"
    PENDING = "PENDING"
    FAILED = "FAILED"
    STARTED = "STARTED"


class RecordState:
    """RecordState enum values."""

    STARTED = "Started"
    SUCCEEDED = "Succeeded"
    FAILED = "Failed"


class RegionName:
    """RegionName enum values."""

    US_EAST_1 = "us-east-1"
    US_EAST_2 = "us-east-2"
    US_WEST_1 = "us-west-1"
    US_WEST_2 = "us-west-2"
    EU_WEST_1 = "eu-west-1"
    EU_WEST_2 = "eu-west-2"
    EU_WEST_3 = "eu-west-3"
    EU_CENTRAL_1 = "eu-central-1"
    CA_CENTRAL_1 = "ca-central-1"
    AP_SOUTH_1 = "ap-south-1"
    AP_SOUTHEAST_1 = "ap-southeast-1"
    AP_SOUTHEAST_2 = "ap-southeast-2"
    AP_NORTHEAST_1 = "ap-northeast-1"
    AP_NORTHEAST_2 = "ap-northeast-2"
    EU_NORTH_1 = "eu-north-1"
    AP_SOUTHEAST_3 = "ap-southeast-3"


class RelationalDatabaseEngine:
    """RelationalDatabaseEngine enum values."""

    MYSQL = "mysql"


class RelationalDatabaseMetricName:
    """RelationalDatabaseMetricName enum values."""

    CPUUTILIZATION = "CPUUtilization"
    DATABASECONNECTIONS = "DatabaseConnections"
    DISKQUEUEDEPTH = "DiskQueueDepth"
    FREESTORAGESPACE = "FreeStorageSpace"
    NETWORKRECEIVETHROUGHPUT = "NetworkReceiveThroughput"
    NETWORKTRANSMITTHROUGHPUT = "NetworkTransmitThroughput"


class RelationalDatabasePasswordVersion:
    """RelationalDatabasePasswordVersion enum values."""

    CURRENT = "CURRENT"
    PREVIOUS = "PREVIOUS"
    PENDING = "PENDING"


class RenewalStatus:
    """RenewalStatus enum values."""

    PENDINGAUTORENEWAL = "PendingAutoRenewal"
    PENDINGVALIDATION = "PendingValidation"
    SUCCESS = "Success"
    FAILED = "Failed"


class ResourceBucketAccess:
    """ResourceBucketAccess enum values."""

    ALLOW = "allow"
    DENY = "deny"


class ResourceType:
    """ResourceType enum values."""

    CONTAINERSERVICE = "ContainerService"
    INSTANCE = "Instance"
    STATICIP = "StaticIp"
    KEYPAIR = "KeyPair"
    INSTANCESNAPSHOT = "InstanceSnapshot"
    DOMAIN = "Domain"
    PEEREDVPC = "PeeredVpc"
    LOADBALANCER = "LoadBalancer"
    LOADBALANCERTLSCERTIFICATE = "LoadBalancerTlsCertificate"
    DISK = "Disk"
    DISKSNAPSHOT = "DiskSnapshot"
    RELATIONALDATABASE = "RelationalDatabase"
    RELATIONALDATABASESNAPSHOT = "RelationalDatabaseSnapshot"
    EXPORTSNAPSHOTRECORD = "ExportSnapshotRecord"
    CLOUDFORMATIONSTACKRECORD = "CloudFormationStackRecord"
    ALARM = "Alarm"
    CONTACTMETHOD = "ContactMethod"
    DISTRIBUTION = "Distribution"
    CERTIFICATE = "Certificate"
    BUCKET = "Bucket"


class SetupStatus:
    """SetupStatus enum values."""

    SUCCEEDED = "succeeded"
    FAILED = "failed"
    INPROGRESS = "inProgress"


class Status:
    """Status enum values."""

    STARTEXPIRED = "startExpired"
    NOTSTARTED = "notStarted"
    STARTED = "started"
    STARTING = "starting"
    STOPPED = "stopped"
    STOPPING = "stopping"
    SETTINGUPINSTANCE = "settingUpInstance"
    FAILEDINSTANCECREATION = "failedInstanceCreation"
    FAILEDSTARTINGGUISESSION = "failedStartingGUISession"
    FAILEDSTOPPINGGUISESSION = "failedStoppingGUISession"


class StatusType:
    """StatusType enum values."""

    ACTIVE = "Active"
    INACTIVE = "Inactive"


class TreatMissingData:
    """TreatMissingData enum values."""

    BREACHING = "breaching"
    NOTBREACHING = "notBreaching"
    IGNORE = "ignore"
    MISSING = "missing"


class ViewerMinimumTlsProtocolVersionEnum:
    """ViewerMinimumTlsProtocolVersionEnum enum values."""

    TLSV1_1_2016 = "TLSv1.1_2016"
    TLSV1_2_2018 = "TLSv1.2_2018"
    TLSV1_2_2019 = "TLSv1.2_2019"
    TLSV1_2_2021 = "TLSv1.2_2021"


# Convenient aliases for enum values
INBOUND = AccessDirection.INBOUND
OUTBOUND = AccessDirection.OUTBOUND
PUBLIC = AccessType.PUBLIC
PRIVATE = AccessType.PRIVATE
INSYNC = AccountLevelBpaSyncStatus.INSYNC
FAILED = AccountLevelBpaSyncStatus.FAILED
NEVERSYNCED = AccountLevelBpaSyncStatus.NEVERSYNCED
DEFAULTED = AccountLevelBpaSyncStatus.DEFAULTED
AUTOSNAPSHOT = AddOnType.AUTOSNAPSHOT
STOPINSTANCEONIDLE = AddOnType.STOPINSTANCEONIDLE
OK = AlarmState.OK
ALARM = AlarmState.ALARM
INSUFFICIENT_DATA = AlarmState.INSUFFICIENT_DATA
LFR = AppCategory.LFR
FAILED = AutoMountStatus.FAILED
PENDING = AutoMountStatus.PENDING
MOUNTED = AutoMountStatus.MOUNTED
NOTMOUNTED = AutoMountStatus.NOTMOUNTED
SUCCESS = AutoSnapshotStatus.SUCCESS
FAILED = AutoSnapshotStatus.FAILED
INPROGRESS = AutoSnapshotStatus.INPROGRESS
NOTFOUND = AutoSnapshotStatus.NOTFOUND
DEFAULTED_FOR_SLR_MISSING = BPAStatusMessage.DEFAULTED_FOR_SLR_MISSING
SYNC_ON_HOLD = BPAStatusMessage.SYNC_ON_HOLD
DEFAULTED_FOR_SLR_MISSING_ON_HOLD = BPAStatusMessage.DEFAULTED_FOR_SLR_MISSING_ON_HOLD
UNKNOWN = BPAStatusMessage.UNKNOWN
DONT_CACHE = BehaviorEnum.DONT_CACHE
CACHE = BehaviorEnum.CACHE
OS = BlueprintType.OS
APP = BlueprintType.APP
BUCKETSIZEBYTES = BucketMetricName.BUCKETSIZEBYTES
NUMBEROFOBJECTS = BucketMetricName.NUMBEROFOBJECTS
PENDING_VALIDATION = CertificateDomainValidationStatus.PENDING_VALIDATION
FAILED = CertificateDomainValidationStatus.FAILED
SUCCESS = CertificateDomainValidationStatus.SUCCESS
LETSENCRYPT = CertificateProvider.LETSENCRYPT
PENDING_VALIDATION = CertificateStatus.PENDING_VALIDATION
ISSUED = CertificateStatus.ISSUED
INACTIVE = CertificateStatus.INACTIVE
EXPIRED = CertificateStatus.EXPIRED
VALIDATION_TIMED_OUT = CertificateStatus.VALIDATION_TIMED_OUT
REVOKED = CertificateStatus.REVOKED
FAILED = CertificateStatus.FAILED
EXPORTSNAPSHOTRECORD = CloudFormationStackRecordSourceType.EXPORTSNAPSHOTRECORD
GREATERTHANOREQUALTOTHRESHOLD = ComparisonOperator.GREATERTHANOREQUALTOTHRESHOLD
GREATERTHANTHRESHOLD = ComparisonOperator.GREATERTHANTHRESHOLD
LESSTHANTHRESHOLD = ComparisonOperator.LESSTHANTHRESHOLD
LESSTHANOREQUALTOTHRESHOLD = ComparisonOperator.LESSTHANOREQUALTOTHRESHOLD
PENDINGVERIFICATION = ContactMethodStatus.PENDINGVERIFICATION
VALID = ContactMethodStatus.VALID
INVALID = ContactMethodStatus.INVALID
EMAIL = ContactMethodVerificationProtocol.EMAIL
EMAIL = ContactProtocol.EMAIL
SMS = ContactProtocol.SMS
ACTIVATING = ContainerServiceDeploymentState.ACTIVATING
ACTIVE = ContainerServiceDeploymentState.ACTIVE
INACTIVE = ContainerServiceDeploymentState.INACTIVE
FAILED = ContainerServiceDeploymentState.FAILED
CPUUTILIZATION = ContainerServiceMetricName.CPUUTILIZATION
MEMORYUTILIZATION = ContainerServiceMetricName.MEMORYUTILIZATION
NANO = ContainerServicePowerName.NANO
MICRO = ContainerServicePowerName.MICRO
SMALL = ContainerServicePowerName.SMALL
MEDIUM = ContainerServicePowerName.MEDIUM
LARGE = ContainerServicePowerName.LARGE
XLARGE = ContainerServicePowerName.XLARGE
HTTP = ContainerServiceProtocol.HTTP
HTTPS = ContainerServiceProtocol.HTTPS
TCP = ContainerServiceProtocol.TCP
UDP = ContainerServiceProtocol.UDP
PENDING = ContainerServiceState.PENDING
READY = ContainerServiceState.READY
RUNNING = ContainerServiceState.RUNNING
UPDATING = ContainerServiceState.UPDATING
DELETING = ContainerServiceState.DELETING
DISABLED = ContainerServiceState.DISABLED
DEPLOYING = ContainerServiceState.DEPLOYING
CREATING_SYSTEM_RESOURCES = ContainerServiceStateDetailCode.CREATING_SYSTEM_RESOURCES
CREATING_NETWORK_INFRASTRUCTURE = ContainerServiceStateDetailCode.CREATING_NETWORK_INFRASTRUCTURE
PROVISIONING_CERTIFICATE = ContainerServiceStateDetailCode.PROVISIONING_CERTIFICATE
PROVISIONING_SERVICE = ContainerServiceStateDetailCode.PROVISIONING_SERVICE
CREATING_DEPLOYMENT = ContainerServiceStateDetailCode.CREATING_DEPLOYMENT
EVALUATING_HEALTH_CHECK = ContainerServiceStateDetailCode.EVALUATING_HEALTH_CHECK
ACTIVATING_DEPLOYMENT = ContainerServiceStateDetailCode.ACTIVATING_DEPLOYMENT
CERTIFICATE_LIMIT_EXCEEDED = ContainerServiceStateDetailCode.CERTIFICATE_LIMIT_EXCEEDED
UNKNOWN_ERROR = ContainerServiceStateDetailCode.UNKNOWN_ERROR
USD = Currency.USD
PENDING = DiskSnapshotState.PENDING
COMPLETED = DiskSnapshotState.COMPLETED
ERROR = DiskSnapshotState.ERROR
UNKNOWN = DiskSnapshotState.UNKNOWN
PENDING = DiskState.PENDING
ERROR = DiskState.ERROR
AVAILABLE = DiskState.AVAILABLE
IN_USE = DiskState.IN_USE
UNKNOWN = DiskState.UNKNOWN
REQUESTS = DistributionMetricName.REQUESTS
BYTESDOWNLOADED = DistributionMetricName.BYTESDOWNLOADED
BYTESUPLOADED = DistributionMetricName.BYTESUPLOADED
TOTALERRORRATE = DistributionMetricName.TOTALERRORRATE
HTTP4XXERRORRATE = DistributionMetricName.HTTP4XXERRORRATE
HTTP5XXERRORRATE = DistributionMetricName.HTTP5XXERRORRATE
SUCCEEDED = DnsRecordCreationStateCode.SUCCEEDED
STARTED = DnsRecordCreationStateCode.STARTED
FAILED = DnsRecordCreationStateCode.FAILED
INSTANCESNAPSHOT = ExportSnapshotRecordSourceType.INSTANCESNAPSHOT
DISKSNAPSHOT = ExportSnapshotRecordSourceType.DISKSNAPSHOT
NONE = ForwardValues.NONE
ALLOW_LIST = ForwardValues.ALLOW_LIST
ALL = ForwardValues.ALL
ACCEPT = HeaderEnum.ACCEPT
ACCEPT_CHARSET = HeaderEnum.ACCEPT_CHARSET
ACCEPT_DATETIME = HeaderEnum.ACCEPT_DATETIME
ACCEPT_ENCODING = HeaderEnum.ACCEPT_ENCODING
ACCEPT_LANGUAGE = HeaderEnum.ACCEPT_LANGUAGE
AUTHORIZATION = HeaderEnum.AUTHORIZATION
CLOUDFRONT_FORWARDED_PROTO = HeaderEnum.CLOUDFRONT_FORWARDED_PROTO
CLOUDFRONT_IS_DESKTOP_VIEWER = HeaderEnum.CLOUDFRONT_IS_DESKTOP_VIEWER
CLOUDFRONT_IS_MOBILE_VIEWER = HeaderEnum.CLOUDFRONT_IS_MOBILE_VIEWER
CLOUDFRONT_IS_SMARTTV_VIEWER = HeaderEnum.CLOUDFRONT_IS_SMARTTV_VIEWER
CLOUDFRONT_IS_TABLET_VIEWER = HeaderEnum.CLOUDFRONT_IS_TABLET_VIEWER
CLOUDFRONT_VIEWER_COUNTRY = HeaderEnum.CLOUDFRONT_VIEWER_COUNTRY
HOST = HeaderEnum.HOST
ORIGIN = HeaderEnum.ORIGIN
REFERER = HeaderEnum.REFERER
DISABLED = HttpEndpoint.DISABLED
ENABLED = HttpEndpoint.ENABLED
DISABLED = HttpProtocolIpv6.DISABLED
ENABLED = HttpProtocolIpv6.ENABLED
OPTIONAL = HttpTokens.OPTIONAL
REQUIRED = HttpTokens.REQUIRED
SSH = InstanceAccessProtocol.SSH
RDP = InstanceAccessProtocol.RDP
LB_REGISTRATIONINPROGRESS = InstanceHealthReason.LB_REGISTRATIONINPROGRESS
LB_INITIALHEALTHCHECKING = InstanceHealthReason.LB_INITIALHEALTHCHECKING
LB_INTERNALERROR = InstanceHealthReason.LB_INTERNALERROR
INSTANCE_RESPONSECODEMISMATCH = InstanceHealthReason.INSTANCE_RESPONSECODEMISMATCH
INSTANCE_TIMEOUT = InstanceHealthReason.INSTANCE_TIMEOUT
INSTANCE_FAILEDHEALTHCHECKS = InstanceHealthReason.INSTANCE_FAILEDHEALTHCHECKS
INSTANCE_NOTREGISTERED = InstanceHealthReason.INSTANCE_NOTREGISTERED
INSTANCE_NOTINUSE = InstanceHealthReason.INSTANCE_NOTINUSE
INSTANCE_DEREGISTRATIONINPROGRESS = InstanceHealthReason.INSTANCE_DEREGISTRATIONINPROGRESS
INSTANCE_INVALIDSTATE = InstanceHealthReason.INSTANCE_INVALIDSTATE
INSTANCE_IPUNUSABLE = InstanceHealthReason.INSTANCE_IPUNUSABLE
INITIAL = InstanceHealthState.INITIAL
HEALTHY = InstanceHealthState.HEALTHY
UNHEALTHY = InstanceHealthState.UNHEALTHY
UNUSED = InstanceHealthState.UNUSED
DRAINING = InstanceHealthState.DRAINING
UNAVAILABLE = InstanceHealthState.UNAVAILABLE
PENDING = InstanceMetadataState.PENDING
APPLIED = InstanceMetadataState.APPLIED
CPUUTILIZATION = InstanceMetricName.CPUUTILIZATION
NETWORKIN = InstanceMetricName.NETWORKIN
NETWORKOUT = InstanceMetricName.NETWORKOUT
STATUSCHECKFAILED = InstanceMetricName.STATUSCHECKFAILED
STATUSCHECKFAILED_INSTANCE = InstanceMetricName.STATUSCHECKFAILED_INSTANCE
STATUSCHECKFAILED_SYSTEM = InstanceMetricName.STATUSCHECKFAILED_SYSTEM
BURSTCAPACITYTIME = InstanceMetricName.BURSTCAPACITYTIME
BURSTCAPACITYPERCENTAGE = InstanceMetricName.BURSTCAPACITYPERCENTAGE
METADATANOTOKEN = InstanceMetricName.METADATANOTOKEN
LINUX_UNIX = InstancePlatform.LINUX_UNIX
WINDOWS = InstancePlatform.WINDOWS
PENDING = InstanceSnapshotState.PENDING
ERROR = InstanceSnapshotState.ERROR
AVAILABLE = InstanceSnapshotState.AVAILABLE
DUALSTACK = IpAddressType.DUALSTACK
IPV4 = IpAddressType.IPV4
IPV6 = IpAddressType.IPV6
HEALTHCHECKPATH = LoadBalancerAttributeName.HEALTHCHECKPATH
SESSIONSTICKINESSENABLED = LoadBalancerAttributeName.SESSIONSTICKINESSENABLED
SESSIONSTICKINESS_LB_COOKIEDURATIONSECONDS = LoadBalancerAttributeName.SESSIONSTICKINESS_LB_COOKIEDURATIONSECONDS
HTTPSREDIRECTIONENABLED = LoadBalancerAttributeName.HTTPSREDIRECTIONENABLED
TLSPOLICYNAME = LoadBalancerAttributeName.TLSPOLICYNAME
CLIENTTLSNEGOTIATIONERRORCOUNT = LoadBalancerMetricName.CLIENTTLSNEGOTIATIONERRORCOUNT
HEALTHYHOSTCOUNT = LoadBalancerMetricName.HEALTHYHOSTCOUNT
UNHEALTHYHOSTCOUNT = LoadBalancerMetricName.UNHEALTHYHOSTCOUNT
HTTPCODE_LB_4XX_COUNT = LoadBalancerMetricName.HTTPCODE_LB_4XX_COUNT
HTTPCODE_LB_5XX_COUNT = LoadBalancerMetricName.HTTPCODE_LB_5XX_COUNT
HTTPCODE_INSTANCE_2XX_COUNT = LoadBalancerMetricName.HTTPCODE_INSTANCE_2XX_COUNT
HTTPCODE_INSTANCE_3XX_COUNT = LoadBalancerMetricName.HTTPCODE_INSTANCE_3XX_COUNT
HTTPCODE_INSTANCE_4XX_COUNT = LoadBalancerMetricName.HTTPCODE_INSTANCE_4XX_COUNT
HTTPCODE_INSTANCE_5XX_COUNT = LoadBalancerMetricName.HTTPCODE_INSTANCE_5XX_COUNT
INSTANCERESPONSETIME = LoadBalancerMetricName.INSTANCERESPONSETIME
REJECTEDCONNECTIONCOUNT = LoadBalancerMetricName.REJECTEDCONNECTIONCOUNT
REQUESTCOUNT = LoadBalancerMetricName.REQUESTCOUNT
HTTP_HTTPS = LoadBalancerProtocol.HTTP_HTTPS
HTTP = LoadBalancerProtocol.HTTP
ACTIVE = LoadBalancerState.ACTIVE
PROVISIONING = LoadBalancerState.PROVISIONING
ACTIVE_IMPAIRED = LoadBalancerState.ACTIVE_IMPAIRED
FAILED = LoadBalancerState.FAILED
UNKNOWN = LoadBalancerState.UNKNOWN
SUCCEEDED = LoadBalancerTlsCertificateDnsRecordCreationStateCode.SUCCEEDED
STARTED = LoadBalancerTlsCertificateDnsRecordCreationStateCode.STARTED
FAILED = LoadBalancerTlsCertificateDnsRecordCreationStateCode.FAILED
PENDING_VALIDATION = LoadBalancerTlsCertificateDomainStatus.PENDING_VALIDATION
FAILED = LoadBalancerTlsCertificateDomainStatus.FAILED
SUCCESS = LoadBalancerTlsCertificateDomainStatus.SUCCESS
NO_AVAILABLE_CONTACTS = LoadBalancerTlsCertificateFailureReason.NO_AVAILABLE_CONTACTS
ADDITIONAL_VERIFICATION_REQUIRED = LoadBalancerTlsCertificateFailureReason.ADDITIONAL_VERIFICATION_REQUIRED
DOMAIN_NOT_ALLOWED = LoadBalancerTlsCertificateFailureReason.DOMAIN_NOT_ALLOWED
INVALID_PUBLIC_DOMAIN = LoadBalancerTlsCertificateFailureReason.INVALID_PUBLIC_DOMAIN
OTHER = LoadBalancerTlsCertificateFailureReason.OTHER
PENDING_AUTO_RENEWAL = LoadBalancerTlsCertificateRenewalStatus.PENDING_AUTO_RENEWAL
PENDING_VALIDATION = LoadBalancerTlsCertificateRenewalStatus.PENDING_VALIDATION
SUCCESS = LoadBalancerTlsCertificateRenewalStatus.SUCCESS
FAILED = LoadBalancerTlsCertificateRenewalStatus.FAILED
UNSPECIFIED = LoadBalancerTlsCertificateRevocationReason.UNSPECIFIED
KEY_COMPROMISE = LoadBalancerTlsCertificateRevocationReason.KEY_COMPROMISE
CA_COMPROMISE = LoadBalancerTlsCertificateRevocationReason.CA_COMPROMISE
AFFILIATION_CHANGED = LoadBalancerTlsCertificateRevocationReason.AFFILIATION_CHANGED
SUPERCEDED = LoadBalancerTlsCertificateRevocationReason.SUPERCEDED
CESSATION_OF_OPERATION = LoadBalancerTlsCertificateRevocationReason.CESSATION_OF_OPERATION
CERTIFICATE_HOLD = LoadBalancerTlsCertificateRevocationReason.CERTIFICATE_HOLD
REMOVE_FROM_CRL = LoadBalancerTlsCertificateRevocationReason.REMOVE_FROM_CRL
PRIVILEGE_WITHDRAWN = LoadBalancerTlsCertificateRevocationReason.PRIVILEGE_WITHDRAWN
A_A_COMPROMISE = LoadBalancerTlsCertificateRevocationReason.A_A_COMPROMISE
PENDING_VALIDATION = LoadBalancerTlsCertificateStatus.PENDING_VALIDATION
ISSUED = LoadBalancerTlsCertificateStatus.ISSUED
INACTIVE = LoadBalancerTlsCertificateStatus.INACTIVE
EXPIRED = LoadBalancerTlsCertificateStatus.EXPIRED
VALIDATION_TIMED_OUT = LoadBalancerTlsCertificateStatus.VALIDATION_TIMED_OUT
REVOKED = LoadBalancerTlsCertificateStatus.REVOKED
FAILED = LoadBalancerTlsCertificateStatus.FAILED
UNKNOWN = LoadBalancerTlsCertificateStatus.UNKNOWN
CPUUTILIZATION = MetricName.CPUUTILIZATION
NETWORKIN = MetricName.NETWORKIN
NETWORKOUT = MetricName.NETWORKOUT
STATUSCHECKFAILED = MetricName.STATUSCHECKFAILED
STATUSCHECKFAILED_INSTANCE = MetricName.STATUSCHECKFAILED_INSTANCE
STATUSCHECKFAILED_SYSTEM = MetricName.STATUSCHECKFAILED_SYSTEM
CLIENTTLSNEGOTIATIONERRORCOUNT = MetricName.CLIENTTLSNEGOTIATIONERRORCOUNT
HEALTHYHOSTCOUNT = MetricName.HEALTHYHOSTCOUNT
UNHEALTHYHOSTCOUNT = MetricName.UNHEALTHYHOSTCOUNT
HTTPCODE_LB_4XX_COUNT = MetricName.HTTPCODE_LB_4XX_COUNT
HTTPCODE_LB_5XX_COUNT = MetricName.HTTPCODE_LB_5XX_COUNT
HTTPCODE_INSTANCE_2XX_COUNT = MetricName.HTTPCODE_INSTANCE_2XX_COUNT
HTTPCODE_INSTANCE_3XX_COUNT = MetricName.HTTPCODE_INSTANCE_3XX_COUNT
HTTPCODE_INSTANCE_4XX_COUNT = MetricName.HTTPCODE_INSTANCE_4XX_COUNT
HTTPCODE_INSTANCE_5XX_COUNT = MetricName.HTTPCODE_INSTANCE_5XX_COUNT
INSTANCERESPONSETIME = MetricName.INSTANCERESPONSETIME
REJECTEDCONNECTIONCOUNT = MetricName.REJECTEDCONNECTIONCOUNT
REQUESTCOUNT = MetricName.REQUESTCOUNT
DATABASECONNECTIONS = MetricName.DATABASECONNECTIONS
DISKQUEUEDEPTH = MetricName.DISKQUEUEDEPTH
FREESTORAGESPACE = MetricName.FREESTORAGESPACE
NETWORKRECEIVETHROUGHPUT = MetricName.NETWORKRECEIVETHROUGHPUT
NETWORKTRANSMITTHROUGHPUT = MetricName.NETWORKTRANSMITTHROUGHPUT
BURSTCAPACITYTIME = MetricName.BURSTCAPACITYTIME
BURSTCAPACITYPERCENTAGE = MetricName.BURSTCAPACITYPERCENTAGE
MINIMUM = MetricStatistic.MINIMUM
MAXIMUM = MetricStatistic.MAXIMUM
SUM = MetricStatistic.SUM
AVERAGE = MetricStatistic.AVERAGE
SAMPLECOUNT = MetricStatistic.SAMPLECOUNT
SECONDS = MetricUnit.SECONDS
MICROSECONDS = MetricUnit.MICROSECONDS
MILLISECONDS = MetricUnit.MILLISECONDS
BYTES = MetricUnit.BYTES
KILOBYTES = MetricUnit.KILOBYTES
MEGABYTES = MetricUnit.MEGABYTES
GIGABYTES = MetricUnit.GIGABYTES
TERABYTES = MetricUnit.TERABYTES
BITS = MetricUnit.BITS
KILOBITS = MetricUnit.KILOBITS
MEGABITS = MetricUnit.MEGABITS
GIGABITS = MetricUnit.GIGABITS
TERABITS = MetricUnit.TERABITS
PERCENT = MetricUnit.PERCENT
COUNT = MetricUnit.COUNT
BYTES_SECOND = MetricUnit.BYTES_SECOND
KILOBYTES_SECOND = MetricUnit.KILOBYTES_SECOND
MEGABYTES_SECOND = MetricUnit.MEGABYTES_SECOND
GIGABYTES_SECOND = MetricUnit.GIGABYTES_SECOND
TERABYTES_SECOND = MetricUnit.TERABYTES_SECOND
BITS_SECOND = MetricUnit.BITS_SECOND
KILOBITS_SECOND = MetricUnit.KILOBITS_SECOND
MEGABITS_SECOND = MetricUnit.MEGABITS_SECOND
GIGABITS_SECOND = MetricUnit.GIGABITS_SECOND
TERABITS_SECOND = MetricUnit.TERABITS_SECOND
COUNT_SECOND = MetricUnit.COUNT_SECOND
NONE = MetricUnit.NONE
SUCCEEDED = NameServersUpdateStateCode.SUCCEEDED
PENDING = NameServersUpdateStateCode.PENDING
FAILED = NameServersUpdateStateCode.FAILED
STARTED = NameServersUpdateStateCode.STARTED
TCP = NetworkProtocol.TCP
ALL = NetworkProtocol.ALL
UDP = NetworkProtocol.UDP
ICMP = NetworkProtocol.ICMP
ICMPV6 = NetworkProtocol.ICMPV6
NOTSTARTED = OperationStatus.NOTSTARTED
STARTED = OperationStatus.STARTED
FAILED = OperationStatus.FAILED
COMPLETED = OperationStatus.COMPLETED
SUCCEEDED = OperationStatus.SUCCEEDED
DELETEKNOWNHOSTKEYS = OperationType.DELETEKNOWNHOSTKEYS
DELETEINSTANCE = OperationType.DELETEINSTANCE
CREATEINSTANCE = OperationType.CREATEINSTANCE
STOPINSTANCE = OperationType.STOPINSTANCE
STARTINSTANCE = OperationType.STARTINSTANCE
REBOOTINSTANCE = OperationType.REBOOTINSTANCE
OPENINSTANCEPUBLICPORTS = OperationType.OPENINSTANCEPUBLICPORTS
PUTINSTANCEPUBLICPORTS = OperationType.PUTINSTANCEPUBLICPORTS
CLOSEINSTANCEPUBLICPORTS = OperationType.CLOSEINSTANCEPUBLICPORTS
ALLOCATESTATICIP = OperationType.ALLOCATESTATICIP
RELEASESTATICIP = OperationType.RELEASESTATICIP
ATTACHSTATICIP = OperationType.ATTACHSTATICIP
DETACHSTATICIP = OperationType.DETACHSTATICIP
UPDATEDOMAINENTRY = OperationType.UPDATEDOMAINENTRY
DELETEDOMAINENTRY = OperationType.DELETEDOMAINENTRY
CREATEDOMAIN = OperationType.CREATEDOMAIN
DELETEDOMAIN = OperationType.DELETEDOMAIN
CREATEINSTANCESNAPSHOT = OperationType.CREATEINSTANCESNAPSHOT
DELETEINSTANCESNAPSHOT = OperationType.DELETEINSTANCESNAPSHOT
CREATEINSTANCESFROMSNAPSHOT = OperationType.CREATEINSTANCESFROMSNAPSHOT
CREATELOADBALANCER = OperationType.CREATELOADBALANCER
DELETELOADBALANCER = OperationType.DELETELOADBALANCER
ATTACHINSTANCESTOLOADBALANCER = OperationType.ATTACHINSTANCESTOLOADBALANCER
DETACHINSTANCESFROMLOADBALANCER = OperationType.DETACHINSTANCESFROMLOADBALANCER
UPDATELOADBALANCERATTRIBUTE = OperationType.UPDATELOADBALANCERATTRIBUTE
CREATELOADBALANCERTLSCERTIFICATE = OperationType.CREATELOADBALANCERTLSCERTIFICATE
DELETELOADBALANCERTLSCERTIFICATE = OperationType.DELETELOADBALANCERTLSCERTIFICATE
ATTACHLOADBALANCERTLSCERTIFICATE = OperationType.ATTACHLOADBALANCERTLSCERTIFICATE
CREATEDISK = OperationType.CREATEDISK
DELETEDISK = OperationType.DELETEDISK
ATTACHDISK = OperationType.ATTACHDISK
DETACHDISK = OperationType.DETACHDISK
CREATEDISKSNAPSHOT = OperationType.CREATEDISKSNAPSHOT
DELETEDISKSNAPSHOT = OperationType.DELETEDISKSNAPSHOT
CREATEDISKFROMSNAPSHOT = OperationType.CREATEDISKFROMSNAPSHOT
CREATERELATIONALDATABASE = OperationType.CREATERELATIONALDATABASE
UPDATERELATIONALDATABASE = OperationType.UPDATERELATIONALDATABASE
DELETERELATIONALDATABASE = OperationType.DELETERELATIONALDATABASE
CREATERELATIONALDATABASEFROMSNAPSHOT = OperationType.CREATERELATIONALDATABASEFROMSNAPSHOT
CREATERELATIONALDATABASESNAPSHOT = OperationType.CREATERELATIONALDATABASESNAPSHOT
DELETERELATIONALDATABASESNAPSHOT = OperationType.DELETERELATIONALDATABASESNAPSHOT
UPDATERELATIONALDATABASEPARAMETERS = OperationType.UPDATERELATIONALDATABASEPARAMETERS
STARTRELATIONALDATABASE = OperationType.STARTRELATIONALDATABASE
REBOOTRELATIONALDATABASE = OperationType.REBOOTRELATIONALDATABASE
STOPRELATIONALDATABASE = OperationType.STOPRELATIONALDATABASE
ENABLEADDON = OperationType.ENABLEADDON
DISABLEADDON = OperationType.DISABLEADDON
PUTALARM = OperationType.PUTALARM
GETALARMS = OperationType.GETALARMS
DELETEALARM = OperationType.DELETEALARM
TESTALARM = OperationType.TESTALARM
CREATECONTACTMETHOD = OperationType.CREATECONTACTMETHOD
GETCONTACTMETHODS = OperationType.GETCONTACTMETHODS
SENDCONTACTMETHODVERIFICATION = OperationType.SENDCONTACTMETHODVERIFICATION
DELETECONTACTMETHOD = OperationType.DELETECONTACTMETHOD
CREATEDISTRIBUTION = OperationType.CREATEDISTRIBUTION
UPDATEDISTRIBUTION = OperationType.UPDATEDISTRIBUTION
DELETEDISTRIBUTION = OperationType.DELETEDISTRIBUTION
RESETDISTRIBUTIONCACHE = OperationType.RESETDISTRIBUTIONCACHE
ATTACHCERTIFICATETODISTRIBUTION = OperationType.ATTACHCERTIFICATETODISTRIBUTION
DETACHCERTIFICATEFROMDISTRIBUTION = OperationType.DETACHCERTIFICATEFROMDISTRIBUTION
UPDATEDISTRIBUTIONBUNDLE = OperationType.UPDATEDISTRIBUTIONBUNDLE
SETIPADDRESSTYPE = OperationType.SETIPADDRESSTYPE
CREATECERTIFICATE = OperationType.CREATECERTIFICATE
DELETECERTIFICATE = OperationType.DELETECERTIFICATE
CREATECONTAINERSERVICE = OperationType.CREATECONTAINERSERVICE
UPDATECONTAINERSERVICE = OperationType.UPDATECONTAINERSERVICE
DELETECONTAINERSERVICE = OperationType.DELETECONTAINERSERVICE
CREATECONTAINERSERVICEDEPLOYMENT = OperationType.CREATECONTAINERSERVICEDEPLOYMENT
CREATECONTAINERSERVICEREGISTRYLOGIN = OperationType.CREATECONTAINERSERVICEREGISTRYLOGIN
REGISTERCONTAINERIMAGE = OperationType.REGISTERCONTAINERIMAGE
DELETECONTAINERIMAGE = OperationType.DELETECONTAINERIMAGE
CREATEBUCKET = OperationType.CREATEBUCKET
DELETEBUCKET = OperationType.DELETEBUCKET
CREATEBUCKETACCESSKEY = OperationType.CREATEBUCKETACCESSKEY
DELETEBUCKETACCESSKEY = OperationType.DELETEBUCKETACCESSKEY
UPDATEBUCKETBUNDLE = OperationType.UPDATEBUCKETBUNDLE
UPDATEBUCKET = OperationType.UPDATEBUCKET
SETRESOURCEACCESSFORBUCKET = OperationType.SETRESOURCEACCESSFORBUCKET
UPDATEINSTANCEMETADATAOPTIONS = OperationType.UPDATEINSTANCEMETADATAOPTIONS
STARTGUISESSION = OperationType.STARTGUISESSION
STOPGUISESSION = OperationType.STOPGUISESSION
SETUPINSTANCEHTTPS = OperationType.SETUPINSTANCEHTTPS
HTTP_ONLY = OriginProtocolPolicyEnum.HTTP_ONLY
HTTPS_ONLY = OriginProtocolPolicyEnum.HTTPS_ONLY
PUBLIC = PortAccessType.PUBLIC
PRIVATE = PortAccessType.PRIVATE
DEFAULT = PortInfoSourceType.DEFAULT
INSTANCE = PortInfoSourceType.INSTANCE
NONE = PortInfoSourceType.NONE
CLOSED = PortInfoSourceType.CLOSED
OPEN = PortState.OPEN
CLOSED = PortState.CLOSED
GB = PricingUnit.GB
HRS = PricingUnit.HRS
GB_MO = PricingUnit.GB_MO
BUNDLES = PricingUnit.BUNDLES
QUERIES = PricingUnit.QUERIES
SUCCEEDED = R53HostedZoneDeletionStateCode.SUCCEEDED
PENDING = R53HostedZoneDeletionStateCode.PENDING
FAILED = R53HostedZoneDeletionStateCode.FAILED
STARTED = R53HostedZoneDeletionStateCode.STARTED
STARTED = RecordState.STARTED
SUCCEEDED = RecordState.SUCCEEDED
FAILED = RecordState.FAILED
US_EAST_1 = RegionName.US_EAST_1
US_EAST_2 = RegionName.US_EAST_2
US_WEST_1 = RegionName.US_WEST_1
US_WEST_2 = RegionName.US_WEST_2
EU_WEST_1 = RegionName.EU_WEST_1
EU_WEST_2 = RegionName.EU_WEST_2
EU_WEST_3 = RegionName.EU_WEST_3
EU_CENTRAL_1 = RegionName.EU_CENTRAL_1
CA_CENTRAL_1 = RegionName.CA_CENTRAL_1
AP_SOUTH_1 = RegionName.AP_SOUTH_1
AP_SOUTHEAST_1 = RegionName.AP_SOUTHEAST_1
AP_SOUTHEAST_2 = RegionName.AP_SOUTHEAST_2
AP_NORTHEAST_1 = RegionName.AP_NORTHEAST_1
AP_NORTHEAST_2 = RegionName.AP_NORTHEAST_2
EU_NORTH_1 = RegionName.EU_NORTH_1
AP_SOUTHEAST_3 = RegionName.AP_SOUTHEAST_3
MYSQL = RelationalDatabaseEngine.MYSQL
CPUUTILIZATION = RelationalDatabaseMetricName.CPUUTILIZATION
DATABASECONNECTIONS = RelationalDatabaseMetricName.DATABASECONNECTIONS
DISKQUEUEDEPTH = RelationalDatabaseMetricName.DISKQUEUEDEPTH
FREESTORAGESPACE = RelationalDatabaseMetricName.FREESTORAGESPACE
NETWORKRECEIVETHROUGHPUT = RelationalDatabaseMetricName.NETWORKRECEIVETHROUGHPUT
NETWORKTRANSMITTHROUGHPUT = RelationalDatabaseMetricName.NETWORKTRANSMITTHROUGHPUT
CURRENT = RelationalDatabasePasswordVersion.CURRENT
PREVIOUS = RelationalDatabasePasswordVersion.PREVIOUS
PENDING = RelationalDatabasePasswordVersion.PENDING
PENDINGAUTORENEWAL = RenewalStatus.PENDINGAUTORENEWAL
PENDINGVALIDATION = RenewalStatus.PENDINGVALIDATION
SUCCESS = RenewalStatus.SUCCESS
FAILED = RenewalStatus.FAILED
ALLOW = ResourceBucketAccess.ALLOW
DENY = ResourceBucketAccess.DENY
CONTAINERSERVICE = ResourceType.CONTAINERSERVICE
INSTANCE = ResourceType.INSTANCE
STATICIP = ResourceType.STATICIP
KEYPAIR = ResourceType.KEYPAIR
INSTANCESNAPSHOT = ResourceType.INSTANCESNAPSHOT
DOMAIN = ResourceType.DOMAIN
PEEREDVPC = ResourceType.PEEREDVPC
LOADBALANCER = ResourceType.LOADBALANCER
LOADBALANCERTLSCERTIFICATE = ResourceType.LOADBALANCERTLSCERTIFICATE
DISK = ResourceType.DISK
DISKSNAPSHOT = ResourceType.DISKSNAPSHOT
RELATIONALDATABASE = ResourceType.RELATIONALDATABASE
RELATIONALDATABASESNAPSHOT = ResourceType.RELATIONALDATABASESNAPSHOT
EXPORTSNAPSHOTRECORD = ResourceType.EXPORTSNAPSHOTRECORD
CLOUDFORMATIONSTACKRECORD = ResourceType.CLOUDFORMATIONSTACKRECORD
ALARM = ResourceType.ALARM
CONTACTMETHOD = ResourceType.CONTACTMETHOD
DISTRIBUTION = ResourceType.DISTRIBUTION
CERTIFICATE = ResourceType.CERTIFICATE
BUCKET = ResourceType.BUCKET
SUCCEEDED = SetupStatus.SUCCEEDED
FAILED = SetupStatus.FAILED
INPROGRESS = SetupStatus.INPROGRESS
STARTEXPIRED = Status.STARTEXPIRED
NOTSTARTED = Status.NOTSTARTED
STARTED = Status.STARTED
STARTING = Status.STARTING
STOPPED = Status.STOPPED
STOPPING = Status.STOPPING
SETTINGUPINSTANCE = Status.SETTINGUPINSTANCE
FAILEDINSTANCECREATION = Status.FAILEDINSTANCECREATION
FAILEDSTARTINGGUISESSION = Status.FAILEDSTARTINGGUISESSION
FAILEDSTOPPINGGUISESSION = Status.FAILEDSTOPPINGGUISESSION
ACTIVE = StatusType.ACTIVE
INACTIVE = StatusType.INACTIVE
BREACHING = TreatMissingData.BREACHING
NOTBREACHING = TreatMissingData.NOTBREACHING
IGNORE = TreatMissingData.IGNORE
MISSING = TreatMissingData.MISSING
TLSV1_1_2016 = ViewerMinimumTlsProtocolVersionEnum.TLSV1_1_2016
TLSV1_2_2018 = ViewerMinimumTlsProtocolVersionEnum.TLSV1_2_2018
TLSV1_2_2019 = ViewerMinimumTlsProtocolVersionEnum.TLSV1_2_2019
TLSV1_2_2021 = ViewerMinimumTlsProtocolVersionEnum.TLSV1_2_2021


@dataclass
class Alarm(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-light"""

    resource_type: ClassVar[str] = "AWS::Lightsail::Alarm"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metric_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    comparison_operator: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    treat_missing_data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    alarm_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    contact_protocols: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    monitored_resource_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    evaluation_periods: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    notification_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    datapoints_to_alarm: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    notification_triggers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    threshold: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_name is not None:
            # Serialize metric_name (handle intrinsic functions)
            if hasattr(self.metric_name, 'to_dict'):
                props["MetricName"] = self.metric_name.to_dict()
            elif isinstance(self.metric_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['MetricName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_name
                ]
            else:
                props["MetricName"] = self.metric_name

        if self.comparison_operator is not None:
            # Serialize comparison_operator (handle intrinsic functions)
            if hasattr(self.comparison_operator, 'to_dict'):
                props["ComparisonOperator"] = self.comparison_operator.to_dict()
            elif isinstance(self.comparison_operator, list):
                # Serialize list items (may contain intrinsic functions)
                props['ComparisonOperator'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.comparison_operator
                ]
            else:
                props["ComparisonOperator"] = self.comparison_operator

        if self.treat_missing_data is not None:
            # Serialize treat_missing_data (handle intrinsic functions)
            if hasattr(self.treat_missing_data, 'to_dict'):
                props["TreatMissingData"] = self.treat_missing_data.to_dict()
            elif isinstance(self.treat_missing_data, list):
                # Serialize list items (may contain intrinsic functions)
                props['TreatMissingData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.treat_missing_data
                ]
            else:
                props["TreatMissingData"] = self.treat_missing_data

        if self.alarm_name is not None:
            # Serialize alarm_name (handle intrinsic functions)
            if hasattr(self.alarm_name, 'to_dict'):
                props["AlarmName"] = self.alarm_name.to_dict()
            elif isinstance(self.alarm_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['AlarmName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.alarm_name
                ]
            else:
                props["AlarmName"] = self.alarm_name

        if self.contact_protocols is not None:
            # Serialize contact_protocols (handle intrinsic functions)
            if hasattr(self.contact_protocols, 'to_dict'):
                props["ContactProtocols"] = self.contact_protocols.to_dict()
            elif isinstance(self.contact_protocols, list):
                # Serialize list items (may contain intrinsic functions)
                props['ContactProtocols'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.contact_protocols
                ]
            else:
                props["ContactProtocols"] = self.contact_protocols

        if self.monitored_resource_name is not None:
            # Serialize monitored_resource_name (handle intrinsic functions)
            if hasattr(self.monitored_resource_name, 'to_dict'):
                props["MonitoredResourceName"] = self.monitored_resource_name.to_dict()
            elif isinstance(self.monitored_resource_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['MonitoredResourceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitored_resource_name
                ]
            else:
                props["MonitoredResourceName"] = self.monitored_resource_name

        if self.evaluation_periods is not None:
            # Serialize evaluation_periods (handle intrinsic functions)
            if hasattr(self.evaluation_periods, 'to_dict'):
                props["EvaluationPeriods"] = self.evaluation_periods.to_dict()
            elif isinstance(self.evaluation_periods, list):
                # Serialize list items (may contain intrinsic functions)
                props['EvaluationPeriods'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.evaluation_periods
                ]
            else:
                props["EvaluationPeriods"] = self.evaluation_periods

        if self.notification_enabled is not None:
            # Serialize notification_enabled (handle intrinsic functions)
            if hasattr(self.notification_enabled, 'to_dict'):
                props["NotificationEnabled"] = self.notification_enabled.to_dict()
            elif isinstance(self.notification_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['NotificationEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_enabled
                ]
            else:
                props["NotificationEnabled"] = self.notification_enabled

        if self.datapoints_to_alarm is not None:
            # Serialize datapoints_to_alarm (handle intrinsic functions)
            if hasattr(self.datapoints_to_alarm, 'to_dict'):
                props["DatapointsToAlarm"] = self.datapoints_to_alarm.to_dict()
            elif isinstance(self.datapoints_to_alarm, list):
                # Serialize list items (may contain intrinsic functions)
                props['DatapointsToAlarm'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.datapoints_to_alarm
                ]
            else:
                props["DatapointsToAlarm"] = self.datapoints_to_alarm

        if self.notification_triggers is not None:
            # Serialize notification_triggers (handle intrinsic functions)
            if hasattr(self.notification_triggers, 'to_dict'):
                props["NotificationTriggers"] = self.notification_triggers.to_dict()
            elif isinstance(self.notification_triggers, list):
                # Serialize list items (may contain intrinsic functions)
                props['NotificationTriggers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_triggers
                ]
            else:
                props["NotificationTriggers"] = self.notification_triggers

        if self.threshold is not None:
            # Serialize threshold (handle intrinsic functions)
            if hasattr(self.threshold, 'to_dict'):
                props["Threshold"] = self.threshold.to_dict()
            elif isinstance(self.threshold, list):
                # Serialize list items (may contain intrinsic functions)
                props['Threshold'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.threshold
                ]
            else:
                props["Threshold"] = self.threshold

        return props

    @property
    def attr_alarm_arn(self) -> GetAtt:
        """Get the AlarmArn attribute."""
        return self.get_att("AlarmArn")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")




@dataclass
class AccessRules:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allow_public_overrides: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    get_object: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.allow_public_overrides is not None:
            if hasattr(self.allow_public_overrides, 'to_dict'):
                props['AllowPublicOverrides'] = self.allow_public_overrides.to_dict()
            elif isinstance(self.allow_public_overrides, list):
                props['AllowPublicOverrides'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allow_public_overrides
                ]
            else:
                props['AllowPublicOverrides'] = self.allow_public_overrides

        if self.get_object is not None:
            if hasattr(self.get_object, 'to_dict'):
                props['GetObject'] = self.get_object.to_dict()
            elif isinstance(self.get_object, list):
                props['GetObject'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.get_object
                ]
            else:
                props['GetObject'] = self.get_object

        return props


@dataclass
class Bucket(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-light"""

    resource_type: ClassVar[str] = "AWS::Lightsail::Bucket"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    object_versioning: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    read_only_access_accounts: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    bundle_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    bucket_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    access_rules: Optional[AccessRules] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resources_receiving_access: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.object_versioning is not None:
            # Serialize object_versioning (handle intrinsic functions)
            if hasattr(self.object_versioning, 'to_dict'):
                props["ObjectVersioning"] = self.object_versioning.to_dict()
            elif isinstance(self.object_versioning, list):
                # Serialize list items (may contain intrinsic functions)
                props['ObjectVersioning'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.object_versioning
                ]
            else:
                props["ObjectVersioning"] = self.object_versioning

        if self.read_only_access_accounts is not None:
            # Serialize read_only_access_accounts (handle intrinsic functions)
            if hasattr(self.read_only_access_accounts, 'to_dict'):
                props["ReadOnlyAccessAccounts"] = self.read_only_access_accounts.to_dict()
            elif isinstance(self.read_only_access_accounts, list):
                # Serialize list items (may contain intrinsic functions)
                props['ReadOnlyAccessAccounts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.read_only_access_accounts
                ]
            else:
                props["ReadOnlyAccessAccounts"] = self.read_only_access_accounts

        if self.bundle_id is not None:
            # Serialize bundle_id (handle intrinsic functions)
            if hasattr(self.bundle_id, 'to_dict'):
                props["BundleId"] = self.bundle_id.to_dict()
            elif isinstance(self.bundle_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['BundleId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bundle_id
                ]
            else:
                props["BundleId"] = self.bundle_id

        if self.bucket_name is not None:
            # Serialize bucket_name (handle intrinsic functions)
            if hasattr(self.bucket_name, 'to_dict'):
                props["BucketName"] = self.bucket_name.to_dict()
            elif isinstance(self.bucket_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['BucketName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket_name
                ]
            else:
                props["BucketName"] = self.bucket_name

        if self.access_rules is not None:
            # Serialize access_rules (handle intrinsic functions)
            if hasattr(self.access_rules, 'to_dict'):
                props["AccessRules"] = self.access_rules.to_dict()
            elif isinstance(self.access_rules, list):
                # Serialize list items (may contain intrinsic functions)
                props['AccessRules'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.access_rules
                ]
            else:
                props["AccessRules"] = self.access_rules

        if self.resources_receiving_access is not None:
            # Serialize resources_receiving_access (handle intrinsic functions)
            if hasattr(self.resources_receiving_access, 'to_dict'):
                props["ResourcesReceivingAccess"] = self.resources_receiving_access.to_dict()
            elif isinstance(self.resources_receiving_access, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourcesReceivingAccess'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resources_receiving_access
                ]
            else:
                props["ResourcesReceivingAccess"] = self.resources_receiving_access

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_bucket_arn(self) -> GetAtt:
        """Get the BucketArn attribute."""
        return self.get_att("BucketArn")

    @property
    def attr_able_to_update_bundle(self) -> GetAtt:
        """Get the AbleToUpdateBundle attribute."""
        return self.get_att("AbleToUpdateBundle")

    @property
    def attr_url(self) -> GetAtt:
        """Get the Url attribute."""
        return self.get_att("Url")




@dataclass
class Certificate(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-light"""

    resource_type: ClassVar[str] = "AWS::Lightsail::Certificate"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subject_alternative_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    certificate_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.domain_name is not None:
            # Serialize domain_name (handle intrinsic functions)
            if hasattr(self.domain_name, 'to_dict'):
                props["DomainName"] = self.domain_name.to_dict()
            elif isinstance(self.domain_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_name
                ]
            else:
                props["DomainName"] = self.domain_name

        if self.subject_alternative_names is not None:
            # Serialize subject_alternative_names (handle intrinsic functions)
            if hasattr(self.subject_alternative_names, 'to_dict'):
                props["SubjectAlternativeNames"] = self.subject_alternative_names.to_dict()
            elif isinstance(self.subject_alternative_names, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubjectAlternativeNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subject_alternative_names
                ]
            else:
                props["SubjectAlternativeNames"] = self.subject_alternative_names

        if self.certificate_name is not None:
            # Serialize certificate_name (handle intrinsic functions)
            if hasattr(self.certificate_name, 'to_dict'):
                props["CertificateName"] = self.certificate_name.to_dict()
            elif isinstance(self.certificate_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['CertificateName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_name
                ]
            else:
                props["CertificateName"] = self.certificate_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_certificate_arn(self) -> GetAtt:
        """Get the CertificateArn attribute."""
        return self.get_att("CertificateArn")




@dataclass
class Container:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    command: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    environment: Optional[list[EnvironmentVariable]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ports: Optional[list[PortInfo]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.container_name is not None:
            if hasattr(self.container_name, 'to_dict'):
                props['ContainerName'] = self.container_name.to_dict()
            elif isinstance(self.container_name, list):
                props['ContainerName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_name
                ]
            else:
                props['ContainerName'] = self.container_name

        if self.command is not None:
            if hasattr(self.command, 'to_dict'):
                props['Command'] = self.command.to_dict()
            elif isinstance(self.command, list):
                props['Command'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.command
                ]
            else:
                props['Command'] = self.command

        if self.environment is not None:
            if hasattr(self.environment, 'to_dict'):
                props['Environment'] = self.environment.to_dict()
            elif isinstance(self.environment, list):
                props['Environment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment
                ]
            else:
                props['Environment'] = self.environment

        if self.ports is not None:
            if hasattr(self.ports, 'to_dict'):
                props['Ports'] = self.ports.to_dict()
            elif isinstance(self.ports, list):
                props['Ports'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ports
                ]
            else:
                props['Ports'] = self.ports

        if self.image is not None:
            if hasattr(self.image, 'to_dict'):
                props['Image'] = self.image.to_dict()
            elif isinstance(self.image, list):
                props['Image'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image
                ]
            else:
                props['Image'] = self.image

        return props


@dataclass
class ContainerServiceDeployment:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    containers: Optional[list[Container]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    public_endpoint: Optional[PublicEndpoint] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.containers is not None:
            if hasattr(self.containers, 'to_dict'):
                props['Containers'] = self.containers.to_dict()
            elif isinstance(self.containers, list):
                props['Containers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.containers
                ]
            else:
                props['Containers'] = self.containers

        if self.public_endpoint is not None:
            if hasattr(self.public_endpoint, 'to_dict'):
                props['PublicEndpoint'] = self.public_endpoint.to_dict()
            elif isinstance(self.public_endpoint, list):
                props['PublicEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_endpoint
                ]
            else:
                props['PublicEndpoint'] = self.public_endpoint

        return props


@dataclass
class EcrImagePullerRole:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    principal_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    is_active: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.principal_arn is not None:
            if hasattr(self.principal_arn, 'to_dict'):
                props['PrincipalArn'] = self.principal_arn.to_dict()
            elif isinstance(self.principal_arn, list):
                props['PrincipalArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.principal_arn
                ]
            else:
                props['PrincipalArn'] = self.principal_arn

        if self.is_active is not None:
            if hasattr(self.is_active, 'to_dict'):
                props['IsActive'] = self.is_active.to_dict()
            elif isinstance(self.is_active, list):
                props['IsActive'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.is_active
                ]
            else:
                props['IsActive'] = self.is_active

        return props


@dataclass
class EnvironmentVariable:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    variable: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.variable is not None:
            if hasattr(self.variable, 'to_dict'):
                props['Variable'] = self.variable.to_dict()
            elif isinstance(self.variable, list):
                props['Variable'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.variable
                ]
            else:
                props['Variable'] = self.variable

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class HealthCheckConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    timeout_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    success_codes: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unhealthy_threshold: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    healthy_threshold: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    interval_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.path is not None:
            if hasattr(self.path, 'to_dict'):
                props['Path'] = self.path.to_dict()
            elif isinstance(self.path, list):
                props['Path'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.path
                ]
            else:
                props['Path'] = self.path

        if self.timeout_seconds is not None:
            if hasattr(self.timeout_seconds, 'to_dict'):
                props['TimeoutSeconds'] = self.timeout_seconds.to_dict()
            elif isinstance(self.timeout_seconds, list):
                props['TimeoutSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.timeout_seconds
                ]
            else:
                props['TimeoutSeconds'] = self.timeout_seconds

        if self.success_codes is not None:
            if hasattr(self.success_codes, 'to_dict'):
                props['SuccessCodes'] = self.success_codes.to_dict()
            elif isinstance(self.success_codes, list):
                props['SuccessCodes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.success_codes
                ]
            else:
                props['SuccessCodes'] = self.success_codes

        if self.unhealthy_threshold is not None:
            if hasattr(self.unhealthy_threshold, 'to_dict'):
                props['UnhealthyThreshold'] = self.unhealthy_threshold.to_dict()
            elif isinstance(self.unhealthy_threshold, list):
                props['UnhealthyThreshold'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unhealthy_threshold
                ]
            else:
                props['UnhealthyThreshold'] = self.unhealthy_threshold

        if self.healthy_threshold is not None:
            if hasattr(self.healthy_threshold, 'to_dict'):
                props['HealthyThreshold'] = self.healthy_threshold.to_dict()
            elif isinstance(self.healthy_threshold, list):
                props['HealthyThreshold'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.healthy_threshold
                ]
            else:
                props['HealthyThreshold'] = self.healthy_threshold

        if self.interval_seconds is not None:
            if hasattr(self.interval_seconds, 'to_dict'):
                props['IntervalSeconds'] = self.interval_seconds.to_dict()
            elif isinstance(self.interval_seconds, list):
                props['IntervalSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.interval_seconds
                ]
            else:
                props['IntervalSeconds'] = self.interval_seconds

        return props


@dataclass
class PortInfo:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.port is not None:
            if hasattr(self.port, 'to_dict'):
                props['Port'] = self.port.to_dict()
            elif isinstance(self.port, list):
                props['Port'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port
                ]
            else:
                props['Port'] = self.port

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        return props


@dataclass
class PrivateRegistryAccess:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ecr_image_puller_role: Optional[EcrImagePullerRole] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ecr_image_puller_role is not None:
            if hasattr(self.ecr_image_puller_role, 'to_dict'):
                props['EcrImagePullerRole'] = self.ecr_image_puller_role.to_dict()
            elif isinstance(self.ecr_image_puller_role, list):
                props['EcrImagePullerRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ecr_image_puller_role
                ]
            else:
                props['EcrImagePullerRole'] = self.ecr_image_puller_role

        return props


@dataclass
class PublicDomainName:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    certificate_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    domain_names: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.certificate_name is not None:
            if hasattr(self.certificate_name, 'to_dict'):
                props['CertificateName'] = self.certificate_name.to_dict()
            elif isinstance(self.certificate_name, list):
                props['CertificateName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_name
                ]
            else:
                props['CertificateName'] = self.certificate_name

        if self.domain_names is not None:
            if hasattr(self.domain_names, 'to_dict'):
                props['DomainNames'] = self.domain_names.to_dict()
            elif isinstance(self.domain_names, list):
                props['DomainNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_names
                ]
            else:
                props['DomainNames'] = self.domain_names

        return props


@dataclass
class PublicEndpoint:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    health_check_config: Optional[HealthCheckConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.container_name is not None:
            if hasattr(self.container_name, 'to_dict'):
                props['ContainerName'] = self.container_name.to_dict()
            elif isinstance(self.container_name, list):
                props['ContainerName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_name
                ]
            else:
                props['ContainerName'] = self.container_name

        if self.container_port is not None:
            if hasattr(self.container_port, 'to_dict'):
                props['ContainerPort'] = self.container_port.to_dict()
            elif isinstance(self.container_port, list):
                props['ContainerPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_port
                ]
            else:
                props['ContainerPort'] = self.container_port

        if self.health_check_config is not None:
            if hasattr(self.health_check_config, 'to_dict'):
                props['HealthCheckConfig'] = self.health_check_config.to_dict()
            elif isinstance(self.health_check_config, list):
                props['HealthCheckConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.health_check_config
                ]
            else:
                props['HealthCheckConfig'] = self.health_check_config

        return props


@dataclass
class Container(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-light"""

    resource_type: ClassVar[str] = "AWS::Lightsail::Container"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    public_domain_names: Optional[list[PublicDomainName]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_registry_access: Optional[PrivateRegistryAccess] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    container_service_deployment: Optional[ContainerServiceDeployment] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    is_disabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    scale: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    power: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.public_domain_names is not None:
            # Serialize public_domain_names (handle intrinsic functions)
            if hasattr(self.public_domain_names, 'to_dict'):
                props["PublicDomainNames"] = self.public_domain_names.to_dict()
            elif isinstance(self.public_domain_names, list):
                # Serialize list items (may contain intrinsic functions)
                props['PublicDomainNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_domain_names
                ]
            else:
                props["PublicDomainNames"] = self.public_domain_names

        if self.service_name is not None:
            # Serialize service_name (handle intrinsic functions)
            if hasattr(self.service_name, 'to_dict'):
                props["ServiceName"] = self.service_name.to_dict()
            elif isinstance(self.service_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_name
                ]
            else:
                props["ServiceName"] = self.service_name

        if self.private_registry_access is not None:
            # Serialize private_registry_access (handle intrinsic functions)
            if hasattr(self.private_registry_access, 'to_dict'):
                props["PrivateRegistryAccess"] = self.private_registry_access.to_dict()
            elif isinstance(self.private_registry_access, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateRegistryAccess'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_registry_access
                ]
            else:
                props["PrivateRegistryAccess"] = self.private_registry_access

        if self.container_service_deployment is not None:
            # Serialize container_service_deployment (handle intrinsic functions)
            if hasattr(self.container_service_deployment, 'to_dict'):
                props["ContainerServiceDeployment"] = self.container_service_deployment.to_dict()
            elif isinstance(self.container_service_deployment, list):
                # Serialize list items (may contain intrinsic functions)
                props['ContainerServiceDeployment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_service_deployment
                ]
            else:
                props["ContainerServiceDeployment"] = self.container_service_deployment

        if self.is_disabled is not None:
            # Serialize is_disabled (handle intrinsic functions)
            if hasattr(self.is_disabled, 'to_dict'):
                props["IsDisabled"] = self.is_disabled.to_dict()
            elif isinstance(self.is_disabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['IsDisabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.is_disabled
                ]
            else:
                props["IsDisabled"] = self.is_disabled

        if self.scale is not None:
            # Serialize scale (handle intrinsic functions)
            if hasattr(self.scale, 'to_dict'):
                props["Scale"] = self.scale.to_dict()
            elif isinstance(self.scale, list):
                # Serialize list items (may contain intrinsic functions)
                props['Scale'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scale
                ]
            else:
                props["Scale"] = self.scale

        if self.power is not None:
            # Serialize power (handle intrinsic functions)
            if hasattr(self.power, 'to_dict'):
                props["Power"] = self.power.to_dict()
            elif isinstance(self.power, list):
                # Serialize list items (may contain intrinsic functions)
                props['Power'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.power
                ]
            else:
                props["Power"] = self.power

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_principal_arn(self) -> GetAtt:
        """Get the PrincipalArn attribute."""
        return self.get_att("PrincipalArn")

    @property
    def attr_private_registry_access__ecr_image_puller_role__principal_arn(self) -> GetAtt:
        """Get the PrivateRegistryAccess.EcrImagePullerRole.PrincipalArn attribute."""
        return self.get_att("PrivateRegistryAccess.EcrImagePullerRole.PrincipalArn")

    @property
    def attr_container_arn(self) -> GetAtt:
        """Get the ContainerArn attribute."""
        return self.get_att("ContainerArn")

    @property
    def attr_url(self) -> GetAtt:
        """Get the Url attribute."""
        return self.get_att("Url")




@dataclass
class RelationalDatabaseParameter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    apply_method: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    is_modifiable: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    apply_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allowed_values: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parameter_value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parameter_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.apply_method is not None:
            if hasattr(self.apply_method, 'to_dict'):
                props['ApplyMethod'] = self.apply_method.to_dict()
            elif isinstance(self.apply_method, list):
                props['ApplyMethod'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.apply_method
                ]
            else:
                props['ApplyMethod'] = self.apply_method

        if self.is_modifiable is not None:
            if hasattr(self.is_modifiable, 'to_dict'):
                props['IsModifiable'] = self.is_modifiable.to_dict()
            elif isinstance(self.is_modifiable, list):
                props['IsModifiable'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.is_modifiable
                ]
            else:
                props['IsModifiable'] = self.is_modifiable

        if self.apply_type is not None:
            if hasattr(self.apply_type, 'to_dict'):
                props['ApplyType'] = self.apply_type.to_dict()
            elif isinstance(self.apply_type, list):
                props['ApplyType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.apply_type
                ]
            else:
                props['ApplyType'] = self.apply_type

        if self.allowed_values is not None:
            if hasattr(self.allowed_values, 'to_dict'):
                props['AllowedValues'] = self.allowed_values.to_dict()
            elif isinstance(self.allowed_values, list):
                props['AllowedValues'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_values
                ]
            else:
                props['AllowedValues'] = self.allowed_values

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.parameter_value is not None:
            if hasattr(self.parameter_value, 'to_dict'):
                props['ParameterValue'] = self.parameter_value.to_dict()
            elif isinstance(self.parameter_value, list):
                props['ParameterValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameter_value
                ]
            else:
                props['ParameterValue'] = self.parameter_value

        if self.data_type is not None:
            if hasattr(self.data_type, 'to_dict'):
                props['DataType'] = self.data_type.to_dict()
            elif isinstance(self.data_type, list):
                props['DataType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_type
                ]
            else:
                props['DataType'] = self.data_type

        if self.parameter_name is not None:
            if hasattr(self.parameter_name, 'to_dict'):
                props['ParameterName'] = self.parameter_name.to_dict()
            elif isinstance(self.parameter_name, list):
                props['ParameterName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameter_name
                ]
            else:
                props['ParameterName'] = self.parameter_name

        return props


@dataclass
class Database(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-light"""

    resource_type: ClassVar[str] = "AWS::Lightsail::Database"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    relational_database_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ca_certificate_identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    preferred_maintenance_window: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    relational_database_blueprint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    preferred_backup_window: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    master_database_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    master_user_password: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    relational_database_parameters: Optional[list[RelationalDatabaseParameter]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rotate_master_user_password: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    master_username: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    publicly_accessible: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    relational_database_bundle_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    backup_retention: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.relational_database_name is not None:
            # Serialize relational_database_name (handle intrinsic functions)
            if hasattr(self.relational_database_name, 'to_dict'):
                props["RelationalDatabaseName"] = self.relational_database_name.to_dict()
            elif isinstance(self.relational_database_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['RelationalDatabaseName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.relational_database_name
                ]
            else:
                props["RelationalDatabaseName"] = self.relational_database_name

        if self.ca_certificate_identifier is not None:
            # Serialize ca_certificate_identifier (handle intrinsic functions)
            if hasattr(self.ca_certificate_identifier, 'to_dict'):
                props["CaCertificateIdentifier"] = self.ca_certificate_identifier.to_dict()
            elif isinstance(self.ca_certificate_identifier, list):
                # Serialize list items (may contain intrinsic functions)
                props['CaCertificateIdentifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ca_certificate_identifier
                ]
            else:
                props["CaCertificateIdentifier"] = self.ca_certificate_identifier

        if self.availability_zone is not None:
            # Serialize availability_zone (handle intrinsic functions)
            if hasattr(self.availability_zone, 'to_dict'):
                props["AvailabilityZone"] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props["AvailabilityZone"] = self.availability_zone

        if self.preferred_maintenance_window is not None:
            # Serialize preferred_maintenance_window (handle intrinsic functions)
            if hasattr(self.preferred_maintenance_window, 'to_dict'):
                props["PreferredMaintenanceWindow"] = self.preferred_maintenance_window.to_dict()
            elif isinstance(self.preferred_maintenance_window, list):
                # Serialize list items (may contain intrinsic functions)
                props['PreferredMaintenanceWindow'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.preferred_maintenance_window
                ]
            else:
                props["PreferredMaintenanceWindow"] = self.preferred_maintenance_window

        if self.relational_database_blueprint_id is not None:
            # Serialize relational_database_blueprint_id (handle intrinsic functions)
            if hasattr(self.relational_database_blueprint_id, 'to_dict'):
                props["RelationalDatabaseBlueprintId"] = self.relational_database_blueprint_id.to_dict()
            elif isinstance(self.relational_database_blueprint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RelationalDatabaseBlueprintId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.relational_database_blueprint_id
                ]
            else:
                props["RelationalDatabaseBlueprintId"] = self.relational_database_blueprint_id

        if self.preferred_backup_window is not None:
            # Serialize preferred_backup_window (handle intrinsic functions)
            if hasattr(self.preferred_backup_window, 'to_dict'):
                props["PreferredBackupWindow"] = self.preferred_backup_window.to_dict()
            elif isinstance(self.preferred_backup_window, list):
                # Serialize list items (may contain intrinsic functions)
                props['PreferredBackupWindow'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.preferred_backup_window
                ]
            else:
                props["PreferredBackupWindow"] = self.preferred_backup_window

        if self.master_database_name is not None:
            # Serialize master_database_name (handle intrinsic functions)
            if hasattr(self.master_database_name, 'to_dict'):
                props["MasterDatabaseName"] = self.master_database_name.to_dict()
            elif isinstance(self.master_database_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['MasterDatabaseName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.master_database_name
                ]
            else:
                props["MasterDatabaseName"] = self.master_database_name

        if self.master_user_password is not None:
            # Serialize master_user_password (handle intrinsic functions)
            if hasattr(self.master_user_password, 'to_dict'):
                props["MasterUserPassword"] = self.master_user_password.to_dict()
            elif isinstance(self.master_user_password, list):
                # Serialize list items (may contain intrinsic functions)
                props['MasterUserPassword'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.master_user_password
                ]
            else:
                props["MasterUserPassword"] = self.master_user_password

        if self.relational_database_parameters is not None:
            # Serialize relational_database_parameters (handle intrinsic functions)
            if hasattr(self.relational_database_parameters, 'to_dict'):
                props["RelationalDatabaseParameters"] = self.relational_database_parameters.to_dict()
            elif isinstance(self.relational_database_parameters, list):
                # Serialize list items (may contain intrinsic functions)
                props['RelationalDatabaseParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.relational_database_parameters
                ]
            else:
                props["RelationalDatabaseParameters"] = self.relational_database_parameters

        if self.rotate_master_user_password is not None:
            # Serialize rotate_master_user_password (handle intrinsic functions)
            if hasattr(self.rotate_master_user_password, 'to_dict'):
                props["RotateMasterUserPassword"] = self.rotate_master_user_password.to_dict()
            elif isinstance(self.rotate_master_user_password, list):
                # Serialize list items (may contain intrinsic functions)
                props['RotateMasterUserPassword'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rotate_master_user_password
                ]
            else:
                props["RotateMasterUserPassword"] = self.rotate_master_user_password

        if self.master_username is not None:
            # Serialize master_username (handle intrinsic functions)
            if hasattr(self.master_username, 'to_dict'):
                props["MasterUsername"] = self.master_username.to_dict()
            elif isinstance(self.master_username, list):
                # Serialize list items (may contain intrinsic functions)
                props['MasterUsername'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.master_username
                ]
            else:
                props["MasterUsername"] = self.master_username

        if self.publicly_accessible is not None:
            # Serialize publicly_accessible (handle intrinsic functions)
            if hasattr(self.publicly_accessible, 'to_dict'):
                props["PubliclyAccessible"] = self.publicly_accessible.to_dict()
            elif isinstance(self.publicly_accessible, list):
                # Serialize list items (may contain intrinsic functions)
                props['PubliclyAccessible'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.publicly_accessible
                ]
            else:
                props["PubliclyAccessible"] = self.publicly_accessible

        if self.relational_database_bundle_id is not None:
            # Serialize relational_database_bundle_id (handle intrinsic functions)
            if hasattr(self.relational_database_bundle_id, 'to_dict'):
                props["RelationalDatabaseBundleId"] = self.relational_database_bundle_id.to_dict()
            elif isinstance(self.relational_database_bundle_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RelationalDatabaseBundleId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.relational_database_bundle_id
                ]
            else:
                props["RelationalDatabaseBundleId"] = self.relational_database_bundle_id

        if self.backup_retention is not None:
            # Serialize backup_retention (handle intrinsic functions)
            if hasattr(self.backup_retention, 'to_dict'):
                props["BackupRetention"] = self.backup_retention.to_dict()
            elif isinstance(self.backup_retention, list):
                # Serialize list items (may contain intrinsic functions)
                props['BackupRetention'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.backup_retention
                ]
            else:
                props["BackupRetention"] = self.backup_retention

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_database_arn(self) -> GetAtt:
        """Get the DatabaseArn attribute."""
        return self.get_att("DatabaseArn")




@dataclass
class AddOn:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    add_on_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auto_snapshot_add_on_request: Optional[AutoSnapshotAddOn] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.status is not None:
            if hasattr(self.status, 'to_dict'):
                props['Status'] = self.status.to_dict()
            elif isinstance(self.status, list):
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props['Status'] = self.status

        if self.add_on_type is not None:
            if hasattr(self.add_on_type, 'to_dict'):
                props['AddOnType'] = self.add_on_type.to_dict()
            elif isinstance(self.add_on_type, list):
                props['AddOnType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.add_on_type
                ]
            else:
                props['AddOnType'] = self.add_on_type

        if self.auto_snapshot_add_on_request is not None:
            if hasattr(self.auto_snapshot_add_on_request, 'to_dict'):
                props['AutoSnapshotAddOnRequest'] = self.auto_snapshot_add_on_request.to_dict()
            elif isinstance(self.auto_snapshot_add_on_request, list):
                props['AutoSnapshotAddOnRequest'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_snapshot_add_on_request
                ]
            else:
                props['AutoSnapshotAddOnRequest'] = self.auto_snapshot_add_on_request

        return props


@dataclass
class AutoSnapshotAddOn:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snapshot_time_of_day: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.snapshot_time_of_day is not None:
            if hasattr(self.snapshot_time_of_day, 'to_dict'):
                props['SnapshotTimeOfDay'] = self.snapshot_time_of_day.to_dict()
            elif isinstance(self.snapshot_time_of_day, list):
                props['SnapshotTimeOfDay'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snapshot_time_of_day
                ]
            else:
                props['SnapshotTimeOfDay'] = self.snapshot_time_of_day

        return props


@dataclass
class Location:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    region_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.region_name is not None:
            if hasattr(self.region_name, 'to_dict'):
                props['RegionName'] = self.region_name.to_dict()
            elif isinstance(self.region_name, list):
                props['RegionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.region_name
                ]
            else:
                props['RegionName'] = self.region_name

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        return props


@dataclass
class Disk(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-light"""

    resource_type: ClassVar[str] = "AWS::Lightsail::Disk"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    size_in_gb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    add_ons: Optional[list[AddOn]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    disk_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    location: Optional[Location] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.size_in_gb is not None:
            # Serialize size_in_gb (handle intrinsic functions)
            if hasattr(self.size_in_gb, 'to_dict'):
                props["SizeInGb"] = self.size_in_gb.to_dict()
            elif isinstance(self.size_in_gb, list):
                # Serialize list items (may contain intrinsic functions)
                props['SizeInGb'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.size_in_gb
                ]
            else:
                props["SizeInGb"] = self.size_in_gb

        if self.availability_zone is not None:
            # Serialize availability_zone (handle intrinsic functions)
            if hasattr(self.availability_zone, 'to_dict'):
                props["AvailabilityZone"] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props["AvailabilityZone"] = self.availability_zone

        if self.add_ons is not None:
            # Serialize add_ons (handle intrinsic functions)
            if hasattr(self.add_ons, 'to_dict'):
                props["AddOns"] = self.add_ons.to_dict()
            elif isinstance(self.add_ons, list):
                # Serialize list items (may contain intrinsic functions)
                props['AddOns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.add_ons
                ]
            else:
                props["AddOns"] = self.add_ons

        if self.disk_name is not None:
            # Serialize disk_name (handle intrinsic functions)
            if hasattr(self.disk_name, 'to_dict'):
                props["DiskName"] = self.disk_name.to_dict()
            elif isinstance(self.disk_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DiskName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disk_name
                ]
            else:
                props["DiskName"] = self.disk_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.location is not None:
            # Serialize location (handle intrinsic functions)
            if hasattr(self.location, 'to_dict'):
                props["Location"] = self.location.to_dict()
            elif isinstance(self.location, list):
                # Serialize list items (may contain intrinsic functions)
                props['Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location
                ]
            else:
                props["Location"] = self.location

        return props

    @property
    def attr_path(self) -> GetAtt:
        """Get the Path attribute."""
        return self.get_att("Path")

    @property
    def attr_attachment_state(self) -> GetAtt:
        """Get the AttachmentState attribute."""
        return self.get_att("AttachmentState")

    @property
    def attr_location__availability_zone(self) -> GetAtt:
        """Get the Location.AvailabilityZone attribute."""
        return self.get_att("Location.AvailabilityZone")

    @property
    def attr_support_code(self) -> GetAtt:
        """Get the SupportCode attribute."""
        return self.get_att("SupportCode")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_is_attached(self) -> GetAtt:
        """Get the IsAttached attribute."""
        return self.get_att("IsAttached")

    @property
    def attr_resource_type(self) -> GetAtt:
        """Get the ResourceType attribute."""
        return self.get_att("ResourceType")

    @property
    def attr_disk_arn(self) -> GetAtt:
        """Get the DiskArn attribute."""
        return self.get_att("DiskArn")

    @property
    def attr_attached_to(self) -> GetAtt:
        """Get the AttachedTo attribute."""
        return self.get_att("AttachedTo")

    @property
    def attr_iops(self) -> GetAtt:
        """Get the Iops attribute."""
        return self.get_att("Iops")

    @property
    def attr_location__region_name(self) -> GetAtt:
        """Get the Location.RegionName attribute."""
        return self.get_att("Location.RegionName")




@dataclass
class Location:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    region_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.region_name is not None:
            if hasattr(self.region_name, 'to_dict'):
                props['RegionName'] = self.region_name.to_dict()
            elif isinstance(self.region_name, list):
                props['RegionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.region_name
                ]
            else:
                props['RegionName'] = self.region_name

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        return props


@dataclass
class DiskSnapshot(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-light"""

    resource_type: ClassVar[str] = "AWS::Lightsail::DiskSnapshot"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    disk_snapshot_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    disk_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.disk_snapshot_name is not None:
            # Serialize disk_snapshot_name (handle intrinsic functions)
            if hasattr(self.disk_snapshot_name, 'to_dict'):
                props["DiskSnapshotName"] = self.disk_snapshot_name.to_dict()
            elif isinstance(self.disk_snapshot_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DiskSnapshotName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disk_snapshot_name
                ]
            else:
                props["DiskSnapshotName"] = self.disk_snapshot_name

        if self.disk_name is not None:
            # Serialize disk_name (handle intrinsic functions)
            if hasattr(self.disk_name, 'to_dict'):
                props["DiskName"] = self.disk_name.to_dict()
            elif isinstance(self.disk_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DiskName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disk_name
                ]
            else:
                props["DiskName"] = self.disk_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_size_in_gb(self) -> GetAtt:
        """Get the SizeInGb attribute."""
        return self.get_att("SizeInGb")

    @property
    def attr_progress(self) -> GetAtt:
        """Get the Progress attribute."""
        return self.get_att("Progress")

    @property
    def attr_location__availability_zone(self) -> GetAtt:
        """Get the Location.AvailabilityZone attribute."""
        return self.get_att("Location.AvailabilityZone")

    @property
    def attr_disk_snapshot_arn(self) -> GetAtt:
        """Get the DiskSnapshotArn attribute."""
        return self.get_att("DiskSnapshotArn")

    @property
    def attr_support_code(self) -> GetAtt:
        """Get the SupportCode attribute."""
        return self.get_att("SupportCode")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_created_at(self) -> GetAtt:
        """Get the CreatedAt attribute."""
        return self.get_att("CreatedAt")

    @property
    def attr_from_disk_name(self) -> GetAtt:
        """Get the FromDiskName attribute."""
        return self.get_att("FromDiskName")

    @property
    def attr_resource_type(self) -> GetAtt:
        """Get the ResourceType attribute."""
        return self.get_att("ResourceType")

    @property
    def attr_is_from_auto_snapshot(self) -> GetAtt:
        """Get the IsFromAutoSnapshot attribute."""
        return self.get_att("IsFromAutoSnapshot")

    @property
    def attr_location(self) -> GetAtt:
        """Get the Location attribute."""
        return self.get_att("Location")

    @property
    def attr_location__region_name(self) -> GetAtt:
        """Get the Location.RegionName attribute."""
        return self.get_att("Location.RegionName")




@dataclass
class CacheBehavior:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    behavior: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.behavior is not None:
            if hasattr(self.behavior, 'to_dict'):
                props['Behavior'] = self.behavior.to_dict()
            elif isinstance(self.behavior, list):
                props['Behavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.behavior
                ]
            else:
                props['Behavior'] = self.behavior

        return props


@dataclass
class CacheBehaviorPerPath:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    behavior: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.path is not None:
            if hasattr(self.path, 'to_dict'):
                props['Path'] = self.path.to_dict()
            elif isinstance(self.path, list):
                props['Path'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.path
                ]
            else:
                props['Path'] = self.path

        if self.behavior is not None:
            if hasattr(self.behavior, 'to_dict'):
                props['Behavior'] = self.behavior.to_dict()
            elif isinstance(self.behavior, list):
                props['Behavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.behavior
                ]
            else:
                props['Behavior'] = self.behavior

        return props


@dataclass
class CacheSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    forwarded_cookies: Optional[CookieObject] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    minimum_ttl: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cached_http_methods: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allowed_http_methods: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_ttl: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    forwarded_headers: Optional[HeaderObject] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_ttl: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    forwarded_query_strings: Optional[QueryStringObject] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.forwarded_cookies is not None:
            if hasattr(self.forwarded_cookies, 'to_dict'):
                props['ForwardedCookies'] = self.forwarded_cookies.to_dict()
            elif isinstance(self.forwarded_cookies, list):
                props['ForwardedCookies'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.forwarded_cookies
                ]
            else:
                props['ForwardedCookies'] = self.forwarded_cookies

        if self.minimum_ttl is not None:
            if hasattr(self.minimum_ttl, 'to_dict'):
                props['MinimumTTL'] = self.minimum_ttl.to_dict()
            elif isinstance(self.minimum_ttl, list):
                props['MinimumTTL'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.minimum_ttl
                ]
            else:
                props['MinimumTTL'] = self.minimum_ttl

        if self.cached_http_methods is not None:
            if hasattr(self.cached_http_methods, 'to_dict'):
                props['CachedHTTPMethods'] = self.cached_http_methods.to_dict()
            elif isinstance(self.cached_http_methods, list):
                props['CachedHTTPMethods'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cached_http_methods
                ]
            else:
                props['CachedHTTPMethods'] = self.cached_http_methods

        if self.allowed_http_methods is not None:
            if hasattr(self.allowed_http_methods, 'to_dict'):
                props['AllowedHTTPMethods'] = self.allowed_http_methods.to_dict()
            elif isinstance(self.allowed_http_methods, list):
                props['AllowedHTTPMethods'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_http_methods
                ]
            else:
                props['AllowedHTTPMethods'] = self.allowed_http_methods

        if self.maximum_ttl is not None:
            if hasattr(self.maximum_ttl, 'to_dict'):
                props['MaximumTTL'] = self.maximum_ttl.to_dict()
            elif isinstance(self.maximum_ttl, list):
                props['MaximumTTL'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_ttl
                ]
            else:
                props['MaximumTTL'] = self.maximum_ttl

        if self.forwarded_headers is not None:
            if hasattr(self.forwarded_headers, 'to_dict'):
                props['ForwardedHeaders'] = self.forwarded_headers.to_dict()
            elif isinstance(self.forwarded_headers, list):
                props['ForwardedHeaders'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.forwarded_headers
                ]
            else:
                props['ForwardedHeaders'] = self.forwarded_headers

        if self.default_ttl is not None:
            if hasattr(self.default_ttl, 'to_dict'):
                props['DefaultTTL'] = self.default_ttl.to_dict()
            elif isinstance(self.default_ttl, list):
                props['DefaultTTL'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_ttl
                ]
            else:
                props['DefaultTTL'] = self.default_ttl

        if self.forwarded_query_strings is not None:
            if hasattr(self.forwarded_query_strings, 'to_dict'):
                props['ForwardedQueryStrings'] = self.forwarded_query_strings.to_dict()
            elif isinstance(self.forwarded_query_strings, list):
                props['ForwardedQueryStrings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.forwarded_query_strings
                ]
            else:
                props['ForwardedQueryStrings'] = self.forwarded_query_strings

        return props


@dataclass
class CookieObject:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cookies_allow_list: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    option: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cookies_allow_list is not None:
            if hasattr(self.cookies_allow_list, 'to_dict'):
                props['CookiesAllowList'] = self.cookies_allow_list.to_dict()
            elif isinstance(self.cookies_allow_list, list):
                props['CookiesAllowList'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cookies_allow_list
                ]
            else:
                props['CookiesAllowList'] = self.cookies_allow_list

        if self.option is not None:
            if hasattr(self.option, 'to_dict'):
                props['Option'] = self.option.to_dict()
            elif isinstance(self.option, list):
                props['Option'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.option
                ]
            else:
                props['Option'] = self.option

        return props


@dataclass
class HeaderObject:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    headers_allow_list: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    option: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.headers_allow_list is not None:
            if hasattr(self.headers_allow_list, 'to_dict'):
                props['HeadersAllowList'] = self.headers_allow_list.to_dict()
            elif isinstance(self.headers_allow_list, list):
                props['HeadersAllowList'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.headers_allow_list
                ]
            else:
                props['HeadersAllowList'] = self.headers_allow_list

        if self.option is not None:
            if hasattr(self.option, 'to_dict'):
                props['Option'] = self.option.to_dict()
            elif isinstance(self.option, list):
                props['Option'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.option
                ]
            else:
                props['Option'] = self.option

        return props


@dataclass
class InputOrigin:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    region_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol_policy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.region_name is not None:
            if hasattr(self.region_name, 'to_dict'):
                props['RegionName'] = self.region_name.to_dict()
            elif isinstance(self.region_name, list):
                props['RegionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.region_name
                ]
            else:
                props['RegionName'] = self.region_name

        if self.protocol_policy is not None:
            if hasattr(self.protocol_policy, 'to_dict'):
                props['ProtocolPolicy'] = self.protocol_policy.to_dict()
            elif isinstance(self.protocol_policy, list):
                props['ProtocolPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol_policy
                ]
            else:
                props['ProtocolPolicy'] = self.protocol_policy

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class QueryStringObject:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    option: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    query_strings_allow_list: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.option is not None:
            if hasattr(self.option, 'to_dict'):
                props['Option'] = self.option.to_dict()
            elif isinstance(self.option, list):
                props['Option'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.option
                ]
            else:
                props['Option'] = self.option

        if self.query_strings_allow_list is not None:
            if hasattr(self.query_strings_allow_list, 'to_dict'):
                props['QueryStringsAllowList'] = self.query_strings_allow_list.to_dict()
            elif isinstance(self.query_strings_allow_list, list):
                props['QueryStringsAllowList'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.query_strings_allow_list
                ]
            else:
                props['QueryStringsAllowList'] = self.query_strings_allow_list

        return props


@dataclass
class Distribution(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-light"""

    resource_type: ClassVar[str] = "AWS::Lightsail::Distribution"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ip_address_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    origin: Optional[InputOrigin] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    distribution_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    bundle_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_cache_behavior: Optional[CacheBehavior] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    is_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cache_behavior_settings: Optional[CacheSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    certificate_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cache_behaviors: Optional[list[CacheBehaviorPerPath]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ip_address_type is not None:
            # Serialize ip_address_type (handle intrinsic functions)
            if hasattr(self.ip_address_type, 'to_dict'):
                props["IpAddressType"] = self.ip_address_type.to_dict()
            elif isinstance(self.ip_address_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpAddressType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_address_type
                ]
            else:
                props["IpAddressType"] = self.ip_address_type

        if self.origin is not None:
            # Serialize origin (handle intrinsic functions)
            if hasattr(self.origin, 'to_dict'):
                props["Origin"] = self.origin.to_dict()
            elif isinstance(self.origin, list):
                # Serialize list items (may contain intrinsic functions)
                props['Origin'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.origin
                ]
            else:
                props["Origin"] = self.origin

        if self.distribution_name is not None:
            # Serialize distribution_name (handle intrinsic functions)
            if hasattr(self.distribution_name, 'to_dict'):
                props["DistributionName"] = self.distribution_name.to_dict()
            elif isinstance(self.distribution_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DistributionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.distribution_name
                ]
            else:
                props["DistributionName"] = self.distribution_name

        if self.bundle_id is not None:
            # Serialize bundle_id (handle intrinsic functions)
            if hasattr(self.bundle_id, 'to_dict'):
                props["BundleId"] = self.bundle_id.to_dict()
            elif isinstance(self.bundle_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['BundleId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bundle_id
                ]
            else:
                props["BundleId"] = self.bundle_id

        if self.default_cache_behavior is not None:
            # Serialize default_cache_behavior (handle intrinsic functions)
            if hasattr(self.default_cache_behavior, 'to_dict'):
                props["DefaultCacheBehavior"] = self.default_cache_behavior.to_dict()
            elif isinstance(self.default_cache_behavior, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultCacheBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_cache_behavior
                ]
            else:
                props["DefaultCacheBehavior"] = self.default_cache_behavior

        if self.is_enabled is not None:
            # Serialize is_enabled (handle intrinsic functions)
            if hasattr(self.is_enabled, 'to_dict'):
                props["IsEnabled"] = self.is_enabled.to_dict()
            elif isinstance(self.is_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['IsEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.is_enabled
                ]
            else:
                props["IsEnabled"] = self.is_enabled

        if self.cache_behavior_settings is not None:
            # Serialize cache_behavior_settings (handle intrinsic functions)
            if hasattr(self.cache_behavior_settings, 'to_dict'):
                props["CacheBehaviorSettings"] = self.cache_behavior_settings.to_dict()
            elif isinstance(self.cache_behavior_settings, list):
                # Serialize list items (may contain intrinsic functions)
                props['CacheBehaviorSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cache_behavior_settings
                ]
            else:
                props["CacheBehaviorSettings"] = self.cache_behavior_settings

        if self.certificate_name is not None:
            # Serialize certificate_name (handle intrinsic functions)
            if hasattr(self.certificate_name, 'to_dict'):
                props["CertificateName"] = self.certificate_name.to_dict()
            elif isinstance(self.certificate_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['CertificateName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_name
                ]
            else:
                props["CertificateName"] = self.certificate_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.cache_behaviors is not None:
            # Serialize cache_behaviors (handle intrinsic functions)
            if hasattr(self.cache_behaviors, 'to_dict'):
                props["CacheBehaviors"] = self.cache_behaviors.to_dict()
            elif isinstance(self.cache_behaviors, list):
                # Serialize list items (may contain intrinsic functions)
                props['CacheBehaviors'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cache_behaviors
                ]
            else:
                props["CacheBehaviors"] = self.cache_behaviors

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_distribution_arn(self) -> GetAtt:
        """Get the DistributionArn attribute."""
        return self.get_att("DistributionArn")

    @property
    def attr_able_to_update_bundle(self) -> GetAtt:
        """Get the AbleToUpdateBundle attribute."""
        return self.get_att("AbleToUpdateBundle")




@dataclass
class DomainEntry:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    is_alias: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.target is not None:
            if hasattr(self.target, 'to_dict'):
                props['Target'] = self.target.to_dict()
            elif isinstance(self.target, list):
                props['Target'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target
                ]
            else:
                props['Target'] = self.target

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.id is not None:
            if hasattr(self.id, 'to_dict'):
                props['Id'] = self.id.to_dict()
            elif isinstance(self.id, list):
                props['Id'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.id
                ]
            else:
                props['Id'] = self.id

        if self.is_alias is not None:
            if hasattr(self.is_alias, 'to_dict'):
                props['IsAlias'] = self.is_alias.to_dict()
            elif isinstance(self.is_alias, list):
                props['IsAlias'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.is_alias
                ]
            else:
                props['IsAlias'] = self.is_alias

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class Location:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    region_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.region_name is not None:
            if hasattr(self.region_name, 'to_dict'):
                props['RegionName'] = self.region_name.to_dict()
            elif isinstance(self.region_name, list):
                props['RegionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.region_name
                ]
            else:
                props['RegionName'] = self.region_name

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        return props


@dataclass
class Domain(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-light"""

    resource_type: ClassVar[str] = "AWS::Lightsail::Domain"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_entries: Optional[list[DomainEntry]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.domain_name is not None:
            # Serialize domain_name (handle intrinsic functions)
            if hasattr(self.domain_name, 'to_dict'):
                props["DomainName"] = self.domain_name.to_dict()
            elif isinstance(self.domain_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_name
                ]
            else:
                props["DomainName"] = self.domain_name

        if self.domain_entries is not None:
            # Serialize domain_entries (handle intrinsic functions)
            if hasattr(self.domain_entries, 'to_dict'):
                props["DomainEntries"] = self.domain_entries.to_dict()
            elif isinstance(self.domain_entries, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainEntries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_entries
                ]
            else:
                props["DomainEntries"] = self.domain_entries

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_location__availability_zone(self) -> GetAtt:
        """Get the Location.AvailabilityZone attribute."""
        return self.get_att("Location.AvailabilityZone")

    @property
    def attr_support_code(self) -> GetAtt:
        """Get the SupportCode attribute."""
        return self.get_att("SupportCode")

    @property
    def attr_created_at(self) -> GetAtt:
        """Get the CreatedAt attribute."""
        return self.get_att("CreatedAt")

    @property
    def attr_resource_type(self) -> GetAtt:
        """Get the ResourceType attribute."""
        return self.get_att("ResourceType")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_location(self) -> GetAtt:
        """Get the Location attribute."""
        return self.get_att("Location")

    @property
    def attr_location__region_name(self) -> GetAtt:
        """Get the Location.RegionName attribute."""
        return self.get_att("Location.RegionName")




@dataclass
class AddOn:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    add_on_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auto_snapshot_add_on_request: Optional[AutoSnapshotAddOn] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.status is not None:
            if hasattr(self.status, 'to_dict'):
                props['Status'] = self.status.to_dict()
            elif isinstance(self.status, list):
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props['Status'] = self.status

        if self.add_on_type is not None:
            if hasattr(self.add_on_type, 'to_dict'):
                props['AddOnType'] = self.add_on_type.to_dict()
            elif isinstance(self.add_on_type, list):
                props['AddOnType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.add_on_type
                ]
            else:
                props['AddOnType'] = self.add_on_type

        if self.auto_snapshot_add_on_request is not None:
            if hasattr(self.auto_snapshot_add_on_request, 'to_dict'):
                props['AutoSnapshotAddOnRequest'] = self.auto_snapshot_add_on_request.to_dict()
            elif isinstance(self.auto_snapshot_add_on_request, list):
                props['AutoSnapshotAddOnRequest'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_snapshot_add_on_request
                ]
            else:
                props['AutoSnapshotAddOnRequest'] = self.auto_snapshot_add_on_request

        return props


@dataclass
class AutoSnapshotAddOn:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snapshot_time_of_day: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.snapshot_time_of_day is not None:
            if hasattr(self.snapshot_time_of_day, 'to_dict'):
                props['SnapshotTimeOfDay'] = self.snapshot_time_of_day.to_dict()
            elif isinstance(self.snapshot_time_of_day, list):
                props['SnapshotTimeOfDay'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snapshot_time_of_day
                ]
            else:
                props['SnapshotTimeOfDay'] = self.snapshot_time_of_day

        return props


@dataclass
class Disk:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    size_in_gb: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attachment_state: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    is_system_disk: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attached_to: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    disk_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.size_in_gb is not None:
            if hasattr(self.size_in_gb, 'to_dict'):
                props['SizeInGb'] = self.size_in_gb.to_dict()
            elif isinstance(self.size_in_gb, list):
                props['SizeInGb'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.size_in_gb
                ]
            else:
                props['SizeInGb'] = self.size_in_gb

        if self.path is not None:
            if hasattr(self.path, 'to_dict'):
                props['Path'] = self.path.to_dict()
            elif isinstance(self.path, list):
                props['Path'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.path
                ]
            else:
                props['Path'] = self.path

        if self.attachment_state is not None:
            if hasattr(self.attachment_state, 'to_dict'):
                props['AttachmentState'] = self.attachment_state.to_dict()
            elif isinstance(self.attachment_state, list):
                props['AttachmentState'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attachment_state
                ]
            else:
                props['AttachmentState'] = self.attachment_state

        if self.is_system_disk is not None:
            if hasattr(self.is_system_disk, 'to_dict'):
                props['IsSystemDisk'] = self.is_system_disk.to_dict()
            elif isinstance(self.is_system_disk, list):
                props['IsSystemDisk'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.is_system_disk
                ]
            else:
                props['IsSystemDisk'] = self.is_system_disk

        if self.attached_to is not None:
            if hasattr(self.attached_to, 'to_dict'):
                props['AttachedTo'] = self.attached_to.to_dict()
            elif isinstance(self.attached_to, list):
                props['AttachedTo'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attached_to
                ]
            else:
                props['AttachedTo'] = self.attached_to

        if self.iops is not None:
            if hasattr(self.iops, 'to_dict'):
                props['IOPS'] = self.iops.to_dict()
            elif isinstance(self.iops, list):
                props['IOPS'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iops
                ]
            else:
                props['IOPS'] = self.iops

        if self.disk_name is not None:
            if hasattr(self.disk_name, 'to_dict'):
                props['DiskName'] = self.disk_name.to_dict()
            elif isinstance(self.disk_name, list):
                props['DiskName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disk_name
                ]
            else:
                props['DiskName'] = self.disk_name

        return props


@dataclass
class Hardware:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ram_size_in_gb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    disks: Optional[list[Disk]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cpu_count is not None:
            if hasattr(self.cpu_count, 'to_dict'):
                props['CpuCount'] = self.cpu_count.to_dict()
            elif isinstance(self.cpu_count, list):
                props['CpuCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_count
                ]
            else:
                props['CpuCount'] = self.cpu_count

        if self.ram_size_in_gb is not None:
            if hasattr(self.ram_size_in_gb, 'to_dict'):
                props['RamSizeInGb'] = self.ram_size_in_gb.to_dict()
            elif isinstance(self.ram_size_in_gb, list):
                props['RamSizeInGb'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ram_size_in_gb
                ]
            else:
                props['RamSizeInGb'] = self.ram_size_in_gb

        if self.disks is not None:
            if hasattr(self.disks, 'to_dict'):
                props['Disks'] = self.disks.to_dict()
            elif isinstance(self.disks, list):
                props['Disks'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disks
                ]
            else:
                props['Disks'] = self.disks

        return props


@dataclass
class Location:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    region_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.region_name is not None:
            if hasattr(self.region_name, 'to_dict'):
                props['RegionName'] = self.region_name.to_dict()
            elif isinstance(self.region_name, list):
                props['RegionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.region_name
                ]
            else:
                props['RegionName'] = self.region_name

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        return props


@dataclass
class MonthlyTransfer:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    gb_per_month_allocated: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.gb_per_month_allocated is not None:
            if hasattr(self.gb_per_month_allocated, 'to_dict'):
                props['GbPerMonthAllocated'] = self.gb_per_month_allocated.to_dict()
            elif isinstance(self.gb_per_month_allocated, list):
                props['GbPerMonthAllocated'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gb_per_month_allocated
                ]
            else:
                props['GbPerMonthAllocated'] = self.gb_per_month_allocated

        return props


@dataclass
class Networking:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ports: Optional[list[Port]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monthly_transfer: Optional[MonthlyTransfer] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ports is not None:
            if hasattr(self.ports, 'to_dict'):
                props['Ports'] = self.ports.to_dict()
            elif isinstance(self.ports, list):
                props['Ports'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ports
                ]
            else:
                props['Ports'] = self.ports

        if self.monthly_transfer is not None:
            if hasattr(self.monthly_transfer, 'to_dict'):
                props['MonthlyTransfer'] = self.monthly_transfer.to_dict()
            elif isinstance(self.monthly_transfer, list):
                props['MonthlyTransfer'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monthly_transfer
                ]
            else:
                props['MonthlyTransfer'] = self.monthly_transfer

        return props


@dataclass
class Port:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    access_direction: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr_list_aliases: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_cidrs: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    access_from: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    access_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidrs: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    common_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.from_port is not None:
            if hasattr(self.from_port, 'to_dict'):
                props['FromPort'] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props['FromPort'] = self.from_port

        if self.access_direction is not None:
            if hasattr(self.access_direction, 'to_dict'):
                props['AccessDirection'] = self.access_direction.to_dict()
            elif isinstance(self.access_direction, list):
                props['AccessDirection'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.access_direction
                ]
            else:
                props['AccessDirection'] = self.access_direction

        if self.cidr_list_aliases is not None:
            if hasattr(self.cidr_list_aliases, 'to_dict'):
                props['CidrListAliases'] = self.cidr_list_aliases.to_dict()
            elif isinstance(self.cidr_list_aliases, list):
                props['CidrListAliases'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_list_aliases
                ]
            else:
                props['CidrListAliases'] = self.cidr_list_aliases

        if self.to_port is not None:
            if hasattr(self.to_port, 'to_dict'):
                props['ToPort'] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props['ToPort'] = self.to_port

        if self.ipv6_cidrs is not None:
            if hasattr(self.ipv6_cidrs, 'to_dict'):
                props['Ipv6Cidrs'] = self.ipv6_cidrs.to_dict()
            elif isinstance(self.ipv6_cidrs, list):
                props['Ipv6Cidrs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_cidrs
                ]
            else:
                props['Ipv6Cidrs'] = self.ipv6_cidrs

        if self.access_from is not None:
            if hasattr(self.access_from, 'to_dict'):
                props['AccessFrom'] = self.access_from.to_dict()
            elif isinstance(self.access_from, list):
                props['AccessFrom'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.access_from
                ]
            else:
                props['AccessFrom'] = self.access_from

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        if self.access_type is not None:
            if hasattr(self.access_type, 'to_dict'):
                props['AccessType'] = self.access_type.to_dict()
            elif isinstance(self.access_type, list):
                props['AccessType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.access_type
                ]
            else:
                props['AccessType'] = self.access_type

        if self.cidrs is not None:
            if hasattr(self.cidrs, 'to_dict'):
                props['Cidrs'] = self.cidrs.to_dict()
            elif isinstance(self.cidrs, list):
                props['Cidrs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidrs
                ]
            else:
                props['Cidrs'] = self.cidrs

        if self.common_name is not None:
            if hasattr(self.common_name, 'to_dict'):
                props['CommonName'] = self.common_name.to_dict()
            elif isinstance(self.common_name, list):
                props['CommonName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.common_name
                ]
            else:
                props['CommonName'] = self.common_name

        return props


@dataclass
class State:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    code: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.code is not None:
            if hasattr(self.code, 'to_dict'):
                props['Code'] = self.code.to_dict()
            elif isinstance(self.code, list):
                props['Code'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code
                ]
            else:
                props['Code'] = self.code

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class Instance(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-light"""

    resource_type: ClassVar[str] = "AWS::Lightsail::Instance"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    key_pair_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    bundle_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    blueprint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    networking: Optional[Networking] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    user_data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    state: Optional[State] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    add_ons: Optional[list[AddOn]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    hardware: Optional[Hardware] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    location: Optional[Location] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_name is not None:
            # Serialize instance_name (handle intrinsic functions)
            if hasattr(self.instance_name, 'to_dict'):
                props["InstanceName"] = self.instance_name.to_dict()
            elif isinstance(self.instance_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_name
                ]
            else:
                props["InstanceName"] = self.instance_name

        if self.key_pair_name is not None:
            # Serialize key_pair_name (handle intrinsic functions)
            if hasattr(self.key_pair_name, 'to_dict'):
                props["KeyPairName"] = self.key_pair_name.to_dict()
            elif isinstance(self.key_pair_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['KeyPairName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_pair_name
                ]
            else:
                props["KeyPairName"] = self.key_pair_name

        if self.bundle_id is not None:
            # Serialize bundle_id (handle intrinsic functions)
            if hasattr(self.bundle_id, 'to_dict'):
                props["BundleId"] = self.bundle_id.to_dict()
            elif isinstance(self.bundle_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['BundleId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bundle_id
                ]
            else:
                props["BundleId"] = self.bundle_id

        if self.blueprint_id is not None:
            # Serialize blueprint_id (handle intrinsic functions)
            if hasattr(self.blueprint_id, 'to_dict'):
                props["BlueprintId"] = self.blueprint_id.to_dict()
            elif isinstance(self.blueprint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['BlueprintId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.blueprint_id
                ]
            else:
                props["BlueprintId"] = self.blueprint_id

        if self.networking is not None:
            # Serialize networking (handle intrinsic functions)
            if hasattr(self.networking, 'to_dict'):
                props["Networking"] = self.networking.to_dict()
            elif isinstance(self.networking, list):
                # Serialize list items (may contain intrinsic functions)
                props['Networking'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.networking
                ]
            else:
                props["Networking"] = self.networking

        if self.user_data is not None:
            # Serialize user_data (handle intrinsic functions)
            if hasattr(self.user_data, 'to_dict'):
                props["UserData"] = self.user_data.to_dict()
            elif isinstance(self.user_data, list):
                # Serialize list items (may contain intrinsic functions)
                props['UserData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_data
                ]
            else:
                props["UserData"] = self.user_data

        if self.state is not None:
            # Serialize state (handle intrinsic functions)
            if hasattr(self.state, 'to_dict'):
                props["State"] = self.state.to_dict()
            elif isinstance(self.state, list):
                # Serialize list items (may contain intrinsic functions)
                props['State'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state
                ]
            else:
                props["State"] = self.state

        if self.availability_zone is not None:
            # Serialize availability_zone (handle intrinsic functions)
            if hasattr(self.availability_zone, 'to_dict'):
                props["AvailabilityZone"] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props["AvailabilityZone"] = self.availability_zone

        if self.add_ons is not None:
            # Serialize add_ons (handle intrinsic functions)
            if hasattr(self.add_ons, 'to_dict'):
                props["AddOns"] = self.add_ons.to_dict()
            elif isinstance(self.add_ons, list):
                # Serialize list items (may contain intrinsic functions)
                props['AddOns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.add_ons
                ]
            else:
                props["AddOns"] = self.add_ons

        if self.hardware is not None:
            # Serialize hardware (handle intrinsic functions)
            if hasattr(self.hardware, 'to_dict'):
                props["Hardware"] = self.hardware.to_dict()
            elif isinstance(self.hardware, list):
                # Serialize list items (may contain intrinsic functions)
                props['Hardware'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hardware
                ]
            else:
                props["Hardware"] = self.hardware

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.location is not None:
            # Serialize location (handle intrinsic functions)
            if hasattr(self.location, 'to_dict'):
                props["Location"] = self.location.to_dict()
            elif isinstance(self.location, list):
                # Serialize list items (may contain intrinsic functions)
                props['Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.location
                ]
            else:
                props["Location"] = self.location

        return props

    @property
    def attr_ssh_key_name(self) -> GetAtt:
        """Get the SshKeyName attribute."""
        return self.get_att("SshKeyName")

    @property
    def attr_networking__monthly_transfer__gb_per_month_allocated(self) -> GetAtt:
        """Get the Networking.MonthlyTransfer.GbPerMonthAllocated attribute."""
        return self.get_att("Networking.MonthlyTransfer.GbPerMonthAllocated")

    @property
    def attr_hardware__cpu_count(self) -> GetAtt:
        """Get the Hardware.CpuCount attribute."""
        return self.get_att("Hardware.CpuCount")

    @property
    def attr_is_static_ip(self) -> GetAtt:
        """Get the IsStaticIp attribute."""
        return self.get_att("IsStaticIp")

    @property
    def attr_private_ip_address(self) -> GetAtt:
        """Get the PrivateIpAddress attribute."""
        return self.get_att("PrivateIpAddress")

    @property
    def attr_user_name(self) -> GetAtt:
        """Get the UserName attribute."""
        return self.get_att("UserName")

    @property
    def attr_resource_type(self) -> GetAtt:
        """Get the ResourceType attribute."""
        return self.get_att("ResourceType")

    @property
    def attr_ipv6_addresses(self) -> GetAtt:
        """Get the Ipv6Addresses attribute."""
        return self.get_att("Ipv6Addresses")

    @property
    def attr_location__region_name(self) -> GetAtt:
        """Get the Location.RegionName attribute."""
        return self.get_att("Location.RegionName")

    @property
    def attr_public_ip_address(self) -> GetAtt:
        """Get the PublicIpAddress attribute."""
        return self.get_att("PublicIpAddress")

    @property
    def attr_location__availability_zone(self) -> GetAtt:
        """Get the Location.AvailabilityZone attribute."""
        return self.get_att("Location.AvailabilityZone")

    @property
    def attr_state__code(self) -> GetAtt:
        """Get the State.Code attribute."""
        return self.get_att("State.Code")

    @property
    def attr_support_code(self) -> GetAtt:
        """Get the SupportCode attribute."""
        return self.get_att("SupportCode")

    @property
    def attr_state__name(self) -> GetAtt:
        """Get the State.Name attribute."""
        return self.get_att("State.Name")

    @property
    def attr_instance_arn(self) -> GetAtt:
        """Get the InstanceArn attribute."""
        return self.get_att("InstanceArn")

    @property
    def attr_hardware__ram_size_in_gb(self) -> GetAtt:
        """Get the Hardware.RamSizeInGb attribute."""
        return self.get_att("Hardware.RamSizeInGb")




@dataclass
class Location:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lig"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    region_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.region_name is not None:
            if hasattr(self.region_name, 'to_dict'):
                props['RegionName'] = self.region_name.to_dict()
            elif isinstance(self.region_name, list):
                props['RegionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.region_name
                ]
            else:
                props['RegionName'] = self.region_name

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        return props


@dataclass
class InstanceSnapshot(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-light"""

    resource_type: ClassVar[str] = "AWS::Lightsail::InstanceSnapshot"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_snapshot_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_name is not None:
            # Serialize instance_name (handle intrinsic functions)
            if hasattr(self.instance_name, 'to_dict'):
                props["InstanceName"] = self.instance_name.to_dict()
            elif isinstance(self.instance_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_name
                ]
            else:
                props["InstanceName"] = self.instance_name

        if self.instance_snapshot_name is not None:
            # Serialize instance_snapshot_name (handle intrinsic functions)
            if hasattr(self.instance_snapshot_name, 'to_dict'):
                props["InstanceSnapshotName"] = self.instance_snapshot_name.to_dict()
            elif isinstance(self.instance_snapshot_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceSnapshotName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_snapshot_name
                ]
            else:
                props["InstanceSnapshotName"] = self.instance_snapshot_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_size_in_gb(self) -> GetAtt:
        """Get the SizeInGb attribute."""
        return self.get_att("SizeInGb")

    @property
    def attr_location__availability_zone(self) -> GetAtt:
        """Get the Location.AvailabilityZone attribute."""
        return self.get_att("Location.AvailabilityZone")

    @property
    def attr_support_code(self) -> GetAtt:
        """Get the SupportCode attribute."""
        return self.get_att("SupportCode")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_from_instance_name(self) -> GetAtt:
        """Get the FromInstanceName attribute."""
        return self.get_att("FromInstanceName")

    @property
    def attr_resource_type(self) -> GetAtt:
        """Get the ResourceType attribute."""
        return self.get_att("ResourceType")

    @property
    def attr_is_from_auto_snapshot(self) -> GetAtt:
        """Get the IsFromAutoSnapshot attribute."""
        return self.get_att("IsFromAutoSnapshot")

    @property
    def attr_from_instance_arn(self) -> GetAtt:
        """Get the FromInstanceArn attribute."""
        return self.get_att("FromInstanceArn")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_location(self) -> GetAtt:
        """Get the Location attribute."""
        return self.get_att("Location")

    @property
    def attr_location__region_name(self) -> GetAtt:
        """Get the Location.RegionName attribute."""
        return self.get_att("Location.RegionName")




@dataclass
class LoadBalancer(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-light"""

    resource_type: ClassVar[str] = "AWS::Lightsail::LoadBalancer"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ip_address_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    session_stickiness_lb_cookie_duration_seconds: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    load_balancer_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    attached_instances: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    health_check_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    session_stickiness_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tls_policy_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ip_address_type is not None:
            # Serialize ip_address_type (handle intrinsic functions)
            if hasattr(self.ip_address_type, 'to_dict'):
                props["IpAddressType"] = self.ip_address_type.to_dict()
            elif isinstance(self.ip_address_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpAddressType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_address_type
                ]
            else:
                props["IpAddressType"] = self.ip_address_type

        if self.session_stickiness_lb_cookie_duration_seconds is not None:
            # Serialize session_stickiness_lb_cookie_duration_seconds (handle intrinsic functions)
            if hasattr(self.session_stickiness_lb_cookie_duration_seconds, 'to_dict'):
                props["SessionStickinessLBCookieDurationSeconds"] = self.session_stickiness_lb_cookie_duration_seconds.to_dict()
            elif isinstance(self.session_stickiness_lb_cookie_duration_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['SessionStickinessLBCookieDurationSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.session_stickiness_lb_cookie_duration_seconds
                ]
            else:
                props["SessionStickinessLBCookieDurationSeconds"] = self.session_stickiness_lb_cookie_duration_seconds

        if self.load_balancer_name is not None:
            # Serialize load_balancer_name (handle intrinsic functions)
            if hasattr(self.load_balancer_name, 'to_dict'):
                props["LoadBalancerName"] = self.load_balancer_name.to_dict()
            elif isinstance(self.load_balancer_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LoadBalancerName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_name
                ]
            else:
                props["LoadBalancerName"] = self.load_balancer_name

        if self.attached_instances is not None:
            # Serialize attached_instances (handle intrinsic functions)
            if hasattr(self.attached_instances, 'to_dict'):
                props["AttachedInstances"] = self.attached_instances.to_dict()
            elif isinstance(self.attached_instances, list):
                # Serialize list items (may contain intrinsic functions)
                props['AttachedInstances'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attached_instances
                ]
            else:
                props["AttachedInstances"] = self.attached_instances

        if self.instance_port is not None:
            # Serialize instance_port (handle intrinsic functions)
            if hasattr(self.instance_port, 'to_dict'):
                props["InstancePort"] = self.instance_port.to_dict()
            elif isinstance(self.instance_port, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstancePort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_port
                ]
            else:
                props["InstancePort"] = self.instance_port

        if self.health_check_path is not None:
            # Serialize health_check_path (handle intrinsic functions)
            if hasattr(self.health_check_path, 'to_dict'):
                props["HealthCheckPath"] = self.health_check_path.to_dict()
            elif isinstance(self.health_check_path, list):
                # Serialize list items (may contain intrinsic functions)
                props['HealthCheckPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.health_check_path
                ]
            else:
                props["HealthCheckPath"] = self.health_check_path

        if self.session_stickiness_enabled is not None:
            # Serialize session_stickiness_enabled (handle intrinsic functions)
            if hasattr(self.session_stickiness_enabled, 'to_dict'):
                props["SessionStickinessEnabled"] = self.session_stickiness_enabled.to_dict()
            elif isinstance(self.session_stickiness_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['SessionStickinessEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.session_stickiness_enabled
                ]
            else:
                props["SessionStickinessEnabled"] = self.session_stickiness_enabled

        if self.tls_policy_name is not None:
            # Serialize tls_policy_name (handle intrinsic functions)
            if hasattr(self.tls_policy_name, 'to_dict'):
                props["TlsPolicyName"] = self.tls_policy_name.to_dict()
            elif isinstance(self.tls_policy_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['TlsPolicyName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tls_policy_name
                ]
            else:
                props["TlsPolicyName"] = self.tls_policy_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_load_balancer_arn(self) -> GetAtt:
        """Get the LoadBalancerArn attribute."""
        return self.get_att("LoadBalancerArn")




@dataclass
class LoadBalancerTlsCertificate(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-light"""

    resource_type: ClassVar[str] = "AWS::Lightsail::LoadBalancerTlsCertificate"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    load_balancer_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    certificate_domain_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    is_attached: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    certificate_alternative_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    https_redirection_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    certificate_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.load_balancer_name is not None:
            # Serialize load_balancer_name (handle intrinsic functions)
            if hasattr(self.load_balancer_name, 'to_dict'):
                props["LoadBalancerName"] = self.load_balancer_name.to_dict()
            elif isinstance(self.load_balancer_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LoadBalancerName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_name
                ]
            else:
                props["LoadBalancerName"] = self.load_balancer_name

        if self.certificate_domain_name is not None:
            # Serialize certificate_domain_name (handle intrinsic functions)
            if hasattr(self.certificate_domain_name, 'to_dict'):
                props["CertificateDomainName"] = self.certificate_domain_name.to_dict()
            elif isinstance(self.certificate_domain_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['CertificateDomainName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_domain_name
                ]
            else:
                props["CertificateDomainName"] = self.certificate_domain_name

        if self.is_attached is not None:
            # Serialize is_attached (handle intrinsic functions)
            if hasattr(self.is_attached, 'to_dict'):
                props["IsAttached"] = self.is_attached.to_dict()
            elif isinstance(self.is_attached, list):
                # Serialize list items (may contain intrinsic functions)
                props['IsAttached'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.is_attached
                ]
            else:
                props["IsAttached"] = self.is_attached

        if self.certificate_alternative_names is not None:
            # Serialize certificate_alternative_names (handle intrinsic functions)
            if hasattr(self.certificate_alternative_names, 'to_dict'):
                props["CertificateAlternativeNames"] = self.certificate_alternative_names.to_dict()
            elif isinstance(self.certificate_alternative_names, list):
                # Serialize list items (may contain intrinsic functions)
                props['CertificateAlternativeNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_alternative_names
                ]
            else:
                props["CertificateAlternativeNames"] = self.certificate_alternative_names

        if self.https_redirection_enabled is not None:
            # Serialize https_redirection_enabled (handle intrinsic functions)
            if hasattr(self.https_redirection_enabled, 'to_dict'):
                props["HttpsRedirectionEnabled"] = self.https_redirection_enabled.to_dict()
            elif isinstance(self.https_redirection_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['HttpsRedirectionEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.https_redirection_enabled
                ]
            else:
                props["HttpsRedirectionEnabled"] = self.https_redirection_enabled

        if self.certificate_name is not None:
            # Serialize certificate_name (handle intrinsic functions)
            if hasattr(self.certificate_name, 'to_dict'):
                props["CertificateName"] = self.certificate_name.to_dict()
            elif isinstance(self.certificate_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['CertificateName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_name
                ]
            else:
                props["CertificateName"] = self.certificate_name

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_load_balancer_tls_certificate_arn(self) -> GetAtt:
        """Get the LoadBalancerTlsCertificateArn attribute."""
        return self.get_att("LoadBalancerTlsCertificateArn")




@dataclass
class StaticIp(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-light"""

    resource_type: ClassVar[str] = "AWS::Lightsail::StaticIp"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    static_ip_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    attached_to: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.static_ip_name is not None:
            # Serialize static_ip_name (handle intrinsic functions)
            if hasattr(self.static_ip_name, 'to_dict'):
                props["StaticIpName"] = self.static_ip_name.to_dict()
            elif isinstance(self.static_ip_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['StaticIpName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.static_ip_name
                ]
            else:
                props["StaticIpName"] = self.static_ip_name

        if self.attached_to is not None:
            # Serialize attached_to (handle intrinsic functions)
            if hasattr(self.attached_to, 'to_dict'):
                props["AttachedTo"] = self.attached_to.to_dict()
            elif isinstance(self.attached_to, list):
                # Serialize list items (may contain intrinsic functions)
                props['AttachedTo'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attached_to
                ]
            else:
                props["AttachedTo"] = self.attached_to

        return props

    @property
    def attr_static_ip_arn(self) -> GetAtt:
        """Get the StaticIpArn attribute."""
        return self.get_att("StaticIpArn")

    @property
    def attr_is_attached(self) -> GetAtt:
        """Get the IsAttached attribute."""
        return self.get_att("IsAttached")

    @property
    def attr_ip_address(self) -> GetAtt:
        """Get the IpAddress attribute."""
        return self.get_att("IpAddress")



