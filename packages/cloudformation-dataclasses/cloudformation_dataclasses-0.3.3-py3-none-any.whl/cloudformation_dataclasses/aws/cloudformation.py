"""
AWS CloudFormation CloudFormation Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:35

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service CloudFormation
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AccountFilterType:
    """AccountFilterType enum values."""

    NONE = "NONE"
    INTERSECTION = "INTERSECTION"
    DIFFERENCE = "DIFFERENCE"
    UNION = "UNION"


class AccountGateStatus:
    """AccountGateStatus enum values."""

    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    SKIPPED = "SKIPPED"


class AfterValueFrom:
    """AfterValueFrom enum values."""

    TEMPLATE = "TEMPLATE"


class AnnotationSeverityLevel:
    """AnnotationSeverityLevel enum values."""

    INFORMATIONAL = "INFORMATIONAL"
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"
    CRITICAL = "CRITICAL"


class AnnotationStatus:
    """AnnotationStatus enum values."""

    PASSED = "PASSED"
    FAILED = "FAILED"
    SKIPPED = "SKIPPED"


class AttributeChangeType:
    """AttributeChangeType enum values."""

    ADD = "Add"
    REMOVE = "Remove"
    MODIFY = "Modify"
    SYNCWITHACTUAL = "SyncWithActual"


class BeaconStackOperationStatus:
    """BeaconStackOperationStatus enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"


class BeforeValueFrom:
    """BeforeValueFrom enum values."""

    PREVIOUS_DEPLOYMENT_STATE = "PREVIOUS_DEPLOYMENT_STATE"
    ACTUAL_STATE = "ACTUAL_STATE"


class CallAs:
    """CallAs enum values."""

    SELF = "SELF"
    DELEGATED_ADMIN = "DELEGATED_ADMIN"


class Capability:
    """Capability enum values."""

    CAPABILITY_IAM = "CAPABILITY_IAM"
    CAPABILITY_NAMED_IAM = "CAPABILITY_NAMED_IAM"
    CAPABILITY_AUTO_EXPAND = "CAPABILITY_AUTO_EXPAND"


class Category:
    """Category enum values."""

    REGISTERED = "REGISTERED"
    ACTIVATED = "ACTIVATED"
    THIRD_PARTY = "THIRD_PARTY"
    AWS_TYPES = "AWS_TYPES"


class ChangeAction:
    """ChangeAction enum values."""

    ADD = "Add"
    MODIFY = "Modify"
    REMOVE = "Remove"
    IMPORT = "Import"
    DYNAMIC = "Dynamic"
    SYNCWITHACTUAL = "SyncWithActual"


class ChangeSetHooksStatus:
    """ChangeSetHooksStatus enum values."""

    PLANNING = "PLANNING"
    PLANNED = "PLANNED"
    UNAVAILABLE = "UNAVAILABLE"


class ChangeSetStatus:
    """ChangeSetStatus enum values."""

    CREATE_PENDING = "CREATE_PENDING"
    CREATE_IN_PROGRESS = "CREATE_IN_PROGRESS"
    CREATE_COMPLETE = "CREATE_COMPLETE"
    DELETE_PENDING = "DELETE_PENDING"
    DELETE_IN_PROGRESS = "DELETE_IN_PROGRESS"
    DELETE_COMPLETE = "DELETE_COMPLETE"
    DELETE_FAILED = "DELETE_FAILED"
    FAILED = "FAILED"


class ChangeSetType:
    """ChangeSetType enum values."""

    CREATE = "CREATE"
    UPDATE = "UPDATE"
    IMPORT = "IMPORT"


class ChangeSource:
    """ChangeSource enum values."""

    RESOURCEREFERENCE = "ResourceReference"
    PARAMETERREFERENCE = "ParameterReference"
    RESOURCEATTRIBUTE = "ResourceAttribute"
    DIRECTMODIFICATION = "DirectModification"
    AUTOMATIC = "Automatic"
    NOMODIFICATION = "NoModification"


class ChangeType:
    """ChangeType enum values."""

    RESOURCE = "Resource"


class ConcurrencyMode:
    """ConcurrencyMode enum values."""

    STRICT_FAILURE_TOLERANCE = "STRICT_FAILURE_TOLERANCE"
    SOFT_FAILURE_TOLERANCE = "SOFT_FAILURE_TOLERANCE"


class DeletionMode:
    """DeletionMode enum values."""

    STANDARD = "STANDARD"
    FORCE_DELETE_STACK = "FORCE_DELETE_STACK"


class DeploymentMode:
    """DeploymentMode enum values."""

    REVERT_DRIFT = "REVERT_DRIFT"


class DeprecatedStatus:
    """DeprecatedStatus enum values."""

    LIVE = "LIVE"
    DEPRECATED = "DEPRECATED"


class DetailedStatus:
    """DetailedStatus enum values."""

    CONFIGURATION_COMPLETE = "CONFIGURATION_COMPLETE"
    VALIDATION_FAILED = "VALIDATION_FAILED"


class DifferenceType:
    """DifferenceType enum values."""

    ADD = "ADD"
    REMOVE = "REMOVE"
    NOT_EQUAL = "NOT_EQUAL"


class DriftIgnoredReason:
    """DriftIgnoredReason enum values."""

    MANAGED_BY_AWS = "MANAGED_BY_AWS"
    WRITE_ONLY_PROPERTY = "WRITE_ONLY_PROPERTY"


class EvaluationType:
    """EvaluationType enum values."""

    STATIC = "Static"
    DYNAMIC = "Dynamic"


class EventType:
    """EventType enum values."""

    STACK_EVENT = "STACK_EVENT"
    PROGRESS_EVENT = "PROGRESS_EVENT"
    VALIDATION_ERROR = "VALIDATION_ERROR"
    PROVISIONING_ERROR = "PROVISIONING_ERROR"
    HOOK_INVOCATION_ERROR = "HOOK_INVOCATION_ERROR"


class ExecutionStatus:
    """ExecutionStatus enum values."""

    UNAVAILABLE = "UNAVAILABLE"
    AVAILABLE = "AVAILABLE"
    EXECUTE_IN_PROGRESS = "EXECUTE_IN_PROGRESS"
    EXECUTE_COMPLETE = "EXECUTE_COMPLETE"
    EXECUTE_FAILED = "EXECUTE_FAILED"
    OBSOLETE = "OBSOLETE"


class GeneratedTemplateDeletionPolicy:
    """GeneratedTemplateDeletionPolicy enum values."""

    DELETE = "DELETE"
    RETAIN = "RETAIN"


class GeneratedTemplateResourceStatus:
    """GeneratedTemplateResourceStatus enum values."""

    PENDING = "PENDING"
    IN_PROGRESS = "IN_PROGRESS"
    FAILED = "FAILED"
    COMPLETE = "COMPLETE"


class GeneratedTemplateStatus:
    """GeneratedTemplateStatus enum values."""

    CREATE_PENDING = "CREATE_PENDING"
    UPDATE_PENDING = "UPDATE_PENDING"
    DELETE_PENDING = "DELETE_PENDING"
    CREATE_IN_PROGRESS = "CREATE_IN_PROGRESS"
    UPDATE_IN_PROGRESS = "UPDATE_IN_PROGRESS"
    DELETE_IN_PROGRESS = "DELETE_IN_PROGRESS"
    FAILED = "FAILED"
    COMPLETE = "COMPLETE"


class GeneratedTemplateUpdateReplacePolicy:
    """GeneratedTemplateUpdateReplacePolicy enum values."""

    DELETE = "DELETE"
    RETAIN = "RETAIN"


class HandlerErrorCode:
    """HandlerErrorCode enum values."""

    NOTUPDATABLE = "NotUpdatable"
    INVALIDREQUEST = "InvalidRequest"
    ACCESSDENIED = "AccessDenied"
    INVALIDCREDENTIALS = "InvalidCredentials"
    ALREADYEXISTS = "AlreadyExists"
    NOTFOUND = "NotFound"
    RESOURCECONFLICT = "ResourceConflict"
    THROTTLING = "Throttling"
    SERVICELIMITEXCEEDED = "ServiceLimitExceeded"
    NOTSTABILIZED = "NotStabilized"
    GENERALSERVICEEXCEPTION = "GeneralServiceException"
    SERVICEINTERNALERROR = "ServiceInternalError"
    NETWORKFAILURE = "NetworkFailure"
    INTERNALFAILURE = "InternalFailure"
    INVALIDTYPECONFIGURATION = "InvalidTypeConfiguration"
    HANDLERINTERNALFAILURE = "HandlerInternalFailure"
    NONCOMPLIANT = "NonCompliant"
    UNKNOWN = "Unknown"
    UNSUPPORTEDTARGET = "UnsupportedTarget"


class HookFailureMode:
    """HookFailureMode enum values."""

    FAIL = "FAIL"
    WARN = "WARN"


class HookInvocationPoint:
    """HookInvocationPoint enum values."""

    PRE_PROVISION = "PRE_PROVISION"


class HookStatus:
    """HookStatus enum values."""

    HOOK_IN_PROGRESS = "HOOK_IN_PROGRESS"
    HOOK_COMPLETE_SUCCEEDED = "HOOK_COMPLETE_SUCCEEDED"
    HOOK_COMPLETE_FAILED = "HOOK_COMPLETE_FAILED"
    HOOK_FAILED = "HOOK_FAILED"


class HookTargetAction:
    """HookTargetAction enum values."""

    CREATE = "CREATE"
    UPDATE = "UPDATE"
    DELETE = "DELETE"
    IMPORT = "IMPORT"


class HookTargetType:
    """HookTargetType enum values."""

    RESOURCE = "RESOURCE"


class IdentityProvider:
    """IdentityProvider enum values."""

    AWS_MARKETPLACE = "AWS_Marketplace"
    GITHUB = "GitHub"
    BITBUCKET = "Bitbucket"


class ListHookResultsTargetType:
    """ListHookResultsTargetType enum values."""

    CHANGE_SET = "CHANGE_SET"
    STACK = "STACK"
    RESOURCE = "RESOURCE"
    CLOUD_CONTROL = "CLOUD_CONTROL"


class OnFailure:
    """OnFailure enum values."""

    DO_NOTHING = "DO_NOTHING"
    ROLLBACK = "ROLLBACK"
    DELETE = "DELETE"


class OnStackFailure:
    """OnStackFailure enum values."""

    DO_NOTHING = "DO_NOTHING"
    ROLLBACK = "ROLLBACK"
    DELETE = "DELETE"


class OperationResultFilterName:
    """OperationResultFilterName enum values."""

    OPERATION_RESULT_STATUS = "OPERATION_RESULT_STATUS"


class OperationStatus:
    """OperationStatus enum values."""

    PENDING = "PENDING"
    IN_PROGRESS = "IN_PROGRESS"
    SUCCESS = "SUCCESS"
    FAILED = "FAILED"


class OperationType:
    """OperationType enum values."""

    CREATE_STACK = "CREATE_STACK"
    UPDATE_STACK = "UPDATE_STACK"
    DELETE_STACK = "DELETE_STACK"
    CONTINUE_ROLLBACK = "CONTINUE_ROLLBACK"
    ROLLBACK = "ROLLBACK"
    CREATE_CHANGESET = "CREATE_CHANGESET"


class OrganizationStatus:
    """OrganizationStatus enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"
    DISABLED_PERMANENTLY = "DISABLED_PERMANENTLY"


class PermissionModels:
    """PermissionModels enum values."""

    SERVICE_MANAGED = "SERVICE_MANAGED"
    SELF_MANAGED = "SELF_MANAGED"


class PolicyAction:
    """PolicyAction enum values."""

    DELETE = "Delete"
    RETAIN = "Retain"
    SNAPSHOT = "Snapshot"
    REPLACEANDDELETE = "ReplaceAndDelete"
    REPLACEANDRETAIN = "ReplaceAndRetain"
    REPLACEANDSNAPSHOT = "ReplaceAndSnapshot"


class ProvisioningType:
    """ProvisioningType enum values."""

    NON_PROVISIONABLE = "NON_PROVISIONABLE"
    IMMUTABLE = "IMMUTABLE"
    FULLY_MUTABLE = "FULLY_MUTABLE"


class PublisherStatus:
    """PublisherStatus enum values."""

    VERIFIED = "VERIFIED"
    UNVERIFIED = "UNVERIFIED"


class RegionConcurrencyType:
    """RegionConcurrencyType enum values."""

    SEQUENTIAL = "SEQUENTIAL"
    PARALLEL = "PARALLEL"


class RegistrationStatus:
    """RegistrationStatus enum values."""

    COMPLETE = "COMPLETE"
    IN_PROGRESS = "IN_PROGRESS"
    FAILED = "FAILED"


class RegistryType:
    """RegistryType enum values."""

    RESOURCE = "RESOURCE"
    MODULE = "MODULE"
    HOOK = "HOOK"


class Replacement:
    """Replacement enum values."""

    TRUE = "True"
    FALSE = "False"
    CONDITIONAL = "Conditional"


class RequiresRecreation:
    """RequiresRecreation enum values."""

    NEVER = "Never"
    CONDITIONALLY = "Conditionally"
    ALWAYS = "Always"


class ResourceAttribute:
    """ResourceAttribute enum values."""

    PROPERTIES = "Properties"
    METADATA = "Metadata"
    CREATIONPOLICY = "CreationPolicy"
    UPDATEPOLICY = "UpdatePolicy"
    DELETIONPOLICY = "DeletionPolicy"
    UPDATEREPLACEPOLICY = "UpdateReplacePolicy"
    TAGS = "Tags"


class ResourceScanStatus:
    """ResourceScanStatus enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    FAILED = "FAILED"
    COMPLETE = "COMPLETE"
    EXPIRED = "EXPIRED"


class ResourceSignalStatus:
    """ResourceSignalStatus enum values."""

    SUCCESS = "SUCCESS"
    FAILURE = "FAILURE"


class ResourceStatus:
    """ResourceStatus enum values."""

    CREATE_IN_PROGRESS = "CREATE_IN_PROGRESS"
    CREATE_FAILED = "CREATE_FAILED"
    CREATE_COMPLETE = "CREATE_COMPLETE"
    DELETE_IN_PROGRESS = "DELETE_IN_PROGRESS"
    DELETE_FAILED = "DELETE_FAILED"
    DELETE_COMPLETE = "DELETE_COMPLETE"
    DELETE_SKIPPED = "DELETE_SKIPPED"
    UPDATE_IN_PROGRESS = "UPDATE_IN_PROGRESS"
    UPDATE_FAILED = "UPDATE_FAILED"
    UPDATE_COMPLETE = "UPDATE_COMPLETE"
    IMPORT_FAILED = "IMPORT_FAILED"
    IMPORT_COMPLETE = "IMPORT_COMPLETE"
    IMPORT_IN_PROGRESS = "IMPORT_IN_PROGRESS"
    IMPORT_ROLLBACK_IN_PROGRESS = "IMPORT_ROLLBACK_IN_PROGRESS"
    IMPORT_ROLLBACK_FAILED = "IMPORT_ROLLBACK_FAILED"
    IMPORT_ROLLBACK_COMPLETE = "IMPORT_ROLLBACK_COMPLETE"
    EXPORT_FAILED = "EXPORT_FAILED"
    EXPORT_COMPLETE = "EXPORT_COMPLETE"
    EXPORT_IN_PROGRESS = "EXPORT_IN_PROGRESS"
    EXPORT_ROLLBACK_IN_PROGRESS = "EXPORT_ROLLBACK_IN_PROGRESS"
    EXPORT_ROLLBACK_FAILED = "EXPORT_ROLLBACK_FAILED"
    EXPORT_ROLLBACK_COMPLETE = "EXPORT_ROLLBACK_COMPLETE"
    UPDATE_ROLLBACK_IN_PROGRESS = "UPDATE_ROLLBACK_IN_PROGRESS"
    UPDATE_ROLLBACK_COMPLETE = "UPDATE_ROLLBACK_COMPLETE"
    UPDATE_ROLLBACK_FAILED = "UPDATE_ROLLBACK_FAILED"
    ROLLBACK_IN_PROGRESS = "ROLLBACK_IN_PROGRESS"
    ROLLBACK_COMPLETE = "ROLLBACK_COMPLETE"
    ROLLBACK_FAILED = "ROLLBACK_FAILED"


class ScanType:
    """ScanType enum values."""

    FULL = "FULL"
    PARTIAL = "PARTIAL"


class StackDriftDetectionStatus:
    """StackDriftDetectionStatus enum values."""

    DETECTION_IN_PROGRESS = "DETECTION_IN_PROGRESS"
    DETECTION_FAILED = "DETECTION_FAILED"
    DETECTION_COMPLETE = "DETECTION_COMPLETE"


class StackDriftStatus:
    """StackDriftStatus enum values."""

    DRIFTED = "DRIFTED"
    IN_SYNC = "IN_SYNC"
    UNKNOWN = "UNKNOWN"
    NOT_CHECKED = "NOT_CHECKED"


class StackInstanceDetailedStatus:
    """StackInstanceDetailedStatus enum values."""

    PENDING = "PENDING"
    RUNNING = "RUNNING"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"
    INOPERABLE = "INOPERABLE"
    SKIPPED_SUSPENDED_ACCOUNT = "SKIPPED_SUSPENDED_ACCOUNT"
    FAILED_IMPORT = "FAILED_IMPORT"


class StackInstanceFilterName:
    """StackInstanceFilterName enum values."""

    DETAILED_STATUS = "DETAILED_STATUS"
    LAST_OPERATION_ID = "LAST_OPERATION_ID"
    DRIFT_STATUS = "DRIFT_STATUS"


class StackInstanceStatus:
    """StackInstanceStatus enum values."""

    CURRENT = "CURRENT"
    OUTDATED = "OUTDATED"
    INOPERABLE = "INOPERABLE"


class StackRefactorActionEntity:
    """StackRefactorActionEntity enum values."""

    RESOURCE = "RESOURCE"
    STACK = "STACK"


class StackRefactorActionType:
    """StackRefactorActionType enum values."""

    MOVE = "MOVE"
    CREATE = "CREATE"


class StackRefactorDetection:
    """StackRefactorDetection enum values."""

    AUTO = "AUTO"
    MANUAL = "MANUAL"


class StackRefactorExecutionStatus:
    """StackRefactorExecutionStatus enum values."""

    UNAVAILABLE = "UNAVAILABLE"
    AVAILABLE = "AVAILABLE"
    OBSOLETE = "OBSOLETE"
    EXECUTE_IN_PROGRESS = "EXECUTE_IN_PROGRESS"
    EXECUTE_COMPLETE = "EXECUTE_COMPLETE"
    EXECUTE_FAILED = "EXECUTE_FAILED"
    ROLLBACK_IN_PROGRESS = "ROLLBACK_IN_PROGRESS"
    ROLLBACK_COMPLETE = "ROLLBACK_COMPLETE"
    ROLLBACK_FAILED = "ROLLBACK_FAILED"


class StackRefactorStatus:
    """StackRefactorStatus enum values."""

    CREATE_IN_PROGRESS = "CREATE_IN_PROGRESS"
    CREATE_COMPLETE = "CREATE_COMPLETE"
    CREATE_FAILED = "CREATE_FAILED"
    DELETE_IN_PROGRESS = "DELETE_IN_PROGRESS"
    DELETE_COMPLETE = "DELETE_COMPLETE"
    DELETE_FAILED = "DELETE_FAILED"


class StackResourceDriftStatus:
    """StackResourceDriftStatus enum values."""

    IN_SYNC = "IN_SYNC"
    MODIFIED = "MODIFIED"
    DELETED = "DELETED"
    NOT_CHECKED = "NOT_CHECKED"
    UNKNOWN = "UNKNOWN"
    UNSUPPORTED = "UNSUPPORTED"


class StackSetDriftDetectionStatus:
    """StackSetDriftDetectionStatus enum values."""

    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    PARTIAL_SUCCESS = "PARTIAL_SUCCESS"
    IN_PROGRESS = "IN_PROGRESS"
    STOPPED = "STOPPED"


class StackSetDriftStatus:
    """StackSetDriftStatus enum values."""

    DRIFTED = "DRIFTED"
    IN_SYNC = "IN_SYNC"
    NOT_CHECKED = "NOT_CHECKED"


class StackSetOperationAction:
    """StackSetOperationAction enum values."""

    CREATE = "CREATE"
    UPDATE = "UPDATE"
    DELETE = "DELETE"
    DETECT_DRIFT = "DETECT_DRIFT"


class StackSetOperationResultStatus:
    """StackSetOperationResultStatus enum values."""

    PENDING = "PENDING"
    RUNNING = "RUNNING"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"


class StackSetOperationStatus:
    """StackSetOperationStatus enum values."""

    RUNNING = "RUNNING"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    STOPPING = "STOPPING"
    STOPPED = "STOPPED"
    QUEUED = "QUEUED"


class StackSetStatus:
    """StackSetStatus enum values."""

    ACTIVE = "ACTIVE"
    DELETED = "DELETED"


class StackStatus:
    """StackStatus enum values."""

    CREATE_IN_PROGRESS = "CREATE_IN_PROGRESS"
    CREATE_FAILED = "CREATE_FAILED"
    CREATE_COMPLETE = "CREATE_COMPLETE"
    ROLLBACK_IN_PROGRESS = "ROLLBACK_IN_PROGRESS"
    ROLLBACK_FAILED = "ROLLBACK_FAILED"
    ROLLBACK_COMPLETE = "ROLLBACK_COMPLETE"
    DELETE_IN_PROGRESS = "DELETE_IN_PROGRESS"
    DELETE_FAILED = "DELETE_FAILED"
    DELETE_COMPLETE = "DELETE_COMPLETE"
    UPDATE_IN_PROGRESS = "UPDATE_IN_PROGRESS"
    UPDATE_COMPLETE_CLEANUP_IN_PROGRESS = "UPDATE_COMPLETE_CLEANUP_IN_PROGRESS"
    UPDATE_COMPLETE = "UPDATE_COMPLETE"
    UPDATE_FAILED = "UPDATE_FAILED"
    UPDATE_ROLLBACK_IN_PROGRESS = "UPDATE_ROLLBACK_IN_PROGRESS"
    UPDATE_ROLLBACK_FAILED = "UPDATE_ROLLBACK_FAILED"
    UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS = "UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS"
    UPDATE_ROLLBACK_COMPLETE = "UPDATE_ROLLBACK_COMPLETE"
    REVIEW_IN_PROGRESS = "REVIEW_IN_PROGRESS"
    IMPORT_IN_PROGRESS = "IMPORT_IN_PROGRESS"
    IMPORT_COMPLETE = "IMPORT_COMPLETE"
    IMPORT_ROLLBACK_IN_PROGRESS = "IMPORT_ROLLBACK_IN_PROGRESS"
    IMPORT_ROLLBACK_FAILED = "IMPORT_ROLLBACK_FAILED"
    IMPORT_ROLLBACK_COMPLETE = "IMPORT_ROLLBACK_COMPLETE"


class TemplateFormat:
    """TemplateFormat enum values."""

    JSON = "JSON"
    YAML = "YAML"


class TemplateStage:
    """TemplateStage enum values."""

    ORIGINAL = "Original"
    PROCESSED = "Processed"


class ThirdPartyType:
    """ThirdPartyType enum values."""

    RESOURCE = "RESOURCE"
    MODULE = "MODULE"
    HOOK = "HOOK"


class TypeTestsStatus:
    """TypeTestsStatus enum values."""

    PASSED = "PASSED"
    FAILED = "FAILED"
    IN_PROGRESS = "IN_PROGRESS"
    NOT_TESTED = "NOT_TESTED"


class ValidationStatus:
    """ValidationStatus enum values."""

    FAILED = "FAILED"
    SKIPPED = "SKIPPED"


class VersionBump:
    """VersionBump enum values."""

    MAJOR = "MAJOR"
    MINOR = "MINOR"


class Visibility:
    """Visibility enum values."""

    PUBLIC = "PUBLIC"
    PRIVATE = "PRIVATE"


class WarningType:
    """WarningType enum values."""

    MUTUALLY_EXCLUSIVE_PROPERTIES = "MUTUALLY_EXCLUSIVE_PROPERTIES"
    UNSUPPORTED_PROPERTIES = "UNSUPPORTED_PROPERTIES"
    MUTUALLY_EXCLUSIVE_TYPES = "MUTUALLY_EXCLUSIVE_TYPES"
    EXCLUDED_PROPERTIES = "EXCLUDED_PROPERTIES"
    EXCLUDED_RESOURCES = "EXCLUDED_RESOURCES"


# Convenient aliases for enum values
NONE = AccountFilterType.NONE
INTERSECTION = AccountFilterType.INTERSECTION
DIFFERENCE = AccountFilterType.DIFFERENCE
UNION = AccountFilterType.UNION
SUCCEEDED = AccountGateStatus.SUCCEEDED
FAILED = AccountGateStatus.FAILED
SKIPPED = AccountGateStatus.SKIPPED
TEMPLATE = AfterValueFrom.TEMPLATE
INFORMATIONAL = AnnotationSeverityLevel.INFORMATIONAL
LOW = AnnotationSeverityLevel.LOW
MEDIUM = AnnotationSeverityLevel.MEDIUM
HIGH = AnnotationSeverityLevel.HIGH
CRITICAL = AnnotationSeverityLevel.CRITICAL
PASSED = AnnotationStatus.PASSED
FAILED = AnnotationStatus.FAILED
SKIPPED = AnnotationStatus.SKIPPED
ADD = AttributeChangeType.ADD
REMOVE = AttributeChangeType.REMOVE
MODIFY = AttributeChangeType.MODIFY
SYNCWITHACTUAL = AttributeChangeType.SYNCWITHACTUAL
IN_PROGRESS = BeaconStackOperationStatus.IN_PROGRESS
SUCCEEDED = BeaconStackOperationStatus.SUCCEEDED
FAILED = BeaconStackOperationStatus.FAILED
PREVIOUS_DEPLOYMENT_STATE = BeforeValueFrom.PREVIOUS_DEPLOYMENT_STATE
ACTUAL_STATE = BeforeValueFrom.ACTUAL_STATE
SELF = CallAs.SELF
DELEGATED_ADMIN = CallAs.DELEGATED_ADMIN
CAPABILITY_IAM = Capability.CAPABILITY_IAM
CAPABILITY_NAMED_IAM = Capability.CAPABILITY_NAMED_IAM
CAPABILITY_AUTO_EXPAND = Capability.CAPABILITY_AUTO_EXPAND
REGISTERED = Category.REGISTERED
ACTIVATED = Category.ACTIVATED
THIRD_PARTY = Category.THIRD_PARTY
AWS_TYPES = Category.AWS_TYPES
ADD = ChangeAction.ADD
MODIFY = ChangeAction.MODIFY
REMOVE = ChangeAction.REMOVE
IMPORT = ChangeAction.IMPORT
DYNAMIC = ChangeAction.DYNAMIC
SYNCWITHACTUAL = ChangeAction.SYNCWITHACTUAL
PLANNING = ChangeSetHooksStatus.PLANNING
PLANNED = ChangeSetHooksStatus.PLANNED
UNAVAILABLE = ChangeSetHooksStatus.UNAVAILABLE
CREATE_PENDING = ChangeSetStatus.CREATE_PENDING
CREATE_IN_PROGRESS = ChangeSetStatus.CREATE_IN_PROGRESS
CREATE_COMPLETE = ChangeSetStatus.CREATE_COMPLETE
DELETE_PENDING = ChangeSetStatus.DELETE_PENDING
DELETE_IN_PROGRESS = ChangeSetStatus.DELETE_IN_PROGRESS
DELETE_COMPLETE = ChangeSetStatus.DELETE_COMPLETE
DELETE_FAILED = ChangeSetStatus.DELETE_FAILED
FAILED = ChangeSetStatus.FAILED
CREATE = ChangeSetType.CREATE
UPDATE = ChangeSetType.UPDATE
IMPORT = ChangeSetType.IMPORT
RESOURCEREFERENCE = ChangeSource.RESOURCEREFERENCE
PARAMETERREFERENCE = ChangeSource.PARAMETERREFERENCE
RESOURCEATTRIBUTE = ChangeSource.RESOURCEATTRIBUTE
DIRECTMODIFICATION = ChangeSource.DIRECTMODIFICATION
AUTOMATIC = ChangeSource.AUTOMATIC
NOMODIFICATION = ChangeSource.NOMODIFICATION
RESOURCE = ChangeType.RESOURCE
STRICT_FAILURE_TOLERANCE = ConcurrencyMode.STRICT_FAILURE_TOLERANCE
SOFT_FAILURE_TOLERANCE = ConcurrencyMode.SOFT_FAILURE_TOLERANCE
STANDARD = DeletionMode.STANDARD
FORCE_DELETE_STACK = DeletionMode.FORCE_DELETE_STACK
REVERT_DRIFT = DeploymentMode.REVERT_DRIFT
LIVE = DeprecatedStatus.LIVE
DEPRECATED = DeprecatedStatus.DEPRECATED
CONFIGURATION_COMPLETE = DetailedStatus.CONFIGURATION_COMPLETE
VALIDATION_FAILED = DetailedStatus.VALIDATION_FAILED
ADD = DifferenceType.ADD
REMOVE = DifferenceType.REMOVE
NOT_EQUAL = DifferenceType.NOT_EQUAL
MANAGED_BY_AWS = DriftIgnoredReason.MANAGED_BY_AWS
WRITE_ONLY_PROPERTY = DriftIgnoredReason.WRITE_ONLY_PROPERTY
STATIC = EvaluationType.STATIC
DYNAMIC = EvaluationType.DYNAMIC
STACK_EVENT = EventType.STACK_EVENT
PROGRESS_EVENT = EventType.PROGRESS_EVENT
VALIDATION_ERROR = EventType.VALIDATION_ERROR
PROVISIONING_ERROR = EventType.PROVISIONING_ERROR
HOOK_INVOCATION_ERROR = EventType.HOOK_INVOCATION_ERROR
UNAVAILABLE = ExecutionStatus.UNAVAILABLE
AVAILABLE = ExecutionStatus.AVAILABLE
EXECUTE_IN_PROGRESS = ExecutionStatus.EXECUTE_IN_PROGRESS
EXECUTE_COMPLETE = ExecutionStatus.EXECUTE_COMPLETE
EXECUTE_FAILED = ExecutionStatus.EXECUTE_FAILED
OBSOLETE = ExecutionStatus.OBSOLETE
DELETE = GeneratedTemplateDeletionPolicy.DELETE
RETAIN = GeneratedTemplateDeletionPolicy.RETAIN
PENDING = GeneratedTemplateResourceStatus.PENDING
IN_PROGRESS = GeneratedTemplateResourceStatus.IN_PROGRESS
FAILED = GeneratedTemplateResourceStatus.FAILED
COMPLETE = GeneratedTemplateResourceStatus.COMPLETE
CREATE_PENDING = GeneratedTemplateStatus.CREATE_PENDING
UPDATE_PENDING = GeneratedTemplateStatus.UPDATE_PENDING
DELETE_PENDING = GeneratedTemplateStatus.DELETE_PENDING
CREATE_IN_PROGRESS = GeneratedTemplateStatus.CREATE_IN_PROGRESS
UPDATE_IN_PROGRESS = GeneratedTemplateStatus.UPDATE_IN_PROGRESS
DELETE_IN_PROGRESS = GeneratedTemplateStatus.DELETE_IN_PROGRESS
FAILED = GeneratedTemplateStatus.FAILED
COMPLETE = GeneratedTemplateStatus.COMPLETE
DELETE = GeneratedTemplateUpdateReplacePolicy.DELETE
RETAIN = GeneratedTemplateUpdateReplacePolicy.RETAIN
NOTUPDATABLE = HandlerErrorCode.NOTUPDATABLE
INVALIDREQUEST = HandlerErrorCode.INVALIDREQUEST
ACCESSDENIED = HandlerErrorCode.ACCESSDENIED
INVALIDCREDENTIALS = HandlerErrorCode.INVALIDCREDENTIALS
ALREADYEXISTS = HandlerErrorCode.ALREADYEXISTS
NOTFOUND = HandlerErrorCode.NOTFOUND
RESOURCECONFLICT = HandlerErrorCode.RESOURCECONFLICT
THROTTLING = HandlerErrorCode.THROTTLING
SERVICELIMITEXCEEDED = HandlerErrorCode.SERVICELIMITEXCEEDED
NOTSTABILIZED = HandlerErrorCode.NOTSTABILIZED
GENERALSERVICEEXCEPTION = HandlerErrorCode.GENERALSERVICEEXCEPTION
SERVICEINTERNALERROR = HandlerErrorCode.SERVICEINTERNALERROR
NETWORKFAILURE = HandlerErrorCode.NETWORKFAILURE
INTERNALFAILURE = HandlerErrorCode.INTERNALFAILURE
INVALIDTYPECONFIGURATION = HandlerErrorCode.INVALIDTYPECONFIGURATION
HANDLERINTERNALFAILURE = HandlerErrorCode.HANDLERINTERNALFAILURE
NONCOMPLIANT = HandlerErrorCode.NONCOMPLIANT
UNKNOWN = HandlerErrorCode.UNKNOWN
UNSUPPORTEDTARGET = HandlerErrorCode.UNSUPPORTEDTARGET
FAIL = HookFailureMode.FAIL
WARN = HookFailureMode.WARN
PRE_PROVISION = HookInvocationPoint.PRE_PROVISION
HOOK_IN_PROGRESS = HookStatus.HOOK_IN_PROGRESS
HOOK_COMPLETE_SUCCEEDED = HookStatus.HOOK_COMPLETE_SUCCEEDED
HOOK_COMPLETE_FAILED = HookStatus.HOOK_COMPLETE_FAILED
HOOK_FAILED = HookStatus.HOOK_FAILED
CREATE = HookTargetAction.CREATE
UPDATE = HookTargetAction.UPDATE
DELETE = HookTargetAction.DELETE
IMPORT = HookTargetAction.IMPORT
RESOURCE = HookTargetType.RESOURCE
AWS_MARKETPLACE = IdentityProvider.AWS_MARKETPLACE
GITHUB = IdentityProvider.GITHUB
BITBUCKET = IdentityProvider.BITBUCKET
CHANGE_SET = ListHookResultsTargetType.CHANGE_SET
STACK = ListHookResultsTargetType.STACK
RESOURCE = ListHookResultsTargetType.RESOURCE
CLOUD_CONTROL = ListHookResultsTargetType.CLOUD_CONTROL
DO_NOTHING = OnFailure.DO_NOTHING
ROLLBACK = OnFailure.ROLLBACK
DELETE = OnFailure.DELETE
DO_NOTHING = OnStackFailure.DO_NOTHING
ROLLBACK = OnStackFailure.ROLLBACK
DELETE = OnStackFailure.DELETE
OPERATION_RESULT_STATUS = OperationResultFilterName.OPERATION_RESULT_STATUS
PENDING = OperationStatus.PENDING
IN_PROGRESS = OperationStatus.IN_PROGRESS
SUCCESS = OperationStatus.SUCCESS
FAILED = OperationStatus.FAILED
CREATE_STACK = OperationType.CREATE_STACK
UPDATE_STACK = OperationType.UPDATE_STACK
DELETE_STACK = OperationType.DELETE_STACK
CONTINUE_ROLLBACK = OperationType.CONTINUE_ROLLBACK
ROLLBACK = OperationType.ROLLBACK
CREATE_CHANGESET = OperationType.CREATE_CHANGESET
ENABLED = OrganizationStatus.ENABLED
DISABLED = OrganizationStatus.DISABLED
DISABLED_PERMANENTLY = OrganizationStatus.DISABLED_PERMANENTLY
SERVICE_MANAGED = PermissionModels.SERVICE_MANAGED
SELF_MANAGED = PermissionModels.SELF_MANAGED
DELETE = PolicyAction.DELETE
RETAIN = PolicyAction.RETAIN
SNAPSHOT = PolicyAction.SNAPSHOT
REPLACEANDDELETE = PolicyAction.REPLACEANDDELETE
REPLACEANDRETAIN = PolicyAction.REPLACEANDRETAIN
REPLACEANDSNAPSHOT = PolicyAction.REPLACEANDSNAPSHOT
NON_PROVISIONABLE = ProvisioningType.NON_PROVISIONABLE
IMMUTABLE = ProvisioningType.IMMUTABLE
FULLY_MUTABLE = ProvisioningType.FULLY_MUTABLE
VERIFIED = PublisherStatus.VERIFIED
UNVERIFIED = PublisherStatus.UNVERIFIED
SEQUENTIAL = RegionConcurrencyType.SEQUENTIAL
PARALLEL = RegionConcurrencyType.PARALLEL
COMPLETE = RegistrationStatus.COMPLETE
IN_PROGRESS = RegistrationStatus.IN_PROGRESS
FAILED = RegistrationStatus.FAILED
RESOURCE = RegistryType.RESOURCE
MODULE = RegistryType.MODULE
HOOK = RegistryType.HOOK
TRUE = Replacement.TRUE
FALSE = Replacement.FALSE
CONDITIONAL = Replacement.CONDITIONAL
NEVER = RequiresRecreation.NEVER
CONDITIONALLY = RequiresRecreation.CONDITIONALLY
ALWAYS = RequiresRecreation.ALWAYS
PROPERTIES = ResourceAttribute.PROPERTIES
METADATA = ResourceAttribute.METADATA
CREATIONPOLICY = ResourceAttribute.CREATIONPOLICY
UPDATEPOLICY = ResourceAttribute.UPDATEPOLICY
DELETIONPOLICY = ResourceAttribute.DELETIONPOLICY
UPDATEREPLACEPOLICY = ResourceAttribute.UPDATEREPLACEPOLICY
TAGS = ResourceAttribute.TAGS
IN_PROGRESS = ResourceScanStatus.IN_PROGRESS
FAILED = ResourceScanStatus.FAILED
COMPLETE = ResourceScanStatus.COMPLETE
EXPIRED = ResourceScanStatus.EXPIRED
SUCCESS = ResourceSignalStatus.SUCCESS
FAILURE = ResourceSignalStatus.FAILURE
CREATE_IN_PROGRESS = ResourceStatus.CREATE_IN_PROGRESS
CREATE_FAILED = ResourceStatus.CREATE_FAILED
CREATE_COMPLETE = ResourceStatus.CREATE_COMPLETE
DELETE_IN_PROGRESS = ResourceStatus.DELETE_IN_PROGRESS
DELETE_FAILED = ResourceStatus.DELETE_FAILED
DELETE_COMPLETE = ResourceStatus.DELETE_COMPLETE
DELETE_SKIPPED = ResourceStatus.DELETE_SKIPPED
UPDATE_IN_PROGRESS = ResourceStatus.UPDATE_IN_PROGRESS
UPDATE_FAILED = ResourceStatus.UPDATE_FAILED
UPDATE_COMPLETE = ResourceStatus.UPDATE_COMPLETE
IMPORT_FAILED = ResourceStatus.IMPORT_FAILED
IMPORT_COMPLETE = ResourceStatus.IMPORT_COMPLETE
IMPORT_IN_PROGRESS = ResourceStatus.IMPORT_IN_PROGRESS
IMPORT_ROLLBACK_IN_PROGRESS = ResourceStatus.IMPORT_ROLLBACK_IN_PROGRESS
IMPORT_ROLLBACK_FAILED = ResourceStatus.IMPORT_ROLLBACK_FAILED
IMPORT_ROLLBACK_COMPLETE = ResourceStatus.IMPORT_ROLLBACK_COMPLETE
EXPORT_FAILED = ResourceStatus.EXPORT_FAILED
EXPORT_COMPLETE = ResourceStatus.EXPORT_COMPLETE
EXPORT_IN_PROGRESS = ResourceStatus.EXPORT_IN_PROGRESS
EXPORT_ROLLBACK_IN_PROGRESS = ResourceStatus.EXPORT_ROLLBACK_IN_PROGRESS
EXPORT_ROLLBACK_FAILED = ResourceStatus.EXPORT_ROLLBACK_FAILED
EXPORT_ROLLBACK_COMPLETE = ResourceStatus.EXPORT_ROLLBACK_COMPLETE
UPDATE_ROLLBACK_IN_PROGRESS = ResourceStatus.UPDATE_ROLLBACK_IN_PROGRESS
UPDATE_ROLLBACK_COMPLETE = ResourceStatus.UPDATE_ROLLBACK_COMPLETE
UPDATE_ROLLBACK_FAILED = ResourceStatus.UPDATE_ROLLBACK_FAILED
ROLLBACK_IN_PROGRESS = ResourceStatus.ROLLBACK_IN_PROGRESS
ROLLBACK_COMPLETE = ResourceStatus.ROLLBACK_COMPLETE
ROLLBACK_FAILED = ResourceStatus.ROLLBACK_FAILED
FULL = ScanType.FULL
PARTIAL = ScanType.PARTIAL
DETECTION_IN_PROGRESS = StackDriftDetectionStatus.DETECTION_IN_PROGRESS
DETECTION_FAILED = StackDriftDetectionStatus.DETECTION_FAILED
DETECTION_COMPLETE = StackDriftDetectionStatus.DETECTION_COMPLETE
DRIFTED = StackDriftStatus.DRIFTED
IN_SYNC = StackDriftStatus.IN_SYNC
UNKNOWN = StackDriftStatus.UNKNOWN
NOT_CHECKED = StackDriftStatus.NOT_CHECKED
PENDING = StackInstanceDetailedStatus.PENDING
RUNNING = StackInstanceDetailedStatus.RUNNING
SUCCEEDED = StackInstanceDetailedStatus.SUCCEEDED
FAILED = StackInstanceDetailedStatus.FAILED
CANCELLED = StackInstanceDetailedStatus.CANCELLED
INOPERABLE = StackInstanceDetailedStatus.INOPERABLE
SKIPPED_SUSPENDED_ACCOUNT = StackInstanceDetailedStatus.SKIPPED_SUSPENDED_ACCOUNT
FAILED_IMPORT = StackInstanceDetailedStatus.FAILED_IMPORT
DETAILED_STATUS = StackInstanceFilterName.DETAILED_STATUS
LAST_OPERATION_ID = StackInstanceFilterName.LAST_OPERATION_ID
DRIFT_STATUS = StackInstanceFilterName.DRIFT_STATUS
CURRENT = StackInstanceStatus.CURRENT
OUTDATED = StackInstanceStatus.OUTDATED
INOPERABLE = StackInstanceStatus.INOPERABLE
RESOURCE = StackRefactorActionEntity.RESOURCE
STACK = StackRefactorActionEntity.STACK
MOVE = StackRefactorActionType.MOVE
CREATE = StackRefactorActionType.CREATE
AUTO = StackRefactorDetection.AUTO
MANUAL = StackRefactorDetection.MANUAL
UNAVAILABLE = StackRefactorExecutionStatus.UNAVAILABLE
AVAILABLE = StackRefactorExecutionStatus.AVAILABLE
OBSOLETE = StackRefactorExecutionStatus.OBSOLETE
EXECUTE_IN_PROGRESS = StackRefactorExecutionStatus.EXECUTE_IN_PROGRESS
EXECUTE_COMPLETE = StackRefactorExecutionStatus.EXECUTE_COMPLETE
EXECUTE_FAILED = StackRefactorExecutionStatus.EXECUTE_FAILED
ROLLBACK_IN_PROGRESS = StackRefactorExecutionStatus.ROLLBACK_IN_PROGRESS
ROLLBACK_COMPLETE = StackRefactorExecutionStatus.ROLLBACK_COMPLETE
ROLLBACK_FAILED = StackRefactorExecutionStatus.ROLLBACK_FAILED
CREATE_IN_PROGRESS = StackRefactorStatus.CREATE_IN_PROGRESS
CREATE_COMPLETE = StackRefactorStatus.CREATE_COMPLETE
CREATE_FAILED = StackRefactorStatus.CREATE_FAILED
DELETE_IN_PROGRESS = StackRefactorStatus.DELETE_IN_PROGRESS
DELETE_COMPLETE = StackRefactorStatus.DELETE_COMPLETE
DELETE_FAILED = StackRefactorStatus.DELETE_FAILED
IN_SYNC = StackResourceDriftStatus.IN_SYNC
MODIFIED = StackResourceDriftStatus.MODIFIED
DELETED = StackResourceDriftStatus.DELETED
NOT_CHECKED = StackResourceDriftStatus.NOT_CHECKED
UNKNOWN = StackResourceDriftStatus.UNKNOWN
UNSUPPORTED = StackResourceDriftStatus.UNSUPPORTED
COMPLETED = StackSetDriftDetectionStatus.COMPLETED
FAILED = StackSetDriftDetectionStatus.FAILED
PARTIAL_SUCCESS = StackSetDriftDetectionStatus.PARTIAL_SUCCESS
IN_PROGRESS = StackSetDriftDetectionStatus.IN_PROGRESS
STOPPED = StackSetDriftDetectionStatus.STOPPED
DRIFTED = StackSetDriftStatus.DRIFTED
IN_SYNC = StackSetDriftStatus.IN_SYNC
NOT_CHECKED = StackSetDriftStatus.NOT_CHECKED
CREATE = StackSetOperationAction.CREATE
UPDATE = StackSetOperationAction.UPDATE
DELETE = StackSetOperationAction.DELETE
DETECT_DRIFT = StackSetOperationAction.DETECT_DRIFT
PENDING = StackSetOperationResultStatus.PENDING
RUNNING = StackSetOperationResultStatus.RUNNING
SUCCEEDED = StackSetOperationResultStatus.SUCCEEDED
FAILED = StackSetOperationResultStatus.FAILED
CANCELLED = StackSetOperationResultStatus.CANCELLED
RUNNING = StackSetOperationStatus.RUNNING
SUCCEEDED = StackSetOperationStatus.SUCCEEDED
FAILED = StackSetOperationStatus.FAILED
STOPPING = StackSetOperationStatus.STOPPING
STOPPED = StackSetOperationStatus.STOPPED
QUEUED = StackSetOperationStatus.QUEUED
ACTIVE = StackSetStatus.ACTIVE
DELETED = StackSetStatus.DELETED
CREATE_IN_PROGRESS = StackStatus.CREATE_IN_PROGRESS
CREATE_FAILED = StackStatus.CREATE_FAILED
CREATE_COMPLETE = StackStatus.CREATE_COMPLETE
ROLLBACK_IN_PROGRESS = StackStatus.ROLLBACK_IN_PROGRESS
ROLLBACK_FAILED = StackStatus.ROLLBACK_FAILED
ROLLBACK_COMPLETE = StackStatus.ROLLBACK_COMPLETE
DELETE_IN_PROGRESS = StackStatus.DELETE_IN_PROGRESS
DELETE_FAILED = StackStatus.DELETE_FAILED
DELETE_COMPLETE = StackStatus.DELETE_COMPLETE
UPDATE_IN_PROGRESS = StackStatus.UPDATE_IN_PROGRESS
UPDATE_COMPLETE_CLEANUP_IN_PROGRESS = StackStatus.UPDATE_COMPLETE_CLEANUP_IN_PROGRESS
UPDATE_COMPLETE = StackStatus.UPDATE_COMPLETE
UPDATE_FAILED = StackStatus.UPDATE_FAILED
UPDATE_ROLLBACK_IN_PROGRESS = StackStatus.UPDATE_ROLLBACK_IN_PROGRESS
UPDATE_ROLLBACK_FAILED = StackStatus.UPDATE_ROLLBACK_FAILED
UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS = StackStatus.UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS
UPDATE_ROLLBACK_COMPLETE = StackStatus.UPDATE_ROLLBACK_COMPLETE
REVIEW_IN_PROGRESS = StackStatus.REVIEW_IN_PROGRESS
IMPORT_IN_PROGRESS = StackStatus.IMPORT_IN_PROGRESS
IMPORT_COMPLETE = StackStatus.IMPORT_COMPLETE
IMPORT_ROLLBACK_IN_PROGRESS = StackStatus.IMPORT_ROLLBACK_IN_PROGRESS
IMPORT_ROLLBACK_FAILED = StackStatus.IMPORT_ROLLBACK_FAILED
IMPORT_ROLLBACK_COMPLETE = StackStatus.IMPORT_ROLLBACK_COMPLETE
JSON = TemplateFormat.JSON
YAML = TemplateFormat.YAML
ORIGINAL = TemplateStage.ORIGINAL
PROCESSED = TemplateStage.PROCESSED
RESOURCE = ThirdPartyType.RESOURCE
MODULE = ThirdPartyType.MODULE
HOOK = ThirdPartyType.HOOK
PASSED = TypeTestsStatus.PASSED
FAILED = TypeTestsStatus.FAILED
IN_PROGRESS = TypeTestsStatus.IN_PROGRESS
NOT_TESTED = TypeTestsStatus.NOT_TESTED
FAILED = ValidationStatus.FAILED
SKIPPED = ValidationStatus.SKIPPED
MAJOR = VersionBump.MAJOR
MINOR = VersionBump.MINOR
PUBLIC = Visibility.PUBLIC
PRIVATE = Visibility.PRIVATE
MUTUALLY_EXCLUSIVE_PROPERTIES = WarningType.MUTUALLY_EXCLUSIVE_PROPERTIES
UNSUPPORTED_PROPERTIES = WarningType.UNSUPPORTED_PROPERTIES
MUTUALLY_EXCLUSIVE_TYPES = WarningType.MUTUALLY_EXCLUSIVE_TYPES
EXCLUDED_PROPERTIES = WarningType.EXCLUDED_PROPERTIES
EXCLUDED_RESOURCES = WarningType.EXCLUDED_RESOURCES


@dataclass
class CustomResource(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cfn-c"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::CustomResource"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_token: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.service_timeout is not None:
            # Serialize service_timeout (handle intrinsic functions)
            if hasattr(self.service_timeout, 'to_dict'):
                props["ServiceTimeout"] = self.service_timeout.to_dict()
            elif isinstance(self.service_timeout, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_timeout
                ]
            else:
                props["ServiceTimeout"] = self.service_timeout

        if self.service_token is not None:
            # Serialize service_token (handle intrinsic functions)
            if hasattr(self.service_token, 'to_dict'):
                props["ServiceToken"] = self.service_token.to_dict()
            elif isinstance(self.service_token, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceToken'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_token
                ]
            else:
                props["ServiceToken"] = self.service_token

        return props



@dataclass
class HookTarget:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    invocation_point: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    action: Optional[Union[str, HookTargetAction, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.invocation_point is not None:
            if hasattr(self.invocation_point, 'to_dict'):
                props['InvocationPoint'] = self.invocation_point.to_dict()
            elif isinstance(self.invocation_point, list):
                props['InvocationPoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.invocation_point
                ]
            else:
                props['InvocationPoint'] = self.invocation_point

        if self.action is not None:
            if hasattr(self.action, 'to_dict'):
                props['Action'] = self.action.to_dict()
            elif isinstance(self.action, list):
                props['Action'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.action
                ]
            else:
                props['Action'] = self.action

        if self.target_name is not None:
            if hasattr(self.target_name, 'to_dict'):
                props['TargetName'] = self.target_name.to_dict()
            elif isinstance(self.target_name, list):
                props['TargetName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_name
                ]
            else:
                props['TargetName'] = self.target_name

        return props


@dataclass
class Options:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    input_params: Optional[S3Location] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.input_params is not None:
            if hasattr(self.input_params, 'to_dict'):
                props['InputParams'] = self.input_params.to_dict()
            elif isinstance(self.input_params, list):
                props['InputParams'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.input_params
                ]
            else:
                props['InputParams'] = self.input_params

        return props


@dataclass
class S3Location:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.version_id is not None:
            if hasattr(self.version_id, 'to_dict'):
                props['VersionId'] = self.version_id.to_dict()
            elif isinstance(self.version_id, list):
                props['VersionId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version_id
                ]
            else:
                props['VersionId'] = self.version_id

        if self.uri is not None:
            if hasattr(self.uri, 'to_dict'):
                props['Uri'] = self.uri.to_dict()
            elif isinstance(self.uri, list):
                props['Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.uri
                ]
            else:
                props['Uri'] = self.uri

        return props


@dataclass
class StackFilters:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    filtering_criteria: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    stack_names: Optional[StackNames] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    stack_roles: Optional[StackRoles] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.filtering_criteria is not None:
            if hasattr(self.filtering_criteria, 'to_dict'):
                props['FilteringCriteria'] = self.filtering_criteria.to_dict()
            elif isinstance(self.filtering_criteria, list):
                props['FilteringCriteria'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filtering_criteria
                ]
            else:
                props['FilteringCriteria'] = self.filtering_criteria

        if self.stack_names is not None:
            if hasattr(self.stack_names, 'to_dict'):
                props['StackNames'] = self.stack_names.to_dict()
            elif isinstance(self.stack_names, list):
                props['StackNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stack_names
                ]
            else:
                props['StackNames'] = self.stack_names

        if self.stack_roles is not None:
            if hasattr(self.stack_roles, 'to_dict'):
                props['StackRoles'] = self.stack_roles.to_dict()
            elif isinstance(self.stack_roles, list):
                props['StackRoles'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stack_roles
                ]
            else:
                props['StackRoles'] = self.stack_roles

        return props


@dataclass
class StackNames:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    exclude: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    include: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.exclude is not None:
            if hasattr(self.exclude, 'to_dict'):
                props['Exclude'] = self.exclude.to_dict()
            elif isinstance(self.exclude, list):
                props['Exclude'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.exclude
                ]
            else:
                props['Exclude'] = self.exclude

        if self.include is not None:
            if hasattr(self.include, 'to_dict'):
                props['Include'] = self.include.to_dict()
            elif isinstance(self.include, list):
                props['Include'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.include
                ]
            else:
                props['Include'] = self.include

        return props


@dataclass
class StackRoles:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    exclude: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    include: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.exclude is not None:
            if hasattr(self.exclude, 'to_dict'):
                props['Exclude'] = self.exclude.to_dict()
            elif isinstance(self.exclude, list):
                props['Exclude'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.exclude
                ]
            else:
                props['Exclude'] = self.exclude

        if self.include is not None:
            if hasattr(self.include, 'to_dict'):
                props['Include'] = self.include.to_dict()
            elif isinstance(self.include, list):
                props['Include'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.include
                ]
            else:
                props['Include'] = self.include

        return props


@dataclass
class TargetFilters:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    actions: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    targets: Optional[list[HookTarget]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    invocation_points: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.actions is not None:
            if hasattr(self.actions, 'to_dict'):
                props['Actions'] = self.actions.to_dict()
            elif isinstance(self.actions, list):
                props['Actions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.actions
                ]
            else:
                props['Actions'] = self.actions

        if self.target_names is not None:
            if hasattr(self.target_names, 'to_dict'):
                props['TargetNames'] = self.target_names.to_dict()
            elif isinstance(self.target_names, list):
                props['TargetNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_names
                ]
            else:
                props['TargetNames'] = self.target_names

        if self.targets is not None:
            if hasattr(self.targets, 'to_dict'):
                props['Targets'] = self.targets.to_dict()
            elif isinstance(self.targets, list):
                props['Targets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.targets
                ]
            else:
                props['Targets'] = self.targets

        if self.invocation_points is not None:
            if hasattr(self.invocation_points, 'to_dict'):
                props['InvocationPoints'] = self.invocation_points.to_dict()
            elif isinstance(self.invocation_points, list):
                props['InvocationPoints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.invocation_points
                ]
            else:
                props['InvocationPoints'] = self.invocation_points

        return props


@dataclass
class GuardHook(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::GuardHook"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    options: Optional[Options] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rule_location: Optional[S3Location] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    hook_status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    alias: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    stack_filters: Optional[StackFilters] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_operations: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_filters: Optional[TargetFilters] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    execution_role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    failure_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.options is not None:
            # Serialize options (handle intrinsic functions)
            if hasattr(self.options, 'to_dict'):
                props["Options"] = self.options.to_dict()
            elif isinstance(self.options, list):
                # Serialize list items (may contain intrinsic functions)
                props['Options'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.options
                ]
            else:
                props["Options"] = self.options

        if self.rule_location is not None:
            # Serialize rule_location (handle intrinsic functions)
            if hasattr(self.rule_location, 'to_dict'):
                props["RuleLocation"] = self.rule_location.to_dict()
            elif isinstance(self.rule_location, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuleLocation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_location
                ]
            else:
                props["RuleLocation"] = self.rule_location

        if self.hook_status is not None:
            # Serialize hook_status (handle intrinsic functions)
            if hasattr(self.hook_status, 'to_dict'):
                props["HookStatus"] = self.hook_status.to_dict()
            elif isinstance(self.hook_status, list):
                # Serialize list items (may contain intrinsic functions)
                props['HookStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hook_status
                ]
            else:
                props["HookStatus"] = self.hook_status

        if self.alias is not None:
            # Serialize alias (handle intrinsic functions)
            if hasattr(self.alias, 'to_dict'):
                props["Alias"] = self.alias.to_dict()
            elif isinstance(self.alias, list):
                # Serialize list items (may contain intrinsic functions)
                props['Alias'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.alias
                ]
            else:
                props["Alias"] = self.alias

        if self.stack_filters is not None:
            # Serialize stack_filters (handle intrinsic functions)
            if hasattr(self.stack_filters, 'to_dict'):
                props["StackFilters"] = self.stack_filters.to_dict()
            elif isinstance(self.stack_filters, list):
                # Serialize list items (may contain intrinsic functions)
                props['StackFilters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stack_filters
                ]
            else:
                props["StackFilters"] = self.stack_filters

        if self.target_operations is not None:
            # Serialize target_operations (handle intrinsic functions)
            if hasattr(self.target_operations, 'to_dict'):
                props["TargetOperations"] = self.target_operations.to_dict()
            elif isinstance(self.target_operations, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetOperations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_operations
                ]
            else:
                props["TargetOperations"] = self.target_operations

        if self.target_filters is not None:
            # Serialize target_filters (handle intrinsic functions)
            if hasattr(self.target_filters, 'to_dict'):
                props["TargetFilters"] = self.target_filters.to_dict()
            elif isinstance(self.target_filters, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetFilters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_filters
                ]
            else:
                props["TargetFilters"] = self.target_filters

        if self.log_bucket is not None:
            # Serialize log_bucket (handle intrinsic functions)
            if hasattr(self.log_bucket, 'to_dict'):
                props["LogBucket"] = self.log_bucket.to_dict()
            elif isinstance(self.log_bucket, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogBucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_bucket
                ]
            else:
                props["LogBucket"] = self.log_bucket

        if self.execution_role is not None:
            # Serialize execution_role (handle intrinsic functions)
            if hasattr(self.execution_role, 'to_dict'):
                props["ExecutionRole"] = self.execution_role.to_dict()
            elif isinstance(self.execution_role, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExecutionRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role
                ]
            else:
                props["ExecutionRole"] = self.execution_role

        if self.failure_mode is not None:
            # Serialize failure_mode (handle intrinsic functions)
            if hasattr(self.failure_mode, 'to_dict'):
                props["FailureMode"] = self.failure_mode.to_dict()
            elif isinstance(self.failure_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['FailureMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.failure_mode
                ]
            else:
                props["FailureMode"] = self.failure_mode

        return props

    @property
    def attr_hook_arn(self) -> GetAtt:
        """Get the HookArn attribute."""
        return self.get_att("HookArn")




@dataclass
class HookDefaultVersion(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::HookDefaultVersion"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    version_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_version_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.version_id is not None:
            # Serialize version_id (handle intrinsic functions)
            if hasattr(self.version_id, 'to_dict'):
                props["VersionId"] = self.version_id.to_dict()
            elif isinstance(self.version_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VersionId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version_id
                ]
            else:
                props["VersionId"] = self.version_id

        if self.type_name is not None:
            # Serialize type_name (handle intrinsic functions)
            if hasattr(self.type_name, 'to_dict'):
                props["TypeName"] = self.type_name.to_dict()
            elif isinstance(self.type_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['TypeName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_name
                ]
            else:
                props["TypeName"] = self.type_name

        if self.type_version_arn is not None:
            # Serialize type_version_arn (handle intrinsic functions)
            if hasattr(self.type_version_arn, 'to_dict'):
                props["TypeVersionArn"] = self.type_version_arn.to_dict()
            elif isinstance(self.type_version_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['TypeVersionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_version_arn
                ]
            else:
                props["TypeVersionArn"] = self.type_version_arn

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class HookTypeConfig(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::HookTypeConfig"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    configuration: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    configuration_alias: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_name is not None:
            # Serialize type_name (handle intrinsic functions)
            if hasattr(self.type_name, 'to_dict'):
                props["TypeName"] = self.type_name.to_dict()
            elif isinstance(self.type_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['TypeName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_name
                ]
            else:
                props["TypeName"] = self.type_name

        if self.configuration is not None:
            # Serialize configuration (handle intrinsic functions)
            if hasattr(self.configuration, 'to_dict'):
                props["Configuration"] = self.configuration.to_dict()
            elif isinstance(self.configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['Configuration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.configuration
                ]
            else:
                props["Configuration"] = self.configuration

        if self.type_arn is not None:
            # Serialize type_arn (handle intrinsic functions)
            if hasattr(self.type_arn, 'to_dict'):
                props["TypeArn"] = self.type_arn.to_dict()
            elif isinstance(self.type_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['TypeArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_arn
                ]
            else:
                props["TypeArn"] = self.type_arn

        if self.configuration_alias is not None:
            # Serialize configuration_alias (handle intrinsic functions)
            if hasattr(self.configuration_alias, 'to_dict'):
                props["ConfigurationAlias"] = self.configuration_alias.to_dict()
            elif isinstance(self.configuration_alias, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConfigurationAlias'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.configuration_alias
                ]
            else:
                props["ConfigurationAlias"] = self.configuration_alias

        return props

    @property
    def attr_configuration_arn(self) -> GetAtt:
        """Get the ConfigurationArn attribute."""
        return self.get_att("ConfigurationArn")




@dataclass
class LoggingConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.log_group_name is not None:
            if hasattr(self.log_group_name, 'to_dict'):
                props['LogGroupName'] = self.log_group_name.to_dict()
            elif isinstance(self.log_group_name, list):
                props['LogGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_name
                ]
            else:
                props['LogGroupName'] = self.log_group_name

        if self.log_role_arn is not None:
            if hasattr(self.log_role_arn, 'to_dict'):
                props['LogRoleArn'] = self.log_role_arn.to_dict()
            elif isinstance(self.log_role_arn, list):
                props['LogRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_role_arn
                ]
            else:
                props['LogRoleArn'] = self.log_role_arn

        return props


@dataclass
class HookVersion(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::HookVersion"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    execution_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    logging_config: Optional[LoggingConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    schema_handler_package: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.execution_role_arn is not None:
            # Serialize execution_role_arn (handle intrinsic functions)
            if hasattr(self.execution_role_arn, 'to_dict'):
                props["ExecutionRoleArn"] = self.execution_role_arn.to_dict()
            elif isinstance(self.execution_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExecutionRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role_arn
                ]
            else:
                props["ExecutionRoleArn"] = self.execution_role_arn

        if self.type_name is not None:
            # Serialize type_name (handle intrinsic functions)
            if hasattr(self.type_name, 'to_dict'):
                props["TypeName"] = self.type_name.to_dict()
            elif isinstance(self.type_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['TypeName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_name
                ]
            else:
                props["TypeName"] = self.type_name

        if self.logging_config is not None:
            # Serialize logging_config (handle intrinsic functions)
            if hasattr(self.logging_config, 'to_dict'):
                props["LoggingConfig"] = self.logging_config.to_dict()
            elif isinstance(self.logging_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['LoggingConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.logging_config
                ]
            else:
                props["LoggingConfig"] = self.logging_config

        if self.schema_handler_package is not None:
            # Serialize schema_handler_package (handle intrinsic functions)
            if hasattr(self.schema_handler_package, 'to_dict'):
                props["SchemaHandlerPackage"] = self.schema_handler_package.to_dict()
            elif isinstance(self.schema_handler_package, list):
                # Serialize list items (may contain intrinsic functions)
                props['SchemaHandlerPackage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schema_handler_package
                ]
            else:
                props["SchemaHandlerPackage"] = self.schema_handler_package

        return props

    @property
    def attr_version_id(self) -> GetAtt:
        """Get the VersionId attribute."""
        return self.get_att("VersionId")

    @property
    def attr_is_default_version(self) -> GetAtt:
        """Get the IsDefaultVersion attribute."""
        return self.get_att("IsDefaultVersion")

    @property
    def attr_visibility(self) -> GetAtt:
        """Get the Visibility attribute."""
        return self.get_att("Visibility")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_type_arn(self) -> GetAtt:
        """Get the TypeArn attribute."""
        return self.get_att("TypeArn")




@dataclass
class HookTarget:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    invocation_point: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    action: Optional[Union[str, HookTargetAction, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.invocation_point is not None:
            if hasattr(self.invocation_point, 'to_dict'):
                props['InvocationPoint'] = self.invocation_point.to_dict()
            elif isinstance(self.invocation_point, list):
                props['InvocationPoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.invocation_point
                ]
            else:
                props['InvocationPoint'] = self.invocation_point

        if self.action is not None:
            if hasattr(self.action, 'to_dict'):
                props['Action'] = self.action.to_dict()
            elif isinstance(self.action, list):
                props['Action'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.action
                ]
            else:
                props['Action'] = self.action

        if self.target_name is not None:
            if hasattr(self.target_name, 'to_dict'):
                props['TargetName'] = self.target_name.to_dict()
            elif isinstance(self.target_name, list):
                props['TargetName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_name
                ]
            else:
                props['TargetName'] = self.target_name

        return props


@dataclass
class StackFilters:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    filtering_criteria: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    stack_names: Optional[StackNames] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    stack_roles: Optional[StackRoles] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.filtering_criteria is not None:
            if hasattr(self.filtering_criteria, 'to_dict'):
                props['FilteringCriteria'] = self.filtering_criteria.to_dict()
            elif isinstance(self.filtering_criteria, list):
                props['FilteringCriteria'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filtering_criteria
                ]
            else:
                props['FilteringCriteria'] = self.filtering_criteria

        if self.stack_names is not None:
            if hasattr(self.stack_names, 'to_dict'):
                props['StackNames'] = self.stack_names.to_dict()
            elif isinstance(self.stack_names, list):
                props['StackNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stack_names
                ]
            else:
                props['StackNames'] = self.stack_names

        if self.stack_roles is not None:
            if hasattr(self.stack_roles, 'to_dict'):
                props['StackRoles'] = self.stack_roles.to_dict()
            elif isinstance(self.stack_roles, list):
                props['StackRoles'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stack_roles
                ]
            else:
                props['StackRoles'] = self.stack_roles

        return props


@dataclass
class StackNames:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    exclude: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    include: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.exclude is not None:
            if hasattr(self.exclude, 'to_dict'):
                props['Exclude'] = self.exclude.to_dict()
            elif isinstance(self.exclude, list):
                props['Exclude'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.exclude
                ]
            else:
                props['Exclude'] = self.exclude

        if self.include is not None:
            if hasattr(self.include, 'to_dict'):
                props['Include'] = self.include.to_dict()
            elif isinstance(self.include, list):
                props['Include'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.include
                ]
            else:
                props['Include'] = self.include

        return props


@dataclass
class StackRoles:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    exclude: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    include: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.exclude is not None:
            if hasattr(self.exclude, 'to_dict'):
                props['Exclude'] = self.exclude.to_dict()
            elif isinstance(self.exclude, list):
                props['Exclude'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.exclude
                ]
            else:
                props['Exclude'] = self.exclude

        if self.include is not None:
            if hasattr(self.include, 'to_dict'):
                props['Include'] = self.include.to_dict()
            elif isinstance(self.include, list):
                props['Include'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.include
                ]
            else:
                props['Include'] = self.include

        return props


@dataclass
class TargetFilters:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    actions: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    targets: Optional[list[HookTarget]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    invocation_points: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.actions is not None:
            if hasattr(self.actions, 'to_dict'):
                props['Actions'] = self.actions.to_dict()
            elif isinstance(self.actions, list):
                props['Actions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.actions
                ]
            else:
                props['Actions'] = self.actions

        if self.target_names is not None:
            if hasattr(self.target_names, 'to_dict'):
                props['TargetNames'] = self.target_names.to_dict()
            elif isinstance(self.target_names, list):
                props['TargetNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_names
                ]
            else:
                props['TargetNames'] = self.target_names

        if self.targets is not None:
            if hasattr(self.targets, 'to_dict'):
                props['Targets'] = self.targets.to_dict()
            elif isinstance(self.targets, list):
                props['Targets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.targets
                ]
            else:
                props['Targets'] = self.targets

        if self.invocation_points is not None:
            if hasattr(self.invocation_points, 'to_dict'):
                props['InvocationPoints'] = self.invocation_points.to_dict()
            elif isinstance(self.invocation_points, list):
                props['InvocationPoints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.invocation_points
                ]
            else:
                props['InvocationPoints'] = self.invocation_points

        return props


@dataclass
class LambdaHook(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::LambdaHook"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    hook_status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    alias: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    stack_filters: Optional[StackFilters] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_operations: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_filters: Optional[TargetFilters] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    lambda_function: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    execution_role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    failure_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.hook_status is not None:
            # Serialize hook_status (handle intrinsic functions)
            if hasattr(self.hook_status, 'to_dict'):
                props["HookStatus"] = self.hook_status.to_dict()
            elif isinstance(self.hook_status, list):
                # Serialize list items (may contain intrinsic functions)
                props['HookStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hook_status
                ]
            else:
                props["HookStatus"] = self.hook_status

        if self.alias is not None:
            # Serialize alias (handle intrinsic functions)
            if hasattr(self.alias, 'to_dict'):
                props["Alias"] = self.alias.to_dict()
            elif isinstance(self.alias, list):
                # Serialize list items (may contain intrinsic functions)
                props['Alias'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.alias
                ]
            else:
                props["Alias"] = self.alias

        if self.stack_filters is not None:
            # Serialize stack_filters (handle intrinsic functions)
            if hasattr(self.stack_filters, 'to_dict'):
                props["StackFilters"] = self.stack_filters.to_dict()
            elif isinstance(self.stack_filters, list):
                # Serialize list items (may contain intrinsic functions)
                props['StackFilters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stack_filters
                ]
            else:
                props["StackFilters"] = self.stack_filters

        if self.target_operations is not None:
            # Serialize target_operations (handle intrinsic functions)
            if hasattr(self.target_operations, 'to_dict'):
                props["TargetOperations"] = self.target_operations.to_dict()
            elif isinstance(self.target_operations, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetOperations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_operations
                ]
            else:
                props["TargetOperations"] = self.target_operations

        if self.target_filters is not None:
            # Serialize target_filters (handle intrinsic functions)
            if hasattr(self.target_filters, 'to_dict'):
                props["TargetFilters"] = self.target_filters.to_dict()
            elif isinstance(self.target_filters, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetFilters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_filters
                ]
            else:
                props["TargetFilters"] = self.target_filters

        if self.lambda_function is not None:
            # Serialize lambda_function (handle intrinsic functions)
            if hasattr(self.lambda_function, 'to_dict'):
                props["LambdaFunction"] = self.lambda_function.to_dict()
            elif isinstance(self.lambda_function, list):
                # Serialize list items (may contain intrinsic functions)
                props['LambdaFunction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lambda_function
                ]
            else:
                props["LambdaFunction"] = self.lambda_function

        if self.execution_role is not None:
            # Serialize execution_role (handle intrinsic functions)
            if hasattr(self.execution_role, 'to_dict'):
                props["ExecutionRole"] = self.execution_role.to_dict()
            elif isinstance(self.execution_role, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExecutionRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role
                ]
            else:
                props["ExecutionRole"] = self.execution_role

        if self.failure_mode is not None:
            # Serialize failure_mode (handle intrinsic functions)
            if hasattr(self.failure_mode, 'to_dict'):
                props["FailureMode"] = self.failure_mode.to_dict()
            elif isinstance(self.failure_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['FailureMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.failure_mode
                ]
            else:
                props["FailureMode"] = self.failure_mode

        return props

    @property
    def attr_hook_arn(self) -> GetAtt:
        """Get the HookArn attribute."""
        return self.get_att("HookArn")




@dataclass
class Macro(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::Macro"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    function_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.function_name is not None:
            # Serialize function_name (handle intrinsic functions)
            if hasattr(self.function_name, 'to_dict'):
                props["FunctionName"] = self.function_name.to_dict()
            elif isinstance(self.function_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['FunctionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.function_name
                ]
            else:
                props["FunctionName"] = self.function_name

        if self.log_group_name is not None:
            # Serialize log_group_name (handle intrinsic functions)
            if hasattr(self.log_group_name, 'to_dict'):
                props["LogGroupName"] = self.log_group_name.to_dict()
            elif isinstance(self.log_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_name
                ]
            else:
                props["LogGroupName"] = self.log_group_name

        if self.log_role_arn is not None:
            # Serialize log_role_arn (handle intrinsic functions)
            if hasattr(self.log_role_arn, 'to_dict'):
                props["LogRoleARN"] = self.log_role_arn.to_dict()
            elif isinstance(self.log_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogRoleARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_role_arn
                ]
            else:
                props["LogRoleARN"] = self.log_role_arn

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props



@dataclass
class ModuleDefaultVersion(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::ModuleDefaultVersion"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    version_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    module_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.version_id is not None:
            # Serialize version_id (handle intrinsic functions)
            if hasattr(self.version_id, 'to_dict'):
                props["VersionId"] = self.version_id.to_dict()
            elif isinstance(self.version_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VersionId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version_id
                ]
            else:
                props["VersionId"] = self.version_id

        if self.module_name is not None:
            # Serialize module_name (handle intrinsic functions)
            if hasattr(self.module_name, 'to_dict'):
                props["ModuleName"] = self.module_name.to_dict()
            elif isinstance(self.module_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModuleName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.module_name
                ]
            else:
                props["ModuleName"] = self.module_name

        if self.arn is not None:
            # Serialize arn (handle intrinsic functions)
            if hasattr(self.arn, 'to_dict'):
                props["Arn"] = self.arn.to_dict()
            elif isinstance(self.arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['Arn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.arn
                ]
            else:
                props["Arn"] = self.arn

        return props



@dataclass
class ModuleVersion(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::ModuleVersion"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    module_package: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    module_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.module_package is not None:
            # Serialize module_package (handle intrinsic functions)
            if hasattr(self.module_package, 'to_dict'):
                props["ModulePackage"] = self.module_package.to_dict()
            elif isinstance(self.module_package, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModulePackage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.module_package
                ]
            else:
                props["ModulePackage"] = self.module_package

        if self.module_name is not None:
            # Serialize module_name (handle intrinsic functions)
            if hasattr(self.module_name, 'to_dict'):
                props["ModuleName"] = self.module_name.to_dict()
            elif isinstance(self.module_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModuleName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.module_name
                ]
            else:
                props["ModuleName"] = self.module_name

        return props

    @property
    def attr_time_created(self) -> GetAtt:
        """Get the TimeCreated attribute."""
        return self.get_att("TimeCreated")

    @property
    def attr_version_id(self) -> GetAtt:
        """Get the VersionId attribute."""
        return self.get_att("VersionId")

    @property
    def attr_description(self) -> GetAtt:
        """Get the Description attribute."""
        return self.get_att("Description")

    @property
    def attr_schema(self) -> GetAtt:
        """Get the Schema attribute."""
        return self.get_att("Schema")

    @property
    def attr_is_default_version(self) -> GetAtt:
        """Get the IsDefaultVersion attribute."""
        return self.get_att("IsDefaultVersion")

    @property
    def attr_visibility(self) -> GetAtt:
        """Get the Visibility attribute."""
        return self.get_att("Visibility")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_documentation_url(self) -> GetAtt:
        """Get the DocumentationUrl attribute."""
        return self.get_att("DocumentationUrl")




@dataclass
class PublicTypeVersion(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::PublicTypeVersion"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_delivery_bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    public_version_number: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_name is not None:
            # Serialize type_name (handle intrinsic functions)
            if hasattr(self.type_name, 'to_dict'):
                props["TypeName"] = self.type_name.to_dict()
            elif isinstance(self.type_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['TypeName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_name
                ]
            else:
                props["TypeName"] = self.type_name

        if self.log_delivery_bucket is not None:
            # Serialize log_delivery_bucket (handle intrinsic functions)
            if hasattr(self.log_delivery_bucket, 'to_dict'):
                props["LogDeliveryBucket"] = self.log_delivery_bucket.to_dict()
            elif isinstance(self.log_delivery_bucket, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogDeliveryBucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_delivery_bucket
                ]
            else:
                props["LogDeliveryBucket"] = self.log_delivery_bucket

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.public_version_number is not None:
            # Serialize public_version_number (handle intrinsic functions)
            if hasattr(self.public_version_number, 'to_dict'):
                props["PublicVersionNumber"] = self.public_version_number.to_dict()
            elif isinstance(self.public_version_number, list):
                # Serialize list items (may contain intrinsic functions)
                props['PublicVersionNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_version_number
                ]
            else:
                props["PublicVersionNumber"] = self.public_version_number

        if self.arn is not None:
            # Serialize arn (handle intrinsic functions)
            if hasattr(self.arn, 'to_dict'):
                props["Arn"] = self.arn.to_dict()
            elif isinstance(self.arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['Arn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.arn
                ]
            else:
                props["Arn"] = self.arn

        return props

    @property
    def attr_public_type_arn(self) -> GetAtt:
        """Get the PublicTypeArn attribute."""
        return self.get_att("PublicTypeArn")

    @property
    def attr_publisher_id(self) -> GetAtt:
        """Get the PublisherId attribute."""
        return self.get_att("PublisherId")

    @property
    def attr_type_version_arn(self) -> GetAtt:
        """Get the TypeVersionArn attribute."""
        return self.get_att("TypeVersionArn")




@dataclass
class Publisher(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::Publisher"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    accept_terms_and_conditions: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connection_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.accept_terms_and_conditions is not None:
            # Serialize accept_terms_and_conditions (handle intrinsic functions)
            if hasattr(self.accept_terms_and_conditions, 'to_dict'):
                props["AcceptTermsAndConditions"] = self.accept_terms_and_conditions.to_dict()
            elif isinstance(self.accept_terms_and_conditions, list):
                # Serialize list items (may contain intrinsic functions)
                props['AcceptTermsAndConditions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accept_terms_and_conditions
                ]
            else:
                props["AcceptTermsAndConditions"] = self.accept_terms_and_conditions

        if self.connection_arn is not None:
            # Serialize connection_arn (handle intrinsic functions)
            if hasattr(self.connection_arn, 'to_dict'):
                props["ConnectionArn"] = self.connection_arn.to_dict()
            elif isinstance(self.connection_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConnectionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connection_arn
                ]
            else:
                props["ConnectionArn"] = self.connection_arn

        return props

    @property
    def attr_publisher_id(self) -> GetAtt:
        """Get the PublisherId attribute."""
        return self.get_att("PublisherId")

    @property
    def attr_identity_provider(self) -> GetAtt:
        """Get the IdentityProvider attribute."""
        return self.get_att("IdentityProvider")

    @property
    def attr_publisher_profile(self) -> GetAtt:
        """Get the PublisherProfile attribute."""
        return self.get_att("PublisherProfile")

    @property
    def attr_publisher_status(self) -> GetAtt:
        """Get the PublisherStatus attribute."""
        return self.get_att("PublisherStatus")




@dataclass
class ResourceDefaultVersion(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::ResourceDefaultVersion"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    version_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_version_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.version_id is not None:
            # Serialize version_id (handle intrinsic functions)
            if hasattr(self.version_id, 'to_dict'):
                props["VersionId"] = self.version_id.to_dict()
            elif isinstance(self.version_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VersionId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version_id
                ]
            else:
                props["VersionId"] = self.version_id

        if self.type_name is not None:
            # Serialize type_name (handle intrinsic functions)
            if hasattr(self.type_name, 'to_dict'):
                props["TypeName"] = self.type_name.to_dict()
            elif isinstance(self.type_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['TypeName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_name
                ]
            else:
                props["TypeName"] = self.type_name

        if self.type_version_arn is not None:
            # Serialize type_version_arn (handle intrinsic functions)
            if hasattr(self.type_version_arn, 'to_dict'):
                props["TypeVersionArn"] = self.type_version_arn.to_dict()
            elif isinstance(self.type_version_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['TypeVersionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_version_arn
                ]
            else:
                props["TypeVersionArn"] = self.type_version_arn

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class LoggingConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.log_group_name is not None:
            if hasattr(self.log_group_name, 'to_dict'):
                props['LogGroupName'] = self.log_group_name.to_dict()
            elif isinstance(self.log_group_name, list):
                props['LogGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_name
                ]
            else:
                props['LogGroupName'] = self.log_group_name

        if self.log_role_arn is not None:
            if hasattr(self.log_role_arn, 'to_dict'):
                props['LogRoleArn'] = self.log_role_arn.to_dict()
            elif isinstance(self.log_role_arn, list):
                props['LogRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_role_arn
                ]
            else:
                props['LogRoleArn'] = self.log_role_arn

        return props


@dataclass
class ResourceVersion(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::ResourceVersion"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    execution_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    logging_config: Optional[LoggingConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    schema_handler_package: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.execution_role_arn is not None:
            # Serialize execution_role_arn (handle intrinsic functions)
            if hasattr(self.execution_role_arn, 'to_dict'):
                props["ExecutionRoleArn"] = self.execution_role_arn.to_dict()
            elif isinstance(self.execution_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExecutionRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role_arn
                ]
            else:
                props["ExecutionRoleArn"] = self.execution_role_arn

        if self.type_name is not None:
            # Serialize type_name (handle intrinsic functions)
            if hasattr(self.type_name, 'to_dict'):
                props["TypeName"] = self.type_name.to_dict()
            elif isinstance(self.type_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['TypeName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_name
                ]
            else:
                props["TypeName"] = self.type_name

        if self.logging_config is not None:
            # Serialize logging_config (handle intrinsic functions)
            if hasattr(self.logging_config, 'to_dict'):
                props["LoggingConfig"] = self.logging_config.to_dict()
            elif isinstance(self.logging_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['LoggingConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.logging_config
                ]
            else:
                props["LoggingConfig"] = self.logging_config

        if self.schema_handler_package is not None:
            # Serialize schema_handler_package (handle intrinsic functions)
            if hasattr(self.schema_handler_package, 'to_dict'):
                props["SchemaHandlerPackage"] = self.schema_handler_package.to_dict()
            elif isinstance(self.schema_handler_package, list):
                # Serialize list items (may contain intrinsic functions)
                props['SchemaHandlerPackage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schema_handler_package
                ]
            else:
                props["SchemaHandlerPackage"] = self.schema_handler_package

        return props

    @property
    def attr_version_id(self) -> GetAtt:
        """Get the VersionId attribute."""
        return self.get_att("VersionId")

    @property
    def attr_provisioning_type(self) -> GetAtt:
        """Get the ProvisioningType attribute."""
        return self.get_att("ProvisioningType")

    @property
    def attr_is_default_version(self) -> GetAtt:
        """Get the IsDefaultVersion attribute."""
        return self.get_att("IsDefaultVersion")

    @property
    def attr_visibility(self) -> GetAtt:
        """Get the Visibility attribute."""
        return self.get_att("Visibility")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_type_arn(self) -> GetAtt:
        """Get the TypeArn attribute."""
        return self.get_att("TypeArn")




@dataclass
class Stack(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sta"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::Stack"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-prop
    notification_ar_ns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-prop
    parameters: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-prop
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-prop
    template_url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-prop
    timeout_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.notification_ar_ns is not None:
            # Serialize notification_ar_ns (handle intrinsic functions)
            if hasattr(self.notification_ar_ns, 'to_dict'):
                props["NotificationARNs"] = self.notification_ar_ns.to_dict()
            elif isinstance(self.notification_ar_ns, list):
                # Serialize list items (may contain intrinsic functions)
                props['NotificationARNs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_ar_ns
                ]
            else:
                props["NotificationARNs"] = self.notification_ar_ns

        if self.parameters is not None:
            # Serialize parameters (handle intrinsic functions)
            if hasattr(self.parameters, 'to_dict'):
                props["Parameters"] = self.parameters.to_dict()
            elif isinstance(self.parameters, list):
                # Serialize list items (may contain intrinsic functions)
                props['Parameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameters
                ]
            else:
                props["Parameters"] = self.parameters

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.template_url is not None:
            # Serialize template_url (handle intrinsic functions)
            if hasattr(self.template_url, 'to_dict'):
                props["TemplateURL"] = self.template_url.to_dict()
            elif isinstance(self.template_url, list):
                # Serialize list items (may contain intrinsic functions)
                props['TemplateURL'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.template_url
                ]
            else:
                props["TemplateURL"] = self.template_url

        if self.timeout_in_minutes is not None:
            # Serialize timeout_in_minutes (handle intrinsic functions)
            if hasattr(self.timeout_in_minutes, 'to_dict'):
                props["TimeoutInMinutes"] = self.timeout_in_minutes.to_dict()
            elif isinstance(self.timeout_in_minutes, list):
                # Serialize list items (may contain intrinsic functions)
                props['TimeoutInMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.timeout_in_minutes
                ]
            else:
                props["TimeoutInMinutes"] = self.timeout_in_minutes

        return props



@dataclass
class AutoDeployment:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    depends_on: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    retain_stacks_on_account_removal: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.depends_on is not None:
            if hasattr(self.depends_on, 'to_dict'):
                props['DependsOn'] = self.depends_on.to_dict()
            elif isinstance(self.depends_on, list):
                props['DependsOn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.depends_on
                ]
            else:
                props['DependsOn'] = self.depends_on

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        if self.retain_stacks_on_account_removal is not None:
            if hasattr(self.retain_stacks_on_account_removal, 'to_dict'):
                props['RetainStacksOnAccountRemoval'] = self.retain_stacks_on_account_removal.to_dict()
            elif isinstance(self.retain_stacks_on_account_removal, list):
                props['RetainStacksOnAccountRemoval'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.retain_stacks_on_account_removal
                ]
            else:
                props['RetainStacksOnAccountRemoval'] = self.retain_stacks_on_account_removal

        return props


@dataclass
class DeploymentTargets:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    account_filter_type: Optional[Union[str, AccountFilterType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accounts: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accounts_url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    organizational_unit_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.account_filter_type is not None:
            if hasattr(self.account_filter_type, 'to_dict'):
                props['AccountFilterType'] = self.account_filter_type.to_dict()
            elif isinstance(self.account_filter_type, list):
                props['AccountFilterType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.account_filter_type
                ]
            else:
                props['AccountFilterType'] = self.account_filter_type

        if self.accounts is not None:
            if hasattr(self.accounts, 'to_dict'):
                props['Accounts'] = self.accounts.to_dict()
            elif isinstance(self.accounts, list):
                props['Accounts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accounts
                ]
            else:
                props['Accounts'] = self.accounts

        if self.accounts_url is not None:
            if hasattr(self.accounts_url, 'to_dict'):
                props['AccountsUrl'] = self.accounts_url.to_dict()
            elif isinstance(self.accounts_url, list):
                props['AccountsUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accounts_url
                ]
            else:
                props['AccountsUrl'] = self.accounts_url

        if self.organizational_unit_ids is not None:
            if hasattr(self.organizational_unit_ids, 'to_dict'):
                props['OrganizationalUnitIds'] = self.organizational_unit_ids.to_dict()
            elif isinstance(self.organizational_unit_ids, list):
                props['OrganizationalUnitIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organizational_unit_ids
                ]
            else:
                props['OrganizationalUnitIds'] = self.organizational_unit_ids

        return props


@dataclass
class ManagedExecution:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    active: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.active is not None:
            if hasattr(self.active, 'to_dict'):
                props['Active'] = self.active.to_dict()
            elif isinstance(self.active, list):
                props['Active'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.active
                ]
            else:
                props['Active'] = self.active

        return props


@dataclass
class OperationPreferences:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_concurrent_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    region_concurrency_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_concurrent_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    failure_tolerance_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    concurrency_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    failure_tolerance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    region_order: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_concurrent_percentage is not None:
            if hasattr(self.max_concurrent_percentage, 'to_dict'):
                props['MaxConcurrentPercentage'] = self.max_concurrent_percentage.to_dict()
            elif isinstance(self.max_concurrent_percentage, list):
                props['MaxConcurrentPercentage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_concurrent_percentage
                ]
            else:
                props['MaxConcurrentPercentage'] = self.max_concurrent_percentage

        if self.region_concurrency_type is not None:
            if hasattr(self.region_concurrency_type, 'to_dict'):
                props['RegionConcurrencyType'] = self.region_concurrency_type.to_dict()
            elif isinstance(self.region_concurrency_type, list):
                props['RegionConcurrencyType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.region_concurrency_type
                ]
            else:
                props['RegionConcurrencyType'] = self.region_concurrency_type

        if self.max_concurrent_count is not None:
            if hasattr(self.max_concurrent_count, 'to_dict'):
                props['MaxConcurrentCount'] = self.max_concurrent_count.to_dict()
            elif isinstance(self.max_concurrent_count, list):
                props['MaxConcurrentCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_concurrent_count
                ]
            else:
                props['MaxConcurrentCount'] = self.max_concurrent_count

        if self.failure_tolerance_percentage is not None:
            if hasattr(self.failure_tolerance_percentage, 'to_dict'):
                props['FailureTolerancePercentage'] = self.failure_tolerance_percentage.to_dict()
            elif isinstance(self.failure_tolerance_percentage, list):
                props['FailureTolerancePercentage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.failure_tolerance_percentage
                ]
            else:
                props['FailureTolerancePercentage'] = self.failure_tolerance_percentage

        if self.concurrency_mode is not None:
            if hasattr(self.concurrency_mode, 'to_dict'):
                props['ConcurrencyMode'] = self.concurrency_mode.to_dict()
            elif isinstance(self.concurrency_mode, list):
                props['ConcurrencyMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.concurrency_mode
                ]
            else:
                props['ConcurrencyMode'] = self.concurrency_mode

        if self.failure_tolerance_count is not None:
            if hasattr(self.failure_tolerance_count, 'to_dict'):
                props['FailureToleranceCount'] = self.failure_tolerance_count.to_dict()
            elif isinstance(self.failure_tolerance_count, list):
                props['FailureToleranceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.failure_tolerance_count
                ]
            else:
                props['FailureToleranceCount'] = self.failure_tolerance_count

        if self.region_order is not None:
            if hasattr(self.region_order, 'to_dict'):
                props['RegionOrder'] = self.region_order.to_dict()
            elif isinstance(self.region_order, list):
                props['RegionOrder'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.region_order
                ]
            else:
                props['RegionOrder'] = self.region_order

        return props


@dataclass
class Parameter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parameter_value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parameter_key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.parameter_value is not None:
            if hasattr(self.parameter_value, 'to_dict'):
                props['ParameterValue'] = self.parameter_value.to_dict()
            elif isinstance(self.parameter_value, list):
                props['ParameterValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameter_value
                ]
            else:
                props['ParameterValue'] = self.parameter_value

        if self.parameter_key is not None:
            if hasattr(self.parameter_key, 'to_dict'):
                props['ParameterKey'] = self.parameter_key.to_dict()
            elif isinstance(self.parameter_key, list):
                props['ParameterKey'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameter_key
                ]
            else:
                props['ParameterKey'] = self.parameter_key

        return props


@dataclass
class StackInstances:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parameter_overrides: Optional[list[Parameter]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    deployment_targets: Optional[DeploymentTargets] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    regions: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.parameter_overrides is not None:
            if hasattr(self.parameter_overrides, 'to_dict'):
                props['ParameterOverrides'] = self.parameter_overrides.to_dict()
            elif isinstance(self.parameter_overrides, list):
                props['ParameterOverrides'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameter_overrides
                ]
            else:
                props['ParameterOverrides'] = self.parameter_overrides

        if self.deployment_targets is not None:
            if hasattr(self.deployment_targets, 'to_dict'):
                props['DeploymentTargets'] = self.deployment_targets.to_dict()
            elif isinstance(self.deployment_targets, list):
                props['DeploymentTargets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.deployment_targets
                ]
            else:
                props['DeploymentTargets'] = self.deployment_targets

        if self.regions is not None:
            if hasattr(self.regions, 'to_dict'):
                props['Regions'] = self.regions.to_dict()
            elif isinstance(self.regions, list):
                props['Regions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.regions
                ]
            else:
                props['Regions'] = self.regions

        return props


@dataclass
class StackSet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::StackSet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    parameters: Optional[list[Parameter]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    stack_instances_group: Optional[list[StackInstances]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    template_body: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    stack_set_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    call_as: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    operation_preferences: Optional[OperationPreferences] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    template_url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_deployment: Optional[AutoDeployment] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    capabilities: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    permission_model: Optional[Union[str, PermissionModels, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    administration_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    execution_role_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    managed_execution: Optional[ManagedExecution] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.parameters is not None:
            # Serialize parameters (handle intrinsic functions)
            if hasattr(self.parameters, 'to_dict'):
                props["Parameters"] = self.parameters.to_dict()
            elif isinstance(self.parameters, list):
                # Serialize list items (may contain intrinsic functions)
                props['Parameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameters
                ]
            else:
                props["Parameters"] = self.parameters

        if self.stack_instances_group is not None:
            # Serialize stack_instances_group (handle intrinsic functions)
            if hasattr(self.stack_instances_group, 'to_dict'):
                props["StackInstancesGroup"] = self.stack_instances_group.to_dict()
            elif isinstance(self.stack_instances_group, list):
                # Serialize list items (may contain intrinsic functions)
                props['StackInstancesGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stack_instances_group
                ]
            else:
                props["StackInstancesGroup"] = self.stack_instances_group

        if self.template_body is not None:
            # Serialize template_body (handle intrinsic functions)
            if hasattr(self.template_body, 'to_dict'):
                props["TemplateBody"] = self.template_body.to_dict()
            elif isinstance(self.template_body, list):
                # Serialize list items (may contain intrinsic functions)
                props['TemplateBody'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.template_body
                ]
            else:
                props["TemplateBody"] = self.template_body

        if self.stack_set_name is not None:
            # Serialize stack_set_name (handle intrinsic functions)
            if hasattr(self.stack_set_name, 'to_dict'):
                props["StackSetName"] = self.stack_set_name.to_dict()
            elif isinstance(self.stack_set_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['StackSetName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stack_set_name
                ]
            else:
                props["StackSetName"] = self.stack_set_name

        if self.call_as is not None:
            # Serialize call_as (handle intrinsic functions)
            if hasattr(self.call_as, 'to_dict'):
                props["CallAs"] = self.call_as.to_dict()
            elif isinstance(self.call_as, list):
                # Serialize list items (may contain intrinsic functions)
                props['CallAs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.call_as
                ]
            else:
                props["CallAs"] = self.call_as

        if self.operation_preferences is not None:
            # Serialize operation_preferences (handle intrinsic functions)
            if hasattr(self.operation_preferences, 'to_dict'):
                props["OperationPreferences"] = self.operation_preferences.to_dict()
            elif isinstance(self.operation_preferences, list):
                # Serialize list items (may contain intrinsic functions)
                props['OperationPreferences'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.operation_preferences
                ]
            else:
                props["OperationPreferences"] = self.operation_preferences

        if self.template_url is not None:
            # Serialize template_url (handle intrinsic functions)
            if hasattr(self.template_url, 'to_dict'):
                props["TemplateURL"] = self.template_url.to_dict()
            elif isinstance(self.template_url, list):
                # Serialize list items (may contain intrinsic functions)
                props['TemplateURL'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.template_url
                ]
            else:
                props["TemplateURL"] = self.template_url

        if self.auto_deployment is not None:
            # Serialize auto_deployment (handle intrinsic functions)
            if hasattr(self.auto_deployment, 'to_dict'):
                props["AutoDeployment"] = self.auto_deployment.to_dict()
            elif isinstance(self.auto_deployment, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoDeployment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_deployment
                ]
            else:
                props["AutoDeployment"] = self.auto_deployment

        if self.capabilities is not None:
            # Serialize capabilities (handle intrinsic functions)
            if hasattr(self.capabilities, 'to_dict'):
                props["Capabilities"] = self.capabilities.to_dict()
            elif isinstance(self.capabilities, list):
                # Serialize list items (may contain intrinsic functions)
                props['Capabilities'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capabilities
                ]
            else:
                props["Capabilities"] = self.capabilities

        if self.permission_model is not None:
            # Serialize permission_model (handle intrinsic functions)
            if hasattr(self.permission_model, 'to_dict'):
                props["PermissionModel"] = self.permission_model.to_dict()
            elif isinstance(self.permission_model, list):
                # Serialize list items (may contain intrinsic functions)
                props['PermissionModel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.permission_model
                ]
            else:
                props["PermissionModel"] = self.permission_model

        if self.administration_role_arn is not None:
            # Serialize administration_role_arn (handle intrinsic functions)
            if hasattr(self.administration_role_arn, 'to_dict'):
                props["AdministrationRoleARN"] = self.administration_role_arn.to_dict()
            elif isinstance(self.administration_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['AdministrationRoleARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.administration_role_arn
                ]
            else:
                props["AdministrationRoleARN"] = self.administration_role_arn

        if self.execution_role_name is not None:
            # Serialize execution_role_name (handle intrinsic functions)
            if hasattr(self.execution_role_name, 'to_dict'):
                props["ExecutionRoleName"] = self.execution_role_name.to_dict()
            elif isinstance(self.execution_role_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExecutionRoleName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role_name
                ]
            else:
                props["ExecutionRoleName"] = self.execution_role_name

        if self.managed_execution is not None:
            # Serialize managed_execution (handle intrinsic functions)
            if hasattr(self.managed_execution, 'to_dict'):
                props["ManagedExecution"] = self.managed_execution.to_dict()
            elif isinstance(self.managed_execution, list):
                # Serialize list items (may contain intrinsic functions)
                props['ManagedExecution'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.managed_execution
                ]
            else:
                props["ManagedExecution"] = self.managed_execution

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_stack_set_id(self) -> GetAtt:
        """Get the StackSetId attribute."""
        return self.get_att("StackSetId")




@dataclass
class LoggingConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-clo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.log_group_name is not None:
            if hasattr(self.log_group_name, 'to_dict'):
                props['LogGroupName'] = self.log_group_name.to_dict()
            elif isinstance(self.log_group_name, list):
                props['LogGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_name
                ]
            else:
                props['LogGroupName'] = self.log_group_name

        if self.log_role_arn is not None:
            if hasattr(self.log_role_arn, 'to_dict'):
                props['LogRoleArn'] = self.log_role_arn.to_dict()
            elif isinstance(self.log_role_arn, list):
                props['LogRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_role_arn
                ]
            else:
                props['LogRoleArn'] = self.log_role_arn

        return props


@dataclass
class TypeActivation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cloud"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::TypeActivation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    major_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    execution_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    public_type_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_update: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    logging_config: Optional[LoggingConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    publisher_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    version_bump: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_name_alias: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.major_version is not None:
            # Serialize major_version (handle intrinsic functions)
            if hasattr(self.major_version, 'to_dict'):
                props["MajorVersion"] = self.major_version.to_dict()
            elif isinstance(self.major_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['MajorVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.major_version
                ]
            else:
                props["MajorVersion"] = self.major_version

        if self.execution_role_arn is not None:
            # Serialize execution_role_arn (handle intrinsic functions)
            if hasattr(self.execution_role_arn, 'to_dict'):
                props["ExecutionRoleArn"] = self.execution_role_arn.to_dict()
            elif isinstance(self.execution_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExecutionRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role_arn
                ]
            else:
                props["ExecutionRoleArn"] = self.execution_role_arn

        if self.type_name is not None:
            # Serialize type_name (handle intrinsic functions)
            if hasattr(self.type_name, 'to_dict'):
                props["TypeName"] = self.type_name.to_dict()
            elif isinstance(self.type_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['TypeName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_name
                ]
            else:
                props["TypeName"] = self.type_name

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.public_type_arn is not None:
            # Serialize public_type_arn (handle intrinsic functions)
            if hasattr(self.public_type_arn, 'to_dict'):
                props["PublicTypeArn"] = self.public_type_arn.to_dict()
            elif isinstance(self.public_type_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['PublicTypeArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_type_arn
                ]
            else:
                props["PublicTypeArn"] = self.public_type_arn

        if self.auto_update is not None:
            # Serialize auto_update (handle intrinsic functions)
            if hasattr(self.auto_update, 'to_dict'):
                props["AutoUpdate"] = self.auto_update.to_dict()
            elif isinstance(self.auto_update, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoUpdate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_update
                ]
            else:
                props["AutoUpdate"] = self.auto_update

        if self.logging_config is not None:
            # Serialize logging_config (handle intrinsic functions)
            if hasattr(self.logging_config, 'to_dict'):
                props["LoggingConfig"] = self.logging_config.to_dict()
            elif isinstance(self.logging_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['LoggingConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.logging_config
                ]
            else:
                props["LoggingConfig"] = self.logging_config

        if self.publisher_id is not None:
            # Serialize publisher_id (handle intrinsic functions)
            if hasattr(self.publisher_id, 'to_dict'):
                props["PublisherId"] = self.publisher_id.to_dict()
            elif isinstance(self.publisher_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['PublisherId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.publisher_id
                ]
            else:
                props["PublisherId"] = self.publisher_id

        if self.version_bump is not None:
            # Serialize version_bump (handle intrinsic functions)
            if hasattr(self.version_bump, 'to_dict'):
                props["VersionBump"] = self.version_bump.to_dict()
            elif isinstance(self.version_bump, list):
                # Serialize list items (may contain intrinsic functions)
                props['VersionBump'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version_bump
                ]
            else:
                props["VersionBump"] = self.version_bump

        if self.type_name_alias is not None:
            # Serialize type_name_alias (handle intrinsic functions)
            if hasattr(self.type_name_alias, 'to_dict'):
                props["TypeNameAlias"] = self.type_name_alias.to_dict()
            elif isinstance(self.type_name_alias, list):
                # Serialize list items (may contain intrinsic functions)
                props['TypeNameAlias'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_name_alias
                ]
            else:
                props["TypeNameAlias"] = self.type_name_alias

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class WaitCondition(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-wai"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::WaitCondition"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-prop
    count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-prop
    handle: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-prop
    timeout: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.count is not None:
            # Serialize count (handle intrinsic functions)
            if hasattr(self.count, 'to_dict'):
                props["Count"] = self.count.to_dict()
            elif isinstance(self.count, list):
                # Serialize list items (may contain intrinsic functions)
                props['Count'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.count
                ]
            else:
                props["Count"] = self.count

        if self.handle is not None:
            # Serialize handle (handle intrinsic functions)
            if hasattr(self.handle, 'to_dict'):
                props["Handle"] = self.handle.to_dict()
            elif isinstance(self.handle, list):
                # Serialize list items (may contain intrinsic functions)
                props['Handle'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.handle
                ]
            else:
                props["Handle"] = self.handle

        if self.timeout is not None:
            # Serialize timeout (handle intrinsic functions)
            if hasattr(self.timeout, 'to_dict'):
                props["Timeout"] = self.timeout.to_dict()
            elif isinstance(self.timeout, list):
                # Serialize list items (may contain intrinsic functions)
                props['Timeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.timeout
                ]
            else:
                props["Timeout"] = self.timeout

        return props

    @property
    def attr_data(self) -> GetAtt:
        """Get the Data attribute."""
        return self.get_att("Data")




@dataclass
class WaitConditionHandle(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-wai"""

    resource_type: ClassVar[str] = "AWS::CloudFormation::WaitConditionHandle"

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        return {}


