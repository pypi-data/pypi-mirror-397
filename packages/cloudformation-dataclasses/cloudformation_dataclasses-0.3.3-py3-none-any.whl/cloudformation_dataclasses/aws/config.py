"""
AWS CloudFormation Config Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:35

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service Config
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AggregateConformancePackComplianceSummaryGroupKey:
    """AggregateConformancePackComplianceSummaryGroupKey enum values."""

    ACCOUNT_ID = "ACCOUNT_ID"
    AWS_REGION = "AWS_REGION"


class AggregatedSourceStatusType:
    """AggregatedSourceStatusType enum values."""

    FAILED = "FAILED"
    SUCCEEDED = "SUCCEEDED"
    OUTDATED = "OUTDATED"


class AggregatedSourceType:
    """AggregatedSourceType enum values."""

    ACCOUNT = "ACCOUNT"
    ORGANIZATION = "ORGANIZATION"


class AggregatorFilterType:
    """AggregatorFilterType enum values."""

    INCLUDE = "INCLUDE"


class ChronologicalOrder:
    """ChronologicalOrder enum values."""

    REVERSE = "Reverse"
    FORWARD = "Forward"


class ComplianceType:
    """ComplianceType enum values."""

    COMPLIANT = "COMPLIANT"
    NON_COMPLIANT = "NON_COMPLIANT"
    NOT_APPLICABLE = "NOT_APPLICABLE"
    INSUFFICIENT_DATA = "INSUFFICIENT_DATA"


class ConfigRuleComplianceSummaryGroupKey:
    """ConfigRuleComplianceSummaryGroupKey enum values."""

    ACCOUNT_ID = "ACCOUNT_ID"
    AWS_REGION = "AWS_REGION"


class ConfigRuleState:
    """ConfigRuleState enum values."""

    ACTIVE = "ACTIVE"
    DELETING = "DELETING"
    DELETING_RESULTS = "DELETING_RESULTS"
    EVALUATING = "EVALUATING"


class ConfigurationItemStatus:
    """ConfigurationItemStatus enum values."""

    OK = "OK"
    RESOURCEDISCOVERED = "ResourceDiscovered"
    RESOURCENOTRECORDED = "ResourceNotRecorded"
    RESOURCEDELETED = "ResourceDeleted"
    RESOURCEDELETEDNOTRECORDED = "ResourceDeletedNotRecorded"


class ConfigurationRecorderFilterName:
    """ConfigurationRecorderFilterName enum values."""

    RECORDINGSCOPE = "recordingScope"


class ConformancePackComplianceType:
    """ConformancePackComplianceType enum values."""

    COMPLIANT = "COMPLIANT"
    NON_COMPLIANT = "NON_COMPLIANT"
    INSUFFICIENT_DATA = "INSUFFICIENT_DATA"


class ConformancePackState:
    """ConformancePackState enum values."""

    CREATE_IN_PROGRESS = "CREATE_IN_PROGRESS"
    CREATE_COMPLETE = "CREATE_COMPLETE"
    CREATE_FAILED = "CREATE_FAILED"
    DELETE_IN_PROGRESS = "DELETE_IN_PROGRESS"
    DELETE_FAILED = "DELETE_FAILED"


class DeliveryStatus:
    """DeliveryStatus enum values."""

    SUCCESS = "Success"
    FAILURE = "Failure"
    NOT_APPLICABLE = "Not_Applicable"


class EvaluationMode:
    """EvaluationMode enum values."""

    DETECTIVE = "DETECTIVE"
    PROACTIVE = "PROACTIVE"


class EventSource:
    """EventSource enum values."""

    AWS_CONFIG = "aws.config"


class MaximumExecutionFrequency:
    """MaximumExecutionFrequency enum values."""

    ONE_HOUR = "One_Hour"
    THREE_HOURS = "Three_Hours"
    SIX_HOURS = "Six_Hours"
    TWELVE_HOURS = "Twelve_Hours"
    TWENTYFOUR_HOURS = "TwentyFour_Hours"


class MemberAccountRuleStatus:
    """MemberAccountRuleStatus enum values."""

    CREATE_SUCCESSFUL = "CREATE_SUCCESSFUL"
    CREATE_IN_PROGRESS = "CREATE_IN_PROGRESS"
    CREATE_FAILED = "CREATE_FAILED"
    DELETE_SUCCESSFUL = "DELETE_SUCCESSFUL"
    DELETE_FAILED = "DELETE_FAILED"
    DELETE_IN_PROGRESS = "DELETE_IN_PROGRESS"
    UPDATE_SUCCESSFUL = "UPDATE_SUCCESSFUL"
    UPDATE_IN_PROGRESS = "UPDATE_IN_PROGRESS"
    UPDATE_FAILED = "UPDATE_FAILED"


class MessageType:
    """MessageType enum values."""

    CONFIGURATIONITEMCHANGENOTIFICATION = "ConfigurationItemChangeNotification"
    CONFIGURATIONSNAPSHOTDELIVERYCOMPLETED = "ConfigurationSnapshotDeliveryCompleted"
    SCHEDULEDNOTIFICATION = "ScheduledNotification"
    OVERSIZEDCONFIGURATIONITEMCHANGENOTIFICATION = "OversizedConfigurationItemChangeNotification"


class OrganizationConfigRuleTriggerType:
    """OrganizationConfigRuleTriggerType enum values."""

    CONFIGURATIONITEMCHANGENOTIFICATION = "ConfigurationItemChangeNotification"
    OVERSIZEDCONFIGURATIONITEMCHANGENOTIFICATION = "OversizedConfigurationItemChangeNotification"
    SCHEDULEDNOTIFICATION = "ScheduledNotification"


class OrganizationConfigRuleTriggerTypeNoSN:
    """OrganizationConfigRuleTriggerTypeNoSN enum values."""

    CONFIGURATIONITEMCHANGENOTIFICATION = "ConfigurationItemChangeNotification"
    OVERSIZEDCONFIGURATIONITEMCHANGENOTIFICATION = "OversizedConfigurationItemChangeNotification"


class OrganizationResourceDetailedStatus:
    """OrganizationResourceDetailedStatus enum values."""

    CREATE_SUCCESSFUL = "CREATE_SUCCESSFUL"
    CREATE_IN_PROGRESS = "CREATE_IN_PROGRESS"
    CREATE_FAILED = "CREATE_FAILED"
    DELETE_SUCCESSFUL = "DELETE_SUCCESSFUL"
    DELETE_FAILED = "DELETE_FAILED"
    DELETE_IN_PROGRESS = "DELETE_IN_PROGRESS"
    UPDATE_SUCCESSFUL = "UPDATE_SUCCESSFUL"
    UPDATE_IN_PROGRESS = "UPDATE_IN_PROGRESS"
    UPDATE_FAILED = "UPDATE_FAILED"


class OrganizationResourceStatus:
    """OrganizationResourceStatus enum values."""

    CREATE_SUCCESSFUL = "CREATE_SUCCESSFUL"
    CREATE_IN_PROGRESS = "CREATE_IN_PROGRESS"
    CREATE_FAILED = "CREATE_FAILED"
    DELETE_SUCCESSFUL = "DELETE_SUCCESSFUL"
    DELETE_FAILED = "DELETE_FAILED"
    DELETE_IN_PROGRESS = "DELETE_IN_PROGRESS"
    UPDATE_SUCCESSFUL = "UPDATE_SUCCESSFUL"
    UPDATE_IN_PROGRESS = "UPDATE_IN_PROGRESS"
    UPDATE_FAILED = "UPDATE_FAILED"


class OrganizationRuleStatus:
    """OrganizationRuleStatus enum values."""

    CREATE_SUCCESSFUL = "CREATE_SUCCESSFUL"
    CREATE_IN_PROGRESS = "CREATE_IN_PROGRESS"
    CREATE_FAILED = "CREATE_FAILED"
    DELETE_SUCCESSFUL = "DELETE_SUCCESSFUL"
    DELETE_FAILED = "DELETE_FAILED"
    DELETE_IN_PROGRESS = "DELETE_IN_PROGRESS"
    UPDATE_SUCCESSFUL = "UPDATE_SUCCESSFUL"
    UPDATE_IN_PROGRESS = "UPDATE_IN_PROGRESS"
    UPDATE_FAILED = "UPDATE_FAILED"


class Owner:
    """Owner enum values."""

    CUSTOM_LAMBDA = "CUSTOM_LAMBDA"
    AWS = "AWS"
    CUSTOM_POLICY = "CUSTOM_POLICY"


class RecorderStatus:
    """RecorderStatus enum values."""

    PENDING = "Pending"
    SUCCESS = "Success"
    FAILURE = "Failure"
    NOTAPPLICABLE = "NotApplicable"


class RecordingFrequency:
    """RecordingFrequency enum values."""

    CONTINUOUS = "CONTINUOUS"
    DAILY = "DAILY"


class RecordingScope:
    """RecordingScope enum values."""

    INTERNAL = "INTERNAL"
    PAID = "PAID"


class RecordingStrategyType:
    """RecordingStrategyType enum values."""

    ALL_SUPPORTED_RESOURCE_TYPES = "ALL_SUPPORTED_RESOURCE_TYPES"
    INCLUSION_BY_RESOURCE_TYPES = "INCLUSION_BY_RESOURCE_TYPES"
    EXCLUSION_BY_RESOURCE_TYPES = "EXCLUSION_BY_RESOURCE_TYPES"


class RemediationExecutionState:
    """RemediationExecutionState enum values."""

    QUEUED = "QUEUED"
    IN_PROGRESS = "IN_PROGRESS"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    UNKNOWN = "UNKNOWN"


class RemediationExecutionStepState:
    """RemediationExecutionStepState enum values."""

    SUCCEEDED = "SUCCEEDED"
    PENDING = "PENDING"
    FAILED = "FAILED"
    IN_PROGRESS = "IN_PROGRESS"
    EXITED = "EXITED"
    UNKNOWN = "UNKNOWN"


class RemediationTargetType:
    """RemediationTargetType enum values."""

    SSM_DOCUMENT = "SSM_DOCUMENT"


class ResourceConfigurationSchemaType:
    """ResourceConfigurationSchemaType enum values."""

    CFN_RESOURCE_SCHEMA = "CFN_RESOURCE_SCHEMA"


class ResourceCountGroupKey:
    """ResourceCountGroupKey enum values."""

    RESOURCE_TYPE = "RESOURCE_TYPE"
    ACCOUNT_ID = "ACCOUNT_ID"
    AWS_REGION = "AWS_REGION"


class ResourceEvaluationStatus:
    """ResourceEvaluationStatus enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    FAILED = "FAILED"
    SUCCEEDED = "SUCCEEDED"


class ResourceType:
    """ResourceType enum values."""

    AWS_EC2_CUSTOMERGATEWAY = "AWS::EC2::CustomerGateway"
    AWS_EC2_EIP = "AWS::EC2::EIP"
    AWS_EC2_HOST = "AWS::EC2::Host"
    AWS_EC2_INSTANCE = "AWS::EC2::Instance"
    AWS_EC2_INTERNETGATEWAY = "AWS::EC2::InternetGateway"
    AWS_EC2_NETWORKACL = "AWS::EC2::NetworkAcl"
    AWS_EC2_NETWORKINTERFACE = "AWS::EC2::NetworkInterface"
    AWS_EC2_ROUTETABLE = "AWS::EC2::RouteTable"
    AWS_EC2_SECURITYGROUP = "AWS::EC2::SecurityGroup"
    AWS_EC2_SUBNET = "AWS::EC2::Subnet"
    AWS_CLOUDTRAIL_TRAIL = "AWS::CloudTrail::Trail"
    AWS_EC2_VOLUME = "AWS::EC2::Volume"
    AWS_EC2_VPC = "AWS::EC2::VPC"
    AWS_EC2_VPNCONNECTION = "AWS::EC2::VPNConnection"
    AWS_EC2_VPNGATEWAY = "AWS::EC2::VPNGateway"
    AWS_EC2_REGISTEREDHAINSTANCE = "AWS::EC2::RegisteredHAInstance"
    AWS_EC2_NATGATEWAY = "AWS::EC2::NatGateway"
    AWS_EC2_EGRESSONLYINTERNETGATEWAY = "AWS::EC2::EgressOnlyInternetGateway"
    AWS_EC2_VPCENDPOINT = "AWS::EC2::VPCEndpoint"
    AWS_EC2_VPCENDPOINTSERVICE = "AWS::EC2::VPCEndpointService"
    AWS_EC2_FLOWLOG = "AWS::EC2::FlowLog"
    AWS_EC2_VPCPEERINGCONNECTION = "AWS::EC2::VPCPeeringConnection"
    AWS_ELASTICSEARCH_DOMAIN = "AWS::Elasticsearch::Domain"
    AWS_IAM_GROUP = "AWS::IAM::Group"
    AWS_IAM_POLICY = "AWS::IAM::Policy"
    AWS_IAM_ROLE = "AWS::IAM::Role"
    AWS_IAM_USER = "AWS::IAM::User"
    AWS_ELASTICLOADBALANCINGV2_LOADBALANCER = "AWS::ElasticLoadBalancingV2::LoadBalancer"
    AWS_ACM_CERTIFICATE = "AWS::ACM::Certificate"
    AWS_RDS_DBINSTANCE = "AWS::RDS::DBInstance"
    AWS_RDS_DBSUBNETGROUP = "AWS::RDS::DBSubnetGroup"
    AWS_RDS_DBSECURITYGROUP = "AWS::RDS::DBSecurityGroup"
    AWS_RDS_DBSNAPSHOT = "AWS::RDS::DBSnapshot"
    AWS_RDS_DBCLUSTER = "AWS::RDS::DBCluster"
    AWS_RDS_DBCLUSTERSNAPSHOT = "AWS::RDS::DBClusterSnapshot"
    AWS_RDS_EVENTSUBSCRIPTION = "AWS::RDS::EventSubscription"
    AWS_S3_BUCKET = "AWS::S3::Bucket"
    AWS_S3_ACCOUNTPUBLICACCESSBLOCK = "AWS::S3::AccountPublicAccessBlock"
    AWS_REDSHIFT_CLUSTER = "AWS::Redshift::Cluster"
    AWS_REDSHIFT_CLUSTERSNAPSHOT = "AWS::Redshift::ClusterSnapshot"
    AWS_REDSHIFT_CLUSTERPARAMETERGROUP = "AWS::Redshift::ClusterParameterGroup"
    AWS_REDSHIFT_CLUSTERSECURITYGROUP = "AWS::Redshift::ClusterSecurityGroup"
    AWS_REDSHIFT_CLUSTERSUBNETGROUP = "AWS::Redshift::ClusterSubnetGroup"
    AWS_REDSHIFT_EVENTSUBSCRIPTION = "AWS::Redshift::EventSubscription"
    AWS_SSM_MANAGEDINSTANCEINVENTORY = "AWS::SSM::ManagedInstanceInventory"
    AWS_CLOUDWATCH_ALARM = "AWS::CloudWatch::Alarm"
    AWS_CLOUDFORMATION_STACK = "AWS::CloudFormation::Stack"
    AWS_ELASTICLOADBALANCING_LOADBALANCER = "AWS::ElasticLoadBalancing::LoadBalancer"
    AWS_AUTOSCALING_AUTOSCALINGGROUP = "AWS::AutoScaling::AutoScalingGroup"
    AWS_AUTOSCALING_LAUNCHCONFIGURATION = "AWS::AutoScaling::LaunchConfiguration"
    AWS_AUTOSCALING_SCALINGPOLICY = "AWS::AutoScaling::ScalingPolicy"
    AWS_AUTOSCALING_SCHEDULEDACTION = "AWS::AutoScaling::ScheduledAction"
    AWS_DYNAMODB_TABLE = "AWS::DynamoDB::Table"
    AWS_CODEBUILD_PROJECT = "AWS::CodeBuild::Project"
    AWS_WAF_RATEBASEDRULE = "AWS::WAF::RateBasedRule"
    AWS_WAF_RULE = "AWS::WAF::Rule"
    AWS_WAF_RULEGROUP = "AWS::WAF::RuleGroup"
    AWS_WAF_WEBACL = "AWS::WAF::WebACL"
    AWS_WAFREGIONAL_RATEBASEDRULE = "AWS::WAFRegional::RateBasedRule"
    AWS_WAFREGIONAL_RULE = "AWS::WAFRegional::Rule"
    AWS_WAFREGIONAL_RULEGROUP = "AWS::WAFRegional::RuleGroup"
    AWS_WAFREGIONAL_WEBACL = "AWS::WAFRegional::WebACL"
    AWS_CLOUDFRONT_DISTRIBUTION = "AWS::CloudFront::Distribution"
    AWS_CLOUDFRONT_STREAMINGDISTRIBUTION = "AWS::CloudFront::StreamingDistribution"
    AWS_LAMBDA_FUNCTION = "AWS::Lambda::Function"
    AWS_NETWORKFIREWALL_FIREWALL = "AWS::NetworkFirewall::Firewall"
    AWS_NETWORKFIREWALL_FIREWALLPOLICY = "AWS::NetworkFirewall::FirewallPolicy"
    AWS_NETWORKFIREWALL_RULEGROUP = "AWS::NetworkFirewall::RuleGroup"
    AWS_ELASTICBEANSTALK_APPLICATION = "AWS::ElasticBeanstalk::Application"
    AWS_ELASTICBEANSTALK_APPLICATIONVERSION = "AWS::ElasticBeanstalk::ApplicationVersion"
    AWS_ELASTICBEANSTALK_ENVIRONMENT = "AWS::ElasticBeanstalk::Environment"
    AWS_WAFV2_WEBACL = "AWS::WAFv2::WebACL"
    AWS_WAFV2_RULEGROUP = "AWS::WAFv2::RuleGroup"
    AWS_WAFV2_IPSET = "AWS::WAFv2::IPSet"
    AWS_WAFV2_REGEXPATTERNSET = "AWS::WAFv2::RegexPatternSet"
    AWS_WAFV2_MANAGEDRULESET = "AWS::WAFv2::ManagedRuleSet"
    AWS_XRAY_ENCRYPTIONCONFIG = "AWS::XRay::EncryptionConfig"
    AWS_SSM_ASSOCIATIONCOMPLIANCE = "AWS::SSM::AssociationCompliance"
    AWS_SSM_PATCHCOMPLIANCE = "AWS::SSM::PatchCompliance"
    AWS_SHIELD_PROTECTION = "AWS::Shield::Protection"
    AWS_SHIELDREGIONAL_PROTECTION = "AWS::ShieldRegional::Protection"
    AWS_CONFIG_CONFORMANCEPACKCOMPLIANCE = "AWS::Config::ConformancePackCompliance"
    AWS_CONFIG_RESOURCECOMPLIANCE = "AWS::Config::ResourceCompliance"
    AWS_APIGATEWAY_STAGE = "AWS::ApiGateway::Stage"
    AWS_APIGATEWAY_RESTAPI = "AWS::ApiGateway::RestApi"
    AWS_APIGATEWAYV2_STAGE = "AWS::ApiGatewayV2::Stage"
    AWS_APIGATEWAYV2_API = "AWS::ApiGatewayV2::Api"
    AWS_CODEPIPELINE_PIPELINE = "AWS::CodePipeline::Pipeline"
    AWS_SERVICECATALOG_CLOUDFORMATIONPROVISIONEDPRODUCT = "AWS::ServiceCatalog::CloudFormationProvisionedProduct"
    AWS_SERVICECATALOG_CLOUDFORMATIONPRODUCT = "AWS::ServiceCatalog::CloudFormationProduct"
    AWS_SERVICECATALOG_PORTFOLIO = "AWS::ServiceCatalog::Portfolio"
    AWS_SQS_QUEUE = "AWS::SQS::Queue"
    AWS_KMS_KEY = "AWS::KMS::Key"
    AWS_QLDB_LEDGER = "AWS::QLDB::Ledger"
    AWS_SECRETSMANAGER_SECRET = "AWS::SecretsManager::Secret"
    AWS_SNS_TOPIC = "AWS::SNS::Topic"
    AWS_SSM_FILEDATA = "AWS::SSM::FileData"
    AWS_BACKUP_BACKUPPLAN = "AWS::Backup::BackupPlan"
    AWS_BACKUP_BACKUPSELECTION = "AWS::Backup::BackupSelection"
    AWS_BACKUP_BACKUPVAULT = "AWS::Backup::BackupVault"
    AWS_BACKUP_RECOVERYPOINT = "AWS::Backup::RecoveryPoint"
    AWS_ECR_REPOSITORY = "AWS::ECR::Repository"
    AWS_ECS_CLUSTER = "AWS::ECS::Cluster"
    AWS_ECS_SERVICE = "AWS::ECS::Service"
    AWS_ECS_TASKDEFINITION = "AWS::ECS::TaskDefinition"
    AWS_EFS_ACCESSPOINT = "AWS::EFS::AccessPoint"
    AWS_EFS_FILESYSTEM = "AWS::EFS::FileSystem"
    AWS_EKS_CLUSTER = "AWS::EKS::Cluster"
    AWS_OPENSEARCH_DOMAIN = "AWS::OpenSearch::Domain"
    AWS_EC2_TRANSITGATEWAY = "AWS::EC2::TransitGateway"
    AWS_KINESIS_STREAM = "AWS::Kinesis::Stream"
    AWS_KINESIS_STREAMCONSUMER = "AWS::Kinesis::StreamConsumer"
    AWS_CODEDEPLOY_APPLICATION = "AWS::CodeDeploy::Application"
    AWS_CODEDEPLOY_DEPLOYMENTCONFIG = "AWS::CodeDeploy::DeploymentConfig"
    AWS_CODEDEPLOY_DEPLOYMENTGROUP = "AWS::CodeDeploy::DeploymentGroup"
    AWS_EC2_LAUNCHTEMPLATE = "AWS::EC2::LaunchTemplate"
    AWS_ECR_PUBLICREPOSITORY = "AWS::ECR::PublicRepository"
    AWS_GUARDDUTY_DETECTOR = "AWS::GuardDuty::Detector"
    AWS_EMR_SECURITYCONFIGURATION = "AWS::EMR::SecurityConfiguration"
    AWS_SAGEMAKER_CODEREPOSITORY = "AWS::SageMaker::CodeRepository"
    AWS_ROUTE53RESOLVER_RESOLVERENDPOINT = "AWS::Route53Resolver::ResolverEndpoint"
    AWS_ROUTE53RESOLVER_RESOLVERRULE = "AWS::Route53Resolver::ResolverRule"
    AWS_ROUTE53RESOLVER_RESOLVERRULEASSOCIATION = "AWS::Route53Resolver::ResolverRuleAssociation"
    AWS_DMS_REPLICATIONSUBNETGROUP = "AWS::DMS::ReplicationSubnetGroup"
    AWS_DMS_EVENTSUBSCRIPTION = "AWS::DMS::EventSubscription"
    AWS_MSK_CLUSTER = "AWS::MSK::Cluster"
    AWS_STEPFUNCTIONS_ACTIVITY = "AWS::StepFunctions::Activity"
    AWS_WORKSPACES_WORKSPACE = "AWS::WorkSpaces::Workspace"
    AWS_WORKSPACES_CONNECTIONALIAS = "AWS::WorkSpaces::ConnectionAlias"
    AWS_SAGEMAKER_MODEL = "AWS::SageMaker::Model"
    AWS_ELASTICLOADBALANCINGV2_LISTENER = "AWS::ElasticLoadBalancingV2::Listener"
    AWS_STEPFUNCTIONS_STATEMACHINE = "AWS::StepFunctions::StateMachine"
    AWS_BATCH_JOBQUEUE = "AWS::Batch::JobQueue"
    AWS_BATCH_COMPUTEENVIRONMENT = "AWS::Batch::ComputeEnvironment"
    AWS_ACCESSANALYZER_ANALYZER = "AWS::AccessAnalyzer::Analyzer"
    AWS_ATHENA_WORKGROUP = "AWS::Athena::WorkGroup"
    AWS_ATHENA_DATACATALOG = "AWS::Athena::DataCatalog"
    AWS_DETECTIVE_GRAPH = "AWS::Detective::Graph"
    AWS_GLOBALACCELERATOR_ACCELERATOR = "AWS::GlobalAccelerator::Accelerator"
    AWS_GLOBALACCELERATOR_ENDPOINTGROUP = "AWS::GlobalAccelerator::EndpointGroup"
    AWS_GLOBALACCELERATOR_LISTENER = "AWS::GlobalAccelerator::Listener"
    AWS_EC2_TRANSITGATEWAYATTACHMENT = "AWS::EC2::TransitGatewayAttachment"
    AWS_EC2_TRANSITGATEWAYROUTETABLE = "AWS::EC2::TransitGatewayRouteTable"
    AWS_DMS_CERTIFICATE = "AWS::DMS::Certificate"
    AWS_APPCONFIG_APPLICATION = "AWS::AppConfig::Application"
    AWS_APPSYNC_GRAPHQLAPI = "AWS::AppSync::GraphQLApi"
    AWS_DATASYNC_LOCATIONSMB = "AWS::DataSync::LocationSMB"
    AWS_DATASYNC_LOCATIONFSXLUSTRE = "AWS::DataSync::LocationFSxLustre"
    AWS_DATASYNC_LOCATIONS3 = "AWS::DataSync::LocationS3"
    AWS_DATASYNC_LOCATIONEFS = "AWS::DataSync::LocationEFS"
    AWS_DATASYNC_TASK = "AWS::DataSync::Task"
    AWS_DATASYNC_LOCATIONNFS = "AWS::DataSync::LocationNFS"
    AWS_EC2_NETWORKINSIGHTSACCESSSCOPEANALYSIS = "AWS::EC2::NetworkInsightsAccessScopeAnalysis"
    AWS_EKS_FARGATEPROFILE = "AWS::EKS::FargateProfile"
    AWS_GLUE_JOB = "AWS::Glue::Job"
    AWS_GUARDDUTY_THREATINTELSET = "AWS::GuardDuty::ThreatIntelSet"
    AWS_GUARDDUTY_IPSET = "AWS::GuardDuty::IPSet"
    AWS_SAGEMAKER_WORKTEAM = "AWS::SageMaker::Workteam"
    AWS_SAGEMAKER_NOTEBOOKINSTANCELIFECYCLECONFIG = "AWS::SageMaker::NotebookInstanceLifecycleConfig"
    AWS_SERVICEDISCOVERY_SERVICE = "AWS::ServiceDiscovery::Service"
    AWS_SERVICEDISCOVERY_PUBLICDNSNAMESPACE = "AWS::ServiceDiscovery::PublicDnsNamespace"
    AWS_SES_CONTACTLIST = "AWS::SES::ContactList"
    AWS_SES_CONFIGURATIONSET = "AWS::SES::ConfigurationSet"
    AWS_ROUTE53_HOSTEDZONE = "AWS::Route53::HostedZone"
    AWS_IOTEVENTS_INPUT = "AWS::IoTEvents::Input"
    AWS_IOTEVENTS_DETECTORMODEL = "AWS::IoTEvents::DetectorModel"
    AWS_IOTEVENTS_ALARMMODEL = "AWS::IoTEvents::AlarmModel"
    AWS_SERVICEDISCOVERY_HTTPNAMESPACE = "AWS::ServiceDiscovery::HttpNamespace"
    AWS_EVENTS_EVENTBUS = "AWS::Events::EventBus"
    AWS_IMAGEBUILDER_CONTAINERRECIPE = "AWS::ImageBuilder::ContainerRecipe"
    AWS_IMAGEBUILDER_DISTRIBUTIONCONFIGURATION = "AWS::ImageBuilder::DistributionConfiguration"
    AWS_IMAGEBUILDER_INFRASTRUCTURECONFIGURATION = "AWS::ImageBuilder::InfrastructureConfiguration"
    AWS_DATASYNC_LOCATIONOBJECTSTORAGE = "AWS::DataSync::LocationObjectStorage"
    AWS_DATASYNC_LOCATIONHDFS = "AWS::DataSync::LocationHDFS"
    AWS_GLUE_CLASSIFIER = "AWS::Glue::Classifier"
    AWS_ROUTE53RECOVERYREADINESS_CELL = "AWS::Route53RecoveryReadiness::Cell"
    AWS_ROUTE53RECOVERYREADINESS_READINESSCHECK = "AWS::Route53RecoveryReadiness::ReadinessCheck"
    AWS_ECR_REGISTRYPOLICY = "AWS::ECR::RegistryPolicy"
    AWS_BACKUP_REPORTPLAN = "AWS::Backup::ReportPlan"
    AWS_LIGHTSAIL_CERTIFICATE = "AWS::Lightsail::Certificate"
    AWS_RUM_APPMONITOR = "AWS::RUM::AppMonitor"
    AWS_EVENTS_ENDPOINT = "AWS::Events::Endpoint"
    AWS_SES_RECEIPTRULESET = "AWS::SES::ReceiptRuleSet"
    AWS_EVENTS_ARCHIVE = "AWS::Events::Archive"
    AWS_EVENTS_APIDESTINATION = "AWS::Events::ApiDestination"
    AWS_LIGHTSAIL_DISK = "AWS::Lightsail::Disk"
    AWS_FIS_EXPERIMENTTEMPLATE = "AWS::FIS::ExperimentTemplate"
    AWS_DATASYNC_LOCATIONFSXWINDOWS = "AWS::DataSync::LocationFSxWindows"
    AWS_SES_RECEIPTFILTER = "AWS::SES::ReceiptFilter"
    AWS_GUARDDUTY_FILTER = "AWS::GuardDuty::Filter"
    AWS_SES_TEMPLATE = "AWS::SES::Template"
    AWS_AMAZONMQ_BROKER = "AWS::AmazonMQ::Broker"
    AWS_APPCONFIG_ENVIRONMENT = "AWS::AppConfig::Environment"
    AWS_APPCONFIG_CONFIGURATIONPROFILE = "AWS::AppConfig::ConfigurationProfile"
    AWS_CLOUD9_ENVIRONMENTEC2 = "AWS::Cloud9::EnvironmentEC2"
    AWS_EVENTSCHEMAS_REGISTRY = "AWS::EventSchemas::Registry"
    AWS_EVENTSCHEMAS_REGISTRYPOLICY = "AWS::EventSchemas::RegistryPolicy"
    AWS_EVENTSCHEMAS_DISCOVERER = "AWS::EventSchemas::Discoverer"
    AWS_FRAUDDETECTOR_LABEL = "AWS::FraudDetector::Label"
    AWS_FRAUDDETECTOR_ENTITYTYPE = "AWS::FraudDetector::EntityType"
    AWS_FRAUDDETECTOR_VARIABLE = "AWS::FraudDetector::Variable"
    AWS_FRAUDDETECTOR_OUTCOME = "AWS::FraudDetector::Outcome"
    AWS_IOT_AUTHORIZER = "AWS::IoT::Authorizer"
    AWS_IOT_SECURITYPROFILE = "AWS::IoT::SecurityProfile"
    AWS_IOT_ROLEALIAS = "AWS::IoT::RoleAlias"
    AWS_IOT_DIMENSION = "AWS::IoT::Dimension"
    AWS_IOTANALYTICS_DATASTORE = "AWS::IoTAnalytics::Datastore"
    AWS_LIGHTSAIL_BUCKET = "AWS::Lightsail::Bucket"
    AWS_LIGHTSAIL_STATICIP = "AWS::Lightsail::StaticIp"
    AWS_MEDIAPACKAGE_PACKAGINGGROUP = "AWS::MediaPackage::PackagingGroup"
    AWS_ROUTE53RECOVERYREADINESS_RECOVERYGROUP = "AWS::Route53RecoveryReadiness::RecoveryGroup"
    AWS_RESILIENCEHUB_RESILIENCYPOLICY = "AWS::ResilienceHub::ResiliencyPolicy"
    AWS_TRANSFER_WORKFLOW = "AWS::Transfer::Workflow"
    AWS_EKS_IDENTITYPROVIDERCONFIG = "AWS::EKS::IdentityProviderConfig"
    AWS_EKS_ADDON = "AWS::EKS::Addon"
    AWS_GLUE_MLTRANSFORM = "AWS::Glue::MLTransform"
    AWS_IOT_POLICY = "AWS::IoT::Policy"
    AWS_IOT_MITIGATIONACTION = "AWS::IoT::MitigationAction"
    AWS_IOTTWINMAKER_WORKSPACE = "AWS::IoTTwinMaker::Workspace"
    AWS_IOTTWINMAKER_ENTITY = "AWS::IoTTwinMaker::Entity"
    AWS_IOTANALYTICS_DATASET = "AWS::IoTAnalytics::Dataset"
    AWS_IOTANALYTICS_PIPELINE = "AWS::IoTAnalytics::Pipeline"
    AWS_IOTANALYTICS_CHANNEL = "AWS::IoTAnalytics::Channel"
    AWS_IOTSITEWISE_DASHBOARD = "AWS::IoTSiteWise::Dashboard"
    AWS_IOTSITEWISE_PROJECT = "AWS::IoTSiteWise::Project"
    AWS_IOTSITEWISE_PORTAL = "AWS::IoTSiteWise::Portal"
    AWS_IOTSITEWISE_ASSETMODEL = "AWS::IoTSiteWise::AssetModel"
    AWS_IVS_CHANNEL = "AWS::IVS::Channel"
    AWS_IVS_RECORDINGCONFIGURATION = "AWS::IVS::RecordingConfiguration"
    AWS_IVS_PLAYBACKKEYPAIR = "AWS::IVS::PlaybackKeyPair"
    AWS_KINESISANALYTICSV2_APPLICATION = "AWS::KinesisAnalyticsV2::Application"
    AWS_RDS_GLOBALCLUSTER = "AWS::RDS::GlobalCluster"
    AWS_S3_MULTIREGIONACCESSPOINT = "AWS::S3::MultiRegionAccessPoint"
    AWS_DEVICEFARM_TESTGRIDPROJECT = "AWS::DeviceFarm::TestGridProject"
    AWS_BUDGETS_BUDGETSACTION = "AWS::Budgets::BudgetsAction"
    AWS_LEX_BOT = "AWS::Lex::Bot"
    AWS_CODEGURUREVIEWER_REPOSITORYASSOCIATION = "AWS::CodeGuruReviewer::RepositoryAssociation"
    AWS_IOT_CUSTOMMETRIC = "AWS::IoT::CustomMetric"
    AWS_ROUTE53RESOLVER_FIREWALLDOMAINLIST = "AWS::Route53Resolver::FirewallDomainList"
    AWS_ROBOMAKER_ROBOTAPPLICATIONVERSION = "AWS::RoboMaker::RobotApplicationVersion"
    AWS_EC2_TRAFFICMIRRORSESSION = "AWS::EC2::TrafficMirrorSession"
    AWS_IOTSITEWISE_GATEWAY = "AWS::IoTSiteWise::Gateway"
    AWS_LEX_BOTALIAS = "AWS::Lex::BotAlias"
    AWS_LOOKOUTMETRICS_ALERT = "AWS::LookoutMetrics::Alert"
    AWS_IOT_ACCOUNTAUDITCONFIGURATION = "AWS::IoT::AccountAuditConfiguration"
    AWS_EC2_TRAFFICMIRRORTARGET = "AWS::EC2::TrafficMirrorTarget"
    AWS_S3_STORAGELENS = "AWS::S3::StorageLens"
    AWS_IOT_SCHEDULEDAUDIT = "AWS::IoT::ScheduledAudit"
    AWS_EVENTS_CONNECTION = "AWS::Events::Connection"
    AWS_EVENTSCHEMAS_SCHEMA = "AWS::EventSchemas::Schema"
    AWS_MEDIAPACKAGE_PACKAGINGCONFIGURATION = "AWS::MediaPackage::PackagingConfiguration"
    AWS_KINESISVIDEO_SIGNALINGCHANNEL = "AWS::KinesisVideo::SignalingChannel"
    AWS_APPSTREAM_DIRECTORYCONFIG = "AWS::AppStream::DirectoryConfig"
    AWS_LOOKOUTVISION_PROJECT = "AWS::LookoutVision::Project"
    AWS_ROUTE53RECOVERYCONTROL_CLUSTER = "AWS::Route53RecoveryControl::Cluster"
    AWS_ROUTE53RECOVERYCONTROL_SAFETYRULE = "AWS::Route53RecoveryControl::SafetyRule"
    AWS_ROUTE53RECOVERYCONTROL_CONTROLPANEL = "AWS::Route53RecoveryControl::ControlPanel"
    AWS_ROUTE53RECOVERYCONTROL_ROUTINGCONTROL = "AWS::Route53RecoveryControl::RoutingControl"
    AWS_ROUTE53RECOVERYREADINESS_RESOURCESET = "AWS::Route53RecoveryReadiness::ResourceSet"
    AWS_ROBOMAKER_SIMULATIONAPPLICATION = "AWS::RoboMaker::SimulationApplication"
    AWS_ROBOMAKER_ROBOTAPPLICATION = "AWS::RoboMaker::RobotApplication"
    AWS_HEALTHLAKE_FHIRDATASTORE = "AWS::HealthLake::FHIRDatastore"
    AWS_PINPOINT_SEGMENT = "AWS::Pinpoint::Segment"
    AWS_PINPOINT_APPLICATIONSETTINGS = "AWS::Pinpoint::ApplicationSettings"
    AWS_EVENTS_RULE = "AWS::Events::Rule"
    AWS_EC2_DHCPOPTIONS = "AWS::EC2::DHCPOptions"
    AWS_EC2_NETWORKINSIGHTSPATH = "AWS::EC2::NetworkInsightsPath"
    AWS_EC2_TRAFFICMIRRORFILTER = "AWS::EC2::TrafficMirrorFilter"
    AWS_EC2_IPAM = "AWS::EC2::IPAM"
    AWS_IOTTWINMAKER_SCENE = "AWS::IoTTwinMaker::Scene"
    AWS_NETWORKMANAGER_TRANSITGATEWAYREGISTRATION = "AWS::NetworkManager::TransitGatewayRegistration"
    AWS_CUSTOMERPROFILES_DOMAIN = "AWS::CustomerProfiles::Domain"
    AWS_AUTOSCALING_WARMPOOL = "AWS::AutoScaling::WarmPool"
    AWS_CONNECT_PHONENUMBER = "AWS::Connect::PhoneNumber"
    AWS_APPCONFIG_DEPLOYMENTSTRATEGY = "AWS::AppConfig::DeploymentStrategy"
    AWS_APPFLOW_FLOW = "AWS::AppFlow::Flow"
    AWS_AUDITMANAGER_ASSESSMENT = "AWS::AuditManager::Assessment"
    AWS_CLOUDWATCH_METRICSTREAM = "AWS::CloudWatch::MetricStream"
    AWS_DEVICEFARM_INSTANCEPROFILE = "AWS::DeviceFarm::InstanceProfile"
    AWS_DEVICEFARM_PROJECT = "AWS::DeviceFarm::Project"
    AWS_EC2_EC2FLEET = "AWS::EC2::EC2Fleet"
    AWS_EC2_SUBNETROUTETABLEASSOCIATION = "AWS::EC2::SubnetRouteTableAssociation"
    AWS_ECR_PULLTHROUGHCACHERULE = "AWS::ECR::PullThroughCacheRule"
    AWS_GROUNDSTATION_CONFIG = "AWS::GroundStation::Config"
    AWS_IMAGEBUILDER_IMAGEPIPELINE = "AWS::ImageBuilder::ImagePipeline"
    AWS_IOT_FLEETMETRIC = "AWS::IoT::FleetMetric"
    AWS_IOTWIRELESS_SERVICEPROFILE = "AWS::IoTWireless::ServiceProfile"
    AWS_NETWORKMANAGER_DEVICE = "AWS::NetworkManager::Device"
    AWS_NETWORKMANAGER_GLOBALNETWORK = "AWS::NetworkManager::GlobalNetwork"
    AWS_NETWORKMANAGER_LINK = "AWS::NetworkManager::Link"
    AWS_NETWORKMANAGER_SITE = "AWS::NetworkManager::Site"
    AWS_PANORAMA_PACKAGE = "AWS::Panorama::Package"
    AWS_PINPOINT_APP = "AWS::Pinpoint::App"
    AWS_REDSHIFT_SCHEDULEDACTION = "AWS::Redshift::ScheduledAction"
    AWS_ROUTE53RESOLVER_FIREWALLRULEGROUPASSOCIATION = "AWS::Route53Resolver::FirewallRuleGroupAssociation"
    AWS_SAGEMAKER_APPIMAGECONFIG = "AWS::SageMaker::AppImageConfig"
    AWS_SAGEMAKER_IMAGE = "AWS::SageMaker::Image"
    AWS_ECS_TASKSET = "AWS::ECS::TaskSet"
    AWS_CASSANDRA_KEYSPACE = "AWS::Cassandra::Keyspace"
    AWS_SIGNER_SIGNINGPROFILE = "AWS::Signer::SigningProfile"
    AWS_AMPLIFY_APP = "AWS::Amplify::App"
    AWS_APPMESH_VIRTUALNODE = "AWS::AppMesh::VirtualNode"
    AWS_APPMESH_VIRTUALSERVICE = "AWS::AppMesh::VirtualService"
    AWS_APPRUNNER_VPCCONNECTOR = "AWS::AppRunner::VpcConnector"
    AWS_APPSTREAM_APPLICATION = "AWS::AppStream::Application"
    AWS_CODEARTIFACT_REPOSITORY = "AWS::CodeArtifact::Repository"
    AWS_EC2_PREFIXLIST = "AWS::EC2::PrefixList"
    AWS_EC2_SPOTFLEET = "AWS::EC2::SpotFleet"
    AWS_EVIDENTLY_PROJECT = "AWS::Evidently::Project"
    AWS_FORECAST_DATASET = "AWS::Forecast::Dataset"
    AWS_IAM_SAMLPROVIDER = "AWS::IAM::SAMLProvider"
    AWS_IAM_SERVERCERTIFICATE = "AWS::IAM::ServerCertificate"
    AWS_PINPOINT_CAMPAIGN = "AWS::Pinpoint::Campaign"
    AWS_PINPOINT_INAPPTEMPLATE = "AWS::Pinpoint::InAppTemplate"
    AWS_SAGEMAKER_DOMAIN = "AWS::SageMaker::Domain"
    AWS_TRANSFER_AGREEMENT = "AWS::Transfer::Agreement"
    AWS_TRANSFER_CONNECTOR = "AWS::Transfer::Connector"
    AWS_KINESISFIREHOSE_DELIVERYSTREAM = "AWS::KinesisFirehose::DeliveryStream"
    AWS_AMPLIFY_BRANCH = "AWS::Amplify::Branch"
    AWS_APPINTEGRATIONS_EVENTINTEGRATION = "AWS::AppIntegrations::EventIntegration"
    AWS_APPMESH_ROUTE = "AWS::AppMesh::Route"
    AWS_ATHENA_PREPAREDSTATEMENT = "AWS::Athena::PreparedStatement"
    AWS_EC2_IPAMSCOPE = "AWS::EC2::IPAMScope"
    AWS_EVIDENTLY_LAUNCH = "AWS::Evidently::Launch"
    AWS_FORECAST_DATASETGROUP = "AWS::Forecast::DatasetGroup"
    AWS_GREENGRASSV2_COMPONENTVERSION = "AWS::GreengrassV2::ComponentVersion"
    AWS_GROUNDSTATION_MISSIONPROFILE = "AWS::GroundStation::MissionProfile"
    AWS_MEDIACONNECT_FLOWENTITLEMENT = "AWS::MediaConnect::FlowEntitlement"
    AWS_MEDIACONNECT_FLOWVPCINTERFACE = "AWS::MediaConnect::FlowVpcInterface"
    AWS_MEDIATAILOR_PLAYBACKCONFIGURATION = "AWS::MediaTailor::PlaybackConfiguration"
    AWS_MSK_CONFIGURATION = "AWS::MSK::Configuration"
    AWS_PERSONALIZE_DATASET = "AWS::Personalize::Dataset"
    AWS_PERSONALIZE_SCHEMA = "AWS::Personalize::Schema"
    AWS_PERSONALIZE_SOLUTION = "AWS::Personalize::Solution"
    AWS_PINPOINT_EMAILTEMPLATE = "AWS::Pinpoint::EmailTemplate"
    AWS_PINPOINT_EVENTSTREAM = "AWS::Pinpoint::EventStream"
    AWS_RESILIENCEHUB_APP = "AWS::ResilienceHub::App"
    AWS_ACMPCA_CERTIFICATEAUTHORITY = "AWS::ACMPCA::CertificateAuthority"
    AWS_APPCONFIG_HOSTEDCONFIGURATIONVERSION = "AWS::AppConfig::HostedConfigurationVersion"
    AWS_APPMESH_VIRTUALGATEWAY = "AWS::AppMesh::VirtualGateway"
    AWS_APPMESH_VIRTUALROUTER = "AWS::AppMesh::VirtualRouter"
    AWS_APPRUNNER_SERVICE = "AWS::AppRunner::Service"
    AWS_CUSTOMERPROFILES_OBJECTTYPE = "AWS::CustomerProfiles::ObjectType"
    AWS_DMS_ENDPOINT = "AWS::DMS::Endpoint"
    AWS_EC2_CAPACITYRESERVATION = "AWS::EC2::CapacityReservation"
    AWS_EC2_CLIENTVPNENDPOINT = "AWS::EC2::ClientVpnEndpoint"
    AWS_KENDRA_INDEX = "AWS::Kendra::Index"
    AWS_KINESISVIDEO_STREAM = "AWS::KinesisVideo::Stream"
    AWS_LOGS_DESTINATION = "AWS::Logs::Destination"
    AWS_PINPOINT_EMAILCHANNEL = "AWS::Pinpoint::EmailChannel"
    AWS_S3_ACCESSPOINT = "AWS::S3::AccessPoint"
    AWS_NETWORKMANAGER_CUSTOMERGATEWAYASSOCIATION = "AWS::NetworkManager::CustomerGatewayAssociation"
    AWS_NETWORKMANAGER_LINKASSOCIATION = "AWS::NetworkManager::LinkAssociation"
    AWS_IOTWIRELESS_MULTICASTGROUP = "AWS::IoTWireless::MulticastGroup"
    AWS_PERSONALIZE_DATASETGROUP = "AWS::Personalize::DatasetGroup"
    AWS_IOTTWINMAKER_COMPONENTTYPE = "AWS::IoTTwinMaker::ComponentType"
    AWS_CODEBUILD_REPORTGROUP = "AWS::CodeBuild::ReportGroup"
    AWS_SAGEMAKER_FEATUREGROUP = "AWS::SageMaker::FeatureGroup"
    AWS_MSK_BATCHSCRAMSECRET = "AWS::MSK::BatchScramSecret"
    AWS_APPSTREAM_STACK = "AWS::AppStream::Stack"
    AWS_IOT_JOBTEMPLATE = "AWS::IoT::JobTemplate"
    AWS_IOTWIRELESS_FUOTATASK = "AWS::IoTWireless::FuotaTask"
    AWS_IOT_PROVISIONINGTEMPLATE = "AWS::IoT::ProvisioningTemplate"
    AWS_INSPECTORV2_FILTER = "AWS::InspectorV2::Filter"
    AWS_ROUTE53RESOLVER_RESOLVERQUERYLOGGINGCONFIGASSOCIATION = "AWS::Route53Resolver::ResolverQueryLoggingConfigAssociation"
    AWS_SERVICEDISCOVERY_INSTANCE = "AWS::ServiceDiscovery::Instance"
    AWS_TRANSFER_CERTIFICATE = "AWS::Transfer::Certificate"
    AWS_MEDIACONNECT_FLOWSOURCE = "AWS::MediaConnect::FlowSource"
    AWS_APS_RULEGROUPSNAMESPACE = "AWS::APS::RuleGroupsNamespace"
    AWS_CODEGURUPROFILER_PROFILINGGROUP = "AWS::CodeGuruProfiler::ProfilingGroup"
    AWS_ROUTE53RESOLVER_RESOLVERQUERYLOGGINGCONFIG = "AWS::Route53Resolver::ResolverQueryLoggingConfig"
    AWS_BATCH_SCHEDULINGPOLICY = "AWS::Batch::SchedulingPolicy"
    AWS_ACMPCA_CERTIFICATEAUTHORITYACTIVATION = "AWS::ACMPCA::CertificateAuthorityActivation"
    AWS_APPMESH_GATEWAYROUTE = "AWS::AppMesh::GatewayRoute"
    AWS_APPMESH_MESH = "AWS::AppMesh::Mesh"
    AWS_CONNECT_INSTANCE = "AWS::Connect::Instance"
    AWS_CONNECT_QUICKCONNECT = "AWS::Connect::QuickConnect"
    AWS_EC2_CARRIERGATEWAY = "AWS::EC2::CarrierGateway"
    AWS_EC2_IPAMPOOL = "AWS::EC2::IPAMPool"
    AWS_EC2_TRANSITGATEWAYCONNECT = "AWS::EC2::TransitGatewayConnect"
    AWS_EC2_TRANSITGATEWAYMULTICASTDOMAIN = "AWS::EC2::TransitGatewayMulticastDomain"
    AWS_ECS_CAPACITYPROVIDER = "AWS::ECS::CapacityProvider"
    AWS_IAM_INSTANCEPROFILE = "AWS::IAM::InstanceProfile"
    AWS_IOT_CACERTIFICATE = "AWS::IoT::CACertificate"
    AWS_IOTTWINMAKER_SYNCJOB = "AWS::IoTTwinMaker::SyncJob"
    AWS_KAFKACONNECT_CONNECTOR = "AWS::KafkaConnect::Connector"
    AWS_LAMBDA_CODESIGNINGCONFIG = "AWS::Lambda::CodeSigningConfig"
    AWS_NETWORKMANAGER_CONNECTPEER = "AWS::NetworkManager::ConnectPeer"
    AWS_RESOURCEEXPLORER2_INDEX = "AWS::ResourceExplorer2::Index"
    AWS_APPSTREAM_FLEET = "AWS::AppStream::Fleet"
    AWS_COGNITO_USERPOOL = "AWS::Cognito::UserPool"
    AWS_COGNITO_USERPOOLCLIENT = "AWS::Cognito::UserPoolClient"
    AWS_COGNITO_USERPOOLGROUP = "AWS::Cognito::UserPoolGroup"
    AWS_EC2_NETWORKINSIGHTSACCESSSCOPE = "AWS::EC2::NetworkInsightsAccessScope"
    AWS_EC2_NETWORKINSIGHTSANALYSIS = "AWS::EC2::NetworkInsightsAnalysis"
    AWS_GRAFANA_WORKSPACE = "AWS::Grafana::Workspace"
    AWS_GROUNDSTATION_DATAFLOWENDPOINTGROUP = "AWS::GroundStation::DataflowEndpointGroup"
    AWS_IMAGEBUILDER_IMAGERECIPE = "AWS::ImageBuilder::ImageRecipe"
    AWS_KMS_ALIAS = "AWS::KMS::Alias"
    AWS_M2_ENVIRONMENT = "AWS::M2::Environment"
    AWS_QUICKSIGHT_DATASOURCE = "AWS::QuickSight::DataSource"
    AWS_QUICKSIGHT_TEMPLATE = "AWS::QuickSight::Template"
    AWS_QUICKSIGHT_THEME = "AWS::QuickSight::Theme"
    AWS_RDS_OPTIONGROUP = "AWS::RDS::OptionGroup"
    AWS_REDSHIFT_ENDPOINTACCESS = "AWS::Redshift::EndpointAccess"
    AWS_ROUTE53RESOLVER_FIREWALLRULEGROUP = "AWS::Route53Resolver::FirewallRuleGroup"
    AWS_SSM_DOCUMENT = "AWS::SSM::Document"
    AWS_APPCONFIG_EXTENSIONASSOCIATION = "AWS::AppConfig::ExtensionAssociation"
    AWS_APPINTEGRATIONS_APPLICATION = "AWS::AppIntegrations::Application"
    AWS_APPSYNC_APICACHE = "AWS::AppSync::ApiCache"
    AWS_BEDROCK_GUARDRAIL = "AWS::Bedrock::Guardrail"
    AWS_BEDROCK_KNOWLEDGEBASE = "AWS::Bedrock::KnowledgeBase"
    AWS_COGNITO_IDENTITYPOOL = "AWS::Cognito::IdentityPool"
    AWS_CONNECT_RULE = "AWS::Connect::Rule"
    AWS_CONNECT_USER = "AWS::Connect::User"
    AWS_EC2_CLIENTVPNTARGETNETWORKASSOCIATION = "AWS::EC2::ClientVpnTargetNetworkAssociation"
    AWS_EC2_EIPASSOCIATION = "AWS::EC2::EIPAssociation"
    AWS_EC2_IPAMRESOURCEDISCOVERY = "AWS::EC2::IPAMResourceDiscovery"
    AWS_EC2_IPAMRESOURCEDISCOVERYASSOCIATION = "AWS::EC2::IPAMResourceDiscoveryAssociation"
    AWS_EC2_INSTANCECONNECTENDPOINT = "AWS::EC2::InstanceConnectEndpoint"
    AWS_EC2_SNAPSHOTBLOCKPUBLICACCESS = "AWS::EC2::SnapshotBlockPublicAccess"
    AWS_EC2_VPCBLOCKPUBLICACCESSEXCLUSION = "AWS::EC2::VPCBlockPublicAccessExclusion"
    AWS_EC2_VPCBLOCKPUBLICACCESSOPTIONS = "AWS::EC2::VPCBlockPublicAccessOptions"
    AWS_EC2_VPCENDPOINTCONNECTIONNOTIFICATION = "AWS::EC2::VPCEndpointConnectionNotification"
    AWS_EC2_VPNCONNECTIONROUTE = "AWS::EC2::VPNConnectionRoute"
    AWS_EVIDENTLY_SEGMENT = "AWS::Evidently::Segment"
    AWS_IAM_OIDCPROVIDER = "AWS::IAM::OIDCProvider"
    AWS_INSPECTORV2_ACTIVATION = "AWS::InspectorV2::Activation"
    AWS_MSK_CLUSTERPOLICY = "AWS::MSK::ClusterPolicy"
    AWS_MSK_VPCCONNECTION = "AWS::MSK::VpcConnection"
    AWS_MEDIACONNECT_GATEWAY = "AWS::MediaConnect::Gateway"
    AWS_MEMORYDB_SUBNETGROUP = "AWS::MemoryDB::SubnetGroup"
    AWS_OPENSEARCHSERVERLESS_COLLECTION = "AWS::OpenSearchServerless::Collection"
    AWS_OPENSEARCHSERVERLESS_VPCENDPOINT = "AWS::OpenSearchServerless::VpcEndpoint"
    AWS_REDSHIFT_ENDPOINTAUTHORIZATION = "AWS::Redshift::EndpointAuthorization"
    AWS_ROUTE53PROFILES_PROFILE = "AWS::Route53Profiles::Profile"
    AWS_S3_STORAGELENSGROUP = "AWS::S3::StorageLensGroup"
    AWS_S3EXPRESS_BUCKETPOLICY = "AWS::S3Express::BucketPolicy"
    AWS_S3EXPRESS_DIRECTORYBUCKET = "AWS::S3Express::DirectoryBucket"
    AWS_SAGEMAKER_INFERENCEEXPERIMENT = "AWS::SageMaker::InferenceExperiment"
    AWS_SECURITYHUB_STANDARD = "AWS::SecurityHub::Standard"
    AWS_TRANSFER_PROFILE = "AWS::Transfer::Profile"


class ResourceValueType:
    """ResourceValueType enum values."""

    RESOURCE_ID = "RESOURCE_ID"


class SortBy:
    """SortBy enum values."""

    SCORE = "SCORE"


class SortOrder:
    """SortOrder enum values."""

    ASCENDING = "ASCENDING"
    DESCENDING = "DESCENDING"


# Convenient aliases for enum values
ACCOUNT_ID = AggregateConformancePackComplianceSummaryGroupKey.ACCOUNT_ID
AWS_REGION = AggregateConformancePackComplianceSummaryGroupKey.AWS_REGION
FAILED = AggregatedSourceStatusType.FAILED
SUCCEEDED = AggregatedSourceStatusType.SUCCEEDED
OUTDATED = AggregatedSourceStatusType.OUTDATED
ACCOUNT = AggregatedSourceType.ACCOUNT
ORGANIZATION = AggregatedSourceType.ORGANIZATION
INCLUDE = AggregatorFilterType.INCLUDE
REVERSE = ChronologicalOrder.REVERSE
FORWARD = ChronologicalOrder.FORWARD
COMPLIANT = ComplianceType.COMPLIANT
NON_COMPLIANT = ComplianceType.NON_COMPLIANT
NOT_APPLICABLE = ComplianceType.NOT_APPLICABLE
INSUFFICIENT_DATA = ComplianceType.INSUFFICIENT_DATA
ACCOUNT_ID = ConfigRuleComplianceSummaryGroupKey.ACCOUNT_ID
AWS_REGION = ConfigRuleComplianceSummaryGroupKey.AWS_REGION
ACTIVE = ConfigRuleState.ACTIVE
DELETING = ConfigRuleState.DELETING
DELETING_RESULTS = ConfigRuleState.DELETING_RESULTS
EVALUATING = ConfigRuleState.EVALUATING
OK = ConfigurationItemStatus.OK
RESOURCEDISCOVERED = ConfigurationItemStatus.RESOURCEDISCOVERED
RESOURCENOTRECORDED = ConfigurationItemStatus.RESOURCENOTRECORDED
RESOURCEDELETED = ConfigurationItemStatus.RESOURCEDELETED
RESOURCEDELETEDNOTRECORDED = ConfigurationItemStatus.RESOURCEDELETEDNOTRECORDED
RECORDINGSCOPE = ConfigurationRecorderFilterName.RECORDINGSCOPE
COMPLIANT = ConformancePackComplianceType.COMPLIANT
NON_COMPLIANT = ConformancePackComplianceType.NON_COMPLIANT
INSUFFICIENT_DATA = ConformancePackComplianceType.INSUFFICIENT_DATA
CREATE_IN_PROGRESS = ConformancePackState.CREATE_IN_PROGRESS
CREATE_COMPLETE = ConformancePackState.CREATE_COMPLETE
CREATE_FAILED = ConformancePackState.CREATE_FAILED
DELETE_IN_PROGRESS = ConformancePackState.DELETE_IN_PROGRESS
DELETE_FAILED = ConformancePackState.DELETE_FAILED
SUCCESS = DeliveryStatus.SUCCESS
FAILURE = DeliveryStatus.FAILURE
NOT_APPLICABLE = DeliveryStatus.NOT_APPLICABLE
DETECTIVE = EvaluationMode.DETECTIVE
PROACTIVE = EvaluationMode.PROACTIVE
AWS_CONFIG = EventSource.AWS_CONFIG
ONE_HOUR = MaximumExecutionFrequency.ONE_HOUR
THREE_HOURS = MaximumExecutionFrequency.THREE_HOURS
SIX_HOURS = MaximumExecutionFrequency.SIX_HOURS
TWELVE_HOURS = MaximumExecutionFrequency.TWELVE_HOURS
TWENTYFOUR_HOURS = MaximumExecutionFrequency.TWENTYFOUR_HOURS
CREATE_SUCCESSFUL = MemberAccountRuleStatus.CREATE_SUCCESSFUL
CREATE_IN_PROGRESS = MemberAccountRuleStatus.CREATE_IN_PROGRESS
CREATE_FAILED = MemberAccountRuleStatus.CREATE_FAILED
DELETE_SUCCESSFUL = MemberAccountRuleStatus.DELETE_SUCCESSFUL
DELETE_FAILED = MemberAccountRuleStatus.DELETE_FAILED
DELETE_IN_PROGRESS = MemberAccountRuleStatus.DELETE_IN_PROGRESS
UPDATE_SUCCESSFUL = MemberAccountRuleStatus.UPDATE_SUCCESSFUL
UPDATE_IN_PROGRESS = MemberAccountRuleStatus.UPDATE_IN_PROGRESS
UPDATE_FAILED = MemberAccountRuleStatus.UPDATE_FAILED
CONFIGURATIONITEMCHANGENOTIFICATION = MessageType.CONFIGURATIONITEMCHANGENOTIFICATION
CONFIGURATIONSNAPSHOTDELIVERYCOMPLETED = MessageType.CONFIGURATIONSNAPSHOTDELIVERYCOMPLETED
SCHEDULEDNOTIFICATION = MessageType.SCHEDULEDNOTIFICATION
OVERSIZEDCONFIGURATIONITEMCHANGENOTIFICATION = MessageType.OVERSIZEDCONFIGURATIONITEMCHANGENOTIFICATION
CONFIGURATIONITEMCHANGENOTIFICATION = OrganizationConfigRuleTriggerType.CONFIGURATIONITEMCHANGENOTIFICATION
OVERSIZEDCONFIGURATIONITEMCHANGENOTIFICATION = OrganizationConfigRuleTriggerType.OVERSIZEDCONFIGURATIONITEMCHANGENOTIFICATION
SCHEDULEDNOTIFICATION = OrganizationConfigRuleTriggerType.SCHEDULEDNOTIFICATION
CONFIGURATIONITEMCHANGENOTIFICATION = OrganizationConfigRuleTriggerTypeNoSN.CONFIGURATIONITEMCHANGENOTIFICATION
OVERSIZEDCONFIGURATIONITEMCHANGENOTIFICATION = OrganizationConfigRuleTriggerTypeNoSN.OVERSIZEDCONFIGURATIONITEMCHANGENOTIFICATION
CREATE_SUCCESSFUL = OrganizationResourceDetailedStatus.CREATE_SUCCESSFUL
CREATE_IN_PROGRESS = OrganizationResourceDetailedStatus.CREATE_IN_PROGRESS
CREATE_FAILED = OrganizationResourceDetailedStatus.CREATE_FAILED
DELETE_SUCCESSFUL = OrganizationResourceDetailedStatus.DELETE_SUCCESSFUL
DELETE_FAILED = OrganizationResourceDetailedStatus.DELETE_FAILED
DELETE_IN_PROGRESS = OrganizationResourceDetailedStatus.DELETE_IN_PROGRESS
UPDATE_SUCCESSFUL = OrganizationResourceDetailedStatus.UPDATE_SUCCESSFUL
UPDATE_IN_PROGRESS = OrganizationResourceDetailedStatus.UPDATE_IN_PROGRESS
UPDATE_FAILED = OrganizationResourceDetailedStatus.UPDATE_FAILED
CREATE_SUCCESSFUL = OrganizationResourceStatus.CREATE_SUCCESSFUL
CREATE_IN_PROGRESS = OrganizationResourceStatus.CREATE_IN_PROGRESS
CREATE_FAILED = OrganizationResourceStatus.CREATE_FAILED
DELETE_SUCCESSFUL = OrganizationResourceStatus.DELETE_SUCCESSFUL
DELETE_FAILED = OrganizationResourceStatus.DELETE_FAILED
DELETE_IN_PROGRESS = OrganizationResourceStatus.DELETE_IN_PROGRESS
UPDATE_SUCCESSFUL = OrganizationResourceStatus.UPDATE_SUCCESSFUL
UPDATE_IN_PROGRESS = OrganizationResourceStatus.UPDATE_IN_PROGRESS
UPDATE_FAILED = OrganizationResourceStatus.UPDATE_FAILED
CREATE_SUCCESSFUL = OrganizationRuleStatus.CREATE_SUCCESSFUL
CREATE_IN_PROGRESS = OrganizationRuleStatus.CREATE_IN_PROGRESS
CREATE_FAILED = OrganizationRuleStatus.CREATE_FAILED
DELETE_SUCCESSFUL = OrganizationRuleStatus.DELETE_SUCCESSFUL
DELETE_FAILED = OrganizationRuleStatus.DELETE_FAILED
DELETE_IN_PROGRESS = OrganizationRuleStatus.DELETE_IN_PROGRESS
UPDATE_SUCCESSFUL = OrganizationRuleStatus.UPDATE_SUCCESSFUL
UPDATE_IN_PROGRESS = OrganizationRuleStatus.UPDATE_IN_PROGRESS
UPDATE_FAILED = OrganizationRuleStatus.UPDATE_FAILED
CUSTOM_LAMBDA = Owner.CUSTOM_LAMBDA
AWS = Owner.AWS
CUSTOM_POLICY = Owner.CUSTOM_POLICY
PENDING = RecorderStatus.PENDING
SUCCESS = RecorderStatus.SUCCESS
FAILURE = RecorderStatus.FAILURE
NOTAPPLICABLE = RecorderStatus.NOTAPPLICABLE
CONTINUOUS = RecordingFrequency.CONTINUOUS
DAILY = RecordingFrequency.DAILY
INTERNAL = RecordingScope.INTERNAL
PAID = RecordingScope.PAID
ALL_SUPPORTED_RESOURCE_TYPES = RecordingStrategyType.ALL_SUPPORTED_RESOURCE_TYPES
INCLUSION_BY_RESOURCE_TYPES = RecordingStrategyType.INCLUSION_BY_RESOURCE_TYPES
EXCLUSION_BY_RESOURCE_TYPES = RecordingStrategyType.EXCLUSION_BY_RESOURCE_TYPES
QUEUED = RemediationExecutionState.QUEUED
IN_PROGRESS = RemediationExecutionState.IN_PROGRESS
SUCCEEDED = RemediationExecutionState.SUCCEEDED
FAILED = RemediationExecutionState.FAILED
UNKNOWN = RemediationExecutionState.UNKNOWN
SUCCEEDED = RemediationExecutionStepState.SUCCEEDED
PENDING = RemediationExecutionStepState.PENDING
FAILED = RemediationExecutionStepState.FAILED
IN_PROGRESS = RemediationExecutionStepState.IN_PROGRESS
EXITED = RemediationExecutionStepState.EXITED
UNKNOWN = RemediationExecutionStepState.UNKNOWN
SSM_DOCUMENT = RemediationTargetType.SSM_DOCUMENT
CFN_RESOURCE_SCHEMA = ResourceConfigurationSchemaType.CFN_RESOURCE_SCHEMA
RESOURCE_TYPE = ResourceCountGroupKey.RESOURCE_TYPE
ACCOUNT_ID = ResourceCountGroupKey.ACCOUNT_ID
AWS_REGION = ResourceCountGroupKey.AWS_REGION
IN_PROGRESS = ResourceEvaluationStatus.IN_PROGRESS
FAILED = ResourceEvaluationStatus.FAILED
SUCCEEDED = ResourceEvaluationStatus.SUCCEEDED
AWS_EC2_CUSTOMERGATEWAY = ResourceType.AWS_EC2_CUSTOMERGATEWAY
AWS_EC2_EIP = ResourceType.AWS_EC2_EIP
AWS_EC2_HOST = ResourceType.AWS_EC2_HOST
AWS_EC2_INSTANCE = ResourceType.AWS_EC2_INSTANCE
AWS_EC2_INTERNETGATEWAY = ResourceType.AWS_EC2_INTERNETGATEWAY
AWS_EC2_NETWORKACL = ResourceType.AWS_EC2_NETWORKACL
AWS_EC2_NETWORKINTERFACE = ResourceType.AWS_EC2_NETWORKINTERFACE
AWS_EC2_ROUTETABLE = ResourceType.AWS_EC2_ROUTETABLE
AWS_EC2_SECURITYGROUP = ResourceType.AWS_EC2_SECURITYGROUP
AWS_EC2_SUBNET = ResourceType.AWS_EC2_SUBNET
AWS_CLOUDTRAIL_TRAIL = ResourceType.AWS_CLOUDTRAIL_TRAIL
AWS_EC2_VOLUME = ResourceType.AWS_EC2_VOLUME
AWS_EC2_VPC = ResourceType.AWS_EC2_VPC
AWS_EC2_VPNCONNECTION = ResourceType.AWS_EC2_VPNCONNECTION
AWS_EC2_VPNGATEWAY = ResourceType.AWS_EC2_VPNGATEWAY
AWS_EC2_REGISTEREDHAINSTANCE = ResourceType.AWS_EC2_REGISTEREDHAINSTANCE
AWS_EC2_NATGATEWAY = ResourceType.AWS_EC2_NATGATEWAY
AWS_EC2_EGRESSONLYINTERNETGATEWAY = ResourceType.AWS_EC2_EGRESSONLYINTERNETGATEWAY
AWS_EC2_VPCENDPOINT = ResourceType.AWS_EC2_VPCENDPOINT
AWS_EC2_VPCENDPOINTSERVICE = ResourceType.AWS_EC2_VPCENDPOINTSERVICE
AWS_EC2_FLOWLOG = ResourceType.AWS_EC2_FLOWLOG
AWS_EC2_VPCPEERINGCONNECTION = ResourceType.AWS_EC2_VPCPEERINGCONNECTION
AWS_ELASTICSEARCH_DOMAIN = ResourceType.AWS_ELASTICSEARCH_DOMAIN
AWS_IAM_GROUP = ResourceType.AWS_IAM_GROUP
AWS_IAM_POLICY = ResourceType.AWS_IAM_POLICY
AWS_IAM_ROLE = ResourceType.AWS_IAM_ROLE
AWS_IAM_USER = ResourceType.AWS_IAM_USER
AWS_ELASTICLOADBALANCINGV2_LOADBALANCER = ResourceType.AWS_ELASTICLOADBALANCINGV2_LOADBALANCER
AWS_ACM_CERTIFICATE = ResourceType.AWS_ACM_CERTIFICATE
AWS_RDS_DBINSTANCE = ResourceType.AWS_RDS_DBINSTANCE
AWS_RDS_DBSUBNETGROUP = ResourceType.AWS_RDS_DBSUBNETGROUP
AWS_RDS_DBSECURITYGROUP = ResourceType.AWS_RDS_DBSECURITYGROUP
AWS_RDS_DBSNAPSHOT = ResourceType.AWS_RDS_DBSNAPSHOT
AWS_RDS_DBCLUSTER = ResourceType.AWS_RDS_DBCLUSTER
AWS_RDS_DBCLUSTERSNAPSHOT = ResourceType.AWS_RDS_DBCLUSTERSNAPSHOT
AWS_RDS_EVENTSUBSCRIPTION = ResourceType.AWS_RDS_EVENTSUBSCRIPTION
AWS_S3_BUCKET = ResourceType.AWS_S3_BUCKET
AWS_S3_ACCOUNTPUBLICACCESSBLOCK = ResourceType.AWS_S3_ACCOUNTPUBLICACCESSBLOCK
AWS_REDSHIFT_CLUSTER = ResourceType.AWS_REDSHIFT_CLUSTER
AWS_REDSHIFT_CLUSTERSNAPSHOT = ResourceType.AWS_REDSHIFT_CLUSTERSNAPSHOT
AWS_REDSHIFT_CLUSTERPARAMETERGROUP = ResourceType.AWS_REDSHIFT_CLUSTERPARAMETERGROUP
AWS_REDSHIFT_CLUSTERSECURITYGROUP = ResourceType.AWS_REDSHIFT_CLUSTERSECURITYGROUP
AWS_REDSHIFT_CLUSTERSUBNETGROUP = ResourceType.AWS_REDSHIFT_CLUSTERSUBNETGROUP
AWS_REDSHIFT_EVENTSUBSCRIPTION = ResourceType.AWS_REDSHIFT_EVENTSUBSCRIPTION
AWS_SSM_MANAGEDINSTANCEINVENTORY = ResourceType.AWS_SSM_MANAGEDINSTANCEINVENTORY
AWS_CLOUDWATCH_ALARM = ResourceType.AWS_CLOUDWATCH_ALARM
AWS_CLOUDFORMATION_STACK = ResourceType.AWS_CLOUDFORMATION_STACK
AWS_ELASTICLOADBALANCING_LOADBALANCER = ResourceType.AWS_ELASTICLOADBALANCING_LOADBALANCER
AWS_AUTOSCALING_AUTOSCALINGGROUP = ResourceType.AWS_AUTOSCALING_AUTOSCALINGGROUP
AWS_AUTOSCALING_LAUNCHCONFIGURATION = ResourceType.AWS_AUTOSCALING_LAUNCHCONFIGURATION
AWS_AUTOSCALING_SCALINGPOLICY = ResourceType.AWS_AUTOSCALING_SCALINGPOLICY
AWS_AUTOSCALING_SCHEDULEDACTION = ResourceType.AWS_AUTOSCALING_SCHEDULEDACTION
AWS_DYNAMODB_TABLE = ResourceType.AWS_DYNAMODB_TABLE
AWS_CODEBUILD_PROJECT = ResourceType.AWS_CODEBUILD_PROJECT
AWS_WAF_RATEBASEDRULE = ResourceType.AWS_WAF_RATEBASEDRULE
AWS_WAF_RULE = ResourceType.AWS_WAF_RULE
AWS_WAF_RULEGROUP = ResourceType.AWS_WAF_RULEGROUP
AWS_WAF_WEBACL = ResourceType.AWS_WAF_WEBACL
AWS_WAFREGIONAL_RATEBASEDRULE = ResourceType.AWS_WAFREGIONAL_RATEBASEDRULE
AWS_WAFREGIONAL_RULE = ResourceType.AWS_WAFREGIONAL_RULE
AWS_WAFREGIONAL_RULEGROUP = ResourceType.AWS_WAFREGIONAL_RULEGROUP
AWS_WAFREGIONAL_WEBACL = ResourceType.AWS_WAFREGIONAL_WEBACL
AWS_CLOUDFRONT_DISTRIBUTION = ResourceType.AWS_CLOUDFRONT_DISTRIBUTION
AWS_CLOUDFRONT_STREAMINGDISTRIBUTION = ResourceType.AWS_CLOUDFRONT_STREAMINGDISTRIBUTION
AWS_LAMBDA_FUNCTION = ResourceType.AWS_LAMBDA_FUNCTION
AWS_NETWORKFIREWALL_FIREWALL = ResourceType.AWS_NETWORKFIREWALL_FIREWALL
AWS_NETWORKFIREWALL_FIREWALLPOLICY = ResourceType.AWS_NETWORKFIREWALL_FIREWALLPOLICY
AWS_NETWORKFIREWALL_RULEGROUP = ResourceType.AWS_NETWORKFIREWALL_RULEGROUP
AWS_ELASTICBEANSTALK_APPLICATION = ResourceType.AWS_ELASTICBEANSTALK_APPLICATION
AWS_ELASTICBEANSTALK_APPLICATIONVERSION = ResourceType.AWS_ELASTICBEANSTALK_APPLICATIONVERSION
AWS_ELASTICBEANSTALK_ENVIRONMENT = ResourceType.AWS_ELASTICBEANSTALK_ENVIRONMENT
AWS_WAFV2_WEBACL = ResourceType.AWS_WAFV2_WEBACL
AWS_WAFV2_RULEGROUP = ResourceType.AWS_WAFV2_RULEGROUP
AWS_WAFV2_IPSET = ResourceType.AWS_WAFV2_IPSET
AWS_WAFV2_REGEXPATTERNSET = ResourceType.AWS_WAFV2_REGEXPATTERNSET
AWS_WAFV2_MANAGEDRULESET = ResourceType.AWS_WAFV2_MANAGEDRULESET
AWS_XRAY_ENCRYPTIONCONFIG = ResourceType.AWS_XRAY_ENCRYPTIONCONFIG
AWS_SSM_ASSOCIATIONCOMPLIANCE = ResourceType.AWS_SSM_ASSOCIATIONCOMPLIANCE
AWS_SSM_PATCHCOMPLIANCE = ResourceType.AWS_SSM_PATCHCOMPLIANCE
AWS_SHIELD_PROTECTION = ResourceType.AWS_SHIELD_PROTECTION
AWS_SHIELDREGIONAL_PROTECTION = ResourceType.AWS_SHIELDREGIONAL_PROTECTION
AWS_CONFIG_CONFORMANCEPACKCOMPLIANCE = ResourceType.AWS_CONFIG_CONFORMANCEPACKCOMPLIANCE
AWS_CONFIG_RESOURCECOMPLIANCE = ResourceType.AWS_CONFIG_RESOURCECOMPLIANCE
AWS_APIGATEWAY_STAGE = ResourceType.AWS_APIGATEWAY_STAGE
AWS_APIGATEWAY_RESTAPI = ResourceType.AWS_APIGATEWAY_RESTAPI
AWS_APIGATEWAYV2_STAGE = ResourceType.AWS_APIGATEWAYV2_STAGE
AWS_APIGATEWAYV2_API = ResourceType.AWS_APIGATEWAYV2_API
AWS_CODEPIPELINE_PIPELINE = ResourceType.AWS_CODEPIPELINE_PIPELINE
AWS_SERVICECATALOG_CLOUDFORMATIONPROVISIONEDPRODUCT = ResourceType.AWS_SERVICECATALOG_CLOUDFORMATIONPROVISIONEDPRODUCT
AWS_SERVICECATALOG_CLOUDFORMATIONPRODUCT = ResourceType.AWS_SERVICECATALOG_CLOUDFORMATIONPRODUCT
AWS_SERVICECATALOG_PORTFOLIO = ResourceType.AWS_SERVICECATALOG_PORTFOLIO
AWS_SQS_QUEUE = ResourceType.AWS_SQS_QUEUE
AWS_KMS_KEY = ResourceType.AWS_KMS_KEY
AWS_QLDB_LEDGER = ResourceType.AWS_QLDB_LEDGER
AWS_SECRETSMANAGER_SECRET = ResourceType.AWS_SECRETSMANAGER_SECRET
AWS_SNS_TOPIC = ResourceType.AWS_SNS_TOPIC
AWS_SSM_FILEDATA = ResourceType.AWS_SSM_FILEDATA
AWS_BACKUP_BACKUPPLAN = ResourceType.AWS_BACKUP_BACKUPPLAN
AWS_BACKUP_BACKUPSELECTION = ResourceType.AWS_BACKUP_BACKUPSELECTION
AWS_BACKUP_BACKUPVAULT = ResourceType.AWS_BACKUP_BACKUPVAULT
AWS_BACKUP_RECOVERYPOINT = ResourceType.AWS_BACKUP_RECOVERYPOINT
AWS_ECR_REPOSITORY = ResourceType.AWS_ECR_REPOSITORY
AWS_ECS_CLUSTER = ResourceType.AWS_ECS_CLUSTER
AWS_ECS_SERVICE = ResourceType.AWS_ECS_SERVICE
AWS_ECS_TASKDEFINITION = ResourceType.AWS_ECS_TASKDEFINITION
AWS_EFS_ACCESSPOINT = ResourceType.AWS_EFS_ACCESSPOINT
AWS_EFS_FILESYSTEM = ResourceType.AWS_EFS_FILESYSTEM
AWS_EKS_CLUSTER = ResourceType.AWS_EKS_CLUSTER
AWS_OPENSEARCH_DOMAIN = ResourceType.AWS_OPENSEARCH_DOMAIN
AWS_EC2_TRANSITGATEWAY = ResourceType.AWS_EC2_TRANSITGATEWAY
AWS_KINESIS_STREAM = ResourceType.AWS_KINESIS_STREAM
AWS_KINESIS_STREAMCONSUMER = ResourceType.AWS_KINESIS_STREAMCONSUMER
AWS_CODEDEPLOY_APPLICATION = ResourceType.AWS_CODEDEPLOY_APPLICATION
AWS_CODEDEPLOY_DEPLOYMENTCONFIG = ResourceType.AWS_CODEDEPLOY_DEPLOYMENTCONFIG
AWS_CODEDEPLOY_DEPLOYMENTGROUP = ResourceType.AWS_CODEDEPLOY_DEPLOYMENTGROUP
AWS_EC2_LAUNCHTEMPLATE = ResourceType.AWS_EC2_LAUNCHTEMPLATE
AWS_ECR_PUBLICREPOSITORY = ResourceType.AWS_ECR_PUBLICREPOSITORY
AWS_GUARDDUTY_DETECTOR = ResourceType.AWS_GUARDDUTY_DETECTOR
AWS_EMR_SECURITYCONFIGURATION = ResourceType.AWS_EMR_SECURITYCONFIGURATION
AWS_SAGEMAKER_CODEREPOSITORY = ResourceType.AWS_SAGEMAKER_CODEREPOSITORY
AWS_ROUTE53RESOLVER_RESOLVERENDPOINT = ResourceType.AWS_ROUTE53RESOLVER_RESOLVERENDPOINT
AWS_ROUTE53RESOLVER_RESOLVERRULE = ResourceType.AWS_ROUTE53RESOLVER_RESOLVERRULE
AWS_ROUTE53RESOLVER_RESOLVERRULEASSOCIATION = ResourceType.AWS_ROUTE53RESOLVER_RESOLVERRULEASSOCIATION
AWS_DMS_REPLICATIONSUBNETGROUP = ResourceType.AWS_DMS_REPLICATIONSUBNETGROUP
AWS_DMS_EVENTSUBSCRIPTION = ResourceType.AWS_DMS_EVENTSUBSCRIPTION
AWS_MSK_CLUSTER = ResourceType.AWS_MSK_CLUSTER
AWS_STEPFUNCTIONS_ACTIVITY = ResourceType.AWS_STEPFUNCTIONS_ACTIVITY
AWS_WORKSPACES_WORKSPACE = ResourceType.AWS_WORKSPACES_WORKSPACE
AWS_WORKSPACES_CONNECTIONALIAS = ResourceType.AWS_WORKSPACES_CONNECTIONALIAS
AWS_SAGEMAKER_MODEL = ResourceType.AWS_SAGEMAKER_MODEL
AWS_ELASTICLOADBALANCINGV2_LISTENER = ResourceType.AWS_ELASTICLOADBALANCINGV2_LISTENER
AWS_STEPFUNCTIONS_STATEMACHINE = ResourceType.AWS_STEPFUNCTIONS_STATEMACHINE
AWS_BATCH_JOBQUEUE = ResourceType.AWS_BATCH_JOBQUEUE
AWS_BATCH_COMPUTEENVIRONMENT = ResourceType.AWS_BATCH_COMPUTEENVIRONMENT
AWS_ACCESSANALYZER_ANALYZER = ResourceType.AWS_ACCESSANALYZER_ANALYZER
AWS_ATHENA_WORKGROUP = ResourceType.AWS_ATHENA_WORKGROUP
AWS_ATHENA_DATACATALOG = ResourceType.AWS_ATHENA_DATACATALOG
AWS_DETECTIVE_GRAPH = ResourceType.AWS_DETECTIVE_GRAPH
AWS_GLOBALACCELERATOR_ACCELERATOR = ResourceType.AWS_GLOBALACCELERATOR_ACCELERATOR
AWS_GLOBALACCELERATOR_ENDPOINTGROUP = ResourceType.AWS_GLOBALACCELERATOR_ENDPOINTGROUP
AWS_GLOBALACCELERATOR_LISTENER = ResourceType.AWS_GLOBALACCELERATOR_LISTENER
AWS_EC2_TRANSITGATEWAYATTACHMENT = ResourceType.AWS_EC2_TRANSITGATEWAYATTACHMENT
AWS_EC2_TRANSITGATEWAYROUTETABLE = ResourceType.AWS_EC2_TRANSITGATEWAYROUTETABLE
AWS_DMS_CERTIFICATE = ResourceType.AWS_DMS_CERTIFICATE
AWS_APPCONFIG_APPLICATION = ResourceType.AWS_APPCONFIG_APPLICATION
AWS_APPSYNC_GRAPHQLAPI = ResourceType.AWS_APPSYNC_GRAPHQLAPI
AWS_DATASYNC_LOCATIONSMB = ResourceType.AWS_DATASYNC_LOCATIONSMB
AWS_DATASYNC_LOCATIONFSXLUSTRE = ResourceType.AWS_DATASYNC_LOCATIONFSXLUSTRE
AWS_DATASYNC_LOCATIONS3 = ResourceType.AWS_DATASYNC_LOCATIONS3
AWS_DATASYNC_LOCATIONEFS = ResourceType.AWS_DATASYNC_LOCATIONEFS
AWS_DATASYNC_TASK = ResourceType.AWS_DATASYNC_TASK
AWS_DATASYNC_LOCATIONNFS = ResourceType.AWS_DATASYNC_LOCATIONNFS
AWS_EC2_NETWORKINSIGHTSACCESSSCOPEANALYSIS = ResourceType.AWS_EC2_NETWORKINSIGHTSACCESSSCOPEANALYSIS
AWS_EKS_FARGATEPROFILE = ResourceType.AWS_EKS_FARGATEPROFILE
AWS_GLUE_JOB = ResourceType.AWS_GLUE_JOB
AWS_GUARDDUTY_THREATINTELSET = ResourceType.AWS_GUARDDUTY_THREATINTELSET
AWS_GUARDDUTY_IPSET = ResourceType.AWS_GUARDDUTY_IPSET
AWS_SAGEMAKER_WORKTEAM = ResourceType.AWS_SAGEMAKER_WORKTEAM
AWS_SAGEMAKER_NOTEBOOKINSTANCELIFECYCLECONFIG = ResourceType.AWS_SAGEMAKER_NOTEBOOKINSTANCELIFECYCLECONFIG
AWS_SERVICEDISCOVERY_SERVICE = ResourceType.AWS_SERVICEDISCOVERY_SERVICE
AWS_SERVICEDISCOVERY_PUBLICDNSNAMESPACE = ResourceType.AWS_SERVICEDISCOVERY_PUBLICDNSNAMESPACE
AWS_SES_CONTACTLIST = ResourceType.AWS_SES_CONTACTLIST
AWS_SES_CONFIGURATIONSET = ResourceType.AWS_SES_CONFIGURATIONSET
AWS_ROUTE53_HOSTEDZONE = ResourceType.AWS_ROUTE53_HOSTEDZONE
AWS_IOTEVENTS_INPUT = ResourceType.AWS_IOTEVENTS_INPUT
AWS_IOTEVENTS_DETECTORMODEL = ResourceType.AWS_IOTEVENTS_DETECTORMODEL
AWS_IOTEVENTS_ALARMMODEL = ResourceType.AWS_IOTEVENTS_ALARMMODEL
AWS_SERVICEDISCOVERY_HTTPNAMESPACE = ResourceType.AWS_SERVICEDISCOVERY_HTTPNAMESPACE
AWS_EVENTS_EVENTBUS = ResourceType.AWS_EVENTS_EVENTBUS
AWS_IMAGEBUILDER_CONTAINERRECIPE = ResourceType.AWS_IMAGEBUILDER_CONTAINERRECIPE
AWS_IMAGEBUILDER_DISTRIBUTIONCONFIGURATION = ResourceType.AWS_IMAGEBUILDER_DISTRIBUTIONCONFIGURATION
AWS_IMAGEBUILDER_INFRASTRUCTURECONFIGURATION = ResourceType.AWS_IMAGEBUILDER_INFRASTRUCTURECONFIGURATION
AWS_DATASYNC_LOCATIONOBJECTSTORAGE = ResourceType.AWS_DATASYNC_LOCATIONOBJECTSTORAGE
AWS_DATASYNC_LOCATIONHDFS = ResourceType.AWS_DATASYNC_LOCATIONHDFS
AWS_GLUE_CLASSIFIER = ResourceType.AWS_GLUE_CLASSIFIER
AWS_ROUTE53RECOVERYREADINESS_CELL = ResourceType.AWS_ROUTE53RECOVERYREADINESS_CELL
AWS_ROUTE53RECOVERYREADINESS_READINESSCHECK = ResourceType.AWS_ROUTE53RECOVERYREADINESS_READINESSCHECK
AWS_ECR_REGISTRYPOLICY = ResourceType.AWS_ECR_REGISTRYPOLICY
AWS_BACKUP_REPORTPLAN = ResourceType.AWS_BACKUP_REPORTPLAN
AWS_LIGHTSAIL_CERTIFICATE = ResourceType.AWS_LIGHTSAIL_CERTIFICATE
AWS_RUM_APPMONITOR = ResourceType.AWS_RUM_APPMONITOR
AWS_EVENTS_ENDPOINT = ResourceType.AWS_EVENTS_ENDPOINT
AWS_SES_RECEIPTRULESET = ResourceType.AWS_SES_RECEIPTRULESET
AWS_EVENTS_ARCHIVE = ResourceType.AWS_EVENTS_ARCHIVE
AWS_EVENTS_APIDESTINATION = ResourceType.AWS_EVENTS_APIDESTINATION
AWS_LIGHTSAIL_DISK = ResourceType.AWS_LIGHTSAIL_DISK
AWS_FIS_EXPERIMENTTEMPLATE = ResourceType.AWS_FIS_EXPERIMENTTEMPLATE
AWS_DATASYNC_LOCATIONFSXWINDOWS = ResourceType.AWS_DATASYNC_LOCATIONFSXWINDOWS
AWS_SES_RECEIPTFILTER = ResourceType.AWS_SES_RECEIPTFILTER
AWS_GUARDDUTY_FILTER = ResourceType.AWS_GUARDDUTY_FILTER
AWS_SES_TEMPLATE = ResourceType.AWS_SES_TEMPLATE
AWS_AMAZONMQ_BROKER = ResourceType.AWS_AMAZONMQ_BROKER
AWS_APPCONFIG_ENVIRONMENT = ResourceType.AWS_APPCONFIG_ENVIRONMENT
AWS_APPCONFIG_CONFIGURATIONPROFILE = ResourceType.AWS_APPCONFIG_CONFIGURATIONPROFILE
AWS_CLOUD9_ENVIRONMENTEC2 = ResourceType.AWS_CLOUD9_ENVIRONMENTEC2
AWS_EVENTSCHEMAS_REGISTRY = ResourceType.AWS_EVENTSCHEMAS_REGISTRY
AWS_EVENTSCHEMAS_REGISTRYPOLICY = ResourceType.AWS_EVENTSCHEMAS_REGISTRYPOLICY
AWS_EVENTSCHEMAS_DISCOVERER = ResourceType.AWS_EVENTSCHEMAS_DISCOVERER
AWS_FRAUDDETECTOR_LABEL = ResourceType.AWS_FRAUDDETECTOR_LABEL
AWS_FRAUDDETECTOR_ENTITYTYPE = ResourceType.AWS_FRAUDDETECTOR_ENTITYTYPE
AWS_FRAUDDETECTOR_VARIABLE = ResourceType.AWS_FRAUDDETECTOR_VARIABLE
AWS_FRAUDDETECTOR_OUTCOME = ResourceType.AWS_FRAUDDETECTOR_OUTCOME
AWS_IOT_AUTHORIZER = ResourceType.AWS_IOT_AUTHORIZER
AWS_IOT_SECURITYPROFILE = ResourceType.AWS_IOT_SECURITYPROFILE
AWS_IOT_ROLEALIAS = ResourceType.AWS_IOT_ROLEALIAS
AWS_IOT_DIMENSION = ResourceType.AWS_IOT_DIMENSION
AWS_IOTANALYTICS_DATASTORE = ResourceType.AWS_IOTANALYTICS_DATASTORE
AWS_LIGHTSAIL_BUCKET = ResourceType.AWS_LIGHTSAIL_BUCKET
AWS_LIGHTSAIL_STATICIP = ResourceType.AWS_LIGHTSAIL_STATICIP
AWS_MEDIAPACKAGE_PACKAGINGGROUP = ResourceType.AWS_MEDIAPACKAGE_PACKAGINGGROUP
AWS_ROUTE53RECOVERYREADINESS_RECOVERYGROUP = ResourceType.AWS_ROUTE53RECOVERYREADINESS_RECOVERYGROUP
AWS_RESILIENCEHUB_RESILIENCYPOLICY = ResourceType.AWS_RESILIENCEHUB_RESILIENCYPOLICY
AWS_TRANSFER_WORKFLOW = ResourceType.AWS_TRANSFER_WORKFLOW
AWS_EKS_IDENTITYPROVIDERCONFIG = ResourceType.AWS_EKS_IDENTITYPROVIDERCONFIG
AWS_EKS_ADDON = ResourceType.AWS_EKS_ADDON
AWS_GLUE_MLTRANSFORM = ResourceType.AWS_GLUE_MLTRANSFORM
AWS_IOT_POLICY = ResourceType.AWS_IOT_POLICY
AWS_IOT_MITIGATIONACTION = ResourceType.AWS_IOT_MITIGATIONACTION
AWS_IOTTWINMAKER_WORKSPACE = ResourceType.AWS_IOTTWINMAKER_WORKSPACE
AWS_IOTTWINMAKER_ENTITY = ResourceType.AWS_IOTTWINMAKER_ENTITY
AWS_IOTANALYTICS_DATASET = ResourceType.AWS_IOTANALYTICS_DATASET
AWS_IOTANALYTICS_PIPELINE = ResourceType.AWS_IOTANALYTICS_PIPELINE
AWS_IOTANALYTICS_CHANNEL = ResourceType.AWS_IOTANALYTICS_CHANNEL
AWS_IOTSITEWISE_DASHBOARD = ResourceType.AWS_IOTSITEWISE_DASHBOARD
AWS_IOTSITEWISE_PROJECT = ResourceType.AWS_IOTSITEWISE_PROJECT
AWS_IOTSITEWISE_PORTAL = ResourceType.AWS_IOTSITEWISE_PORTAL
AWS_IOTSITEWISE_ASSETMODEL = ResourceType.AWS_IOTSITEWISE_ASSETMODEL
AWS_IVS_CHANNEL = ResourceType.AWS_IVS_CHANNEL
AWS_IVS_RECORDINGCONFIGURATION = ResourceType.AWS_IVS_RECORDINGCONFIGURATION
AWS_IVS_PLAYBACKKEYPAIR = ResourceType.AWS_IVS_PLAYBACKKEYPAIR
AWS_KINESISANALYTICSV2_APPLICATION = ResourceType.AWS_KINESISANALYTICSV2_APPLICATION
AWS_RDS_GLOBALCLUSTER = ResourceType.AWS_RDS_GLOBALCLUSTER
AWS_S3_MULTIREGIONACCESSPOINT = ResourceType.AWS_S3_MULTIREGIONACCESSPOINT
AWS_DEVICEFARM_TESTGRIDPROJECT = ResourceType.AWS_DEVICEFARM_TESTGRIDPROJECT
AWS_BUDGETS_BUDGETSACTION = ResourceType.AWS_BUDGETS_BUDGETSACTION
AWS_LEX_BOT = ResourceType.AWS_LEX_BOT
AWS_CODEGURUREVIEWER_REPOSITORYASSOCIATION = ResourceType.AWS_CODEGURUREVIEWER_REPOSITORYASSOCIATION
AWS_IOT_CUSTOMMETRIC = ResourceType.AWS_IOT_CUSTOMMETRIC
AWS_ROUTE53RESOLVER_FIREWALLDOMAINLIST = ResourceType.AWS_ROUTE53RESOLVER_FIREWALLDOMAINLIST
AWS_ROBOMAKER_ROBOTAPPLICATIONVERSION = ResourceType.AWS_ROBOMAKER_ROBOTAPPLICATIONVERSION
AWS_EC2_TRAFFICMIRRORSESSION = ResourceType.AWS_EC2_TRAFFICMIRRORSESSION
AWS_IOTSITEWISE_GATEWAY = ResourceType.AWS_IOTSITEWISE_GATEWAY
AWS_LEX_BOTALIAS = ResourceType.AWS_LEX_BOTALIAS
AWS_LOOKOUTMETRICS_ALERT = ResourceType.AWS_LOOKOUTMETRICS_ALERT
AWS_IOT_ACCOUNTAUDITCONFIGURATION = ResourceType.AWS_IOT_ACCOUNTAUDITCONFIGURATION
AWS_EC2_TRAFFICMIRRORTARGET = ResourceType.AWS_EC2_TRAFFICMIRRORTARGET
AWS_S3_STORAGELENS = ResourceType.AWS_S3_STORAGELENS
AWS_IOT_SCHEDULEDAUDIT = ResourceType.AWS_IOT_SCHEDULEDAUDIT
AWS_EVENTS_CONNECTION = ResourceType.AWS_EVENTS_CONNECTION
AWS_EVENTSCHEMAS_SCHEMA = ResourceType.AWS_EVENTSCHEMAS_SCHEMA
AWS_MEDIAPACKAGE_PACKAGINGCONFIGURATION = ResourceType.AWS_MEDIAPACKAGE_PACKAGINGCONFIGURATION
AWS_KINESISVIDEO_SIGNALINGCHANNEL = ResourceType.AWS_KINESISVIDEO_SIGNALINGCHANNEL
AWS_APPSTREAM_DIRECTORYCONFIG = ResourceType.AWS_APPSTREAM_DIRECTORYCONFIG
AWS_LOOKOUTVISION_PROJECT = ResourceType.AWS_LOOKOUTVISION_PROJECT
AWS_ROUTE53RECOVERYCONTROL_CLUSTER = ResourceType.AWS_ROUTE53RECOVERYCONTROL_CLUSTER
AWS_ROUTE53RECOVERYCONTROL_SAFETYRULE = ResourceType.AWS_ROUTE53RECOVERYCONTROL_SAFETYRULE
AWS_ROUTE53RECOVERYCONTROL_CONTROLPANEL = ResourceType.AWS_ROUTE53RECOVERYCONTROL_CONTROLPANEL
AWS_ROUTE53RECOVERYCONTROL_ROUTINGCONTROL = ResourceType.AWS_ROUTE53RECOVERYCONTROL_ROUTINGCONTROL
AWS_ROUTE53RECOVERYREADINESS_RESOURCESET = ResourceType.AWS_ROUTE53RECOVERYREADINESS_RESOURCESET
AWS_ROBOMAKER_SIMULATIONAPPLICATION = ResourceType.AWS_ROBOMAKER_SIMULATIONAPPLICATION
AWS_ROBOMAKER_ROBOTAPPLICATION = ResourceType.AWS_ROBOMAKER_ROBOTAPPLICATION
AWS_HEALTHLAKE_FHIRDATASTORE = ResourceType.AWS_HEALTHLAKE_FHIRDATASTORE
AWS_PINPOINT_SEGMENT = ResourceType.AWS_PINPOINT_SEGMENT
AWS_PINPOINT_APPLICATIONSETTINGS = ResourceType.AWS_PINPOINT_APPLICATIONSETTINGS
AWS_EVENTS_RULE = ResourceType.AWS_EVENTS_RULE
AWS_EC2_DHCPOPTIONS = ResourceType.AWS_EC2_DHCPOPTIONS
AWS_EC2_NETWORKINSIGHTSPATH = ResourceType.AWS_EC2_NETWORKINSIGHTSPATH
AWS_EC2_TRAFFICMIRRORFILTER = ResourceType.AWS_EC2_TRAFFICMIRRORFILTER
AWS_EC2_IPAM = ResourceType.AWS_EC2_IPAM
AWS_IOTTWINMAKER_SCENE = ResourceType.AWS_IOTTWINMAKER_SCENE
AWS_NETWORKMANAGER_TRANSITGATEWAYREGISTRATION = ResourceType.AWS_NETWORKMANAGER_TRANSITGATEWAYREGISTRATION
AWS_CUSTOMERPROFILES_DOMAIN = ResourceType.AWS_CUSTOMERPROFILES_DOMAIN
AWS_AUTOSCALING_WARMPOOL = ResourceType.AWS_AUTOSCALING_WARMPOOL
AWS_CONNECT_PHONENUMBER = ResourceType.AWS_CONNECT_PHONENUMBER
AWS_APPCONFIG_DEPLOYMENTSTRATEGY = ResourceType.AWS_APPCONFIG_DEPLOYMENTSTRATEGY
AWS_APPFLOW_FLOW = ResourceType.AWS_APPFLOW_FLOW
AWS_AUDITMANAGER_ASSESSMENT = ResourceType.AWS_AUDITMANAGER_ASSESSMENT
AWS_CLOUDWATCH_METRICSTREAM = ResourceType.AWS_CLOUDWATCH_METRICSTREAM
AWS_DEVICEFARM_INSTANCEPROFILE = ResourceType.AWS_DEVICEFARM_INSTANCEPROFILE
AWS_DEVICEFARM_PROJECT = ResourceType.AWS_DEVICEFARM_PROJECT
AWS_EC2_EC2FLEET = ResourceType.AWS_EC2_EC2FLEET
AWS_EC2_SUBNETROUTETABLEASSOCIATION = ResourceType.AWS_EC2_SUBNETROUTETABLEASSOCIATION
AWS_ECR_PULLTHROUGHCACHERULE = ResourceType.AWS_ECR_PULLTHROUGHCACHERULE
AWS_GROUNDSTATION_CONFIG = ResourceType.AWS_GROUNDSTATION_CONFIG
AWS_IMAGEBUILDER_IMAGEPIPELINE = ResourceType.AWS_IMAGEBUILDER_IMAGEPIPELINE
AWS_IOT_FLEETMETRIC = ResourceType.AWS_IOT_FLEETMETRIC
AWS_IOTWIRELESS_SERVICEPROFILE = ResourceType.AWS_IOTWIRELESS_SERVICEPROFILE
AWS_NETWORKMANAGER_DEVICE = ResourceType.AWS_NETWORKMANAGER_DEVICE
AWS_NETWORKMANAGER_GLOBALNETWORK = ResourceType.AWS_NETWORKMANAGER_GLOBALNETWORK
AWS_NETWORKMANAGER_LINK = ResourceType.AWS_NETWORKMANAGER_LINK
AWS_NETWORKMANAGER_SITE = ResourceType.AWS_NETWORKMANAGER_SITE
AWS_PANORAMA_PACKAGE = ResourceType.AWS_PANORAMA_PACKAGE
AWS_PINPOINT_APP = ResourceType.AWS_PINPOINT_APP
AWS_REDSHIFT_SCHEDULEDACTION = ResourceType.AWS_REDSHIFT_SCHEDULEDACTION
AWS_ROUTE53RESOLVER_FIREWALLRULEGROUPASSOCIATION = ResourceType.AWS_ROUTE53RESOLVER_FIREWALLRULEGROUPASSOCIATION
AWS_SAGEMAKER_APPIMAGECONFIG = ResourceType.AWS_SAGEMAKER_APPIMAGECONFIG
AWS_SAGEMAKER_IMAGE = ResourceType.AWS_SAGEMAKER_IMAGE
AWS_ECS_TASKSET = ResourceType.AWS_ECS_TASKSET
AWS_CASSANDRA_KEYSPACE = ResourceType.AWS_CASSANDRA_KEYSPACE
AWS_SIGNER_SIGNINGPROFILE = ResourceType.AWS_SIGNER_SIGNINGPROFILE
AWS_AMPLIFY_APP = ResourceType.AWS_AMPLIFY_APP
AWS_APPMESH_VIRTUALNODE = ResourceType.AWS_APPMESH_VIRTUALNODE
AWS_APPMESH_VIRTUALSERVICE = ResourceType.AWS_APPMESH_VIRTUALSERVICE
AWS_APPRUNNER_VPCCONNECTOR = ResourceType.AWS_APPRUNNER_VPCCONNECTOR
AWS_APPSTREAM_APPLICATION = ResourceType.AWS_APPSTREAM_APPLICATION
AWS_CODEARTIFACT_REPOSITORY = ResourceType.AWS_CODEARTIFACT_REPOSITORY
AWS_EC2_PREFIXLIST = ResourceType.AWS_EC2_PREFIXLIST
AWS_EC2_SPOTFLEET = ResourceType.AWS_EC2_SPOTFLEET
AWS_EVIDENTLY_PROJECT = ResourceType.AWS_EVIDENTLY_PROJECT
AWS_FORECAST_DATASET = ResourceType.AWS_FORECAST_DATASET
AWS_IAM_SAMLPROVIDER = ResourceType.AWS_IAM_SAMLPROVIDER
AWS_IAM_SERVERCERTIFICATE = ResourceType.AWS_IAM_SERVERCERTIFICATE
AWS_PINPOINT_CAMPAIGN = ResourceType.AWS_PINPOINT_CAMPAIGN
AWS_PINPOINT_INAPPTEMPLATE = ResourceType.AWS_PINPOINT_INAPPTEMPLATE
AWS_SAGEMAKER_DOMAIN = ResourceType.AWS_SAGEMAKER_DOMAIN
AWS_TRANSFER_AGREEMENT = ResourceType.AWS_TRANSFER_AGREEMENT
AWS_TRANSFER_CONNECTOR = ResourceType.AWS_TRANSFER_CONNECTOR
AWS_KINESISFIREHOSE_DELIVERYSTREAM = ResourceType.AWS_KINESISFIREHOSE_DELIVERYSTREAM
AWS_AMPLIFY_BRANCH = ResourceType.AWS_AMPLIFY_BRANCH
AWS_APPINTEGRATIONS_EVENTINTEGRATION = ResourceType.AWS_APPINTEGRATIONS_EVENTINTEGRATION
AWS_APPMESH_ROUTE = ResourceType.AWS_APPMESH_ROUTE
AWS_ATHENA_PREPAREDSTATEMENT = ResourceType.AWS_ATHENA_PREPAREDSTATEMENT
AWS_EC2_IPAMSCOPE = ResourceType.AWS_EC2_IPAMSCOPE
AWS_EVIDENTLY_LAUNCH = ResourceType.AWS_EVIDENTLY_LAUNCH
AWS_FORECAST_DATASETGROUP = ResourceType.AWS_FORECAST_DATASETGROUP
AWS_GREENGRASSV2_COMPONENTVERSION = ResourceType.AWS_GREENGRASSV2_COMPONENTVERSION
AWS_GROUNDSTATION_MISSIONPROFILE = ResourceType.AWS_GROUNDSTATION_MISSIONPROFILE
AWS_MEDIACONNECT_FLOWENTITLEMENT = ResourceType.AWS_MEDIACONNECT_FLOWENTITLEMENT
AWS_MEDIACONNECT_FLOWVPCINTERFACE = ResourceType.AWS_MEDIACONNECT_FLOWVPCINTERFACE
AWS_MEDIATAILOR_PLAYBACKCONFIGURATION = ResourceType.AWS_MEDIATAILOR_PLAYBACKCONFIGURATION
AWS_MSK_CONFIGURATION = ResourceType.AWS_MSK_CONFIGURATION
AWS_PERSONALIZE_DATASET = ResourceType.AWS_PERSONALIZE_DATASET
AWS_PERSONALIZE_SCHEMA = ResourceType.AWS_PERSONALIZE_SCHEMA
AWS_PERSONALIZE_SOLUTION = ResourceType.AWS_PERSONALIZE_SOLUTION
AWS_PINPOINT_EMAILTEMPLATE = ResourceType.AWS_PINPOINT_EMAILTEMPLATE
AWS_PINPOINT_EVENTSTREAM = ResourceType.AWS_PINPOINT_EVENTSTREAM
AWS_RESILIENCEHUB_APP = ResourceType.AWS_RESILIENCEHUB_APP
AWS_ACMPCA_CERTIFICATEAUTHORITY = ResourceType.AWS_ACMPCA_CERTIFICATEAUTHORITY
AWS_APPCONFIG_HOSTEDCONFIGURATIONVERSION = ResourceType.AWS_APPCONFIG_HOSTEDCONFIGURATIONVERSION
AWS_APPMESH_VIRTUALGATEWAY = ResourceType.AWS_APPMESH_VIRTUALGATEWAY
AWS_APPMESH_VIRTUALROUTER = ResourceType.AWS_APPMESH_VIRTUALROUTER
AWS_APPRUNNER_SERVICE = ResourceType.AWS_APPRUNNER_SERVICE
AWS_CUSTOMERPROFILES_OBJECTTYPE = ResourceType.AWS_CUSTOMERPROFILES_OBJECTTYPE
AWS_DMS_ENDPOINT = ResourceType.AWS_DMS_ENDPOINT
AWS_EC2_CAPACITYRESERVATION = ResourceType.AWS_EC2_CAPACITYRESERVATION
AWS_EC2_CLIENTVPNENDPOINT = ResourceType.AWS_EC2_CLIENTVPNENDPOINT
AWS_KENDRA_INDEX = ResourceType.AWS_KENDRA_INDEX
AWS_KINESISVIDEO_STREAM = ResourceType.AWS_KINESISVIDEO_STREAM
AWS_LOGS_DESTINATION = ResourceType.AWS_LOGS_DESTINATION
AWS_PINPOINT_EMAILCHANNEL = ResourceType.AWS_PINPOINT_EMAILCHANNEL
AWS_S3_ACCESSPOINT = ResourceType.AWS_S3_ACCESSPOINT
AWS_NETWORKMANAGER_CUSTOMERGATEWAYASSOCIATION = ResourceType.AWS_NETWORKMANAGER_CUSTOMERGATEWAYASSOCIATION
AWS_NETWORKMANAGER_LINKASSOCIATION = ResourceType.AWS_NETWORKMANAGER_LINKASSOCIATION
AWS_IOTWIRELESS_MULTICASTGROUP = ResourceType.AWS_IOTWIRELESS_MULTICASTGROUP
AWS_PERSONALIZE_DATASETGROUP = ResourceType.AWS_PERSONALIZE_DATASETGROUP
AWS_IOTTWINMAKER_COMPONENTTYPE = ResourceType.AWS_IOTTWINMAKER_COMPONENTTYPE
AWS_CODEBUILD_REPORTGROUP = ResourceType.AWS_CODEBUILD_REPORTGROUP
AWS_SAGEMAKER_FEATUREGROUP = ResourceType.AWS_SAGEMAKER_FEATUREGROUP
AWS_MSK_BATCHSCRAMSECRET = ResourceType.AWS_MSK_BATCHSCRAMSECRET
AWS_APPSTREAM_STACK = ResourceType.AWS_APPSTREAM_STACK
AWS_IOT_JOBTEMPLATE = ResourceType.AWS_IOT_JOBTEMPLATE
AWS_IOTWIRELESS_FUOTATASK = ResourceType.AWS_IOTWIRELESS_FUOTATASK
AWS_IOT_PROVISIONINGTEMPLATE = ResourceType.AWS_IOT_PROVISIONINGTEMPLATE
AWS_INSPECTORV2_FILTER = ResourceType.AWS_INSPECTORV2_FILTER
AWS_ROUTE53RESOLVER_RESOLVERQUERYLOGGINGCONFIGASSOCIATION = ResourceType.AWS_ROUTE53RESOLVER_RESOLVERQUERYLOGGINGCONFIGASSOCIATION
AWS_SERVICEDISCOVERY_INSTANCE = ResourceType.AWS_SERVICEDISCOVERY_INSTANCE
AWS_TRANSFER_CERTIFICATE = ResourceType.AWS_TRANSFER_CERTIFICATE
AWS_MEDIACONNECT_FLOWSOURCE = ResourceType.AWS_MEDIACONNECT_FLOWSOURCE
AWS_APS_RULEGROUPSNAMESPACE = ResourceType.AWS_APS_RULEGROUPSNAMESPACE
AWS_CODEGURUPROFILER_PROFILINGGROUP = ResourceType.AWS_CODEGURUPROFILER_PROFILINGGROUP
AWS_ROUTE53RESOLVER_RESOLVERQUERYLOGGINGCONFIG = ResourceType.AWS_ROUTE53RESOLVER_RESOLVERQUERYLOGGINGCONFIG
AWS_BATCH_SCHEDULINGPOLICY = ResourceType.AWS_BATCH_SCHEDULINGPOLICY
AWS_ACMPCA_CERTIFICATEAUTHORITYACTIVATION = ResourceType.AWS_ACMPCA_CERTIFICATEAUTHORITYACTIVATION
AWS_APPMESH_GATEWAYROUTE = ResourceType.AWS_APPMESH_GATEWAYROUTE
AWS_APPMESH_MESH = ResourceType.AWS_APPMESH_MESH
AWS_CONNECT_INSTANCE = ResourceType.AWS_CONNECT_INSTANCE
AWS_CONNECT_QUICKCONNECT = ResourceType.AWS_CONNECT_QUICKCONNECT
AWS_EC2_CARRIERGATEWAY = ResourceType.AWS_EC2_CARRIERGATEWAY
AWS_EC2_IPAMPOOL = ResourceType.AWS_EC2_IPAMPOOL
AWS_EC2_TRANSITGATEWAYCONNECT = ResourceType.AWS_EC2_TRANSITGATEWAYCONNECT
AWS_EC2_TRANSITGATEWAYMULTICASTDOMAIN = ResourceType.AWS_EC2_TRANSITGATEWAYMULTICASTDOMAIN
AWS_ECS_CAPACITYPROVIDER = ResourceType.AWS_ECS_CAPACITYPROVIDER
AWS_IAM_INSTANCEPROFILE = ResourceType.AWS_IAM_INSTANCEPROFILE
AWS_IOT_CACERTIFICATE = ResourceType.AWS_IOT_CACERTIFICATE
AWS_IOTTWINMAKER_SYNCJOB = ResourceType.AWS_IOTTWINMAKER_SYNCJOB
AWS_KAFKACONNECT_CONNECTOR = ResourceType.AWS_KAFKACONNECT_CONNECTOR
AWS_LAMBDA_CODESIGNINGCONFIG = ResourceType.AWS_LAMBDA_CODESIGNINGCONFIG
AWS_NETWORKMANAGER_CONNECTPEER = ResourceType.AWS_NETWORKMANAGER_CONNECTPEER
AWS_RESOURCEEXPLORER2_INDEX = ResourceType.AWS_RESOURCEEXPLORER2_INDEX
AWS_APPSTREAM_FLEET = ResourceType.AWS_APPSTREAM_FLEET
AWS_COGNITO_USERPOOL = ResourceType.AWS_COGNITO_USERPOOL
AWS_COGNITO_USERPOOLCLIENT = ResourceType.AWS_COGNITO_USERPOOLCLIENT
AWS_COGNITO_USERPOOLGROUP = ResourceType.AWS_COGNITO_USERPOOLGROUP
AWS_EC2_NETWORKINSIGHTSACCESSSCOPE = ResourceType.AWS_EC2_NETWORKINSIGHTSACCESSSCOPE
AWS_EC2_NETWORKINSIGHTSANALYSIS = ResourceType.AWS_EC2_NETWORKINSIGHTSANALYSIS
AWS_GRAFANA_WORKSPACE = ResourceType.AWS_GRAFANA_WORKSPACE
AWS_GROUNDSTATION_DATAFLOWENDPOINTGROUP = ResourceType.AWS_GROUNDSTATION_DATAFLOWENDPOINTGROUP
AWS_IMAGEBUILDER_IMAGERECIPE = ResourceType.AWS_IMAGEBUILDER_IMAGERECIPE
AWS_KMS_ALIAS = ResourceType.AWS_KMS_ALIAS
AWS_M2_ENVIRONMENT = ResourceType.AWS_M2_ENVIRONMENT
AWS_QUICKSIGHT_DATASOURCE = ResourceType.AWS_QUICKSIGHT_DATASOURCE
AWS_QUICKSIGHT_TEMPLATE = ResourceType.AWS_QUICKSIGHT_TEMPLATE
AWS_QUICKSIGHT_THEME = ResourceType.AWS_QUICKSIGHT_THEME
AWS_RDS_OPTIONGROUP = ResourceType.AWS_RDS_OPTIONGROUP
AWS_REDSHIFT_ENDPOINTACCESS = ResourceType.AWS_REDSHIFT_ENDPOINTACCESS
AWS_ROUTE53RESOLVER_FIREWALLRULEGROUP = ResourceType.AWS_ROUTE53RESOLVER_FIREWALLRULEGROUP
AWS_SSM_DOCUMENT = ResourceType.AWS_SSM_DOCUMENT
AWS_APPCONFIG_EXTENSIONASSOCIATION = ResourceType.AWS_APPCONFIG_EXTENSIONASSOCIATION
AWS_APPINTEGRATIONS_APPLICATION = ResourceType.AWS_APPINTEGRATIONS_APPLICATION
AWS_APPSYNC_APICACHE = ResourceType.AWS_APPSYNC_APICACHE
AWS_BEDROCK_GUARDRAIL = ResourceType.AWS_BEDROCK_GUARDRAIL
AWS_BEDROCK_KNOWLEDGEBASE = ResourceType.AWS_BEDROCK_KNOWLEDGEBASE
AWS_COGNITO_IDENTITYPOOL = ResourceType.AWS_COGNITO_IDENTITYPOOL
AWS_CONNECT_RULE = ResourceType.AWS_CONNECT_RULE
AWS_CONNECT_USER = ResourceType.AWS_CONNECT_USER
AWS_EC2_CLIENTVPNTARGETNETWORKASSOCIATION = ResourceType.AWS_EC2_CLIENTVPNTARGETNETWORKASSOCIATION
AWS_EC2_EIPASSOCIATION = ResourceType.AWS_EC2_EIPASSOCIATION
AWS_EC2_IPAMRESOURCEDISCOVERY = ResourceType.AWS_EC2_IPAMRESOURCEDISCOVERY
AWS_EC2_IPAMRESOURCEDISCOVERYASSOCIATION = ResourceType.AWS_EC2_IPAMRESOURCEDISCOVERYASSOCIATION
AWS_EC2_INSTANCECONNECTENDPOINT = ResourceType.AWS_EC2_INSTANCECONNECTENDPOINT
AWS_EC2_SNAPSHOTBLOCKPUBLICACCESS = ResourceType.AWS_EC2_SNAPSHOTBLOCKPUBLICACCESS
AWS_EC2_VPCBLOCKPUBLICACCESSEXCLUSION = ResourceType.AWS_EC2_VPCBLOCKPUBLICACCESSEXCLUSION
AWS_EC2_VPCBLOCKPUBLICACCESSOPTIONS = ResourceType.AWS_EC2_VPCBLOCKPUBLICACCESSOPTIONS
AWS_EC2_VPCENDPOINTCONNECTIONNOTIFICATION = ResourceType.AWS_EC2_VPCENDPOINTCONNECTIONNOTIFICATION
AWS_EC2_VPNCONNECTIONROUTE = ResourceType.AWS_EC2_VPNCONNECTIONROUTE
AWS_EVIDENTLY_SEGMENT = ResourceType.AWS_EVIDENTLY_SEGMENT
AWS_IAM_OIDCPROVIDER = ResourceType.AWS_IAM_OIDCPROVIDER
AWS_INSPECTORV2_ACTIVATION = ResourceType.AWS_INSPECTORV2_ACTIVATION
AWS_MSK_CLUSTERPOLICY = ResourceType.AWS_MSK_CLUSTERPOLICY
AWS_MSK_VPCCONNECTION = ResourceType.AWS_MSK_VPCCONNECTION
AWS_MEDIACONNECT_GATEWAY = ResourceType.AWS_MEDIACONNECT_GATEWAY
AWS_MEMORYDB_SUBNETGROUP = ResourceType.AWS_MEMORYDB_SUBNETGROUP
AWS_OPENSEARCHSERVERLESS_COLLECTION = ResourceType.AWS_OPENSEARCHSERVERLESS_COLLECTION
AWS_OPENSEARCHSERVERLESS_VPCENDPOINT = ResourceType.AWS_OPENSEARCHSERVERLESS_VPCENDPOINT
AWS_REDSHIFT_ENDPOINTAUTHORIZATION = ResourceType.AWS_REDSHIFT_ENDPOINTAUTHORIZATION
AWS_ROUTE53PROFILES_PROFILE = ResourceType.AWS_ROUTE53PROFILES_PROFILE
AWS_S3_STORAGELENSGROUP = ResourceType.AWS_S3_STORAGELENSGROUP
AWS_S3EXPRESS_BUCKETPOLICY = ResourceType.AWS_S3EXPRESS_BUCKETPOLICY
AWS_S3EXPRESS_DIRECTORYBUCKET = ResourceType.AWS_S3EXPRESS_DIRECTORYBUCKET
AWS_SAGEMAKER_INFERENCEEXPERIMENT = ResourceType.AWS_SAGEMAKER_INFERENCEEXPERIMENT
AWS_SECURITYHUB_STANDARD = ResourceType.AWS_SECURITYHUB_STANDARD
AWS_TRANSFER_PROFILE = ResourceType.AWS_TRANSFER_PROFILE
RESOURCE_ID = ResourceValueType.RESOURCE_ID
SCORE = SortBy.SCORE
ASCENDING = SortOrder.ASCENDING
DESCENDING = SortOrder.DESCENDING


@dataclass
class AggregationAuthorization(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-confi"""

    resource_type: ClassVar[str] = "AWS::Config::AggregationAuthorization"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    authorized_account_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    authorized_aws_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.authorized_account_id is not None:
            # Serialize authorized_account_id (handle intrinsic functions)
            if hasattr(self.authorized_account_id, 'to_dict'):
                props["AuthorizedAccountId"] = self.authorized_account_id.to_dict()
            elif isinstance(self.authorized_account_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AuthorizedAccountId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.authorized_account_id
                ]
            else:
                props["AuthorizedAccountId"] = self.authorized_account_id

        if self.authorized_aws_region is not None:
            # Serialize authorized_aws_region (handle intrinsic functions)
            if hasattr(self.authorized_aws_region, 'to_dict'):
                props["AuthorizedAwsRegion"] = self.authorized_aws_region.to_dict()
            elif isinstance(self.authorized_aws_region, list):
                # Serialize list items (may contain intrinsic functions)
                props['AuthorizedAwsRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.authorized_aws_region
                ]
            else:
                props["AuthorizedAwsRegion"] = self.authorized_aws_region

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_aggregation_authorization_arn(self) -> GetAtt:
        """Get the AggregationAuthorizationArn attribute."""
        return self.get_att("AggregationAuthorizationArn")




@dataclass
class Compliance:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        return props


@dataclass
class CustomPolicyDetails:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_debug_log_delivery: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    policy_text: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    policy_runtime: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enable_debug_log_delivery is not None:
            if hasattr(self.enable_debug_log_delivery, 'to_dict'):
                props['EnableDebugLogDelivery'] = self.enable_debug_log_delivery.to_dict()
            elif isinstance(self.enable_debug_log_delivery, list):
                props['EnableDebugLogDelivery'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_debug_log_delivery
                ]
            else:
                props['EnableDebugLogDelivery'] = self.enable_debug_log_delivery

        if self.policy_text is not None:
            if hasattr(self.policy_text, 'to_dict'):
                props['PolicyText'] = self.policy_text.to_dict()
            elif isinstance(self.policy_text, list):
                props['PolicyText'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_text
                ]
            else:
                props['PolicyText'] = self.policy_text

        if self.policy_runtime is not None:
            if hasattr(self.policy_runtime, 'to_dict'):
                props['PolicyRuntime'] = self.policy_runtime.to_dict()
            elif isinstance(self.policy_runtime, list):
                props['PolicyRuntime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_runtime
                ]
            else:
                props['PolicyRuntime'] = self.policy_runtime

        return props


@dataclass
class EvaluationModeConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mode: Optional[Union[str, EvaluationMode, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mode is not None:
            if hasattr(self.mode, 'to_dict'):
                props['Mode'] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props['Mode'] = self.mode

        return props


@dataclass
class Scope:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    compliance_resource_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    compliance_resource_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_value: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.compliance_resource_id is not None:
            if hasattr(self.compliance_resource_id, 'to_dict'):
                props['ComplianceResourceId'] = self.compliance_resource_id.to_dict()
            elif isinstance(self.compliance_resource_id, list):
                props['ComplianceResourceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compliance_resource_id
                ]
            else:
                props['ComplianceResourceId'] = self.compliance_resource_id

        if self.tag_key is not None:
            if hasattr(self.tag_key, 'to_dict'):
                props['TagKey'] = self.tag_key.to_dict()
            elif isinstance(self.tag_key, list):
                props['TagKey'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_key
                ]
            else:
                props['TagKey'] = self.tag_key

        if self.compliance_resource_types is not None:
            if hasattr(self.compliance_resource_types, 'to_dict'):
                props['ComplianceResourceTypes'] = self.compliance_resource_types.to_dict()
            elif isinstance(self.compliance_resource_types, list):
                props['ComplianceResourceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compliance_resource_types
                ]
            else:
                props['ComplianceResourceTypes'] = self.compliance_resource_types

        if self.tag_value is not None:
            if hasattr(self.tag_value, 'to_dict'):
                props['TagValue'] = self.tag_value.to_dict()
            elif isinstance(self.tag_value, list):
                props['TagValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_value
                ]
            else:
                props['TagValue'] = self.tag_value

        return props


@dataclass
class Source:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    owner: Optional[Union[str, Owner, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_policy_details: Optional[CustomPolicyDetails] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_details: Optional[list[SourceDetail]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.owner is not None:
            if hasattr(self.owner, 'to_dict'):
                props['Owner'] = self.owner.to_dict()
            elif isinstance(self.owner, list):
                props['Owner'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.owner
                ]
            else:
                props['Owner'] = self.owner

        if self.custom_policy_details is not None:
            if hasattr(self.custom_policy_details, 'to_dict'):
                props['CustomPolicyDetails'] = self.custom_policy_details.to_dict()
            elif isinstance(self.custom_policy_details, list):
                props['CustomPolicyDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_policy_details
                ]
            else:
                props['CustomPolicyDetails'] = self.custom_policy_details

        if self.source_identifier is not None:
            if hasattr(self.source_identifier, 'to_dict'):
                props['SourceIdentifier'] = self.source_identifier.to_dict()
            elif isinstance(self.source_identifier, list):
                props['SourceIdentifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_identifier
                ]
            else:
                props['SourceIdentifier'] = self.source_identifier

        if self.source_details is not None:
            if hasattr(self.source_details, 'to_dict'):
                props['SourceDetails'] = self.source_details.to_dict()
            elif isinstance(self.source_details, list):
                props['SourceDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_details
                ]
            else:
                props['SourceDetails'] = self.source_details

        return props


@dataclass
class SourceDetail:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    event_source: Optional[Union[str, EventSource, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_execution_frequency: Optional[Union[str, MaximumExecutionFrequency, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    message_type: Optional[Union[str, MessageType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.event_source is not None:
            if hasattr(self.event_source, 'to_dict'):
                props['EventSource'] = self.event_source.to_dict()
            elif isinstance(self.event_source, list):
                props['EventSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.event_source
                ]
            else:
                props['EventSource'] = self.event_source

        if self.maximum_execution_frequency is not None:
            if hasattr(self.maximum_execution_frequency, 'to_dict'):
                props['MaximumExecutionFrequency'] = self.maximum_execution_frequency.to_dict()
            elif isinstance(self.maximum_execution_frequency, list):
                props['MaximumExecutionFrequency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_execution_frequency
                ]
            else:
                props['MaximumExecutionFrequency'] = self.maximum_execution_frequency

        if self.message_type is not None:
            if hasattr(self.message_type, 'to_dict'):
                props['MessageType'] = self.message_type.to_dict()
            elif isinstance(self.message_type, list):
                props['MessageType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.message_type
                ]
            else:
                props['MessageType'] = self.message_type

        return props


@dataclass
class ConfigRule(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-confi"""

    resource_type: ClassVar[str] = "AWS::Config::ConfigRule"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    evaluation_modes: Optional[list[EvaluationModeConfiguration]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    scope: Optional[Scope] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    compliance: Optional[Compliance] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    config_rule_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    maximum_execution_frequency: Optional[Union[str, MaximumExecutionFrequency, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source: Optional[Source] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    input_parameters: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.evaluation_modes is not None:
            # Serialize evaluation_modes (handle intrinsic functions)
            if hasattr(self.evaluation_modes, 'to_dict'):
                props["EvaluationModes"] = self.evaluation_modes.to_dict()
            elif isinstance(self.evaluation_modes, list):
                # Serialize list items (may contain intrinsic functions)
                props['EvaluationModes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.evaluation_modes
                ]
            else:
                props["EvaluationModes"] = self.evaluation_modes

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.scope is not None:
            # Serialize scope (handle intrinsic functions)
            if hasattr(self.scope, 'to_dict'):
                props["Scope"] = self.scope.to_dict()
            elif isinstance(self.scope, list):
                # Serialize list items (may contain intrinsic functions)
                props['Scope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scope
                ]
            else:
                props["Scope"] = self.scope

        if self.compliance is not None:
            # Serialize compliance (handle intrinsic functions)
            if hasattr(self.compliance, 'to_dict'):
                props["Compliance"] = self.compliance.to_dict()
            elif isinstance(self.compliance, list):
                # Serialize list items (may contain intrinsic functions)
                props['Compliance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compliance
                ]
            else:
                props["Compliance"] = self.compliance

        if self.config_rule_name is not None:
            # Serialize config_rule_name (handle intrinsic functions)
            if hasattr(self.config_rule_name, 'to_dict'):
                props["ConfigRuleName"] = self.config_rule_name.to_dict()
            elif isinstance(self.config_rule_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConfigRuleName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.config_rule_name
                ]
            else:
                props["ConfigRuleName"] = self.config_rule_name

        if self.maximum_execution_frequency is not None:
            # Serialize maximum_execution_frequency (handle intrinsic functions)
            if hasattr(self.maximum_execution_frequency, 'to_dict'):
                props["MaximumExecutionFrequency"] = self.maximum_execution_frequency.to_dict()
            elif isinstance(self.maximum_execution_frequency, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaximumExecutionFrequency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_execution_frequency
                ]
            else:
                props["MaximumExecutionFrequency"] = self.maximum_execution_frequency

        if self.source is not None:
            # Serialize source (handle intrinsic functions)
            if hasattr(self.source, 'to_dict'):
                props["Source"] = self.source.to_dict()
            elif isinstance(self.source, list):
                # Serialize list items (may contain intrinsic functions)
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props["Source"] = self.source

        if self.input_parameters is not None:
            # Serialize input_parameters (handle intrinsic functions)
            if hasattr(self.input_parameters, 'to_dict'):
                props["InputParameters"] = self.input_parameters.to_dict()
            elif isinstance(self.input_parameters, list):
                # Serialize list items (may contain intrinsic functions)
                props['InputParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.input_parameters
                ]
            else:
                props["InputParameters"] = self.input_parameters

        return props

    @property
    def attr_config_rule_id(self) -> GetAtt:
        """Get the ConfigRuleId attribute."""
        return self.get_att("ConfigRuleId")

    @property
    def attr_compliance__type(self) -> GetAtt:
        """Get the Compliance.Type attribute."""
        return self.get_att("Compliance.Type")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class AccountAggregationSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    all_aws_regions: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    aws_regions: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    account_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.all_aws_regions is not None:
            if hasattr(self.all_aws_regions, 'to_dict'):
                props['AllAwsRegions'] = self.all_aws_regions.to_dict()
            elif isinstance(self.all_aws_regions, list):
                props['AllAwsRegions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.all_aws_regions
                ]
            else:
                props['AllAwsRegions'] = self.all_aws_regions

        if self.aws_regions is not None:
            if hasattr(self.aws_regions, 'to_dict'):
                props['AwsRegions'] = self.aws_regions.to_dict()
            elif isinstance(self.aws_regions, list):
                props['AwsRegions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.aws_regions
                ]
            else:
                props['AwsRegions'] = self.aws_regions

        if self.account_ids is not None:
            if hasattr(self.account_ids, 'to_dict'):
                props['AccountIds'] = self.account_ids.to_dict()
            elif isinstance(self.account_ids, list):
                props['AccountIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.account_ids
                ]
            else:
                props['AccountIds'] = self.account_ids

        return props


@dataclass
class OrganizationAggregationSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    all_aws_regions: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    aws_regions: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.all_aws_regions is not None:
            if hasattr(self.all_aws_regions, 'to_dict'):
                props['AllAwsRegions'] = self.all_aws_regions.to_dict()
            elif isinstance(self.all_aws_regions, list):
                props['AllAwsRegions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.all_aws_regions
                ]
            else:
                props['AllAwsRegions'] = self.all_aws_regions

        if self.aws_regions is not None:
            if hasattr(self.aws_regions, 'to_dict'):
                props['AwsRegions'] = self.aws_regions.to_dict()
            elif isinstance(self.aws_regions, list):
                props['AwsRegions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.aws_regions
                ]
            else:
                props['AwsRegions'] = self.aws_regions

        if self.role_arn is not None:
            if hasattr(self.role_arn, 'to_dict'):
                props['RoleArn'] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props['RoleArn'] = self.role_arn

        return props


@dataclass
class ConfigurationAggregator(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-confi"""

    resource_type: ClassVar[str] = "AWS::Config::ConfigurationAggregator"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    account_aggregation_sources: Optional[list[AccountAggregationSource]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    configuration_aggregator_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    organization_aggregation_source: Optional[OrganizationAggregationSource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.account_aggregation_sources is not None:
            # Serialize account_aggregation_sources (handle intrinsic functions)
            if hasattr(self.account_aggregation_sources, 'to_dict'):
                props["AccountAggregationSources"] = self.account_aggregation_sources.to_dict()
            elif isinstance(self.account_aggregation_sources, list):
                # Serialize list items (may contain intrinsic functions)
                props['AccountAggregationSources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.account_aggregation_sources
                ]
            else:
                props["AccountAggregationSources"] = self.account_aggregation_sources

        if self.configuration_aggregator_name is not None:
            # Serialize configuration_aggregator_name (handle intrinsic functions)
            if hasattr(self.configuration_aggregator_name, 'to_dict'):
                props["ConfigurationAggregatorName"] = self.configuration_aggregator_name.to_dict()
            elif isinstance(self.configuration_aggregator_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConfigurationAggregatorName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.configuration_aggregator_name
                ]
            else:
                props["ConfigurationAggregatorName"] = self.configuration_aggregator_name

        if self.organization_aggregation_source is not None:
            # Serialize organization_aggregation_source (handle intrinsic functions)
            if hasattr(self.organization_aggregation_source, 'to_dict'):
                props["OrganizationAggregationSource"] = self.organization_aggregation_source.to_dict()
            elif isinstance(self.organization_aggregation_source, list):
                # Serialize list items (may contain intrinsic functions)
                props['OrganizationAggregationSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organization_aggregation_source
                ]
            else:
                props["OrganizationAggregationSource"] = self.organization_aggregation_source

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_configuration_aggregator_arn(self) -> GetAtt:
        """Get the ConfigurationAggregatorArn attribute."""
        return self.get_att("ConfigurationAggregatorArn")




@dataclass
class ExclusionByResourceTypes:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_types: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_types is not None:
            if hasattr(self.resource_types, 'to_dict'):
                props['ResourceTypes'] = self.resource_types.to_dict()
            elif isinstance(self.resource_types, list):
                props['ResourceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_types
                ]
            else:
                props['ResourceTypes'] = self.resource_types

        return props


@dataclass
class RecordingGroup:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    all_supported: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    exclusion_by_resource_types: Optional[ExclusionByResourceTypes] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    include_global_resource_types: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    recording_strategy: Optional[RecordingStrategy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_types: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.all_supported is not None:
            if hasattr(self.all_supported, 'to_dict'):
                props['AllSupported'] = self.all_supported.to_dict()
            elif isinstance(self.all_supported, list):
                props['AllSupported'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.all_supported
                ]
            else:
                props['AllSupported'] = self.all_supported

        if self.exclusion_by_resource_types is not None:
            if hasattr(self.exclusion_by_resource_types, 'to_dict'):
                props['ExclusionByResourceTypes'] = self.exclusion_by_resource_types.to_dict()
            elif isinstance(self.exclusion_by_resource_types, list):
                props['ExclusionByResourceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.exclusion_by_resource_types
                ]
            else:
                props['ExclusionByResourceTypes'] = self.exclusion_by_resource_types

        if self.include_global_resource_types is not None:
            if hasattr(self.include_global_resource_types, 'to_dict'):
                props['IncludeGlobalResourceTypes'] = self.include_global_resource_types.to_dict()
            elif isinstance(self.include_global_resource_types, list):
                props['IncludeGlobalResourceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.include_global_resource_types
                ]
            else:
                props['IncludeGlobalResourceTypes'] = self.include_global_resource_types

        if self.recording_strategy is not None:
            if hasattr(self.recording_strategy, 'to_dict'):
                props['RecordingStrategy'] = self.recording_strategy.to_dict()
            elif isinstance(self.recording_strategy, list):
                props['RecordingStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.recording_strategy
                ]
            else:
                props['RecordingStrategy'] = self.recording_strategy

        if self.resource_types is not None:
            if hasattr(self.resource_types, 'to_dict'):
                props['ResourceTypes'] = self.resource_types.to_dict()
            elif isinstance(self.resource_types, list):
                props['ResourceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_types
                ]
            else:
                props['ResourceTypes'] = self.resource_types

        return props


@dataclass
class RecordingMode:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    recording_frequency: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    recording_mode_overrides: Optional[list[RecordingModeOverride]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.recording_frequency is not None:
            if hasattr(self.recording_frequency, 'to_dict'):
                props['RecordingFrequency'] = self.recording_frequency.to_dict()
            elif isinstance(self.recording_frequency, list):
                props['RecordingFrequency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.recording_frequency
                ]
            else:
                props['RecordingFrequency'] = self.recording_frequency

        if self.recording_mode_overrides is not None:
            if hasattr(self.recording_mode_overrides, 'to_dict'):
                props['RecordingModeOverrides'] = self.recording_mode_overrides.to_dict()
            elif isinstance(self.recording_mode_overrides, list):
                props['RecordingModeOverrides'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.recording_mode_overrides
                ]
            else:
                props['RecordingModeOverrides'] = self.recording_mode_overrides

        return props


@dataclass
class RecordingModeOverride:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    recording_frequency: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_types: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.recording_frequency is not None:
            if hasattr(self.recording_frequency, 'to_dict'):
                props['RecordingFrequency'] = self.recording_frequency.to_dict()
            elif isinstance(self.recording_frequency, list):
                props['RecordingFrequency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.recording_frequency
                ]
            else:
                props['RecordingFrequency'] = self.recording_frequency

        if self.resource_types is not None:
            if hasattr(self.resource_types, 'to_dict'):
                props['ResourceTypes'] = self.resource_types.to_dict()
            elif isinstance(self.resource_types, list):
                props['ResourceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_types
                ]
            else:
                props['ResourceTypes'] = self.resource_types

        return props


@dataclass
class RecordingStrategy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    use_only: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.use_only is not None:
            if hasattr(self.use_only, 'to_dict'):
                props['UseOnly'] = self.use_only.to_dict()
            elif isinstance(self.use_only, list):
                props['UseOnly'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.use_only
                ]
            else:
                props['UseOnly'] = self.use_only

        return props


@dataclass
class ConfigurationRecorder(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-confi"""

    resource_type: ClassVar[str] = "AWS::Config::ConfigurationRecorder"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    recording_group: Optional[RecordingGroup] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    recording_mode: Optional[RecordingMode] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.recording_group is not None:
            # Serialize recording_group (handle intrinsic functions)
            if hasattr(self.recording_group, 'to_dict'):
                props["RecordingGroup"] = self.recording_group.to_dict()
            elif isinstance(self.recording_group, list):
                # Serialize list items (may contain intrinsic functions)
                props['RecordingGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.recording_group
                ]
            else:
                props["RecordingGroup"] = self.recording_group

        if self.recording_mode is not None:
            # Serialize recording_mode (handle intrinsic functions)
            if hasattr(self.recording_mode, 'to_dict'):
                props["RecordingMode"] = self.recording_mode.to_dict()
            elif isinstance(self.recording_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['RecordingMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.recording_mode
                ]
            else:
                props["RecordingMode"] = self.recording_mode

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleARN"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleARN"] = self.role_arn

        return props



@dataclass
class ConformancePackInputParameter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parameter_value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parameter_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.parameter_value is not None:
            if hasattr(self.parameter_value, 'to_dict'):
                props['ParameterValue'] = self.parameter_value.to_dict()
            elif isinstance(self.parameter_value, list):
                props['ParameterValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameter_value
                ]
            else:
                props['ParameterValue'] = self.parameter_value

        if self.parameter_name is not None:
            if hasattr(self.parameter_name, 'to_dict'):
                props['ParameterName'] = self.parameter_name.to_dict()
            elif isinstance(self.parameter_name, list):
                props['ParameterName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameter_name
                ]
            else:
                props['ParameterName'] = self.parameter_name

        return props


@dataclass
class TemplateSSMDocumentDetails:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    document_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    document_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.document_version is not None:
            if hasattr(self.document_version, 'to_dict'):
                props['DocumentVersion'] = self.document_version.to_dict()
            elif isinstance(self.document_version, list):
                props['DocumentVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_version
                ]
            else:
                props['DocumentVersion'] = self.document_version

        if self.document_name is not None:
            if hasattr(self.document_name, 'to_dict'):
                props['DocumentName'] = self.document_name.to_dict()
            elif isinstance(self.document_name, list):
                props['DocumentName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_name
                ]
            else:
                props['DocumentName'] = self.document_name

        return props


@dataclass
class ConformancePack(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-confi"""

    resource_type: ClassVar[str] = "AWS::Config::ConformancePack"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    conformance_pack_input_parameters: Optional[list[ConformancePackInputParameter]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    template_ssm_document_details: Optional[TemplateSSMDocumentDetails] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delivery_s3_bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    conformance_pack_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delivery_s3_key_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    template_body: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    template_s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.conformance_pack_input_parameters is not None:
            # Serialize conformance_pack_input_parameters (handle intrinsic functions)
            if hasattr(self.conformance_pack_input_parameters, 'to_dict'):
                props["ConformancePackInputParameters"] = self.conformance_pack_input_parameters.to_dict()
            elif isinstance(self.conformance_pack_input_parameters, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConformancePackInputParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.conformance_pack_input_parameters
                ]
            else:
                props["ConformancePackInputParameters"] = self.conformance_pack_input_parameters

        if self.template_ssm_document_details is not None:
            # Serialize template_ssm_document_details (handle intrinsic functions)
            if hasattr(self.template_ssm_document_details, 'to_dict'):
                props["TemplateSSMDocumentDetails"] = self.template_ssm_document_details.to_dict()
            elif isinstance(self.template_ssm_document_details, list):
                # Serialize list items (may contain intrinsic functions)
                props['TemplateSSMDocumentDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.template_ssm_document_details
                ]
            else:
                props["TemplateSSMDocumentDetails"] = self.template_ssm_document_details

        if self.delivery_s3_bucket is not None:
            # Serialize delivery_s3_bucket (handle intrinsic functions)
            if hasattr(self.delivery_s3_bucket, 'to_dict'):
                props["DeliveryS3Bucket"] = self.delivery_s3_bucket.to_dict()
            elif isinstance(self.delivery_s3_bucket, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeliveryS3Bucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delivery_s3_bucket
                ]
            else:
                props["DeliveryS3Bucket"] = self.delivery_s3_bucket

        if self.conformance_pack_name is not None:
            # Serialize conformance_pack_name (handle intrinsic functions)
            if hasattr(self.conformance_pack_name, 'to_dict'):
                props["ConformancePackName"] = self.conformance_pack_name.to_dict()
            elif isinstance(self.conformance_pack_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConformancePackName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.conformance_pack_name
                ]
            else:
                props["ConformancePackName"] = self.conformance_pack_name

        if self.delivery_s3_key_prefix is not None:
            # Serialize delivery_s3_key_prefix (handle intrinsic functions)
            if hasattr(self.delivery_s3_key_prefix, 'to_dict'):
                props["DeliveryS3KeyPrefix"] = self.delivery_s3_key_prefix.to_dict()
            elif isinstance(self.delivery_s3_key_prefix, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeliveryS3KeyPrefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delivery_s3_key_prefix
                ]
            else:
                props["DeliveryS3KeyPrefix"] = self.delivery_s3_key_prefix

        if self.template_body is not None:
            # Serialize template_body (handle intrinsic functions)
            if hasattr(self.template_body, 'to_dict'):
                props["TemplateBody"] = self.template_body.to_dict()
            elif isinstance(self.template_body, list):
                # Serialize list items (may contain intrinsic functions)
                props['TemplateBody'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.template_body
                ]
            else:
                props["TemplateBody"] = self.template_body

        if self.template_s3_uri is not None:
            # Serialize template_s3_uri (handle intrinsic functions)
            if hasattr(self.template_s3_uri, 'to_dict'):
                props["TemplateS3Uri"] = self.template_s3_uri.to_dict()
            elif isinstance(self.template_s3_uri, list):
                # Serialize list items (may contain intrinsic functions)
                props['TemplateS3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.template_s3_uri
                ]
            else:
                props["TemplateS3Uri"] = self.template_s3_uri

        return props



@dataclass
class ConfigSnapshotDeliveryProperties:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delivery_frequency: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.delivery_frequency is not None:
            if hasattr(self.delivery_frequency, 'to_dict'):
                props['DeliveryFrequency'] = self.delivery_frequency.to_dict()
            elif isinstance(self.delivery_frequency, list):
                props['DeliveryFrequency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delivery_frequency
                ]
            else:
                props['DeliveryFrequency'] = self.delivery_frequency

        return props


@dataclass
class DeliveryChannel(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-confi"""

    resource_type: ClassVar[str] = "AWS::Config::DeliveryChannel"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    config_snapshot_delivery_properties: Optional[ConfigSnapshotDeliveryProperties] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    s3_bucket_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    s3_key_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    s3_kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sns_topic_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.config_snapshot_delivery_properties is not None:
            # Serialize config_snapshot_delivery_properties (handle intrinsic functions)
            if hasattr(self.config_snapshot_delivery_properties, 'to_dict'):
                props["ConfigSnapshotDeliveryProperties"] = self.config_snapshot_delivery_properties.to_dict()
            elif isinstance(self.config_snapshot_delivery_properties, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConfigSnapshotDeliveryProperties'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.config_snapshot_delivery_properties
                ]
            else:
                props["ConfigSnapshotDeliveryProperties"] = self.config_snapshot_delivery_properties

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.s3_bucket_name is not None:
            # Serialize s3_bucket_name (handle intrinsic functions)
            if hasattr(self.s3_bucket_name, 'to_dict'):
                props["S3BucketName"] = self.s3_bucket_name.to_dict()
            elif isinstance(self.s3_bucket_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['S3BucketName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_bucket_name
                ]
            else:
                props["S3BucketName"] = self.s3_bucket_name

        if self.s3_key_prefix is not None:
            # Serialize s3_key_prefix (handle intrinsic functions)
            if hasattr(self.s3_key_prefix, 'to_dict'):
                props["S3KeyPrefix"] = self.s3_key_prefix.to_dict()
            elif isinstance(self.s3_key_prefix, list):
                # Serialize list items (may contain intrinsic functions)
                props['S3KeyPrefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_key_prefix
                ]
            else:
                props["S3KeyPrefix"] = self.s3_key_prefix

        if self.s3_kms_key_arn is not None:
            # Serialize s3_kms_key_arn (handle intrinsic functions)
            if hasattr(self.s3_kms_key_arn, 'to_dict'):
                props["S3KmsKeyArn"] = self.s3_kms_key_arn.to_dict()
            elif isinstance(self.s3_kms_key_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['S3KmsKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_kms_key_arn
                ]
            else:
                props["S3KmsKeyArn"] = self.s3_kms_key_arn

        if self.sns_topic_arn is not None:
            # Serialize sns_topic_arn (handle intrinsic functions)
            if hasattr(self.sns_topic_arn, 'to_dict'):
                props["SnsTopicARN"] = self.sns_topic_arn.to_dict()
            elif isinstance(self.sns_topic_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['SnsTopicARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sns_topic_arn
                ]
            else:
                props["SnsTopicARN"] = self.sns_topic_arn

        return props



@dataclass
class OrganizationCustomPolicyRuleMetadata:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_key_scope: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_value_scope: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    runtime: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    policy_text: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_id_scope: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    organization_config_rule_trigger_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    debug_log_delivery_accounts: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_types_scope: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_execution_frequency: Optional[Union[str, MaximumExecutionFrequency, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    input_parameters: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.tag_key_scope is not None:
            if hasattr(self.tag_key_scope, 'to_dict'):
                props['TagKeyScope'] = self.tag_key_scope.to_dict()
            elif isinstance(self.tag_key_scope, list):
                props['TagKeyScope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_key_scope
                ]
            else:
                props['TagKeyScope'] = self.tag_key_scope

        if self.tag_value_scope is not None:
            if hasattr(self.tag_value_scope, 'to_dict'):
                props['TagValueScope'] = self.tag_value_scope.to_dict()
            elif isinstance(self.tag_value_scope, list):
                props['TagValueScope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_value_scope
                ]
            else:
                props['TagValueScope'] = self.tag_value_scope

        if self.runtime is not None:
            if hasattr(self.runtime, 'to_dict'):
                props['Runtime'] = self.runtime.to_dict()
            elif isinstance(self.runtime, list):
                props['Runtime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.runtime
                ]
            else:
                props['Runtime'] = self.runtime

        if self.policy_text is not None:
            if hasattr(self.policy_text, 'to_dict'):
                props['PolicyText'] = self.policy_text.to_dict()
            elif isinstance(self.policy_text, list):
                props['PolicyText'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_text
                ]
            else:
                props['PolicyText'] = self.policy_text

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.resource_id_scope is not None:
            if hasattr(self.resource_id_scope, 'to_dict'):
                props['ResourceIdScope'] = self.resource_id_scope.to_dict()
            elif isinstance(self.resource_id_scope, list):
                props['ResourceIdScope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_id_scope
                ]
            else:
                props['ResourceIdScope'] = self.resource_id_scope

        if self.organization_config_rule_trigger_types is not None:
            if hasattr(self.organization_config_rule_trigger_types, 'to_dict'):
                props['OrganizationConfigRuleTriggerTypes'] = self.organization_config_rule_trigger_types.to_dict()
            elif isinstance(self.organization_config_rule_trigger_types, list):
                props['OrganizationConfigRuleTriggerTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organization_config_rule_trigger_types
                ]
            else:
                props['OrganizationConfigRuleTriggerTypes'] = self.organization_config_rule_trigger_types

        if self.debug_log_delivery_accounts is not None:
            if hasattr(self.debug_log_delivery_accounts, 'to_dict'):
                props['DebugLogDeliveryAccounts'] = self.debug_log_delivery_accounts.to_dict()
            elif isinstance(self.debug_log_delivery_accounts, list):
                props['DebugLogDeliveryAccounts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.debug_log_delivery_accounts
                ]
            else:
                props['DebugLogDeliveryAccounts'] = self.debug_log_delivery_accounts

        if self.resource_types_scope is not None:
            if hasattr(self.resource_types_scope, 'to_dict'):
                props['ResourceTypesScope'] = self.resource_types_scope.to_dict()
            elif isinstance(self.resource_types_scope, list):
                props['ResourceTypesScope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_types_scope
                ]
            else:
                props['ResourceTypesScope'] = self.resource_types_scope

        if self.maximum_execution_frequency is not None:
            if hasattr(self.maximum_execution_frequency, 'to_dict'):
                props['MaximumExecutionFrequency'] = self.maximum_execution_frequency.to_dict()
            elif isinstance(self.maximum_execution_frequency, list):
                props['MaximumExecutionFrequency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_execution_frequency
                ]
            else:
                props['MaximumExecutionFrequency'] = self.maximum_execution_frequency

        if self.input_parameters is not None:
            if hasattr(self.input_parameters, 'to_dict'):
                props['InputParameters'] = self.input_parameters.to_dict()
            elif isinstance(self.input_parameters, list):
                props['InputParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.input_parameters
                ]
            else:
                props['InputParameters'] = self.input_parameters

        return props


@dataclass
class OrganizationCustomRuleMetadata:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_key_scope: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_value_scope: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_id_scope: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lambda_function_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    organization_config_rule_trigger_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_types_scope: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_execution_frequency: Optional[Union[str, MaximumExecutionFrequency, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    input_parameters: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.tag_key_scope is not None:
            if hasattr(self.tag_key_scope, 'to_dict'):
                props['TagKeyScope'] = self.tag_key_scope.to_dict()
            elif isinstance(self.tag_key_scope, list):
                props['TagKeyScope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_key_scope
                ]
            else:
                props['TagKeyScope'] = self.tag_key_scope

        if self.tag_value_scope is not None:
            if hasattr(self.tag_value_scope, 'to_dict'):
                props['TagValueScope'] = self.tag_value_scope.to_dict()
            elif isinstance(self.tag_value_scope, list):
                props['TagValueScope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_value_scope
                ]
            else:
                props['TagValueScope'] = self.tag_value_scope

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.resource_id_scope is not None:
            if hasattr(self.resource_id_scope, 'to_dict'):
                props['ResourceIdScope'] = self.resource_id_scope.to_dict()
            elif isinstance(self.resource_id_scope, list):
                props['ResourceIdScope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_id_scope
                ]
            else:
                props['ResourceIdScope'] = self.resource_id_scope

        if self.lambda_function_arn is not None:
            if hasattr(self.lambda_function_arn, 'to_dict'):
                props['LambdaFunctionArn'] = self.lambda_function_arn.to_dict()
            elif isinstance(self.lambda_function_arn, list):
                props['LambdaFunctionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lambda_function_arn
                ]
            else:
                props['LambdaFunctionArn'] = self.lambda_function_arn

        if self.organization_config_rule_trigger_types is not None:
            if hasattr(self.organization_config_rule_trigger_types, 'to_dict'):
                props['OrganizationConfigRuleTriggerTypes'] = self.organization_config_rule_trigger_types.to_dict()
            elif isinstance(self.organization_config_rule_trigger_types, list):
                props['OrganizationConfigRuleTriggerTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organization_config_rule_trigger_types
                ]
            else:
                props['OrganizationConfigRuleTriggerTypes'] = self.organization_config_rule_trigger_types

        if self.resource_types_scope is not None:
            if hasattr(self.resource_types_scope, 'to_dict'):
                props['ResourceTypesScope'] = self.resource_types_scope.to_dict()
            elif isinstance(self.resource_types_scope, list):
                props['ResourceTypesScope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_types_scope
                ]
            else:
                props['ResourceTypesScope'] = self.resource_types_scope

        if self.maximum_execution_frequency is not None:
            if hasattr(self.maximum_execution_frequency, 'to_dict'):
                props['MaximumExecutionFrequency'] = self.maximum_execution_frequency.to_dict()
            elif isinstance(self.maximum_execution_frequency, list):
                props['MaximumExecutionFrequency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_execution_frequency
                ]
            else:
                props['MaximumExecutionFrequency'] = self.maximum_execution_frequency

        if self.input_parameters is not None:
            if hasattr(self.input_parameters, 'to_dict'):
                props['InputParameters'] = self.input_parameters.to_dict()
            elif isinstance(self.input_parameters, list):
                props['InputParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.input_parameters
                ]
            else:
                props['InputParameters'] = self.input_parameters

        return props


@dataclass
class OrganizationManagedRuleMetadata:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_key_scope: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_value_scope: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_id_scope: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_types_scope: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_execution_frequency: Optional[Union[str, MaximumExecutionFrequency, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    input_parameters: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.tag_key_scope is not None:
            if hasattr(self.tag_key_scope, 'to_dict'):
                props['TagKeyScope'] = self.tag_key_scope.to_dict()
            elif isinstance(self.tag_key_scope, list):
                props['TagKeyScope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_key_scope
                ]
            else:
                props['TagKeyScope'] = self.tag_key_scope

        if self.tag_value_scope is not None:
            if hasattr(self.tag_value_scope, 'to_dict'):
                props['TagValueScope'] = self.tag_value_scope.to_dict()
            elif isinstance(self.tag_value_scope, list):
                props['TagValueScope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_value_scope
                ]
            else:
                props['TagValueScope'] = self.tag_value_scope

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.resource_id_scope is not None:
            if hasattr(self.resource_id_scope, 'to_dict'):
                props['ResourceIdScope'] = self.resource_id_scope.to_dict()
            elif isinstance(self.resource_id_scope, list):
                props['ResourceIdScope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_id_scope
                ]
            else:
                props['ResourceIdScope'] = self.resource_id_scope

        if self.rule_identifier is not None:
            if hasattr(self.rule_identifier, 'to_dict'):
                props['RuleIdentifier'] = self.rule_identifier.to_dict()
            elif isinstance(self.rule_identifier, list):
                props['RuleIdentifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_identifier
                ]
            else:
                props['RuleIdentifier'] = self.rule_identifier

        if self.resource_types_scope is not None:
            if hasattr(self.resource_types_scope, 'to_dict'):
                props['ResourceTypesScope'] = self.resource_types_scope.to_dict()
            elif isinstance(self.resource_types_scope, list):
                props['ResourceTypesScope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_types_scope
                ]
            else:
                props['ResourceTypesScope'] = self.resource_types_scope

        if self.maximum_execution_frequency is not None:
            if hasattr(self.maximum_execution_frequency, 'to_dict'):
                props['MaximumExecutionFrequency'] = self.maximum_execution_frequency.to_dict()
            elif isinstance(self.maximum_execution_frequency, list):
                props['MaximumExecutionFrequency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_execution_frequency
                ]
            else:
                props['MaximumExecutionFrequency'] = self.maximum_execution_frequency

        if self.input_parameters is not None:
            if hasattr(self.input_parameters, 'to_dict'):
                props['InputParameters'] = self.input_parameters.to_dict()
            elif isinstance(self.input_parameters, list):
                props['InputParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.input_parameters
                ]
            else:
                props['InputParameters'] = self.input_parameters

        return props


@dataclass
class OrganizationConfigRule(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-confi"""

    resource_type: ClassVar[str] = "AWS::Config::OrganizationConfigRule"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    organization_managed_rule_metadata: Optional[OrganizationManagedRuleMetadata] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    organization_config_rule_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    organization_custom_rule_metadata: Optional[OrganizationCustomRuleMetadata] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    excluded_accounts: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    organization_custom_policy_rule_metadata: Optional[OrganizationCustomPolicyRuleMetadata] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.organization_managed_rule_metadata is not None:
            # Serialize organization_managed_rule_metadata (handle intrinsic functions)
            if hasattr(self.organization_managed_rule_metadata, 'to_dict'):
                props["OrganizationManagedRuleMetadata"] = self.organization_managed_rule_metadata.to_dict()
            elif isinstance(self.organization_managed_rule_metadata, list):
                # Serialize list items (may contain intrinsic functions)
                props['OrganizationManagedRuleMetadata'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organization_managed_rule_metadata
                ]
            else:
                props["OrganizationManagedRuleMetadata"] = self.organization_managed_rule_metadata

        if self.organization_config_rule_name is not None:
            # Serialize organization_config_rule_name (handle intrinsic functions)
            if hasattr(self.organization_config_rule_name, 'to_dict'):
                props["OrganizationConfigRuleName"] = self.organization_config_rule_name.to_dict()
            elif isinstance(self.organization_config_rule_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['OrganizationConfigRuleName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organization_config_rule_name
                ]
            else:
                props["OrganizationConfigRuleName"] = self.organization_config_rule_name

        if self.organization_custom_rule_metadata is not None:
            # Serialize organization_custom_rule_metadata (handle intrinsic functions)
            if hasattr(self.organization_custom_rule_metadata, 'to_dict'):
                props["OrganizationCustomRuleMetadata"] = self.organization_custom_rule_metadata.to_dict()
            elif isinstance(self.organization_custom_rule_metadata, list):
                # Serialize list items (may contain intrinsic functions)
                props['OrganizationCustomRuleMetadata'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organization_custom_rule_metadata
                ]
            else:
                props["OrganizationCustomRuleMetadata"] = self.organization_custom_rule_metadata

        if self.excluded_accounts is not None:
            # Serialize excluded_accounts (handle intrinsic functions)
            if hasattr(self.excluded_accounts, 'to_dict'):
                props["ExcludedAccounts"] = self.excluded_accounts.to_dict()
            elif isinstance(self.excluded_accounts, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExcludedAccounts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.excluded_accounts
                ]
            else:
                props["ExcludedAccounts"] = self.excluded_accounts

        if self.organization_custom_policy_rule_metadata is not None:
            # Serialize organization_custom_policy_rule_metadata (handle intrinsic functions)
            if hasattr(self.organization_custom_policy_rule_metadata, 'to_dict'):
                props["OrganizationCustomPolicyRuleMetadata"] = self.organization_custom_policy_rule_metadata.to_dict()
            elif isinstance(self.organization_custom_policy_rule_metadata, list):
                # Serialize list items (may contain intrinsic functions)
                props['OrganizationCustomPolicyRuleMetadata'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organization_custom_policy_rule_metadata
                ]
            else:
                props["OrganizationCustomPolicyRuleMetadata"] = self.organization_custom_policy_rule_metadata

        return props



@dataclass
class ConformancePackInputParameter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parameter_value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parameter_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.parameter_value is not None:
            if hasattr(self.parameter_value, 'to_dict'):
                props['ParameterValue'] = self.parameter_value.to_dict()
            elif isinstance(self.parameter_value, list):
                props['ParameterValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameter_value
                ]
            else:
                props['ParameterValue'] = self.parameter_value

        if self.parameter_name is not None:
            if hasattr(self.parameter_name, 'to_dict'):
                props['ParameterName'] = self.parameter_name.to_dict()
            elif isinstance(self.parameter_name, list):
                props['ParameterName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameter_name
                ]
            else:
                props['ParameterName'] = self.parameter_name

        return props


@dataclass
class OrganizationConformancePack(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-confi"""

    resource_type: ClassVar[str] = "AWS::Config::OrganizationConformancePack"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    conformance_pack_input_parameters: Optional[list[ConformancePackInputParameter]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delivery_s3_bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    excluded_accounts: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delivery_s3_key_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    template_body: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    organization_conformance_pack_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    template_s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.conformance_pack_input_parameters is not None:
            # Serialize conformance_pack_input_parameters (handle intrinsic functions)
            if hasattr(self.conformance_pack_input_parameters, 'to_dict'):
                props["ConformancePackInputParameters"] = self.conformance_pack_input_parameters.to_dict()
            elif isinstance(self.conformance_pack_input_parameters, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConformancePackInputParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.conformance_pack_input_parameters
                ]
            else:
                props["ConformancePackInputParameters"] = self.conformance_pack_input_parameters

        if self.delivery_s3_bucket is not None:
            # Serialize delivery_s3_bucket (handle intrinsic functions)
            if hasattr(self.delivery_s3_bucket, 'to_dict'):
                props["DeliveryS3Bucket"] = self.delivery_s3_bucket.to_dict()
            elif isinstance(self.delivery_s3_bucket, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeliveryS3Bucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delivery_s3_bucket
                ]
            else:
                props["DeliveryS3Bucket"] = self.delivery_s3_bucket

        if self.excluded_accounts is not None:
            # Serialize excluded_accounts (handle intrinsic functions)
            if hasattr(self.excluded_accounts, 'to_dict'):
                props["ExcludedAccounts"] = self.excluded_accounts.to_dict()
            elif isinstance(self.excluded_accounts, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExcludedAccounts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.excluded_accounts
                ]
            else:
                props["ExcludedAccounts"] = self.excluded_accounts

        if self.delivery_s3_key_prefix is not None:
            # Serialize delivery_s3_key_prefix (handle intrinsic functions)
            if hasattr(self.delivery_s3_key_prefix, 'to_dict'):
                props["DeliveryS3KeyPrefix"] = self.delivery_s3_key_prefix.to_dict()
            elif isinstance(self.delivery_s3_key_prefix, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeliveryS3KeyPrefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delivery_s3_key_prefix
                ]
            else:
                props["DeliveryS3KeyPrefix"] = self.delivery_s3_key_prefix

        if self.template_body is not None:
            # Serialize template_body (handle intrinsic functions)
            if hasattr(self.template_body, 'to_dict'):
                props["TemplateBody"] = self.template_body.to_dict()
            elif isinstance(self.template_body, list):
                # Serialize list items (may contain intrinsic functions)
                props['TemplateBody'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.template_body
                ]
            else:
                props["TemplateBody"] = self.template_body

        if self.organization_conformance_pack_name is not None:
            # Serialize organization_conformance_pack_name (handle intrinsic functions)
            if hasattr(self.organization_conformance_pack_name, 'to_dict'):
                props["OrganizationConformancePackName"] = self.organization_conformance_pack_name.to_dict()
            elif isinstance(self.organization_conformance_pack_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['OrganizationConformancePackName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organization_conformance_pack_name
                ]
            else:
                props["OrganizationConformancePackName"] = self.organization_conformance_pack_name

        if self.template_s3_uri is not None:
            # Serialize template_s3_uri (handle intrinsic functions)
            if hasattr(self.template_s3_uri, 'to_dict'):
                props["TemplateS3Uri"] = self.template_s3_uri.to_dict()
            elif isinstance(self.template_s3_uri, list):
                # Serialize list items (may contain intrinsic functions)
                props['TemplateS3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.template_s3_uri
                ]
            else:
                props["TemplateS3Uri"] = self.template_s3_uri

        return props



@dataclass
class ExecutionControls:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ssm_controls: Optional[SsmControls] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ssm_controls is not None:
            if hasattr(self.ssm_controls, 'to_dict'):
                props['SsmControls'] = self.ssm_controls.to_dict()
            elif isinstance(self.ssm_controls, list):
                props['SsmControls'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ssm_controls
                ]
            else:
                props['SsmControls'] = self.ssm_controls

        return props


@dataclass
class RemediationParameterValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_value: Optional[ResourceValue] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    static_value: Optional[StaticValue] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_value is not None:
            if hasattr(self.resource_value, 'to_dict'):
                props['ResourceValue'] = self.resource_value.to_dict()
            elif isinstance(self.resource_value, list):
                props['ResourceValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_value
                ]
            else:
                props['ResourceValue'] = self.resource_value

        if self.static_value is not None:
            if hasattr(self.static_value, 'to_dict'):
                props['StaticValue'] = self.static_value.to_dict()
            elif isinstance(self.static_value, list):
                props['StaticValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.static_value
                ]
            else:
                props['StaticValue'] = self.static_value

        return props


@dataclass
class ResourceValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, ResourceValueType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class SsmControls:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    error_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    concurrent_execution_rate_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.error_percentage is not None:
            if hasattr(self.error_percentage, 'to_dict'):
                props['ErrorPercentage'] = self.error_percentage.to_dict()
            elif isinstance(self.error_percentage, list):
                props['ErrorPercentage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.error_percentage
                ]
            else:
                props['ErrorPercentage'] = self.error_percentage

        if self.concurrent_execution_rate_percentage is not None:
            if hasattr(self.concurrent_execution_rate_percentage, 'to_dict'):
                props['ConcurrentExecutionRatePercentage'] = self.concurrent_execution_rate_percentage.to_dict()
            elif isinstance(self.concurrent_execution_rate_percentage, list):
                props['ConcurrentExecutionRatePercentage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.concurrent_execution_rate_percentage
                ]
            else:
                props['ConcurrentExecutionRatePercentage'] = self.concurrent_execution_rate_percentage

        return props


@dataclass
class StaticValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-con"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    values: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.values is not None:
            if hasattr(self.values, 'to_dict'):
                props['Values'] = self.values.to_dict()
            elif isinstance(self.values, list):
                props['Values'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.values
                ]
            else:
                props['Values'] = self.values

        return props


@dataclass
class RemediationConfiguration(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-confi"""

    resource_type: ClassVar[str] = "AWS::Config::RemediationConfiguration"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    execution_controls: Optional[ExecutionControls] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    parameters: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_type: Optional[Union[str, RemediationTargetType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    config_rule_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    retry_attempt_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    maximum_automatic_attempts: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    automatic: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.target_version is not None:
            # Serialize target_version (handle intrinsic functions)
            if hasattr(self.target_version, 'to_dict'):
                props["TargetVersion"] = self.target_version.to_dict()
            elif isinstance(self.target_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_version
                ]
            else:
                props["TargetVersion"] = self.target_version

        if self.execution_controls is not None:
            # Serialize execution_controls (handle intrinsic functions)
            if hasattr(self.execution_controls, 'to_dict'):
                props["ExecutionControls"] = self.execution_controls.to_dict()
            elif isinstance(self.execution_controls, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExecutionControls'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_controls
                ]
            else:
                props["ExecutionControls"] = self.execution_controls

        if self.parameters is not None:
            # Serialize parameters (handle intrinsic functions)
            if hasattr(self.parameters, 'to_dict'):
                props["Parameters"] = self.parameters.to_dict()
            elif isinstance(self.parameters, list):
                # Serialize list items (may contain intrinsic functions)
                props['Parameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameters
                ]
            else:
                props["Parameters"] = self.parameters

        if self.target_type is not None:
            # Serialize target_type (handle intrinsic functions)
            if hasattr(self.target_type, 'to_dict'):
                props["TargetType"] = self.target_type.to_dict()
            elif isinstance(self.target_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_type
                ]
            else:
                props["TargetType"] = self.target_type

        if self.config_rule_name is not None:
            # Serialize config_rule_name (handle intrinsic functions)
            if hasattr(self.config_rule_name, 'to_dict'):
                props["ConfigRuleName"] = self.config_rule_name.to_dict()
            elif isinstance(self.config_rule_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConfigRuleName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.config_rule_name
                ]
            else:
                props["ConfigRuleName"] = self.config_rule_name

        if self.resource_type is not None:
            # Serialize resource_type (handle intrinsic functions)
            if hasattr(self.resource_type, 'to_dict'):
                props["ResourceType"] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props["ResourceType"] = self.resource_type

        if self.retry_attempt_seconds is not None:
            # Serialize retry_attempt_seconds (handle intrinsic functions)
            if hasattr(self.retry_attempt_seconds, 'to_dict'):
                props["RetryAttemptSeconds"] = self.retry_attempt_seconds.to_dict()
            elif isinstance(self.retry_attempt_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['RetryAttemptSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.retry_attempt_seconds
                ]
            else:
                props["RetryAttemptSeconds"] = self.retry_attempt_seconds

        if self.maximum_automatic_attempts is not None:
            # Serialize maximum_automatic_attempts (handle intrinsic functions)
            if hasattr(self.maximum_automatic_attempts, 'to_dict'):
                props["MaximumAutomaticAttempts"] = self.maximum_automatic_attempts.to_dict()
            elif isinstance(self.maximum_automatic_attempts, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaximumAutomaticAttempts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_automatic_attempts
                ]
            else:
                props["MaximumAutomaticAttempts"] = self.maximum_automatic_attempts

        if self.target_id is not None:
            # Serialize target_id (handle intrinsic functions)
            if hasattr(self.target_id, 'to_dict'):
                props["TargetId"] = self.target_id.to_dict()
            elif isinstance(self.target_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_id
                ]
            else:
                props["TargetId"] = self.target_id

        if self.automatic is not None:
            # Serialize automatic (handle intrinsic functions)
            if hasattr(self.automatic, 'to_dict'):
                props["Automatic"] = self.automatic.to_dict()
            elif isinstance(self.automatic, list):
                # Serialize list items (may contain intrinsic functions)
                props['Automatic'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.automatic
                ]
            else:
                props["Automatic"] = self.automatic

        return props



@dataclass
class StoredQuery(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-confi"""

    resource_type: ClassVar[str] = "AWS::Config::StoredQuery"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    query_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    query_expression: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    query_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.query_description is not None:
            # Serialize query_description (handle intrinsic functions)
            if hasattr(self.query_description, 'to_dict'):
                props["QueryDescription"] = self.query_description.to_dict()
            elif isinstance(self.query_description, list):
                # Serialize list items (may contain intrinsic functions)
                props['QueryDescription'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.query_description
                ]
            else:
                props["QueryDescription"] = self.query_description

        if self.query_expression is not None:
            # Serialize query_expression (handle intrinsic functions)
            if hasattr(self.query_expression, 'to_dict'):
                props["QueryExpression"] = self.query_expression.to_dict()
            elif isinstance(self.query_expression, list):
                # Serialize list items (may contain intrinsic functions)
                props['QueryExpression'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.query_expression
                ]
            else:
                props["QueryExpression"] = self.query_expression

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.query_name is not None:
            # Serialize query_name (handle intrinsic functions)
            if hasattr(self.query_name, 'to_dict'):
                props["QueryName"] = self.query_name.to_dict()
            elif isinstance(self.query_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['QueryName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.query_name
                ]
            else:
                props["QueryName"] = self.query_name

        return props

    @property
    def attr_query_arn(self) -> GetAtt:
        """Get the QueryArn attribute."""
        return self.get_att("QueryArn")

    @property
    def attr_query_id(self) -> GetAtt:
        """Get the QueryId attribute."""
        return self.get_att("QueryId")



