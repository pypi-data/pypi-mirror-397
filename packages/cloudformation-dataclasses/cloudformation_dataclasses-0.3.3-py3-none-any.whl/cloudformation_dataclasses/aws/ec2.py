"""
AWS CloudFormation EC2 Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:36

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service EC2
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AcceleratorManufacturer:
    """AcceleratorManufacturer enum values."""

    AMAZON_WEB_SERVICES = "amazon-web-services"
    AMD = "amd"
    NVIDIA = "nvidia"
    XILINX = "xilinx"
    HABANA = "habana"


class AcceleratorName:
    """AcceleratorName enum values."""

    A100 = "a100"
    INFERENTIA = "inferentia"
    K520 = "k520"
    K80 = "k80"
    M60 = "m60"
    RADEON_PRO_V520 = "radeon-pro-v520"
    T4 = "t4"
    VU9P = "vu9p"
    V100 = "v100"
    A10G = "a10g"
    H100 = "h100"
    T4G = "t4g"
    L40S = "l40s"
    L4 = "l4"
    GAUDI_HL_205 = "gaudi-hl-205"
    INFERENTIA2 = "inferentia2"
    TRAINIUM = "trainium"
    TRAINIUM2 = "trainium2"
    U30 = "u30"


class AcceleratorType:
    """AcceleratorType enum values."""

    GPU = "gpu"
    FPGA = "fpga"
    INFERENCE = "inference"
    MEDIA = "media"


class AccountAttributeName:
    """AccountAttributeName enum values."""

    SUPPORTED_PLATFORMS = "supported-platforms"
    DEFAULT_VPC = "default-vpc"


class ActivityStatus:
    """ActivityStatus enum values."""

    ERROR = "error"
    PENDING_FULFILLMENT = "pending_fulfillment"
    PENDING_TERMINATION = "pending_termination"
    FULFILLED = "fulfilled"


class AddressAttributeName:
    """AddressAttributeName enum values."""

    DOMAIN_NAME = "domain-name"


class AddressFamily:
    """AddressFamily enum values."""

    IPV4 = "ipv4"
    IPV6 = "ipv6"


class AddressTransferStatus:
    """AddressTransferStatus enum values."""

    PENDING = "pending"
    DISABLED = "disabled"
    ACCEPTED = "accepted"


class Affinity:
    """Affinity enum values."""

    DEFAULT = "default"
    HOST = "host"


class AllocationState:
    """AllocationState enum values."""

    AVAILABLE = "available"
    UNDER_ASSESSMENT = "under-assessment"
    PERMANENT_FAILURE = "permanent-failure"
    RELEASED = "released"
    RELEASED_PERMANENT_FAILURE = "released-permanent-failure"
    PENDING = "pending"


class AllocationStrategy:
    """AllocationStrategy enum values."""

    LOWESTPRICE = "lowestPrice"
    DIVERSIFIED = "diversified"
    CAPACITYOPTIMIZED = "capacityOptimized"
    CAPACITYOPTIMIZEDPRIORITIZED = "capacityOptimizedPrioritized"
    PRICECAPACITYOPTIMIZED = "priceCapacityOptimized"


class AllocationType:
    """AllocationType enum values."""

    USED = "used"
    FUTURE = "future"


class AllowedImagesSettingsDisabledState:
    """AllowedImagesSettingsDisabledState enum values."""

    DISABLED = "disabled"


class AllowedImagesSettingsEnabledState:
    """AllowedImagesSettingsEnabledState enum values."""

    ENABLED = "enabled"
    AUDIT_MODE = "audit-mode"


class AllowsMultipleInstanceTypes:
    """AllowsMultipleInstanceTypes enum values."""

    ON = "on"
    OFF = "off"


class AmdSevSnpSpecification:
    """AmdSevSnpSpecification enum values."""

    ENABLED = "enabled"
    DISABLED = "disabled"


class AnalysisStatus:
    """AnalysisStatus enum values."""

    RUNNING = "running"
    SUCCEEDED = "succeeded"
    FAILED = "failed"


class ApplianceModeSupportValue:
    """ApplianceModeSupportValue enum values."""

    ENABLE = "enable"
    DISABLE = "disable"


class ArchitectureType:
    """ArchitectureType enum values."""

    I386 = "i386"
    X86_64 = "x86_64"
    ARM64 = "arm64"
    X86_64_MAC = "x86_64_mac"
    ARM64_MAC = "arm64_mac"


class ArchitectureValues:
    """ArchitectureValues enum values."""

    I386 = "i386"
    X86_64 = "x86_64"
    ARM64 = "arm64"
    X86_64_MAC = "x86_64_mac"
    ARM64_MAC = "arm64_mac"


class AsnAssociationState:
    """AsnAssociationState enum values."""

    DISASSOCIATED = "disassociated"
    FAILED_DISASSOCIATION = "failed-disassociation"
    FAILED_ASSOCIATION = "failed-association"
    PENDING_DISASSOCIATION = "pending-disassociation"
    PENDING_ASSOCIATION = "pending-association"
    ASSOCIATED = "associated"


class AsnState:
    """AsnState enum values."""

    DEPROVISIONED = "deprovisioned"
    FAILED_DEPROVISION = "failed-deprovision"
    FAILED_PROVISION = "failed-provision"
    PENDING_DEPROVISION = "pending-deprovision"
    PENDING_PROVISION = "pending-provision"
    PROVISIONED = "provisioned"


class AssociatedNetworkType:
    """AssociatedNetworkType enum values."""

    VPC = "vpc"


class AssociationStatusCode:
    """AssociationStatusCode enum values."""

    ASSOCIATING = "associating"
    ASSOCIATED = "associated"
    ASSOCIATION_FAILED = "association-failed"
    DISASSOCIATING = "disassociating"
    DISASSOCIATED = "disassociated"


class AttachmentLimitType:
    """AttachmentLimitType enum values."""

    SHARED = "shared"
    DEDICATED = "dedicated"


class AttachmentStatus:
    """AttachmentStatus enum values."""

    ATTACHING = "attaching"
    ATTACHED = "attached"
    DETACHING = "detaching"
    DETACHED = "detached"


class AutoAcceptSharedAssociationsValue:
    """AutoAcceptSharedAssociationsValue enum values."""

    ENABLE = "enable"
    DISABLE = "disable"


class AutoAcceptSharedAttachmentsValue:
    """AutoAcceptSharedAttachmentsValue enum values."""

    ENABLE = "enable"
    DISABLE = "disable"


class AutoPlacement:
    """AutoPlacement enum values."""

    ON = "on"
    OFF = "off"


class AutoProvisionZonesState:
    """AutoProvisionZonesState enum values."""

    ENABLED = "enabled"
    DISABLED = "disabled"


class AutoScalingIpsState:
    """AutoScalingIpsState enum values."""

    ENABLED = "enabled"
    DISABLED = "disabled"


class AvailabilityMode:
    """AvailabilityMode enum values."""

    ZONAL = "zonal"
    REGIONAL = "regional"


class AvailabilityZoneOptInStatus:
    """AvailabilityZoneOptInStatus enum values."""

    OPT_IN_NOT_REQUIRED = "opt-in-not-required"
    OPTED_IN = "opted-in"
    NOT_OPTED_IN = "not-opted-in"


class AvailabilityZoneState:
    """AvailabilityZoneState enum values."""

    AVAILABLE = "available"
    INFORMATION = "information"
    IMPAIRED = "impaired"
    UNAVAILABLE = "unavailable"
    CONSTRAINED = "constrained"


class BandwidthWeightingType:
    """BandwidthWeightingType enum values."""

    DEFAULT = "default"
    VPC_1 = "vpc-1"
    EBS_1 = "ebs-1"


class BareMetal:
    """BareMetal enum values."""

    INCLUDED = "included"
    REQUIRED = "required"
    EXCLUDED = "excluded"


class BatchState:
    """BatchState enum values."""

    SUBMITTED = "submitted"
    ACTIVE = "active"
    CANCELLED = "cancelled"
    FAILED = "failed"
    CANCELLED_RUNNING = "cancelled_running"
    CANCELLED_TERMINATING = "cancelled_terminating"
    MODIFYING = "modifying"


class BgpStatus:
    """BgpStatus enum values."""

    UP = "up"
    DOWN = "down"


class BlockPublicAccessMode:
    """BlockPublicAccessMode enum values."""

    OFF = "off"
    BLOCK_BIDIRECTIONAL = "block-bidirectional"
    BLOCK_INGRESS = "block-ingress"


class BootModeType:
    """BootModeType enum values."""

    LEGACY_BIOS = "legacy-bios"
    UEFI = "uefi"


class BootModeValues:
    """BootModeValues enum values."""

    LEGACY_BIOS = "legacy-bios"
    UEFI = "uefi"
    UEFI_PREFERRED = "uefi-preferred"


class BundleTaskState:
    """BundleTaskState enum values."""

    PENDING = "pending"
    WAITING_FOR_SHUTDOWN = "waiting-for-shutdown"
    BUNDLING = "bundling"
    STORING = "storing"
    CANCELLING = "cancelling"
    COMPLETE = "complete"
    FAILED = "failed"


class BurstablePerformance:
    """BurstablePerformance enum values."""

    INCLUDED = "included"
    REQUIRED = "required"
    EXCLUDED = "excluded"


class ByoipCidrState:
    """ByoipCidrState enum values."""

    ADVERTISED = "advertised"
    DEPROVISIONED = "deprovisioned"
    FAILED_DEPROVISION = "failed-deprovision"
    FAILED_PROVISION = "failed-provision"
    PENDING_ADVERTISING = "pending-advertising"
    PENDING_DEPROVISION = "pending-deprovision"
    PENDING_PROVISION = "pending-provision"
    PENDING_WITHDRAWAL = "pending-withdrawal"
    PROVISIONED = "provisioned"
    PROVISIONED_NOT_PUBLICLY_ADVERTISABLE = "provisioned-not-publicly-advertisable"


class CallerRole:
    """CallerRole enum values."""

    ODCR_OWNER = "odcr-owner"
    UNUSED_RESERVATION_BILLING_OWNER = "unused-reservation-billing-owner"


class CancelBatchErrorCode:
    """CancelBatchErrorCode enum values."""

    FLEETREQUESTIDDOESNOTEXIST = "fleetRequestIdDoesNotExist"
    FLEETREQUESTIDMALFORMED = "fleetRequestIdMalformed"
    FLEETREQUESTNOTINCANCELLABLESTATE = "fleetRequestNotInCancellableState"
    UNEXPECTEDERROR = "unexpectedError"


class CancelSpotInstanceRequestState:
    """CancelSpotInstanceRequestState enum values."""

    ACTIVE = "active"
    OPEN = "open"
    CLOSED = "closed"
    CANCELLED = "cancelled"
    COMPLETED = "completed"


class CapacityBlockExtensionStatus:
    """CapacityBlockExtensionStatus enum values."""

    PAYMENT_PENDING = "payment-pending"
    PAYMENT_FAILED = "payment-failed"
    PAYMENT_SUCCEEDED = "payment-succeeded"


class CapacityBlockInterconnectStatus:
    """CapacityBlockInterconnectStatus enum values."""

    OK = "ok"
    IMPAIRED = "impaired"
    INSUFFICIENT_DATA = "insufficient-data"


class CapacityBlockResourceState:
    """CapacityBlockResourceState enum values."""

    ACTIVE = "active"
    EXPIRED = "expired"
    UNAVAILABLE = "unavailable"
    CANCELLED = "cancelled"
    FAILED = "failed"
    SCHEDULED = "scheduled"
    PAYMENT_PENDING = "payment-pending"
    PAYMENT_FAILED = "payment-failed"


class CapacityManagerDataExportStatus:
    """CapacityManagerDataExportStatus enum values."""

    PENDING = "pending"
    IN_PROGRESS = "in-progress"
    DELIVERED = "delivered"
    FAILED = "failed"


class CapacityManagerStatus:
    """CapacityManagerStatus enum values."""

    ENABLED = "enabled"
    DISABLED = "disabled"


class CapacityReservationBillingRequestStatus:
    """CapacityReservationBillingRequestStatus enum values."""

    PENDING = "pending"
    ACCEPTED = "accepted"
    REJECTED = "rejected"
    CANCELLED = "cancelled"
    REVOKED = "revoked"
    EXPIRED = "expired"


class CapacityReservationDeliveryPreference:
    """CapacityReservationDeliveryPreference enum values."""

    FIXED = "fixed"
    INCREMENTAL = "incremental"


class CapacityReservationFleetState:
    """CapacityReservationFleetState enum values."""

    SUBMITTED = "submitted"
    MODIFYING = "modifying"
    ACTIVE = "active"
    PARTIALLY_FULFILLED = "partially_fulfilled"
    EXPIRING = "expiring"
    EXPIRED = "expired"
    CANCELLING = "cancelling"
    CANCELLED = "cancelled"
    FAILED = "failed"


class CapacityReservationInstancePlatform:
    """CapacityReservationInstancePlatform enum values."""

    LINUX_UNIX = "Linux/UNIX"
    RED_HAT_ENTERPRISE_LINUX = "Red Hat Enterprise Linux"
    SUSE_LINUX = "SUSE Linux"
    WINDOWS = "Windows"
    WINDOWS_WITH_SQL_SERVER = "Windows with SQL Server"
    WINDOWS_WITH_SQL_SERVER_ENTERPRISE = "Windows with SQL Server Enterprise"
    WINDOWS_WITH_SQL_SERVER_STANDARD = "Windows with SQL Server Standard"
    WINDOWS_WITH_SQL_SERVER_WEB = "Windows with SQL Server Web"
    LINUX_WITH_SQL_SERVER_STANDARD = "Linux with SQL Server Standard"
    LINUX_WITH_SQL_SERVER_WEB = "Linux with SQL Server Web"
    LINUX_WITH_SQL_SERVER_ENTERPRISE = "Linux with SQL Server Enterprise"
    RHEL_WITH_SQL_SERVER_STANDARD = "RHEL with SQL Server Standard"
    RHEL_WITH_SQL_SERVER_ENTERPRISE = "RHEL with SQL Server Enterprise"
    RHEL_WITH_SQL_SERVER_WEB = "RHEL with SQL Server Web"
    RHEL_WITH_HA = "RHEL with HA"
    RHEL_WITH_HA_AND_SQL_SERVER_STANDARD = "RHEL with HA and SQL Server Standard"
    RHEL_WITH_HA_AND_SQL_SERVER_ENTERPRISE = "RHEL with HA and SQL Server Enterprise"
    UBUNTU_PRO = "Ubuntu Pro"


class CapacityReservationPreference:
    """CapacityReservationPreference enum values."""

    CAPACITY_RESERVATIONS_ONLY = "capacity-reservations-only"
    OPEN = "open"
    NONE = "none"


class CapacityReservationState:
    """CapacityReservationState enum values."""

    ACTIVE = "active"
    EXPIRED = "expired"
    CANCELLED = "cancelled"
    PENDING = "pending"
    FAILED = "failed"
    SCHEDULED = "scheduled"
    PAYMENT_PENDING = "payment-pending"
    PAYMENT_FAILED = "payment-failed"
    ASSESSING = "assessing"
    DELAYED = "delayed"
    UNSUPPORTED = "unsupported"
    UNAVAILABLE = "unavailable"


class CapacityReservationTenancy:
    """CapacityReservationTenancy enum values."""

    DEFAULT = "default"
    DEDICATED = "dedicated"


class CapacityReservationType:
    """CapacityReservationType enum values."""

    DEFAULT = "default"
    CAPACITY_BLOCK = "capacity-block"


class CapacityTenancy:
    """CapacityTenancy enum values."""

    DEFAULT = "default"
    DEDICATED = "dedicated"


class CarrierGatewayState:
    """CarrierGatewayState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    DELETING = "deleting"
    DELETED = "deleted"


class ClientCertificateRevocationListStatusCode:
    """ClientCertificateRevocationListStatusCode enum values."""

    PENDING = "pending"
    ACTIVE = "active"


class ClientVpnAuthenticationType:
    """ClientVpnAuthenticationType enum values."""

    CERTIFICATE_AUTHENTICATION = "certificate-authentication"
    DIRECTORY_SERVICE_AUTHENTICATION = "directory-service-authentication"
    FEDERATED_AUTHENTICATION = "federated-authentication"


class ClientVpnAuthorizationRuleStatusCode:
    """ClientVpnAuthorizationRuleStatusCode enum values."""

    AUTHORIZING = "authorizing"
    ACTIVE = "active"
    FAILED = "failed"
    REVOKING = "revoking"


class ClientVpnConnectionStatusCode:
    """ClientVpnConnectionStatusCode enum values."""

    ACTIVE = "active"
    FAILED_TO_TERMINATE = "failed-to-terminate"
    TERMINATING = "terminating"
    TERMINATED = "terminated"


class ClientVpnEndpointAttributeStatusCode:
    """ClientVpnEndpointAttributeStatusCode enum values."""

    APPLYING = "applying"
    APPLIED = "applied"


class ClientVpnEndpointStatusCode:
    """ClientVpnEndpointStatusCode enum values."""

    PENDING_ASSOCIATE = "pending-associate"
    AVAILABLE = "available"
    DELETING = "deleting"
    DELETED = "deleted"


class ClientVpnRouteStatusCode:
    """ClientVpnRouteStatusCode enum values."""

    CREATING = "creating"
    ACTIVE = "active"
    FAILED = "failed"
    DELETING = "deleting"


class Comparison:
    """Comparison enum values."""

    EQUALS = "equals"
    IN = "in"


class ConnectionNotificationState:
    """ConnectionNotificationState enum values."""

    ENABLED = "Enabled"
    DISABLED = "Disabled"


class ConnectionNotificationType:
    """ConnectionNotificationType enum values."""

    TOPIC = "Topic"


class ConnectivityType:
    """ConnectivityType enum values."""

    PRIVATE = "private"
    PUBLIC = "public"


class ContainerFormat:
    """ContainerFormat enum values."""

    OVA = "ova"


class ConversionTaskState:
    """ConversionTaskState enum values."""

    ACTIVE = "active"
    CANCELLING = "cancelling"
    CANCELLED = "cancelled"
    COMPLETED = "completed"


class CopyTagsFromSource:
    """CopyTagsFromSource enum values."""

    VOLUME = "volume"


class CpuManufacturer:
    """CpuManufacturer enum values."""

    INTEL = "intel"
    AMD = "amd"
    AMAZON_WEB_SERVICES = "amazon-web-services"
    APPLE = "apple"


class CurrencyCodeValues:
    """CurrencyCodeValues enum values."""

    USD = "USD"


class DatafeedSubscriptionState:
    """DatafeedSubscriptionState enum values."""

    ACTIVE = "Active"
    INACTIVE = "Inactive"


class DefaultInstanceMetadataEndpointState:
    """DefaultInstanceMetadataEndpointState enum values."""

    DISABLED = "disabled"
    ENABLED = "enabled"
    NO_PREFERENCE = "no-preference"


class DefaultInstanceMetadataTagsState:
    """DefaultInstanceMetadataTagsState enum values."""

    DISABLED = "disabled"
    ENABLED = "enabled"
    NO_PREFERENCE = "no-preference"


class DefaultRouteTableAssociationValue:
    """DefaultRouteTableAssociationValue enum values."""

    ENABLE = "enable"
    DISABLE = "disable"


class DefaultRouteTablePropagationValue:
    """DefaultRouteTablePropagationValue enum values."""

    ENABLE = "enable"
    DISABLE = "disable"


class DefaultTargetCapacityType:
    """DefaultTargetCapacityType enum values."""

    SPOT = "spot"
    ON_DEMAND = "on-demand"
    CAPACITY_BLOCK = "capacity-block"


class DeleteFleetErrorCode:
    """DeleteFleetErrorCode enum values."""

    FLEETIDDOESNOTEXIST = "fleetIdDoesNotExist"
    FLEETIDMALFORMED = "fleetIdMalformed"
    FLEETNOTINDELETABLESTATE = "fleetNotInDeletableState"
    UNEXPECTEDERROR = "unexpectedError"


class DeleteQueuedReservedInstancesErrorCode:
    """DeleteQueuedReservedInstancesErrorCode enum values."""

    RESERVED_INSTANCES_ID_INVALID = "reserved-instances-id-invalid"
    RESERVED_INSTANCES_NOT_IN_QUEUED_STATE = "reserved-instances-not-in-queued-state"
    UNEXPECTED_ERROR = "unexpected-error"


class DestinationFileFormat:
    """DestinationFileFormat enum values."""

    PLAIN_TEXT = "plain-text"
    PARQUET = "parquet"


class DeviceTrustProviderType:
    """DeviceTrustProviderType enum values."""

    JAMF = "jamf"
    CROWDSTRIKE = "crowdstrike"
    JUMPCLOUD = "jumpcloud"


class DeviceType:
    """DeviceType enum values."""

    EBS = "ebs"
    INSTANCE_STORE = "instance-store"


class DiskImageFormat:
    """DiskImageFormat enum values."""

    VMDK = "VMDK"
    RAW = "RAW"
    VHD = "VHD"


class DiskType:
    """DiskType enum values."""

    HDD = "hdd"
    SSD = "ssd"


class DnsNameState:
    """DnsNameState enum values."""

    PENDINGVERIFICATION = "pendingVerification"
    VERIFIED = "verified"
    FAILED = "failed"


class DnsRecordIpType:
    """DnsRecordIpType enum values."""

    IPV4 = "ipv4"
    DUALSTACK = "dualstack"
    IPV6 = "ipv6"
    SERVICE_DEFINED = "service-defined"


class DnsSupportValue:
    """DnsSupportValue enum values."""

    ENABLE = "enable"
    DISABLE = "disable"


class DomainType:
    """DomainType enum values."""

    VPC = "vpc"
    STANDARD = "standard"


class DynamicRoutingValue:
    """DynamicRoutingValue enum values."""

    ENABLE = "enable"
    DISABLE = "disable"


class EbsEncryptionSupport:
    """EbsEncryptionSupport enum values."""

    UNSUPPORTED = "unsupported"
    SUPPORTED = "supported"


class EbsNvmeSupport:
    """EbsNvmeSupport enum values."""

    UNSUPPORTED = "unsupported"
    SUPPORTED = "supported"
    REQUIRED = "required"


class EbsOptimizedSupport:
    """EbsOptimizedSupport enum values."""

    UNSUPPORTED = "unsupported"
    SUPPORTED = "supported"
    DEFAULT = "default"


class Ec2InstanceConnectEndpointState:
    """Ec2InstanceConnectEndpointState enum values."""

    CREATE_IN_PROGRESS = "create-in-progress"
    CREATE_COMPLETE = "create-complete"
    CREATE_FAILED = "create-failed"
    DELETE_IN_PROGRESS = "delete-in-progress"
    DELETE_COMPLETE = "delete-complete"
    DELETE_FAILED = "delete-failed"
    UPDATE_IN_PROGRESS = "update-in-progress"
    UPDATE_COMPLETE = "update-complete"
    UPDATE_FAILED = "update-failed"


class EkPubKeyFormat:
    """EkPubKeyFormat enum values."""

    DER = "der"
    TPMT = "tpmt"


class EkPubKeyType:
    """EkPubKeyType enum values."""

    RSA_2048 = "rsa-2048"
    ECC_SEC_P384 = "ecc-sec-p384"


class ElasticGpuState:
    """ElasticGpuState enum values."""

    ATTACHED = "ATTACHED"


class ElasticGpuStatus:
    """ElasticGpuStatus enum values."""

    OK = "OK"
    IMPAIRED = "IMPAIRED"


class EnaSupport:
    """EnaSupport enum values."""

    UNSUPPORTED = "unsupported"
    SUPPORTED = "supported"
    REQUIRED = "required"


class EncryptionStateValue:
    """EncryptionStateValue enum values."""

    ENABLING = "enabling"
    ENABLED = "enabled"
    DISABLING = "disabling"
    DISABLED = "disabled"


class EncryptionSupportOptionValue:
    """EncryptionSupportOptionValue enum values."""

    ENABLE = "enable"
    DISABLE = "disable"


class EndDateType:
    """EndDateType enum values."""

    UNLIMITED = "unlimited"
    LIMITED = "limited"


class EndpointIpAddressType:
    """EndpointIpAddressType enum values."""

    IPV4 = "ipv4"
    IPV6 = "ipv6"
    DUAL_STACK = "dual-stack"


class EphemeralNvmeSupport:
    """EphemeralNvmeSupport enum values."""

    UNSUPPORTED = "unsupported"
    SUPPORTED = "supported"
    REQUIRED = "required"


class EventCode:
    """EventCode enum values."""

    INSTANCE_REBOOT = "instance-reboot"
    SYSTEM_REBOOT = "system-reboot"
    SYSTEM_MAINTENANCE = "system-maintenance"
    INSTANCE_RETIREMENT = "instance-retirement"
    INSTANCE_STOP = "instance-stop"


class EventType:
    """EventType enum values."""

    INSTANCECHANGE = "instanceChange"
    FLEETREQUESTCHANGE = "fleetRequestChange"
    ERROR = "error"
    INFORMATION = "information"


class ExcessCapacityTerminationPolicy:
    """ExcessCapacityTerminationPolicy enum values."""

    NOTERMINATION = "noTermination"
    DEFAULT = "default"


class ExportEnvironment:
    """ExportEnvironment enum values."""

    CITRIX = "citrix"
    VMWARE = "vmware"
    MICROSOFT = "microsoft"


class ExportTaskState:
    """ExportTaskState enum values."""

    ACTIVE = "active"
    CANCELLING = "cancelling"
    CANCELLED = "cancelled"
    COMPLETED = "completed"


class FastLaunchResourceType:
    """FastLaunchResourceType enum values."""

    SNAPSHOT = "snapshot"


class FastLaunchStateCode:
    """FastLaunchStateCode enum values."""

    ENABLING = "enabling"
    ENABLING_FAILED = "enabling-failed"
    ENABLED = "enabled"
    ENABLED_FAILED = "enabled-failed"
    DISABLING = "disabling"
    DISABLING_FAILED = "disabling-failed"


class FastSnapshotRestoreStateCode:
    """FastSnapshotRestoreStateCode enum values."""

    ENABLING = "enabling"
    OPTIMIZING = "optimizing"
    ENABLED = "enabled"
    DISABLING = "disabling"
    DISABLED = "disabled"


class FilterByDimension:
    """FilterByDimension enum values."""

    RESOURCE_REGION = "resource-region"
    AVAILABILITY_ZONE_ID = "availability-zone-id"
    ACCOUNT_ID = "account-id"
    INSTANCE_FAMILY = "instance-family"
    INSTANCE_TYPE = "instance-type"
    INSTANCE_PLATFORM = "instance-platform"
    RESERVATION_ARN = "reservation-arn"
    RESERVATION_ID = "reservation-id"
    RESERVATION_TYPE = "reservation-type"
    RESERVATION_CREATE_TIMESTAMP = "reservation-create-timestamp"
    RESERVATION_START_TIMESTAMP = "reservation-start-timestamp"
    RESERVATION_END_TIMESTAMP = "reservation-end-timestamp"
    RESERVATION_END_DATE_TYPE = "reservation-end-date-type"
    TENANCY = "tenancy"
    RESERVATION_STATE = "reservation-state"
    RESERVATION_INSTANCE_MATCH_CRITERIA = "reservation-instance-match-criteria"
    RESERVATION_UNUSED_FINANCIAL_OWNER = "reservation-unused-financial-owner"


class FindingsFound:
    """FindingsFound enum values."""

    TRUE = "true"
    FALSE = "false"
    UNKNOWN = "unknown"


class FleetActivityStatus:
    """FleetActivityStatus enum values."""

    ERROR = "error"
    PENDING_FULFILLMENT = "pending_fulfillment"
    PENDING_TERMINATION = "pending_termination"
    FULFILLED = "fulfilled"


class FleetCapacityReservationTenancy:
    """FleetCapacityReservationTenancy enum values."""

    DEFAULT = "default"


class FleetCapacityReservationUsageStrategy:
    """FleetCapacityReservationUsageStrategy enum values."""

    USE_CAPACITY_RESERVATIONS_FIRST = "use-capacity-reservations-first"


class FleetEventType:
    """FleetEventType enum values."""

    INSTANCE_CHANGE = "instance-change"
    FLEET_CHANGE = "fleet-change"
    SERVICE_ERROR = "service-error"


class FleetExcessCapacityTerminationPolicy:
    """FleetExcessCapacityTerminationPolicy enum values."""

    NO_TERMINATION = "no-termination"
    TERMINATION = "termination"


class FleetInstanceMatchCriteria:
    """FleetInstanceMatchCriteria enum values."""

    OPEN = "open"


class FleetOnDemandAllocationStrategy:
    """FleetOnDemandAllocationStrategy enum values."""

    LOWEST_PRICE = "lowest-price"
    PRIORITIZED = "prioritized"


class FleetReplacementStrategy:
    """FleetReplacementStrategy enum values."""

    LAUNCH = "launch"
    LAUNCH_BEFORE_TERMINATE = "launch-before-terminate"


class FleetStateCode:
    """FleetStateCode enum values."""

    SUBMITTED = "submitted"
    ACTIVE = "active"
    DELETED = "deleted"
    FAILED = "failed"
    DELETED_RUNNING = "deleted_running"
    DELETED_TERMINATING = "deleted_terminating"
    MODIFYING = "modifying"


class FleetType:
    """FleetType enum values."""

    REQUEST = "request"
    MAINTAIN = "maintain"
    INSTANT = "instant"


class FlexibleEnaQueuesSupport:
    """FlexibleEnaQueuesSupport enum values."""

    UNSUPPORTED = "unsupported"
    SUPPORTED = "supported"


class FlowLogsResourceType:
    """FlowLogsResourceType enum values."""

    VPC = "VPC"
    SUBNET = "Subnet"
    NETWORKINTERFACE = "NetworkInterface"
    TRANSITGATEWAY = "TransitGateway"
    TRANSITGATEWAYATTACHMENT = "TransitGatewayAttachment"
    REGIONALNATGATEWAY = "RegionalNatGateway"


class FpgaImageAttributeName:
    """FpgaImageAttributeName enum values."""

    DESCRIPTION = "description"
    NAME = "name"
    LOADPERMISSION = "loadPermission"
    PRODUCTCODES = "productCodes"


class FpgaImageStateCode:
    """FpgaImageStateCode enum values."""

    PENDING = "pending"
    FAILED = "failed"
    AVAILABLE = "available"
    UNAVAILABLE = "unavailable"


class GatewayAssociationState:
    """GatewayAssociationState enum values."""

    ASSOCIATED = "associated"
    NOT_ASSOCIATED = "not-associated"
    ASSOCIATING = "associating"
    DISASSOCIATING = "disassociating"


class GatewayType:
    """GatewayType enum values."""

    IPSEC_1 = "ipsec.1"


class GroupBy:
    """GroupBy enum values."""

    RESOURCE_REGION = "resource-region"
    AVAILABILITY_ZONE_ID = "availability-zone-id"
    ACCOUNT_ID = "account-id"
    INSTANCE_FAMILY = "instance-family"
    INSTANCE_TYPE = "instance-type"
    INSTANCE_PLATFORM = "instance-platform"
    RESERVATION_ARN = "reservation-arn"
    RESERVATION_ID = "reservation-id"
    RESERVATION_TYPE = "reservation-type"
    RESERVATION_CREATE_TIMESTAMP = "reservation-create-timestamp"
    RESERVATION_START_TIMESTAMP = "reservation-start-timestamp"
    RESERVATION_END_TIMESTAMP = "reservation-end-timestamp"
    RESERVATION_END_DATE_TYPE = "reservation-end-date-type"
    TENANCY = "tenancy"
    RESERVATION_STATE = "reservation-state"
    RESERVATION_INSTANCE_MATCH_CRITERIA = "reservation-instance-match-criteria"
    RESERVATION_UNUSED_FINANCIAL_OWNER = "reservation-unused-financial-owner"


class HaStatus:
    """HaStatus enum values."""

    PROCESSING = "processing"
    ACTIVE = "active"
    STANDBY = "standby"
    INVALID = "invalid"


class HostMaintenance:
    """HostMaintenance enum values."""

    ON = "on"
    OFF = "off"


class HostRecovery:
    """HostRecovery enum values."""

    ON = "on"
    OFF = "off"


class HostTenancy:
    """HostTenancy enum values."""

    DEFAULT = "default"
    DEDICATED = "dedicated"
    HOST = "host"


class HostnameType:
    """HostnameType enum values."""

    IP_NAME = "ip-name"
    RESOURCE_NAME = "resource-name"


class HttpTokensState:
    """HttpTokensState enum values."""

    OPTIONAL = "optional"
    REQUIRED = "required"


class HypervisorType:
    """HypervisorType enum values."""

    OVM = "ovm"
    XEN = "xen"


class IamInstanceProfileAssociationState:
    """IamInstanceProfileAssociationState enum values."""

    ASSOCIATING = "associating"
    ASSOCIATED = "associated"
    DISASSOCIATING = "disassociating"
    DISASSOCIATED = "disassociated"


class Igmpv2SupportValue:
    """Igmpv2SupportValue enum values."""

    ENABLE = "enable"
    DISABLE = "disable"


class ImageAttributeName:
    """ImageAttributeName enum values."""

    DESCRIPTION = "description"
    KERNEL = "kernel"
    RAMDISK = "ramdisk"
    LAUNCHPERMISSION = "launchPermission"
    PRODUCTCODES = "productCodes"
    BLOCKDEVICEMAPPING = "blockDeviceMapping"
    SRIOVNETSUPPORT = "sriovNetSupport"
    BOOTMODE = "bootMode"
    TPMSUPPORT = "tpmSupport"
    UEFIDATA = "uefiData"
    LASTLAUNCHEDTIME = "lastLaunchedTime"
    IMDSSUPPORT = "imdsSupport"
    DEREGISTRATIONPROTECTION = "deregistrationProtection"


class ImageBlockPublicAccessDisabledState:
    """ImageBlockPublicAccessDisabledState enum values."""

    UNBLOCKED = "unblocked"


class ImageBlockPublicAccessEnabledState:
    """ImageBlockPublicAccessEnabledState enum values."""

    BLOCK_NEW_SHARING = "block-new-sharing"


class ImageReferenceOptionName:
    """ImageReferenceOptionName enum values."""

    STATE_NAME = "state-name"
    VERSION_DEPTH = "version-depth"


class ImageReferenceResourceType:
    """ImageReferenceResourceType enum values."""

    EC2_INSTANCE = "ec2:Instance"
    EC2_LAUNCHTEMPLATE = "ec2:LaunchTemplate"
    SSM_PARAMETER = "ssm:Parameter"
    IMAGEBUILDER_IMAGERECIPE = "imagebuilder:ImageRecipe"
    IMAGEBUILDER_CONTAINERRECIPE = "imagebuilder:ContainerRecipe"


class ImageState:
    """ImageState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    INVALID = "invalid"
    DEREGISTERED = "deregistered"
    TRANSIENT = "transient"
    FAILED = "failed"
    ERROR = "error"
    DISABLED = "disabled"


class ImageTypeValues:
    """ImageTypeValues enum values."""

    MACHINE = "machine"
    KERNEL = "kernel"
    RAMDISK = "ramdisk"


class ImdsSupportValues:
    """ImdsSupportValues enum values."""

    V2_0 = "v2.0"


class IngestionStatus:
    """IngestionStatus enum values."""

    INITIAL_INGESTION_IN_PROGRESS = "initial-ingestion-in-progress"
    INGESTION_COMPLETE = "ingestion-complete"
    INGESTION_FAILED = "ingestion-failed"


class InitializationType:
    """InitializationType enum values."""

    DEFAULT = "default"
    PROVISIONED_RATE = "provisioned-rate"
    VOLUME_COPY = "volume-copy"


class InstanceAttributeName:
    """InstanceAttributeName enum values."""

    INSTANCETYPE = "instanceType"
    KERNEL = "kernel"
    RAMDISK = "ramdisk"
    USERDATA = "userData"
    DISABLEAPITERMINATION = "disableApiTermination"
    INSTANCEINITIATEDSHUTDOWNBEHAVIOR = "instanceInitiatedShutdownBehavior"
    ROOTDEVICENAME = "rootDeviceName"
    BLOCKDEVICEMAPPING = "blockDeviceMapping"
    PRODUCTCODES = "productCodes"
    SOURCEDESTCHECK = "sourceDestCheck"
    GROUPSET = "groupSet"
    EBSOPTIMIZED = "ebsOptimized"
    SRIOVNETSUPPORT = "sriovNetSupport"
    ENASUPPORT = "enaSupport"
    ENCLAVEOPTIONS = "enclaveOptions"
    DISABLEAPISTOP = "disableApiStop"


class InstanceAutoRecoveryState:
    """InstanceAutoRecoveryState enum values."""

    DISABLED = "disabled"
    DEFAULT = "default"


class InstanceBandwidthWeighting:
    """InstanceBandwidthWeighting enum values."""

    DEFAULT = "default"
    VPC_1 = "vpc-1"
    EBS_1 = "ebs-1"


class InstanceBootModeValues:
    """InstanceBootModeValues enum values."""

    LEGACY_BIOS = "legacy-bios"
    UEFI = "uefi"


class InstanceEventWindowState:
    """InstanceEventWindowState enum values."""

    CREATING = "creating"
    DELETING = "deleting"
    ACTIVE = "active"
    DELETED = "deleted"


class InstanceGeneration:
    """InstanceGeneration enum values."""

    CURRENT = "current"
    PREVIOUS = "previous"


class InstanceHealthStatus:
    """InstanceHealthStatus enum values."""

    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"


class InstanceInterruptionBehavior:
    """InstanceInterruptionBehavior enum values."""

    HIBERNATE = "hibernate"
    STOP = "stop"
    TERMINATE = "terminate"


class InstanceLifecycle:
    """InstanceLifecycle enum values."""

    SPOT = "spot"
    ON_DEMAND = "on-demand"


class InstanceLifecycleType:
    """InstanceLifecycleType enum values."""

    SPOT = "spot"
    SCHEDULED = "scheduled"
    CAPACITY_BLOCK = "capacity-block"
    INTERRUPTIBLE_CAPACITY_RESERVATION = "interruptible-capacity-reservation"


class InstanceMatchCriteria:
    """InstanceMatchCriteria enum values."""

    OPEN = "open"
    TARGETED = "targeted"


class InstanceMetadataEndpointState:
    """InstanceMetadataEndpointState enum values."""

    DISABLED = "disabled"
    ENABLED = "enabled"


class InstanceMetadataOptionsState:
    """InstanceMetadataOptionsState enum values."""

    PENDING = "pending"
    APPLIED = "applied"


class InstanceMetadataProtocolState:
    """InstanceMetadataProtocolState enum values."""

    DISABLED = "disabled"
    ENABLED = "enabled"


class InstanceMetadataTagsState:
    """InstanceMetadataTagsState enum values."""

    DISABLED = "disabled"
    ENABLED = "enabled"


class InstanceRebootMigrationState:
    """InstanceRebootMigrationState enum values."""

    DISABLED = "disabled"
    DEFAULT = "default"


class InstanceStateName:
    """InstanceStateName enum values."""

    PENDING = "pending"
    RUNNING = "running"
    SHUTTING_DOWN = "shutting-down"
    TERMINATED = "terminated"
    STOPPING = "stopping"
    STOPPED = "stopped"


class InstanceStorageEncryptionSupport:
    """InstanceStorageEncryptionSupport enum values."""

    UNSUPPORTED = "unsupported"
    REQUIRED = "required"


class InstanceType:
    """InstanceType enum values."""

    A1_MEDIUM = "a1.medium"
    A1_LARGE = "a1.large"
    A1_XLARGE = "a1.xlarge"
    A1_2XLARGE = "a1.2xlarge"
    A1_4XLARGE = "a1.4xlarge"
    A1_METAL = "a1.metal"
    C1_MEDIUM = "c1.medium"
    C1_XLARGE = "c1.xlarge"
    C3_LARGE = "c3.large"
    C3_XLARGE = "c3.xlarge"
    C3_2XLARGE = "c3.2xlarge"
    C3_4XLARGE = "c3.4xlarge"
    C3_8XLARGE = "c3.8xlarge"
    C4_LARGE = "c4.large"
    C4_XLARGE = "c4.xlarge"
    C4_2XLARGE = "c4.2xlarge"
    C4_4XLARGE = "c4.4xlarge"
    C4_8XLARGE = "c4.8xlarge"
    C5_LARGE = "c5.large"
    C5_XLARGE = "c5.xlarge"
    C5_2XLARGE = "c5.2xlarge"
    C5_4XLARGE = "c5.4xlarge"
    C5_9XLARGE = "c5.9xlarge"
    C5_12XLARGE = "c5.12xlarge"
    C5_18XLARGE = "c5.18xlarge"
    C5_24XLARGE = "c5.24xlarge"
    C5_METAL = "c5.metal"
    C5A_LARGE = "c5a.large"
    C5A_XLARGE = "c5a.xlarge"
    C5A_2XLARGE = "c5a.2xlarge"
    C5A_4XLARGE = "c5a.4xlarge"
    C5A_8XLARGE = "c5a.8xlarge"
    C5A_12XLARGE = "c5a.12xlarge"
    C5A_16XLARGE = "c5a.16xlarge"
    C5A_24XLARGE = "c5a.24xlarge"
    C5AD_LARGE = "c5ad.large"
    C5AD_XLARGE = "c5ad.xlarge"
    C5AD_2XLARGE = "c5ad.2xlarge"
    C5AD_4XLARGE = "c5ad.4xlarge"
    C5AD_8XLARGE = "c5ad.8xlarge"
    C5AD_12XLARGE = "c5ad.12xlarge"
    C5AD_16XLARGE = "c5ad.16xlarge"
    C5AD_24XLARGE = "c5ad.24xlarge"
    C5D_LARGE = "c5d.large"
    C5D_XLARGE = "c5d.xlarge"
    C5D_2XLARGE = "c5d.2xlarge"
    C5D_4XLARGE = "c5d.4xlarge"
    C5D_9XLARGE = "c5d.9xlarge"
    C5D_12XLARGE = "c5d.12xlarge"
    C5D_18XLARGE = "c5d.18xlarge"
    C5D_24XLARGE = "c5d.24xlarge"
    C5D_METAL = "c5d.metal"
    C5N_LARGE = "c5n.large"
    C5N_XLARGE = "c5n.xlarge"
    C5N_2XLARGE = "c5n.2xlarge"
    C5N_4XLARGE = "c5n.4xlarge"
    C5N_9XLARGE = "c5n.9xlarge"
    C5N_18XLARGE = "c5n.18xlarge"
    C5N_METAL = "c5n.metal"
    C6G_MEDIUM = "c6g.medium"
    C6G_LARGE = "c6g.large"
    C6G_XLARGE = "c6g.xlarge"
    C6G_2XLARGE = "c6g.2xlarge"
    C6G_4XLARGE = "c6g.4xlarge"
    C6G_8XLARGE = "c6g.8xlarge"
    C6G_12XLARGE = "c6g.12xlarge"
    C6G_16XLARGE = "c6g.16xlarge"
    C6G_METAL = "c6g.metal"
    C6GD_MEDIUM = "c6gd.medium"
    C6GD_LARGE = "c6gd.large"
    C6GD_XLARGE = "c6gd.xlarge"
    C6GD_2XLARGE = "c6gd.2xlarge"
    C6GD_4XLARGE = "c6gd.4xlarge"
    C6GD_8XLARGE = "c6gd.8xlarge"
    C6GD_12XLARGE = "c6gd.12xlarge"
    C6GD_16XLARGE = "c6gd.16xlarge"
    C6GD_METAL = "c6gd.metal"
    C6GN_MEDIUM = "c6gn.medium"
    C6GN_LARGE = "c6gn.large"
    C6GN_XLARGE = "c6gn.xlarge"
    C6GN_2XLARGE = "c6gn.2xlarge"
    C6GN_4XLARGE = "c6gn.4xlarge"
    C6GN_8XLARGE = "c6gn.8xlarge"
    C6GN_12XLARGE = "c6gn.12xlarge"
    C6GN_16XLARGE = "c6gn.16xlarge"
    C6I_LARGE = "c6i.large"
    C6I_XLARGE = "c6i.xlarge"
    C6I_2XLARGE = "c6i.2xlarge"
    C6I_4XLARGE = "c6i.4xlarge"
    C6I_8XLARGE = "c6i.8xlarge"
    C6I_12XLARGE = "c6i.12xlarge"
    C6I_16XLARGE = "c6i.16xlarge"
    C6I_24XLARGE = "c6i.24xlarge"
    C6I_32XLARGE = "c6i.32xlarge"
    C6I_METAL = "c6i.metal"
    CC1_4XLARGE = "cc1.4xlarge"
    CC2_8XLARGE = "cc2.8xlarge"
    CG1_4XLARGE = "cg1.4xlarge"
    CR1_8XLARGE = "cr1.8xlarge"
    D2_XLARGE = "d2.xlarge"
    D2_2XLARGE = "d2.2xlarge"
    D2_4XLARGE = "d2.4xlarge"
    D2_8XLARGE = "d2.8xlarge"
    D3_XLARGE = "d3.xlarge"
    D3_2XLARGE = "d3.2xlarge"
    D3_4XLARGE = "d3.4xlarge"
    D3_8XLARGE = "d3.8xlarge"
    D3EN_XLARGE = "d3en.xlarge"
    D3EN_2XLARGE = "d3en.2xlarge"
    D3EN_4XLARGE = "d3en.4xlarge"
    D3EN_6XLARGE = "d3en.6xlarge"
    D3EN_8XLARGE = "d3en.8xlarge"
    D3EN_12XLARGE = "d3en.12xlarge"
    DL1_24XLARGE = "dl1.24xlarge"
    F1_2XLARGE = "f1.2xlarge"
    F1_4XLARGE = "f1.4xlarge"
    F1_16XLARGE = "f1.16xlarge"
    G2_2XLARGE = "g2.2xlarge"
    G2_8XLARGE = "g2.8xlarge"
    G3_4XLARGE = "g3.4xlarge"
    G3_8XLARGE = "g3.8xlarge"
    G3_16XLARGE = "g3.16xlarge"
    G3S_XLARGE = "g3s.xlarge"
    G4AD_XLARGE = "g4ad.xlarge"
    G4AD_2XLARGE = "g4ad.2xlarge"
    G4AD_4XLARGE = "g4ad.4xlarge"
    G4AD_8XLARGE = "g4ad.8xlarge"
    G4AD_16XLARGE = "g4ad.16xlarge"
    G4DN_XLARGE = "g4dn.xlarge"
    G4DN_2XLARGE = "g4dn.2xlarge"
    G4DN_4XLARGE = "g4dn.4xlarge"
    G4DN_8XLARGE = "g4dn.8xlarge"
    G4DN_12XLARGE = "g4dn.12xlarge"
    G4DN_16XLARGE = "g4dn.16xlarge"
    G4DN_METAL = "g4dn.metal"
    G5_XLARGE = "g5.xlarge"
    G5_2XLARGE = "g5.2xlarge"
    G5_4XLARGE = "g5.4xlarge"
    G5_8XLARGE = "g5.8xlarge"
    G5_12XLARGE = "g5.12xlarge"
    G5_16XLARGE = "g5.16xlarge"
    G5_24XLARGE = "g5.24xlarge"
    G5_48XLARGE = "g5.48xlarge"
    G5G_XLARGE = "g5g.xlarge"
    G5G_2XLARGE = "g5g.2xlarge"
    G5G_4XLARGE = "g5g.4xlarge"
    G5G_8XLARGE = "g5g.8xlarge"
    G5G_16XLARGE = "g5g.16xlarge"
    G5G_METAL = "g5g.metal"
    HI1_4XLARGE = "hi1.4xlarge"
    HPC6A_48XLARGE = "hpc6a.48xlarge"
    HS1_8XLARGE = "hs1.8xlarge"
    H1_2XLARGE = "h1.2xlarge"
    H1_4XLARGE = "h1.4xlarge"
    H1_8XLARGE = "h1.8xlarge"
    H1_16XLARGE = "h1.16xlarge"
    I2_XLARGE = "i2.xlarge"
    I2_2XLARGE = "i2.2xlarge"
    I2_4XLARGE = "i2.4xlarge"
    I2_8XLARGE = "i2.8xlarge"
    I3_LARGE = "i3.large"
    I3_XLARGE = "i3.xlarge"
    I3_2XLARGE = "i3.2xlarge"
    I3_4XLARGE = "i3.4xlarge"
    I3_8XLARGE = "i3.8xlarge"
    I3_16XLARGE = "i3.16xlarge"
    I3_METAL = "i3.metal"
    I3EN_LARGE = "i3en.large"
    I3EN_XLARGE = "i3en.xlarge"
    I3EN_2XLARGE = "i3en.2xlarge"
    I3EN_3XLARGE = "i3en.3xlarge"
    I3EN_6XLARGE = "i3en.6xlarge"
    I3EN_12XLARGE = "i3en.12xlarge"
    I3EN_24XLARGE = "i3en.24xlarge"
    I3EN_METAL = "i3en.metal"
    IM4GN_LARGE = "im4gn.large"
    IM4GN_XLARGE = "im4gn.xlarge"
    IM4GN_2XLARGE = "im4gn.2xlarge"
    IM4GN_4XLARGE = "im4gn.4xlarge"
    IM4GN_8XLARGE = "im4gn.8xlarge"
    IM4GN_16XLARGE = "im4gn.16xlarge"
    INF1_XLARGE = "inf1.xlarge"
    INF1_2XLARGE = "inf1.2xlarge"
    INF1_6XLARGE = "inf1.6xlarge"
    INF1_24XLARGE = "inf1.24xlarge"
    IS4GEN_MEDIUM = "is4gen.medium"
    IS4GEN_LARGE = "is4gen.large"
    IS4GEN_XLARGE = "is4gen.xlarge"
    IS4GEN_2XLARGE = "is4gen.2xlarge"
    IS4GEN_4XLARGE = "is4gen.4xlarge"
    IS4GEN_8XLARGE = "is4gen.8xlarge"
    M1_SMALL = "m1.small"
    M1_MEDIUM = "m1.medium"
    M1_LARGE = "m1.large"
    M1_XLARGE = "m1.xlarge"
    M2_XLARGE = "m2.xlarge"
    M2_2XLARGE = "m2.2xlarge"
    M2_4XLARGE = "m2.4xlarge"
    M3_MEDIUM = "m3.medium"
    M3_LARGE = "m3.large"
    M3_XLARGE = "m3.xlarge"
    M3_2XLARGE = "m3.2xlarge"
    M4_LARGE = "m4.large"
    M4_XLARGE = "m4.xlarge"
    M4_2XLARGE = "m4.2xlarge"
    M4_4XLARGE = "m4.4xlarge"
    M4_10XLARGE = "m4.10xlarge"
    M4_16XLARGE = "m4.16xlarge"
    M5_LARGE = "m5.large"
    M5_XLARGE = "m5.xlarge"
    M5_2XLARGE = "m5.2xlarge"
    M5_4XLARGE = "m5.4xlarge"
    M5_8XLARGE = "m5.8xlarge"
    M5_12XLARGE = "m5.12xlarge"
    M5_16XLARGE = "m5.16xlarge"
    M5_24XLARGE = "m5.24xlarge"
    M5_METAL = "m5.metal"
    M5A_LARGE = "m5a.large"
    M5A_XLARGE = "m5a.xlarge"
    M5A_2XLARGE = "m5a.2xlarge"
    M5A_4XLARGE = "m5a.4xlarge"
    M5A_8XLARGE = "m5a.8xlarge"
    M5A_12XLARGE = "m5a.12xlarge"
    M5A_16XLARGE = "m5a.16xlarge"
    M5A_24XLARGE = "m5a.24xlarge"
    M5AD_LARGE = "m5ad.large"
    M5AD_XLARGE = "m5ad.xlarge"
    M5AD_2XLARGE = "m5ad.2xlarge"
    M5AD_4XLARGE = "m5ad.4xlarge"
    M5AD_8XLARGE = "m5ad.8xlarge"
    M5AD_12XLARGE = "m5ad.12xlarge"
    M5AD_16XLARGE = "m5ad.16xlarge"
    M5AD_24XLARGE = "m5ad.24xlarge"
    M5D_LARGE = "m5d.large"
    M5D_XLARGE = "m5d.xlarge"
    M5D_2XLARGE = "m5d.2xlarge"
    M5D_4XLARGE = "m5d.4xlarge"
    M5D_8XLARGE = "m5d.8xlarge"
    M5D_12XLARGE = "m5d.12xlarge"
    M5D_16XLARGE = "m5d.16xlarge"
    M5D_24XLARGE = "m5d.24xlarge"
    M5D_METAL = "m5d.metal"
    M5DN_LARGE = "m5dn.large"
    M5DN_XLARGE = "m5dn.xlarge"
    M5DN_2XLARGE = "m5dn.2xlarge"
    M5DN_4XLARGE = "m5dn.4xlarge"
    M5DN_8XLARGE = "m5dn.8xlarge"
    M5DN_12XLARGE = "m5dn.12xlarge"
    M5DN_16XLARGE = "m5dn.16xlarge"
    M5DN_24XLARGE = "m5dn.24xlarge"
    M5DN_METAL = "m5dn.metal"
    M5N_LARGE = "m5n.large"
    M5N_XLARGE = "m5n.xlarge"
    M5N_2XLARGE = "m5n.2xlarge"
    M5N_4XLARGE = "m5n.4xlarge"
    M5N_8XLARGE = "m5n.8xlarge"
    M5N_12XLARGE = "m5n.12xlarge"
    M5N_16XLARGE = "m5n.16xlarge"
    M5N_24XLARGE = "m5n.24xlarge"
    M5N_METAL = "m5n.metal"
    M5ZN_LARGE = "m5zn.large"
    M5ZN_XLARGE = "m5zn.xlarge"
    M5ZN_2XLARGE = "m5zn.2xlarge"
    M5ZN_3XLARGE = "m5zn.3xlarge"
    M5ZN_6XLARGE = "m5zn.6xlarge"
    M5ZN_12XLARGE = "m5zn.12xlarge"
    M5ZN_METAL = "m5zn.metal"
    M6A_LARGE = "m6a.large"
    M6A_XLARGE = "m6a.xlarge"
    M6A_2XLARGE = "m6a.2xlarge"
    M6A_4XLARGE = "m6a.4xlarge"
    M6A_8XLARGE = "m6a.8xlarge"
    M6A_12XLARGE = "m6a.12xlarge"
    M6A_16XLARGE = "m6a.16xlarge"
    M6A_24XLARGE = "m6a.24xlarge"
    M6A_32XLARGE = "m6a.32xlarge"
    M6A_48XLARGE = "m6a.48xlarge"
    M6G_METAL = "m6g.metal"
    M6G_MEDIUM = "m6g.medium"
    M6G_LARGE = "m6g.large"
    M6G_XLARGE = "m6g.xlarge"
    M6G_2XLARGE = "m6g.2xlarge"
    M6G_4XLARGE = "m6g.4xlarge"
    M6G_8XLARGE = "m6g.8xlarge"
    M6G_12XLARGE = "m6g.12xlarge"
    M6G_16XLARGE = "m6g.16xlarge"
    M6GD_METAL = "m6gd.metal"
    M6GD_MEDIUM = "m6gd.medium"
    M6GD_LARGE = "m6gd.large"
    M6GD_XLARGE = "m6gd.xlarge"
    M6GD_2XLARGE = "m6gd.2xlarge"
    M6GD_4XLARGE = "m6gd.4xlarge"
    M6GD_8XLARGE = "m6gd.8xlarge"
    M6GD_12XLARGE = "m6gd.12xlarge"
    M6GD_16XLARGE = "m6gd.16xlarge"
    M6I_LARGE = "m6i.large"
    M6I_XLARGE = "m6i.xlarge"
    M6I_2XLARGE = "m6i.2xlarge"
    M6I_4XLARGE = "m6i.4xlarge"
    M6I_8XLARGE = "m6i.8xlarge"
    M6I_12XLARGE = "m6i.12xlarge"
    M6I_16XLARGE = "m6i.16xlarge"
    M6I_24XLARGE = "m6i.24xlarge"
    M6I_32XLARGE = "m6i.32xlarge"
    M6I_METAL = "m6i.metal"
    MAC1_METAL = "mac1.metal"
    P2_XLARGE = "p2.xlarge"
    P2_8XLARGE = "p2.8xlarge"
    P2_16XLARGE = "p2.16xlarge"
    P3_2XLARGE = "p3.2xlarge"
    P3_8XLARGE = "p3.8xlarge"
    P3_16XLARGE = "p3.16xlarge"
    P3DN_24XLARGE = "p3dn.24xlarge"
    P4D_24XLARGE = "p4d.24xlarge"
    R3_LARGE = "r3.large"
    R3_XLARGE = "r3.xlarge"
    R3_2XLARGE = "r3.2xlarge"
    R3_4XLARGE = "r3.4xlarge"
    R3_8XLARGE = "r3.8xlarge"
    R4_LARGE = "r4.large"
    R4_XLARGE = "r4.xlarge"
    R4_2XLARGE = "r4.2xlarge"
    R4_4XLARGE = "r4.4xlarge"
    R4_8XLARGE = "r4.8xlarge"
    R4_16XLARGE = "r4.16xlarge"
    R5_LARGE = "r5.large"
    R5_XLARGE = "r5.xlarge"
    R5_2XLARGE = "r5.2xlarge"
    R5_4XLARGE = "r5.4xlarge"
    R5_8XLARGE = "r5.8xlarge"
    R5_12XLARGE = "r5.12xlarge"
    R5_16XLARGE = "r5.16xlarge"
    R5_24XLARGE = "r5.24xlarge"
    R5_METAL = "r5.metal"
    R5A_LARGE = "r5a.large"
    R5A_XLARGE = "r5a.xlarge"
    R5A_2XLARGE = "r5a.2xlarge"
    R5A_4XLARGE = "r5a.4xlarge"
    R5A_8XLARGE = "r5a.8xlarge"
    R5A_12XLARGE = "r5a.12xlarge"
    R5A_16XLARGE = "r5a.16xlarge"
    R5A_24XLARGE = "r5a.24xlarge"
    R5AD_LARGE = "r5ad.large"
    R5AD_XLARGE = "r5ad.xlarge"
    R5AD_2XLARGE = "r5ad.2xlarge"
    R5AD_4XLARGE = "r5ad.4xlarge"
    R5AD_8XLARGE = "r5ad.8xlarge"
    R5AD_12XLARGE = "r5ad.12xlarge"
    R5AD_16XLARGE = "r5ad.16xlarge"
    R5AD_24XLARGE = "r5ad.24xlarge"
    R5B_LARGE = "r5b.large"
    R5B_XLARGE = "r5b.xlarge"
    R5B_2XLARGE = "r5b.2xlarge"
    R5B_4XLARGE = "r5b.4xlarge"
    R5B_8XLARGE = "r5b.8xlarge"
    R5B_12XLARGE = "r5b.12xlarge"
    R5B_16XLARGE = "r5b.16xlarge"
    R5B_24XLARGE = "r5b.24xlarge"
    R5B_METAL = "r5b.metal"
    R5D_LARGE = "r5d.large"
    R5D_XLARGE = "r5d.xlarge"
    R5D_2XLARGE = "r5d.2xlarge"
    R5D_4XLARGE = "r5d.4xlarge"
    R5D_8XLARGE = "r5d.8xlarge"
    R5D_12XLARGE = "r5d.12xlarge"
    R5D_16XLARGE = "r5d.16xlarge"
    R5D_24XLARGE = "r5d.24xlarge"
    R5D_METAL = "r5d.metal"
    R5DN_LARGE = "r5dn.large"
    R5DN_XLARGE = "r5dn.xlarge"
    R5DN_2XLARGE = "r5dn.2xlarge"
    R5DN_4XLARGE = "r5dn.4xlarge"
    R5DN_8XLARGE = "r5dn.8xlarge"
    R5DN_12XLARGE = "r5dn.12xlarge"
    R5DN_16XLARGE = "r5dn.16xlarge"
    R5DN_24XLARGE = "r5dn.24xlarge"
    R5DN_METAL = "r5dn.metal"
    R5N_LARGE = "r5n.large"
    R5N_XLARGE = "r5n.xlarge"
    R5N_2XLARGE = "r5n.2xlarge"
    R5N_4XLARGE = "r5n.4xlarge"
    R5N_8XLARGE = "r5n.8xlarge"
    R5N_12XLARGE = "r5n.12xlarge"
    R5N_16XLARGE = "r5n.16xlarge"
    R5N_24XLARGE = "r5n.24xlarge"
    R5N_METAL = "r5n.metal"
    R6G_MEDIUM = "r6g.medium"
    R6G_LARGE = "r6g.large"
    R6G_XLARGE = "r6g.xlarge"
    R6G_2XLARGE = "r6g.2xlarge"
    R6G_4XLARGE = "r6g.4xlarge"
    R6G_8XLARGE = "r6g.8xlarge"
    R6G_12XLARGE = "r6g.12xlarge"
    R6G_16XLARGE = "r6g.16xlarge"
    R6G_METAL = "r6g.metal"
    R6GD_MEDIUM = "r6gd.medium"
    R6GD_LARGE = "r6gd.large"
    R6GD_XLARGE = "r6gd.xlarge"
    R6GD_2XLARGE = "r6gd.2xlarge"
    R6GD_4XLARGE = "r6gd.4xlarge"
    R6GD_8XLARGE = "r6gd.8xlarge"
    R6GD_12XLARGE = "r6gd.12xlarge"
    R6GD_16XLARGE = "r6gd.16xlarge"
    R6GD_METAL = "r6gd.metal"
    R6I_LARGE = "r6i.large"
    R6I_XLARGE = "r6i.xlarge"
    R6I_2XLARGE = "r6i.2xlarge"
    R6I_4XLARGE = "r6i.4xlarge"
    R6I_8XLARGE = "r6i.8xlarge"
    R6I_12XLARGE = "r6i.12xlarge"
    R6I_16XLARGE = "r6i.16xlarge"
    R6I_24XLARGE = "r6i.24xlarge"
    R6I_32XLARGE = "r6i.32xlarge"
    R6I_METAL = "r6i.metal"
    T1_MICRO = "t1.micro"
    T2_NANO = "t2.nano"
    T2_MICRO = "t2.micro"
    T2_SMALL = "t2.small"
    T2_MEDIUM = "t2.medium"
    T2_LARGE = "t2.large"
    T2_XLARGE = "t2.xlarge"
    T2_2XLARGE = "t2.2xlarge"
    T3_NANO = "t3.nano"
    T3_MICRO = "t3.micro"
    T3_SMALL = "t3.small"
    T3_MEDIUM = "t3.medium"
    T3_LARGE = "t3.large"
    T3_XLARGE = "t3.xlarge"
    T3_2XLARGE = "t3.2xlarge"
    T3A_NANO = "t3a.nano"
    T3A_MICRO = "t3a.micro"
    T3A_SMALL = "t3a.small"
    T3A_MEDIUM = "t3a.medium"
    T3A_LARGE = "t3a.large"
    T3A_XLARGE = "t3a.xlarge"
    T3A_2XLARGE = "t3a.2xlarge"
    T4G_NANO = "t4g.nano"
    T4G_MICRO = "t4g.micro"
    T4G_SMALL = "t4g.small"
    T4G_MEDIUM = "t4g.medium"
    T4G_LARGE = "t4g.large"
    T4G_XLARGE = "t4g.xlarge"
    T4G_2XLARGE = "t4g.2xlarge"
    U_6TB1_56XLARGE = "u-6tb1.56xlarge"
    U_6TB1_112XLARGE = "u-6tb1.112xlarge"
    U_9TB1_112XLARGE = "u-9tb1.112xlarge"
    U_12TB1_112XLARGE = "u-12tb1.112xlarge"
    U_6TB1_METAL = "u-6tb1.metal"
    U_9TB1_METAL = "u-9tb1.metal"
    U_12TB1_METAL = "u-12tb1.metal"
    U_18TB1_METAL = "u-18tb1.metal"
    U_24TB1_METAL = "u-24tb1.metal"
    VT1_3XLARGE = "vt1.3xlarge"
    VT1_6XLARGE = "vt1.6xlarge"
    VT1_24XLARGE = "vt1.24xlarge"
    X1_16XLARGE = "x1.16xlarge"
    X1_32XLARGE = "x1.32xlarge"
    X1E_XLARGE = "x1e.xlarge"
    X1E_2XLARGE = "x1e.2xlarge"
    X1E_4XLARGE = "x1e.4xlarge"
    X1E_8XLARGE = "x1e.8xlarge"
    X1E_16XLARGE = "x1e.16xlarge"
    X1E_32XLARGE = "x1e.32xlarge"
    X2IEZN_2XLARGE = "x2iezn.2xlarge"
    X2IEZN_4XLARGE = "x2iezn.4xlarge"
    X2IEZN_6XLARGE = "x2iezn.6xlarge"
    X2IEZN_8XLARGE = "x2iezn.8xlarge"
    X2IEZN_12XLARGE = "x2iezn.12xlarge"
    X2IEZN_METAL = "x2iezn.metal"
    X2GD_MEDIUM = "x2gd.medium"
    X2GD_LARGE = "x2gd.large"
    X2GD_XLARGE = "x2gd.xlarge"
    X2GD_2XLARGE = "x2gd.2xlarge"
    X2GD_4XLARGE = "x2gd.4xlarge"
    X2GD_8XLARGE = "x2gd.8xlarge"
    X2GD_12XLARGE = "x2gd.12xlarge"
    X2GD_16XLARGE = "x2gd.16xlarge"
    X2GD_METAL = "x2gd.metal"
    Z1D_LARGE = "z1d.large"
    Z1D_XLARGE = "z1d.xlarge"
    Z1D_2XLARGE = "z1d.2xlarge"
    Z1D_3XLARGE = "z1d.3xlarge"
    Z1D_6XLARGE = "z1d.6xlarge"
    Z1D_12XLARGE = "z1d.12xlarge"
    Z1D_METAL = "z1d.metal"
    X2IDN_16XLARGE = "x2idn.16xlarge"
    X2IDN_24XLARGE = "x2idn.24xlarge"
    X2IDN_32XLARGE = "x2idn.32xlarge"
    X2IEDN_XLARGE = "x2iedn.xlarge"
    X2IEDN_2XLARGE = "x2iedn.2xlarge"
    X2IEDN_4XLARGE = "x2iedn.4xlarge"
    X2IEDN_8XLARGE = "x2iedn.8xlarge"
    X2IEDN_16XLARGE = "x2iedn.16xlarge"
    X2IEDN_24XLARGE = "x2iedn.24xlarge"
    X2IEDN_32XLARGE = "x2iedn.32xlarge"
    C6A_LARGE = "c6a.large"
    C6A_XLARGE = "c6a.xlarge"
    C6A_2XLARGE = "c6a.2xlarge"
    C6A_4XLARGE = "c6a.4xlarge"
    C6A_8XLARGE = "c6a.8xlarge"
    C6A_12XLARGE = "c6a.12xlarge"
    C6A_16XLARGE = "c6a.16xlarge"
    C6A_24XLARGE = "c6a.24xlarge"
    C6A_32XLARGE = "c6a.32xlarge"
    C6A_48XLARGE = "c6a.48xlarge"
    C6A_METAL = "c6a.metal"
    M6A_METAL = "m6a.metal"
    I4I_LARGE = "i4i.large"
    I4I_XLARGE = "i4i.xlarge"
    I4I_2XLARGE = "i4i.2xlarge"
    I4I_4XLARGE = "i4i.4xlarge"
    I4I_8XLARGE = "i4i.8xlarge"
    I4I_16XLARGE = "i4i.16xlarge"
    I4I_32XLARGE = "i4i.32xlarge"
    I4I_METAL = "i4i.metal"
    X2IDN_METAL = "x2idn.metal"
    X2IEDN_METAL = "x2iedn.metal"
    C7G_MEDIUM = "c7g.medium"
    C7G_LARGE = "c7g.large"
    C7G_XLARGE = "c7g.xlarge"
    C7G_2XLARGE = "c7g.2xlarge"
    C7G_4XLARGE = "c7g.4xlarge"
    C7G_8XLARGE = "c7g.8xlarge"
    C7G_12XLARGE = "c7g.12xlarge"
    C7G_16XLARGE = "c7g.16xlarge"
    MAC2_METAL = "mac2.metal"
    C6ID_LARGE = "c6id.large"
    C6ID_XLARGE = "c6id.xlarge"
    C6ID_2XLARGE = "c6id.2xlarge"
    C6ID_4XLARGE = "c6id.4xlarge"
    C6ID_8XLARGE = "c6id.8xlarge"
    C6ID_12XLARGE = "c6id.12xlarge"
    C6ID_16XLARGE = "c6id.16xlarge"
    C6ID_24XLARGE = "c6id.24xlarge"
    C6ID_32XLARGE = "c6id.32xlarge"
    C6ID_METAL = "c6id.metal"
    M6ID_LARGE = "m6id.large"
    M6ID_XLARGE = "m6id.xlarge"
    M6ID_2XLARGE = "m6id.2xlarge"
    M6ID_4XLARGE = "m6id.4xlarge"
    M6ID_8XLARGE = "m6id.8xlarge"
    M6ID_12XLARGE = "m6id.12xlarge"
    M6ID_16XLARGE = "m6id.16xlarge"
    M6ID_24XLARGE = "m6id.24xlarge"
    M6ID_32XLARGE = "m6id.32xlarge"
    M6ID_METAL = "m6id.metal"
    R6ID_LARGE = "r6id.large"
    R6ID_XLARGE = "r6id.xlarge"
    R6ID_2XLARGE = "r6id.2xlarge"
    R6ID_4XLARGE = "r6id.4xlarge"
    R6ID_8XLARGE = "r6id.8xlarge"
    R6ID_12XLARGE = "r6id.12xlarge"
    R6ID_16XLARGE = "r6id.16xlarge"
    R6ID_24XLARGE = "r6id.24xlarge"
    R6ID_32XLARGE = "r6id.32xlarge"
    R6ID_METAL = "r6id.metal"
    R6A_LARGE = "r6a.large"
    R6A_XLARGE = "r6a.xlarge"
    R6A_2XLARGE = "r6a.2xlarge"
    R6A_4XLARGE = "r6a.4xlarge"
    R6A_8XLARGE = "r6a.8xlarge"
    R6A_12XLARGE = "r6a.12xlarge"
    R6A_16XLARGE = "r6a.16xlarge"
    R6A_24XLARGE = "r6a.24xlarge"
    R6A_32XLARGE = "r6a.32xlarge"
    R6A_48XLARGE = "r6a.48xlarge"
    R6A_METAL = "r6a.metal"
    P4DE_24XLARGE = "p4de.24xlarge"
    U_3TB1_56XLARGE = "u-3tb1.56xlarge"
    U_18TB1_112XLARGE = "u-18tb1.112xlarge"
    U_24TB1_112XLARGE = "u-24tb1.112xlarge"
    TRN1_2XLARGE = "trn1.2xlarge"
    TRN1_32XLARGE = "trn1.32xlarge"
    HPC6ID_32XLARGE = "hpc6id.32xlarge"
    C6IN_LARGE = "c6in.large"
    C6IN_XLARGE = "c6in.xlarge"
    C6IN_2XLARGE = "c6in.2xlarge"
    C6IN_4XLARGE = "c6in.4xlarge"
    C6IN_8XLARGE = "c6in.8xlarge"
    C6IN_12XLARGE = "c6in.12xlarge"
    C6IN_16XLARGE = "c6in.16xlarge"
    C6IN_24XLARGE = "c6in.24xlarge"
    C6IN_32XLARGE = "c6in.32xlarge"
    M6IN_LARGE = "m6in.large"
    M6IN_XLARGE = "m6in.xlarge"
    M6IN_2XLARGE = "m6in.2xlarge"
    M6IN_4XLARGE = "m6in.4xlarge"
    M6IN_8XLARGE = "m6in.8xlarge"
    M6IN_12XLARGE = "m6in.12xlarge"
    M6IN_16XLARGE = "m6in.16xlarge"
    M6IN_24XLARGE = "m6in.24xlarge"
    M6IN_32XLARGE = "m6in.32xlarge"
    M6IDN_LARGE = "m6idn.large"
    M6IDN_XLARGE = "m6idn.xlarge"
    M6IDN_2XLARGE = "m6idn.2xlarge"
    M6IDN_4XLARGE = "m6idn.4xlarge"
    M6IDN_8XLARGE = "m6idn.8xlarge"
    M6IDN_12XLARGE = "m6idn.12xlarge"
    M6IDN_16XLARGE = "m6idn.16xlarge"
    M6IDN_24XLARGE = "m6idn.24xlarge"
    M6IDN_32XLARGE = "m6idn.32xlarge"
    R6IN_LARGE = "r6in.large"
    R6IN_XLARGE = "r6in.xlarge"
    R6IN_2XLARGE = "r6in.2xlarge"
    R6IN_4XLARGE = "r6in.4xlarge"
    R6IN_8XLARGE = "r6in.8xlarge"
    R6IN_12XLARGE = "r6in.12xlarge"
    R6IN_16XLARGE = "r6in.16xlarge"
    R6IN_24XLARGE = "r6in.24xlarge"
    R6IN_32XLARGE = "r6in.32xlarge"
    R6IDN_LARGE = "r6idn.large"
    R6IDN_XLARGE = "r6idn.xlarge"
    R6IDN_2XLARGE = "r6idn.2xlarge"
    R6IDN_4XLARGE = "r6idn.4xlarge"
    R6IDN_8XLARGE = "r6idn.8xlarge"
    R6IDN_12XLARGE = "r6idn.12xlarge"
    R6IDN_16XLARGE = "r6idn.16xlarge"
    R6IDN_24XLARGE = "r6idn.24xlarge"
    R6IDN_32XLARGE = "r6idn.32xlarge"
    C7G_METAL = "c7g.metal"
    M7G_MEDIUM = "m7g.medium"
    M7G_LARGE = "m7g.large"
    M7G_XLARGE = "m7g.xlarge"
    M7G_2XLARGE = "m7g.2xlarge"
    M7G_4XLARGE = "m7g.4xlarge"
    M7G_8XLARGE = "m7g.8xlarge"
    M7G_12XLARGE = "m7g.12xlarge"
    M7G_16XLARGE = "m7g.16xlarge"
    M7G_METAL = "m7g.metal"
    R7G_MEDIUM = "r7g.medium"
    R7G_LARGE = "r7g.large"
    R7G_XLARGE = "r7g.xlarge"
    R7G_2XLARGE = "r7g.2xlarge"
    R7G_4XLARGE = "r7g.4xlarge"
    R7G_8XLARGE = "r7g.8xlarge"
    R7G_12XLARGE = "r7g.12xlarge"
    R7G_16XLARGE = "r7g.16xlarge"
    R7G_METAL = "r7g.metal"
    C6IN_METAL = "c6in.metal"
    M6IN_METAL = "m6in.metal"
    M6IDN_METAL = "m6idn.metal"
    R6IN_METAL = "r6in.metal"
    R6IDN_METAL = "r6idn.metal"
    INF2_XLARGE = "inf2.xlarge"
    INF2_8XLARGE = "inf2.8xlarge"
    INF2_24XLARGE = "inf2.24xlarge"
    INF2_48XLARGE = "inf2.48xlarge"
    TRN1N_32XLARGE = "trn1n.32xlarge"
    I4G_LARGE = "i4g.large"
    I4G_XLARGE = "i4g.xlarge"
    I4G_2XLARGE = "i4g.2xlarge"
    I4G_4XLARGE = "i4g.4xlarge"
    I4G_8XLARGE = "i4g.8xlarge"
    I4G_16XLARGE = "i4g.16xlarge"
    HPC7G_4XLARGE = "hpc7g.4xlarge"
    HPC7G_8XLARGE = "hpc7g.8xlarge"
    HPC7G_16XLARGE = "hpc7g.16xlarge"
    C7GN_MEDIUM = "c7gn.medium"
    C7GN_LARGE = "c7gn.large"
    C7GN_XLARGE = "c7gn.xlarge"
    C7GN_2XLARGE = "c7gn.2xlarge"
    C7GN_4XLARGE = "c7gn.4xlarge"
    C7GN_8XLARGE = "c7gn.8xlarge"
    C7GN_12XLARGE = "c7gn.12xlarge"
    C7GN_16XLARGE = "c7gn.16xlarge"
    P5_48XLARGE = "p5.48xlarge"
    M7I_LARGE = "m7i.large"
    M7I_XLARGE = "m7i.xlarge"
    M7I_2XLARGE = "m7i.2xlarge"
    M7I_4XLARGE = "m7i.4xlarge"
    M7I_8XLARGE = "m7i.8xlarge"
    M7I_12XLARGE = "m7i.12xlarge"
    M7I_16XLARGE = "m7i.16xlarge"
    M7I_24XLARGE = "m7i.24xlarge"
    M7I_48XLARGE = "m7i.48xlarge"
    M7I_FLEX_LARGE = "m7i-flex.large"
    M7I_FLEX_XLARGE = "m7i-flex.xlarge"
    M7I_FLEX_2XLARGE = "m7i-flex.2xlarge"
    M7I_FLEX_4XLARGE = "m7i-flex.4xlarge"
    M7I_FLEX_8XLARGE = "m7i-flex.8xlarge"
    M7A_MEDIUM = "m7a.medium"
    M7A_LARGE = "m7a.large"
    M7A_XLARGE = "m7a.xlarge"
    M7A_2XLARGE = "m7a.2xlarge"
    M7A_4XLARGE = "m7a.4xlarge"
    M7A_8XLARGE = "m7a.8xlarge"
    M7A_12XLARGE = "m7a.12xlarge"
    M7A_16XLARGE = "m7a.16xlarge"
    M7A_24XLARGE = "m7a.24xlarge"
    M7A_32XLARGE = "m7a.32xlarge"
    M7A_48XLARGE = "m7a.48xlarge"
    M7A_METAL_48XL = "m7a.metal-48xl"
    HPC7A_12XLARGE = "hpc7a.12xlarge"
    HPC7A_24XLARGE = "hpc7a.24xlarge"
    HPC7A_48XLARGE = "hpc7a.48xlarge"
    HPC7A_96XLARGE = "hpc7a.96xlarge"
    C7GD_MEDIUM = "c7gd.medium"
    C7GD_LARGE = "c7gd.large"
    C7GD_XLARGE = "c7gd.xlarge"
    C7GD_2XLARGE = "c7gd.2xlarge"
    C7GD_4XLARGE = "c7gd.4xlarge"
    C7GD_8XLARGE = "c7gd.8xlarge"
    C7GD_12XLARGE = "c7gd.12xlarge"
    C7GD_16XLARGE = "c7gd.16xlarge"
    M7GD_MEDIUM = "m7gd.medium"
    M7GD_LARGE = "m7gd.large"
    M7GD_XLARGE = "m7gd.xlarge"
    M7GD_2XLARGE = "m7gd.2xlarge"
    M7GD_4XLARGE = "m7gd.4xlarge"
    M7GD_8XLARGE = "m7gd.8xlarge"
    M7GD_12XLARGE = "m7gd.12xlarge"
    M7GD_16XLARGE = "m7gd.16xlarge"
    R7GD_MEDIUM = "r7gd.medium"
    R7GD_LARGE = "r7gd.large"
    R7GD_XLARGE = "r7gd.xlarge"
    R7GD_2XLARGE = "r7gd.2xlarge"
    R7GD_4XLARGE = "r7gd.4xlarge"
    R7GD_8XLARGE = "r7gd.8xlarge"
    R7GD_12XLARGE = "r7gd.12xlarge"
    R7GD_16XLARGE = "r7gd.16xlarge"
    R7A_MEDIUM = "r7a.medium"
    R7A_LARGE = "r7a.large"
    R7A_XLARGE = "r7a.xlarge"
    R7A_2XLARGE = "r7a.2xlarge"
    R7A_4XLARGE = "r7a.4xlarge"
    R7A_8XLARGE = "r7a.8xlarge"
    R7A_12XLARGE = "r7a.12xlarge"
    R7A_16XLARGE = "r7a.16xlarge"
    R7A_24XLARGE = "r7a.24xlarge"
    R7A_32XLARGE = "r7a.32xlarge"
    R7A_48XLARGE = "r7a.48xlarge"
    C7I_LARGE = "c7i.large"
    C7I_XLARGE = "c7i.xlarge"
    C7I_2XLARGE = "c7i.2xlarge"
    C7I_4XLARGE = "c7i.4xlarge"
    C7I_8XLARGE = "c7i.8xlarge"
    C7I_12XLARGE = "c7i.12xlarge"
    C7I_16XLARGE = "c7i.16xlarge"
    C7I_24XLARGE = "c7i.24xlarge"
    C7I_48XLARGE = "c7i.48xlarge"
    MAC2_M2PRO_METAL = "mac2-m2pro.metal"
    R7IZ_LARGE = "r7iz.large"
    R7IZ_XLARGE = "r7iz.xlarge"
    R7IZ_2XLARGE = "r7iz.2xlarge"
    R7IZ_4XLARGE = "r7iz.4xlarge"
    R7IZ_8XLARGE = "r7iz.8xlarge"
    R7IZ_12XLARGE = "r7iz.12xlarge"
    R7IZ_16XLARGE = "r7iz.16xlarge"
    R7IZ_32XLARGE = "r7iz.32xlarge"
    C7A_MEDIUM = "c7a.medium"
    C7A_LARGE = "c7a.large"
    C7A_XLARGE = "c7a.xlarge"
    C7A_2XLARGE = "c7a.2xlarge"
    C7A_4XLARGE = "c7a.4xlarge"
    C7A_8XLARGE = "c7a.8xlarge"
    C7A_12XLARGE = "c7a.12xlarge"
    C7A_16XLARGE = "c7a.16xlarge"
    C7A_24XLARGE = "c7a.24xlarge"
    C7A_32XLARGE = "c7a.32xlarge"
    C7A_48XLARGE = "c7a.48xlarge"
    C7A_METAL_48XL = "c7a.metal-48xl"
    R7A_METAL_48XL = "r7a.metal-48xl"
    R7I_LARGE = "r7i.large"
    R7I_XLARGE = "r7i.xlarge"
    R7I_2XLARGE = "r7i.2xlarge"
    R7I_4XLARGE = "r7i.4xlarge"
    R7I_8XLARGE = "r7i.8xlarge"
    R7I_12XLARGE = "r7i.12xlarge"
    R7I_16XLARGE = "r7i.16xlarge"
    R7I_24XLARGE = "r7i.24xlarge"
    R7I_48XLARGE = "r7i.48xlarge"
    DL2Q_24XLARGE = "dl2q.24xlarge"
    MAC2_M2_METAL = "mac2-m2.metal"
    I4I_12XLARGE = "i4i.12xlarge"
    I4I_24XLARGE = "i4i.24xlarge"
    C7I_METAL_24XL = "c7i.metal-24xl"
    C7I_METAL_48XL = "c7i.metal-48xl"
    M7I_METAL_24XL = "m7i.metal-24xl"
    M7I_METAL_48XL = "m7i.metal-48xl"
    R7I_METAL_24XL = "r7i.metal-24xl"
    R7I_METAL_48XL = "r7i.metal-48xl"
    R7IZ_METAL_16XL = "r7iz.metal-16xl"
    R7IZ_METAL_32XL = "r7iz.metal-32xl"
    C7GD_METAL = "c7gd.metal"
    M7GD_METAL = "m7gd.metal"
    R7GD_METAL = "r7gd.metal"
    G6_XLARGE = "g6.xlarge"
    G6_2XLARGE = "g6.2xlarge"
    G6_4XLARGE = "g6.4xlarge"
    G6_8XLARGE = "g6.8xlarge"
    G6_12XLARGE = "g6.12xlarge"
    G6_16XLARGE = "g6.16xlarge"
    G6_24XLARGE = "g6.24xlarge"
    G6_48XLARGE = "g6.48xlarge"
    GR6_4XLARGE = "gr6.4xlarge"
    GR6_8XLARGE = "gr6.8xlarge"
    C7I_FLEX_LARGE = "c7i-flex.large"
    C7I_FLEX_XLARGE = "c7i-flex.xlarge"
    C7I_FLEX_2XLARGE = "c7i-flex.2xlarge"
    C7I_FLEX_4XLARGE = "c7i-flex.4xlarge"
    C7I_FLEX_8XLARGE = "c7i-flex.8xlarge"
    U7I_12TB_224XLARGE = "u7i-12tb.224xlarge"
    U7IN_16TB_224XLARGE = "u7in-16tb.224xlarge"
    U7IN_24TB_224XLARGE = "u7in-24tb.224xlarge"
    U7IN_32TB_224XLARGE = "u7in-32tb.224xlarge"
    U7IB_12TB_224XLARGE = "u7ib-12tb.224xlarge"
    C7GN_METAL = "c7gn.metal"
    R8G_MEDIUM = "r8g.medium"
    R8G_LARGE = "r8g.large"
    R8G_XLARGE = "r8g.xlarge"
    R8G_2XLARGE = "r8g.2xlarge"
    R8G_4XLARGE = "r8g.4xlarge"
    R8G_8XLARGE = "r8g.8xlarge"
    R8G_12XLARGE = "r8g.12xlarge"
    R8G_16XLARGE = "r8g.16xlarge"
    R8G_24XLARGE = "r8g.24xlarge"
    R8G_48XLARGE = "r8g.48xlarge"
    R8G_METAL_24XL = "r8g.metal-24xl"
    R8G_METAL_48XL = "r8g.metal-48xl"
    MAC2_M1ULTRA_METAL = "mac2-m1ultra.metal"
    G6E_XLARGE = "g6e.xlarge"
    G6E_2XLARGE = "g6e.2xlarge"
    G6E_4XLARGE = "g6e.4xlarge"
    G6E_8XLARGE = "g6e.8xlarge"
    G6E_12XLARGE = "g6e.12xlarge"
    G6E_16XLARGE = "g6e.16xlarge"
    G6E_24XLARGE = "g6e.24xlarge"
    G6E_48XLARGE = "g6e.48xlarge"
    C8G_MEDIUM = "c8g.medium"
    C8G_LARGE = "c8g.large"
    C8G_XLARGE = "c8g.xlarge"
    C8G_2XLARGE = "c8g.2xlarge"
    C8G_4XLARGE = "c8g.4xlarge"
    C8G_8XLARGE = "c8g.8xlarge"
    C8G_12XLARGE = "c8g.12xlarge"
    C8G_16XLARGE = "c8g.16xlarge"
    C8G_24XLARGE = "c8g.24xlarge"
    C8G_48XLARGE = "c8g.48xlarge"
    C8G_METAL_24XL = "c8g.metal-24xl"
    C8G_METAL_48XL = "c8g.metal-48xl"
    M8G_MEDIUM = "m8g.medium"
    M8G_LARGE = "m8g.large"
    M8G_XLARGE = "m8g.xlarge"
    M8G_2XLARGE = "m8g.2xlarge"
    M8G_4XLARGE = "m8g.4xlarge"
    M8G_8XLARGE = "m8g.8xlarge"
    M8G_12XLARGE = "m8g.12xlarge"
    M8G_16XLARGE = "m8g.16xlarge"
    M8G_24XLARGE = "m8g.24xlarge"
    M8G_48XLARGE = "m8g.48xlarge"
    M8G_METAL_24XL = "m8g.metal-24xl"
    M8G_METAL_48XL = "m8g.metal-48xl"
    X8G_MEDIUM = "x8g.medium"
    X8G_LARGE = "x8g.large"
    X8G_XLARGE = "x8g.xlarge"
    X8G_2XLARGE = "x8g.2xlarge"
    X8G_4XLARGE = "x8g.4xlarge"
    X8G_8XLARGE = "x8g.8xlarge"
    X8G_12XLARGE = "x8g.12xlarge"
    X8G_16XLARGE = "x8g.16xlarge"
    X8G_24XLARGE = "x8g.24xlarge"
    X8G_48XLARGE = "x8g.48xlarge"
    X8G_METAL_24XL = "x8g.metal-24xl"
    X8G_METAL_48XL = "x8g.metal-48xl"
    I7IE_LARGE = "i7ie.large"
    I7IE_XLARGE = "i7ie.xlarge"
    I7IE_2XLARGE = "i7ie.2xlarge"
    I7IE_3XLARGE = "i7ie.3xlarge"
    I7IE_6XLARGE = "i7ie.6xlarge"
    I7IE_12XLARGE = "i7ie.12xlarge"
    I7IE_18XLARGE = "i7ie.18xlarge"
    I7IE_24XLARGE = "i7ie.24xlarge"
    I7IE_48XLARGE = "i7ie.48xlarge"
    I8G_LARGE = "i8g.large"
    I8G_XLARGE = "i8g.xlarge"
    I8G_2XLARGE = "i8g.2xlarge"
    I8G_4XLARGE = "i8g.4xlarge"
    I8G_8XLARGE = "i8g.8xlarge"
    I8G_12XLARGE = "i8g.12xlarge"
    I8G_16XLARGE = "i8g.16xlarge"
    I8G_24XLARGE = "i8g.24xlarge"
    I8G_METAL_24XL = "i8g.metal-24xl"
    U7I_6TB_112XLARGE = "u7i-6tb.112xlarge"
    U7I_8TB_112XLARGE = "u7i-8tb.112xlarge"
    U7INH_32TB_480XLARGE = "u7inh-32tb.480xlarge"
    P5E_48XLARGE = "p5e.48xlarge"
    P5EN_48XLARGE = "p5en.48xlarge"
    F2_12XLARGE = "f2.12xlarge"
    F2_48XLARGE = "f2.48xlarge"
    TRN2_48XLARGE = "trn2.48xlarge"
    C7I_FLEX_12XLARGE = "c7i-flex.12xlarge"
    C7I_FLEX_16XLARGE = "c7i-flex.16xlarge"
    M7I_FLEX_12XLARGE = "m7i-flex.12xlarge"
    M7I_FLEX_16XLARGE = "m7i-flex.16xlarge"
    I7IE_METAL_24XL = "i7ie.metal-24xl"
    I7IE_METAL_48XL = "i7ie.metal-48xl"
    I8G_48XLARGE = "i8g.48xlarge"
    C8GD_MEDIUM = "c8gd.medium"
    C8GD_LARGE = "c8gd.large"
    C8GD_XLARGE = "c8gd.xlarge"
    C8GD_2XLARGE = "c8gd.2xlarge"
    C8GD_4XLARGE = "c8gd.4xlarge"
    C8GD_8XLARGE = "c8gd.8xlarge"
    C8GD_12XLARGE = "c8gd.12xlarge"
    C8GD_16XLARGE = "c8gd.16xlarge"
    C8GD_24XLARGE = "c8gd.24xlarge"
    C8GD_48XLARGE = "c8gd.48xlarge"
    C8GD_METAL_24XL = "c8gd.metal-24xl"
    C8GD_METAL_48XL = "c8gd.metal-48xl"
    I7I_LARGE = "i7i.large"
    I7I_XLARGE = "i7i.xlarge"
    I7I_2XLARGE = "i7i.2xlarge"
    I7I_4XLARGE = "i7i.4xlarge"
    I7I_8XLARGE = "i7i.8xlarge"
    I7I_12XLARGE = "i7i.12xlarge"
    I7I_16XLARGE = "i7i.16xlarge"
    I7I_24XLARGE = "i7i.24xlarge"
    I7I_48XLARGE = "i7i.48xlarge"
    I7I_METAL_24XL = "i7i.metal-24xl"
    I7I_METAL_48XL = "i7i.metal-48xl"
    P6_B200_48XLARGE = "p6-b200.48xlarge"
    M8GD_MEDIUM = "m8gd.medium"
    M8GD_LARGE = "m8gd.large"
    M8GD_XLARGE = "m8gd.xlarge"
    M8GD_2XLARGE = "m8gd.2xlarge"
    M8GD_4XLARGE = "m8gd.4xlarge"
    M8GD_8XLARGE = "m8gd.8xlarge"
    M8GD_12XLARGE = "m8gd.12xlarge"
    M8GD_16XLARGE = "m8gd.16xlarge"
    M8GD_24XLARGE = "m8gd.24xlarge"
    M8GD_48XLARGE = "m8gd.48xlarge"
    M8GD_METAL_24XL = "m8gd.metal-24xl"
    M8GD_METAL_48XL = "m8gd.metal-48xl"
    R8GD_MEDIUM = "r8gd.medium"
    R8GD_LARGE = "r8gd.large"
    R8GD_XLARGE = "r8gd.xlarge"
    R8GD_2XLARGE = "r8gd.2xlarge"
    R8GD_4XLARGE = "r8gd.4xlarge"
    R8GD_8XLARGE = "r8gd.8xlarge"
    R8GD_12XLARGE = "r8gd.12xlarge"
    R8GD_16XLARGE = "r8gd.16xlarge"
    R8GD_24XLARGE = "r8gd.24xlarge"
    R8GD_48XLARGE = "r8gd.48xlarge"
    R8GD_METAL_24XL = "r8gd.metal-24xl"
    R8GD_METAL_48XL = "r8gd.metal-48xl"
    C8GN_MEDIUM = "c8gn.medium"
    C8GN_LARGE = "c8gn.large"
    C8GN_XLARGE = "c8gn.xlarge"
    C8GN_2XLARGE = "c8gn.2xlarge"
    C8GN_4XLARGE = "c8gn.4xlarge"
    C8GN_8XLARGE = "c8gn.8xlarge"
    C8GN_12XLARGE = "c8gn.12xlarge"
    C8GN_16XLARGE = "c8gn.16xlarge"
    C8GN_24XLARGE = "c8gn.24xlarge"
    C8GN_48XLARGE = "c8gn.48xlarge"
    C8GN_METAL_24XL = "c8gn.metal-24xl"
    C8GN_METAL_48XL = "c8gn.metal-48xl"
    F2_6XLARGE = "f2.6xlarge"
    P6E_GB200_36XLARGE = "p6e-gb200.36xlarge"
    G6F_LARGE = "g6f.large"
    G6F_XLARGE = "g6f.xlarge"
    G6F_2XLARGE = "g6f.2xlarge"
    G6F_4XLARGE = "g6f.4xlarge"
    GR6F_4XLARGE = "gr6f.4xlarge"
    P5_4XLARGE = "p5.4xlarge"
    R8I_LARGE = "r8i.large"
    R8I_XLARGE = "r8i.xlarge"
    R8I_2XLARGE = "r8i.2xlarge"
    R8I_4XLARGE = "r8i.4xlarge"
    R8I_8XLARGE = "r8i.8xlarge"
    R8I_12XLARGE = "r8i.12xlarge"
    R8I_16XLARGE = "r8i.16xlarge"
    R8I_24XLARGE = "r8i.24xlarge"
    R8I_32XLARGE = "r8i.32xlarge"
    R8I_48XLARGE = "r8i.48xlarge"
    R8I_96XLARGE = "r8i.96xlarge"
    R8I_METAL_48XL = "r8i.metal-48xl"
    R8I_METAL_96XL = "r8i.metal-96xl"
    R8I_FLEX_LARGE = "r8i-flex.large"
    R8I_FLEX_XLARGE = "r8i-flex.xlarge"
    R8I_FLEX_2XLARGE = "r8i-flex.2xlarge"
    R8I_FLEX_4XLARGE = "r8i-flex.4xlarge"
    R8I_FLEX_8XLARGE = "r8i-flex.8xlarge"
    R8I_FLEX_12XLARGE = "r8i-flex.12xlarge"
    R8I_FLEX_16XLARGE = "r8i-flex.16xlarge"
    M8I_LARGE = "m8i.large"
    M8I_XLARGE = "m8i.xlarge"
    M8I_2XLARGE = "m8i.2xlarge"
    M8I_4XLARGE = "m8i.4xlarge"
    M8I_8XLARGE = "m8i.8xlarge"
    M8I_12XLARGE = "m8i.12xlarge"
    M8I_16XLARGE = "m8i.16xlarge"
    M8I_24XLARGE = "m8i.24xlarge"
    M8I_32XLARGE = "m8i.32xlarge"
    M8I_48XLARGE = "m8i.48xlarge"
    M8I_96XLARGE = "m8i.96xlarge"
    M8I_METAL_48XL = "m8i.metal-48xl"
    M8I_METAL_96XL = "m8i.metal-96xl"
    M8I_FLEX_LARGE = "m8i-flex.large"
    M8I_FLEX_XLARGE = "m8i-flex.xlarge"
    M8I_FLEX_2XLARGE = "m8i-flex.2xlarge"
    M8I_FLEX_4XLARGE = "m8i-flex.4xlarge"
    M8I_FLEX_8XLARGE = "m8i-flex.8xlarge"
    M8I_FLEX_12XLARGE = "m8i-flex.12xlarge"
    M8I_FLEX_16XLARGE = "m8i-flex.16xlarge"
    I8GE_LARGE = "i8ge.large"
    I8GE_XLARGE = "i8ge.xlarge"
    I8GE_2XLARGE = "i8ge.2xlarge"
    I8GE_3XLARGE = "i8ge.3xlarge"
    I8GE_6XLARGE = "i8ge.6xlarge"
    I8GE_12XLARGE = "i8ge.12xlarge"
    I8GE_18XLARGE = "i8ge.18xlarge"
    I8GE_24XLARGE = "i8ge.24xlarge"
    I8GE_48XLARGE = "i8ge.48xlarge"
    I8GE_METAL_24XL = "i8ge.metal-24xl"
    I8GE_METAL_48XL = "i8ge.metal-48xl"
    MAC_M4_METAL = "mac-m4.metal"
    MAC_M4PRO_METAL = "mac-m4pro.metal"
    R8GN_MEDIUM = "r8gn.medium"
    R8GN_LARGE = "r8gn.large"
    R8GN_XLARGE = "r8gn.xlarge"
    R8GN_2XLARGE = "r8gn.2xlarge"
    R8GN_4XLARGE = "r8gn.4xlarge"
    R8GN_8XLARGE = "r8gn.8xlarge"
    R8GN_12XLARGE = "r8gn.12xlarge"
    R8GN_16XLARGE = "r8gn.16xlarge"
    R8GN_24XLARGE = "r8gn.24xlarge"
    R8GN_48XLARGE = "r8gn.48xlarge"
    R8GN_METAL_24XL = "r8gn.metal-24xl"
    R8GN_METAL_48XL = "r8gn.metal-48xl"
    C8I_LARGE = "c8i.large"
    C8I_XLARGE = "c8i.xlarge"
    C8I_2XLARGE = "c8i.2xlarge"
    C8I_4XLARGE = "c8i.4xlarge"
    C8I_8XLARGE = "c8i.8xlarge"
    C8I_12XLARGE = "c8i.12xlarge"
    C8I_16XLARGE = "c8i.16xlarge"
    C8I_24XLARGE = "c8i.24xlarge"
    C8I_32XLARGE = "c8i.32xlarge"
    C8I_48XLARGE = "c8i.48xlarge"
    C8I_96XLARGE = "c8i.96xlarge"
    C8I_METAL_48XL = "c8i.metal-48xl"
    C8I_METAL_96XL = "c8i.metal-96xl"
    C8I_FLEX_LARGE = "c8i-flex.large"
    C8I_FLEX_XLARGE = "c8i-flex.xlarge"
    C8I_FLEX_2XLARGE = "c8i-flex.2xlarge"
    C8I_FLEX_4XLARGE = "c8i-flex.4xlarge"
    C8I_FLEX_8XLARGE = "c8i-flex.8xlarge"
    C8I_FLEX_12XLARGE = "c8i-flex.12xlarge"
    C8I_FLEX_16XLARGE = "c8i-flex.16xlarge"
    R8GB_MEDIUM = "r8gb.medium"
    R8GB_LARGE = "r8gb.large"
    R8GB_XLARGE = "r8gb.xlarge"
    R8GB_2XLARGE = "r8gb.2xlarge"
    R8GB_4XLARGE = "r8gb.4xlarge"
    R8GB_8XLARGE = "r8gb.8xlarge"
    R8GB_12XLARGE = "r8gb.12xlarge"
    R8GB_16XLARGE = "r8gb.16xlarge"
    R8GB_24XLARGE = "r8gb.24xlarge"
    R8GB_METAL_24XL = "r8gb.metal-24xl"
    M8A_MEDIUM = "m8a.medium"
    M8A_LARGE = "m8a.large"
    M8A_XLARGE = "m8a.xlarge"
    M8A_2XLARGE = "m8a.2xlarge"
    M8A_4XLARGE = "m8a.4xlarge"
    M8A_8XLARGE = "m8a.8xlarge"
    M8A_12XLARGE = "m8a.12xlarge"
    M8A_16XLARGE = "m8a.16xlarge"
    M8A_24XLARGE = "m8a.24xlarge"
    M8A_48XLARGE = "m8a.48xlarge"
    M8A_METAL_24XL = "m8a.metal-24xl"
    M8A_METAL_48XL = "m8a.metal-48xl"
    TRN2_3XLARGE = "trn2.3xlarge"
    R8A_MEDIUM = "r8a.medium"
    R8A_LARGE = "r8a.large"
    R8A_XLARGE = "r8a.xlarge"
    R8A_2XLARGE = "r8a.2xlarge"
    R8A_4XLARGE = "r8a.4xlarge"
    R8A_8XLARGE = "r8a.8xlarge"
    R8A_12XLARGE = "r8a.12xlarge"
    R8A_16XLARGE = "r8a.16xlarge"
    R8A_24XLARGE = "r8a.24xlarge"
    R8A_48XLARGE = "r8a.48xlarge"
    R8A_METAL_24XL = "r8a.metal-24xl"
    R8A_METAL_48XL = "r8a.metal-48xl"
    P6_B300_48XLARGE = "p6-b300.48xlarge"
    C8A_MEDIUM = "c8a.medium"
    C8A_LARGE = "c8a.large"
    C8A_XLARGE = "c8a.xlarge"
    C8A_2XLARGE = "c8a.2xlarge"
    C8A_4XLARGE = "c8a.4xlarge"
    C8A_8XLARGE = "c8a.8xlarge"
    C8A_12XLARGE = "c8a.12xlarge"
    C8A_16XLARGE = "c8a.16xlarge"
    C8A_24XLARGE = "c8a.24xlarge"
    C8A_48XLARGE = "c8a.48xlarge"
    C8A_METAL_24XL = "c8a.metal-24xl"
    C8A_METAL_48XL = "c8a.metal-48xl"


class InstanceTypeHypervisor:
    """InstanceTypeHypervisor enum values."""

    NITRO = "nitro"
    XEN = "xen"


class InterfacePermissionType:
    """InterfacePermissionType enum values."""

    INSTANCE_ATTACH = "INSTANCE-ATTACH"
    EIP_ASSOCIATE = "EIP-ASSOCIATE"


class InterfaceProtocolType:
    """InterfaceProtocolType enum values."""

    VLAN = "VLAN"
    GRE = "GRE"


class InternetGatewayBlockMode:
    """InternetGatewayBlockMode enum values."""

    OFF = "off"
    BLOCK_BIDIRECTIONAL = "block-bidirectional"
    BLOCK_INGRESS = "block-ingress"


class InternetGatewayExclusionMode:
    """InternetGatewayExclusionMode enum values."""

    ALLOW_BIDIRECTIONAL = "allow-bidirectional"
    ALLOW_EGRESS = "allow-egress"


class InterruptibleCapacityReservationAllocationStatus:
    """InterruptibleCapacityReservationAllocationStatus enum values."""

    PENDING = "pending"
    ACTIVE = "active"
    UPDATING = "updating"
    CANCELING = "canceling"
    CANCELED = "canceled"
    FAILED = "failed"


class InterruptionType:
    """InterruptionType enum values."""

    ADHOC = "adhoc"


class IpAddressType:
    """IpAddressType enum values."""

    IPV4 = "ipv4"
    DUALSTACK = "dualstack"
    IPV6 = "ipv6"


class IpSource:
    """IpSource enum values."""

    AMAZON = "amazon"
    BYOIP = "byoip"
    NONE = "none"


class IpamAddressHistoryResourceType:
    """IpamAddressHistoryResourceType enum values."""

    EIP = "eip"
    VPC = "vpc"
    SUBNET = "subnet"
    NETWORK_INTERFACE = "network-interface"
    INSTANCE = "instance"


class IpamAssociatedResourceDiscoveryStatus:
    """IpamAssociatedResourceDiscoveryStatus enum values."""

    ACTIVE = "active"
    NOT_FOUND = "not-found"


class IpamComplianceStatus:
    """IpamComplianceStatus enum values."""

    COMPLIANT = "compliant"
    NONCOMPLIANT = "noncompliant"
    UNMANAGED = "unmanaged"
    IGNORED = "ignored"


class IpamDiscoveryFailureCode:
    """IpamDiscoveryFailureCode enum values."""

    ASSUME_ROLE_FAILURE = "assume-role-failure"
    THROTTLING_FAILURE = "throttling-failure"
    UNAUTHORIZED_FAILURE = "unauthorized-failure"


class IpamExternalResourceVerificationTokenState:
    """IpamExternalResourceVerificationTokenState enum values."""

    CREATE_IN_PROGRESS = "create-in-progress"
    CREATE_COMPLETE = "create-complete"
    CREATE_FAILED = "create-failed"
    DELETE_IN_PROGRESS = "delete-in-progress"
    DELETE_COMPLETE = "delete-complete"
    DELETE_FAILED = "delete-failed"


class IpamManagementState:
    """IpamManagementState enum values."""

    MANAGED = "managed"
    UNMANAGED = "unmanaged"
    IGNORED = "ignored"


class IpamMeteredAccount:
    """IpamMeteredAccount enum values."""

    IPAM_OWNER = "ipam-owner"
    RESOURCE_OWNER = "resource-owner"


class IpamNetworkInterfaceAttachmentStatus:
    """IpamNetworkInterfaceAttachmentStatus enum values."""

    AVAILABLE = "available"
    IN_USE = "in-use"


class IpamOverlapStatus:
    """IpamOverlapStatus enum values."""

    OVERLAPPING = "overlapping"
    NONOVERLAPPING = "nonoverlapping"
    IGNORED = "ignored"


class IpamPolicyManagedBy:
    """IpamPolicyManagedBy enum values."""

    ACCOUNT = "account"
    DELEGATED_ADMINISTRATOR_FOR_IPAM = "delegated-administrator-for-ipam"


class IpamPolicyResourceType:
    """IpamPolicyResourceType enum values."""

    ALB = "alb"
    EIP = "eip"
    RDS = "rds"
    RNAT = "rnat"


class IpamPolicyState:
    """IpamPolicyState enum values."""

    CREATE_IN_PROGRESS = "create-in-progress"
    CREATE_COMPLETE = "create-complete"
    CREATE_FAILED = "create-failed"
    MODIFY_IN_PROGRESS = "modify-in-progress"
    MODIFY_COMPLETE = "modify-complete"
    MODIFY_FAILED = "modify-failed"
    DELETE_IN_PROGRESS = "delete-in-progress"
    DELETE_COMPLETE = "delete-complete"
    DELETE_FAILED = "delete-failed"
    ISOLATE_IN_PROGRESS = "isolate-in-progress"
    ISOLATE_COMPLETE = "isolate-complete"
    RESTORE_IN_PROGRESS = "restore-in-progress"


class IpamPoolAllocationResourceType:
    """IpamPoolAllocationResourceType enum values."""

    IPAM_POOL = "ipam-pool"
    VPC = "vpc"
    EC2_PUBLIC_IPV4_POOL = "ec2-public-ipv4-pool"
    CUSTOM = "custom"
    SUBNET = "subnet"
    EIP = "eip"
    ANYCAST_IP_LIST = "anycast-ip-list"


class IpamPoolAwsService:
    """IpamPoolAwsService enum values."""

    EC2 = "ec2"
    GLOBAL_SERVICES = "global-services"


class IpamPoolCidrFailureCode:
    """IpamPoolCidrFailureCode enum values."""

    CIDR_NOT_AVAILABLE = "cidr-not-available"
    LIMIT_EXCEEDED = "limit-exceeded"


class IpamPoolCidrState:
    """IpamPoolCidrState enum values."""

    PENDING_PROVISION = "pending-provision"
    PROVISIONED = "provisioned"
    FAILED_PROVISION = "failed-provision"
    PENDING_DEPROVISION = "pending-deprovision"
    DEPROVISIONED = "deprovisioned"
    FAILED_DEPROVISION = "failed-deprovision"
    PENDING_IMPORT = "pending-import"
    FAILED_IMPORT = "failed-import"


class IpamPoolPublicIpSource:
    """IpamPoolPublicIpSource enum values."""

    AMAZON = "amazon"
    BYOIP = "byoip"


class IpamPoolSourceResourceType:
    """IpamPoolSourceResourceType enum values."""

    VPC = "vpc"


class IpamPoolState:
    """IpamPoolState enum values."""

    CREATE_IN_PROGRESS = "create-in-progress"
    CREATE_COMPLETE = "create-complete"
    CREATE_FAILED = "create-failed"
    MODIFY_IN_PROGRESS = "modify-in-progress"
    MODIFY_COMPLETE = "modify-complete"
    MODIFY_FAILED = "modify-failed"
    DELETE_IN_PROGRESS = "delete-in-progress"
    DELETE_COMPLETE = "delete-complete"
    DELETE_FAILED = "delete-failed"
    ISOLATE_IN_PROGRESS = "isolate-in-progress"
    ISOLATE_COMPLETE = "isolate-complete"
    RESTORE_IN_PROGRESS = "restore-in-progress"


class IpamPrefixListResolverRuleConditionOperation:
    """IpamPrefixListResolverRuleConditionOperation enum values."""

    EQUALS = "equals"
    NOT_EQUALS = "not-equals"
    SUBNET_OF = "subnet-of"


class IpamPrefixListResolverRuleType:
    """IpamPrefixListResolverRuleType enum values."""

    STATIC_CIDR = "static-cidr"
    IPAM_RESOURCE_CIDR = "ipam-resource-cidr"
    IPAM_POOL_CIDR = "ipam-pool-cidr"


class IpamPrefixListResolverState:
    """IpamPrefixListResolverState enum values."""

    CREATE_IN_PROGRESS = "create-in-progress"
    CREATE_COMPLETE = "create-complete"
    CREATE_FAILED = "create-failed"
    MODIFY_IN_PROGRESS = "modify-in-progress"
    MODIFY_COMPLETE = "modify-complete"
    MODIFY_FAILED = "modify-failed"
    DELETE_IN_PROGRESS = "delete-in-progress"
    DELETE_COMPLETE = "delete-complete"
    DELETE_FAILED = "delete-failed"
    ISOLATE_IN_PROGRESS = "isolate-in-progress"
    ISOLATE_COMPLETE = "isolate-complete"
    RESTORE_IN_PROGRESS = "restore-in-progress"


class IpamPrefixListResolverTargetState:
    """IpamPrefixListResolverTargetState enum values."""

    CREATE_IN_PROGRESS = "create-in-progress"
    CREATE_COMPLETE = "create-complete"
    CREATE_FAILED = "create-failed"
    MODIFY_IN_PROGRESS = "modify-in-progress"
    MODIFY_COMPLETE = "modify-complete"
    MODIFY_FAILED = "modify-failed"
    SYNC_IN_PROGRESS = "sync-in-progress"
    SYNC_COMPLETE = "sync-complete"
    SYNC_FAILED = "sync-failed"
    DELETE_IN_PROGRESS = "delete-in-progress"
    DELETE_COMPLETE = "delete-complete"
    DELETE_FAILED = "delete-failed"
    ISOLATE_IN_PROGRESS = "isolate-in-progress"
    ISOLATE_COMPLETE = "isolate-complete"
    RESTORE_IN_PROGRESS = "restore-in-progress"


class IpamPrefixListResolverVersionCreationStatus:
    """IpamPrefixListResolverVersionCreationStatus enum values."""

    PENDING = "pending"
    SUCCESS = "success"
    FAILURE = "failure"


class IpamPublicAddressAssociationStatus:
    """IpamPublicAddressAssociationStatus enum values."""

    ASSOCIATED = "associated"
    DISASSOCIATED = "disassociated"


class IpamPublicAddressAwsService:
    """IpamPublicAddressAwsService enum values."""

    NAT_GATEWAY = "nat-gateway"
    DATABASE_MIGRATION_SERVICE = "database-migration-service"
    REDSHIFT = "redshift"
    ELASTIC_CONTAINER_SERVICE = "elastic-container-service"
    RELATIONAL_DATABASE_SERVICE = "relational-database-service"
    SITE_TO_SITE_VPN = "site-to-site-vpn"
    LOAD_BALANCER = "load-balancer"
    GLOBAL_ACCELERATOR = "global-accelerator"
    CLOUDFRONT = "cloudfront"
    OTHER = "other"


class IpamPublicAddressType:
    """IpamPublicAddressType enum values."""

    SERVICE_MANAGED_IP = "service-managed-ip"
    SERVICE_MANAGED_BYOIP = "service-managed-byoip"
    AMAZON_OWNED_EIP = "amazon-owned-eip"
    AMAZON_OWNED_CONTIG = "amazon-owned-contig"
    BYOIP = "byoip"
    EC2_PUBLIC_IP = "ec2-public-ip"
    ANYCAST_IP_LIST_IP = "anycast-ip-list-ip"


class IpamResourceCidrIpSource:
    """IpamResourceCidrIpSource enum values."""

    AMAZON = "amazon"
    BYOIP = "byoip"
    NONE = "none"


class IpamResourceDiscoveryAssociationState:
    """IpamResourceDiscoveryAssociationState enum values."""

    ASSOCIATE_IN_PROGRESS = "associate-in-progress"
    ASSOCIATE_COMPLETE = "associate-complete"
    ASSOCIATE_FAILED = "associate-failed"
    DISASSOCIATE_IN_PROGRESS = "disassociate-in-progress"
    DISASSOCIATE_COMPLETE = "disassociate-complete"
    DISASSOCIATE_FAILED = "disassociate-failed"
    ISOLATE_IN_PROGRESS = "isolate-in-progress"
    ISOLATE_COMPLETE = "isolate-complete"
    RESTORE_IN_PROGRESS = "restore-in-progress"


class IpamResourceDiscoveryState:
    """IpamResourceDiscoveryState enum values."""

    CREATE_IN_PROGRESS = "create-in-progress"
    CREATE_COMPLETE = "create-complete"
    CREATE_FAILED = "create-failed"
    MODIFY_IN_PROGRESS = "modify-in-progress"
    MODIFY_COMPLETE = "modify-complete"
    MODIFY_FAILED = "modify-failed"
    DELETE_IN_PROGRESS = "delete-in-progress"
    DELETE_COMPLETE = "delete-complete"
    DELETE_FAILED = "delete-failed"
    ISOLATE_IN_PROGRESS = "isolate-in-progress"
    ISOLATE_COMPLETE = "isolate-complete"
    RESTORE_IN_PROGRESS = "restore-in-progress"


class IpamResourceType:
    """IpamResourceType enum values."""

    VPC = "vpc"
    SUBNET = "subnet"
    EIP = "eip"
    PUBLIC_IPV4_POOL = "public-ipv4-pool"
    IPV6_POOL = "ipv6-pool"
    ENI = "eni"
    ANYCAST_IP_LIST = "anycast-ip-list"


class IpamScopeExternalAuthorityType:
    """IpamScopeExternalAuthorityType enum values."""

    INFOBLOX = "infoblox"


class IpamScopeState:
    """IpamScopeState enum values."""

    CREATE_IN_PROGRESS = "create-in-progress"
    CREATE_COMPLETE = "create-complete"
    CREATE_FAILED = "create-failed"
    MODIFY_IN_PROGRESS = "modify-in-progress"
    MODIFY_COMPLETE = "modify-complete"
    MODIFY_FAILED = "modify-failed"
    DELETE_IN_PROGRESS = "delete-in-progress"
    DELETE_COMPLETE = "delete-complete"
    DELETE_FAILED = "delete-failed"
    ISOLATE_IN_PROGRESS = "isolate-in-progress"
    ISOLATE_COMPLETE = "isolate-complete"
    RESTORE_IN_PROGRESS = "restore-in-progress"


class IpamScopeType:
    """IpamScopeType enum values."""

    PUBLIC = "public"
    PRIVATE = "private"


class IpamState:
    """IpamState enum values."""

    CREATE_IN_PROGRESS = "create-in-progress"
    CREATE_COMPLETE = "create-complete"
    CREATE_FAILED = "create-failed"
    MODIFY_IN_PROGRESS = "modify-in-progress"
    MODIFY_COMPLETE = "modify-complete"
    MODIFY_FAILED = "modify-failed"
    DELETE_IN_PROGRESS = "delete-in-progress"
    DELETE_COMPLETE = "delete-complete"
    DELETE_FAILED = "delete-failed"
    ISOLATE_IN_PROGRESS = "isolate-in-progress"
    ISOLATE_COMPLETE = "isolate-complete"
    RESTORE_IN_PROGRESS = "restore-in-progress"


class IpamTier:
    """IpamTier enum values."""

    FREE = "free"
    ADVANCED = "advanced"


class Ipv6AddressAttribute:
    """Ipv6AddressAttribute enum values."""

    PUBLIC = "public"
    PRIVATE = "private"


class Ipv6SupportValue:
    """Ipv6SupportValue enum values."""

    ENABLE = "enable"
    DISABLE = "disable"


class KeyFormat:
    """KeyFormat enum values."""

    PEM = "pem"
    PPK = "ppk"


class KeyType:
    """KeyType enum values."""

    RSA = "rsa"
    ED25519 = "ed25519"


class LaunchTemplateAutoRecoveryState:
    """LaunchTemplateAutoRecoveryState enum values."""

    DEFAULT = "default"
    DISABLED = "disabled"


class LaunchTemplateErrorCode:
    """LaunchTemplateErrorCode enum values."""

    LAUNCHTEMPLATEIDDOESNOTEXIST = "launchTemplateIdDoesNotExist"
    LAUNCHTEMPLATEIDMALFORMED = "launchTemplateIdMalformed"
    LAUNCHTEMPLATENAMEDOESNOTEXIST = "launchTemplateNameDoesNotExist"
    LAUNCHTEMPLATENAMEMALFORMED = "launchTemplateNameMalformed"
    LAUNCHTEMPLATEVERSIONDOESNOTEXIST = "launchTemplateVersionDoesNotExist"
    UNEXPECTEDERROR = "unexpectedError"


class LaunchTemplateHttpTokensState:
    """LaunchTemplateHttpTokensState enum values."""

    OPTIONAL = "optional"
    REQUIRED = "required"


class LaunchTemplateInstanceMetadataEndpointState:
    """LaunchTemplateInstanceMetadataEndpointState enum values."""

    DISABLED = "disabled"
    ENABLED = "enabled"


class LaunchTemplateInstanceMetadataOptionsState:
    """LaunchTemplateInstanceMetadataOptionsState enum values."""

    PENDING = "pending"
    APPLIED = "applied"


class LaunchTemplateInstanceMetadataProtocolIpv6:
    """LaunchTemplateInstanceMetadataProtocolIpv6 enum values."""

    DISABLED = "disabled"
    ENABLED = "enabled"


class LaunchTemplateInstanceMetadataTagsState:
    """LaunchTemplateInstanceMetadataTagsState enum values."""

    DISABLED = "disabled"
    ENABLED = "enabled"


class ListingState:
    """ListingState enum values."""

    AVAILABLE = "available"
    SOLD = "sold"
    CANCELLED = "cancelled"
    PENDING = "pending"


class ListingStatus:
    """ListingStatus enum values."""

    ACTIVE = "active"
    PENDING = "pending"
    CANCELLED = "cancelled"
    CLOSED = "closed"


class LocalGatewayRouteState:
    """LocalGatewayRouteState enum values."""

    PENDING = "pending"
    ACTIVE = "active"
    BLACKHOLE = "blackhole"
    DELETING = "deleting"
    DELETED = "deleted"


class LocalGatewayRouteTableMode:
    """LocalGatewayRouteTableMode enum values."""

    DIRECT_VPC_ROUTING = "direct-vpc-routing"
    COIP = "coip"


class LocalGatewayRouteType:
    """LocalGatewayRouteType enum values."""

    STATIC = "static"
    PROPAGATED = "propagated"


class LocalGatewayVirtualInterfaceConfigurationState:
    """LocalGatewayVirtualInterfaceConfigurationState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    DELETING = "deleting"
    DELETED = "deleted"


class LocalGatewayVirtualInterfaceGroupConfigurationState:
    """LocalGatewayVirtualInterfaceGroupConfigurationState enum values."""

    PENDING = "pending"
    INCOMPLETE = "incomplete"
    AVAILABLE = "available"
    DELETING = "deleting"
    DELETED = "deleted"


class LocalStorage:
    """LocalStorage enum values."""

    INCLUDED = "included"
    REQUIRED = "required"
    EXCLUDED = "excluded"


class LocalStorageType:
    """LocalStorageType enum values."""

    HDD = "hdd"
    SSD = "ssd"


class LocationType:
    """LocationType enum values."""

    REGION = "region"
    AVAILABILITY_ZONE = "availability-zone"
    AVAILABILITY_ZONE_ID = "availability-zone-id"
    OUTPOST = "outpost"


class LockMode:
    """LockMode enum values."""

    COMPLIANCE = "compliance"
    GOVERNANCE = "governance"


class LockState:
    """LockState enum values."""

    COMPLIANCE = "compliance"
    GOVERNANCE = "governance"
    COMPLIANCE_COOLOFF = "compliance-cooloff"
    EXPIRED = "expired"


class LogDestinationType:
    """LogDestinationType enum values."""

    CLOUD_WATCH_LOGS = "cloud-watch-logs"
    S3 = "s3"
    KINESIS_DATA_FIREHOSE = "kinesis-data-firehose"


class MacModificationTaskState:
    """MacModificationTaskState enum values."""

    SUCCESSFUL = "successful"
    FAILED = "failed"
    IN_PROGRESS = "in-progress"
    PENDING = "pending"


class MacModificationTaskType:
    """MacModificationTaskType enum values."""

    SIP_MODIFICATION = "sip-modification"
    VOLUME_OWNERSHIP_DELEGATION = "volume-ownership-delegation"


class MacSystemIntegrityProtectionSettingStatus:
    """MacSystemIntegrityProtectionSettingStatus enum values."""

    ENABLED = "enabled"
    DISABLED = "disabled"


class ManagedBy:
    """ManagedBy enum values."""

    ACCOUNT = "account"
    DECLARATIVE_POLICY = "declarative-policy"


class MarketType:
    """MarketType enum values."""

    SPOT = "spot"
    CAPACITY_BLOCK = "capacity-block"
    INTERRUPTIBLE_CAPACITY_RESERVATION = "interruptible-capacity-reservation"


class MembershipType:
    """MembershipType enum values."""

    STATIC = "static"
    IGMP = "igmp"


class MetadataDefaultHttpTokensState:
    """MetadataDefaultHttpTokensState enum values."""

    OPTIONAL = "optional"
    REQUIRED = "required"
    NO_PREFERENCE = "no-preference"


class Metric:
    """Metric enum values."""

    RESERVATION_TOTAL_CAPACITY_HRS_VCPU = "reservation-total-capacity-hrs-vcpu"
    RESERVATION_TOTAL_CAPACITY_HRS_INST = "reservation-total-capacity-hrs-inst"
    RESERVATION_MAX_SIZE_VCPU = "reservation-max-size-vcpu"
    RESERVATION_MAX_SIZE_INST = "reservation-max-size-inst"
    RESERVATION_MIN_SIZE_VCPU = "reservation-min-size-vcpu"
    RESERVATION_MIN_SIZE_INST = "reservation-min-size-inst"
    RESERVATION_UNUSED_TOTAL_CAPACITY_HRS_VCPU = "reservation-unused-total-capacity-hrs-vcpu"
    RESERVATION_UNUSED_TOTAL_CAPACITY_HRS_INST = "reservation-unused-total-capacity-hrs-inst"
    RESERVATION_UNUSED_TOTAL_ESTIMATED_COST = "reservation-unused-total-estimated-cost"
    RESERVATION_MAX_UNUSED_SIZE_VCPU = "reservation-max-unused-size-vcpu"
    RESERVATION_MAX_UNUSED_SIZE_INST = "reservation-max-unused-size-inst"
    RESERVATION_MIN_UNUSED_SIZE_VCPU = "reservation-min-unused-size-vcpu"
    RESERVATION_MIN_UNUSED_SIZE_INST = "reservation-min-unused-size-inst"
    RESERVATION_MAX_UTILIZATION = "reservation-max-utilization"
    RESERVATION_MIN_UTILIZATION = "reservation-min-utilization"
    RESERVATION_AVG_UTILIZATION_VCPU = "reservation-avg-utilization-vcpu"
    RESERVATION_AVG_UTILIZATION_INST = "reservation-avg-utilization-inst"
    RESERVATION_TOTAL_COUNT = "reservation-total-count"
    RESERVATION_TOTAL_ESTIMATED_COST = "reservation-total-estimated-cost"
    RESERVATION_AVG_FUTURE_SIZE_VCPU = "reservation-avg-future-size-vcpu"
    RESERVATION_AVG_FUTURE_SIZE_INST = "reservation-avg-future-size-inst"
    RESERVATION_MIN_FUTURE_SIZE_VCPU = "reservation-min-future-size-vcpu"
    RESERVATION_MIN_FUTURE_SIZE_INST = "reservation-min-future-size-inst"
    RESERVATION_MAX_FUTURE_SIZE_VCPU = "reservation-max-future-size-vcpu"
    RESERVATION_MAX_FUTURE_SIZE_INST = "reservation-max-future-size-inst"
    RESERVATION_AVG_COMMITTED_SIZE_VCPU = "reservation-avg-committed-size-vcpu"
    RESERVATION_AVG_COMMITTED_SIZE_INST = "reservation-avg-committed-size-inst"
    RESERVATION_MAX_COMMITTED_SIZE_VCPU = "reservation-max-committed-size-vcpu"
    RESERVATION_MAX_COMMITTED_SIZE_INST = "reservation-max-committed-size-inst"
    RESERVATION_MIN_COMMITTED_SIZE_VCPU = "reservation-min-committed-size-vcpu"
    RESERVATION_MIN_COMMITTED_SIZE_INST = "reservation-min-committed-size-inst"
    RESERVED_TOTAL_USAGE_HRS_VCPU = "reserved-total-usage-hrs-vcpu"
    RESERVED_TOTAL_USAGE_HRS_INST = "reserved-total-usage-hrs-inst"
    RESERVED_TOTAL_ESTIMATED_COST = "reserved-total-estimated-cost"
    UNRESERVED_TOTAL_USAGE_HRS_VCPU = "unreserved-total-usage-hrs-vcpu"
    UNRESERVED_TOTAL_USAGE_HRS_INST = "unreserved-total-usage-hrs-inst"
    UNRESERVED_TOTAL_ESTIMATED_COST = "unreserved-total-estimated-cost"
    SPOT_TOTAL_USAGE_HRS_VCPU = "spot-total-usage-hrs-vcpu"
    SPOT_TOTAL_USAGE_HRS_INST = "spot-total-usage-hrs-inst"
    SPOT_TOTAL_ESTIMATED_COST = "spot-total-estimated-cost"
    SPOT_AVG_RUN_TIME_BEFORE_INTERRUPTION_INST = "spot-avg-run-time-before-interruption-inst"
    SPOT_MAX_RUN_TIME_BEFORE_INTERRUPTION_INST = "spot-max-run-time-before-interruption-inst"
    SPOT_MIN_RUN_TIME_BEFORE_INTERRUPTION_INST = "spot-min-run-time-before-interruption-inst"
    SPOT_TOTAL_INTERRUPTIONS_INST = "spot-total-interruptions-inst"
    SPOT_TOTAL_INTERRUPTIONS_VCPU = "spot-total-interruptions-vcpu"
    SPOT_TOTAL_COUNT_INST = "spot-total-count-inst"
    SPOT_TOTAL_COUNT_VCPU = "spot-total-count-vcpu"
    SPOT_INTERRUPTION_RATE_INST = "spot-interruption-rate-inst"
    SPOT_INTERRUPTION_RATE_VCPU = "spot-interruption-rate-vcpu"


class MetricType:
    """MetricType enum values."""

    AGGREGATE_LATENCY = "aggregate-latency"


class ModifyAvailabilityZoneOptInStatus:
    """ModifyAvailabilityZoneOptInStatus enum values."""

    OPTED_IN = "opted-in"
    NOT_OPTED_IN = "not-opted-in"


class MonitoringState:
    """MonitoringState enum values."""

    DISABLED = "disabled"
    DISABLING = "disabling"
    ENABLED = "enabled"
    PENDING = "pending"


class MoveStatus:
    """MoveStatus enum values."""

    MOVINGTOVPC = "movingToVpc"
    RESTORINGTOCLASSIC = "restoringToClassic"


class MulticastSupportValue:
    """MulticastSupportValue enum values."""

    ENABLE = "enable"
    DISABLE = "disable"


class NatGatewayAddressStatus:
    """NatGatewayAddressStatus enum values."""

    ASSIGNING = "assigning"
    UNASSIGNING = "unassigning"
    ASSOCIATING = "associating"
    DISASSOCIATING = "disassociating"
    SUCCEEDED = "succeeded"
    FAILED = "failed"


class NatGatewayApplianceModifyState:
    """NatGatewayApplianceModifyState enum values."""

    MODIFYING = "modifying"
    COMPLETED = "completed"
    FAILED = "failed"


class NatGatewayApplianceState:
    """NatGatewayApplianceState enum values."""

    ATTACHING = "attaching"
    ATTACHED = "attached"
    DETACHING = "detaching"
    DETACHED = "detached"
    ATTACH_FAILED = "attach-failed"
    DETACH_FAILED = "detach-failed"


class NatGatewayApplianceType:
    """NatGatewayApplianceType enum values."""

    NETWORK_FIREWALL_PROXY = "network-firewall-proxy"


class NatGatewayState:
    """NatGatewayState enum values."""

    PENDING = "pending"
    FAILED = "failed"
    AVAILABLE = "available"
    DELETING = "deleting"
    DELETED = "deleted"


class NetworkInterfaceAttribute:
    """NetworkInterfaceAttribute enum values."""

    DESCRIPTION = "description"
    GROUPSET = "groupSet"
    SOURCEDESTCHECK = "sourceDestCheck"
    ATTACHMENT = "attachment"
    ASSOCIATEPUBLICIPADDRESS = "associatePublicIpAddress"


class NetworkInterfaceCreationType:
    """NetworkInterfaceCreationType enum values."""

    EFA = "efa"
    EFA_ONLY = "efa-only"
    BRANCH = "branch"
    TRUNK = "trunk"


class NetworkInterfacePermissionStateCode:
    """NetworkInterfacePermissionStateCode enum values."""

    PENDING = "pending"
    GRANTED = "granted"
    REVOKING = "revoking"
    REVOKED = "revoked"


class NetworkInterfaceStatus:
    """NetworkInterfaceStatus enum values."""

    AVAILABLE = "available"
    ASSOCIATED = "associated"
    ATTACHING = "attaching"
    IN_USE = "in-use"
    DETACHING = "detaching"


class NetworkInterfaceType:
    """NetworkInterfaceType enum values."""

    INTERFACE = "interface"
    NATGATEWAY = "natGateway"
    EFA = "efa"
    EFA_ONLY = "efa-only"
    TRUNK = "trunk"
    LOAD_BALANCER = "load_balancer"
    NETWORK_LOAD_BALANCER = "network_load_balancer"
    VPC_ENDPOINT = "vpc_endpoint"
    BRANCH = "branch"
    TRANSIT_GATEWAY = "transit_gateway"
    LAMBDA = "lambda"
    QUICKSIGHT = "quicksight"
    GLOBAL_ACCELERATOR_MANAGED = "global_accelerator_managed"
    API_GATEWAY_MANAGED = "api_gateway_managed"
    GATEWAY_LOAD_BALANCER = "gateway_load_balancer"
    GATEWAY_LOAD_BALANCER_ENDPOINT = "gateway_load_balancer_endpoint"
    IOT_RULES_MANAGED = "iot_rules_managed"
    AWS_CODESTAR_CONNECTIONS_MANAGED = "aws_codestar_connections_managed"


class NitroEnclavesSupport:
    """NitroEnclavesSupport enum values."""

    UNSUPPORTED = "unsupported"
    SUPPORTED = "supported"


class NitroTpmSupport:
    """NitroTpmSupport enum values."""

    UNSUPPORTED = "unsupported"
    SUPPORTED = "supported"


class OfferingClassType:
    """OfferingClassType enum values."""

    STANDARD = "standard"
    CONVERTIBLE = "convertible"


class OfferingTypeValues:
    """OfferingTypeValues enum values."""

    HEAVY_UTILIZATION = "Heavy Utilization"
    MEDIUM_UTILIZATION = "Medium Utilization"
    LIGHT_UTILIZATION = "Light Utilization"
    NO_UPFRONT = "No Upfront"
    PARTIAL_UPFRONT = "Partial Upfront"
    ALL_UPFRONT = "All Upfront"


class OnDemandAllocationStrategy:
    """OnDemandAllocationStrategy enum values."""

    LOWESTPRICE = "lowestPrice"
    PRIORITIZED = "prioritized"


class OperationType:
    """OperationType enum values."""

    ADD = "add"
    REMOVE = "remove"


class OutputFormat:
    """OutputFormat enum values."""

    CSV = "csv"
    PARQUET = "parquet"


class PartitionLoadFrequency:
    """PartitionLoadFrequency enum values."""

    NONE = "none"
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"


class PayerResponsibility:
    """PayerResponsibility enum values."""

    SERVICEOWNER = "ServiceOwner"


class PaymentOption:
    """PaymentOption enum values."""

    ALLUPFRONT = "AllUpfront"
    PARTIALUPFRONT = "PartialUpfront"
    NOUPFRONT = "NoUpfront"


class PeriodType:
    """PeriodType enum values."""

    FIVE_MINUTES = "five-minutes"
    FIFTEEN_MINUTES = "fifteen-minutes"
    ONE_HOUR = "one-hour"
    THREE_HOURS = "three-hours"
    ONE_DAY = "one-day"
    ONE_WEEK = "one-week"


class PermissionGroup:
    """PermissionGroup enum values."""

    ALL = "all"


class PhcSupport:
    """PhcSupport enum values."""

    UNSUPPORTED = "unsupported"
    SUPPORTED = "supported"


class PlacementGroupState:
    """PlacementGroupState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    DELETING = "deleting"
    DELETED = "deleted"


class PlacementGroupStrategy:
    """PlacementGroupStrategy enum values."""

    CLUSTER = "cluster"
    PARTITION = "partition"
    SPREAD = "spread"


class PlacementStrategy:
    """PlacementStrategy enum values."""

    CLUSTER = "cluster"
    SPREAD = "spread"
    PARTITION = "partition"


class PlatformValues:
    """PlatformValues enum values."""

    WINDOWS = "Windows"


class PrefixListState:
    """PrefixListState enum values."""

    CREATE_IN_PROGRESS = "create-in-progress"
    CREATE_COMPLETE = "create-complete"
    CREATE_FAILED = "create-failed"
    MODIFY_IN_PROGRESS = "modify-in-progress"
    MODIFY_COMPLETE = "modify-complete"
    MODIFY_FAILED = "modify-failed"
    RESTORE_IN_PROGRESS = "restore-in-progress"
    RESTORE_COMPLETE = "restore-complete"
    RESTORE_FAILED = "restore-failed"
    DELETE_IN_PROGRESS = "delete-in-progress"
    DELETE_COMPLETE = "delete-complete"
    DELETE_FAILED = "delete-failed"


class PrincipalType:
    """PrincipalType enum values."""

    ALL = "All"
    SERVICE = "Service"
    ORGANIZATIONUNIT = "OrganizationUnit"
    ACCOUNT = "Account"
    USER = "User"
    ROLE = "Role"


class ProductCodeValues:
    """ProductCodeValues enum values."""

    DEVPAY = "devpay"
    MARKETPLACE = "marketplace"


class Protocol:
    """Protocol enum values."""

    TCP = "tcp"
    UDP = "udp"


class ProtocolValue:
    """ProtocolValue enum values."""

    GRE = "gre"


class PublicIpDnsOption:
    """PublicIpDnsOption enum values."""

    PUBLIC_DUAL_STACK_DNS_NAME = "public-dual-stack-dns-name"
    PUBLIC_IPV4_DNS_NAME = "public-ipv4-dns-name"
    PUBLIC_IPV6_DNS_NAME = "public-ipv6-dns-name"


class RIProductDescription:
    """RIProductDescription enum values."""

    LINUX_UNIX = "Linux/UNIX"
    LINUX_UNIX_AMAZON_VPC = "Linux/UNIX (Amazon VPC)"
    WINDOWS = "Windows"
    WINDOWS_AMAZON_VPC = "Windows (Amazon VPC)"


class RebootMigrationSupport:
    """RebootMigrationSupport enum values."""

    UNSUPPORTED = "unsupported"
    SUPPORTED = "supported"


class RecurringChargeFrequency:
    """RecurringChargeFrequency enum values."""

    HOURLY = "Hourly"


class ReplaceRootVolumeTaskState:
    """ReplaceRootVolumeTaskState enum values."""

    PENDING = "pending"
    IN_PROGRESS = "in-progress"
    FAILING = "failing"
    SUCCEEDED = "succeeded"
    FAILED = "failed"
    FAILED_DETACHED = "failed-detached"


class ReplacementStrategy:
    """ReplacementStrategy enum values."""

    LAUNCH = "launch"
    LAUNCH_BEFORE_TERMINATE = "launch-before-terminate"


class ReportInstanceReasonCodes:
    """ReportInstanceReasonCodes enum values."""

    INSTANCE_STUCK_IN_STATE = "instance-stuck-in-state"
    UNRESPONSIVE = "unresponsive"
    NOT_ACCEPTING_CREDENTIALS = "not-accepting-credentials"
    PASSWORD_NOT_AVAILABLE = "password-not-available"
    PERFORMANCE_NETWORK = "performance-network"
    PERFORMANCE_INSTANCE_STORE = "performance-instance-store"
    PERFORMANCE_EBS_VOLUME = "performance-ebs-volume"
    PERFORMANCE_OTHER = "performance-other"
    OTHER = "other"


class ReportState:
    """ReportState enum values."""

    RUNNING = "running"
    CANCELLED = "cancelled"
    COMPLETE = "complete"
    ERROR = "error"


class ReportStatusType:
    """ReportStatusType enum values."""

    OK = "ok"
    IMPAIRED = "impaired"


class ReservationEndDateType:
    """ReservationEndDateType enum values."""

    LIMITED = "limited"
    UNLIMITED = "unlimited"


class ReservationState:
    """ReservationState enum values."""

    ACTIVE = "active"
    EXPIRED = "expired"
    CANCELLED = "cancelled"
    SCHEDULED = "scheduled"
    PENDING = "pending"
    FAILED = "failed"
    DELAYED = "delayed"
    UNSUPPORTED = "unsupported"
    PAYMENT_PENDING = "payment-pending"
    PAYMENT_FAILED = "payment-failed"
    RETIRED = "retired"


class ReservationType:
    """ReservationType enum values."""

    CAPACITY_BLOCK = "capacity-block"
    ODCR = "odcr"


class ReservedInstanceState:
    """ReservedInstanceState enum values."""

    PAYMENT_PENDING = "payment-pending"
    ACTIVE = "active"
    PAYMENT_FAILED = "payment-failed"
    RETIRED = "retired"
    QUEUED = "queued"
    QUEUED_DELETED = "queued-deleted"


class ResetFpgaImageAttributeName:
    """ResetFpgaImageAttributeName enum values."""

    LOADPERMISSION = "loadPermission"


class ResetImageAttributeName:
    """ResetImageAttributeName enum values."""

    LAUNCHPERMISSION = "launchPermission"


class ResourceType:
    """ResourceType enum values."""

    CAPACITY_RESERVATION = "capacity-reservation"
    CLIENT_VPN_ENDPOINT = "client-vpn-endpoint"
    CUSTOMER_GATEWAY = "customer-gateway"
    CARRIER_GATEWAY = "carrier-gateway"
    COIP_POOL = "coip-pool"
    DECLARATIVE_POLICIES_REPORT = "declarative-policies-report"
    DEDICATED_HOST = "dedicated-host"
    DHCP_OPTIONS = "dhcp-options"
    EGRESS_ONLY_INTERNET_GATEWAY = "egress-only-internet-gateway"
    ELASTIC_IP = "elastic-ip"
    ELASTIC_GPU = "elastic-gpu"
    EXPORT_IMAGE_TASK = "export-image-task"
    EXPORT_INSTANCE_TASK = "export-instance-task"
    FLEET = "fleet"
    FPGA_IMAGE = "fpga-image"
    HOST_RESERVATION = "host-reservation"
    IMAGE = "image"
    IMAGE_USAGE_REPORT = "image-usage-report"
    IMPORT_IMAGE_TASK = "import-image-task"
    IMPORT_SNAPSHOT_TASK = "import-snapshot-task"
    INSTANCE = "instance"
    INSTANCE_EVENT_WINDOW = "instance-event-window"
    INTERNET_GATEWAY = "internet-gateway"
    IPAM = "ipam"
    IPAM_POOL = "ipam-pool"
    IPAM_SCOPE = "ipam-scope"
    IPV4POOL_EC2 = "ipv4pool-ec2"
    IPV6POOL_EC2 = "ipv6pool-ec2"
    KEY_PAIR = "key-pair"
    LAUNCH_TEMPLATE = "launch-template"
    LOCAL_GATEWAY = "local-gateway"
    LOCAL_GATEWAY_ROUTE_TABLE = "local-gateway-route-table"
    LOCAL_GATEWAY_VIRTUAL_INTERFACE = "local-gateway-virtual-interface"
    LOCAL_GATEWAY_VIRTUAL_INTERFACE_GROUP = "local-gateway-virtual-interface-group"
    LOCAL_GATEWAY_ROUTE_TABLE_VPC_ASSOCIATION = "local-gateway-route-table-vpc-association"
    LOCAL_GATEWAY_ROUTE_TABLE_VIRTUAL_INTERFACE_GROUP_ASSOCIATION = "local-gateway-route-table-virtual-interface-group-association"
    NATGATEWAY = "natgateway"
    NETWORK_ACL = "network-acl"
    NETWORK_INTERFACE = "network-interface"
    NETWORK_INSIGHTS_ANALYSIS = "network-insights-analysis"
    NETWORK_INSIGHTS_PATH = "network-insights-path"
    NETWORK_INSIGHTS_ACCESS_SCOPE = "network-insights-access-scope"
    NETWORK_INSIGHTS_ACCESS_SCOPE_ANALYSIS = "network-insights-access-scope-analysis"
    OUTPOST_LAG = "outpost-lag"
    PLACEMENT_GROUP = "placement-group"
    PREFIX_LIST = "prefix-list"
    REPLACE_ROOT_VOLUME_TASK = "replace-root-volume-task"
    RESERVED_INSTANCES = "reserved-instances"
    ROUTE_TABLE = "route-table"
    SECURITY_GROUP = "security-group"
    SECURITY_GROUP_RULE = "security-group-rule"
    SERVICE_LINK_VIRTUAL_INTERFACE = "service-link-virtual-interface"
    SNAPSHOT = "snapshot"
    SPOT_FLEET_REQUEST = "spot-fleet-request"
    SPOT_INSTANCES_REQUEST = "spot-instances-request"
    SUBNET = "subnet"
    SUBNET_CIDR_RESERVATION = "subnet-cidr-reservation"
    TRAFFIC_MIRROR_FILTER = "traffic-mirror-filter"
    TRAFFIC_MIRROR_SESSION = "traffic-mirror-session"
    TRAFFIC_MIRROR_TARGET = "traffic-mirror-target"
    TRANSIT_GATEWAY = "transit-gateway"
    TRANSIT_GATEWAY_ATTACHMENT = "transit-gateway-attachment"
    TRANSIT_GATEWAY_CONNECT_PEER = "transit-gateway-connect-peer"
    TRANSIT_GATEWAY_MULTICAST_DOMAIN = "transit-gateway-multicast-domain"
    TRANSIT_GATEWAY_POLICY_TABLE = "transit-gateway-policy-table"
    TRANSIT_GATEWAY_METERING_POLICY = "transit-gateway-metering-policy"
    TRANSIT_GATEWAY_ROUTE_TABLE = "transit-gateway-route-table"
    TRANSIT_GATEWAY_ROUTE_TABLE_ANNOUNCEMENT = "transit-gateway-route-table-announcement"
    VOLUME = "volume"
    VPC = "vpc"
    VPC_ENDPOINT = "vpc-endpoint"
    VPC_ENDPOINT_CONNECTION = "vpc-endpoint-connection"
    VPC_ENDPOINT_SERVICE = "vpc-endpoint-service"
    VPC_ENDPOINT_SERVICE_PERMISSION = "vpc-endpoint-service-permission"
    VPC_PEERING_CONNECTION = "vpc-peering-connection"
    VPN_CONNECTION = "vpn-connection"
    VPN_GATEWAY = "vpn-gateway"
    VPC_FLOW_LOG = "vpc-flow-log"
    CAPACITY_RESERVATION_FLEET = "capacity-reservation-fleet"
    TRAFFIC_MIRROR_FILTER_RULE = "traffic-mirror-filter-rule"
    VPC_ENDPOINT_CONNECTION_DEVICE_TYPE = "vpc-endpoint-connection-device-type"
    VERIFIED_ACCESS_INSTANCE = "verified-access-instance"
    VERIFIED_ACCESS_GROUP = "verified-access-group"
    VERIFIED_ACCESS_ENDPOINT = "verified-access-endpoint"
    VERIFIED_ACCESS_POLICY = "verified-access-policy"
    VERIFIED_ACCESS_TRUST_PROVIDER = "verified-access-trust-provider"
    VPN_CONNECTION_DEVICE_TYPE = "vpn-connection-device-type"
    VPC_BLOCK_PUBLIC_ACCESS_EXCLUSION = "vpc-block-public-access-exclusion"
    VPC_ENCRYPTION_CONTROL = "vpc-encryption-control"
    ROUTE_SERVER = "route-server"
    ROUTE_SERVER_ENDPOINT = "route-server-endpoint"
    ROUTE_SERVER_PEER = "route-server-peer"
    IPAM_RESOURCE_DISCOVERY = "ipam-resource-discovery"
    IPAM_RESOURCE_DISCOVERY_ASSOCIATION = "ipam-resource-discovery-association"
    INSTANCE_CONNECT_ENDPOINT = "instance-connect-endpoint"
    VERIFIED_ACCESS_ENDPOINT_TARGET = "verified-access-endpoint-target"
    IPAM_EXTERNAL_RESOURCE_VERIFICATION_TOKEN = "ipam-external-resource-verification-token"
    CAPACITY_BLOCK = "capacity-block"
    MAC_MODIFICATION_TASK = "mac-modification-task"
    IPAM_PREFIX_LIST_RESOLVER = "ipam-prefix-list-resolver"
    IPAM_POLICY = "ipam-policy"
    IPAM_PREFIX_LIST_RESOLVER_TARGET = "ipam-prefix-list-resolver-target"
    CAPACITY_MANAGER_DATA_EXPORT = "capacity-manager-data-export"
    VPN_CONCENTRATOR = "vpn-concentrator"


class RootDeviceType:
    """RootDeviceType enum values."""

    EBS = "ebs"
    INSTANCE_STORE = "instance-store"


class RouteOrigin:
    """RouteOrigin enum values."""

    CREATEROUTETABLE = "CreateRouteTable"
    CREATEROUTE = "CreateRoute"
    ENABLEVGWROUTEPROPAGATION = "EnableVgwRoutePropagation"
    ADVERTISEMENT = "Advertisement"


class RouteServerAssociationState:
    """RouteServerAssociationState enum values."""

    ASSOCIATING = "associating"
    ASSOCIATED = "associated"
    DISASSOCIATING = "disassociating"


class RouteServerBfdState:
    """RouteServerBfdState enum values."""

    UP = "up"
    DOWN = "down"


class RouteServerBgpState:
    """RouteServerBgpState enum values."""

    UP = "up"
    DOWN = "down"


class RouteServerEndpointState:
    """RouteServerEndpointState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    DELETING = "deleting"
    DELETED = "deleted"
    FAILING = "failing"
    FAILED = "failed"
    DELETE_FAILED = "delete-failed"


class RouteServerPeerLivenessMode:
    """RouteServerPeerLivenessMode enum values."""

    BFD = "bfd"
    BGP_KEEPALIVE = "bgp-keepalive"


class RouteServerPeerState:
    """RouteServerPeerState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    DELETING = "deleting"
    DELETED = "deleted"
    FAILING = "failing"
    FAILED = "failed"


class RouteServerPersistRoutesAction:
    """RouteServerPersistRoutesAction enum values."""

    ENABLE = "enable"
    DISABLE = "disable"
    RESET = "reset"


class RouteServerPersistRoutesState:
    """RouteServerPersistRoutesState enum values."""

    ENABLING = "enabling"
    ENABLED = "enabled"
    RESETTING = "resetting"
    DISABLING = "disabling"
    DISABLED = "disabled"
    MODIFYING = "modifying"


class RouteServerPropagationState:
    """RouteServerPropagationState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    DELETING = "deleting"


class RouteServerRouteInstallationStatus:
    """RouteServerRouteInstallationStatus enum values."""

    INSTALLED = "installed"
    REJECTED = "rejected"


class RouteServerRouteStatus:
    """RouteServerRouteStatus enum values."""

    IN_RIB = "in-rib"
    IN_FIB = "in-fib"


class RouteServerState:
    """RouteServerState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    MODIFYING = "modifying"
    DELETING = "deleting"
    DELETED = "deleted"


class RouteState:
    """RouteState enum values."""

    ACTIVE = "active"
    BLACKHOLE = "blackhole"
    FILTERED = "filtered"


class RouteTableAssociationStateCode:
    """RouteTableAssociationStateCode enum values."""

    ASSOCIATING = "associating"
    ASSOCIATED = "associated"
    DISASSOCIATING = "disassociating"
    DISASSOCIATED = "disassociated"
    FAILED = "failed"


class RuleAction:
    """RuleAction enum values."""

    ALLOW = "allow"
    DENY = "deny"


class SSEType:
    """SSEType enum values."""

    SSE_EBS = "sse-ebs"
    SSE_KMS = "sse-kms"
    NONE = "none"


class Schedule:
    """Schedule enum values."""

    HOURLY = "hourly"


class SecurityGroupReferencingSupportValue:
    """SecurityGroupReferencingSupportValue enum values."""

    ENABLE = "enable"
    DISABLE = "disable"


class SecurityGroupVpcAssociationState:
    """SecurityGroupVpcAssociationState enum values."""

    ASSOCIATING = "associating"
    ASSOCIATED = "associated"
    ASSOCIATION_FAILED = "association-failed"
    DISASSOCIATING = "disassociating"
    DISASSOCIATED = "disassociated"
    DISASSOCIATION_FAILED = "disassociation-failed"


class SelfServicePortal:
    """SelfServicePortal enum values."""

    ENABLED = "enabled"
    DISABLED = "disabled"


class ServiceConnectivityType:
    """ServiceConnectivityType enum values."""

    IPV4 = "ipv4"
    IPV6 = "ipv6"


class ServiceLinkVirtualInterfaceConfigurationState:
    """ServiceLinkVirtualInterfaceConfigurationState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    DELETING = "deleting"
    DELETED = "deleted"


class ServiceManaged:
    """ServiceManaged enum values."""

    ALB = "alb"
    NLB = "nlb"
    RNAT = "rnat"
    RDS = "rds"


class ServiceState:
    """ServiceState enum values."""

    PENDING = "Pending"
    AVAILABLE = "Available"
    DELETING = "Deleting"
    DELETED = "Deleted"
    FAILED = "Failed"


class ServiceType:
    """ServiceType enum values."""

    INTERFACE = "Interface"
    GATEWAY = "Gateway"
    GATEWAYLOADBALANCER = "GatewayLoadBalancer"


class ShutdownBehavior:
    """ShutdownBehavior enum values."""

    STOP = "stop"
    TERMINATE = "terminate"


class SnapshotAttributeName:
    """SnapshotAttributeName enum values."""

    PRODUCTCODES = "productCodes"
    CREATEVOLUMEPERMISSION = "createVolumePermission"


class SnapshotBlockPublicAccessState:
    """SnapshotBlockPublicAccessState enum values."""

    BLOCK_ALL_SHARING = "block-all-sharing"
    BLOCK_NEW_SHARING = "block-new-sharing"
    UNBLOCKED = "unblocked"


class SnapshotLocationEnum:
    """SnapshotLocationEnum enum values."""

    REGIONAL = "regional"
    LOCAL = "local"


class SnapshotReturnCodes:
    """SnapshotReturnCodes enum values."""

    SUCCESS = "success"
    SKIPPED = "skipped"
    MISSING_PERMISSIONS = "missing-permissions"
    INTERNAL_ERROR = "internal-error"
    CLIENT_ERROR = "client-error"


class SnapshotState:
    """SnapshotState enum values."""

    PENDING = "pending"
    COMPLETED = "completed"
    ERROR = "error"
    RECOVERABLE = "recoverable"
    RECOVERING = "recovering"


class SpotAllocationStrategy:
    """SpotAllocationStrategy enum values."""

    LOWEST_PRICE = "lowest-price"
    DIVERSIFIED = "diversified"
    CAPACITY_OPTIMIZED = "capacity-optimized"
    CAPACITY_OPTIMIZED_PRIORITIZED = "capacity-optimized-prioritized"
    PRICE_CAPACITY_OPTIMIZED = "price-capacity-optimized"


class SpotInstanceInterruptionBehavior:
    """SpotInstanceInterruptionBehavior enum values."""

    HIBERNATE = "hibernate"
    STOP = "stop"
    TERMINATE = "terminate"


class SpotInstanceState:
    """SpotInstanceState enum values."""

    OPEN = "open"
    ACTIVE = "active"
    CLOSED = "closed"
    CANCELLED = "cancelled"
    FAILED = "failed"
    DISABLED = "disabled"


class SpotInstanceType:
    """SpotInstanceType enum values."""

    ONE_TIME = "one-time"
    PERSISTENT = "persistent"


class SpreadLevel:
    """SpreadLevel enum values."""

    HOST = "host"
    RACK = "rack"


class SqlServerLicenseUsage:
    """SqlServerLicenseUsage enum values."""

    FULL = "full"
    WAIVED = "waived"


class State:
    """State enum values."""

    PENDINGACCEPTANCE = "PendingAcceptance"
    PENDING = "Pending"
    AVAILABLE = "Available"
    DELETING = "Deleting"
    DELETED = "Deleted"
    REJECTED = "Rejected"
    FAILED = "Failed"
    EXPIRED = "Expired"
    PARTIAL = "Partial"


class StaticSourcesSupportValue:
    """StaticSourcesSupportValue enum values."""

    ENABLE = "enable"
    DISABLE = "disable"


class StatisticType:
    """StatisticType enum values."""

    P50 = "p50"


class Status:
    """Status enum values."""

    MOVEINPROGRESS = "MoveInProgress"
    INVPC = "InVpc"
    INCLASSIC = "InClassic"


class StatusName:
    """StatusName enum values."""

    REACHABILITY = "reachability"


class StatusType:
    """StatusType enum values."""

    PASSED = "passed"
    FAILED = "failed"
    INSUFFICIENT_DATA = "insufficient-data"
    INITIALIZING = "initializing"


class StorageTier:
    """StorageTier enum values."""

    ARCHIVE = "archive"
    STANDARD = "standard"


class SubnetCidrBlockStateCode:
    """SubnetCidrBlockStateCode enum values."""

    ASSOCIATING = "associating"
    ASSOCIATED = "associated"
    DISASSOCIATING = "disassociating"
    DISASSOCIATED = "disassociated"
    FAILING = "failing"
    FAILED = "failed"


class SubnetCidrReservationType:
    """SubnetCidrReservationType enum values."""

    PREFIX = "prefix"
    EXPLICIT = "explicit"


class SubnetState:
    """SubnetState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    UNAVAILABLE = "unavailable"
    FAILED = "failed"
    FAILED_INSUFFICIENT_CAPACITY = "failed-insufficient-capacity"


class SummaryStatus:
    """SummaryStatus enum values."""

    OK = "ok"
    IMPAIRED = "impaired"
    INSUFFICIENT_DATA = "insufficient-data"
    NOT_APPLICABLE = "not-applicable"
    INITIALIZING = "initializing"


class SupportedAdditionalProcessorFeature:
    """SupportedAdditionalProcessorFeature enum values."""

    AMD_SEV_SNP = "amd-sev-snp"


class TargetCapacityUnitType:
    """TargetCapacityUnitType enum values."""

    VCPU = "vcpu"
    MEMORY_MIB = "memory-mib"
    UNITS = "units"


class TargetStorageTier:
    """TargetStorageTier enum values."""

    ARCHIVE = "archive"


class TelemetryStatus:
    """TelemetryStatus enum values."""

    UP = "UP"
    DOWN = "DOWN"


class Tenancy:
    """Tenancy enum values."""

    DEFAULT = "default"
    DEDICATED = "dedicated"
    HOST = "host"


class TieringOperationStatus:
    """TieringOperationStatus enum values."""

    ARCHIVAL_IN_PROGRESS = "archival-in-progress"
    ARCHIVAL_COMPLETED = "archival-completed"
    ARCHIVAL_FAILED = "archival-failed"
    TEMPORARY_RESTORE_IN_PROGRESS = "temporary-restore-in-progress"
    TEMPORARY_RESTORE_COMPLETED = "temporary-restore-completed"
    TEMPORARY_RESTORE_FAILED = "temporary-restore-failed"
    PERMANENT_RESTORE_IN_PROGRESS = "permanent-restore-in-progress"
    PERMANENT_RESTORE_COMPLETED = "permanent-restore-completed"
    PERMANENT_RESTORE_FAILED = "permanent-restore-failed"


class TokenState:
    """TokenState enum values."""

    VALID = "valid"
    EXPIRED = "expired"


class TpmSupportValues:
    """TpmSupportValues enum values."""

    V2_0 = "v2.0"


class TrafficDirection:
    """TrafficDirection enum values."""

    INGRESS = "ingress"
    EGRESS = "egress"


class TrafficIpAddressType:
    """TrafficIpAddressType enum values."""

    IPV4 = "ipv4"
    IPV6 = "ipv6"
    DUAL_STACK = "dual-stack"


class TrafficMirrorFilterRuleField:
    """TrafficMirrorFilterRuleField enum values."""

    DESTINATION_PORT_RANGE = "destination-port-range"
    SOURCE_PORT_RANGE = "source-port-range"
    PROTOCOL = "protocol"
    DESCRIPTION = "description"


class TrafficMirrorNetworkService:
    """TrafficMirrorNetworkService enum values."""

    AMAZON_DNS = "amazon-dns"


class TrafficMirrorRuleAction:
    """TrafficMirrorRuleAction enum values."""

    ACCEPT = "accept"
    REJECT = "reject"


class TrafficMirrorSessionField:
    """TrafficMirrorSessionField enum values."""

    PACKET_LENGTH = "packet-length"
    DESCRIPTION = "description"
    VIRTUAL_NETWORK_ID = "virtual-network-id"


class TrafficMirrorTargetType:
    """TrafficMirrorTargetType enum values."""

    NETWORK_INTERFACE = "network-interface"
    NETWORK_LOAD_BALANCER = "network-load-balancer"
    GATEWAY_LOAD_BALANCER_ENDPOINT = "gateway-load-balancer-endpoint"


class TrafficType:
    """TrafficType enum values."""

    ACCEPT = "ACCEPT"
    REJECT = "REJECT"
    ALL = "ALL"


class TransferType:
    """TransferType enum values."""

    TIME_BASED = "time-based"
    STANDARD = "standard"


class TransitGatewayAssociationState:
    """TransitGatewayAssociationState enum values."""

    ASSOCIATING = "associating"
    ASSOCIATED = "associated"
    DISASSOCIATING = "disassociating"
    DISASSOCIATED = "disassociated"


class TransitGatewayAttachmentResourceType:
    """TransitGatewayAttachmentResourceType enum values."""

    VPC = "vpc"
    VPN = "vpn"
    VPN_CONCENTRATOR = "vpn-concentrator"
    DIRECT_CONNECT_GATEWAY = "direct-connect-gateway"
    CONNECT = "connect"
    PEERING = "peering"
    TGW_PEERING = "tgw-peering"
    NETWORK_FUNCTION = "network-function"


class TransitGatewayAttachmentState:
    """TransitGatewayAttachmentState enum values."""

    INITIATING = "initiating"
    INITIATINGREQUEST = "initiatingRequest"
    PENDINGACCEPTANCE = "pendingAcceptance"
    ROLLINGBACK = "rollingBack"
    PENDING = "pending"
    AVAILABLE = "available"
    MODIFYING = "modifying"
    DELETING = "deleting"
    DELETED = "deleted"
    FAILED = "failed"
    REJECTED = "rejected"
    REJECTING = "rejecting"
    FAILING = "failing"


class TransitGatewayConnectPeerState:
    """TransitGatewayConnectPeerState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    DELETING = "deleting"
    DELETED = "deleted"


class TransitGatewayMeteringPayerType:
    """TransitGatewayMeteringPayerType enum values."""

    SOURCE_ATTACHMENT_OWNER = "source-attachment-owner"
    DESTINATION_ATTACHMENT_OWNER = "destination-attachment-owner"
    TRANSIT_GATEWAY_OWNER = "transit-gateway-owner"


class TransitGatewayMeteringPolicyEntryState:
    """TransitGatewayMeteringPolicyEntryState enum values."""

    AVAILABLE = "available"
    DELETED = "deleted"


class TransitGatewayMeteringPolicyState:
    """TransitGatewayMeteringPolicyState enum values."""

    AVAILABLE = "available"
    DELETED = "deleted"
    PENDING = "pending"
    MODIFYING = "modifying"
    DELETING = "deleting"


class TransitGatewayMulitcastDomainAssociationState:
    """TransitGatewayMulitcastDomainAssociationState enum values."""

    PENDINGACCEPTANCE = "pendingAcceptance"
    ASSOCIATING = "associating"
    ASSOCIATED = "associated"
    DISASSOCIATING = "disassociating"
    DISASSOCIATED = "disassociated"
    REJECTED = "rejected"
    FAILED = "failed"


class TransitGatewayMulticastDomainState:
    """TransitGatewayMulticastDomainState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    DELETING = "deleting"
    DELETED = "deleted"


class TransitGatewayPolicyTableState:
    """TransitGatewayPolicyTableState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    DELETING = "deleting"
    DELETED = "deleted"


class TransitGatewayPrefixListReferenceState:
    """TransitGatewayPrefixListReferenceState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    MODIFYING = "modifying"
    DELETING = "deleting"


class TransitGatewayPropagationState:
    """TransitGatewayPropagationState enum values."""

    ENABLING = "enabling"
    ENABLED = "enabled"
    DISABLING = "disabling"
    DISABLED = "disabled"


class TransitGatewayRouteState:
    """TransitGatewayRouteState enum values."""

    PENDING = "pending"
    ACTIVE = "active"
    BLACKHOLE = "blackhole"
    DELETING = "deleting"
    DELETED = "deleted"


class TransitGatewayRouteTableAnnouncementDirection:
    """TransitGatewayRouteTableAnnouncementDirection enum values."""

    OUTGOING = "outgoing"
    INCOMING = "incoming"


class TransitGatewayRouteTableAnnouncementState:
    """TransitGatewayRouteTableAnnouncementState enum values."""

    AVAILABLE = "available"
    PENDING = "pending"
    FAILING = "failing"
    FAILED = "failed"
    DELETING = "deleting"
    DELETED = "deleted"


class TransitGatewayRouteTableState:
    """TransitGatewayRouteTableState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    DELETING = "deleting"
    DELETED = "deleted"


class TransitGatewayRouteType:
    """TransitGatewayRouteType enum values."""

    STATIC = "static"
    PROPAGATED = "propagated"


class TransitGatewayState:
    """TransitGatewayState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    MODIFYING = "modifying"
    DELETING = "deleting"
    DELETED = "deleted"


class TransportProtocol:
    """TransportProtocol enum values."""

    TCP = "tcp"
    UDP = "udp"


class TrustProviderType:
    """TrustProviderType enum values."""

    USER = "user"
    DEVICE = "device"


class TunnelInsideIpVersion:
    """TunnelInsideIpVersion enum values."""

    IPV4 = "ipv4"
    IPV6 = "ipv6"


class UnlimitedSupportedInstanceFamily:
    """UnlimitedSupportedInstanceFamily enum values."""

    T2 = "t2"
    T3 = "t3"
    T3A = "t3a"
    T4G = "t4g"


class UnsuccessfulInstanceCreditSpecificationErrorCode:
    """UnsuccessfulInstanceCreditSpecificationErrorCode enum values."""

    INVALIDINSTANCEID_MALFORMED = "InvalidInstanceID.Malformed"
    INVALIDINSTANCEID_NOTFOUND = "InvalidInstanceID.NotFound"
    INCORRECTINSTANCESTATE = "IncorrectInstanceState"
    INSTANCECREDITSPECIFICATION_NOTSUPPORTED = "InstanceCreditSpecification.NotSupported"


class UsageClassType:
    """UsageClassType enum values."""

    SPOT = "spot"
    ON_DEMAND = "on-demand"
    CAPACITY_BLOCK = "capacity-block"


class UserTrustProviderType:
    """UserTrustProviderType enum values."""

    IAM_IDENTITY_CENTER = "iam-identity-center"
    OIDC = "oidc"


class VerificationMethod:
    """VerificationMethod enum values."""

    REMARKS_X509 = "remarks-x509"
    DNS_TOKEN = "dns-token"


class VerifiedAccessEndpointAttachmentType:
    """VerifiedAccessEndpointAttachmentType enum values."""

    VPC = "vpc"


class VerifiedAccessEndpointProtocol:
    """VerifiedAccessEndpointProtocol enum values."""

    HTTP = "http"
    HTTPS = "https"
    TCP = "tcp"


class VerifiedAccessEndpointStatusCode:
    """VerifiedAccessEndpointStatusCode enum values."""

    PENDING = "pending"
    ACTIVE = "active"
    UPDATING = "updating"
    DELETING = "deleting"
    DELETED = "deleted"


class VerifiedAccessEndpointType:
    """VerifiedAccessEndpointType enum values."""

    LOAD_BALANCER = "load-balancer"
    NETWORK_INTERFACE = "network-interface"
    RDS = "rds"
    CIDR = "cidr"


class VerifiedAccessLogDeliveryStatusCode:
    """VerifiedAccessLogDeliveryStatusCode enum values."""

    SUCCESS = "success"
    FAILED = "failed"


class VirtualizationType:
    """VirtualizationType enum values."""

    HVM = "hvm"
    PARAVIRTUAL = "paravirtual"


class VolumeAttachmentState:
    """VolumeAttachmentState enum values."""

    ATTACHING = "attaching"
    ATTACHED = "attached"
    DETACHING = "detaching"
    DETACHED = "detached"
    BUSY = "busy"


class VolumeAttributeName:
    """VolumeAttributeName enum values."""

    AUTOENABLEIO = "autoEnableIO"
    PRODUCTCODES = "productCodes"


class VolumeModificationState:
    """VolumeModificationState enum values."""

    MODIFYING = "modifying"
    OPTIMIZING = "optimizing"
    COMPLETED = "completed"
    FAILED = "failed"


class VolumeState:
    """VolumeState enum values."""

    CREATING = "creating"
    AVAILABLE = "available"
    IN_USE = "in-use"
    DELETING = "deleting"
    DELETED = "deleted"
    ERROR = "error"


class VolumeStatusInfoStatus:
    """VolumeStatusInfoStatus enum values."""

    OK = "ok"
    IMPAIRED = "impaired"
    INSUFFICIENT_DATA = "insufficient-data"
    WARNING = "warning"


class VolumeStatusName:
    """VolumeStatusName enum values."""

    IO_ENABLED = "io-enabled"
    IO_PERFORMANCE = "io-performance"
    INITIALIZATION_STATE = "initialization-state"


class VolumeType:
    """VolumeType enum values."""

    STANDARD = "standard"
    IO1 = "io1"
    IO2 = "io2"
    GP2 = "gp2"
    SC1 = "sc1"
    ST1 = "st1"
    GP3 = "gp3"


class VpcAttributeName:
    """VpcAttributeName enum values."""

    ENABLEDNSSUPPORT = "enableDnsSupport"
    ENABLEDNSHOSTNAMES = "enableDnsHostnames"
    ENABLENETWORKADDRESSUSAGEMETRICS = "enableNetworkAddressUsageMetrics"


class VpcBlockPublicAccessExclusionState:
    """VpcBlockPublicAccessExclusionState enum values."""

    CREATE_IN_PROGRESS = "create-in-progress"
    CREATE_COMPLETE = "create-complete"
    CREATE_FAILED = "create-failed"
    UPDATE_IN_PROGRESS = "update-in-progress"
    UPDATE_COMPLETE = "update-complete"
    UPDATE_FAILED = "update-failed"
    DELETE_IN_PROGRESS = "delete-in-progress"
    DELETE_COMPLETE = "delete-complete"
    DISABLE_IN_PROGRESS = "disable-in-progress"
    DISABLE_COMPLETE = "disable-complete"


class VpcBlockPublicAccessExclusionsAllowed:
    """VpcBlockPublicAccessExclusionsAllowed enum values."""

    ALLOWED = "allowed"
    NOT_ALLOWED = "not-allowed"


class VpcBlockPublicAccessState:
    """VpcBlockPublicAccessState enum values."""

    DEFAULT_STATE = "default-state"
    UPDATE_IN_PROGRESS = "update-in-progress"
    UPDATE_COMPLETE = "update-complete"


class VpcCidrBlockStateCode:
    """VpcCidrBlockStateCode enum values."""

    ASSOCIATING = "associating"
    ASSOCIATED = "associated"
    DISASSOCIATING = "disassociating"
    DISASSOCIATED = "disassociated"
    FAILING = "failing"
    FAILED = "failed"


class VpcEncryptionControlExclusionState:
    """VpcEncryptionControlExclusionState enum values."""

    ENABLING = "enabling"
    ENABLED = "enabled"
    DISABLING = "disabling"
    DISABLED = "disabled"


class VpcEncryptionControlExclusionStateInput:
    """VpcEncryptionControlExclusionStateInput enum values."""

    ENABLE = "enable"
    DISABLE = "disable"


class VpcEncryptionControlMode:
    """VpcEncryptionControlMode enum values."""

    MONITOR = "monitor"
    ENFORCE = "enforce"


class VpcEncryptionControlState:
    """VpcEncryptionControlState enum values."""

    ENFORCE_IN_PROGRESS = "enforce-in-progress"
    MONITOR_IN_PROGRESS = "monitor-in-progress"
    ENFORCE_FAILED = "enforce-failed"
    MONITOR_FAILED = "monitor-failed"
    DELETING = "deleting"
    DELETED = "deleted"
    AVAILABLE = "available"
    CREATING = "creating"
    DELETE_FAILED = "delete-failed"


class VpcEndpointType:
    """VpcEndpointType enum values."""

    INTERFACE = "Interface"
    GATEWAY = "Gateway"
    GATEWAYLOADBALANCER = "GatewayLoadBalancer"
    RESOURCE = "Resource"
    SERVICENETWORK = "ServiceNetwork"


class VpcPeeringConnectionStateReasonCode:
    """VpcPeeringConnectionStateReasonCode enum values."""

    INITIATING_REQUEST = "initiating-request"
    PENDING_ACCEPTANCE = "pending-acceptance"
    ACTIVE = "active"
    DELETED = "deleted"
    REJECTED = "rejected"
    FAILED = "failed"
    EXPIRED = "expired"
    PROVISIONING = "provisioning"
    DELETING = "deleting"


class VpcState:
    """VpcState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"


class VpcTenancy:
    """VpcTenancy enum values."""

    DEFAULT = "default"


class VpnConcentratorType:
    """VpnConcentratorType enum values."""

    IPSEC_1 = "ipsec.1"


class VpnEcmpSupportValue:
    """VpnEcmpSupportValue enum values."""

    ENABLE = "enable"
    DISABLE = "disable"


class VpnProtocol:
    """VpnProtocol enum values."""

    OPENVPN = "openvpn"


class VpnState:
    """VpnState enum values."""

    PENDING = "pending"
    AVAILABLE = "available"
    DELETING = "deleting"
    DELETED = "deleted"


class VpnStaticRouteSource:
    """VpnStaticRouteSource enum values."""

    STATIC = "Static"


class VpnTunnelBandwidth:
    """VpnTunnelBandwidth enum values."""

    STANDARD = "standard"
    LARGE = "large"


class VpnTunnelProvisioningStatus:
    """VpnTunnelProvisioningStatus enum values."""

    AVAILABLE = "available"
    PENDING = "pending"
    FAILED = "failed"


class WeekDay:
    """WeekDay enum values."""

    SUNDAY = "sunday"
    MONDAY = "monday"
    TUESDAY = "tuesday"
    WEDNESDAY = "wednesday"
    THURSDAY = "thursday"
    FRIDAY = "friday"
    SATURDAY = "saturday"


class scope:
    """scope enum values."""

    AVAILABILITY_ZONE = "Availability Zone"
    REGION = "Region"


# Convenient aliases for enum values
AMAZON_WEB_SERVICES = AcceleratorManufacturer.AMAZON_WEB_SERVICES
AMD = AcceleratorManufacturer.AMD
NVIDIA = AcceleratorManufacturer.NVIDIA
XILINX = AcceleratorManufacturer.XILINX
HABANA = AcceleratorManufacturer.HABANA
A100 = AcceleratorName.A100
INFERENTIA = AcceleratorName.INFERENTIA
K520 = AcceleratorName.K520
K80 = AcceleratorName.K80
M60 = AcceleratorName.M60
RADEON_PRO_V520 = AcceleratorName.RADEON_PRO_V520
T4 = AcceleratorName.T4
VU9P = AcceleratorName.VU9P
V100 = AcceleratorName.V100
A10G = AcceleratorName.A10G
H100 = AcceleratorName.H100
T4G = AcceleratorName.T4G
L40S = AcceleratorName.L40S
L4 = AcceleratorName.L4
GAUDI_HL_205 = AcceleratorName.GAUDI_HL_205
INFERENTIA2 = AcceleratorName.INFERENTIA2
TRAINIUM = AcceleratorName.TRAINIUM
TRAINIUM2 = AcceleratorName.TRAINIUM2
U30 = AcceleratorName.U30
GPU = AcceleratorType.GPU
FPGA = AcceleratorType.FPGA
INFERENCE = AcceleratorType.INFERENCE
MEDIA = AcceleratorType.MEDIA
SUPPORTED_PLATFORMS = AccountAttributeName.SUPPORTED_PLATFORMS
DEFAULT_VPC = AccountAttributeName.DEFAULT_VPC
ERROR = ActivityStatus.ERROR
PENDING_FULFILLMENT = ActivityStatus.PENDING_FULFILLMENT
PENDING_TERMINATION = ActivityStatus.PENDING_TERMINATION
FULFILLED = ActivityStatus.FULFILLED
DOMAIN_NAME = AddressAttributeName.DOMAIN_NAME
IPV4 = AddressFamily.IPV4
IPV6 = AddressFamily.IPV6
PENDING = AddressTransferStatus.PENDING
DISABLED = AddressTransferStatus.DISABLED
ACCEPTED = AddressTransferStatus.ACCEPTED
DEFAULT = Affinity.DEFAULT
HOST = Affinity.HOST
AVAILABLE = AllocationState.AVAILABLE
UNDER_ASSESSMENT = AllocationState.UNDER_ASSESSMENT
PERMANENT_FAILURE = AllocationState.PERMANENT_FAILURE
RELEASED = AllocationState.RELEASED
RELEASED_PERMANENT_FAILURE = AllocationState.RELEASED_PERMANENT_FAILURE
PENDING = AllocationState.PENDING
LOWESTPRICE = AllocationStrategy.LOWESTPRICE
DIVERSIFIED = AllocationStrategy.DIVERSIFIED
CAPACITYOPTIMIZED = AllocationStrategy.CAPACITYOPTIMIZED
CAPACITYOPTIMIZEDPRIORITIZED = AllocationStrategy.CAPACITYOPTIMIZEDPRIORITIZED
PRICECAPACITYOPTIMIZED = AllocationStrategy.PRICECAPACITYOPTIMIZED
USED = AllocationType.USED
FUTURE = AllocationType.FUTURE
DISABLED = AllowedImagesSettingsDisabledState.DISABLED
ENABLED = AllowedImagesSettingsEnabledState.ENABLED
AUDIT_MODE = AllowedImagesSettingsEnabledState.AUDIT_MODE
ON = AllowsMultipleInstanceTypes.ON
OFF = AllowsMultipleInstanceTypes.OFF
ENABLED = AmdSevSnpSpecification.ENABLED
DISABLED = AmdSevSnpSpecification.DISABLED
RUNNING = AnalysisStatus.RUNNING
SUCCEEDED = AnalysisStatus.SUCCEEDED
FAILED = AnalysisStatus.FAILED
ENABLE = ApplianceModeSupportValue.ENABLE
DISABLE = ApplianceModeSupportValue.DISABLE
I386 = ArchitectureType.I386
X86_64 = ArchitectureType.X86_64
ARM64 = ArchitectureType.ARM64
X86_64_MAC = ArchitectureType.X86_64_MAC
ARM64_MAC = ArchitectureType.ARM64_MAC
I386 = ArchitectureValues.I386
X86_64 = ArchitectureValues.X86_64
ARM64 = ArchitectureValues.ARM64
X86_64_MAC = ArchitectureValues.X86_64_MAC
ARM64_MAC = ArchitectureValues.ARM64_MAC
DISASSOCIATED = AsnAssociationState.DISASSOCIATED
FAILED_DISASSOCIATION = AsnAssociationState.FAILED_DISASSOCIATION
FAILED_ASSOCIATION = AsnAssociationState.FAILED_ASSOCIATION
PENDING_DISASSOCIATION = AsnAssociationState.PENDING_DISASSOCIATION
PENDING_ASSOCIATION = AsnAssociationState.PENDING_ASSOCIATION
ASSOCIATED = AsnAssociationState.ASSOCIATED
DEPROVISIONED = AsnState.DEPROVISIONED
FAILED_DEPROVISION = AsnState.FAILED_DEPROVISION
FAILED_PROVISION = AsnState.FAILED_PROVISION
PENDING_DEPROVISION = AsnState.PENDING_DEPROVISION
PENDING_PROVISION = AsnState.PENDING_PROVISION
PROVISIONED = AsnState.PROVISIONED
VPC = AssociatedNetworkType.VPC
ASSOCIATING = AssociationStatusCode.ASSOCIATING
ASSOCIATED = AssociationStatusCode.ASSOCIATED
ASSOCIATION_FAILED = AssociationStatusCode.ASSOCIATION_FAILED
DISASSOCIATING = AssociationStatusCode.DISASSOCIATING
DISASSOCIATED = AssociationStatusCode.DISASSOCIATED
SHARED = AttachmentLimitType.SHARED
DEDICATED = AttachmentLimitType.DEDICATED
ATTACHING = AttachmentStatus.ATTACHING
ATTACHED = AttachmentStatus.ATTACHED
DETACHING = AttachmentStatus.DETACHING
DETACHED = AttachmentStatus.DETACHED
ENABLE = AutoAcceptSharedAssociationsValue.ENABLE
DISABLE = AutoAcceptSharedAssociationsValue.DISABLE
ENABLE = AutoAcceptSharedAttachmentsValue.ENABLE
DISABLE = AutoAcceptSharedAttachmentsValue.DISABLE
ON = AutoPlacement.ON
OFF = AutoPlacement.OFF
ENABLED = AutoProvisionZonesState.ENABLED
DISABLED = AutoProvisionZonesState.DISABLED
ENABLED = AutoScalingIpsState.ENABLED
DISABLED = AutoScalingIpsState.DISABLED
ZONAL = AvailabilityMode.ZONAL
REGIONAL = AvailabilityMode.REGIONAL
OPT_IN_NOT_REQUIRED = AvailabilityZoneOptInStatus.OPT_IN_NOT_REQUIRED
OPTED_IN = AvailabilityZoneOptInStatus.OPTED_IN
NOT_OPTED_IN = AvailabilityZoneOptInStatus.NOT_OPTED_IN
AVAILABLE = AvailabilityZoneState.AVAILABLE
INFORMATION = AvailabilityZoneState.INFORMATION
IMPAIRED = AvailabilityZoneState.IMPAIRED
UNAVAILABLE = AvailabilityZoneState.UNAVAILABLE
CONSTRAINED = AvailabilityZoneState.CONSTRAINED
DEFAULT = BandwidthWeightingType.DEFAULT
VPC_1 = BandwidthWeightingType.VPC_1
EBS_1 = BandwidthWeightingType.EBS_1
INCLUDED = BareMetal.INCLUDED
REQUIRED = BareMetal.REQUIRED
EXCLUDED = BareMetal.EXCLUDED
SUBMITTED = BatchState.SUBMITTED
ACTIVE = BatchState.ACTIVE
CANCELLED = BatchState.CANCELLED
FAILED = BatchState.FAILED
CANCELLED_RUNNING = BatchState.CANCELLED_RUNNING
CANCELLED_TERMINATING = BatchState.CANCELLED_TERMINATING
MODIFYING = BatchState.MODIFYING
UP = BgpStatus.UP
DOWN = BgpStatus.DOWN
OFF = BlockPublicAccessMode.OFF
BLOCK_BIDIRECTIONAL = BlockPublicAccessMode.BLOCK_BIDIRECTIONAL
BLOCK_INGRESS = BlockPublicAccessMode.BLOCK_INGRESS
LEGACY_BIOS = BootModeType.LEGACY_BIOS
UEFI = BootModeType.UEFI
LEGACY_BIOS = BootModeValues.LEGACY_BIOS
UEFI = BootModeValues.UEFI
UEFI_PREFERRED = BootModeValues.UEFI_PREFERRED
PENDING = BundleTaskState.PENDING
WAITING_FOR_SHUTDOWN = BundleTaskState.WAITING_FOR_SHUTDOWN
BUNDLING = BundleTaskState.BUNDLING
STORING = BundleTaskState.STORING
CANCELLING = BundleTaskState.CANCELLING
COMPLETE = BundleTaskState.COMPLETE
FAILED = BundleTaskState.FAILED
INCLUDED = BurstablePerformance.INCLUDED
REQUIRED = BurstablePerformance.REQUIRED
EXCLUDED = BurstablePerformance.EXCLUDED
ADVERTISED = ByoipCidrState.ADVERTISED
DEPROVISIONED = ByoipCidrState.DEPROVISIONED
FAILED_DEPROVISION = ByoipCidrState.FAILED_DEPROVISION
FAILED_PROVISION = ByoipCidrState.FAILED_PROVISION
PENDING_ADVERTISING = ByoipCidrState.PENDING_ADVERTISING
PENDING_DEPROVISION = ByoipCidrState.PENDING_DEPROVISION
PENDING_PROVISION = ByoipCidrState.PENDING_PROVISION
PENDING_WITHDRAWAL = ByoipCidrState.PENDING_WITHDRAWAL
PROVISIONED = ByoipCidrState.PROVISIONED
PROVISIONED_NOT_PUBLICLY_ADVERTISABLE = ByoipCidrState.PROVISIONED_NOT_PUBLICLY_ADVERTISABLE
ODCR_OWNER = CallerRole.ODCR_OWNER
UNUSED_RESERVATION_BILLING_OWNER = CallerRole.UNUSED_RESERVATION_BILLING_OWNER
FLEETREQUESTIDDOESNOTEXIST = CancelBatchErrorCode.FLEETREQUESTIDDOESNOTEXIST
FLEETREQUESTIDMALFORMED = CancelBatchErrorCode.FLEETREQUESTIDMALFORMED
FLEETREQUESTNOTINCANCELLABLESTATE = CancelBatchErrorCode.FLEETREQUESTNOTINCANCELLABLESTATE
UNEXPECTEDERROR = CancelBatchErrorCode.UNEXPECTEDERROR
ACTIVE = CancelSpotInstanceRequestState.ACTIVE
OPEN = CancelSpotInstanceRequestState.OPEN
CLOSED = CancelSpotInstanceRequestState.CLOSED
CANCELLED = CancelSpotInstanceRequestState.CANCELLED
COMPLETED = CancelSpotInstanceRequestState.COMPLETED
PAYMENT_PENDING = CapacityBlockExtensionStatus.PAYMENT_PENDING
PAYMENT_FAILED = CapacityBlockExtensionStatus.PAYMENT_FAILED
PAYMENT_SUCCEEDED = CapacityBlockExtensionStatus.PAYMENT_SUCCEEDED
OK = CapacityBlockInterconnectStatus.OK
IMPAIRED = CapacityBlockInterconnectStatus.IMPAIRED
INSUFFICIENT_DATA = CapacityBlockInterconnectStatus.INSUFFICIENT_DATA
ACTIVE = CapacityBlockResourceState.ACTIVE
EXPIRED = CapacityBlockResourceState.EXPIRED
UNAVAILABLE = CapacityBlockResourceState.UNAVAILABLE
CANCELLED = CapacityBlockResourceState.CANCELLED
FAILED = CapacityBlockResourceState.FAILED
SCHEDULED = CapacityBlockResourceState.SCHEDULED
PAYMENT_PENDING = CapacityBlockResourceState.PAYMENT_PENDING
PAYMENT_FAILED = CapacityBlockResourceState.PAYMENT_FAILED
PENDING = CapacityManagerDataExportStatus.PENDING
IN_PROGRESS = CapacityManagerDataExportStatus.IN_PROGRESS
DELIVERED = CapacityManagerDataExportStatus.DELIVERED
FAILED = CapacityManagerDataExportStatus.FAILED
ENABLED = CapacityManagerStatus.ENABLED
DISABLED = CapacityManagerStatus.DISABLED
PENDING = CapacityReservationBillingRequestStatus.PENDING
ACCEPTED = CapacityReservationBillingRequestStatus.ACCEPTED
REJECTED = CapacityReservationBillingRequestStatus.REJECTED
CANCELLED = CapacityReservationBillingRequestStatus.CANCELLED
REVOKED = CapacityReservationBillingRequestStatus.REVOKED
EXPIRED = CapacityReservationBillingRequestStatus.EXPIRED
FIXED = CapacityReservationDeliveryPreference.FIXED
INCREMENTAL = CapacityReservationDeliveryPreference.INCREMENTAL
SUBMITTED = CapacityReservationFleetState.SUBMITTED
MODIFYING = CapacityReservationFleetState.MODIFYING
ACTIVE = CapacityReservationFleetState.ACTIVE
PARTIALLY_FULFILLED = CapacityReservationFleetState.PARTIALLY_FULFILLED
EXPIRING = CapacityReservationFleetState.EXPIRING
EXPIRED = CapacityReservationFleetState.EXPIRED
CANCELLING = CapacityReservationFleetState.CANCELLING
CANCELLED = CapacityReservationFleetState.CANCELLED
FAILED = CapacityReservationFleetState.FAILED
LINUX_UNIX = CapacityReservationInstancePlatform.LINUX_UNIX
RED_HAT_ENTERPRISE_LINUX = CapacityReservationInstancePlatform.RED_HAT_ENTERPRISE_LINUX
SUSE_LINUX = CapacityReservationInstancePlatform.SUSE_LINUX
WINDOWS = CapacityReservationInstancePlatform.WINDOWS
WINDOWS_WITH_SQL_SERVER = CapacityReservationInstancePlatform.WINDOWS_WITH_SQL_SERVER
WINDOWS_WITH_SQL_SERVER_ENTERPRISE = CapacityReservationInstancePlatform.WINDOWS_WITH_SQL_SERVER_ENTERPRISE
WINDOWS_WITH_SQL_SERVER_STANDARD = CapacityReservationInstancePlatform.WINDOWS_WITH_SQL_SERVER_STANDARD
WINDOWS_WITH_SQL_SERVER_WEB = CapacityReservationInstancePlatform.WINDOWS_WITH_SQL_SERVER_WEB
LINUX_WITH_SQL_SERVER_STANDARD = CapacityReservationInstancePlatform.LINUX_WITH_SQL_SERVER_STANDARD
LINUX_WITH_SQL_SERVER_WEB = CapacityReservationInstancePlatform.LINUX_WITH_SQL_SERVER_WEB
LINUX_WITH_SQL_SERVER_ENTERPRISE = CapacityReservationInstancePlatform.LINUX_WITH_SQL_SERVER_ENTERPRISE
RHEL_WITH_SQL_SERVER_STANDARD = CapacityReservationInstancePlatform.RHEL_WITH_SQL_SERVER_STANDARD
RHEL_WITH_SQL_SERVER_ENTERPRISE = CapacityReservationInstancePlatform.RHEL_WITH_SQL_SERVER_ENTERPRISE
RHEL_WITH_SQL_SERVER_WEB = CapacityReservationInstancePlatform.RHEL_WITH_SQL_SERVER_WEB
RHEL_WITH_HA = CapacityReservationInstancePlatform.RHEL_WITH_HA
RHEL_WITH_HA_AND_SQL_SERVER_STANDARD = CapacityReservationInstancePlatform.RHEL_WITH_HA_AND_SQL_SERVER_STANDARD
RHEL_WITH_HA_AND_SQL_SERVER_ENTERPRISE = CapacityReservationInstancePlatform.RHEL_WITH_HA_AND_SQL_SERVER_ENTERPRISE
UBUNTU_PRO = CapacityReservationInstancePlatform.UBUNTU_PRO
CAPACITY_RESERVATIONS_ONLY = CapacityReservationPreference.CAPACITY_RESERVATIONS_ONLY
OPEN = CapacityReservationPreference.OPEN
NONE = CapacityReservationPreference.NONE
ACTIVE = CapacityReservationState.ACTIVE
EXPIRED = CapacityReservationState.EXPIRED
CANCELLED = CapacityReservationState.CANCELLED
PENDING = CapacityReservationState.PENDING
FAILED = CapacityReservationState.FAILED
SCHEDULED = CapacityReservationState.SCHEDULED
PAYMENT_PENDING = CapacityReservationState.PAYMENT_PENDING
PAYMENT_FAILED = CapacityReservationState.PAYMENT_FAILED
ASSESSING = CapacityReservationState.ASSESSING
DELAYED = CapacityReservationState.DELAYED
UNSUPPORTED = CapacityReservationState.UNSUPPORTED
UNAVAILABLE = CapacityReservationState.UNAVAILABLE
DEFAULT = CapacityReservationTenancy.DEFAULT
DEDICATED = CapacityReservationTenancy.DEDICATED
DEFAULT = CapacityReservationType.DEFAULT
CAPACITY_BLOCK = CapacityReservationType.CAPACITY_BLOCK
DEFAULT = CapacityTenancy.DEFAULT
DEDICATED = CapacityTenancy.DEDICATED
PENDING = CarrierGatewayState.PENDING
AVAILABLE = CarrierGatewayState.AVAILABLE
DELETING = CarrierGatewayState.DELETING
DELETED = CarrierGatewayState.DELETED
PENDING = ClientCertificateRevocationListStatusCode.PENDING
ACTIVE = ClientCertificateRevocationListStatusCode.ACTIVE
CERTIFICATE_AUTHENTICATION = ClientVpnAuthenticationType.CERTIFICATE_AUTHENTICATION
DIRECTORY_SERVICE_AUTHENTICATION = ClientVpnAuthenticationType.DIRECTORY_SERVICE_AUTHENTICATION
FEDERATED_AUTHENTICATION = ClientVpnAuthenticationType.FEDERATED_AUTHENTICATION
AUTHORIZING = ClientVpnAuthorizationRuleStatusCode.AUTHORIZING
ACTIVE = ClientVpnAuthorizationRuleStatusCode.ACTIVE
FAILED = ClientVpnAuthorizationRuleStatusCode.FAILED
REVOKING = ClientVpnAuthorizationRuleStatusCode.REVOKING
ACTIVE = ClientVpnConnectionStatusCode.ACTIVE
FAILED_TO_TERMINATE = ClientVpnConnectionStatusCode.FAILED_TO_TERMINATE
TERMINATING = ClientVpnConnectionStatusCode.TERMINATING
TERMINATED = ClientVpnConnectionStatusCode.TERMINATED
APPLYING = ClientVpnEndpointAttributeStatusCode.APPLYING
APPLIED = ClientVpnEndpointAttributeStatusCode.APPLIED
PENDING_ASSOCIATE = ClientVpnEndpointStatusCode.PENDING_ASSOCIATE
AVAILABLE = ClientVpnEndpointStatusCode.AVAILABLE
DELETING = ClientVpnEndpointStatusCode.DELETING
DELETED = ClientVpnEndpointStatusCode.DELETED
CREATING = ClientVpnRouteStatusCode.CREATING
ACTIVE = ClientVpnRouteStatusCode.ACTIVE
FAILED = ClientVpnRouteStatusCode.FAILED
DELETING = ClientVpnRouteStatusCode.DELETING
EQUALS = Comparison.EQUALS
IN = Comparison.IN
ENABLED = ConnectionNotificationState.ENABLED
DISABLED = ConnectionNotificationState.DISABLED
TOPIC = ConnectionNotificationType.TOPIC
PRIVATE = ConnectivityType.PRIVATE
PUBLIC = ConnectivityType.PUBLIC
OVA = ContainerFormat.OVA
ACTIVE = ConversionTaskState.ACTIVE
CANCELLING = ConversionTaskState.CANCELLING
CANCELLED = ConversionTaskState.CANCELLED
COMPLETED = ConversionTaskState.COMPLETED
VOLUME = CopyTagsFromSource.VOLUME
INTEL = CpuManufacturer.INTEL
AMD = CpuManufacturer.AMD
AMAZON_WEB_SERVICES = CpuManufacturer.AMAZON_WEB_SERVICES
APPLE = CpuManufacturer.APPLE
USD = CurrencyCodeValues.USD
ACTIVE = DatafeedSubscriptionState.ACTIVE
INACTIVE = DatafeedSubscriptionState.INACTIVE
DISABLED = DefaultInstanceMetadataEndpointState.DISABLED
ENABLED = DefaultInstanceMetadataEndpointState.ENABLED
NO_PREFERENCE = DefaultInstanceMetadataEndpointState.NO_PREFERENCE
DISABLED = DefaultInstanceMetadataTagsState.DISABLED
ENABLED = DefaultInstanceMetadataTagsState.ENABLED
NO_PREFERENCE = DefaultInstanceMetadataTagsState.NO_PREFERENCE
ENABLE = DefaultRouteTableAssociationValue.ENABLE
DISABLE = DefaultRouteTableAssociationValue.DISABLE
ENABLE = DefaultRouteTablePropagationValue.ENABLE
DISABLE = DefaultRouteTablePropagationValue.DISABLE
SPOT = DefaultTargetCapacityType.SPOT
ON_DEMAND = DefaultTargetCapacityType.ON_DEMAND
CAPACITY_BLOCK = DefaultTargetCapacityType.CAPACITY_BLOCK
FLEETIDDOESNOTEXIST = DeleteFleetErrorCode.FLEETIDDOESNOTEXIST
FLEETIDMALFORMED = DeleteFleetErrorCode.FLEETIDMALFORMED
FLEETNOTINDELETABLESTATE = DeleteFleetErrorCode.FLEETNOTINDELETABLESTATE
UNEXPECTEDERROR = DeleteFleetErrorCode.UNEXPECTEDERROR
RESERVED_INSTANCES_ID_INVALID = DeleteQueuedReservedInstancesErrorCode.RESERVED_INSTANCES_ID_INVALID
RESERVED_INSTANCES_NOT_IN_QUEUED_STATE = DeleteQueuedReservedInstancesErrorCode.RESERVED_INSTANCES_NOT_IN_QUEUED_STATE
UNEXPECTED_ERROR = DeleteQueuedReservedInstancesErrorCode.UNEXPECTED_ERROR
PLAIN_TEXT = DestinationFileFormat.PLAIN_TEXT
PARQUET = DestinationFileFormat.PARQUET
JAMF = DeviceTrustProviderType.JAMF
CROWDSTRIKE = DeviceTrustProviderType.CROWDSTRIKE
JUMPCLOUD = DeviceTrustProviderType.JUMPCLOUD
EBS = DeviceType.EBS
INSTANCE_STORE = DeviceType.INSTANCE_STORE
VMDK = DiskImageFormat.VMDK
RAW = DiskImageFormat.RAW
VHD = DiskImageFormat.VHD
HDD = DiskType.HDD
SSD = DiskType.SSD
PENDINGVERIFICATION = DnsNameState.PENDINGVERIFICATION
VERIFIED = DnsNameState.VERIFIED
FAILED = DnsNameState.FAILED
IPV4 = DnsRecordIpType.IPV4
DUALSTACK = DnsRecordIpType.DUALSTACK
IPV6 = DnsRecordIpType.IPV6
SERVICE_DEFINED = DnsRecordIpType.SERVICE_DEFINED
ENABLE = DnsSupportValue.ENABLE
DISABLE = DnsSupportValue.DISABLE
VPC = DomainType.VPC
STANDARD = DomainType.STANDARD
ENABLE = DynamicRoutingValue.ENABLE
DISABLE = DynamicRoutingValue.DISABLE
UNSUPPORTED = EbsEncryptionSupport.UNSUPPORTED
SUPPORTED = EbsEncryptionSupport.SUPPORTED
UNSUPPORTED = EbsNvmeSupport.UNSUPPORTED
SUPPORTED = EbsNvmeSupport.SUPPORTED
REQUIRED = EbsNvmeSupport.REQUIRED
UNSUPPORTED = EbsOptimizedSupport.UNSUPPORTED
SUPPORTED = EbsOptimizedSupport.SUPPORTED
DEFAULT = EbsOptimizedSupport.DEFAULT
CREATE_IN_PROGRESS = Ec2InstanceConnectEndpointState.CREATE_IN_PROGRESS
CREATE_COMPLETE = Ec2InstanceConnectEndpointState.CREATE_COMPLETE
CREATE_FAILED = Ec2InstanceConnectEndpointState.CREATE_FAILED
DELETE_IN_PROGRESS = Ec2InstanceConnectEndpointState.DELETE_IN_PROGRESS
DELETE_COMPLETE = Ec2InstanceConnectEndpointState.DELETE_COMPLETE
DELETE_FAILED = Ec2InstanceConnectEndpointState.DELETE_FAILED
UPDATE_IN_PROGRESS = Ec2InstanceConnectEndpointState.UPDATE_IN_PROGRESS
UPDATE_COMPLETE = Ec2InstanceConnectEndpointState.UPDATE_COMPLETE
UPDATE_FAILED = Ec2InstanceConnectEndpointState.UPDATE_FAILED
DER = EkPubKeyFormat.DER
TPMT = EkPubKeyFormat.TPMT
RSA_2048 = EkPubKeyType.RSA_2048
ECC_SEC_P384 = EkPubKeyType.ECC_SEC_P384
ATTACHED = ElasticGpuState.ATTACHED
OK = ElasticGpuStatus.OK
IMPAIRED = ElasticGpuStatus.IMPAIRED
UNSUPPORTED = EnaSupport.UNSUPPORTED
SUPPORTED = EnaSupport.SUPPORTED
REQUIRED = EnaSupport.REQUIRED
ENABLING = EncryptionStateValue.ENABLING
ENABLED = EncryptionStateValue.ENABLED
DISABLING = EncryptionStateValue.DISABLING
DISABLED = EncryptionStateValue.DISABLED
ENABLE = EncryptionSupportOptionValue.ENABLE
DISABLE = EncryptionSupportOptionValue.DISABLE
UNLIMITED = EndDateType.UNLIMITED
LIMITED = EndDateType.LIMITED
IPV4 = EndpointIpAddressType.IPV4
IPV6 = EndpointIpAddressType.IPV6
DUAL_STACK = EndpointIpAddressType.DUAL_STACK
UNSUPPORTED = EphemeralNvmeSupport.UNSUPPORTED
SUPPORTED = EphemeralNvmeSupport.SUPPORTED
REQUIRED = EphemeralNvmeSupport.REQUIRED
INSTANCE_REBOOT = EventCode.INSTANCE_REBOOT
SYSTEM_REBOOT = EventCode.SYSTEM_REBOOT
SYSTEM_MAINTENANCE = EventCode.SYSTEM_MAINTENANCE
INSTANCE_RETIREMENT = EventCode.INSTANCE_RETIREMENT
INSTANCE_STOP = EventCode.INSTANCE_STOP
INSTANCECHANGE = EventType.INSTANCECHANGE
FLEETREQUESTCHANGE = EventType.FLEETREQUESTCHANGE
ERROR = EventType.ERROR
INFORMATION = EventType.INFORMATION
NOTERMINATION = ExcessCapacityTerminationPolicy.NOTERMINATION
DEFAULT = ExcessCapacityTerminationPolicy.DEFAULT
CITRIX = ExportEnvironment.CITRIX
VMWARE = ExportEnvironment.VMWARE
MICROSOFT = ExportEnvironment.MICROSOFT
ACTIVE = ExportTaskState.ACTIVE
CANCELLING = ExportTaskState.CANCELLING
CANCELLED = ExportTaskState.CANCELLED
COMPLETED = ExportTaskState.COMPLETED
SNAPSHOT = FastLaunchResourceType.SNAPSHOT
ENABLING = FastLaunchStateCode.ENABLING
ENABLING_FAILED = FastLaunchStateCode.ENABLING_FAILED
ENABLED = FastLaunchStateCode.ENABLED
ENABLED_FAILED = FastLaunchStateCode.ENABLED_FAILED
DISABLING = FastLaunchStateCode.DISABLING
DISABLING_FAILED = FastLaunchStateCode.DISABLING_FAILED
ENABLING = FastSnapshotRestoreStateCode.ENABLING
OPTIMIZING = FastSnapshotRestoreStateCode.OPTIMIZING
ENABLED = FastSnapshotRestoreStateCode.ENABLED
DISABLING = FastSnapshotRestoreStateCode.DISABLING
DISABLED = FastSnapshotRestoreStateCode.DISABLED
RESOURCE_REGION = FilterByDimension.RESOURCE_REGION
AVAILABILITY_ZONE_ID = FilterByDimension.AVAILABILITY_ZONE_ID
ACCOUNT_ID = FilterByDimension.ACCOUNT_ID
INSTANCE_FAMILY = FilterByDimension.INSTANCE_FAMILY
INSTANCE_TYPE = FilterByDimension.INSTANCE_TYPE
INSTANCE_PLATFORM = FilterByDimension.INSTANCE_PLATFORM
RESERVATION_ARN = FilterByDimension.RESERVATION_ARN
RESERVATION_ID = FilterByDimension.RESERVATION_ID
RESERVATION_TYPE = FilterByDimension.RESERVATION_TYPE
RESERVATION_CREATE_TIMESTAMP = FilterByDimension.RESERVATION_CREATE_TIMESTAMP
RESERVATION_START_TIMESTAMP = FilterByDimension.RESERVATION_START_TIMESTAMP
RESERVATION_END_TIMESTAMP = FilterByDimension.RESERVATION_END_TIMESTAMP
RESERVATION_END_DATE_TYPE = FilterByDimension.RESERVATION_END_DATE_TYPE
TENANCY = FilterByDimension.TENANCY
RESERVATION_STATE = FilterByDimension.RESERVATION_STATE
RESERVATION_INSTANCE_MATCH_CRITERIA = FilterByDimension.RESERVATION_INSTANCE_MATCH_CRITERIA
RESERVATION_UNUSED_FINANCIAL_OWNER = FilterByDimension.RESERVATION_UNUSED_FINANCIAL_OWNER
TRUE = FindingsFound.TRUE
FALSE = FindingsFound.FALSE
UNKNOWN = FindingsFound.UNKNOWN
ERROR = FleetActivityStatus.ERROR
PENDING_FULFILLMENT = FleetActivityStatus.PENDING_FULFILLMENT
PENDING_TERMINATION = FleetActivityStatus.PENDING_TERMINATION
FULFILLED = FleetActivityStatus.FULFILLED
DEFAULT = FleetCapacityReservationTenancy.DEFAULT
USE_CAPACITY_RESERVATIONS_FIRST = FleetCapacityReservationUsageStrategy.USE_CAPACITY_RESERVATIONS_FIRST
INSTANCE_CHANGE = FleetEventType.INSTANCE_CHANGE
FLEET_CHANGE = FleetEventType.FLEET_CHANGE
SERVICE_ERROR = FleetEventType.SERVICE_ERROR
NO_TERMINATION = FleetExcessCapacityTerminationPolicy.NO_TERMINATION
TERMINATION = FleetExcessCapacityTerminationPolicy.TERMINATION
OPEN = FleetInstanceMatchCriteria.OPEN
LOWEST_PRICE = FleetOnDemandAllocationStrategy.LOWEST_PRICE
PRIORITIZED = FleetOnDemandAllocationStrategy.PRIORITIZED
LAUNCH = FleetReplacementStrategy.LAUNCH
LAUNCH_BEFORE_TERMINATE = FleetReplacementStrategy.LAUNCH_BEFORE_TERMINATE
SUBMITTED = FleetStateCode.SUBMITTED
ACTIVE = FleetStateCode.ACTIVE
DELETED = FleetStateCode.DELETED
FAILED = FleetStateCode.FAILED
DELETED_RUNNING = FleetStateCode.DELETED_RUNNING
DELETED_TERMINATING = FleetStateCode.DELETED_TERMINATING
MODIFYING = FleetStateCode.MODIFYING
REQUEST = FleetType.REQUEST
MAINTAIN = FleetType.MAINTAIN
INSTANT = FleetType.INSTANT
UNSUPPORTED = FlexibleEnaQueuesSupport.UNSUPPORTED
SUPPORTED = FlexibleEnaQueuesSupport.SUPPORTED
VPC = FlowLogsResourceType.VPC
SUBNET = FlowLogsResourceType.SUBNET
NETWORKINTERFACE = FlowLogsResourceType.NETWORKINTERFACE
TRANSITGATEWAY = FlowLogsResourceType.TRANSITGATEWAY
TRANSITGATEWAYATTACHMENT = FlowLogsResourceType.TRANSITGATEWAYATTACHMENT
REGIONALNATGATEWAY = FlowLogsResourceType.REGIONALNATGATEWAY
DESCRIPTION = FpgaImageAttributeName.DESCRIPTION
NAME = FpgaImageAttributeName.NAME
LOADPERMISSION = FpgaImageAttributeName.LOADPERMISSION
PRODUCTCODES = FpgaImageAttributeName.PRODUCTCODES
PENDING = FpgaImageStateCode.PENDING
FAILED = FpgaImageStateCode.FAILED
AVAILABLE = FpgaImageStateCode.AVAILABLE
UNAVAILABLE = FpgaImageStateCode.UNAVAILABLE
ASSOCIATED = GatewayAssociationState.ASSOCIATED
NOT_ASSOCIATED = GatewayAssociationState.NOT_ASSOCIATED
ASSOCIATING = GatewayAssociationState.ASSOCIATING
DISASSOCIATING = GatewayAssociationState.DISASSOCIATING
IPSEC_1 = GatewayType.IPSEC_1
RESOURCE_REGION = GroupBy.RESOURCE_REGION
AVAILABILITY_ZONE_ID = GroupBy.AVAILABILITY_ZONE_ID
ACCOUNT_ID = GroupBy.ACCOUNT_ID
INSTANCE_FAMILY = GroupBy.INSTANCE_FAMILY
INSTANCE_TYPE = GroupBy.INSTANCE_TYPE
INSTANCE_PLATFORM = GroupBy.INSTANCE_PLATFORM
RESERVATION_ARN = GroupBy.RESERVATION_ARN
RESERVATION_ID = GroupBy.RESERVATION_ID
RESERVATION_TYPE = GroupBy.RESERVATION_TYPE
RESERVATION_CREATE_TIMESTAMP = GroupBy.RESERVATION_CREATE_TIMESTAMP
RESERVATION_START_TIMESTAMP = GroupBy.RESERVATION_START_TIMESTAMP
RESERVATION_END_TIMESTAMP = GroupBy.RESERVATION_END_TIMESTAMP
RESERVATION_END_DATE_TYPE = GroupBy.RESERVATION_END_DATE_TYPE
TENANCY = GroupBy.TENANCY
RESERVATION_STATE = GroupBy.RESERVATION_STATE
RESERVATION_INSTANCE_MATCH_CRITERIA = GroupBy.RESERVATION_INSTANCE_MATCH_CRITERIA
RESERVATION_UNUSED_FINANCIAL_OWNER = GroupBy.RESERVATION_UNUSED_FINANCIAL_OWNER
PROCESSING = HaStatus.PROCESSING
ACTIVE = HaStatus.ACTIVE
STANDBY = HaStatus.STANDBY
INVALID = HaStatus.INVALID
ON = HostMaintenance.ON
OFF = HostMaintenance.OFF
ON = HostRecovery.ON
OFF = HostRecovery.OFF
DEFAULT = HostTenancy.DEFAULT
DEDICATED = HostTenancy.DEDICATED
HOST = HostTenancy.HOST
IP_NAME = HostnameType.IP_NAME
RESOURCE_NAME = HostnameType.RESOURCE_NAME
OPTIONAL = HttpTokensState.OPTIONAL
REQUIRED = HttpTokensState.REQUIRED
OVM = HypervisorType.OVM
XEN = HypervisorType.XEN
ASSOCIATING = IamInstanceProfileAssociationState.ASSOCIATING
ASSOCIATED = IamInstanceProfileAssociationState.ASSOCIATED
DISASSOCIATING = IamInstanceProfileAssociationState.DISASSOCIATING
DISASSOCIATED = IamInstanceProfileAssociationState.DISASSOCIATED
ENABLE = Igmpv2SupportValue.ENABLE
DISABLE = Igmpv2SupportValue.DISABLE
DESCRIPTION = ImageAttributeName.DESCRIPTION
KERNEL = ImageAttributeName.KERNEL
RAMDISK = ImageAttributeName.RAMDISK
LAUNCHPERMISSION = ImageAttributeName.LAUNCHPERMISSION
PRODUCTCODES = ImageAttributeName.PRODUCTCODES
BLOCKDEVICEMAPPING = ImageAttributeName.BLOCKDEVICEMAPPING
SRIOVNETSUPPORT = ImageAttributeName.SRIOVNETSUPPORT
BOOTMODE = ImageAttributeName.BOOTMODE
TPMSUPPORT = ImageAttributeName.TPMSUPPORT
UEFIDATA = ImageAttributeName.UEFIDATA
LASTLAUNCHEDTIME = ImageAttributeName.LASTLAUNCHEDTIME
IMDSSUPPORT = ImageAttributeName.IMDSSUPPORT
DEREGISTRATIONPROTECTION = ImageAttributeName.DEREGISTRATIONPROTECTION
UNBLOCKED = ImageBlockPublicAccessDisabledState.UNBLOCKED
BLOCK_NEW_SHARING = ImageBlockPublicAccessEnabledState.BLOCK_NEW_SHARING
STATE_NAME = ImageReferenceOptionName.STATE_NAME
VERSION_DEPTH = ImageReferenceOptionName.VERSION_DEPTH
EC2_INSTANCE = ImageReferenceResourceType.EC2_INSTANCE
EC2_LAUNCHTEMPLATE = ImageReferenceResourceType.EC2_LAUNCHTEMPLATE
SSM_PARAMETER = ImageReferenceResourceType.SSM_PARAMETER
IMAGEBUILDER_IMAGERECIPE = ImageReferenceResourceType.IMAGEBUILDER_IMAGERECIPE
IMAGEBUILDER_CONTAINERRECIPE = ImageReferenceResourceType.IMAGEBUILDER_CONTAINERRECIPE
PENDING = ImageState.PENDING
AVAILABLE = ImageState.AVAILABLE
INVALID = ImageState.INVALID
DEREGISTERED = ImageState.DEREGISTERED
TRANSIENT = ImageState.TRANSIENT
FAILED = ImageState.FAILED
ERROR = ImageState.ERROR
DISABLED = ImageState.DISABLED
MACHINE = ImageTypeValues.MACHINE
KERNEL = ImageTypeValues.KERNEL
RAMDISK = ImageTypeValues.RAMDISK
V2_0 = ImdsSupportValues.V2_0
INITIAL_INGESTION_IN_PROGRESS = IngestionStatus.INITIAL_INGESTION_IN_PROGRESS
INGESTION_COMPLETE = IngestionStatus.INGESTION_COMPLETE
INGESTION_FAILED = IngestionStatus.INGESTION_FAILED
DEFAULT = InitializationType.DEFAULT
PROVISIONED_RATE = InitializationType.PROVISIONED_RATE
VOLUME_COPY = InitializationType.VOLUME_COPY
INSTANCETYPE = InstanceAttributeName.INSTANCETYPE
KERNEL = InstanceAttributeName.KERNEL
RAMDISK = InstanceAttributeName.RAMDISK
USERDATA = InstanceAttributeName.USERDATA
DISABLEAPITERMINATION = InstanceAttributeName.DISABLEAPITERMINATION
INSTANCEINITIATEDSHUTDOWNBEHAVIOR = InstanceAttributeName.INSTANCEINITIATEDSHUTDOWNBEHAVIOR
ROOTDEVICENAME = InstanceAttributeName.ROOTDEVICENAME
BLOCKDEVICEMAPPING = InstanceAttributeName.BLOCKDEVICEMAPPING
PRODUCTCODES = InstanceAttributeName.PRODUCTCODES
SOURCEDESTCHECK = InstanceAttributeName.SOURCEDESTCHECK
GROUPSET = InstanceAttributeName.GROUPSET
EBSOPTIMIZED = InstanceAttributeName.EBSOPTIMIZED
SRIOVNETSUPPORT = InstanceAttributeName.SRIOVNETSUPPORT
ENASUPPORT = InstanceAttributeName.ENASUPPORT
ENCLAVEOPTIONS = InstanceAttributeName.ENCLAVEOPTIONS
DISABLEAPISTOP = InstanceAttributeName.DISABLEAPISTOP
DISABLED = InstanceAutoRecoveryState.DISABLED
DEFAULT = InstanceAutoRecoveryState.DEFAULT
DEFAULT = InstanceBandwidthWeighting.DEFAULT
VPC_1 = InstanceBandwidthWeighting.VPC_1
EBS_1 = InstanceBandwidthWeighting.EBS_1
LEGACY_BIOS = InstanceBootModeValues.LEGACY_BIOS
UEFI = InstanceBootModeValues.UEFI
CREATING = InstanceEventWindowState.CREATING
DELETING = InstanceEventWindowState.DELETING
ACTIVE = InstanceEventWindowState.ACTIVE
DELETED = InstanceEventWindowState.DELETED
CURRENT = InstanceGeneration.CURRENT
PREVIOUS = InstanceGeneration.PREVIOUS
HEALTHY = InstanceHealthStatus.HEALTHY
UNHEALTHY = InstanceHealthStatus.UNHEALTHY
HIBERNATE = InstanceInterruptionBehavior.HIBERNATE
STOP = InstanceInterruptionBehavior.STOP
TERMINATE = InstanceInterruptionBehavior.TERMINATE
SPOT = InstanceLifecycle.SPOT
ON_DEMAND = InstanceLifecycle.ON_DEMAND
SPOT = InstanceLifecycleType.SPOT
SCHEDULED = InstanceLifecycleType.SCHEDULED
CAPACITY_BLOCK = InstanceLifecycleType.CAPACITY_BLOCK
INTERRUPTIBLE_CAPACITY_RESERVATION = InstanceLifecycleType.INTERRUPTIBLE_CAPACITY_RESERVATION
OPEN = InstanceMatchCriteria.OPEN
TARGETED = InstanceMatchCriteria.TARGETED
DISABLED = InstanceMetadataEndpointState.DISABLED
ENABLED = InstanceMetadataEndpointState.ENABLED
PENDING = InstanceMetadataOptionsState.PENDING
APPLIED = InstanceMetadataOptionsState.APPLIED
DISABLED = InstanceMetadataProtocolState.DISABLED
ENABLED = InstanceMetadataProtocolState.ENABLED
DISABLED = InstanceMetadataTagsState.DISABLED
ENABLED = InstanceMetadataTagsState.ENABLED
DISABLED = InstanceRebootMigrationState.DISABLED
DEFAULT = InstanceRebootMigrationState.DEFAULT
PENDING = InstanceStateName.PENDING
RUNNING = InstanceStateName.RUNNING
SHUTTING_DOWN = InstanceStateName.SHUTTING_DOWN
TERMINATED = InstanceStateName.TERMINATED
STOPPING = InstanceStateName.STOPPING
STOPPED = InstanceStateName.STOPPED
UNSUPPORTED = InstanceStorageEncryptionSupport.UNSUPPORTED
REQUIRED = InstanceStorageEncryptionSupport.REQUIRED
A1_MEDIUM = InstanceType.A1_MEDIUM
A1_LARGE = InstanceType.A1_LARGE
A1_XLARGE = InstanceType.A1_XLARGE
A1_2XLARGE = InstanceType.A1_2XLARGE
A1_4XLARGE = InstanceType.A1_4XLARGE
A1_METAL = InstanceType.A1_METAL
C1_MEDIUM = InstanceType.C1_MEDIUM
C1_XLARGE = InstanceType.C1_XLARGE
C3_LARGE = InstanceType.C3_LARGE
C3_XLARGE = InstanceType.C3_XLARGE
C3_2XLARGE = InstanceType.C3_2XLARGE
C3_4XLARGE = InstanceType.C3_4XLARGE
C3_8XLARGE = InstanceType.C3_8XLARGE
C4_LARGE = InstanceType.C4_LARGE
C4_XLARGE = InstanceType.C4_XLARGE
C4_2XLARGE = InstanceType.C4_2XLARGE
C4_4XLARGE = InstanceType.C4_4XLARGE
C4_8XLARGE = InstanceType.C4_8XLARGE
C5_LARGE = InstanceType.C5_LARGE
C5_XLARGE = InstanceType.C5_XLARGE
C5_2XLARGE = InstanceType.C5_2XLARGE
C5_4XLARGE = InstanceType.C5_4XLARGE
C5_9XLARGE = InstanceType.C5_9XLARGE
C5_12XLARGE = InstanceType.C5_12XLARGE
C5_18XLARGE = InstanceType.C5_18XLARGE
C5_24XLARGE = InstanceType.C5_24XLARGE
C5_METAL = InstanceType.C5_METAL
C5A_LARGE = InstanceType.C5A_LARGE
C5A_XLARGE = InstanceType.C5A_XLARGE
C5A_2XLARGE = InstanceType.C5A_2XLARGE
C5A_4XLARGE = InstanceType.C5A_4XLARGE
C5A_8XLARGE = InstanceType.C5A_8XLARGE
C5A_12XLARGE = InstanceType.C5A_12XLARGE
C5A_16XLARGE = InstanceType.C5A_16XLARGE
C5A_24XLARGE = InstanceType.C5A_24XLARGE
C5AD_LARGE = InstanceType.C5AD_LARGE
C5AD_XLARGE = InstanceType.C5AD_XLARGE
C5AD_2XLARGE = InstanceType.C5AD_2XLARGE
C5AD_4XLARGE = InstanceType.C5AD_4XLARGE
C5AD_8XLARGE = InstanceType.C5AD_8XLARGE
C5AD_12XLARGE = InstanceType.C5AD_12XLARGE
C5AD_16XLARGE = InstanceType.C5AD_16XLARGE
C5AD_24XLARGE = InstanceType.C5AD_24XLARGE
C5D_LARGE = InstanceType.C5D_LARGE
C5D_XLARGE = InstanceType.C5D_XLARGE
C5D_2XLARGE = InstanceType.C5D_2XLARGE
C5D_4XLARGE = InstanceType.C5D_4XLARGE
C5D_9XLARGE = InstanceType.C5D_9XLARGE
C5D_12XLARGE = InstanceType.C5D_12XLARGE
C5D_18XLARGE = InstanceType.C5D_18XLARGE
C5D_24XLARGE = InstanceType.C5D_24XLARGE
C5D_METAL = InstanceType.C5D_METAL
C5N_LARGE = InstanceType.C5N_LARGE
C5N_XLARGE = InstanceType.C5N_XLARGE
C5N_2XLARGE = InstanceType.C5N_2XLARGE
C5N_4XLARGE = InstanceType.C5N_4XLARGE
C5N_9XLARGE = InstanceType.C5N_9XLARGE
C5N_18XLARGE = InstanceType.C5N_18XLARGE
C5N_METAL = InstanceType.C5N_METAL
C6G_MEDIUM = InstanceType.C6G_MEDIUM
C6G_LARGE = InstanceType.C6G_LARGE
C6G_XLARGE = InstanceType.C6G_XLARGE
C6G_2XLARGE = InstanceType.C6G_2XLARGE
C6G_4XLARGE = InstanceType.C6G_4XLARGE
C6G_8XLARGE = InstanceType.C6G_8XLARGE
C6G_12XLARGE = InstanceType.C6G_12XLARGE
C6G_16XLARGE = InstanceType.C6G_16XLARGE
C6G_METAL = InstanceType.C6G_METAL
C6GD_MEDIUM = InstanceType.C6GD_MEDIUM
C6GD_LARGE = InstanceType.C6GD_LARGE
C6GD_XLARGE = InstanceType.C6GD_XLARGE
C6GD_2XLARGE = InstanceType.C6GD_2XLARGE
C6GD_4XLARGE = InstanceType.C6GD_4XLARGE
C6GD_8XLARGE = InstanceType.C6GD_8XLARGE
C6GD_12XLARGE = InstanceType.C6GD_12XLARGE
C6GD_16XLARGE = InstanceType.C6GD_16XLARGE
C6GD_METAL = InstanceType.C6GD_METAL
C6GN_MEDIUM = InstanceType.C6GN_MEDIUM
C6GN_LARGE = InstanceType.C6GN_LARGE
C6GN_XLARGE = InstanceType.C6GN_XLARGE
C6GN_2XLARGE = InstanceType.C6GN_2XLARGE
C6GN_4XLARGE = InstanceType.C6GN_4XLARGE
C6GN_8XLARGE = InstanceType.C6GN_8XLARGE
C6GN_12XLARGE = InstanceType.C6GN_12XLARGE
C6GN_16XLARGE = InstanceType.C6GN_16XLARGE
C6I_LARGE = InstanceType.C6I_LARGE
C6I_XLARGE = InstanceType.C6I_XLARGE
C6I_2XLARGE = InstanceType.C6I_2XLARGE
C6I_4XLARGE = InstanceType.C6I_4XLARGE
C6I_8XLARGE = InstanceType.C6I_8XLARGE
C6I_12XLARGE = InstanceType.C6I_12XLARGE
C6I_16XLARGE = InstanceType.C6I_16XLARGE
C6I_24XLARGE = InstanceType.C6I_24XLARGE
C6I_32XLARGE = InstanceType.C6I_32XLARGE
C6I_METAL = InstanceType.C6I_METAL
CC1_4XLARGE = InstanceType.CC1_4XLARGE
CC2_8XLARGE = InstanceType.CC2_8XLARGE
CG1_4XLARGE = InstanceType.CG1_4XLARGE
CR1_8XLARGE = InstanceType.CR1_8XLARGE
D2_XLARGE = InstanceType.D2_XLARGE
D2_2XLARGE = InstanceType.D2_2XLARGE
D2_4XLARGE = InstanceType.D2_4XLARGE
D2_8XLARGE = InstanceType.D2_8XLARGE
D3_XLARGE = InstanceType.D3_XLARGE
D3_2XLARGE = InstanceType.D3_2XLARGE
D3_4XLARGE = InstanceType.D3_4XLARGE
D3_8XLARGE = InstanceType.D3_8XLARGE
D3EN_XLARGE = InstanceType.D3EN_XLARGE
D3EN_2XLARGE = InstanceType.D3EN_2XLARGE
D3EN_4XLARGE = InstanceType.D3EN_4XLARGE
D3EN_6XLARGE = InstanceType.D3EN_6XLARGE
D3EN_8XLARGE = InstanceType.D3EN_8XLARGE
D3EN_12XLARGE = InstanceType.D3EN_12XLARGE
DL1_24XLARGE = InstanceType.DL1_24XLARGE
F1_2XLARGE = InstanceType.F1_2XLARGE
F1_4XLARGE = InstanceType.F1_4XLARGE
F1_16XLARGE = InstanceType.F1_16XLARGE
G2_2XLARGE = InstanceType.G2_2XLARGE
G2_8XLARGE = InstanceType.G2_8XLARGE
G3_4XLARGE = InstanceType.G3_4XLARGE
G3_8XLARGE = InstanceType.G3_8XLARGE
G3_16XLARGE = InstanceType.G3_16XLARGE
G3S_XLARGE = InstanceType.G3S_XLARGE
G4AD_XLARGE = InstanceType.G4AD_XLARGE
G4AD_2XLARGE = InstanceType.G4AD_2XLARGE
G4AD_4XLARGE = InstanceType.G4AD_4XLARGE
G4AD_8XLARGE = InstanceType.G4AD_8XLARGE
G4AD_16XLARGE = InstanceType.G4AD_16XLARGE
G4DN_XLARGE = InstanceType.G4DN_XLARGE
G4DN_2XLARGE = InstanceType.G4DN_2XLARGE
G4DN_4XLARGE = InstanceType.G4DN_4XLARGE
G4DN_8XLARGE = InstanceType.G4DN_8XLARGE
G4DN_12XLARGE = InstanceType.G4DN_12XLARGE
G4DN_16XLARGE = InstanceType.G4DN_16XLARGE
G4DN_METAL = InstanceType.G4DN_METAL
G5_XLARGE = InstanceType.G5_XLARGE
G5_2XLARGE = InstanceType.G5_2XLARGE
G5_4XLARGE = InstanceType.G5_4XLARGE
G5_8XLARGE = InstanceType.G5_8XLARGE
G5_12XLARGE = InstanceType.G5_12XLARGE
G5_16XLARGE = InstanceType.G5_16XLARGE
G5_24XLARGE = InstanceType.G5_24XLARGE
G5_48XLARGE = InstanceType.G5_48XLARGE
G5G_XLARGE = InstanceType.G5G_XLARGE
G5G_2XLARGE = InstanceType.G5G_2XLARGE
G5G_4XLARGE = InstanceType.G5G_4XLARGE
G5G_8XLARGE = InstanceType.G5G_8XLARGE
G5G_16XLARGE = InstanceType.G5G_16XLARGE
G5G_METAL = InstanceType.G5G_METAL
HI1_4XLARGE = InstanceType.HI1_4XLARGE
HPC6A_48XLARGE = InstanceType.HPC6A_48XLARGE
HS1_8XLARGE = InstanceType.HS1_8XLARGE
H1_2XLARGE = InstanceType.H1_2XLARGE
H1_4XLARGE = InstanceType.H1_4XLARGE
H1_8XLARGE = InstanceType.H1_8XLARGE
H1_16XLARGE = InstanceType.H1_16XLARGE
I2_XLARGE = InstanceType.I2_XLARGE
I2_2XLARGE = InstanceType.I2_2XLARGE
I2_4XLARGE = InstanceType.I2_4XLARGE
I2_8XLARGE = InstanceType.I2_8XLARGE
I3_LARGE = InstanceType.I3_LARGE
I3_XLARGE = InstanceType.I3_XLARGE
I3_2XLARGE = InstanceType.I3_2XLARGE
I3_4XLARGE = InstanceType.I3_4XLARGE
I3_8XLARGE = InstanceType.I3_8XLARGE
I3_16XLARGE = InstanceType.I3_16XLARGE
I3_METAL = InstanceType.I3_METAL
I3EN_LARGE = InstanceType.I3EN_LARGE
I3EN_XLARGE = InstanceType.I3EN_XLARGE
I3EN_2XLARGE = InstanceType.I3EN_2XLARGE
I3EN_3XLARGE = InstanceType.I3EN_3XLARGE
I3EN_6XLARGE = InstanceType.I3EN_6XLARGE
I3EN_12XLARGE = InstanceType.I3EN_12XLARGE
I3EN_24XLARGE = InstanceType.I3EN_24XLARGE
I3EN_METAL = InstanceType.I3EN_METAL
IM4GN_LARGE = InstanceType.IM4GN_LARGE
IM4GN_XLARGE = InstanceType.IM4GN_XLARGE
IM4GN_2XLARGE = InstanceType.IM4GN_2XLARGE
IM4GN_4XLARGE = InstanceType.IM4GN_4XLARGE
IM4GN_8XLARGE = InstanceType.IM4GN_8XLARGE
IM4GN_16XLARGE = InstanceType.IM4GN_16XLARGE
INF1_XLARGE = InstanceType.INF1_XLARGE
INF1_2XLARGE = InstanceType.INF1_2XLARGE
INF1_6XLARGE = InstanceType.INF1_6XLARGE
INF1_24XLARGE = InstanceType.INF1_24XLARGE
IS4GEN_MEDIUM = InstanceType.IS4GEN_MEDIUM
IS4GEN_LARGE = InstanceType.IS4GEN_LARGE
IS4GEN_XLARGE = InstanceType.IS4GEN_XLARGE
IS4GEN_2XLARGE = InstanceType.IS4GEN_2XLARGE
IS4GEN_4XLARGE = InstanceType.IS4GEN_4XLARGE
IS4GEN_8XLARGE = InstanceType.IS4GEN_8XLARGE
M1_SMALL = InstanceType.M1_SMALL
M1_MEDIUM = InstanceType.M1_MEDIUM
M1_LARGE = InstanceType.M1_LARGE
M1_XLARGE = InstanceType.M1_XLARGE
M2_XLARGE = InstanceType.M2_XLARGE
M2_2XLARGE = InstanceType.M2_2XLARGE
M2_4XLARGE = InstanceType.M2_4XLARGE
M3_MEDIUM = InstanceType.M3_MEDIUM
M3_LARGE = InstanceType.M3_LARGE
M3_XLARGE = InstanceType.M3_XLARGE
M3_2XLARGE = InstanceType.M3_2XLARGE
M4_LARGE = InstanceType.M4_LARGE
M4_XLARGE = InstanceType.M4_XLARGE
M4_2XLARGE = InstanceType.M4_2XLARGE
M4_4XLARGE = InstanceType.M4_4XLARGE
M4_10XLARGE = InstanceType.M4_10XLARGE
M4_16XLARGE = InstanceType.M4_16XLARGE
M5_LARGE = InstanceType.M5_LARGE
M5_XLARGE = InstanceType.M5_XLARGE
M5_2XLARGE = InstanceType.M5_2XLARGE
M5_4XLARGE = InstanceType.M5_4XLARGE
M5_8XLARGE = InstanceType.M5_8XLARGE
M5_12XLARGE = InstanceType.M5_12XLARGE
M5_16XLARGE = InstanceType.M5_16XLARGE
M5_24XLARGE = InstanceType.M5_24XLARGE
M5_METAL = InstanceType.M5_METAL
M5A_LARGE = InstanceType.M5A_LARGE
M5A_XLARGE = InstanceType.M5A_XLARGE
M5A_2XLARGE = InstanceType.M5A_2XLARGE
M5A_4XLARGE = InstanceType.M5A_4XLARGE
M5A_8XLARGE = InstanceType.M5A_8XLARGE
M5A_12XLARGE = InstanceType.M5A_12XLARGE
M5A_16XLARGE = InstanceType.M5A_16XLARGE
M5A_24XLARGE = InstanceType.M5A_24XLARGE
M5AD_LARGE = InstanceType.M5AD_LARGE
M5AD_XLARGE = InstanceType.M5AD_XLARGE
M5AD_2XLARGE = InstanceType.M5AD_2XLARGE
M5AD_4XLARGE = InstanceType.M5AD_4XLARGE
M5AD_8XLARGE = InstanceType.M5AD_8XLARGE
M5AD_12XLARGE = InstanceType.M5AD_12XLARGE
M5AD_16XLARGE = InstanceType.M5AD_16XLARGE
M5AD_24XLARGE = InstanceType.M5AD_24XLARGE
M5D_LARGE = InstanceType.M5D_LARGE
M5D_XLARGE = InstanceType.M5D_XLARGE
M5D_2XLARGE = InstanceType.M5D_2XLARGE
M5D_4XLARGE = InstanceType.M5D_4XLARGE
M5D_8XLARGE = InstanceType.M5D_8XLARGE
M5D_12XLARGE = InstanceType.M5D_12XLARGE
M5D_16XLARGE = InstanceType.M5D_16XLARGE
M5D_24XLARGE = InstanceType.M5D_24XLARGE
M5D_METAL = InstanceType.M5D_METAL
M5DN_LARGE = InstanceType.M5DN_LARGE
M5DN_XLARGE = InstanceType.M5DN_XLARGE
M5DN_2XLARGE = InstanceType.M5DN_2XLARGE
M5DN_4XLARGE = InstanceType.M5DN_4XLARGE
M5DN_8XLARGE = InstanceType.M5DN_8XLARGE
M5DN_12XLARGE = InstanceType.M5DN_12XLARGE
M5DN_16XLARGE = InstanceType.M5DN_16XLARGE
M5DN_24XLARGE = InstanceType.M5DN_24XLARGE
M5DN_METAL = InstanceType.M5DN_METAL
M5N_LARGE = InstanceType.M5N_LARGE
M5N_XLARGE = InstanceType.M5N_XLARGE
M5N_2XLARGE = InstanceType.M5N_2XLARGE
M5N_4XLARGE = InstanceType.M5N_4XLARGE
M5N_8XLARGE = InstanceType.M5N_8XLARGE
M5N_12XLARGE = InstanceType.M5N_12XLARGE
M5N_16XLARGE = InstanceType.M5N_16XLARGE
M5N_24XLARGE = InstanceType.M5N_24XLARGE
M5N_METAL = InstanceType.M5N_METAL
M5ZN_LARGE = InstanceType.M5ZN_LARGE
M5ZN_XLARGE = InstanceType.M5ZN_XLARGE
M5ZN_2XLARGE = InstanceType.M5ZN_2XLARGE
M5ZN_3XLARGE = InstanceType.M5ZN_3XLARGE
M5ZN_6XLARGE = InstanceType.M5ZN_6XLARGE
M5ZN_12XLARGE = InstanceType.M5ZN_12XLARGE
M5ZN_METAL = InstanceType.M5ZN_METAL
M6A_LARGE = InstanceType.M6A_LARGE
M6A_XLARGE = InstanceType.M6A_XLARGE
M6A_2XLARGE = InstanceType.M6A_2XLARGE
M6A_4XLARGE = InstanceType.M6A_4XLARGE
M6A_8XLARGE = InstanceType.M6A_8XLARGE
M6A_12XLARGE = InstanceType.M6A_12XLARGE
M6A_16XLARGE = InstanceType.M6A_16XLARGE
M6A_24XLARGE = InstanceType.M6A_24XLARGE
M6A_32XLARGE = InstanceType.M6A_32XLARGE
M6A_48XLARGE = InstanceType.M6A_48XLARGE
M6G_METAL = InstanceType.M6G_METAL
M6G_MEDIUM = InstanceType.M6G_MEDIUM
M6G_LARGE = InstanceType.M6G_LARGE
M6G_XLARGE = InstanceType.M6G_XLARGE
M6G_2XLARGE = InstanceType.M6G_2XLARGE
M6G_4XLARGE = InstanceType.M6G_4XLARGE
M6G_8XLARGE = InstanceType.M6G_8XLARGE
M6G_12XLARGE = InstanceType.M6G_12XLARGE
M6G_16XLARGE = InstanceType.M6G_16XLARGE
M6GD_METAL = InstanceType.M6GD_METAL
M6GD_MEDIUM = InstanceType.M6GD_MEDIUM
M6GD_LARGE = InstanceType.M6GD_LARGE
M6GD_XLARGE = InstanceType.M6GD_XLARGE
M6GD_2XLARGE = InstanceType.M6GD_2XLARGE
M6GD_4XLARGE = InstanceType.M6GD_4XLARGE
M6GD_8XLARGE = InstanceType.M6GD_8XLARGE
M6GD_12XLARGE = InstanceType.M6GD_12XLARGE
M6GD_16XLARGE = InstanceType.M6GD_16XLARGE
M6I_LARGE = InstanceType.M6I_LARGE
M6I_XLARGE = InstanceType.M6I_XLARGE
M6I_2XLARGE = InstanceType.M6I_2XLARGE
M6I_4XLARGE = InstanceType.M6I_4XLARGE
M6I_8XLARGE = InstanceType.M6I_8XLARGE
M6I_12XLARGE = InstanceType.M6I_12XLARGE
M6I_16XLARGE = InstanceType.M6I_16XLARGE
M6I_24XLARGE = InstanceType.M6I_24XLARGE
M6I_32XLARGE = InstanceType.M6I_32XLARGE
M6I_METAL = InstanceType.M6I_METAL
MAC1_METAL = InstanceType.MAC1_METAL
P2_XLARGE = InstanceType.P2_XLARGE
P2_8XLARGE = InstanceType.P2_8XLARGE
P2_16XLARGE = InstanceType.P2_16XLARGE
P3_2XLARGE = InstanceType.P3_2XLARGE
P3_8XLARGE = InstanceType.P3_8XLARGE
P3_16XLARGE = InstanceType.P3_16XLARGE
P3DN_24XLARGE = InstanceType.P3DN_24XLARGE
P4D_24XLARGE = InstanceType.P4D_24XLARGE
R3_LARGE = InstanceType.R3_LARGE
R3_XLARGE = InstanceType.R3_XLARGE
R3_2XLARGE = InstanceType.R3_2XLARGE
R3_4XLARGE = InstanceType.R3_4XLARGE
R3_8XLARGE = InstanceType.R3_8XLARGE
R4_LARGE = InstanceType.R4_LARGE
R4_XLARGE = InstanceType.R4_XLARGE
R4_2XLARGE = InstanceType.R4_2XLARGE
R4_4XLARGE = InstanceType.R4_4XLARGE
R4_8XLARGE = InstanceType.R4_8XLARGE
R4_16XLARGE = InstanceType.R4_16XLARGE
R5_LARGE = InstanceType.R5_LARGE
R5_XLARGE = InstanceType.R5_XLARGE
R5_2XLARGE = InstanceType.R5_2XLARGE
R5_4XLARGE = InstanceType.R5_4XLARGE
R5_8XLARGE = InstanceType.R5_8XLARGE
R5_12XLARGE = InstanceType.R5_12XLARGE
R5_16XLARGE = InstanceType.R5_16XLARGE
R5_24XLARGE = InstanceType.R5_24XLARGE
R5_METAL = InstanceType.R5_METAL
R5A_LARGE = InstanceType.R5A_LARGE
R5A_XLARGE = InstanceType.R5A_XLARGE
R5A_2XLARGE = InstanceType.R5A_2XLARGE
R5A_4XLARGE = InstanceType.R5A_4XLARGE
R5A_8XLARGE = InstanceType.R5A_8XLARGE
R5A_12XLARGE = InstanceType.R5A_12XLARGE
R5A_16XLARGE = InstanceType.R5A_16XLARGE
R5A_24XLARGE = InstanceType.R5A_24XLARGE
R5AD_LARGE = InstanceType.R5AD_LARGE
R5AD_XLARGE = InstanceType.R5AD_XLARGE
R5AD_2XLARGE = InstanceType.R5AD_2XLARGE
R5AD_4XLARGE = InstanceType.R5AD_4XLARGE
R5AD_8XLARGE = InstanceType.R5AD_8XLARGE
R5AD_12XLARGE = InstanceType.R5AD_12XLARGE
R5AD_16XLARGE = InstanceType.R5AD_16XLARGE
R5AD_24XLARGE = InstanceType.R5AD_24XLARGE
R5B_LARGE = InstanceType.R5B_LARGE
R5B_XLARGE = InstanceType.R5B_XLARGE
R5B_2XLARGE = InstanceType.R5B_2XLARGE
R5B_4XLARGE = InstanceType.R5B_4XLARGE
R5B_8XLARGE = InstanceType.R5B_8XLARGE
R5B_12XLARGE = InstanceType.R5B_12XLARGE
R5B_16XLARGE = InstanceType.R5B_16XLARGE
R5B_24XLARGE = InstanceType.R5B_24XLARGE
R5B_METAL = InstanceType.R5B_METAL
R5D_LARGE = InstanceType.R5D_LARGE
R5D_XLARGE = InstanceType.R5D_XLARGE
R5D_2XLARGE = InstanceType.R5D_2XLARGE
R5D_4XLARGE = InstanceType.R5D_4XLARGE
R5D_8XLARGE = InstanceType.R5D_8XLARGE
R5D_12XLARGE = InstanceType.R5D_12XLARGE
R5D_16XLARGE = InstanceType.R5D_16XLARGE
R5D_24XLARGE = InstanceType.R5D_24XLARGE
R5D_METAL = InstanceType.R5D_METAL
R5DN_LARGE = InstanceType.R5DN_LARGE
R5DN_XLARGE = InstanceType.R5DN_XLARGE
R5DN_2XLARGE = InstanceType.R5DN_2XLARGE
R5DN_4XLARGE = InstanceType.R5DN_4XLARGE
R5DN_8XLARGE = InstanceType.R5DN_8XLARGE
R5DN_12XLARGE = InstanceType.R5DN_12XLARGE
R5DN_16XLARGE = InstanceType.R5DN_16XLARGE
R5DN_24XLARGE = InstanceType.R5DN_24XLARGE
R5DN_METAL = InstanceType.R5DN_METAL
R5N_LARGE = InstanceType.R5N_LARGE
R5N_XLARGE = InstanceType.R5N_XLARGE
R5N_2XLARGE = InstanceType.R5N_2XLARGE
R5N_4XLARGE = InstanceType.R5N_4XLARGE
R5N_8XLARGE = InstanceType.R5N_8XLARGE
R5N_12XLARGE = InstanceType.R5N_12XLARGE
R5N_16XLARGE = InstanceType.R5N_16XLARGE
R5N_24XLARGE = InstanceType.R5N_24XLARGE
R5N_METAL = InstanceType.R5N_METAL
R6G_MEDIUM = InstanceType.R6G_MEDIUM
R6G_LARGE = InstanceType.R6G_LARGE
R6G_XLARGE = InstanceType.R6G_XLARGE
R6G_2XLARGE = InstanceType.R6G_2XLARGE
R6G_4XLARGE = InstanceType.R6G_4XLARGE
R6G_8XLARGE = InstanceType.R6G_8XLARGE
R6G_12XLARGE = InstanceType.R6G_12XLARGE
R6G_16XLARGE = InstanceType.R6G_16XLARGE
R6G_METAL = InstanceType.R6G_METAL
R6GD_MEDIUM = InstanceType.R6GD_MEDIUM
R6GD_LARGE = InstanceType.R6GD_LARGE
R6GD_XLARGE = InstanceType.R6GD_XLARGE
R6GD_2XLARGE = InstanceType.R6GD_2XLARGE
R6GD_4XLARGE = InstanceType.R6GD_4XLARGE
R6GD_8XLARGE = InstanceType.R6GD_8XLARGE
R6GD_12XLARGE = InstanceType.R6GD_12XLARGE
R6GD_16XLARGE = InstanceType.R6GD_16XLARGE
R6GD_METAL = InstanceType.R6GD_METAL
R6I_LARGE = InstanceType.R6I_LARGE
R6I_XLARGE = InstanceType.R6I_XLARGE
R6I_2XLARGE = InstanceType.R6I_2XLARGE
R6I_4XLARGE = InstanceType.R6I_4XLARGE
R6I_8XLARGE = InstanceType.R6I_8XLARGE
R6I_12XLARGE = InstanceType.R6I_12XLARGE
R6I_16XLARGE = InstanceType.R6I_16XLARGE
R6I_24XLARGE = InstanceType.R6I_24XLARGE
R6I_32XLARGE = InstanceType.R6I_32XLARGE
R6I_METAL = InstanceType.R6I_METAL
T1_MICRO = InstanceType.T1_MICRO
T2_NANO = InstanceType.T2_NANO
T2_MICRO = InstanceType.T2_MICRO
T2_SMALL = InstanceType.T2_SMALL
T2_MEDIUM = InstanceType.T2_MEDIUM
T2_LARGE = InstanceType.T2_LARGE
T2_XLARGE = InstanceType.T2_XLARGE
T2_2XLARGE = InstanceType.T2_2XLARGE
T3_NANO = InstanceType.T3_NANO
T3_MICRO = InstanceType.T3_MICRO
T3_SMALL = InstanceType.T3_SMALL
T3_MEDIUM = InstanceType.T3_MEDIUM
T3_LARGE = InstanceType.T3_LARGE
T3_XLARGE = InstanceType.T3_XLARGE
T3_2XLARGE = InstanceType.T3_2XLARGE
T3A_NANO = InstanceType.T3A_NANO
T3A_MICRO = InstanceType.T3A_MICRO
T3A_SMALL = InstanceType.T3A_SMALL
T3A_MEDIUM = InstanceType.T3A_MEDIUM
T3A_LARGE = InstanceType.T3A_LARGE
T3A_XLARGE = InstanceType.T3A_XLARGE
T3A_2XLARGE = InstanceType.T3A_2XLARGE
T4G_NANO = InstanceType.T4G_NANO
T4G_MICRO = InstanceType.T4G_MICRO
T4G_SMALL = InstanceType.T4G_SMALL
T4G_MEDIUM = InstanceType.T4G_MEDIUM
T4G_LARGE = InstanceType.T4G_LARGE
T4G_XLARGE = InstanceType.T4G_XLARGE
T4G_2XLARGE = InstanceType.T4G_2XLARGE
U_6TB1_56XLARGE = InstanceType.U_6TB1_56XLARGE
U_6TB1_112XLARGE = InstanceType.U_6TB1_112XLARGE
U_9TB1_112XLARGE = InstanceType.U_9TB1_112XLARGE
U_12TB1_112XLARGE = InstanceType.U_12TB1_112XLARGE
U_6TB1_METAL = InstanceType.U_6TB1_METAL
U_9TB1_METAL = InstanceType.U_9TB1_METAL
U_12TB1_METAL = InstanceType.U_12TB1_METAL
U_18TB1_METAL = InstanceType.U_18TB1_METAL
U_24TB1_METAL = InstanceType.U_24TB1_METAL
VT1_3XLARGE = InstanceType.VT1_3XLARGE
VT1_6XLARGE = InstanceType.VT1_6XLARGE
VT1_24XLARGE = InstanceType.VT1_24XLARGE
X1_16XLARGE = InstanceType.X1_16XLARGE
X1_32XLARGE = InstanceType.X1_32XLARGE
X1E_XLARGE = InstanceType.X1E_XLARGE
X1E_2XLARGE = InstanceType.X1E_2XLARGE
X1E_4XLARGE = InstanceType.X1E_4XLARGE
X1E_8XLARGE = InstanceType.X1E_8XLARGE
X1E_16XLARGE = InstanceType.X1E_16XLARGE
X1E_32XLARGE = InstanceType.X1E_32XLARGE
X2IEZN_2XLARGE = InstanceType.X2IEZN_2XLARGE
X2IEZN_4XLARGE = InstanceType.X2IEZN_4XLARGE
X2IEZN_6XLARGE = InstanceType.X2IEZN_6XLARGE
X2IEZN_8XLARGE = InstanceType.X2IEZN_8XLARGE
X2IEZN_12XLARGE = InstanceType.X2IEZN_12XLARGE
X2IEZN_METAL = InstanceType.X2IEZN_METAL
X2GD_MEDIUM = InstanceType.X2GD_MEDIUM
X2GD_LARGE = InstanceType.X2GD_LARGE
X2GD_XLARGE = InstanceType.X2GD_XLARGE
X2GD_2XLARGE = InstanceType.X2GD_2XLARGE
X2GD_4XLARGE = InstanceType.X2GD_4XLARGE
X2GD_8XLARGE = InstanceType.X2GD_8XLARGE
X2GD_12XLARGE = InstanceType.X2GD_12XLARGE
X2GD_16XLARGE = InstanceType.X2GD_16XLARGE
X2GD_METAL = InstanceType.X2GD_METAL
Z1D_LARGE = InstanceType.Z1D_LARGE
Z1D_XLARGE = InstanceType.Z1D_XLARGE
Z1D_2XLARGE = InstanceType.Z1D_2XLARGE
Z1D_3XLARGE = InstanceType.Z1D_3XLARGE
Z1D_6XLARGE = InstanceType.Z1D_6XLARGE
Z1D_12XLARGE = InstanceType.Z1D_12XLARGE
Z1D_METAL = InstanceType.Z1D_METAL
X2IDN_16XLARGE = InstanceType.X2IDN_16XLARGE
X2IDN_24XLARGE = InstanceType.X2IDN_24XLARGE
X2IDN_32XLARGE = InstanceType.X2IDN_32XLARGE
X2IEDN_XLARGE = InstanceType.X2IEDN_XLARGE
X2IEDN_2XLARGE = InstanceType.X2IEDN_2XLARGE
X2IEDN_4XLARGE = InstanceType.X2IEDN_4XLARGE
X2IEDN_8XLARGE = InstanceType.X2IEDN_8XLARGE
X2IEDN_16XLARGE = InstanceType.X2IEDN_16XLARGE
X2IEDN_24XLARGE = InstanceType.X2IEDN_24XLARGE
X2IEDN_32XLARGE = InstanceType.X2IEDN_32XLARGE
C6A_LARGE = InstanceType.C6A_LARGE
C6A_XLARGE = InstanceType.C6A_XLARGE
C6A_2XLARGE = InstanceType.C6A_2XLARGE
C6A_4XLARGE = InstanceType.C6A_4XLARGE
C6A_8XLARGE = InstanceType.C6A_8XLARGE
C6A_12XLARGE = InstanceType.C6A_12XLARGE
C6A_16XLARGE = InstanceType.C6A_16XLARGE
C6A_24XLARGE = InstanceType.C6A_24XLARGE
C6A_32XLARGE = InstanceType.C6A_32XLARGE
C6A_48XLARGE = InstanceType.C6A_48XLARGE
C6A_METAL = InstanceType.C6A_METAL
M6A_METAL = InstanceType.M6A_METAL
I4I_LARGE = InstanceType.I4I_LARGE
I4I_XLARGE = InstanceType.I4I_XLARGE
I4I_2XLARGE = InstanceType.I4I_2XLARGE
I4I_4XLARGE = InstanceType.I4I_4XLARGE
I4I_8XLARGE = InstanceType.I4I_8XLARGE
I4I_16XLARGE = InstanceType.I4I_16XLARGE
I4I_32XLARGE = InstanceType.I4I_32XLARGE
I4I_METAL = InstanceType.I4I_METAL
X2IDN_METAL = InstanceType.X2IDN_METAL
X2IEDN_METAL = InstanceType.X2IEDN_METAL
C7G_MEDIUM = InstanceType.C7G_MEDIUM
C7G_LARGE = InstanceType.C7G_LARGE
C7G_XLARGE = InstanceType.C7G_XLARGE
C7G_2XLARGE = InstanceType.C7G_2XLARGE
C7G_4XLARGE = InstanceType.C7G_4XLARGE
C7G_8XLARGE = InstanceType.C7G_8XLARGE
C7G_12XLARGE = InstanceType.C7G_12XLARGE
C7G_16XLARGE = InstanceType.C7G_16XLARGE
MAC2_METAL = InstanceType.MAC2_METAL
C6ID_LARGE = InstanceType.C6ID_LARGE
C6ID_XLARGE = InstanceType.C6ID_XLARGE
C6ID_2XLARGE = InstanceType.C6ID_2XLARGE
C6ID_4XLARGE = InstanceType.C6ID_4XLARGE
C6ID_8XLARGE = InstanceType.C6ID_8XLARGE
C6ID_12XLARGE = InstanceType.C6ID_12XLARGE
C6ID_16XLARGE = InstanceType.C6ID_16XLARGE
C6ID_24XLARGE = InstanceType.C6ID_24XLARGE
C6ID_32XLARGE = InstanceType.C6ID_32XLARGE
C6ID_METAL = InstanceType.C6ID_METAL
M6ID_LARGE = InstanceType.M6ID_LARGE
M6ID_XLARGE = InstanceType.M6ID_XLARGE
M6ID_2XLARGE = InstanceType.M6ID_2XLARGE
M6ID_4XLARGE = InstanceType.M6ID_4XLARGE
M6ID_8XLARGE = InstanceType.M6ID_8XLARGE
M6ID_12XLARGE = InstanceType.M6ID_12XLARGE
M6ID_16XLARGE = InstanceType.M6ID_16XLARGE
M6ID_24XLARGE = InstanceType.M6ID_24XLARGE
M6ID_32XLARGE = InstanceType.M6ID_32XLARGE
M6ID_METAL = InstanceType.M6ID_METAL
R6ID_LARGE = InstanceType.R6ID_LARGE
R6ID_XLARGE = InstanceType.R6ID_XLARGE
R6ID_2XLARGE = InstanceType.R6ID_2XLARGE
R6ID_4XLARGE = InstanceType.R6ID_4XLARGE
R6ID_8XLARGE = InstanceType.R6ID_8XLARGE
R6ID_12XLARGE = InstanceType.R6ID_12XLARGE
R6ID_16XLARGE = InstanceType.R6ID_16XLARGE
R6ID_24XLARGE = InstanceType.R6ID_24XLARGE
R6ID_32XLARGE = InstanceType.R6ID_32XLARGE
R6ID_METAL = InstanceType.R6ID_METAL
R6A_LARGE = InstanceType.R6A_LARGE
R6A_XLARGE = InstanceType.R6A_XLARGE
R6A_2XLARGE = InstanceType.R6A_2XLARGE
R6A_4XLARGE = InstanceType.R6A_4XLARGE
R6A_8XLARGE = InstanceType.R6A_8XLARGE
R6A_12XLARGE = InstanceType.R6A_12XLARGE
R6A_16XLARGE = InstanceType.R6A_16XLARGE
R6A_24XLARGE = InstanceType.R6A_24XLARGE
R6A_32XLARGE = InstanceType.R6A_32XLARGE
R6A_48XLARGE = InstanceType.R6A_48XLARGE
R6A_METAL = InstanceType.R6A_METAL
P4DE_24XLARGE = InstanceType.P4DE_24XLARGE
U_3TB1_56XLARGE = InstanceType.U_3TB1_56XLARGE
U_18TB1_112XLARGE = InstanceType.U_18TB1_112XLARGE
U_24TB1_112XLARGE = InstanceType.U_24TB1_112XLARGE
TRN1_2XLARGE = InstanceType.TRN1_2XLARGE
TRN1_32XLARGE = InstanceType.TRN1_32XLARGE
HPC6ID_32XLARGE = InstanceType.HPC6ID_32XLARGE
C6IN_LARGE = InstanceType.C6IN_LARGE
C6IN_XLARGE = InstanceType.C6IN_XLARGE
C6IN_2XLARGE = InstanceType.C6IN_2XLARGE
C6IN_4XLARGE = InstanceType.C6IN_4XLARGE
C6IN_8XLARGE = InstanceType.C6IN_8XLARGE
C6IN_12XLARGE = InstanceType.C6IN_12XLARGE
C6IN_16XLARGE = InstanceType.C6IN_16XLARGE
C6IN_24XLARGE = InstanceType.C6IN_24XLARGE
C6IN_32XLARGE = InstanceType.C6IN_32XLARGE
M6IN_LARGE = InstanceType.M6IN_LARGE
M6IN_XLARGE = InstanceType.M6IN_XLARGE
M6IN_2XLARGE = InstanceType.M6IN_2XLARGE
M6IN_4XLARGE = InstanceType.M6IN_4XLARGE
M6IN_8XLARGE = InstanceType.M6IN_8XLARGE
M6IN_12XLARGE = InstanceType.M6IN_12XLARGE
M6IN_16XLARGE = InstanceType.M6IN_16XLARGE
M6IN_24XLARGE = InstanceType.M6IN_24XLARGE
M6IN_32XLARGE = InstanceType.M6IN_32XLARGE
M6IDN_LARGE = InstanceType.M6IDN_LARGE
M6IDN_XLARGE = InstanceType.M6IDN_XLARGE
M6IDN_2XLARGE = InstanceType.M6IDN_2XLARGE
M6IDN_4XLARGE = InstanceType.M6IDN_4XLARGE
M6IDN_8XLARGE = InstanceType.M6IDN_8XLARGE
M6IDN_12XLARGE = InstanceType.M6IDN_12XLARGE
M6IDN_16XLARGE = InstanceType.M6IDN_16XLARGE
M6IDN_24XLARGE = InstanceType.M6IDN_24XLARGE
M6IDN_32XLARGE = InstanceType.M6IDN_32XLARGE
R6IN_LARGE = InstanceType.R6IN_LARGE
R6IN_XLARGE = InstanceType.R6IN_XLARGE
R6IN_2XLARGE = InstanceType.R6IN_2XLARGE
R6IN_4XLARGE = InstanceType.R6IN_4XLARGE
R6IN_8XLARGE = InstanceType.R6IN_8XLARGE
R6IN_12XLARGE = InstanceType.R6IN_12XLARGE
R6IN_16XLARGE = InstanceType.R6IN_16XLARGE
R6IN_24XLARGE = InstanceType.R6IN_24XLARGE
R6IN_32XLARGE = InstanceType.R6IN_32XLARGE
R6IDN_LARGE = InstanceType.R6IDN_LARGE
R6IDN_XLARGE = InstanceType.R6IDN_XLARGE
R6IDN_2XLARGE = InstanceType.R6IDN_2XLARGE
R6IDN_4XLARGE = InstanceType.R6IDN_4XLARGE
R6IDN_8XLARGE = InstanceType.R6IDN_8XLARGE
R6IDN_12XLARGE = InstanceType.R6IDN_12XLARGE
R6IDN_16XLARGE = InstanceType.R6IDN_16XLARGE
R6IDN_24XLARGE = InstanceType.R6IDN_24XLARGE
R6IDN_32XLARGE = InstanceType.R6IDN_32XLARGE
C7G_METAL = InstanceType.C7G_METAL
M7G_MEDIUM = InstanceType.M7G_MEDIUM
M7G_LARGE = InstanceType.M7G_LARGE
M7G_XLARGE = InstanceType.M7G_XLARGE
M7G_2XLARGE = InstanceType.M7G_2XLARGE
M7G_4XLARGE = InstanceType.M7G_4XLARGE
M7G_8XLARGE = InstanceType.M7G_8XLARGE
M7G_12XLARGE = InstanceType.M7G_12XLARGE
M7G_16XLARGE = InstanceType.M7G_16XLARGE
M7G_METAL = InstanceType.M7G_METAL
R7G_MEDIUM = InstanceType.R7G_MEDIUM
R7G_LARGE = InstanceType.R7G_LARGE
R7G_XLARGE = InstanceType.R7G_XLARGE
R7G_2XLARGE = InstanceType.R7G_2XLARGE
R7G_4XLARGE = InstanceType.R7G_4XLARGE
R7G_8XLARGE = InstanceType.R7G_8XLARGE
R7G_12XLARGE = InstanceType.R7G_12XLARGE
R7G_16XLARGE = InstanceType.R7G_16XLARGE
R7G_METAL = InstanceType.R7G_METAL
C6IN_METAL = InstanceType.C6IN_METAL
M6IN_METAL = InstanceType.M6IN_METAL
M6IDN_METAL = InstanceType.M6IDN_METAL
R6IN_METAL = InstanceType.R6IN_METAL
R6IDN_METAL = InstanceType.R6IDN_METAL
INF2_XLARGE = InstanceType.INF2_XLARGE
INF2_8XLARGE = InstanceType.INF2_8XLARGE
INF2_24XLARGE = InstanceType.INF2_24XLARGE
INF2_48XLARGE = InstanceType.INF2_48XLARGE
TRN1N_32XLARGE = InstanceType.TRN1N_32XLARGE
I4G_LARGE = InstanceType.I4G_LARGE
I4G_XLARGE = InstanceType.I4G_XLARGE
I4G_2XLARGE = InstanceType.I4G_2XLARGE
I4G_4XLARGE = InstanceType.I4G_4XLARGE
I4G_8XLARGE = InstanceType.I4G_8XLARGE
I4G_16XLARGE = InstanceType.I4G_16XLARGE
HPC7G_4XLARGE = InstanceType.HPC7G_4XLARGE
HPC7G_8XLARGE = InstanceType.HPC7G_8XLARGE
HPC7G_16XLARGE = InstanceType.HPC7G_16XLARGE
C7GN_MEDIUM = InstanceType.C7GN_MEDIUM
C7GN_LARGE = InstanceType.C7GN_LARGE
C7GN_XLARGE = InstanceType.C7GN_XLARGE
C7GN_2XLARGE = InstanceType.C7GN_2XLARGE
C7GN_4XLARGE = InstanceType.C7GN_4XLARGE
C7GN_8XLARGE = InstanceType.C7GN_8XLARGE
C7GN_12XLARGE = InstanceType.C7GN_12XLARGE
C7GN_16XLARGE = InstanceType.C7GN_16XLARGE
P5_48XLARGE = InstanceType.P5_48XLARGE
M7I_LARGE = InstanceType.M7I_LARGE
M7I_XLARGE = InstanceType.M7I_XLARGE
M7I_2XLARGE = InstanceType.M7I_2XLARGE
M7I_4XLARGE = InstanceType.M7I_4XLARGE
M7I_8XLARGE = InstanceType.M7I_8XLARGE
M7I_12XLARGE = InstanceType.M7I_12XLARGE
M7I_16XLARGE = InstanceType.M7I_16XLARGE
M7I_24XLARGE = InstanceType.M7I_24XLARGE
M7I_48XLARGE = InstanceType.M7I_48XLARGE
M7I_FLEX_LARGE = InstanceType.M7I_FLEX_LARGE
M7I_FLEX_XLARGE = InstanceType.M7I_FLEX_XLARGE
M7I_FLEX_2XLARGE = InstanceType.M7I_FLEX_2XLARGE
M7I_FLEX_4XLARGE = InstanceType.M7I_FLEX_4XLARGE
M7I_FLEX_8XLARGE = InstanceType.M7I_FLEX_8XLARGE
M7A_MEDIUM = InstanceType.M7A_MEDIUM
M7A_LARGE = InstanceType.M7A_LARGE
M7A_XLARGE = InstanceType.M7A_XLARGE
M7A_2XLARGE = InstanceType.M7A_2XLARGE
M7A_4XLARGE = InstanceType.M7A_4XLARGE
M7A_8XLARGE = InstanceType.M7A_8XLARGE
M7A_12XLARGE = InstanceType.M7A_12XLARGE
M7A_16XLARGE = InstanceType.M7A_16XLARGE
M7A_24XLARGE = InstanceType.M7A_24XLARGE
M7A_32XLARGE = InstanceType.M7A_32XLARGE
M7A_48XLARGE = InstanceType.M7A_48XLARGE
M7A_METAL_48XL = InstanceType.M7A_METAL_48XL
HPC7A_12XLARGE = InstanceType.HPC7A_12XLARGE
HPC7A_24XLARGE = InstanceType.HPC7A_24XLARGE
HPC7A_48XLARGE = InstanceType.HPC7A_48XLARGE
HPC7A_96XLARGE = InstanceType.HPC7A_96XLARGE
C7GD_MEDIUM = InstanceType.C7GD_MEDIUM
C7GD_LARGE = InstanceType.C7GD_LARGE
C7GD_XLARGE = InstanceType.C7GD_XLARGE
C7GD_2XLARGE = InstanceType.C7GD_2XLARGE
C7GD_4XLARGE = InstanceType.C7GD_4XLARGE
C7GD_8XLARGE = InstanceType.C7GD_8XLARGE
C7GD_12XLARGE = InstanceType.C7GD_12XLARGE
C7GD_16XLARGE = InstanceType.C7GD_16XLARGE
M7GD_MEDIUM = InstanceType.M7GD_MEDIUM
M7GD_LARGE = InstanceType.M7GD_LARGE
M7GD_XLARGE = InstanceType.M7GD_XLARGE
M7GD_2XLARGE = InstanceType.M7GD_2XLARGE
M7GD_4XLARGE = InstanceType.M7GD_4XLARGE
M7GD_8XLARGE = InstanceType.M7GD_8XLARGE
M7GD_12XLARGE = InstanceType.M7GD_12XLARGE
M7GD_16XLARGE = InstanceType.M7GD_16XLARGE
R7GD_MEDIUM = InstanceType.R7GD_MEDIUM
R7GD_LARGE = InstanceType.R7GD_LARGE
R7GD_XLARGE = InstanceType.R7GD_XLARGE
R7GD_2XLARGE = InstanceType.R7GD_2XLARGE
R7GD_4XLARGE = InstanceType.R7GD_4XLARGE
R7GD_8XLARGE = InstanceType.R7GD_8XLARGE
R7GD_12XLARGE = InstanceType.R7GD_12XLARGE
R7GD_16XLARGE = InstanceType.R7GD_16XLARGE
R7A_MEDIUM = InstanceType.R7A_MEDIUM
R7A_LARGE = InstanceType.R7A_LARGE
R7A_XLARGE = InstanceType.R7A_XLARGE
R7A_2XLARGE = InstanceType.R7A_2XLARGE
R7A_4XLARGE = InstanceType.R7A_4XLARGE
R7A_8XLARGE = InstanceType.R7A_8XLARGE
R7A_12XLARGE = InstanceType.R7A_12XLARGE
R7A_16XLARGE = InstanceType.R7A_16XLARGE
R7A_24XLARGE = InstanceType.R7A_24XLARGE
R7A_32XLARGE = InstanceType.R7A_32XLARGE
R7A_48XLARGE = InstanceType.R7A_48XLARGE
C7I_LARGE = InstanceType.C7I_LARGE
C7I_XLARGE = InstanceType.C7I_XLARGE
C7I_2XLARGE = InstanceType.C7I_2XLARGE
C7I_4XLARGE = InstanceType.C7I_4XLARGE
C7I_8XLARGE = InstanceType.C7I_8XLARGE
C7I_12XLARGE = InstanceType.C7I_12XLARGE
C7I_16XLARGE = InstanceType.C7I_16XLARGE
C7I_24XLARGE = InstanceType.C7I_24XLARGE
C7I_48XLARGE = InstanceType.C7I_48XLARGE
MAC2_M2PRO_METAL = InstanceType.MAC2_M2PRO_METAL
R7IZ_LARGE = InstanceType.R7IZ_LARGE
R7IZ_XLARGE = InstanceType.R7IZ_XLARGE
R7IZ_2XLARGE = InstanceType.R7IZ_2XLARGE
R7IZ_4XLARGE = InstanceType.R7IZ_4XLARGE
R7IZ_8XLARGE = InstanceType.R7IZ_8XLARGE
R7IZ_12XLARGE = InstanceType.R7IZ_12XLARGE
R7IZ_16XLARGE = InstanceType.R7IZ_16XLARGE
R7IZ_32XLARGE = InstanceType.R7IZ_32XLARGE
C7A_MEDIUM = InstanceType.C7A_MEDIUM
C7A_LARGE = InstanceType.C7A_LARGE
C7A_XLARGE = InstanceType.C7A_XLARGE
C7A_2XLARGE = InstanceType.C7A_2XLARGE
C7A_4XLARGE = InstanceType.C7A_4XLARGE
C7A_8XLARGE = InstanceType.C7A_8XLARGE
C7A_12XLARGE = InstanceType.C7A_12XLARGE
C7A_16XLARGE = InstanceType.C7A_16XLARGE
C7A_24XLARGE = InstanceType.C7A_24XLARGE
C7A_32XLARGE = InstanceType.C7A_32XLARGE
C7A_48XLARGE = InstanceType.C7A_48XLARGE
C7A_METAL_48XL = InstanceType.C7A_METAL_48XL
R7A_METAL_48XL = InstanceType.R7A_METAL_48XL
R7I_LARGE = InstanceType.R7I_LARGE
R7I_XLARGE = InstanceType.R7I_XLARGE
R7I_2XLARGE = InstanceType.R7I_2XLARGE
R7I_4XLARGE = InstanceType.R7I_4XLARGE
R7I_8XLARGE = InstanceType.R7I_8XLARGE
R7I_12XLARGE = InstanceType.R7I_12XLARGE
R7I_16XLARGE = InstanceType.R7I_16XLARGE
R7I_24XLARGE = InstanceType.R7I_24XLARGE
R7I_48XLARGE = InstanceType.R7I_48XLARGE
DL2Q_24XLARGE = InstanceType.DL2Q_24XLARGE
MAC2_M2_METAL = InstanceType.MAC2_M2_METAL
I4I_12XLARGE = InstanceType.I4I_12XLARGE
I4I_24XLARGE = InstanceType.I4I_24XLARGE
C7I_METAL_24XL = InstanceType.C7I_METAL_24XL
C7I_METAL_48XL = InstanceType.C7I_METAL_48XL
M7I_METAL_24XL = InstanceType.M7I_METAL_24XL
M7I_METAL_48XL = InstanceType.M7I_METAL_48XL
R7I_METAL_24XL = InstanceType.R7I_METAL_24XL
R7I_METAL_48XL = InstanceType.R7I_METAL_48XL
R7IZ_METAL_16XL = InstanceType.R7IZ_METAL_16XL
R7IZ_METAL_32XL = InstanceType.R7IZ_METAL_32XL
C7GD_METAL = InstanceType.C7GD_METAL
M7GD_METAL = InstanceType.M7GD_METAL
R7GD_METAL = InstanceType.R7GD_METAL
G6_XLARGE = InstanceType.G6_XLARGE
G6_2XLARGE = InstanceType.G6_2XLARGE
G6_4XLARGE = InstanceType.G6_4XLARGE
G6_8XLARGE = InstanceType.G6_8XLARGE
G6_12XLARGE = InstanceType.G6_12XLARGE
G6_16XLARGE = InstanceType.G6_16XLARGE
G6_24XLARGE = InstanceType.G6_24XLARGE
G6_48XLARGE = InstanceType.G6_48XLARGE
GR6_4XLARGE = InstanceType.GR6_4XLARGE
GR6_8XLARGE = InstanceType.GR6_8XLARGE
C7I_FLEX_LARGE = InstanceType.C7I_FLEX_LARGE
C7I_FLEX_XLARGE = InstanceType.C7I_FLEX_XLARGE
C7I_FLEX_2XLARGE = InstanceType.C7I_FLEX_2XLARGE
C7I_FLEX_4XLARGE = InstanceType.C7I_FLEX_4XLARGE
C7I_FLEX_8XLARGE = InstanceType.C7I_FLEX_8XLARGE
U7I_12TB_224XLARGE = InstanceType.U7I_12TB_224XLARGE
U7IN_16TB_224XLARGE = InstanceType.U7IN_16TB_224XLARGE
U7IN_24TB_224XLARGE = InstanceType.U7IN_24TB_224XLARGE
U7IN_32TB_224XLARGE = InstanceType.U7IN_32TB_224XLARGE
U7IB_12TB_224XLARGE = InstanceType.U7IB_12TB_224XLARGE
C7GN_METAL = InstanceType.C7GN_METAL
R8G_MEDIUM = InstanceType.R8G_MEDIUM
R8G_LARGE = InstanceType.R8G_LARGE
R8G_XLARGE = InstanceType.R8G_XLARGE
R8G_2XLARGE = InstanceType.R8G_2XLARGE
R8G_4XLARGE = InstanceType.R8G_4XLARGE
R8G_8XLARGE = InstanceType.R8G_8XLARGE
R8G_12XLARGE = InstanceType.R8G_12XLARGE
R8G_16XLARGE = InstanceType.R8G_16XLARGE
R8G_24XLARGE = InstanceType.R8G_24XLARGE
R8G_48XLARGE = InstanceType.R8G_48XLARGE
R8G_METAL_24XL = InstanceType.R8G_METAL_24XL
R8G_METAL_48XL = InstanceType.R8G_METAL_48XL
MAC2_M1ULTRA_METAL = InstanceType.MAC2_M1ULTRA_METAL
G6E_XLARGE = InstanceType.G6E_XLARGE
G6E_2XLARGE = InstanceType.G6E_2XLARGE
G6E_4XLARGE = InstanceType.G6E_4XLARGE
G6E_8XLARGE = InstanceType.G6E_8XLARGE
G6E_12XLARGE = InstanceType.G6E_12XLARGE
G6E_16XLARGE = InstanceType.G6E_16XLARGE
G6E_24XLARGE = InstanceType.G6E_24XLARGE
G6E_48XLARGE = InstanceType.G6E_48XLARGE
C8G_MEDIUM = InstanceType.C8G_MEDIUM
C8G_LARGE = InstanceType.C8G_LARGE
C8G_XLARGE = InstanceType.C8G_XLARGE
C8G_2XLARGE = InstanceType.C8G_2XLARGE
C8G_4XLARGE = InstanceType.C8G_4XLARGE
C8G_8XLARGE = InstanceType.C8G_8XLARGE
C8G_12XLARGE = InstanceType.C8G_12XLARGE
C8G_16XLARGE = InstanceType.C8G_16XLARGE
C8G_24XLARGE = InstanceType.C8G_24XLARGE
C8G_48XLARGE = InstanceType.C8G_48XLARGE
C8G_METAL_24XL = InstanceType.C8G_METAL_24XL
C8G_METAL_48XL = InstanceType.C8G_METAL_48XL
M8G_MEDIUM = InstanceType.M8G_MEDIUM
M8G_LARGE = InstanceType.M8G_LARGE
M8G_XLARGE = InstanceType.M8G_XLARGE
M8G_2XLARGE = InstanceType.M8G_2XLARGE
M8G_4XLARGE = InstanceType.M8G_4XLARGE
M8G_8XLARGE = InstanceType.M8G_8XLARGE
M8G_12XLARGE = InstanceType.M8G_12XLARGE
M8G_16XLARGE = InstanceType.M8G_16XLARGE
M8G_24XLARGE = InstanceType.M8G_24XLARGE
M8G_48XLARGE = InstanceType.M8G_48XLARGE
M8G_METAL_24XL = InstanceType.M8G_METAL_24XL
M8G_METAL_48XL = InstanceType.M8G_METAL_48XL
X8G_MEDIUM = InstanceType.X8G_MEDIUM
X8G_LARGE = InstanceType.X8G_LARGE
X8G_XLARGE = InstanceType.X8G_XLARGE
X8G_2XLARGE = InstanceType.X8G_2XLARGE
X8G_4XLARGE = InstanceType.X8G_4XLARGE
X8G_8XLARGE = InstanceType.X8G_8XLARGE
X8G_12XLARGE = InstanceType.X8G_12XLARGE
X8G_16XLARGE = InstanceType.X8G_16XLARGE
X8G_24XLARGE = InstanceType.X8G_24XLARGE
X8G_48XLARGE = InstanceType.X8G_48XLARGE
X8G_METAL_24XL = InstanceType.X8G_METAL_24XL
X8G_METAL_48XL = InstanceType.X8G_METAL_48XL
I7IE_LARGE = InstanceType.I7IE_LARGE
I7IE_XLARGE = InstanceType.I7IE_XLARGE
I7IE_2XLARGE = InstanceType.I7IE_2XLARGE
I7IE_3XLARGE = InstanceType.I7IE_3XLARGE
I7IE_6XLARGE = InstanceType.I7IE_6XLARGE
I7IE_12XLARGE = InstanceType.I7IE_12XLARGE
I7IE_18XLARGE = InstanceType.I7IE_18XLARGE
I7IE_24XLARGE = InstanceType.I7IE_24XLARGE
I7IE_48XLARGE = InstanceType.I7IE_48XLARGE
I8G_LARGE = InstanceType.I8G_LARGE
I8G_XLARGE = InstanceType.I8G_XLARGE
I8G_2XLARGE = InstanceType.I8G_2XLARGE
I8G_4XLARGE = InstanceType.I8G_4XLARGE
I8G_8XLARGE = InstanceType.I8G_8XLARGE
I8G_12XLARGE = InstanceType.I8G_12XLARGE
I8G_16XLARGE = InstanceType.I8G_16XLARGE
I8G_24XLARGE = InstanceType.I8G_24XLARGE
I8G_METAL_24XL = InstanceType.I8G_METAL_24XL
U7I_6TB_112XLARGE = InstanceType.U7I_6TB_112XLARGE
U7I_8TB_112XLARGE = InstanceType.U7I_8TB_112XLARGE
U7INH_32TB_480XLARGE = InstanceType.U7INH_32TB_480XLARGE
P5E_48XLARGE = InstanceType.P5E_48XLARGE
P5EN_48XLARGE = InstanceType.P5EN_48XLARGE
F2_12XLARGE = InstanceType.F2_12XLARGE
F2_48XLARGE = InstanceType.F2_48XLARGE
TRN2_48XLARGE = InstanceType.TRN2_48XLARGE
C7I_FLEX_12XLARGE = InstanceType.C7I_FLEX_12XLARGE
C7I_FLEX_16XLARGE = InstanceType.C7I_FLEX_16XLARGE
M7I_FLEX_12XLARGE = InstanceType.M7I_FLEX_12XLARGE
M7I_FLEX_16XLARGE = InstanceType.M7I_FLEX_16XLARGE
I7IE_METAL_24XL = InstanceType.I7IE_METAL_24XL
I7IE_METAL_48XL = InstanceType.I7IE_METAL_48XL
I8G_48XLARGE = InstanceType.I8G_48XLARGE
C8GD_MEDIUM = InstanceType.C8GD_MEDIUM
C8GD_LARGE = InstanceType.C8GD_LARGE
C8GD_XLARGE = InstanceType.C8GD_XLARGE
C8GD_2XLARGE = InstanceType.C8GD_2XLARGE
C8GD_4XLARGE = InstanceType.C8GD_4XLARGE
C8GD_8XLARGE = InstanceType.C8GD_8XLARGE
C8GD_12XLARGE = InstanceType.C8GD_12XLARGE
C8GD_16XLARGE = InstanceType.C8GD_16XLARGE
C8GD_24XLARGE = InstanceType.C8GD_24XLARGE
C8GD_48XLARGE = InstanceType.C8GD_48XLARGE
C8GD_METAL_24XL = InstanceType.C8GD_METAL_24XL
C8GD_METAL_48XL = InstanceType.C8GD_METAL_48XL
I7I_LARGE = InstanceType.I7I_LARGE
I7I_XLARGE = InstanceType.I7I_XLARGE
I7I_2XLARGE = InstanceType.I7I_2XLARGE
I7I_4XLARGE = InstanceType.I7I_4XLARGE
I7I_8XLARGE = InstanceType.I7I_8XLARGE
I7I_12XLARGE = InstanceType.I7I_12XLARGE
I7I_16XLARGE = InstanceType.I7I_16XLARGE
I7I_24XLARGE = InstanceType.I7I_24XLARGE
I7I_48XLARGE = InstanceType.I7I_48XLARGE
I7I_METAL_24XL = InstanceType.I7I_METAL_24XL
I7I_METAL_48XL = InstanceType.I7I_METAL_48XL
P6_B200_48XLARGE = InstanceType.P6_B200_48XLARGE
M8GD_MEDIUM = InstanceType.M8GD_MEDIUM
M8GD_LARGE = InstanceType.M8GD_LARGE
M8GD_XLARGE = InstanceType.M8GD_XLARGE
M8GD_2XLARGE = InstanceType.M8GD_2XLARGE
M8GD_4XLARGE = InstanceType.M8GD_4XLARGE
M8GD_8XLARGE = InstanceType.M8GD_8XLARGE
M8GD_12XLARGE = InstanceType.M8GD_12XLARGE
M8GD_16XLARGE = InstanceType.M8GD_16XLARGE
M8GD_24XLARGE = InstanceType.M8GD_24XLARGE
M8GD_48XLARGE = InstanceType.M8GD_48XLARGE
M8GD_METAL_24XL = InstanceType.M8GD_METAL_24XL
M8GD_METAL_48XL = InstanceType.M8GD_METAL_48XL
R8GD_MEDIUM = InstanceType.R8GD_MEDIUM
R8GD_LARGE = InstanceType.R8GD_LARGE
R8GD_XLARGE = InstanceType.R8GD_XLARGE
R8GD_2XLARGE = InstanceType.R8GD_2XLARGE
R8GD_4XLARGE = InstanceType.R8GD_4XLARGE
R8GD_8XLARGE = InstanceType.R8GD_8XLARGE
R8GD_12XLARGE = InstanceType.R8GD_12XLARGE
R8GD_16XLARGE = InstanceType.R8GD_16XLARGE
R8GD_24XLARGE = InstanceType.R8GD_24XLARGE
R8GD_48XLARGE = InstanceType.R8GD_48XLARGE
R8GD_METAL_24XL = InstanceType.R8GD_METAL_24XL
R8GD_METAL_48XL = InstanceType.R8GD_METAL_48XL
C8GN_MEDIUM = InstanceType.C8GN_MEDIUM
C8GN_LARGE = InstanceType.C8GN_LARGE
C8GN_XLARGE = InstanceType.C8GN_XLARGE
C8GN_2XLARGE = InstanceType.C8GN_2XLARGE
C8GN_4XLARGE = InstanceType.C8GN_4XLARGE
C8GN_8XLARGE = InstanceType.C8GN_8XLARGE
C8GN_12XLARGE = InstanceType.C8GN_12XLARGE
C8GN_16XLARGE = InstanceType.C8GN_16XLARGE
C8GN_24XLARGE = InstanceType.C8GN_24XLARGE
C8GN_48XLARGE = InstanceType.C8GN_48XLARGE
C8GN_METAL_24XL = InstanceType.C8GN_METAL_24XL
C8GN_METAL_48XL = InstanceType.C8GN_METAL_48XL
F2_6XLARGE = InstanceType.F2_6XLARGE
P6E_GB200_36XLARGE = InstanceType.P6E_GB200_36XLARGE
G6F_LARGE = InstanceType.G6F_LARGE
G6F_XLARGE = InstanceType.G6F_XLARGE
G6F_2XLARGE = InstanceType.G6F_2XLARGE
G6F_4XLARGE = InstanceType.G6F_4XLARGE
GR6F_4XLARGE = InstanceType.GR6F_4XLARGE
P5_4XLARGE = InstanceType.P5_4XLARGE
R8I_LARGE = InstanceType.R8I_LARGE
R8I_XLARGE = InstanceType.R8I_XLARGE
R8I_2XLARGE = InstanceType.R8I_2XLARGE
R8I_4XLARGE = InstanceType.R8I_4XLARGE
R8I_8XLARGE = InstanceType.R8I_8XLARGE
R8I_12XLARGE = InstanceType.R8I_12XLARGE
R8I_16XLARGE = InstanceType.R8I_16XLARGE
R8I_24XLARGE = InstanceType.R8I_24XLARGE
R8I_32XLARGE = InstanceType.R8I_32XLARGE
R8I_48XLARGE = InstanceType.R8I_48XLARGE
R8I_96XLARGE = InstanceType.R8I_96XLARGE
R8I_METAL_48XL = InstanceType.R8I_METAL_48XL
R8I_METAL_96XL = InstanceType.R8I_METAL_96XL
R8I_FLEX_LARGE = InstanceType.R8I_FLEX_LARGE
R8I_FLEX_XLARGE = InstanceType.R8I_FLEX_XLARGE
R8I_FLEX_2XLARGE = InstanceType.R8I_FLEX_2XLARGE
R8I_FLEX_4XLARGE = InstanceType.R8I_FLEX_4XLARGE
R8I_FLEX_8XLARGE = InstanceType.R8I_FLEX_8XLARGE
R8I_FLEX_12XLARGE = InstanceType.R8I_FLEX_12XLARGE
R8I_FLEX_16XLARGE = InstanceType.R8I_FLEX_16XLARGE
M8I_LARGE = InstanceType.M8I_LARGE
M8I_XLARGE = InstanceType.M8I_XLARGE
M8I_2XLARGE = InstanceType.M8I_2XLARGE
M8I_4XLARGE = InstanceType.M8I_4XLARGE
M8I_8XLARGE = InstanceType.M8I_8XLARGE
M8I_12XLARGE = InstanceType.M8I_12XLARGE
M8I_16XLARGE = InstanceType.M8I_16XLARGE
M8I_24XLARGE = InstanceType.M8I_24XLARGE
M8I_32XLARGE = InstanceType.M8I_32XLARGE
M8I_48XLARGE = InstanceType.M8I_48XLARGE
M8I_96XLARGE = InstanceType.M8I_96XLARGE
M8I_METAL_48XL = InstanceType.M8I_METAL_48XL
M8I_METAL_96XL = InstanceType.M8I_METAL_96XL
M8I_FLEX_LARGE = InstanceType.M8I_FLEX_LARGE
M8I_FLEX_XLARGE = InstanceType.M8I_FLEX_XLARGE
M8I_FLEX_2XLARGE = InstanceType.M8I_FLEX_2XLARGE
M8I_FLEX_4XLARGE = InstanceType.M8I_FLEX_4XLARGE
M8I_FLEX_8XLARGE = InstanceType.M8I_FLEX_8XLARGE
M8I_FLEX_12XLARGE = InstanceType.M8I_FLEX_12XLARGE
M8I_FLEX_16XLARGE = InstanceType.M8I_FLEX_16XLARGE
I8GE_LARGE = InstanceType.I8GE_LARGE
I8GE_XLARGE = InstanceType.I8GE_XLARGE
I8GE_2XLARGE = InstanceType.I8GE_2XLARGE
I8GE_3XLARGE = InstanceType.I8GE_3XLARGE
I8GE_6XLARGE = InstanceType.I8GE_6XLARGE
I8GE_12XLARGE = InstanceType.I8GE_12XLARGE
I8GE_18XLARGE = InstanceType.I8GE_18XLARGE
I8GE_24XLARGE = InstanceType.I8GE_24XLARGE
I8GE_48XLARGE = InstanceType.I8GE_48XLARGE
I8GE_METAL_24XL = InstanceType.I8GE_METAL_24XL
I8GE_METAL_48XL = InstanceType.I8GE_METAL_48XL
MAC_M4_METAL = InstanceType.MAC_M4_METAL
MAC_M4PRO_METAL = InstanceType.MAC_M4PRO_METAL
R8GN_MEDIUM = InstanceType.R8GN_MEDIUM
R8GN_LARGE = InstanceType.R8GN_LARGE
R8GN_XLARGE = InstanceType.R8GN_XLARGE
R8GN_2XLARGE = InstanceType.R8GN_2XLARGE
R8GN_4XLARGE = InstanceType.R8GN_4XLARGE
R8GN_8XLARGE = InstanceType.R8GN_8XLARGE
R8GN_12XLARGE = InstanceType.R8GN_12XLARGE
R8GN_16XLARGE = InstanceType.R8GN_16XLARGE
R8GN_24XLARGE = InstanceType.R8GN_24XLARGE
R8GN_48XLARGE = InstanceType.R8GN_48XLARGE
R8GN_METAL_24XL = InstanceType.R8GN_METAL_24XL
R8GN_METAL_48XL = InstanceType.R8GN_METAL_48XL
C8I_LARGE = InstanceType.C8I_LARGE
C8I_XLARGE = InstanceType.C8I_XLARGE
C8I_2XLARGE = InstanceType.C8I_2XLARGE
C8I_4XLARGE = InstanceType.C8I_4XLARGE
C8I_8XLARGE = InstanceType.C8I_8XLARGE
C8I_12XLARGE = InstanceType.C8I_12XLARGE
C8I_16XLARGE = InstanceType.C8I_16XLARGE
C8I_24XLARGE = InstanceType.C8I_24XLARGE
C8I_32XLARGE = InstanceType.C8I_32XLARGE
C8I_48XLARGE = InstanceType.C8I_48XLARGE
C8I_96XLARGE = InstanceType.C8I_96XLARGE
C8I_METAL_48XL = InstanceType.C8I_METAL_48XL
C8I_METAL_96XL = InstanceType.C8I_METAL_96XL
C8I_FLEX_LARGE = InstanceType.C8I_FLEX_LARGE
C8I_FLEX_XLARGE = InstanceType.C8I_FLEX_XLARGE
C8I_FLEX_2XLARGE = InstanceType.C8I_FLEX_2XLARGE
C8I_FLEX_4XLARGE = InstanceType.C8I_FLEX_4XLARGE
C8I_FLEX_8XLARGE = InstanceType.C8I_FLEX_8XLARGE
C8I_FLEX_12XLARGE = InstanceType.C8I_FLEX_12XLARGE
C8I_FLEX_16XLARGE = InstanceType.C8I_FLEX_16XLARGE
R8GB_MEDIUM = InstanceType.R8GB_MEDIUM
R8GB_LARGE = InstanceType.R8GB_LARGE
R8GB_XLARGE = InstanceType.R8GB_XLARGE
R8GB_2XLARGE = InstanceType.R8GB_2XLARGE
R8GB_4XLARGE = InstanceType.R8GB_4XLARGE
R8GB_8XLARGE = InstanceType.R8GB_8XLARGE
R8GB_12XLARGE = InstanceType.R8GB_12XLARGE
R8GB_16XLARGE = InstanceType.R8GB_16XLARGE
R8GB_24XLARGE = InstanceType.R8GB_24XLARGE
R8GB_METAL_24XL = InstanceType.R8GB_METAL_24XL
M8A_MEDIUM = InstanceType.M8A_MEDIUM
M8A_LARGE = InstanceType.M8A_LARGE
M8A_XLARGE = InstanceType.M8A_XLARGE
M8A_2XLARGE = InstanceType.M8A_2XLARGE
M8A_4XLARGE = InstanceType.M8A_4XLARGE
M8A_8XLARGE = InstanceType.M8A_8XLARGE
M8A_12XLARGE = InstanceType.M8A_12XLARGE
M8A_16XLARGE = InstanceType.M8A_16XLARGE
M8A_24XLARGE = InstanceType.M8A_24XLARGE
M8A_48XLARGE = InstanceType.M8A_48XLARGE
M8A_METAL_24XL = InstanceType.M8A_METAL_24XL
M8A_METAL_48XL = InstanceType.M8A_METAL_48XL
TRN2_3XLARGE = InstanceType.TRN2_3XLARGE
R8A_MEDIUM = InstanceType.R8A_MEDIUM
R8A_LARGE = InstanceType.R8A_LARGE
R8A_XLARGE = InstanceType.R8A_XLARGE
R8A_2XLARGE = InstanceType.R8A_2XLARGE
R8A_4XLARGE = InstanceType.R8A_4XLARGE
R8A_8XLARGE = InstanceType.R8A_8XLARGE
R8A_12XLARGE = InstanceType.R8A_12XLARGE
R8A_16XLARGE = InstanceType.R8A_16XLARGE
R8A_24XLARGE = InstanceType.R8A_24XLARGE
R8A_48XLARGE = InstanceType.R8A_48XLARGE
R8A_METAL_24XL = InstanceType.R8A_METAL_24XL
R8A_METAL_48XL = InstanceType.R8A_METAL_48XL
P6_B300_48XLARGE = InstanceType.P6_B300_48XLARGE
C8A_MEDIUM = InstanceType.C8A_MEDIUM
C8A_LARGE = InstanceType.C8A_LARGE
C8A_XLARGE = InstanceType.C8A_XLARGE
C8A_2XLARGE = InstanceType.C8A_2XLARGE
C8A_4XLARGE = InstanceType.C8A_4XLARGE
C8A_8XLARGE = InstanceType.C8A_8XLARGE
C8A_12XLARGE = InstanceType.C8A_12XLARGE
C8A_16XLARGE = InstanceType.C8A_16XLARGE
C8A_24XLARGE = InstanceType.C8A_24XLARGE
C8A_48XLARGE = InstanceType.C8A_48XLARGE
C8A_METAL_24XL = InstanceType.C8A_METAL_24XL
C8A_METAL_48XL = InstanceType.C8A_METAL_48XL
NITRO = InstanceTypeHypervisor.NITRO
XEN = InstanceTypeHypervisor.XEN
INSTANCE_ATTACH = InterfacePermissionType.INSTANCE_ATTACH
EIP_ASSOCIATE = InterfacePermissionType.EIP_ASSOCIATE
VLAN = InterfaceProtocolType.VLAN
GRE = InterfaceProtocolType.GRE
OFF = InternetGatewayBlockMode.OFF
BLOCK_BIDIRECTIONAL = InternetGatewayBlockMode.BLOCK_BIDIRECTIONAL
BLOCK_INGRESS = InternetGatewayBlockMode.BLOCK_INGRESS
ALLOW_BIDIRECTIONAL = InternetGatewayExclusionMode.ALLOW_BIDIRECTIONAL
ALLOW_EGRESS = InternetGatewayExclusionMode.ALLOW_EGRESS
PENDING = InterruptibleCapacityReservationAllocationStatus.PENDING
ACTIVE = InterruptibleCapacityReservationAllocationStatus.ACTIVE
UPDATING = InterruptibleCapacityReservationAllocationStatus.UPDATING
CANCELING = InterruptibleCapacityReservationAllocationStatus.CANCELING
CANCELED = InterruptibleCapacityReservationAllocationStatus.CANCELED
FAILED = InterruptibleCapacityReservationAllocationStatus.FAILED
ADHOC = InterruptionType.ADHOC
IPV4 = IpAddressType.IPV4
DUALSTACK = IpAddressType.DUALSTACK
IPV6 = IpAddressType.IPV6
AMAZON = IpSource.AMAZON
BYOIP = IpSource.BYOIP
NONE = IpSource.NONE
EIP = IpamAddressHistoryResourceType.EIP
VPC = IpamAddressHistoryResourceType.VPC
SUBNET = IpamAddressHistoryResourceType.SUBNET
NETWORK_INTERFACE = IpamAddressHistoryResourceType.NETWORK_INTERFACE
INSTANCE = IpamAddressHistoryResourceType.INSTANCE
ACTIVE = IpamAssociatedResourceDiscoveryStatus.ACTIVE
NOT_FOUND = IpamAssociatedResourceDiscoveryStatus.NOT_FOUND
COMPLIANT = IpamComplianceStatus.COMPLIANT
NONCOMPLIANT = IpamComplianceStatus.NONCOMPLIANT
UNMANAGED = IpamComplianceStatus.UNMANAGED
IGNORED = IpamComplianceStatus.IGNORED
ASSUME_ROLE_FAILURE = IpamDiscoveryFailureCode.ASSUME_ROLE_FAILURE
THROTTLING_FAILURE = IpamDiscoveryFailureCode.THROTTLING_FAILURE
UNAUTHORIZED_FAILURE = IpamDiscoveryFailureCode.UNAUTHORIZED_FAILURE
CREATE_IN_PROGRESS = IpamExternalResourceVerificationTokenState.CREATE_IN_PROGRESS
CREATE_COMPLETE = IpamExternalResourceVerificationTokenState.CREATE_COMPLETE
CREATE_FAILED = IpamExternalResourceVerificationTokenState.CREATE_FAILED
DELETE_IN_PROGRESS = IpamExternalResourceVerificationTokenState.DELETE_IN_PROGRESS
DELETE_COMPLETE = IpamExternalResourceVerificationTokenState.DELETE_COMPLETE
DELETE_FAILED = IpamExternalResourceVerificationTokenState.DELETE_FAILED
MANAGED = IpamManagementState.MANAGED
UNMANAGED = IpamManagementState.UNMANAGED
IGNORED = IpamManagementState.IGNORED
IPAM_OWNER = IpamMeteredAccount.IPAM_OWNER
RESOURCE_OWNER = IpamMeteredAccount.RESOURCE_OWNER
AVAILABLE = IpamNetworkInterfaceAttachmentStatus.AVAILABLE
IN_USE = IpamNetworkInterfaceAttachmentStatus.IN_USE
OVERLAPPING = IpamOverlapStatus.OVERLAPPING
NONOVERLAPPING = IpamOverlapStatus.NONOVERLAPPING
IGNORED = IpamOverlapStatus.IGNORED
ACCOUNT = IpamPolicyManagedBy.ACCOUNT
DELEGATED_ADMINISTRATOR_FOR_IPAM = IpamPolicyManagedBy.DELEGATED_ADMINISTRATOR_FOR_IPAM
ALB = IpamPolicyResourceType.ALB
EIP = IpamPolicyResourceType.EIP
RDS = IpamPolicyResourceType.RDS
RNAT = IpamPolicyResourceType.RNAT
CREATE_IN_PROGRESS = IpamPolicyState.CREATE_IN_PROGRESS
CREATE_COMPLETE = IpamPolicyState.CREATE_COMPLETE
CREATE_FAILED = IpamPolicyState.CREATE_FAILED
MODIFY_IN_PROGRESS = IpamPolicyState.MODIFY_IN_PROGRESS
MODIFY_COMPLETE = IpamPolicyState.MODIFY_COMPLETE
MODIFY_FAILED = IpamPolicyState.MODIFY_FAILED
DELETE_IN_PROGRESS = IpamPolicyState.DELETE_IN_PROGRESS
DELETE_COMPLETE = IpamPolicyState.DELETE_COMPLETE
DELETE_FAILED = IpamPolicyState.DELETE_FAILED
ISOLATE_IN_PROGRESS = IpamPolicyState.ISOLATE_IN_PROGRESS
ISOLATE_COMPLETE = IpamPolicyState.ISOLATE_COMPLETE
RESTORE_IN_PROGRESS = IpamPolicyState.RESTORE_IN_PROGRESS
IPAM_POOL = IpamPoolAllocationResourceType.IPAM_POOL
VPC = IpamPoolAllocationResourceType.VPC
EC2_PUBLIC_IPV4_POOL = IpamPoolAllocationResourceType.EC2_PUBLIC_IPV4_POOL
CUSTOM = IpamPoolAllocationResourceType.CUSTOM
SUBNET = IpamPoolAllocationResourceType.SUBNET
EIP = IpamPoolAllocationResourceType.EIP
ANYCAST_IP_LIST = IpamPoolAllocationResourceType.ANYCAST_IP_LIST
EC2 = IpamPoolAwsService.EC2
GLOBAL_SERVICES = IpamPoolAwsService.GLOBAL_SERVICES
CIDR_NOT_AVAILABLE = IpamPoolCidrFailureCode.CIDR_NOT_AVAILABLE
LIMIT_EXCEEDED = IpamPoolCidrFailureCode.LIMIT_EXCEEDED
PENDING_PROVISION = IpamPoolCidrState.PENDING_PROVISION
PROVISIONED = IpamPoolCidrState.PROVISIONED
FAILED_PROVISION = IpamPoolCidrState.FAILED_PROVISION
PENDING_DEPROVISION = IpamPoolCidrState.PENDING_DEPROVISION
DEPROVISIONED = IpamPoolCidrState.DEPROVISIONED
FAILED_DEPROVISION = IpamPoolCidrState.FAILED_DEPROVISION
PENDING_IMPORT = IpamPoolCidrState.PENDING_IMPORT
FAILED_IMPORT = IpamPoolCidrState.FAILED_IMPORT
AMAZON = IpamPoolPublicIpSource.AMAZON
BYOIP = IpamPoolPublicIpSource.BYOIP
VPC = IpamPoolSourceResourceType.VPC
CREATE_IN_PROGRESS = IpamPoolState.CREATE_IN_PROGRESS
CREATE_COMPLETE = IpamPoolState.CREATE_COMPLETE
CREATE_FAILED = IpamPoolState.CREATE_FAILED
MODIFY_IN_PROGRESS = IpamPoolState.MODIFY_IN_PROGRESS
MODIFY_COMPLETE = IpamPoolState.MODIFY_COMPLETE
MODIFY_FAILED = IpamPoolState.MODIFY_FAILED
DELETE_IN_PROGRESS = IpamPoolState.DELETE_IN_PROGRESS
DELETE_COMPLETE = IpamPoolState.DELETE_COMPLETE
DELETE_FAILED = IpamPoolState.DELETE_FAILED
ISOLATE_IN_PROGRESS = IpamPoolState.ISOLATE_IN_PROGRESS
ISOLATE_COMPLETE = IpamPoolState.ISOLATE_COMPLETE
RESTORE_IN_PROGRESS = IpamPoolState.RESTORE_IN_PROGRESS
EQUALS = IpamPrefixListResolverRuleConditionOperation.EQUALS
NOT_EQUALS = IpamPrefixListResolverRuleConditionOperation.NOT_EQUALS
SUBNET_OF = IpamPrefixListResolverRuleConditionOperation.SUBNET_OF
STATIC_CIDR = IpamPrefixListResolverRuleType.STATIC_CIDR
IPAM_RESOURCE_CIDR = IpamPrefixListResolverRuleType.IPAM_RESOURCE_CIDR
IPAM_POOL_CIDR = IpamPrefixListResolverRuleType.IPAM_POOL_CIDR
CREATE_IN_PROGRESS = IpamPrefixListResolverState.CREATE_IN_PROGRESS
CREATE_COMPLETE = IpamPrefixListResolverState.CREATE_COMPLETE
CREATE_FAILED = IpamPrefixListResolverState.CREATE_FAILED
MODIFY_IN_PROGRESS = IpamPrefixListResolverState.MODIFY_IN_PROGRESS
MODIFY_COMPLETE = IpamPrefixListResolverState.MODIFY_COMPLETE
MODIFY_FAILED = IpamPrefixListResolverState.MODIFY_FAILED
DELETE_IN_PROGRESS = IpamPrefixListResolverState.DELETE_IN_PROGRESS
DELETE_COMPLETE = IpamPrefixListResolverState.DELETE_COMPLETE
DELETE_FAILED = IpamPrefixListResolverState.DELETE_FAILED
ISOLATE_IN_PROGRESS = IpamPrefixListResolverState.ISOLATE_IN_PROGRESS
ISOLATE_COMPLETE = IpamPrefixListResolverState.ISOLATE_COMPLETE
RESTORE_IN_PROGRESS = IpamPrefixListResolverState.RESTORE_IN_PROGRESS
CREATE_IN_PROGRESS = IpamPrefixListResolverTargetState.CREATE_IN_PROGRESS
CREATE_COMPLETE = IpamPrefixListResolverTargetState.CREATE_COMPLETE
CREATE_FAILED = IpamPrefixListResolverTargetState.CREATE_FAILED
MODIFY_IN_PROGRESS = IpamPrefixListResolverTargetState.MODIFY_IN_PROGRESS
MODIFY_COMPLETE = IpamPrefixListResolverTargetState.MODIFY_COMPLETE
MODIFY_FAILED = IpamPrefixListResolverTargetState.MODIFY_FAILED
SYNC_IN_PROGRESS = IpamPrefixListResolverTargetState.SYNC_IN_PROGRESS
SYNC_COMPLETE = IpamPrefixListResolverTargetState.SYNC_COMPLETE
SYNC_FAILED = IpamPrefixListResolverTargetState.SYNC_FAILED
DELETE_IN_PROGRESS = IpamPrefixListResolverTargetState.DELETE_IN_PROGRESS
DELETE_COMPLETE = IpamPrefixListResolverTargetState.DELETE_COMPLETE
DELETE_FAILED = IpamPrefixListResolverTargetState.DELETE_FAILED
ISOLATE_IN_PROGRESS = IpamPrefixListResolverTargetState.ISOLATE_IN_PROGRESS
ISOLATE_COMPLETE = IpamPrefixListResolverTargetState.ISOLATE_COMPLETE
RESTORE_IN_PROGRESS = IpamPrefixListResolverTargetState.RESTORE_IN_PROGRESS
PENDING = IpamPrefixListResolverVersionCreationStatus.PENDING
SUCCESS = IpamPrefixListResolverVersionCreationStatus.SUCCESS
FAILURE = IpamPrefixListResolverVersionCreationStatus.FAILURE
ASSOCIATED = IpamPublicAddressAssociationStatus.ASSOCIATED
DISASSOCIATED = IpamPublicAddressAssociationStatus.DISASSOCIATED
NAT_GATEWAY = IpamPublicAddressAwsService.NAT_GATEWAY
DATABASE_MIGRATION_SERVICE = IpamPublicAddressAwsService.DATABASE_MIGRATION_SERVICE
REDSHIFT = IpamPublicAddressAwsService.REDSHIFT
ELASTIC_CONTAINER_SERVICE = IpamPublicAddressAwsService.ELASTIC_CONTAINER_SERVICE
RELATIONAL_DATABASE_SERVICE = IpamPublicAddressAwsService.RELATIONAL_DATABASE_SERVICE
SITE_TO_SITE_VPN = IpamPublicAddressAwsService.SITE_TO_SITE_VPN
LOAD_BALANCER = IpamPublicAddressAwsService.LOAD_BALANCER
GLOBAL_ACCELERATOR = IpamPublicAddressAwsService.GLOBAL_ACCELERATOR
CLOUDFRONT = IpamPublicAddressAwsService.CLOUDFRONT
OTHER = IpamPublicAddressAwsService.OTHER
SERVICE_MANAGED_IP = IpamPublicAddressType.SERVICE_MANAGED_IP
SERVICE_MANAGED_BYOIP = IpamPublicAddressType.SERVICE_MANAGED_BYOIP
AMAZON_OWNED_EIP = IpamPublicAddressType.AMAZON_OWNED_EIP
AMAZON_OWNED_CONTIG = IpamPublicAddressType.AMAZON_OWNED_CONTIG
BYOIP = IpamPublicAddressType.BYOIP
EC2_PUBLIC_IP = IpamPublicAddressType.EC2_PUBLIC_IP
ANYCAST_IP_LIST_IP = IpamPublicAddressType.ANYCAST_IP_LIST_IP
AMAZON = IpamResourceCidrIpSource.AMAZON
BYOIP = IpamResourceCidrIpSource.BYOIP
NONE = IpamResourceCidrIpSource.NONE
ASSOCIATE_IN_PROGRESS = IpamResourceDiscoveryAssociationState.ASSOCIATE_IN_PROGRESS
ASSOCIATE_COMPLETE = IpamResourceDiscoveryAssociationState.ASSOCIATE_COMPLETE
ASSOCIATE_FAILED = IpamResourceDiscoveryAssociationState.ASSOCIATE_FAILED
DISASSOCIATE_IN_PROGRESS = IpamResourceDiscoveryAssociationState.DISASSOCIATE_IN_PROGRESS
DISASSOCIATE_COMPLETE = IpamResourceDiscoveryAssociationState.DISASSOCIATE_COMPLETE
DISASSOCIATE_FAILED = IpamResourceDiscoveryAssociationState.DISASSOCIATE_FAILED
ISOLATE_IN_PROGRESS = IpamResourceDiscoveryAssociationState.ISOLATE_IN_PROGRESS
ISOLATE_COMPLETE = IpamResourceDiscoveryAssociationState.ISOLATE_COMPLETE
RESTORE_IN_PROGRESS = IpamResourceDiscoveryAssociationState.RESTORE_IN_PROGRESS
CREATE_IN_PROGRESS = IpamResourceDiscoveryState.CREATE_IN_PROGRESS
CREATE_COMPLETE = IpamResourceDiscoveryState.CREATE_COMPLETE
CREATE_FAILED = IpamResourceDiscoveryState.CREATE_FAILED
MODIFY_IN_PROGRESS = IpamResourceDiscoveryState.MODIFY_IN_PROGRESS
MODIFY_COMPLETE = IpamResourceDiscoveryState.MODIFY_COMPLETE
MODIFY_FAILED = IpamResourceDiscoveryState.MODIFY_FAILED
DELETE_IN_PROGRESS = IpamResourceDiscoveryState.DELETE_IN_PROGRESS
DELETE_COMPLETE = IpamResourceDiscoveryState.DELETE_COMPLETE
DELETE_FAILED = IpamResourceDiscoveryState.DELETE_FAILED
ISOLATE_IN_PROGRESS = IpamResourceDiscoveryState.ISOLATE_IN_PROGRESS
ISOLATE_COMPLETE = IpamResourceDiscoveryState.ISOLATE_COMPLETE
RESTORE_IN_PROGRESS = IpamResourceDiscoveryState.RESTORE_IN_PROGRESS
VPC = IpamResourceType.VPC
SUBNET = IpamResourceType.SUBNET
EIP = IpamResourceType.EIP
PUBLIC_IPV4_POOL = IpamResourceType.PUBLIC_IPV4_POOL
IPV6_POOL = IpamResourceType.IPV6_POOL
ENI = IpamResourceType.ENI
ANYCAST_IP_LIST = IpamResourceType.ANYCAST_IP_LIST
INFOBLOX = IpamScopeExternalAuthorityType.INFOBLOX
CREATE_IN_PROGRESS = IpamScopeState.CREATE_IN_PROGRESS
CREATE_COMPLETE = IpamScopeState.CREATE_COMPLETE
CREATE_FAILED = IpamScopeState.CREATE_FAILED
MODIFY_IN_PROGRESS = IpamScopeState.MODIFY_IN_PROGRESS
MODIFY_COMPLETE = IpamScopeState.MODIFY_COMPLETE
MODIFY_FAILED = IpamScopeState.MODIFY_FAILED
DELETE_IN_PROGRESS = IpamScopeState.DELETE_IN_PROGRESS
DELETE_COMPLETE = IpamScopeState.DELETE_COMPLETE
DELETE_FAILED = IpamScopeState.DELETE_FAILED
ISOLATE_IN_PROGRESS = IpamScopeState.ISOLATE_IN_PROGRESS
ISOLATE_COMPLETE = IpamScopeState.ISOLATE_COMPLETE
RESTORE_IN_PROGRESS = IpamScopeState.RESTORE_IN_PROGRESS
PUBLIC = IpamScopeType.PUBLIC
PRIVATE = IpamScopeType.PRIVATE
CREATE_IN_PROGRESS = IpamState.CREATE_IN_PROGRESS
CREATE_COMPLETE = IpamState.CREATE_COMPLETE
CREATE_FAILED = IpamState.CREATE_FAILED
MODIFY_IN_PROGRESS = IpamState.MODIFY_IN_PROGRESS
MODIFY_COMPLETE = IpamState.MODIFY_COMPLETE
MODIFY_FAILED = IpamState.MODIFY_FAILED
DELETE_IN_PROGRESS = IpamState.DELETE_IN_PROGRESS
DELETE_COMPLETE = IpamState.DELETE_COMPLETE
DELETE_FAILED = IpamState.DELETE_FAILED
ISOLATE_IN_PROGRESS = IpamState.ISOLATE_IN_PROGRESS
ISOLATE_COMPLETE = IpamState.ISOLATE_COMPLETE
RESTORE_IN_PROGRESS = IpamState.RESTORE_IN_PROGRESS
FREE = IpamTier.FREE
ADVANCED = IpamTier.ADVANCED
PUBLIC = Ipv6AddressAttribute.PUBLIC
PRIVATE = Ipv6AddressAttribute.PRIVATE
ENABLE = Ipv6SupportValue.ENABLE
DISABLE = Ipv6SupportValue.DISABLE
PEM = KeyFormat.PEM
PPK = KeyFormat.PPK
RSA = KeyType.RSA
ED25519 = KeyType.ED25519
DEFAULT = LaunchTemplateAutoRecoveryState.DEFAULT
DISABLED = LaunchTemplateAutoRecoveryState.DISABLED
LAUNCHTEMPLATEIDDOESNOTEXIST = LaunchTemplateErrorCode.LAUNCHTEMPLATEIDDOESNOTEXIST
LAUNCHTEMPLATEIDMALFORMED = LaunchTemplateErrorCode.LAUNCHTEMPLATEIDMALFORMED
LAUNCHTEMPLATENAMEDOESNOTEXIST = LaunchTemplateErrorCode.LAUNCHTEMPLATENAMEDOESNOTEXIST
LAUNCHTEMPLATENAMEMALFORMED = LaunchTemplateErrorCode.LAUNCHTEMPLATENAMEMALFORMED
LAUNCHTEMPLATEVERSIONDOESNOTEXIST = LaunchTemplateErrorCode.LAUNCHTEMPLATEVERSIONDOESNOTEXIST
UNEXPECTEDERROR = LaunchTemplateErrorCode.UNEXPECTEDERROR
OPTIONAL = LaunchTemplateHttpTokensState.OPTIONAL
REQUIRED = LaunchTemplateHttpTokensState.REQUIRED
DISABLED = LaunchTemplateInstanceMetadataEndpointState.DISABLED
ENABLED = LaunchTemplateInstanceMetadataEndpointState.ENABLED
PENDING = LaunchTemplateInstanceMetadataOptionsState.PENDING
APPLIED = LaunchTemplateInstanceMetadataOptionsState.APPLIED
DISABLED = LaunchTemplateInstanceMetadataProtocolIpv6.DISABLED
ENABLED = LaunchTemplateInstanceMetadataProtocolIpv6.ENABLED
DISABLED = LaunchTemplateInstanceMetadataTagsState.DISABLED
ENABLED = LaunchTemplateInstanceMetadataTagsState.ENABLED
AVAILABLE = ListingState.AVAILABLE
SOLD = ListingState.SOLD
CANCELLED = ListingState.CANCELLED
PENDING = ListingState.PENDING
ACTIVE = ListingStatus.ACTIVE
PENDING = ListingStatus.PENDING
CANCELLED = ListingStatus.CANCELLED
CLOSED = ListingStatus.CLOSED
PENDING = LocalGatewayRouteState.PENDING
ACTIVE = LocalGatewayRouteState.ACTIVE
BLACKHOLE = LocalGatewayRouteState.BLACKHOLE
DELETING = LocalGatewayRouteState.DELETING
DELETED = LocalGatewayRouteState.DELETED
DIRECT_VPC_ROUTING = LocalGatewayRouteTableMode.DIRECT_VPC_ROUTING
COIP = LocalGatewayRouteTableMode.COIP
STATIC = LocalGatewayRouteType.STATIC
PROPAGATED = LocalGatewayRouteType.PROPAGATED
PENDING = LocalGatewayVirtualInterfaceConfigurationState.PENDING
AVAILABLE = LocalGatewayVirtualInterfaceConfigurationState.AVAILABLE
DELETING = LocalGatewayVirtualInterfaceConfigurationState.DELETING
DELETED = LocalGatewayVirtualInterfaceConfigurationState.DELETED
PENDING = LocalGatewayVirtualInterfaceGroupConfigurationState.PENDING
INCOMPLETE = LocalGatewayVirtualInterfaceGroupConfigurationState.INCOMPLETE
AVAILABLE = LocalGatewayVirtualInterfaceGroupConfigurationState.AVAILABLE
DELETING = LocalGatewayVirtualInterfaceGroupConfigurationState.DELETING
DELETED = LocalGatewayVirtualInterfaceGroupConfigurationState.DELETED
INCLUDED = LocalStorage.INCLUDED
REQUIRED = LocalStorage.REQUIRED
EXCLUDED = LocalStorage.EXCLUDED
HDD = LocalStorageType.HDD
SSD = LocalStorageType.SSD
REGION = LocationType.REGION
AVAILABILITY_ZONE = LocationType.AVAILABILITY_ZONE
AVAILABILITY_ZONE_ID = LocationType.AVAILABILITY_ZONE_ID
OUTPOST = LocationType.OUTPOST
COMPLIANCE = LockMode.COMPLIANCE
GOVERNANCE = LockMode.GOVERNANCE
COMPLIANCE = LockState.COMPLIANCE
GOVERNANCE = LockState.GOVERNANCE
COMPLIANCE_COOLOFF = LockState.COMPLIANCE_COOLOFF
EXPIRED = LockState.EXPIRED
CLOUD_WATCH_LOGS = LogDestinationType.CLOUD_WATCH_LOGS
S3 = LogDestinationType.S3
KINESIS_DATA_FIREHOSE = LogDestinationType.KINESIS_DATA_FIREHOSE
SUCCESSFUL = MacModificationTaskState.SUCCESSFUL
FAILED = MacModificationTaskState.FAILED
IN_PROGRESS = MacModificationTaskState.IN_PROGRESS
PENDING = MacModificationTaskState.PENDING
SIP_MODIFICATION = MacModificationTaskType.SIP_MODIFICATION
VOLUME_OWNERSHIP_DELEGATION = MacModificationTaskType.VOLUME_OWNERSHIP_DELEGATION
ENABLED = MacSystemIntegrityProtectionSettingStatus.ENABLED
DISABLED = MacSystemIntegrityProtectionSettingStatus.DISABLED
ACCOUNT = ManagedBy.ACCOUNT
DECLARATIVE_POLICY = ManagedBy.DECLARATIVE_POLICY
SPOT = MarketType.SPOT
CAPACITY_BLOCK = MarketType.CAPACITY_BLOCK
INTERRUPTIBLE_CAPACITY_RESERVATION = MarketType.INTERRUPTIBLE_CAPACITY_RESERVATION
STATIC = MembershipType.STATIC
IGMP = MembershipType.IGMP
OPTIONAL = MetadataDefaultHttpTokensState.OPTIONAL
REQUIRED = MetadataDefaultHttpTokensState.REQUIRED
NO_PREFERENCE = MetadataDefaultHttpTokensState.NO_PREFERENCE
RESERVATION_TOTAL_CAPACITY_HRS_VCPU = Metric.RESERVATION_TOTAL_CAPACITY_HRS_VCPU
RESERVATION_TOTAL_CAPACITY_HRS_INST = Metric.RESERVATION_TOTAL_CAPACITY_HRS_INST
RESERVATION_MAX_SIZE_VCPU = Metric.RESERVATION_MAX_SIZE_VCPU
RESERVATION_MAX_SIZE_INST = Metric.RESERVATION_MAX_SIZE_INST
RESERVATION_MIN_SIZE_VCPU = Metric.RESERVATION_MIN_SIZE_VCPU
RESERVATION_MIN_SIZE_INST = Metric.RESERVATION_MIN_SIZE_INST
RESERVATION_UNUSED_TOTAL_CAPACITY_HRS_VCPU = Metric.RESERVATION_UNUSED_TOTAL_CAPACITY_HRS_VCPU
RESERVATION_UNUSED_TOTAL_CAPACITY_HRS_INST = Metric.RESERVATION_UNUSED_TOTAL_CAPACITY_HRS_INST
RESERVATION_UNUSED_TOTAL_ESTIMATED_COST = Metric.RESERVATION_UNUSED_TOTAL_ESTIMATED_COST
RESERVATION_MAX_UNUSED_SIZE_VCPU = Metric.RESERVATION_MAX_UNUSED_SIZE_VCPU
RESERVATION_MAX_UNUSED_SIZE_INST = Metric.RESERVATION_MAX_UNUSED_SIZE_INST
RESERVATION_MIN_UNUSED_SIZE_VCPU = Metric.RESERVATION_MIN_UNUSED_SIZE_VCPU
RESERVATION_MIN_UNUSED_SIZE_INST = Metric.RESERVATION_MIN_UNUSED_SIZE_INST
RESERVATION_MAX_UTILIZATION = Metric.RESERVATION_MAX_UTILIZATION
RESERVATION_MIN_UTILIZATION = Metric.RESERVATION_MIN_UTILIZATION
RESERVATION_AVG_UTILIZATION_VCPU = Metric.RESERVATION_AVG_UTILIZATION_VCPU
RESERVATION_AVG_UTILIZATION_INST = Metric.RESERVATION_AVG_UTILIZATION_INST
RESERVATION_TOTAL_COUNT = Metric.RESERVATION_TOTAL_COUNT
RESERVATION_TOTAL_ESTIMATED_COST = Metric.RESERVATION_TOTAL_ESTIMATED_COST
RESERVATION_AVG_FUTURE_SIZE_VCPU = Metric.RESERVATION_AVG_FUTURE_SIZE_VCPU
RESERVATION_AVG_FUTURE_SIZE_INST = Metric.RESERVATION_AVG_FUTURE_SIZE_INST
RESERVATION_MIN_FUTURE_SIZE_VCPU = Metric.RESERVATION_MIN_FUTURE_SIZE_VCPU
RESERVATION_MIN_FUTURE_SIZE_INST = Metric.RESERVATION_MIN_FUTURE_SIZE_INST
RESERVATION_MAX_FUTURE_SIZE_VCPU = Metric.RESERVATION_MAX_FUTURE_SIZE_VCPU
RESERVATION_MAX_FUTURE_SIZE_INST = Metric.RESERVATION_MAX_FUTURE_SIZE_INST
RESERVATION_AVG_COMMITTED_SIZE_VCPU = Metric.RESERVATION_AVG_COMMITTED_SIZE_VCPU
RESERVATION_AVG_COMMITTED_SIZE_INST = Metric.RESERVATION_AVG_COMMITTED_SIZE_INST
RESERVATION_MAX_COMMITTED_SIZE_VCPU = Metric.RESERVATION_MAX_COMMITTED_SIZE_VCPU
RESERVATION_MAX_COMMITTED_SIZE_INST = Metric.RESERVATION_MAX_COMMITTED_SIZE_INST
RESERVATION_MIN_COMMITTED_SIZE_VCPU = Metric.RESERVATION_MIN_COMMITTED_SIZE_VCPU
RESERVATION_MIN_COMMITTED_SIZE_INST = Metric.RESERVATION_MIN_COMMITTED_SIZE_INST
RESERVED_TOTAL_USAGE_HRS_VCPU = Metric.RESERVED_TOTAL_USAGE_HRS_VCPU
RESERVED_TOTAL_USAGE_HRS_INST = Metric.RESERVED_TOTAL_USAGE_HRS_INST
RESERVED_TOTAL_ESTIMATED_COST = Metric.RESERVED_TOTAL_ESTIMATED_COST
UNRESERVED_TOTAL_USAGE_HRS_VCPU = Metric.UNRESERVED_TOTAL_USAGE_HRS_VCPU
UNRESERVED_TOTAL_USAGE_HRS_INST = Metric.UNRESERVED_TOTAL_USAGE_HRS_INST
UNRESERVED_TOTAL_ESTIMATED_COST = Metric.UNRESERVED_TOTAL_ESTIMATED_COST
SPOT_TOTAL_USAGE_HRS_VCPU = Metric.SPOT_TOTAL_USAGE_HRS_VCPU
SPOT_TOTAL_USAGE_HRS_INST = Metric.SPOT_TOTAL_USAGE_HRS_INST
SPOT_TOTAL_ESTIMATED_COST = Metric.SPOT_TOTAL_ESTIMATED_COST
SPOT_AVG_RUN_TIME_BEFORE_INTERRUPTION_INST = Metric.SPOT_AVG_RUN_TIME_BEFORE_INTERRUPTION_INST
SPOT_MAX_RUN_TIME_BEFORE_INTERRUPTION_INST = Metric.SPOT_MAX_RUN_TIME_BEFORE_INTERRUPTION_INST
SPOT_MIN_RUN_TIME_BEFORE_INTERRUPTION_INST = Metric.SPOT_MIN_RUN_TIME_BEFORE_INTERRUPTION_INST
SPOT_TOTAL_INTERRUPTIONS_INST = Metric.SPOT_TOTAL_INTERRUPTIONS_INST
SPOT_TOTAL_INTERRUPTIONS_VCPU = Metric.SPOT_TOTAL_INTERRUPTIONS_VCPU
SPOT_TOTAL_COUNT_INST = Metric.SPOT_TOTAL_COUNT_INST
SPOT_TOTAL_COUNT_VCPU = Metric.SPOT_TOTAL_COUNT_VCPU
SPOT_INTERRUPTION_RATE_INST = Metric.SPOT_INTERRUPTION_RATE_INST
SPOT_INTERRUPTION_RATE_VCPU = Metric.SPOT_INTERRUPTION_RATE_VCPU
AGGREGATE_LATENCY = MetricType.AGGREGATE_LATENCY
OPTED_IN = ModifyAvailabilityZoneOptInStatus.OPTED_IN
NOT_OPTED_IN = ModifyAvailabilityZoneOptInStatus.NOT_OPTED_IN
DISABLED = MonitoringState.DISABLED
DISABLING = MonitoringState.DISABLING
ENABLED = MonitoringState.ENABLED
PENDING = MonitoringState.PENDING
MOVINGTOVPC = MoveStatus.MOVINGTOVPC
RESTORINGTOCLASSIC = MoveStatus.RESTORINGTOCLASSIC
ENABLE = MulticastSupportValue.ENABLE
DISABLE = MulticastSupportValue.DISABLE
ASSIGNING = NatGatewayAddressStatus.ASSIGNING
UNASSIGNING = NatGatewayAddressStatus.UNASSIGNING
ASSOCIATING = NatGatewayAddressStatus.ASSOCIATING
DISASSOCIATING = NatGatewayAddressStatus.DISASSOCIATING
SUCCEEDED = NatGatewayAddressStatus.SUCCEEDED
FAILED = NatGatewayAddressStatus.FAILED
MODIFYING = NatGatewayApplianceModifyState.MODIFYING
COMPLETED = NatGatewayApplianceModifyState.COMPLETED
FAILED = NatGatewayApplianceModifyState.FAILED
ATTACHING = NatGatewayApplianceState.ATTACHING
ATTACHED = NatGatewayApplianceState.ATTACHED
DETACHING = NatGatewayApplianceState.DETACHING
DETACHED = NatGatewayApplianceState.DETACHED
ATTACH_FAILED = NatGatewayApplianceState.ATTACH_FAILED
DETACH_FAILED = NatGatewayApplianceState.DETACH_FAILED
NETWORK_FIREWALL_PROXY = NatGatewayApplianceType.NETWORK_FIREWALL_PROXY
PENDING = NatGatewayState.PENDING
FAILED = NatGatewayState.FAILED
AVAILABLE = NatGatewayState.AVAILABLE
DELETING = NatGatewayState.DELETING
DELETED = NatGatewayState.DELETED
DESCRIPTION = NetworkInterfaceAttribute.DESCRIPTION
GROUPSET = NetworkInterfaceAttribute.GROUPSET
SOURCEDESTCHECK = NetworkInterfaceAttribute.SOURCEDESTCHECK
ATTACHMENT = NetworkInterfaceAttribute.ATTACHMENT
ASSOCIATEPUBLICIPADDRESS = NetworkInterfaceAttribute.ASSOCIATEPUBLICIPADDRESS
EFA = NetworkInterfaceCreationType.EFA
EFA_ONLY = NetworkInterfaceCreationType.EFA_ONLY
BRANCH = NetworkInterfaceCreationType.BRANCH
TRUNK = NetworkInterfaceCreationType.TRUNK
PENDING = NetworkInterfacePermissionStateCode.PENDING
GRANTED = NetworkInterfacePermissionStateCode.GRANTED
REVOKING = NetworkInterfacePermissionStateCode.REVOKING
REVOKED = NetworkInterfacePermissionStateCode.REVOKED
AVAILABLE = NetworkInterfaceStatus.AVAILABLE
ASSOCIATED = NetworkInterfaceStatus.ASSOCIATED
ATTACHING = NetworkInterfaceStatus.ATTACHING
IN_USE = NetworkInterfaceStatus.IN_USE
DETACHING = NetworkInterfaceStatus.DETACHING
INTERFACE = NetworkInterfaceType.INTERFACE
NATGATEWAY = NetworkInterfaceType.NATGATEWAY
EFA = NetworkInterfaceType.EFA
EFA_ONLY = NetworkInterfaceType.EFA_ONLY
TRUNK = NetworkInterfaceType.TRUNK
LOAD_BALANCER = NetworkInterfaceType.LOAD_BALANCER
NETWORK_LOAD_BALANCER = NetworkInterfaceType.NETWORK_LOAD_BALANCER
VPC_ENDPOINT = NetworkInterfaceType.VPC_ENDPOINT
BRANCH = NetworkInterfaceType.BRANCH
TRANSIT_GATEWAY = NetworkInterfaceType.TRANSIT_GATEWAY
LAMBDA = NetworkInterfaceType.LAMBDA
QUICKSIGHT = NetworkInterfaceType.QUICKSIGHT
GLOBAL_ACCELERATOR_MANAGED = NetworkInterfaceType.GLOBAL_ACCELERATOR_MANAGED
API_GATEWAY_MANAGED = NetworkInterfaceType.API_GATEWAY_MANAGED
GATEWAY_LOAD_BALANCER = NetworkInterfaceType.GATEWAY_LOAD_BALANCER
GATEWAY_LOAD_BALANCER_ENDPOINT = NetworkInterfaceType.GATEWAY_LOAD_BALANCER_ENDPOINT
IOT_RULES_MANAGED = NetworkInterfaceType.IOT_RULES_MANAGED
AWS_CODESTAR_CONNECTIONS_MANAGED = NetworkInterfaceType.AWS_CODESTAR_CONNECTIONS_MANAGED
UNSUPPORTED = NitroEnclavesSupport.UNSUPPORTED
SUPPORTED = NitroEnclavesSupport.SUPPORTED
UNSUPPORTED = NitroTpmSupport.UNSUPPORTED
SUPPORTED = NitroTpmSupport.SUPPORTED
STANDARD = OfferingClassType.STANDARD
CONVERTIBLE = OfferingClassType.CONVERTIBLE
HEAVY_UTILIZATION = OfferingTypeValues.HEAVY_UTILIZATION
MEDIUM_UTILIZATION = OfferingTypeValues.MEDIUM_UTILIZATION
LIGHT_UTILIZATION = OfferingTypeValues.LIGHT_UTILIZATION
NO_UPFRONT = OfferingTypeValues.NO_UPFRONT
PARTIAL_UPFRONT = OfferingTypeValues.PARTIAL_UPFRONT
ALL_UPFRONT = OfferingTypeValues.ALL_UPFRONT
LOWESTPRICE = OnDemandAllocationStrategy.LOWESTPRICE
PRIORITIZED = OnDemandAllocationStrategy.PRIORITIZED
ADD = OperationType.ADD
REMOVE = OperationType.REMOVE
CSV = OutputFormat.CSV
PARQUET = OutputFormat.PARQUET
NONE = PartitionLoadFrequency.NONE
DAILY = PartitionLoadFrequency.DAILY
WEEKLY = PartitionLoadFrequency.WEEKLY
MONTHLY = PartitionLoadFrequency.MONTHLY
SERVICEOWNER = PayerResponsibility.SERVICEOWNER
ALLUPFRONT = PaymentOption.ALLUPFRONT
PARTIALUPFRONT = PaymentOption.PARTIALUPFRONT
NOUPFRONT = PaymentOption.NOUPFRONT
FIVE_MINUTES = PeriodType.FIVE_MINUTES
FIFTEEN_MINUTES = PeriodType.FIFTEEN_MINUTES
ONE_HOUR = PeriodType.ONE_HOUR
THREE_HOURS = PeriodType.THREE_HOURS
ONE_DAY = PeriodType.ONE_DAY
ONE_WEEK = PeriodType.ONE_WEEK
ALL = PermissionGroup.ALL
UNSUPPORTED = PhcSupport.UNSUPPORTED
SUPPORTED = PhcSupport.SUPPORTED
PENDING = PlacementGroupState.PENDING
AVAILABLE = PlacementGroupState.AVAILABLE
DELETING = PlacementGroupState.DELETING
DELETED = PlacementGroupState.DELETED
CLUSTER = PlacementGroupStrategy.CLUSTER
PARTITION = PlacementGroupStrategy.PARTITION
SPREAD = PlacementGroupStrategy.SPREAD
CLUSTER = PlacementStrategy.CLUSTER
SPREAD = PlacementStrategy.SPREAD
PARTITION = PlacementStrategy.PARTITION
WINDOWS = PlatformValues.WINDOWS
CREATE_IN_PROGRESS = PrefixListState.CREATE_IN_PROGRESS
CREATE_COMPLETE = PrefixListState.CREATE_COMPLETE
CREATE_FAILED = PrefixListState.CREATE_FAILED
MODIFY_IN_PROGRESS = PrefixListState.MODIFY_IN_PROGRESS
MODIFY_COMPLETE = PrefixListState.MODIFY_COMPLETE
MODIFY_FAILED = PrefixListState.MODIFY_FAILED
RESTORE_IN_PROGRESS = PrefixListState.RESTORE_IN_PROGRESS
RESTORE_COMPLETE = PrefixListState.RESTORE_COMPLETE
RESTORE_FAILED = PrefixListState.RESTORE_FAILED
DELETE_IN_PROGRESS = PrefixListState.DELETE_IN_PROGRESS
DELETE_COMPLETE = PrefixListState.DELETE_COMPLETE
DELETE_FAILED = PrefixListState.DELETE_FAILED
ALL = PrincipalType.ALL
SERVICE = PrincipalType.SERVICE
ORGANIZATIONUNIT = PrincipalType.ORGANIZATIONUNIT
ACCOUNT = PrincipalType.ACCOUNT
USER = PrincipalType.USER
ROLE = PrincipalType.ROLE
DEVPAY = ProductCodeValues.DEVPAY
MARKETPLACE = ProductCodeValues.MARKETPLACE
TCP = Protocol.TCP
UDP = Protocol.UDP
GRE = ProtocolValue.GRE
PUBLIC_DUAL_STACK_DNS_NAME = PublicIpDnsOption.PUBLIC_DUAL_STACK_DNS_NAME
PUBLIC_IPV4_DNS_NAME = PublicIpDnsOption.PUBLIC_IPV4_DNS_NAME
PUBLIC_IPV6_DNS_NAME = PublicIpDnsOption.PUBLIC_IPV6_DNS_NAME
LINUX_UNIX = RIProductDescription.LINUX_UNIX
LINUX_UNIX_AMAZON_VPC = RIProductDescription.LINUX_UNIX_AMAZON_VPC
WINDOWS = RIProductDescription.WINDOWS
WINDOWS_AMAZON_VPC = RIProductDescription.WINDOWS_AMAZON_VPC
UNSUPPORTED = RebootMigrationSupport.UNSUPPORTED
SUPPORTED = RebootMigrationSupport.SUPPORTED
HOURLY = RecurringChargeFrequency.HOURLY
PENDING = ReplaceRootVolumeTaskState.PENDING
IN_PROGRESS = ReplaceRootVolumeTaskState.IN_PROGRESS
FAILING = ReplaceRootVolumeTaskState.FAILING
SUCCEEDED = ReplaceRootVolumeTaskState.SUCCEEDED
FAILED = ReplaceRootVolumeTaskState.FAILED
FAILED_DETACHED = ReplaceRootVolumeTaskState.FAILED_DETACHED
LAUNCH = ReplacementStrategy.LAUNCH
LAUNCH_BEFORE_TERMINATE = ReplacementStrategy.LAUNCH_BEFORE_TERMINATE
INSTANCE_STUCK_IN_STATE = ReportInstanceReasonCodes.INSTANCE_STUCK_IN_STATE
UNRESPONSIVE = ReportInstanceReasonCodes.UNRESPONSIVE
NOT_ACCEPTING_CREDENTIALS = ReportInstanceReasonCodes.NOT_ACCEPTING_CREDENTIALS
PASSWORD_NOT_AVAILABLE = ReportInstanceReasonCodes.PASSWORD_NOT_AVAILABLE
PERFORMANCE_NETWORK = ReportInstanceReasonCodes.PERFORMANCE_NETWORK
PERFORMANCE_INSTANCE_STORE = ReportInstanceReasonCodes.PERFORMANCE_INSTANCE_STORE
PERFORMANCE_EBS_VOLUME = ReportInstanceReasonCodes.PERFORMANCE_EBS_VOLUME
PERFORMANCE_OTHER = ReportInstanceReasonCodes.PERFORMANCE_OTHER
OTHER = ReportInstanceReasonCodes.OTHER
RUNNING = ReportState.RUNNING
CANCELLED = ReportState.CANCELLED
COMPLETE = ReportState.COMPLETE
ERROR = ReportState.ERROR
OK = ReportStatusType.OK
IMPAIRED = ReportStatusType.IMPAIRED
LIMITED = ReservationEndDateType.LIMITED
UNLIMITED = ReservationEndDateType.UNLIMITED
ACTIVE = ReservationState.ACTIVE
EXPIRED = ReservationState.EXPIRED
CANCELLED = ReservationState.CANCELLED
SCHEDULED = ReservationState.SCHEDULED
PENDING = ReservationState.PENDING
FAILED = ReservationState.FAILED
DELAYED = ReservationState.DELAYED
UNSUPPORTED = ReservationState.UNSUPPORTED
PAYMENT_PENDING = ReservationState.PAYMENT_PENDING
PAYMENT_FAILED = ReservationState.PAYMENT_FAILED
RETIRED = ReservationState.RETIRED
CAPACITY_BLOCK = ReservationType.CAPACITY_BLOCK
ODCR = ReservationType.ODCR
PAYMENT_PENDING = ReservedInstanceState.PAYMENT_PENDING
ACTIVE = ReservedInstanceState.ACTIVE
PAYMENT_FAILED = ReservedInstanceState.PAYMENT_FAILED
RETIRED = ReservedInstanceState.RETIRED
QUEUED = ReservedInstanceState.QUEUED
QUEUED_DELETED = ReservedInstanceState.QUEUED_DELETED
LOADPERMISSION = ResetFpgaImageAttributeName.LOADPERMISSION
LAUNCHPERMISSION = ResetImageAttributeName.LAUNCHPERMISSION
CAPACITY_RESERVATION = ResourceType.CAPACITY_RESERVATION
CLIENT_VPN_ENDPOINT = ResourceType.CLIENT_VPN_ENDPOINT
CUSTOMER_GATEWAY = ResourceType.CUSTOMER_GATEWAY
CARRIER_GATEWAY = ResourceType.CARRIER_GATEWAY
COIP_POOL = ResourceType.COIP_POOL
DECLARATIVE_POLICIES_REPORT = ResourceType.DECLARATIVE_POLICIES_REPORT
DEDICATED_HOST = ResourceType.DEDICATED_HOST
DHCP_OPTIONS = ResourceType.DHCP_OPTIONS
EGRESS_ONLY_INTERNET_GATEWAY = ResourceType.EGRESS_ONLY_INTERNET_GATEWAY
ELASTIC_IP = ResourceType.ELASTIC_IP
ELASTIC_GPU = ResourceType.ELASTIC_GPU
EXPORT_IMAGE_TASK = ResourceType.EXPORT_IMAGE_TASK
EXPORT_INSTANCE_TASK = ResourceType.EXPORT_INSTANCE_TASK
FLEET = ResourceType.FLEET
FPGA_IMAGE = ResourceType.FPGA_IMAGE
HOST_RESERVATION = ResourceType.HOST_RESERVATION
IMAGE = ResourceType.IMAGE
IMAGE_USAGE_REPORT = ResourceType.IMAGE_USAGE_REPORT
IMPORT_IMAGE_TASK = ResourceType.IMPORT_IMAGE_TASK
IMPORT_SNAPSHOT_TASK = ResourceType.IMPORT_SNAPSHOT_TASK
INSTANCE = ResourceType.INSTANCE
INSTANCE_EVENT_WINDOW = ResourceType.INSTANCE_EVENT_WINDOW
INTERNET_GATEWAY = ResourceType.INTERNET_GATEWAY
IPAM = ResourceType.IPAM
IPAM_POOL = ResourceType.IPAM_POOL
IPAM_SCOPE = ResourceType.IPAM_SCOPE
IPV4POOL_EC2 = ResourceType.IPV4POOL_EC2
IPV6POOL_EC2 = ResourceType.IPV6POOL_EC2
KEY_PAIR = ResourceType.KEY_PAIR
LAUNCH_TEMPLATE = ResourceType.LAUNCH_TEMPLATE
LOCAL_GATEWAY = ResourceType.LOCAL_GATEWAY
LOCAL_GATEWAY_ROUTE_TABLE = ResourceType.LOCAL_GATEWAY_ROUTE_TABLE
LOCAL_GATEWAY_VIRTUAL_INTERFACE = ResourceType.LOCAL_GATEWAY_VIRTUAL_INTERFACE
LOCAL_GATEWAY_VIRTUAL_INTERFACE_GROUP = ResourceType.LOCAL_GATEWAY_VIRTUAL_INTERFACE_GROUP
LOCAL_GATEWAY_ROUTE_TABLE_VPC_ASSOCIATION = ResourceType.LOCAL_GATEWAY_ROUTE_TABLE_VPC_ASSOCIATION
LOCAL_GATEWAY_ROUTE_TABLE_VIRTUAL_INTERFACE_GROUP_ASSOCIATION = ResourceType.LOCAL_GATEWAY_ROUTE_TABLE_VIRTUAL_INTERFACE_GROUP_ASSOCIATION
NATGATEWAY = ResourceType.NATGATEWAY
NETWORK_ACL = ResourceType.NETWORK_ACL
NETWORK_INTERFACE = ResourceType.NETWORK_INTERFACE
NETWORK_INSIGHTS_ANALYSIS = ResourceType.NETWORK_INSIGHTS_ANALYSIS
NETWORK_INSIGHTS_PATH = ResourceType.NETWORK_INSIGHTS_PATH
NETWORK_INSIGHTS_ACCESS_SCOPE = ResourceType.NETWORK_INSIGHTS_ACCESS_SCOPE
NETWORK_INSIGHTS_ACCESS_SCOPE_ANALYSIS = ResourceType.NETWORK_INSIGHTS_ACCESS_SCOPE_ANALYSIS
OUTPOST_LAG = ResourceType.OUTPOST_LAG
PLACEMENT_GROUP = ResourceType.PLACEMENT_GROUP
PREFIX_LIST = ResourceType.PREFIX_LIST
REPLACE_ROOT_VOLUME_TASK = ResourceType.REPLACE_ROOT_VOLUME_TASK
RESERVED_INSTANCES = ResourceType.RESERVED_INSTANCES
ROUTE_TABLE = ResourceType.ROUTE_TABLE
SECURITY_GROUP = ResourceType.SECURITY_GROUP
SECURITY_GROUP_RULE = ResourceType.SECURITY_GROUP_RULE
SERVICE_LINK_VIRTUAL_INTERFACE = ResourceType.SERVICE_LINK_VIRTUAL_INTERFACE
SNAPSHOT = ResourceType.SNAPSHOT
SPOT_FLEET_REQUEST = ResourceType.SPOT_FLEET_REQUEST
SPOT_INSTANCES_REQUEST = ResourceType.SPOT_INSTANCES_REQUEST
SUBNET = ResourceType.SUBNET
SUBNET_CIDR_RESERVATION = ResourceType.SUBNET_CIDR_RESERVATION
TRAFFIC_MIRROR_FILTER = ResourceType.TRAFFIC_MIRROR_FILTER
TRAFFIC_MIRROR_SESSION = ResourceType.TRAFFIC_MIRROR_SESSION
TRAFFIC_MIRROR_TARGET = ResourceType.TRAFFIC_MIRROR_TARGET
TRANSIT_GATEWAY = ResourceType.TRANSIT_GATEWAY
TRANSIT_GATEWAY_ATTACHMENT = ResourceType.TRANSIT_GATEWAY_ATTACHMENT
TRANSIT_GATEWAY_CONNECT_PEER = ResourceType.TRANSIT_GATEWAY_CONNECT_PEER
TRANSIT_GATEWAY_MULTICAST_DOMAIN = ResourceType.TRANSIT_GATEWAY_MULTICAST_DOMAIN
TRANSIT_GATEWAY_POLICY_TABLE = ResourceType.TRANSIT_GATEWAY_POLICY_TABLE
TRANSIT_GATEWAY_METERING_POLICY = ResourceType.TRANSIT_GATEWAY_METERING_POLICY
TRANSIT_GATEWAY_ROUTE_TABLE = ResourceType.TRANSIT_GATEWAY_ROUTE_TABLE
TRANSIT_GATEWAY_ROUTE_TABLE_ANNOUNCEMENT = ResourceType.TRANSIT_GATEWAY_ROUTE_TABLE_ANNOUNCEMENT
VOLUME = ResourceType.VOLUME
VPC = ResourceType.VPC
VPC_ENDPOINT = ResourceType.VPC_ENDPOINT
VPC_ENDPOINT_CONNECTION = ResourceType.VPC_ENDPOINT_CONNECTION
VPC_ENDPOINT_SERVICE = ResourceType.VPC_ENDPOINT_SERVICE
VPC_ENDPOINT_SERVICE_PERMISSION = ResourceType.VPC_ENDPOINT_SERVICE_PERMISSION
VPC_PEERING_CONNECTION = ResourceType.VPC_PEERING_CONNECTION
VPN_CONNECTION = ResourceType.VPN_CONNECTION
VPN_GATEWAY = ResourceType.VPN_GATEWAY
VPC_FLOW_LOG = ResourceType.VPC_FLOW_LOG
CAPACITY_RESERVATION_FLEET = ResourceType.CAPACITY_RESERVATION_FLEET
TRAFFIC_MIRROR_FILTER_RULE = ResourceType.TRAFFIC_MIRROR_FILTER_RULE
VPC_ENDPOINT_CONNECTION_DEVICE_TYPE = ResourceType.VPC_ENDPOINT_CONNECTION_DEVICE_TYPE
VERIFIED_ACCESS_INSTANCE = ResourceType.VERIFIED_ACCESS_INSTANCE
VERIFIED_ACCESS_GROUP = ResourceType.VERIFIED_ACCESS_GROUP
VERIFIED_ACCESS_ENDPOINT = ResourceType.VERIFIED_ACCESS_ENDPOINT
VERIFIED_ACCESS_POLICY = ResourceType.VERIFIED_ACCESS_POLICY
VERIFIED_ACCESS_TRUST_PROVIDER = ResourceType.VERIFIED_ACCESS_TRUST_PROVIDER
VPN_CONNECTION_DEVICE_TYPE = ResourceType.VPN_CONNECTION_DEVICE_TYPE
VPC_BLOCK_PUBLIC_ACCESS_EXCLUSION = ResourceType.VPC_BLOCK_PUBLIC_ACCESS_EXCLUSION
VPC_ENCRYPTION_CONTROL = ResourceType.VPC_ENCRYPTION_CONTROL
ROUTE_SERVER = ResourceType.ROUTE_SERVER
ROUTE_SERVER_ENDPOINT = ResourceType.ROUTE_SERVER_ENDPOINT
ROUTE_SERVER_PEER = ResourceType.ROUTE_SERVER_PEER
IPAM_RESOURCE_DISCOVERY = ResourceType.IPAM_RESOURCE_DISCOVERY
IPAM_RESOURCE_DISCOVERY_ASSOCIATION = ResourceType.IPAM_RESOURCE_DISCOVERY_ASSOCIATION
INSTANCE_CONNECT_ENDPOINT = ResourceType.INSTANCE_CONNECT_ENDPOINT
VERIFIED_ACCESS_ENDPOINT_TARGET = ResourceType.VERIFIED_ACCESS_ENDPOINT_TARGET
IPAM_EXTERNAL_RESOURCE_VERIFICATION_TOKEN = ResourceType.IPAM_EXTERNAL_RESOURCE_VERIFICATION_TOKEN
CAPACITY_BLOCK = ResourceType.CAPACITY_BLOCK
MAC_MODIFICATION_TASK = ResourceType.MAC_MODIFICATION_TASK
IPAM_PREFIX_LIST_RESOLVER = ResourceType.IPAM_PREFIX_LIST_RESOLVER
IPAM_POLICY = ResourceType.IPAM_POLICY
IPAM_PREFIX_LIST_RESOLVER_TARGET = ResourceType.IPAM_PREFIX_LIST_RESOLVER_TARGET
CAPACITY_MANAGER_DATA_EXPORT = ResourceType.CAPACITY_MANAGER_DATA_EXPORT
VPN_CONCENTRATOR = ResourceType.VPN_CONCENTRATOR
EBS = RootDeviceType.EBS
INSTANCE_STORE = RootDeviceType.INSTANCE_STORE
CREATEROUTETABLE = RouteOrigin.CREATEROUTETABLE
CREATEROUTE = RouteOrigin.CREATEROUTE
ENABLEVGWROUTEPROPAGATION = RouteOrigin.ENABLEVGWROUTEPROPAGATION
ADVERTISEMENT = RouteOrigin.ADVERTISEMENT
ASSOCIATING = RouteServerAssociationState.ASSOCIATING
ASSOCIATED = RouteServerAssociationState.ASSOCIATED
DISASSOCIATING = RouteServerAssociationState.DISASSOCIATING
UP = RouteServerBfdState.UP
DOWN = RouteServerBfdState.DOWN
UP = RouteServerBgpState.UP
DOWN = RouteServerBgpState.DOWN
PENDING = RouteServerEndpointState.PENDING
AVAILABLE = RouteServerEndpointState.AVAILABLE
DELETING = RouteServerEndpointState.DELETING
DELETED = RouteServerEndpointState.DELETED
FAILING = RouteServerEndpointState.FAILING
FAILED = RouteServerEndpointState.FAILED
DELETE_FAILED = RouteServerEndpointState.DELETE_FAILED
BFD = RouteServerPeerLivenessMode.BFD
BGP_KEEPALIVE = RouteServerPeerLivenessMode.BGP_KEEPALIVE
PENDING = RouteServerPeerState.PENDING
AVAILABLE = RouteServerPeerState.AVAILABLE
DELETING = RouteServerPeerState.DELETING
DELETED = RouteServerPeerState.DELETED
FAILING = RouteServerPeerState.FAILING
FAILED = RouteServerPeerState.FAILED
ENABLE = RouteServerPersistRoutesAction.ENABLE
DISABLE = RouteServerPersistRoutesAction.DISABLE
RESET = RouteServerPersistRoutesAction.RESET
ENABLING = RouteServerPersistRoutesState.ENABLING
ENABLED = RouteServerPersistRoutesState.ENABLED
RESETTING = RouteServerPersistRoutesState.RESETTING
DISABLING = RouteServerPersistRoutesState.DISABLING
DISABLED = RouteServerPersistRoutesState.DISABLED
MODIFYING = RouteServerPersistRoutesState.MODIFYING
PENDING = RouteServerPropagationState.PENDING
AVAILABLE = RouteServerPropagationState.AVAILABLE
DELETING = RouteServerPropagationState.DELETING
INSTALLED = RouteServerRouteInstallationStatus.INSTALLED
REJECTED = RouteServerRouteInstallationStatus.REJECTED
IN_RIB = RouteServerRouteStatus.IN_RIB
IN_FIB = RouteServerRouteStatus.IN_FIB
PENDING = RouteServerState.PENDING
AVAILABLE = RouteServerState.AVAILABLE
MODIFYING = RouteServerState.MODIFYING
DELETING = RouteServerState.DELETING
DELETED = RouteServerState.DELETED
ACTIVE = RouteState.ACTIVE
BLACKHOLE = RouteState.BLACKHOLE
FILTERED = RouteState.FILTERED
ASSOCIATING = RouteTableAssociationStateCode.ASSOCIATING
ASSOCIATED = RouteTableAssociationStateCode.ASSOCIATED
DISASSOCIATING = RouteTableAssociationStateCode.DISASSOCIATING
DISASSOCIATED = RouteTableAssociationStateCode.DISASSOCIATED
FAILED = RouteTableAssociationStateCode.FAILED
ALLOW = RuleAction.ALLOW
DENY = RuleAction.DENY
SSE_EBS = SSEType.SSE_EBS
SSE_KMS = SSEType.SSE_KMS
NONE = SSEType.NONE
HOURLY = Schedule.HOURLY
ENABLE = SecurityGroupReferencingSupportValue.ENABLE
DISABLE = SecurityGroupReferencingSupportValue.DISABLE
ASSOCIATING = SecurityGroupVpcAssociationState.ASSOCIATING
ASSOCIATED = SecurityGroupVpcAssociationState.ASSOCIATED
ASSOCIATION_FAILED = SecurityGroupVpcAssociationState.ASSOCIATION_FAILED
DISASSOCIATING = SecurityGroupVpcAssociationState.DISASSOCIATING
DISASSOCIATED = SecurityGroupVpcAssociationState.DISASSOCIATED
DISASSOCIATION_FAILED = SecurityGroupVpcAssociationState.DISASSOCIATION_FAILED
ENABLED = SelfServicePortal.ENABLED
DISABLED = SelfServicePortal.DISABLED
IPV4 = ServiceConnectivityType.IPV4
IPV6 = ServiceConnectivityType.IPV6
PENDING = ServiceLinkVirtualInterfaceConfigurationState.PENDING
AVAILABLE = ServiceLinkVirtualInterfaceConfigurationState.AVAILABLE
DELETING = ServiceLinkVirtualInterfaceConfigurationState.DELETING
DELETED = ServiceLinkVirtualInterfaceConfigurationState.DELETED
ALB = ServiceManaged.ALB
NLB = ServiceManaged.NLB
RNAT = ServiceManaged.RNAT
RDS = ServiceManaged.RDS
PENDING = ServiceState.PENDING
AVAILABLE = ServiceState.AVAILABLE
DELETING = ServiceState.DELETING
DELETED = ServiceState.DELETED
FAILED = ServiceState.FAILED
INTERFACE = ServiceType.INTERFACE
GATEWAY = ServiceType.GATEWAY
GATEWAYLOADBALANCER = ServiceType.GATEWAYLOADBALANCER
STOP = ShutdownBehavior.STOP
TERMINATE = ShutdownBehavior.TERMINATE
PRODUCTCODES = SnapshotAttributeName.PRODUCTCODES
CREATEVOLUMEPERMISSION = SnapshotAttributeName.CREATEVOLUMEPERMISSION
BLOCK_ALL_SHARING = SnapshotBlockPublicAccessState.BLOCK_ALL_SHARING
BLOCK_NEW_SHARING = SnapshotBlockPublicAccessState.BLOCK_NEW_SHARING
UNBLOCKED = SnapshotBlockPublicAccessState.UNBLOCKED
REGIONAL = SnapshotLocationEnum.REGIONAL
LOCAL = SnapshotLocationEnum.LOCAL
SUCCESS = SnapshotReturnCodes.SUCCESS
SKIPPED = SnapshotReturnCodes.SKIPPED
MISSING_PERMISSIONS = SnapshotReturnCodes.MISSING_PERMISSIONS
INTERNAL_ERROR = SnapshotReturnCodes.INTERNAL_ERROR
CLIENT_ERROR = SnapshotReturnCodes.CLIENT_ERROR
PENDING = SnapshotState.PENDING
COMPLETED = SnapshotState.COMPLETED
ERROR = SnapshotState.ERROR
RECOVERABLE = SnapshotState.RECOVERABLE
RECOVERING = SnapshotState.RECOVERING
LOWEST_PRICE = SpotAllocationStrategy.LOWEST_PRICE
DIVERSIFIED = SpotAllocationStrategy.DIVERSIFIED
CAPACITY_OPTIMIZED = SpotAllocationStrategy.CAPACITY_OPTIMIZED
CAPACITY_OPTIMIZED_PRIORITIZED = SpotAllocationStrategy.CAPACITY_OPTIMIZED_PRIORITIZED
PRICE_CAPACITY_OPTIMIZED = SpotAllocationStrategy.PRICE_CAPACITY_OPTIMIZED
HIBERNATE = SpotInstanceInterruptionBehavior.HIBERNATE
STOP = SpotInstanceInterruptionBehavior.STOP
TERMINATE = SpotInstanceInterruptionBehavior.TERMINATE
OPEN = SpotInstanceState.OPEN
ACTIVE = SpotInstanceState.ACTIVE
CLOSED = SpotInstanceState.CLOSED
CANCELLED = SpotInstanceState.CANCELLED
FAILED = SpotInstanceState.FAILED
DISABLED = SpotInstanceState.DISABLED
ONE_TIME = SpotInstanceType.ONE_TIME
PERSISTENT = SpotInstanceType.PERSISTENT
HOST = SpreadLevel.HOST
RACK = SpreadLevel.RACK
FULL = SqlServerLicenseUsage.FULL
WAIVED = SqlServerLicenseUsage.WAIVED
PENDINGACCEPTANCE = State.PENDINGACCEPTANCE
PENDING = State.PENDING
AVAILABLE = State.AVAILABLE
DELETING = State.DELETING
DELETED = State.DELETED
REJECTED = State.REJECTED
FAILED = State.FAILED
EXPIRED = State.EXPIRED
PARTIAL = State.PARTIAL
ENABLE = StaticSourcesSupportValue.ENABLE
DISABLE = StaticSourcesSupportValue.DISABLE
P50 = StatisticType.P50
MOVEINPROGRESS = Status.MOVEINPROGRESS
INVPC = Status.INVPC
INCLASSIC = Status.INCLASSIC
REACHABILITY = StatusName.REACHABILITY
PASSED = StatusType.PASSED
FAILED = StatusType.FAILED
INSUFFICIENT_DATA = StatusType.INSUFFICIENT_DATA
INITIALIZING = StatusType.INITIALIZING
ARCHIVE = StorageTier.ARCHIVE
STANDARD = StorageTier.STANDARD
ASSOCIATING = SubnetCidrBlockStateCode.ASSOCIATING
ASSOCIATED = SubnetCidrBlockStateCode.ASSOCIATED
DISASSOCIATING = SubnetCidrBlockStateCode.DISASSOCIATING
DISASSOCIATED = SubnetCidrBlockStateCode.DISASSOCIATED
FAILING = SubnetCidrBlockStateCode.FAILING
FAILED = SubnetCidrBlockStateCode.FAILED
PREFIX = SubnetCidrReservationType.PREFIX
EXPLICIT = SubnetCidrReservationType.EXPLICIT
PENDING = SubnetState.PENDING
AVAILABLE = SubnetState.AVAILABLE
UNAVAILABLE = SubnetState.UNAVAILABLE
FAILED = SubnetState.FAILED
FAILED_INSUFFICIENT_CAPACITY = SubnetState.FAILED_INSUFFICIENT_CAPACITY
OK = SummaryStatus.OK
IMPAIRED = SummaryStatus.IMPAIRED
INSUFFICIENT_DATA = SummaryStatus.INSUFFICIENT_DATA
NOT_APPLICABLE = SummaryStatus.NOT_APPLICABLE
INITIALIZING = SummaryStatus.INITIALIZING
AMD_SEV_SNP = SupportedAdditionalProcessorFeature.AMD_SEV_SNP
VCPU = TargetCapacityUnitType.VCPU
MEMORY_MIB = TargetCapacityUnitType.MEMORY_MIB
UNITS = TargetCapacityUnitType.UNITS
ARCHIVE = TargetStorageTier.ARCHIVE
UP = TelemetryStatus.UP
DOWN = TelemetryStatus.DOWN
DEFAULT = Tenancy.DEFAULT
DEDICATED = Tenancy.DEDICATED
HOST = Tenancy.HOST
ARCHIVAL_IN_PROGRESS = TieringOperationStatus.ARCHIVAL_IN_PROGRESS
ARCHIVAL_COMPLETED = TieringOperationStatus.ARCHIVAL_COMPLETED
ARCHIVAL_FAILED = TieringOperationStatus.ARCHIVAL_FAILED
TEMPORARY_RESTORE_IN_PROGRESS = TieringOperationStatus.TEMPORARY_RESTORE_IN_PROGRESS
TEMPORARY_RESTORE_COMPLETED = TieringOperationStatus.TEMPORARY_RESTORE_COMPLETED
TEMPORARY_RESTORE_FAILED = TieringOperationStatus.TEMPORARY_RESTORE_FAILED
PERMANENT_RESTORE_IN_PROGRESS = TieringOperationStatus.PERMANENT_RESTORE_IN_PROGRESS
PERMANENT_RESTORE_COMPLETED = TieringOperationStatus.PERMANENT_RESTORE_COMPLETED
PERMANENT_RESTORE_FAILED = TieringOperationStatus.PERMANENT_RESTORE_FAILED
VALID = TokenState.VALID
EXPIRED = TokenState.EXPIRED
V2_0 = TpmSupportValues.V2_0
INGRESS = TrafficDirection.INGRESS
EGRESS = TrafficDirection.EGRESS
IPV4 = TrafficIpAddressType.IPV4
IPV6 = TrafficIpAddressType.IPV6
DUAL_STACK = TrafficIpAddressType.DUAL_STACK
DESTINATION_PORT_RANGE = TrafficMirrorFilterRuleField.DESTINATION_PORT_RANGE
SOURCE_PORT_RANGE = TrafficMirrorFilterRuleField.SOURCE_PORT_RANGE
PROTOCOL = TrafficMirrorFilterRuleField.PROTOCOL
DESCRIPTION = TrafficMirrorFilterRuleField.DESCRIPTION
AMAZON_DNS = TrafficMirrorNetworkService.AMAZON_DNS
ACCEPT = TrafficMirrorRuleAction.ACCEPT
REJECT = TrafficMirrorRuleAction.REJECT
PACKET_LENGTH = TrafficMirrorSessionField.PACKET_LENGTH
DESCRIPTION = TrafficMirrorSessionField.DESCRIPTION
VIRTUAL_NETWORK_ID = TrafficMirrorSessionField.VIRTUAL_NETWORK_ID
NETWORK_INTERFACE = TrafficMirrorTargetType.NETWORK_INTERFACE
NETWORK_LOAD_BALANCER = TrafficMirrorTargetType.NETWORK_LOAD_BALANCER
GATEWAY_LOAD_BALANCER_ENDPOINT = TrafficMirrorTargetType.GATEWAY_LOAD_BALANCER_ENDPOINT
ACCEPT = TrafficType.ACCEPT
REJECT = TrafficType.REJECT
ALL = TrafficType.ALL
TIME_BASED = TransferType.TIME_BASED
STANDARD = TransferType.STANDARD
ASSOCIATING = TransitGatewayAssociationState.ASSOCIATING
ASSOCIATED = TransitGatewayAssociationState.ASSOCIATED
DISASSOCIATING = TransitGatewayAssociationState.DISASSOCIATING
DISASSOCIATED = TransitGatewayAssociationState.DISASSOCIATED
VPC = TransitGatewayAttachmentResourceType.VPC
VPN = TransitGatewayAttachmentResourceType.VPN
VPN_CONCENTRATOR = TransitGatewayAttachmentResourceType.VPN_CONCENTRATOR
DIRECT_CONNECT_GATEWAY = TransitGatewayAttachmentResourceType.DIRECT_CONNECT_GATEWAY
CONNECT = TransitGatewayAttachmentResourceType.CONNECT
PEERING = TransitGatewayAttachmentResourceType.PEERING
TGW_PEERING = TransitGatewayAttachmentResourceType.TGW_PEERING
NETWORK_FUNCTION = TransitGatewayAttachmentResourceType.NETWORK_FUNCTION
INITIATING = TransitGatewayAttachmentState.INITIATING
INITIATINGREQUEST = TransitGatewayAttachmentState.INITIATINGREQUEST
PENDINGACCEPTANCE = TransitGatewayAttachmentState.PENDINGACCEPTANCE
ROLLINGBACK = TransitGatewayAttachmentState.ROLLINGBACK
PENDING = TransitGatewayAttachmentState.PENDING
AVAILABLE = TransitGatewayAttachmentState.AVAILABLE
MODIFYING = TransitGatewayAttachmentState.MODIFYING
DELETING = TransitGatewayAttachmentState.DELETING
DELETED = TransitGatewayAttachmentState.DELETED
FAILED = TransitGatewayAttachmentState.FAILED
REJECTED = TransitGatewayAttachmentState.REJECTED
REJECTING = TransitGatewayAttachmentState.REJECTING
FAILING = TransitGatewayAttachmentState.FAILING
PENDING = TransitGatewayConnectPeerState.PENDING
AVAILABLE = TransitGatewayConnectPeerState.AVAILABLE
DELETING = TransitGatewayConnectPeerState.DELETING
DELETED = TransitGatewayConnectPeerState.DELETED
SOURCE_ATTACHMENT_OWNER = TransitGatewayMeteringPayerType.SOURCE_ATTACHMENT_OWNER
DESTINATION_ATTACHMENT_OWNER = TransitGatewayMeteringPayerType.DESTINATION_ATTACHMENT_OWNER
TRANSIT_GATEWAY_OWNER = TransitGatewayMeteringPayerType.TRANSIT_GATEWAY_OWNER
AVAILABLE = TransitGatewayMeteringPolicyEntryState.AVAILABLE
DELETED = TransitGatewayMeteringPolicyEntryState.DELETED
AVAILABLE = TransitGatewayMeteringPolicyState.AVAILABLE
DELETED = TransitGatewayMeteringPolicyState.DELETED
PENDING = TransitGatewayMeteringPolicyState.PENDING
MODIFYING = TransitGatewayMeteringPolicyState.MODIFYING
DELETING = TransitGatewayMeteringPolicyState.DELETING
PENDINGACCEPTANCE = TransitGatewayMulitcastDomainAssociationState.PENDINGACCEPTANCE
ASSOCIATING = TransitGatewayMulitcastDomainAssociationState.ASSOCIATING
ASSOCIATED = TransitGatewayMulitcastDomainAssociationState.ASSOCIATED
DISASSOCIATING = TransitGatewayMulitcastDomainAssociationState.DISASSOCIATING
DISASSOCIATED = TransitGatewayMulitcastDomainAssociationState.DISASSOCIATED
REJECTED = TransitGatewayMulitcastDomainAssociationState.REJECTED
FAILED = TransitGatewayMulitcastDomainAssociationState.FAILED
PENDING = TransitGatewayMulticastDomainState.PENDING
AVAILABLE = TransitGatewayMulticastDomainState.AVAILABLE
DELETING = TransitGatewayMulticastDomainState.DELETING
DELETED = TransitGatewayMulticastDomainState.DELETED
PENDING = TransitGatewayPolicyTableState.PENDING
AVAILABLE = TransitGatewayPolicyTableState.AVAILABLE
DELETING = TransitGatewayPolicyTableState.DELETING
DELETED = TransitGatewayPolicyTableState.DELETED
PENDING = TransitGatewayPrefixListReferenceState.PENDING
AVAILABLE = TransitGatewayPrefixListReferenceState.AVAILABLE
MODIFYING = TransitGatewayPrefixListReferenceState.MODIFYING
DELETING = TransitGatewayPrefixListReferenceState.DELETING
ENABLING = TransitGatewayPropagationState.ENABLING
ENABLED = TransitGatewayPropagationState.ENABLED
DISABLING = TransitGatewayPropagationState.DISABLING
DISABLED = TransitGatewayPropagationState.DISABLED
PENDING = TransitGatewayRouteState.PENDING
ACTIVE = TransitGatewayRouteState.ACTIVE
BLACKHOLE = TransitGatewayRouteState.BLACKHOLE
DELETING = TransitGatewayRouteState.DELETING
DELETED = TransitGatewayRouteState.DELETED
OUTGOING = TransitGatewayRouteTableAnnouncementDirection.OUTGOING
INCOMING = TransitGatewayRouteTableAnnouncementDirection.INCOMING
AVAILABLE = TransitGatewayRouteTableAnnouncementState.AVAILABLE
PENDING = TransitGatewayRouteTableAnnouncementState.PENDING
FAILING = TransitGatewayRouteTableAnnouncementState.FAILING
FAILED = TransitGatewayRouteTableAnnouncementState.FAILED
DELETING = TransitGatewayRouteTableAnnouncementState.DELETING
DELETED = TransitGatewayRouteTableAnnouncementState.DELETED
PENDING = TransitGatewayRouteTableState.PENDING
AVAILABLE = TransitGatewayRouteTableState.AVAILABLE
DELETING = TransitGatewayRouteTableState.DELETING
DELETED = TransitGatewayRouteTableState.DELETED
STATIC = TransitGatewayRouteType.STATIC
PROPAGATED = TransitGatewayRouteType.PROPAGATED
PENDING = TransitGatewayState.PENDING
AVAILABLE = TransitGatewayState.AVAILABLE
MODIFYING = TransitGatewayState.MODIFYING
DELETING = TransitGatewayState.DELETING
DELETED = TransitGatewayState.DELETED
TCP = TransportProtocol.TCP
UDP = TransportProtocol.UDP
USER = TrustProviderType.USER
DEVICE = TrustProviderType.DEVICE
IPV4 = TunnelInsideIpVersion.IPV4
IPV6 = TunnelInsideIpVersion.IPV6
T2 = UnlimitedSupportedInstanceFamily.T2
T3 = UnlimitedSupportedInstanceFamily.T3
T3A = UnlimitedSupportedInstanceFamily.T3A
T4G = UnlimitedSupportedInstanceFamily.T4G
INVALIDINSTANCEID_MALFORMED = UnsuccessfulInstanceCreditSpecificationErrorCode.INVALIDINSTANCEID_MALFORMED
INVALIDINSTANCEID_NOTFOUND = UnsuccessfulInstanceCreditSpecificationErrorCode.INVALIDINSTANCEID_NOTFOUND
INCORRECTINSTANCESTATE = UnsuccessfulInstanceCreditSpecificationErrorCode.INCORRECTINSTANCESTATE
INSTANCECREDITSPECIFICATION_NOTSUPPORTED = UnsuccessfulInstanceCreditSpecificationErrorCode.INSTANCECREDITSPECIFICATION_NOTSUPPORTED
SPOT = UsageClassType.SPOT
ON_DEMAND = UsageClassType.ON_DEMAND
CAPACITY_BLOCK = UsageClassType.CAPACITY_BLOCK
IAM_IDENTITY_CENTER = UserTrustProviderType.IAM_IDENTITY_CENTER
OIDC = UserTrustProviderType.OIDC
REMARKS_X509 = VerificationMethod.REMARKS_X509
DNS_TOKEN = VerificationMethod.DNS_TOKEN
VPC = VerifiedAccessEndpointAttachmentType.VPC
HTTP = VerifiedAccessEndpointProtocol.HTTP
HTTPS = VerifiedAccessEndpointProtocol.HTTPS
TCP = VerifiedAccessEndpointProtocol.TCP
PENDING = VerifiedAccessEndpointStatusCode.PENDING
ACTIVE = VerifiedAccessEndpointStatusCode.ACTIVE
UPDATING = VerifiedAccessEndpointStatusCode.UPDATING
DELETING = VerifiedAccessEndpointStatusCode.DELETING
DELETED = VerifiedAccessEndpointStatusCode.DELETED
LOAD_BALANCER = VerifiedAccessEndpointType.LOAD_BALANCER
NETWORK_INTERFACE = VerifiedAccessEndpointType.NETWORK_INTERFACE
RDS = VerifiedAccessEndpointType.RDS
CIDR = VerifiedAccessEndpointType.CIDR
SUCCESS = VerifiedAccessLogDeliveryStatusCode.SUCCESS
FAILED = VerifiedAccessLogDeliveryStatusCode.FAILED
HVM = VirtualizationType.HVM
PARAVIRTUAL = VirtualizationType.PARAVIRTUAL
ATTACHING = VolumeAttachmentState.ATTACHING
ATTACHED = VolumeAttachmentState.ATTACHED
DETACHING = VolumeAttachmentState.DETACHING
DETACHED = VolumeAttachmentState.DETACHED
BUSY = VolumeAttachmentState.BUSY
AUTOENABLEIO = VolumeAttributeName.AUTOENABLEIO
PRODUCTCODES = VolumeAttributeName.PRODUCTCODES
MODIFYING = VolumeModificationState.MODIFYING
OPTIMIZING = VolumeModificationState.OPTIMIZING
COMPLETED = VolumeModificationState.COMPLETED
FAILED = VolumeModificationState.FAILED
CREATING = VolumeState.CREATING
AVAILABLE = VolumeState.AVAILABLE
IN_USE = VolumeState.IN_USE
DELETING = VolumeState.DELETING
DELETED = VolumeState.DELETED
ERROR = VolumeState.ERROR
OK = VolumeStatusInfoStatus.OK
IMPAIRED = VolumeStatusInfoStatus.IMPAIRED
INSUFFICIENT_DATA = VolumeStatusInfoStatus.INSUFFICIENT_DATA
WARNING = VolumeStatusInfoStatus.WARNING
IO_ENABLED = VolumeStatusName.IO_ENABLED
IO_PERFORMANCE = VolumeStatusName.IO_PERFORMANCE
INITIALIZATION_STATE = VolumeStatusName.INITIALIZATION_STATE
STANDARD = VolumeType.STANDARD
IO1 = VolumeType.IO1
IO2 = VolumeType.IO2
GP2 = VolumeType.GP2
SC1 = VolumeType.SC1
ST1 = VolumeType.ST1
GP3 = VolumeType.GP3
ENABLEDNSSUPPORT = VpcAttributeName.ENABLEDNSSUPPORT
ENABLEDNSHOSTNAMES = VpcAttributeName.ENABLEDNSHOSTNAMES
ENABLENETWORKADDRESSUSAGEMETRICS = VpcAttributeName.ENABLENETWORKADDRESSUSAGEMETRICS
CREATE_IN_PROGRESS = VpcBlockPublicAccessExclusionState.CREATE_IN_PROGRESS
CREATE_COMPLETE = VpcBlockPublicAccessExclusionState.CREATE_COMPLETE
CREATE_FAILED = VpcBlockPublicAccessExclusionState.CREATE_FAILED
UPDATE_IN_PROGRESS = VpcBlockPublicAccessExclusionState.UPDATE_IN_PROGRESS
UPDATE_COMPLETE = VpcBlockPublicAccessExclusionState.UPDATE_COMPLETE
UPDATE_FAILED = VpcBlockPublicAccessExclusionState.UPDATE_FAILED
DELETE_IN_PROGRESS = VpcBlockPublicAccessExclusionState.DELETE_IN_PROGRESS
DELETE_COMPLETE = VpcBlockPublicAccessExclusionState.DELETE_COMPLETE
DISABLE_IN_PROGRESS = VpcBlockPublicAccessExclusionState.DISABLE_IN_PROGRESS
DISABLE_COMPLETE = VpcBlockPublicAccessExclusionState.DISABLE_COMPLETE
ALLOWED = VpcBlockPublicAccessExclusionsAllowed.ALLOWED
NOT_ALLOWED = VpcBlockPublicAccessExclusionsAllowed.NOT_ALLOWED
DEFAULT_STATE = VpcBlockPublicAccessState.DEFAULT_STATE
UPDATE_IN_PROGRESS = VpcBlockPublicAccessState.UPDATE_IN_PROGRESS
UPDATE_COMPLETE = VpcBlockPublicAccessState.UPDATE_COMPLETE
ASSOCIATING = VpcCidrBlockStateCode.ASSOCIATING
ASSOCIATED = VpcCidrBlockStateCode.ASSOCIATED
DISASSOCIATING = VpcCidrBlockStateCode.DISASSOCIATING
DISASSOCIATED = VpcCidrBlockStateCode.DISASSOCIATED
FAILING = VpcCidrBlockStateCode.FAILING
FAILED = VpcCidrBlockStateCode.FAILED
ENABLING = VpcEncryptionControlExclusionState.ENABLING
ENABLED = VpcEncryptionControlExclusionState.ENABLED
DISABLING = VpcEncryptionControlExclusionState.DISABLING
DISABLED = VpcEncryptionControlExclusionState.DISABLED
ENABLE = VpcEncryptionControlExclusionStateInput.ENABLE
DISABLE = VpcEncryptionControlExclusionStateInput.DISABLE
MONITOR = VpcEncryptionControlMode.MONITOR
ENFORCE = VpcEncryptionControlMode.ENFORCE
ENFORCE_IN_PROGRESS = VpcEncryptionControlState.ENFORCE_IN_PROGRESS
MONITOR_IN_PROGRESS = VpcEncryptionControlState.MONITOR_IN_PROGRESS
ENFORCE_FAILED = VpcEncryptionControlState.ENFORCE_FAILED
MONITOR_FAILED = VpcEncryptionControlState.MONITOR_FAILED
DELETING = VpcEncryptionControlState.DELETING
DELETED = VpcEncryptionControlState.DELETED
AVAILABLE = VpcEncryptionControlState.AVAILABLE
CREATING = VpcEncryptionControlState.CREATING
DELETE_FAILED = VpcEncryptionControlState.DELETE_FAILED
INTERFACE = VpcEndpointType.INTERFACE
GATEWAY = VpcEndpointType.GATEWAY
GATEWAYLOADBALANCER = VpcEndpointType.GATEWAYLOADBALANCER
RESOURCE = VpcEndpointType.RESOURCE
SERVICENETWORK = VpcEndpointType.SERVICENETWORK
INITIATING_REQUEST = VpcPeeringConnectionStateReasonCode.INITIATING_REQUEST
PENDING_ACCEPTANCE = VpcPeeringConnectionStateReasonCode.PENDING_ACCEPTANCE
ACTIVE = VpcPeeringConnectionStateReasonCode.ACTIVE
DELETED = VpcPeeringConnectionStateReasonCode.DELETED
REJECTED = VpcPeeringConnectionStateReasonCode.REJECTED
FAILED = VpcPeeringConnectionStateReasonCode.FAILED
EXPIRED = VpcPeeringConnectionStateReasonCode.EXPIRED
PROVISIONING = VpcPeeringConnectionStateReasonCode.PROVISIONING
DELETING = VpcPeeringConnectionStateReasonCode.DELETING
PENDING = VpcState.PENDING
AVAILABLE = VpcState.AVAILABLE
DEFAULT = VpcTenancy.DEFAULT
IPSEC_1 = VpnConcentratorType.IPSEC_1
ENABLE = VpnEcmpSupportValue.ENABLE
DISABLE = VpnEcmpSupportValue.DISABLE
OPENVPN = VpnProtocol.OPENVPN
PENDING = VpnState.PENDING
AVAILABLE = VpnState.AVAILABLE
DELETING = VpnState.DELETING
DELETED = VpnState.DELETED
STATIC = VpnStaticRouteSource.STATIC
STANDARD = VpnTunnelBandwidth.STANDARD
LARGE = VpnTunnelBandwidth.LARGE
AVAILABLE = VpnTunnelProvisioningStatus.AVAILABLE
PENDING = VpnTunnelProvisioningStatus.PENDING
FAILED = VpnTunnelProvisioningStatus.FAILED
SUNDAY = WeekDay.SUNDAY
MONDAY = WeekDay.MONDAY
TUESDAY = WeekDay.TUESDAY
WEDNESDAY = WeekDay.WEDNESDAY
THURSDAY = WeekDay.THURSDAY
FRIDAY = WeekDay.FRIDAY
SATURDAY = WeekDay.SATURDAY
AVAILABILITY_ZONE = scope.AVAILABILITY_ZONE
REGION = scope.REGION


@dataclass
class CapacityManagerDataExport(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::CapacityManagerDataExport"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    s3_bucket_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    schedule: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    output_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    s3_bucket_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_bucket_prefix is not None:
            # Serialize s3_bucket_prefix (handle intrinsic functions)
            if hasattr(self.s3_bucket_prefix, 'to_dict'):
                props["S3BucketPrefix"] = self.s3_bucket_prefix.to_dict()
            elif isinstance(self.s3_bucket_prefix, list):
                # Serialize list items (may contain intrinsic functions)
                props['S3BucketPrefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_bucket_prefix
                ]
            else:
                props["S3BucketPrefix"] = self.s3_bucket_prefix

        if self.schedule is not None:
            # Serialize schedule (handle intrinsic functions)
            if hasattr(self.schedule, 'to_dict'):
                props["Schedule"] = self.schedule.to_dict()
            elif isinstance(self.schedule, list):
                # Serialize list items (may contain intrinsic functions)
                props['Schedule'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schedule
                ]
            else:
                props["Schedule"] = self.schedule

        if self.output_format is not None:
            # Serialize output_format (handle intrinsic functions)
            if hasattr(self.output_format, 'to_dict'):
                props["OutputFormat"] = self.output_format.to_dict()
            elif isinstance(self.output_format, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutputFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_format
                ]
            else:
                props["OutputFormat"] = self.output_format

        if self.s3_bucket_name is not None:
            # Serialize s3_bucket_name (handle intrinsic functions)
            if hasattr(self.s3_bucket_name, 'to_dict'):
                props["S3BucketName"] = self.s3_bucket_name.to_dict()
            elif isinstance(self.s3_bucket_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['S3BucketName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_bucket_name
                ]
            else:
                props["S3BucketName"] = self.s3_bucket_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_capacity_manager_data_export_id(self) -> GetAtt:
        """Get the CapacityManagerDataExportId attribute."""
        return self.get_att("CapacityManagerDataExportId")




@dataclass
class CapacityAllocation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allocation_type: Optional[Union[str, AllocationType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.allocation_type is not None:
            if hasattr(self.allocation_type, 'to_dict'):
                props['AllocationType'] = self.allocation_type.to_dict()
            elif isinstance(self.allocation_type, list):
                props['AllocationType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_type
                ]
            else:
                props['AllocationType'] = self.allocation_type

        if self.count is not None:
            if hasattr(self.count, 'to_dict'):
                props['Count'] = self.count.to_dict()
            elif isinstance(self.count, list):
                props['Count'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.count
                ]
            else:
                props['Count'] = self.count

        return props


@dataclass
class CommitmentInfo:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    committed_instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    commitment_end_date: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.committed_instance_count is not None:
            if hasattr(self.committed_instance_count, 'to_dict'):
                props['CommittedInstanceCount'] = self.committed_instance_count.to_dict()
            elif isinstance(self.committed_instance_count, list):
                props['CommittedInstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.committed_instance_count
                ]
            else:
                props['CommittedInstanceCount'] = self.committed_instance_count

        if self.commitment_end_date is not None:
            if hasattr(self.commitment_end_date, 'to_dict'):
                props['CommitmentEndDate'] = self.commitment_end_date.to_dict()
            elif isinstance(self.commitment_end_date, list):
                props['CommitmentEndDate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.commitment_end_date
                ]
            else:
                props['CommitmentEndDate'] = self.commitment_end_date

        return props


@dataclass
class TagSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, ResourceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tags: Optional[list[Tag]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        if self.tags is not None:
            if hasattr(self.tags, 'to_dict'):
                props['Tags'] = self.tags.to_dict()
            elif isinstance(self.tags, list):
                props['Tags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tags
                ]
            else:
                props['Tags'] = self.tags

        return props


@dataclass
class CapacityReservation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::CapacityReservation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tenancy: Optional[Union[str, CapacityReservationTenancy, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    end_date_type: Optional[Union[str, EndDateType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tag_specifications: Optional[list[TagSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    unused_reservation_billing_owner_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    end_date: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ebs_optimized: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    out_post_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    placement_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_platform: Optional[Union[str, CapacityReservationInstancePlatform, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ephemeral_storage: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_match_criteria: Optional[Union[str, InstanceMatchCriteria, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.tenancy is not None:
            # Serialize tenancy (handle intrinsic functions)
            if hasattr(self.tenancy, 'to_dict'):
                props["Tenancy"] = self.tenancy.to_dict()
            elif isinstance(self.tenancy, list):
                # Serialize list items (may contain intrinsic functions)
                props['Tenancy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tenancy
                ]
            else:
                props["Tenancy"] = self.tenancy

        if self.end_date_type is not None:
            # Serialize end_date_type (handle intrinsic functions)
            if hasattr(self.end_date_type, 'to_dict'):
                props["EndDateType"] = self.end_date_type.to_dict()
            elif isinstance(self.end_date_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndDateType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.end_date_type
                ]
            else:
                props["EndDateType"] = self.end_date_type

        if self.tag_specifications is not None:
            # Serialize tag_specifications (handle intrinsic functions)
            if hasattr(self.tag_specifications, 'to_dict'):
                props["TagSpecifications"] = self.tag_specifications.to_dict()
            elif isinstance(self.tag_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['TagSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_specifications
                ]
            else:
                props["TagSpecifications"] = self.tag_specifications

        if self.unused_reservation_billing_owner_id is not None:
            # Serialize unused_reservation_billing_owner_id (handle intrinsic functions)
            if hasattr(self.unused_reservation_billing_owner_id, 'to_dict'):
                props["UnusedReservationBillingOwnerId"] = self.unused_reservation_billing_owner_id.to_dict()
            elif isinstance(self.unused_reservation_billing_owner_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['UnusedReservationBillingOwnerId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unused_reservation_billing_owner_id
                ]
            else:
                props["UnusedReservationBillingOwnerId"] = self.unused_reservation_billing_owner_id

        if self.availability_zone_id is not None:
            # Serialize availability_zone_id (handle intrinsic functions)
            if hasattr(self.availability_zone_id, 'to_dict'):
                props["AvailabilityZoneId"] = self.availability_zone_id.to_dict()
            elif isinstance(self.availability_zone_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZoneId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone_id
                ]
            else:
                props["AvailabilityZoneId"] = self.availability_zone_id

        if self.availability_zone is not None:
            # Serialize availability_zone (handle intrinsic functions)
            if hasattr(self.availability_zone, 'to_dict'):
                props["AvailabilityZone"] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props["AvailabilityZone"] = self.availability_zone

        if self.end_date is not None:
            # Serialize end_date (handle intrinsic functions)
            if hasattr(self.end_date, 'to_dict'):
                props["EndDate"] = self.end_date.to_dict()
            elif isinstance(self.end_date, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndDate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.end_date
                ]
            else:
                props["EndDate"] = self.end_date

        if self.ebs_optimized is not None:
            # Serialize ebs_optimized (handle intrinsic functions)
            if hasattr(self.ebs_optimized, 'to_dict'):
                props["EbsOptimized"] = self.ebs_optimized.to_dict()
            elif isinstance(self.ebs_optimized, list):
                # Serialize list items (may contain intrinsic functions)
                props['EbsOptimized'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_optimized
                ]
            else:
                props["EbsOptimized"] = self.ebs_optimized

        if self.out_post_arn is not None:
            # Serialize out_post_arn (handle intrinsic functions)
            if hasattr(self.out_post_arn, 'to_dict'):
                props["OutPostArn"] = self.out_post_arn.to_dict()
            elif isinstance(self.out_post_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutPostArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.out_post_arn
                ]
            else:
                props["OutPostArn"] = self.out_post_arn

        if self.instance_count is not None:
            # Serialize instance_count (handle intrinsic functions)
            if hasattr(self.instance_count, 'to_dict'):
                props["InstanceCount"] = self.instance_count.to_dict()
            elif isinstance(self.instance_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_count
                ]
            else:
                props["InstanceCount"] = self.instance_count

        if self.placement_group_arn is not None:
            # Serialize placement_group_arn (handle intrinsic functions)
            if hasattr(self.placement_group_arn, 'to_dict'):
                props["PlacementGroupArn"] = self.placement_group_arn.to_dict()
            elif isinstance(self.placement_group_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['PlacementGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.placement_group_arn
                ]
            else:
                props["PlacementGroupArn"] = self.placement_group_arn

        if self.instance_platform is not None:
            # Serialize instance_platform (handle intrinsic functions)
            if hasattr(self.instance_platform, 'to_dict'):
                props["InstancePlatform"] = self.instance_platform.to_dict()
            elif isinstance(self.instance_platform, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstancePlatform'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_platform
                ]
            else:
                props["InstancePlatform"] = self.instance_platform

        if self.instance_type is not None:
            # Serialize instance_type (handle intrinsic functions)
            if hasattr(self.instance_type, 'to_dict'):
                props["InstanceType"] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props["InstanceType"] = self.instance_type

        if self.ephemeral_storage is not None:
            # Serialize ephemeral_storage (handle intrinsic functions)
            if hasattr(self.ephemeral_storage, 'to_dict'):
                props["EphemeralStorage"] = self.ephemeral_storage.to_dict()
            elif isinstance(self.ephemeral_storage, list):
                # Serialize list items (may contain intrinsic functions)
                props['EphemeralStorage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ephemeral_storage
                ]
            else:
                props["EphemeralStorage"] = self.ephemeral_storage

        if self.instance_match_criteria is not None:
            # Serialize instance_match_criteria (handle intrinsic functions)
            if hasattr(self.instance_match_criteria, 'to_dict'):
                props["InstanceMatchCriteria"] = self.instance_match_criteria.to_dict()
            elif isinstance(self.instance_match_criteria, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceMatchCriteria'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_match_criteria
                ]
            else:
                props["InstanceMatchCriteria"] = self.instance_match_criteria

        return props

    @property
    def attr_tenancy(self) -> GetAtt:
        """Get the Tenancy attribute."""
        return self.get_att("Tenancy")

    @property
    def attr_commitment_info__committed_instance_count(self) -> GetAtt:
        """Get the CommitmentInfo.CommittedInstanceCount attribute."""
        return self.get_att("CommitmentInfo.CommittedInstanceCount")

    @property
    def attr_capacity_reservation_fleet_id(self) -> GetAtt:
        """Get the CapacityReservationFleetId attribute."""
        return self.get_att("CapacityReservationFleetId")

    @property
    def attr_availability_zone(self) -> GetAtt:
        """Get the AvailabilityZone attribute."""
        return self.get_att("AvailabilityZone")

    @property
    def attr_total_instance_count(self) -> GetAtt:
        """Get the TotalInstanceCount attribute."""
        return self.get_att("TotalInstanceCount")

    @property
    def attr_create_date(self) -> GetAtt:
        """Get the CreateDate attribute."""
        return self.get_att("CreateDate")

    @property
    def attr_start_date(self) -> GetAtt:
        """Get the StartDate attribute."""
        return self.get_att("StartDate")

    @property
    def attr_capacity_reservation_arn(self) -> GetAtt:
        """Get the CapacityReservationArn attribute."""
        return self.get_att("CapacityReservationArn")

    @property
    def attr_delivery_preference(self) -> GetAtt:
        """Get the DeliveryPreference attribute."""
        return self.get_att("DeliveryPreference")

    @property
    def attr_commitment_info(self) -> GetAtt:
        """Get the CommitmentInfo attribute."""
        return self.get_att("CommitmentInfo")

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_available_instance_count(self) -> GetAtt:
        """Get the AvailableInstanceCount attribute."""
        return self.get_att("AvailableInstanceCount")

    @property
    def attr_reservation_type(self) -> GetAtt:
        """Get the ReservationType attribute."""
        return self.get_att("ReservationType")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")

    @property
    def attr_capacity_allocation_set(self) -> GetAtt:
        """Get the CapacityAllocationSet attribute."""
        return self.get_att("CapacityAllocationSet")

    @property
    def attr_instance_type(self) -> GetAtt:
        """Get the InstanceType attribute."""
        return self.get_att("InstanceType")

    @property
    def attr_commitment_info__commitment_end_date(self) -> GetAtt:
        """Get the CommitmentInfo.CommitmentEndDate attribute."""
        return self.get_att("CommitmentInfo.CommitmentEndDate")




@dataclass
class InstanceTypeSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    priority: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_platform: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    weight: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs_optimized: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.priority is not None:
            if hasattr(self.priority, 'to_dict'):
                props['Priority'] = self.priority.to_dict()
            elif isinstance(self.priority, list):
                props['Priority'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.priority
                ]
            else:
                props['Priority'] = self.priority

        if self.availability_zone_id is not None:
            if hasattr(self.availability_zone_id, 'to_dict'):
                props['AvailabilityZoneId'] = self.availability_zone_id.to_dict()
            elif isinstance(self.availability_zone_id, list):
                props['AvailabilityZoneId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone_id
                ]
            else:
                props['AvailabilityZoneId'] = self.availability_zone_id

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        if self.instance_platform is not None:
            if hasattr(self.instance_platform, 'to_dict'):
                props['InstancePlatform'] = self.instance_platform.to_dict()
            elif isinstance(self.instance_platform, list):
                props['InstancePlatform'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_platform
                ]
            else:
                props['InstancePlatform'] = self.instance_platform

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        if self.weight is not None:
            if hasattr(self.weight, 'to_dict'):
                props['Weight'] = self.weight.to_dict()
            elif isinstance(self.weight, list):
                props['Weight'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weight
                ]
            else:
                props['Weight'] = self.weight

        if self.ebs_optimized is not None:
            if hasattr(self.ebs_optimized, 'to_dict'):
                props['EbsOptimized'] = self.ebs_optimized.to_dict()
            elif isinstance(self.ebs_optimized, list):
                props['EbsOptimized'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_optimized
                ]
            else:
                props['EbsOptimized'] = self.ebs_optimized

        return props


@dataclass
class TagSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, ResourceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tags: Optional[list[Tag]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        if self.tags is not None:
            if hasattr(self.tags, 'to_dict'):
                props['Tags'] = self.tags.to_dict()
            elif isinstance(self.tags, list):
                props['Tags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tags
                ]
            else:
                props['Tags'] = self.tags

        return props


@dataclass
class CapacityReservationFleet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::CapacityReservationFleet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tenancy: Optional[Union[str, FleetCapacityReservationTenancy, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    total_target_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allocation_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tag_specifications: Optional[list[TagSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    no_remove_end_date: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_type_specifications: Optional[list[InstanceTypeSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    remove_end_date: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_match_criteria: Optional[Union[str, FleetInstanceMatchCriteria, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    end_date: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.tenancy is not None:
            # Serialize tenancy (handle intrinsic functions)
            if hasattr(self.tenancy, 'to_dict'):
                props["Tenancy"] = self.tenancy.to_dict()
            elif isinstance(self.tenancy, list):
                # Serialize list items (may contain intrinsic functions)
                props['Tenancy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tenancy
                ]
            else:
                props["Tenancy"] = self.tenancy

        if self.total_target_capacity is not None:
            # Serialize total_target_capacity (handle intrinsic functions)
            if hasattr(self.total_target_capacity, 'to_dict'):
                props["TotalTargetCapacity"] = self.total_target_capacity.to_dict()
            elif isinstance(self.total_target_capacity, list):
                # Serialize list items (may contain intrinsic functions)
                props['TotalTargetCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_target_capacity
                ]
            else:
                props["TotalTargetCapacity"] = self.total_target_capacity

        if self.allocation_strategy is not None:
            # Serialize allocation_strategy (handle intrinsic functions)
            if hasattr(self.allocation_strategy, 'to_dict'):
                props["AllocationStrategy"] = self.allocation_strategy.to_dict()
            elif isinstance(self.allocation_strategy, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllocationStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_strategy
                ]
            else:
                props["AllocationStrategy"] = self.allocation_strategy

        if self.tag_specifications is not None:
            # Serialize tag_specifications (handle intrinsic functions)
            if hasattr(self.tag_specifications, 'to_dict'):
                props["TagSpecifications"] = self.tag_specifications.to_dict()
            elif isinstance(self.tag_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['TagSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_specifications
                ]
            else:
                props["TagSpecifications"] = self.tag_specifications

        if self.no_remove_end_date is not None:
            # Serialize no_remove_end_date (handle intrinsic functions)
            if hasattr(self.no_remove_end_date, 'to_dict'):
                props["NoRemoveEndDate"] = self.no_remove_end_date.to_dict()
            elif isinstance(self.no_remove_end_date, list):
                # Serialize list items (may contain intrinsic functions)
                props['NoRemoveEndDate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.no_remove_end_date
                ]
            else:
                props["NoRemoveEndDate"] = self.no_remove_end_date

        if self.instance_type_specifications is not None:
            # Serialize instance_type_specifications (handle intrinsic functions)
            if hasattr(self.instance_type_specifications, 'to_dict'):
                props["InstanceTypeSpecifications"] = self.instance_type_specifications.to_dict()
            elif isinstance(self.instance_type_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceTypeSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type_specifications
                ]
            else:
                props["InstanceTypeSpecifications"] = self.instance_type_specifications

        if self.remove_end_date is not None:
            # Serialize remove_end_date (handle intrinsic functions)
            if hasattr(self.remove_end_date, 'to_dict'):
                props["RemoveEndDate"] = self.remove_end_date.to_dict()
            elif isinstance(self.remove_end_date, list):
                # Serialize list items (may contain intrinsic functions)
                props['RemoveEndDate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.remove_end_date
                ]
            else:
                props["RemoveEndDate"] = self.remove_end_date

        if self.instance_match_criteria is not None:
            # Serialize instance_match_criteria (handle intrinsic functions)
            if hasattr(self.instance_match_criteria, 'to_dict'):
                props["InstanceMatchCriteria"] = self.instance_match_criteria.to_dict()
            elif isinstance(self.instance_match_criteria, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceMatchCriteria'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_match_criteria
                ]
            else:
                props["InstanceMatchCriteria"] = self.instance_match_criteria

        if self.end_date is not None:
            # Serialize end_date (handle intrinsic functions)
            if hasattr(self.end_date, 'to_dict'):
                props["EndDate"] = self.end_date.to_dict()
            elif isinstance(self.end_date, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndDate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.end_date
                ]
            else:
                props["EndDate"] = self.end_date

        return props

    @property
    def attr_capacity_reservation_fleet_id(self) -> GetAtt:
        """Get the CapacityReservationFleetId attribute."""
        return self.get_att("CapacityReservationFleetId")




@dataclass
class CarrierGateway(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::CarrierGateway"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_carrier_gateway_id(self) -> GetAtt:
        """Get the CarrierGatewayId attribute."""
        return self.get_att("CarrierGatewayId")




@dataclass
class ClientVpnAuthorizationRule(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::ClientVpnAuthorizationRule"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_vpn_endpoint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    access_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_network_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    authorize_all_groups: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.client_vpn_endpoint_id is not None:
            # Serialize client_vpn_endpoint_id (handle intrinsic functions)
            if hasattr(self.client_vpn_endpoint_id, 'to_dict'):
                props["ClientVpnEndpointId"] = self.client_vpn_endpoint_id.to_dict()
            elif isinstance(self.client_vpn_endpoint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientVpnEndpointId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_vpn_endpoint_id
                ]
            else:
                props["ClientVpnEndpointId"] = self.client_vpn_endpoint_id

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.access_group_id is not None:
            # Serialize access_group_id (handle intrinsic functions)
            if hasattr(self.access_group_id, 'to_dict'):
                props["AccessGroupId"] = self.access_group_id.to_dict()
            elif isinstance(self.access_group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AccessGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.access_group_id
                ]
            else:
                props["AccessGroupId"] = self.access_group_id

        if self.target_network_cidr is not None:
            # Serialize target_network_cidr (handle intrinsic functions)
            if hasattr(self.target_network_cidr, 'to_dict'):
                props["TargetNetworkCidr"] = self.target_network_cidr.to_dict()
            elif isinstance(self.target_network_cidr, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetNetworkCidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_network_cidr
                ]
            else:
                props["TargetNetworkCidr"] = self.target_network_cidr

        if self.authorize_all_groups is not None:
            # Serialize authorize_all_groups (handle intrinsic functions)
            if hasattr(self.authorize_all_groups, 'to_dict'):
                props["AuthorizeAllGroups"] = self.authorize_all_groups.to_dict()
            elif isinstance(self.authorize_all_groups, list):
                # Serialize list items (may contain intrinsic functions)
                props['AuthorizeAllGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.authorize_all_groups
                ]
            else:
                props["AuthorizeAllGroups"] = self.authorize_all_groups

        return props



@dataclass
class CertificateAuthenticationRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    client_root_certificate_chain_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.client_root_certificate_chain_arn is not None:
            if hasattr(self.client_root_certificate_chain_arn, 'to_dict'):
                props['ClientRootCertificateChainArn'] = self.client_root_certificate_chain_arn.to_dict()
            elif isinstance(self.client_root_certificate_chain_arn, list):
                props['ClientRootCertificateChainArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_root_certificate_chain_arn
                ]
            else:
                props['ClientRootCertificateChainArn'] = self.client_root_certificate_chain_arn

        return props


@dataclass
class ClientAuthenticationRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mutual_authentication: Optional[CertificateAuthenticationRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    federated_authentication: Optional[FederatedAuthenticationRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    active_directory: Optional[DirectoryServiceAuthenticationRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mutual_authentication is not None:
            if hasattr(self.mutual_authentication, 'to_dict'):
                props['MutualAuthentication'] = self.mutual_authentication.to_dict()
            elif isinstance(self.mutual_authentication, list):
                props['MutualAuthentication'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mutual_authentication
                ]
            else:
                props['MutualAuthentication'] = self.mutual_authentication

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.federated_authentication is not None:
            if hasattr(self.federated_authentication, 'to_dict'):
                props['FederatedAuthentication'] = self.federated_authentication.to_dict()
            elif isinstance(self.federated_authentication, list):
                props['FederatedAuthentication'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.federated_authentication
                ]
            else:
                props['FederatedAuthentication'] = self.federated_authentication

        if self.active_directory is not None:
            if hasattr(self.active_directory, 'to_dict'):
                props['ActiveDirectory'] = self.active_directory.to_dict()
            elif isinstance(self.active_directory, list):
                props['ActiveDirectory'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.active_directory
                ]
            else:
                props['ActiveDirectory'] = self.active_directory

        return props


@dataclass
class ClientConnectOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lambda_function_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.lambda_function_arn is not None:
            if hasattr(self.lambda_function_arn, 'to_dict'):
                props['LambdaFunctionArn'] = self.lambda_function_arn.to_dict()
            elif isinstance(self.lambda_function_arn, list):
                props['LambdaFunctionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lambda_function_arn
                ]
            else:
                props['LambdaFunctionArn'] = self.lambda_function_arn

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class ClientLoginBannerOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    banner_text: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        if self.banner_text is not None:
            if hasattr(self.banner_text, 'to_dict'):
                props['BannerText'] = self.banner_text.to_dict()
            elif isinstance(self.banner_text, list):
                props['BannerText'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.banner_text
                ]
            else:
                props['BannerText'] = self.banner_text

        return props


@dataclass
class ClientRouteEnforcementOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enforced: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enforced is not None:
            if hasattr(self.enforced, 'to_dict'):
                props['Enforced'] = self.enforced.to_dict()
            elif isinstance(self.enforced, list):
                props['Enforced'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enforced
                ]
            else:
                props['Enforced'] = self.enforced

        return props


@dataclass
class ConnectionLogOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloudwatch_log_stream: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloudwatch_log_group: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cloudwatch_log_stream is not None:
            if hasattr(self.cloudwatch_log_stream, 'to_dict'):
                props['CloudwatchLogStream'] = self.cloudwatch_log_stream.to_dict()
            elif isinstance(self.cloudwatch_log_stream, list):
                props['CloudwatchLogStream'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cloudwatch_log_stream
                ]
            else:
                props['CloudwatchLogStream'] = self.cloudwatch_log_stream

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        if self.cloudwatch_log_group is not None:
            if hasattr(self.cloudwatch_log_group, 'to_dict'):
                props['CloudwatchLogGroup'] = self.cloudwatch_log_group.to_dict()
            elif isinstance(self.cloudwatch_log_group, list):
                props['CloudwatchLogGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cloudwatch_log_group
                ]
            else:
                props['CloudwatchLogGroup'] = self.cloudwatch_log_group

        return props


@dataclass
class DirectoryServiceAuthenticationRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    directory_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.directory_id is not None:
            if hasattr(self.directory_id, 'to_dict'):
                props['DirectoryId'] = self.directory_id.to_dict()
            elif isinstance(self.directory_id, list):
                props['DirectoryId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.directory_id
                ]
            else:
                props['DirectoryId'] = self.directory_id

        return props


@dataclass
class FederatedAuthenticationRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    self_service_saml_provider_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    saml_provider_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.self_service_saml_provider_arn is not None:
            if hasattr(self.self_service_saml_provider_arn, 'to_dict'):
                props['SelfServiceSAMLProviderArn'] = self.self_service_saml_provider_arn.to_dict()
            elif isinstance(self.self_service_saml_provider_arn, list):
                props['SelfServiceSAMLProviderArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.self_service_saml_provider_arn
                ]
            else:
                props['SelfServiceSAMLProviderArn'] = self.self_service_saml_provider_arn

        if self.saml_provider_arn is not None:
            if hasattr(self.saml_provider_arn, 'to_dict'):
                props['SAMLProviderArn'] = self.saml_provider_arn.to_dict()
            elif isinstance(self.saml_provider_arn, list):
                props['SAMLProviderArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.saml_provider_arn
                ]
            else:
                props['SAMLProviderArn'] = self.saml_provider_arn

        return props


@dataclass
class TagSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, ResourceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tags: Optional[list[Tag]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        if self.tags is not None:
            if hasattr(self.tags, 'to_dict'):
                props['Tags'] = self.tags.to_dict()
            elif isinstance(self.tags, list):
                props['Tags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tags
                ]
            else:
                props['Tags'] = self.tags

        return props


@dataclass
class ClientVpnEndpoint(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::ClientVpnEndpoint"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_connect_options: Optional[ClientConnectOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_route_enforcement_options: Optional[ClientRouteEnforcementOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tag_specifications: Optional[list[TagSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    authentication_options: Optional[list[ClientAuthenticationRequest]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    server_certificate_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    session_timeout_hours: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    dns_servers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    disconnect_on_session_timeout: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connection_log_options: Optional[ConnectionLogOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    split_tunnel: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_login_banner_options: Optional[ClientLoginBannerOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    self_service_portal: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transport_protocol: Optional[Union[str, TransportProtocol, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpn_port: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.client_cidr_block is not None:
            # Serialize client_cidr_block (handle intrinsic functions)
            if hasattr(self.client_cidr_block, 'to_dict'):
                props["ClientCidrBlock"] = self.client_cidr_block.to_dict()
            elif isinstance(self.client_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_cidr_block
                ]
            else:
                props["ClientCidrBlock"] = self.client_cidr_block

        if self.client_connect_options is not None:
            # Serialize client_connect_options (handle intrinsic functions)
            if hasattr(self.client_connect_options, 'to_dict'):
                props["ClientConnectOptions"] = self.client_connect_options.to_dict()
            elif isinstance(self.client_connect_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientConnectOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_connect_options
                ]
            else:
                props["ClientConnectOptions"] = self.client_connect_options

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.client_route_enforcement_options is not None:
            # Serialize client_route_enforcement_options (handle intrinsic functions)
            if hasattr(self.client_route_enforcement_options, 'to_dict'):
                props["ClientRouteEnforcementOptions"] = self.client_route_enforcement_options.to_dict()
            elif isinstance(self.client_route_enforcement_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientRouteEnforcementOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_route_enforcement_options
                ]
            else:
                props["ClientRouteEnforcementOptions"] = self.client_route_enforcement_options

        if self.tag_specifications is not None:
            # Serialize tag_specifications (handle intrinsic functions)
            if hasattr(self.tag_specifications, 'to_dict'):
                props["TagSpecifications"] = self.tag_specifications.to_dict()
            elif isinstance(self.tag_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['TagSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_specifications
                ]
            else:
                props["TagSpecifications"] = self.tag_specifications

        if self.authentication_options is not None:
            # Serialize authentication_options (handle intrinsic functions)
            if hasattr(self.authentication_options, 'to_dict'):
                props["AuthenticationOptions"] = self.authentication_options.to_dict()
            elif isinstance(self.authentication_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['AuthenticationOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.authentication_options
                ]
            else:
                props["AuthenticationOptions"] = self.authentication_options

        if self.server_certificate_arn is not None:
            # Serialize server_certificate_arn (handle intrinsic functions)
            if hasattr(self.server_certificate_arn, 'to_dict'):
                props["ServerCertificateArn"] = self.server_certificate_arn.to_dict()
            elif isinstance(self.server_certificate_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServerCertificateArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.server_certificate_arn
                ]
            else:
                props["ServerCertificateArn"] = self.server_certificate_arn

        if self.session_timeout_hours is not None:
            # Serialize session_timeout_hours (handle intrinsic functions)
            if hasattr(self.session_timeout_hours, 'to_dict'):
                props["SessionTimeoutHours"] = self.session_timeout_hours.to_dict()
            elif isinstance(self.session_timeout_hours, list):
                # Serialize list items (may contain intrinsic functions)
                props['SessionTimeoutHours'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.session_timeout_hours
                ]
            else:
                props["SessionTimeoutHours"] = self.session_timeout_hours

        if self.dns_servers is not None:
            # Serialize dns_servers (handle intrinsic functions)
            if hasattr(self.dns_servers, 'to_dict'):
                props["DnsServers"] = self.dns_servers.to_dict()
            elif isinstance(self.dns_servers, list):
                # Serialize list items (may contain intrinsic functions)
                props['DnsServers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dns_servers
                ]
            else:
                props["DnsServers"] = self.dns_servers

        if self.security_group_ids is not None:
            # Serialize security_group_ids (handle intrinsic functions)
            if hasattr(self.security_group_ids, 'to_dict'):
                props["SecurityGroupIds"] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props["SecurityGroupIds"] = self.security_group_ids

        if self.disconnect_on_session_timeout is not None:
            # Serialize disconnect_on_session_timeout (handle intrinsic functions)
            if hasattr(self.disconnect_on_session_timeout, 'to_dict'):
                props["DisconnectOnSessionTimeout"] = self.disconnect_on_session_timeout.to_dict()
            elif isinstance(self.disconnect_on_session_timeout, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisconnectOnSessionTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disconnect_on_session_timeout
                ]
            else:
                props["DisconnectOnSessionTimeout"] = self.disconnect_on_session_timeout

        if self.connection_log_options is not None:
            # Serialize connection_log_options (handle intrinsic functions)
            if hasattr(self.connection_log_options, 'to_dict'):
                props["ConnectionLogOptions"] = self.connection_log_options.to_dict()
            elif isinstance(self.connection_log_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConnectionLogOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connection_log_options
                ]
            else:
                props["ConnectionLogOptions"] = self.connection_log_options

        if self.split_tunnel is not None:
            # Serialize split_tunnel (handle intrinsic functions)
            if hasattr(self.split_tunnel, 'to_dict'):
                props["SplitTunnel"] = self.split_tunnel.to_dict()
            elif isinstance(self.split_tunnel, list):
                # Serialize list items (may contain intrinsic functions)
                props['SplitTunnel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.split_tunnel
                ]
            else:
                props["SplitTunnel"] = self.split_tunnel

        if self.client_login_banner_options is not None:
            # Serialize client_login_banner_options (handle intrinsic functions)
            if hasattr(self.client_login_banner_options, 'to_dict'):
                props["ClientLoginBannerOptions"] = self.client_login_banner_options.to_dict()
            elif isinstance(self.client_login_banner_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientLoginBannerOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_login_banner_options
                ]
            else:
                props["ClientLoginBannerOptions"] = self.client_login_banner_options

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.self_service_portal is not None:
            # Serialize self_service_portal (handle intrinsic functions)
            if hasattr(self.self_service_portal, 'to_dict'):
                props["SelfServicePortal"] = self.self_service_portal.to_dict()
            elif isinstance(self.self_service_portal, list):
                # Serialize list items (may contain intrinsic functions)
                props['SelfServicePortal'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.self_service_portal
                ]
            else:
                props["SelfServicePortal"] = self.self_service_portal

        if self.transport_protocol is not None:
            # Serialize transport_protocol (handle intrinsic functions)
            if hasattr(self.transport_protocol, 'to_dict'):
                props["TransportProtocol"] = self.transport_protocol.to_dict()
            elif isinstance(self.transport_protocol, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransportProtocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transport_protocol
                ]
            else:
                props["TransportProtocol"] = self.transport_protocol

        if self.vpn_port is not None:
            # Serialize vpn_port (handle intrinsic functions)
            if hasattr(self.vpn_port, 'to_dict'):
                props["VpnPort"] = self.vpn_port.to_dict()
            elif isinstance(self.vpn_port, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpnPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_port
                ]
            else:
                props["VpnPort"] = self.vpn_port

        return props



@dataclass
class ClientVpnRoute(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::ClientVpnRoute"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_vpn_endpoint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_vpc_subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.client_vpn_endpoint_id is not None:
            # Serialize client_vpn_endpoint_id (handle intrinsic functions)
            if hasattr(self.client_vpn_endpoint_id, 'to_dict'):
                props["ClientVpnEndpointId"] = self.client_vpn_endpoint_id.to_dict()
            elif isinstance(self.client_vpn_endpoint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientVpnEndpointId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_vpn_endpoint_id
                ]
            else:
                props["ClientVpnEndpointId"] = self.client_vpn_endpoint_id

        if self.target_vpc_subnet_id is not None:
            # Serialize target_vpc_subnet_id (handle intrinsic functions)
            if hasattr(self.target_vpc_subnet_id, 'to_dict'):
                props["TargetVpcSubnetId"] = self.target_vpc_subnet_id.to_dict()
            elif isinstance(self.target_vpc_subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetVpcSubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_vpc_subnet_id
                ]
            else:
                props["TargetVpcSubnetId"] = self.target_vpc_subnet_id

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.destination_cidr_block is not None:
            # Serialize destination_cidr_block (handle intrinsic functions)
            if hasattr(self.destination_cidr_block, 'to_dict'):
                props["DestinationCidrBlock"] = self.destination_cidr_block.to_dict()
            elif isinstance(self.destination_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr_block
                ]
            else:
                props["DestinationCidrBlock"] = self.destination_cidr_block

        return props



@dataclass
class ClientVpnTargetNetworkAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::ClientVpnTargetNetworkAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_vpn_endpoint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.client_vpn_endpoint_id is not None:
            # Serialize client_vpn_endpoint_id (handle intrinsic functions)
            if hasattr(self.client_vpn_endpoint_id, 'to_dict'):
                props["ClientVpnEndpointId"] = self.client_vpn_endpoint_id.to_dict()
            elif isinstance(self.client_vpn_endpoint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientVpnEndpointId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_vpn_endpoint_id
                ]
            else:
                props["ClientVpnEndpointId"] = self.client_vpn_endpoint_id

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        return props



@dataclass
class CustomerGateway(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-c"""

    resource_type: ClassVar[str] = "AWS::EC2::CustomerGateway"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    bgp_asn_extended: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    bgp_asn: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    certificate_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    device_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.ip_address is not None:
            # Serialize ip_address (handle intrinsic functions)
            if hasattr(self.ip_address, 'to_dict'):
                props["IpAddress"] = self.ip_address.to_dict()
            elif isinstance(self.ip_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_address
                ]
            else:
                props["IpAddress"] = self.ip_address

        if self.bgp_asn_extended is not None:
            # Serialize bgp_asn_extended (handle intrinsic functions)
            if hasattr(self.bgp_asn_extended, 'to_dict'):
                props["BgpAsnExtended"] = self.bgp_asn_extended.to_dict()
            elif isinstance(self.bgp_asn_extended, list):
                # Serialize list items (may contain intrinsic functions)
                props['BgpAsnExtended'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bgp_asn_extended
                ]
            else:
                props["BgpAsnExtended"] = self.bgp_asn_extended

        if self.bgp_asn is not None:
            # Serialize bgp_asn (handle intrinsic functions)
            if hasattr(self.bgp_asn, 'to_dict'):
                props["BgpAsn"] = self.bgp_asn.to_dict()
            elif isinstance(self.bgp_asn, list):
                # Serialize list items (may contain intrinsic functions)
                props['BgpAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bgp_asn
                ]
            else:
                props["BgpAsn"] = self.bgp_asn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.certificate_arn is not None:
            # Serialize certificate_arn (handle intrinsic functions)
            if hasattr(self.certificate_arn, 'to_dict'):
                props["CertificateArn"] = self.certificate_arn.to_dict()
            elif isinstance(self.certificate_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['CertificateArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_arn
                ]
            else:
                props["CertificateArn"] = self.certificate_arn

        if self.device_name is not None:
            # Serialize device_name (handle intrinsic functions)
            if hasattr(self.device_name, 'to_dict'):
                props["DeviceName"] = self.device_name.to_dict()
            elif isinstance(self.device_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeviceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_name
                ]
            else:
                props["DeviceName"] = self.device_name

        return props

    @property
    def attr_customer_gateway_id(self) -> GetAtt:
        """Get the CustomerGatewayId attribute."""
        return self.get_att("CustomerGatewayId")




@dataclass
class DHCPOptions(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-d"""

    resource_type: ClassVar[str] = "AWS::EC2::DHCPOptions"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    netbios_name_servers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ntp_servers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_address_preferred_lease_time: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    netbios_node_type: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_name_servers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.netbios_name_servers is not None:
            # Serialize netbios_name_servers (handle intrinsic functions)
            if hasattr(self.netbios_name_servers, 'to_dict'):
                props["NetbiosNameServers"] = self.netbios_name_servers.to_dict()
            elif isinstance(self.netbios_name_servers, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetbiosNameServers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.netbios_name_servers
                ]
            else:
                props["NetbiosNameServers"] = self.netbios_name_servers

        if self.ntp_servers is not None:
            # Serialize ntp_servers (handle intrinsic functions)
            if hasattr(self.ntp_servers, 'to_dict'):
                props["NtpServers"] = self.ntp_servers.to_dict()
            elif isinstance(self.ntp_servers, list):
                # Serialize list items (may contain intrinsic functions)
                props['NtpServers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ntp_servers
                ]
            else:
                props["NtpServers"] = self.ntp_servers

        if self.domain_name is not None:
            # Serialize domain_name (handle intrinsic functions)
            if hasattr(self.domain_name, 'to_dict'):
                props["DomainName"] = self.domain_name.to_dict()
            elif isinstance(self.domain_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_name
                ]
            else:
                props["DomainName"] = self.domain_name

        if self.ipv6_address_preferred_lease_time is not None:
            # Serialize ipv6_address_preferred_lease_time (handle intrinsic functions)
            if hasattr(self.ipv6_address_preferred_lease_time, 'to_dict'):
                props["Ipv6AddressPreferredLeaseTime"] = self.ipv6_address_preferred_lease_time.to_dict()
            elif isinstance(self.ipv6_address_preferred_lease_time, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6AddressPreferredLeaseTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address_preferred_lease_time
                ]
            else:
                props["Ipv6AddressPreferredLeaseTime"] = self.ipv6_address_preferred_lease_time

        if self.netbios_node_type is not None:
            # Serialize netbios_node_type (handle intrinsic functions)
            if hasattr(self.netbios_node_type, 'to_dict'):
                props["NetbiosNodeType"] = self.netbios_node_type.to_dict()
            elif isinstance(self.netbios_node_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetbiosNodeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.netbios_node_type
                ]
            else:
                props["NetbiosNodeType"] = self.netbios_node_type

        if self.domain_name_servers is not None:
            # Serialize domain_name_servers (handle intrinsic functions)
            if hasattr(self.domain_name_servers, 'to_dict'):
                props["DomainNameServers"] = self.domain_name_servers.to_dict()
            elif isinstance(self.domain_name_servers, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainNameServers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_name_servers
                ]
            else:
                props["DomainNameServers"] = self.domain_name_servers

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_dhcp_options_id(self) -> GetAtt:
        """Get the DhcpOptionsId attribute."""
        return self.get_att("DhcpOptionsId")




@dataclass
class AcceleratorCountRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class AcceleratorTotalMemoryMiBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class BaselineEbsBandwidthMbpsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class BaselinePerformanceFactorsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu: Optional[CpuPerformanceFactorRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cpu is not None:
            if hasattr(self.cpu, 'to_dict'):
                props['Cpu'] = self.cpu.to_dict()
            elif isinstance(self.cpu, list):
                props['Cpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu
                ]
            else:
                props['Cpu'] = self.cpu

        return props


@dataclass
class BlockDeviceMapping:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs: Optional[EbsBlockDevice] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    no_device: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    virtual_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ebs is not None:
            if hasattr(self.ebs, 'to_dict'):
                props['Ebs'] = self.ebs.to_dict()
            elif isinstance(self.ebs, list):
                props['Ebs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs
                ]
            else:
                props['Ebs'] = self.ebs

        if self.no_device is not None:
            if hasattr(self.no_device, 'to_dict'):
                props['NoDevice'] = self.no_device.to_dict()
            elif isinstance(self.no_device, list):
                props['NoDevice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.no_device
                ]
            else:
                props['NoDevice'] = self.no_device

        if self.virtual_name is not None:
            if hasattr(self.virtual_name, 'to_dict'):
                props['VirtualName'] = self.virtual_name.to_dict()
            elif isinstance(self.virtual_name, list):
                props['VirtualName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.virtual_name
                ]
            else:
                props['VirtualName'] = self.virtual_name

        if self.device_name is not None:
            if hasattr(self.device_name, 'to_dict'):
                props['DeviceName'] = self.device_name.to_dict()
            elif isinstance(self.device_name, list):
                props['DeviceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_name
                ]
            else:
                props['DeviceName'] = self.device_name

        return props


@dataclass
class CapacityRebalance:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    termination_delay: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    replacement_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.termination_delay is not None:
            if hasattr(self.termination_delay, 'to_dict'):
                props['TerminationDelay'] = self.termination_delay.to_dict()
            elif isinstance(self.termination_delay, list):
                props['TerminationDelay'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.termination_delay
                ]
            else:
                props['TerminationDelay'] = self.termination_delay

        if self.replacement_strategy is not None:
            if hasattr(self.replacement_strategy, 'to_dict'):
                props['ReplacementStrategy'] = self.replacement_strategy.to_dict()
            elif isinstance(self.replacement_strategy, list):
                props['ReplacementStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.replacement_strategy
                ]
            else:
                props['ReplacementStrategy'] = self.replacement_strategy

        return props


@dataclass
class CapacityReservationOptionsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    usage_strategy: Optional[Union[str, FleetCapacityReservationUsageStrategy, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.usage_strategy is not None:
            if hasattr(self.usage_strategy, 'to_dict'):
                props['UsageStrategy'] = self.usage_strategy.to_dict()
            elif isinstance(self.usage_strategy, list):
                props['UsageStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.usage_strategy
                ]
            else:
                props['UsageStrategy'] = self.usage_strategy

        return props


@dataclass
class CpuPerformanceFactorRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    references: Optional[list[PerformanceFactorReferenceRequest]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.references is not None:
            if hasattr(self.references, 'to_dict'):
                props['References'] = self.references.to_dict()
            elif isinstance(self.references, list):
                props['References'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.references
                ]
            else:
                props['References'] = self.references

        return props


@dataclass
class EbsBlockDevice:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snapshot_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_type: Optional[Union[str, VolumeType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encrypted: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.snapshot_id is not None:
            if hasattr(self.snapshot_id, 'to_dict'):
                props['SnapshotId'] = self.snapshot_id.to_dict()
            elif isinstance(self.snapshot_id, list):
                props['SnapshotId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snapshot_id
                ]
            else:
                props['SnapshotId'] = self.snapshot_id

        if self.volume_type is not None:
            if hasattr(self.volume_type, 'to_dict'):
                props['VolumeType'] = self.volume_type.to_dict()
            elif isinstance(self.volume_type, list):
                props['VolumeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_type
                ]
            else:
                props['VolumeType'] = self.volume_type

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.encrypted is not None:
            if hasattr(self.encrypted, 'to_dict'):
                props['Encrypted'] = self.encrypted.to_dict()
            elif isinstance(self.encrypted, list):
                props['Encrypted'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encrypted
                ]
            else:
                props['Encrypted'] = self.encrypted

        if self.iops is not None:
            if hasattr(self.iops, 'to_dict'):
                props['Iops'] = self.iops.to_dict()
            elif isinstance(self.iops, list):
                props['Iops'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iops
                ]
            else:
                props['Iops'] = self.iops

        if self.volume_size is not None:
            if hasattr(self.volume_size, 'to_dict'):
                props['VolumeSize'] = self.volume_size.to_dict()
            elif isinstance(self.volume_size, list):
                props['VolumeSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size
                ]
            else:
                props['VolumeSize'] = self.volume_size

        if self.delete_on_termination is not None:
            if hasattr(self.delete_on_termination, 'to_dict'):
                props['DeleteOnTermination'] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props['DeleteOnTermination'] = self.delete_on_termination

        return props


@dataclass
class FleetLaunchTemplateConfigRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_specification: Optional[FleetLaunchTemplateSpecificationRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    overrides: Optional[list[FleetLaunchTemplateOverridesRequest]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.launch_template_specification is not None:
            if hasattr(self.launch_template_specification, 'to_dict'):
                props['LaunchTemplateSpecification'] = self.launch_template_specification.to_dict()
            elif isinstance(self.launch_template_specification, list):
                props['LaunchTemplateSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_specification
                ]
            else:
                props['LaunchTemplateSpecification'] = self.launch_template_specification

        if self.overrides is not None:
            if hasattr(self.overrides, 'to_dict'):
                props['Overrides'] = self.overrides.to_dict()
            elif isinstance(self.overrides, list):
                props['Overrides'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.overrides
                ]
            else:
                props['Overrides'] = self.overrides

        return props


@dataclass
class FleetLaunchTemplateOverridesRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    weighted_capacity: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    placement: Optional[Placement] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    priority: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    block_device_mappings: Optional[list[BlockDeviceMapping]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_requirements: Optional[InstanceRequirementsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, InstanceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_price: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.weighted_capacity is not None:
            if hasattr(self.weighted_capacity, 'to_dict'):
                props['WeightedCapacity'] = self.weighted_capacity.to_dict()
            elif isinstance(self.weighted_capacity, list):
                props['WeightedCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weighted_capacity
                ]
            else:
                props['WeightedCapacity'] = self.weighted_capacity

        if self.placement is not None:
            if hasattr(self.placement, 'to_dict'):
                props['Placement'] = self.placement.to_dict()
            elif isinstance(self.placement, list):
                props['Placement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.placement
                ]
            else:
                props['Placement'] = self.placement

        if self.priority is not None:
            if hasattr(self.priority, 'to_dict'):
                props['Priority'] = self.priority.to_dict()
            elif isinstance(self.priority, list):
                props['Priority'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.priority
                ]
            else:
                props['Priority'] = self.priority

        if self.block_device_mappings is not None:
            if hasattr(self.block_device_mappings, 'to_dict'):
                props['BlockDeviceMappings'] = self.block_device_mappings.to_dict()
            elif isinstance(self.block_device_mappings, list):
                props['BlockDeviceMappings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.block_device_mappings
                ]
            else:
                props['BlockDeviceMappings'] = self.block_device_mappings

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        if self.subnet_id is not None:
            if hasattr(self.subnet_id, 'to_dict'):
                props['SubnetId'] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props['SubnetId'] = self.subnet_id

        if self.instance_requirements is not None:
            if hasattr(self.instance_requirements, 'to_dict'):
                props['InstanceRequirements'] = self.instance_requirements.to_dict()
            elif isinstance(self.instance_requirements, list):
                props['InstanceRequirements'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_requirements
                ]
            else:
                props['InstanceRequirements'] = self.instance_requirements

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        if self.max_price is not None:
            if hasattr(self.max_price, 'to_dict'):
                props['MaxPrice'] = self.max_price.to_dict()
            elif isinstance(self.max_price, list):
                props['MaxPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_price
                ]
            else:
                props['MaxPrice'] = self.max_price

        return props


@dataclass
class FleetLaunchTemplateSpecificationRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.launch_template_name is not None:
            if hasattr(self.launch_template_name, 'to_dict'):
                props['LaunchTemplateName'] = self.launch_template_name.to_dict()
            elif isinstance(self.launch_template_name, list):
                props['LaunchTemplateName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_name
                ]
            else:
                props['LaunchTemplateName'] = self.launch_template_name

        if self.version is not None:
            if hasattr(self.version, 'to_dict'):
                props['Version'] = self.version.to_dict()
            elif isinstance(self.version, list):
                props['Version'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version
                ]
            else:
                props['Version'] = self.version

        if self.launch_template_id is not None:
            if hasattr(self.launch_template_id, 'to_dict'):
                props['LaunchTemplateId'] = self.launch_template_id.to_dict()
            elif isinstance(self.launch_template_id, list):
                props['LaunchTemplateId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_id
                ]
            else:
                props['LaunchTemplateId'] = self.launch_template_id

        return props


@dataclass
class InstanceRequirementsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_generations: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    require_encryption_in_transit: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_gi_b_per_v_cpu: Optional[MemoryGiBPerVCpuRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    v_cpu_count: Optional[VCpuCountRangeRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_manufacturers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_storage: Optional[Union[str, LocalStorage, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_manufacturers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bare_metal: Optional[Union[str, BareMetal, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    require_hibernate_support: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_max_price_percentage_over_lowest_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_mi_b: Optional[MemoryMiBRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_storage_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_count: Optional[NetworkInterfaceCountRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    excluded_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allowed_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_bandwidth_gbps: Optional[NetworkBandwidthGbpsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_count: Optional[AcceleratorCountRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_performance_factors: Optional[BaselinePerformanceFactorsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_max_price_percentage_over_lowest_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_ebs_bandwidth_mbps: Optional[BaselineEbsBandwidthMbpsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_total_memory_mi_b: Optional[AcceleratorTotalMemoryMiBRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    burstable_performance: Optional[Union[str, BurstablePerformance, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    total_local_storage_gb: Optional[TotalLocalStorageGBRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_generations is not None:
            if hasattr(self.instance_generations, 'to_dict'):
                props['InstanceGenerations'] = self.instance_generations.to_dict()
            elif isinstance(self.instance_generations, list):
                props['InstanceGenerations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_generations
                ]
            else:
                props['InstanceGenerations'] = self.instance_generations

        if self.require_encryption_in_transit is not None:
            if hasattr(self.require_encryption_in_transit, 'to_dict'):
                props['RequireEncryptionInTransit'] = self.require_encryption_in_transit.to_dict()
            elif isinstance(self.require_encryption_in_transit, list):
                props['RequireEncryptionInTransit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.require_encryption_in_transit
                ]
            else:
                props['RequireEncryptionInTransit'] = self.require_encryption_in_transit

        if self.memory_gi_b_per_v_cpu is not None:
            if hasattr(self.memory_gi_b_per_v_cpu, 'to_dict'):
                props['MemoryGiBPerVCpu'] = self.memory_gi_b_per_v_cpu.to_dict()
            elif isinstance(self.memory_gi_b_per_v_cpu, list):
                props['MemoryGiBPerVCpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_gi_b_per_v_cpu
                ]
            else:
                props['MemoryGiBPerVCpu'] = self.memory_gi_b_per_v_cpu

        if self.accelerator_types is not None:
            if hasattr(self.accelerator_types, 'to_dict'):
                props['AcceleratorTypes'] = self.accelerator_types.to_dict()
            elif isinstance(self.accelerator_types, list):
                props['AcceleratorTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_types
                ]
            else:
                props['AcceleratorTypes'] = self.accelerator_types

        if self.v_cpu_count is not None:
            if hasattr(self.v_cpu_count, 'to_dict'):
                props['VCpuCount'] = self.v_cpu_count.to_dict()
            elif isinstance(self.v_cpu_count, list):
                props['VCpuCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.v_cpu_count
                ]
            else:
                props['VCpuCount'] = self.v_cpu_count

        if self.accelerator_manufacturers is not None:
            if hasattr(self.accelerator_manufacturers, 'to_dict'):
                props['AcceleratorManufacturers'] = self.accelerator_manufacturers.to_dict()
            elif isinstance(self.accelerator_manufacturers, list):
                props['AcceleratorManufacturers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_manufacturers
                ]
            else:
                props['AcceleratorManufacturers'] = self.accelerator_manufacturers

        if self.local_storage is not None:
            if hasattr(self.local_storage, 'to_dict'):
                props['LocalStorage'] = self.local_storage.to_dict()
            elif isinstance(self.local_storage, list):
                props['LocalStorage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_storage
                ]
            else:
                props['LocalStorage'] = self.local_storage

        if self.cpu_manufacturers is not None:
            if hasattr(self.cpu_manufacturers, 'to_dict'):
                props['CpuManufacturers'] = self.cpu_manufacturers.to_dict()
            elif isinstance(self.cpu_manufacturers, list):
                props['CpuManufacturers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_manufacturers
                ]
            else:
                props['CpuManufacturers'] = self.cpu_manufacturers

        if self.bare_metal is not None:
            if hasattr(self.bare_metal, 'to_dict'):
                props['BareMetal'] = self.bare_metal.to_dict()
            elif isinstance(self.bare_metal, list):
                props['BareMetal'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bare_metal
                ]
            else:
                props['BareMetal'] = self.bare_metal

        if self.require_hibernate_support is not None:
            if hasattr(self.require_hibernate_support, 'to_dict'):
                props['RequireHibernateSupport'] = self.require_hibernate_support.to_dict()
            elif isinstance(self.require_hibernate_support, list):
                props['RequireHibernateSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.require_hibernate_support
                ]
            else:
                props['RequireHibernateSupport'] = self.require_hibernate_support

        if self.max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            if hasattr(self.max_spot_price_as_percentage_of_optimal_on_demand_price, 'to_dict'):
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = self.max_spot_price_as_percentage_of_optimal_on_demand_price.to_dict()
            elif isinstance(self.max_spot_price_as_percentage_of_optimal_on_demand_price, list):
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_spot_price_as_percentage_of_optimal_on_demand_price
                ]
            else:
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = self.max_spot_price_as_percentage_of_optimal_on_demand_price

        if self.on_demand_max_price_percentage_over_lowest_price is not None:
            if hasattr(self.on_demand_max_price_percentage_over_lowest_price, 'to_dict'):
                props['OnDemandMaxPricePercentageOverLowestPrice'] = self.on_demand_max_price_percentage_over_lowest_price.to_dict()
            elif isinstance(self.on_demand_max_price_percentage_over_lowest_price, list):
                props['OnDemandMaxPricePercentageOverLowestPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_max_price_percentage_over_lowest_price
                ]
            else:
                props['OnDemandMaxPricePercentageOverLowestPrice'] = self.on_demand_max_price_percentage_over_lowest_price

        if self.memory_mi_b is not None:
            if hasattr(self.memory_mi_b, 'to_dict'):
                props['MemoryMiB'] = self.memory_mi_b.to_dict()
            elif isinstance(self.memory_mi_b, list):
                props['MemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_mi_b
                ]
            else:
                props['MemoryMiB'] = self.memory_mi_b

        if self.local_storage_types is not None:
            if hasattr(self.local_storage_types, 'to_dict'):
                props['LocalStorageTypes'] = self.local_storage_types.to_dict()
            elif isinstance(self.local_storage_types, list):
                props['LocalStorageTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_storage_types
                ]
            else:
                props['LocalStorageTypes'] = self.local_storage_types

        if self.network_interface_count is not None:
            if hasattr(self.network_interface_count, 'to_dict'):
                props['NetworkInterfaceCount'] = self.network_interface_count.to_dict()
            elif isinstance(self.network_interface_count, list):
                props['NetworkInterfaceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_count
                ]
            else:
                props['NetworkInterfaceCount'] = self.network_interface_count

        if self.excluded_instance_types is not None:
            if hasattr(self.excluded_instance_types, 'to_dict'):
                props['ExcludedInstanceTypes'] = self.excluded_instance_types.to_dict()
            elif isinstance(self.excluded_instance_types, list):
                props['ExcludedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.excluded_instance_types
                ]
            else:
                props['ExcludedInstanceTypes'] = self.excluded_instance_types

        if self.allowed_instance_types is not None:
            if hasattr(self.allowed_instance_types, 'to_dict'):
                props['AllowedInstanceTypes'] = self.allowed_instance_types.to_dict()
            elif isinstance(self.allowed_instance_types, list):
                props['AllowedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_instance_types
                ]
            else:
                props['AllowedInstanceTypes'] = self.allowed_instance_types

        if self.network_bandwidth_gbps is not None:
            if hasattr(self.network_bandwidth_gbps, 'to_dict'):
                props['NetworkBandwidthGbps'] = self.network_bandwidth_gbps.to_dict()
            elif isinstance(self.network_bandwidth_gbps, list):
                props['NetworkBandwidthGbps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_bandwidth_gbps
                ]
            else:
                props['NetworkBandwidthGbps'] = self.network_bandwidth_gbps

        if self.accelerator_count is not None:
            if hasattr(self.accelerator_count, 'to_dict'):
                props['AcceleratorCount'] = self.accelerator_count.to_dict()
            elif isinstance(self.accelerator_count, list):
                props['AcceleratorCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_count
                ]
            else:
                props['AcceleratorCount'] = self.accelerator_count

        if self.baseline_performance_factors is not None:
            if hasattr(self.baseline_performance_factors, 'to_dict'):
                props['BaselinePerformanceFactors'] = self.baseline_performance_factors.to_dict()
            elif isinstance(self.baseline_performance_factors, list):
                props['BaselinePerformanceFactors'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baseline_performance_factors
                ]
            else:
                props['BaselinePerformanceFactors'] = self.baseline_performance_factors

        if self.spot_max_price_percentage_over_lowest_price is not None:
            if hasattr(self.spot_max_price_percentage_over_lowest_price, 'to_dict'):
                props['SpotMaxPricePercentageOverLowestPrice'] = self.spot_max_price_percentage_over_lowest_price.to_dict()
            elif isinstance(self.spot_max_price_percentage_over_lowest_price, list):
                props['SpotMaxPricePercentageOverLowestPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_max_price_percentage_over_lowest_price
                ]
            else:
                props['SpotMaxPricePercentageOverLowestPrice'] = self.spot_max_price_percentage_over_lowest_price

        if self.baseline_ebs_bandwidth_mbps is not None:
            if hasattr(self.baseline_ebs_bandwidth_mbps, 'to_dict'):
                props['BaselineEbsBandwidthMbps'] = self.baseline_ebs_bandwidth_mbps.to_dict()
            elif isinstance(self.baseline_ebs_bandwidth_mbps, list):
                props['BaselineEbsBandwidthMbps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baseline_ebs_bandwidth_mbps
                ]
            else:
                props['BaselineEbsBandwidthMbps'] = self.baseline_ebs_bandwidth_mbps

        if self.accelerator_names is not None:
            if hasattr(self.accelerator_names, 'to_dict'):
                props['AcceleratorNames'] = self.accelerator_names.to_dict()
            elif isinstance(self.accelerator_names, list):
                props['AcceleratorNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_names
                ]
            else:
                props['AcceleratorNames'] = self.accelerator_names

        if self.accelerator_total_memory_mi_b is not None:
            if hasattr(self.accelerator_total_memory_mi_b, 'to_dict'):
                props['AcceleratorTotalMemoryMiB'] = self.accelerator_total_memory_mi_b.to_dict()
            elif isinstance(self.accelerator_total_memory_mi_b, list):
                props['AcceleratorTotalMemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_total_memory_mi_b
                ]
            else:
                props['AcceleratorTotalMemoryMiB'] = self.accelerator_total_memory_mi_b

        if self.burstable_performance is not None:
            if hasattr(self.burstable_performance, 'to_dict'):
                props['BurstablePerformance'] = self.burstable_performance.to_dict()
            elif isinstance(self.burstable_performance, list):
                props['BurstablePerformance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.burstable_performance
                ]
            else:
                props['BurstablePerformance'] = self.burstable_performance

        if self.total_local_storage_gb is not None:
            if hasattr(self.total_local_storage_gb, 'to_dict'):
                props['TotalLocalStorageGB'] = self.total_local_storage_gb.to_dict()
            elif isinstance(self.total_local_storage_gb, list):
                props['TotalLocalStorageGB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_local_storage_gb
                ]
            else:
                props['TotalLocalStorageGB'] = self.total_local_storage_gb

        return props


@dataclass
class MaintenanceStrategies:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_rebalance: Optional[CapacityRebalance] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capacity_rebalance is not None:
            if hasattr(self.capacity_rebalance, 'to_dict'):
                props['CapacityRebalance'] = self.capacity_rebalance.to_dict()
            elif isinstance(self.capacity_rebalance, list):
                props['CapacityRebalance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_rebalance
                ]
            else:
                props['CapacityRebalance'] = self.capacity_rebalance

        return props


@dataclass
class MemoryGiBPerVCpuRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class MemoryMiBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class NetworkBandwidthGbpsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class NetworkInterfaceCountRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class OnDemandOptionsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    single_availability_zone: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allocation_strategy: Optional[Union[str, FleetOnDemandAllocationStrategy, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    single_instance_type: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_target_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_total_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_options: Optional[CapacityReservationOptionsRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.single_availability_zone is not None:
            if hasattr(self.single_availability_zone, 'to_dict'):
                props['SingleAvailabilityZone'] = self.single_availability_zone.to_dict()
            elif isinstance(self.single_availability_zone, list):
                props['SingleAvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.single_availability_zone
                ]
            else:
                props['SingleAvailabilityZone'] = self.single_availability_zone

        if self.allocation_strategy is not None:
            if hasattr(self.allocation_strategy, 'to_dict'):
                props['AllocationStrategy'] = self.allocation_strategy.to_dict()
            elif isinstance(self.allocation_strategy, list):
                props['AllocationStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_strategy
                ]
            else:
                props['AllocationStrategy'] = self.allocation_strategy

        if self.single_instance_type is not None:
            if hasattr(self.single_instance_type, 'to_dict'):
                props['SingleInstanceType'] = self.single_instance_type.to_dict()
            elif isinstance(self.single_instance_type, list):
                props['SingleInstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.single_instance_type
                ]
            else:
                props['SingleInstanceType'] = self.single_instance_type

        if self.min_target_capacity is not None:
            if hasattr(self.min_target_capacity, 'to_dict'):
                props['MinTargetCapacity'] = self.min_target_capacity.to_dict()
            elif isinstance(self.min_target_capacity, list):
                props['MinTargetCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_target_capacity
                ]
            else:
                props['MinTargetCapacity'] = self.min_target_capacity

        if self.max_total_price is not None:
            if hasattr(self.max_total_price, 'to_dict'):
                props['MaxTotalPrice'] = self.max_total_price.to_dict()
            elif isinstance(self.max_total_price, list):
                props['MaxTotalPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_total_price
                ]
            else:
                props['MaxTotalPrice'] = self.max_total_price

        if self.capacity_reservation_options is not None:
            if hasattr(self.capacity_reservation_options, 'to_dict'):
                props['CapacityReservationOptions'] = self.capacity_reservation_options.to_dict()
            elif isinstance(self.capacity_reservation_options, list):
                props['CapacityReservationOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_options
                ]
            else:
                props['CapacityReservationOptions'] = self.capacity_reservation_options

        return props


@dataclass
class PerformanceFactorReferenceRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_family: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_family is not None:
            if hasattr(self.instance_family, 'to_dict'):
                props['InstanceFamily'] = self.instance_family.to_dict()
            elif isinstance(self.instance_family, list):
                props['InstanceFamily'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_family
                ]
            else:
                props['InstanceFamily'] = self.instance_family

        return props


@dataclass
class Placement:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tenancy: Optional[Union[str, Tenancy, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spread_domain: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    partition_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    affinity: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    host_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    host_resource_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.group_name is not None:
            if hasattr(self.group_name, 'to_dict'):
                props['GroupName'] = self.group_name.to_dict()
            elif isinstance(self.group_name, list):
                props['GroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_name
                ]
            else:
                props['GroupName'] = self.group_name

        if self.tenancy is not None:
            if hasattr(self.tenancy, 'to_dict'):
                props['Tenancy'] = self.tenancy.to_dict()
            elif isinstance(self.tenancy, list):
                props['Tenancy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tenancy
                ]
            else:
                props['Tenancy'] = self.tenancy

        if self.spread_domain is not None:
            if hasattr(self.spread_domain, 'to_dict'):
                props['SpreadDomain'] = self.spread_domain.to_dict()
            elif isinstance(self.spread_domain, list):
                props['SpreadDomain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spread_domain
                ]
            else:
                props['SpreadDomain'] = self.spread_domain

        if self.partition_number is not None:
            if hasattr(self.partition_number, 'to_dict'):
                props['PartitionNumber'] = self.partition_number.to_dict()
            elif isinstance(self.partition_number, list):
                props['PartitionNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.partition_number
                ]
            else:
                props['PartitionNumber'] = self.partition_number

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        if self.affinity is not None:
            if hasattr(self.affinity, 'to_dict'):
                props['Affinity'] = self.affinity.to_dict()
            elif isinstance(self.affinity, list):
                props['Affinity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.affinity
                ]
            else:
                props['Affinity'] = self.affinity

        if self.host_id is not None:
            if hasattr(self.host_id, 'to_dict'):
                props['HostId'] = self.host_id.to_dict()
            elif isinstance(self.host_id, list):
                props['HostId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_id
                ]
            else:
                props['HostId'] = self.host_id

        if self.host_resource_group_arn is not None:
            if hasattr(self.host_resource_group_arn, 'to_dict'):
                props['HostResourceGroupArn'] = self.host_resource_group_arn.to_dict()
            elif isinstance(self.host_resource_group_arn, list):
                props['HostResourceGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_resource_group_arn
                ]
            else:
                props['HostResourceGroupArn'] = self.host_resource_group_arn

        return props


@dataclass
class SpotOptionsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    single_availability_zone: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allocation_strategy: Optional[Union[str, SpotAllocationStrategy, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    single_instance_type: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_target_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_total_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maintenance_strategies: Optional[MaintenanceStrategies] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_interruption_behavior: Optional[Union[str, SpotInstanceInterruptionBehavior, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_pools_to_use_count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.single_availability_zone is not None:
            if hasattr(self.single_availability_zone, 'to_dict'):
                props['SingleAvailabilityZone'] = self.single_availability_zone.to_dict()
            elif isinstance(self.single_availability_zone, list):
                props['SingleAvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.single_availability_zone
                ]
            else:
                props['SingleAvailabilityZone'] = self.single_availability_zone

        if self.allocation_strategy is not None:
            if hasattr(self.allocation_strategy, 'to_dict'):
                props['AllocationStrategy'] = self.allocation_strategy.to_dict()
            elif isinstance(self.allocation_strategy, list):
                props['AllocationStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_strategy
                ]
            else:
                props['AllocationStrategy'] = self.allocation_strategy

        if self.single_instance_type is not None:
            if hasattr(self.single_instance_type, 'to_dict'):
                props['SingleInstanceType'] = self.single_instance_type.to_dict()
            elif isinstance(self.single_instance_type, list):
                props['SingleInstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.single_instance_type
                ]
            else:
                props['SingleInstanceType'] = self.single_instance_type

        if self.min_target_capacity is not None:
            if hasattr(self.min_target_capacity, 'to_dict'):
                props['MinTargetCapacity'] = self.min_target_capacity.to_dict()
            elif isinstance(self.min_target_capacity, list):
                props['MinTargetCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_target_capacity
                ]
            else:
                props['MinTargetCapacity'] = self.min_target_capacity

        if self.max_total_price is not None:
            if hasattr(self.max_total_price, 'to_dict'):
                props['MaxTotalPrice'] = self.max_total_price.to_dict()
            elif isinstance(self.max_total_price, list):
                props['MaxTotalPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_total_price
                ]
            else:
                props['MaxTotalPrice'] = self.max_total_price

        if self.maintenance_strategies is not None:
            if hasattr(self.maintenance_strategies, 'to_dict'):
                props['MaintenanceStrategies'] = self.maintenance_strategies.to_dict()
            elif isinstance(self.maintenance_strategies, list):
                props['MaintenanceStrategies'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maintenance_strategies
                ]
            else:
                props['MaintenanceStrategies'] = self.maintenance_strategies

        if self.instance_interruption_behavior is not None:
            if hasattr(self.instance_interruption_behavior, 'to_dict'):
                props['InstanceInterruptionBehavior'] = self.instance_interruption_behavior.to_dict()
            elif isinstance(self.instance_interruption_behavior, list):
                props['InstanceInterruptionBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_interruption_behavior
                ]
            else:
                props['InstanceInterruptionBehavior'] = self.instance_interruption_behavior

        if self.instance_pools_to_use_count is not None:
            if hasattr(self.instance_pools_to_use_count, 'to_dict'):
                props['InstancePoolsToUseCount'] = self.instance_pools_to_use_count.to_dict()
            elif isinstance(self.instance_pools_to_use_count, list):
                props['InstancePoolsToUseCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_pools_to_use_count
                ]
            else:
                props['InstancePoolsToUseCount'] = self.instance_pools_to_use_count

        return props


@dataclass
class TagSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, ResourceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tags: Optional[list[Tag]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        if self.tags is not None:
            if hasattr(self.tags, 'to_dict'):
                props['Tags'] = self.tags.to_dict()
            elif isinstance(self.tags, list):
                props['Tags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tags
                ]
            else:
                props['Tags'] = self.tags

        return props


@dataclass
class TargetCapacitySpecificationRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_target_capacity_type: Optional[Union[str, DefaultTargetCapacityType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    total_target_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_target_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_target_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_capacity_unit_type: Optional[Union[str, TargetCapacityUnitType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_target_capacity_type is not None:
            if hasattr(self.default_target_capacity_type, 'to_dict'):
                props['DefaultTargetCapacityType'] = self.default_target_capacity_type.to_dict()
            elif isinstance(self.default_target_capacity_type, list):
                props['DefaultTargetCapacityType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_target_capacity_type
                ]
            else:
                props['DefaultTargetCapacityType'] = self.default_target_capacity_type

        if self.total_target_capacity is not None:
            if hasattr(self.total_target_capacity, 'to_dict'):
                props['TotalTargetCapacity'] = self.total_target_capacity.to_dict()
            elif isinstance(self.total_target_capacity, list):
                props['TotalTargetCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_target_capacity
                ]
            else:
                props['TotalTargetCapacity'] = self.total_target_capacity

        if self.on_demand_target_capacity is not None:
            if hasattr(self.on_demand_target_capacity, 'to_dict'):
                props['OnDemandTargetCapacity'] = self.on_demand_target_capacity.to_dict()
            elif isinstance(self.on_demand_target_capacity, list):
                props['OnDemandTargetCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_target_capacity
                ]
            else:
                props['OnDemandTargetCapacity'] = self.on_demand_target_capacity

        if self.spot_target_capacity is not None:
            if hasattr(self.spot_target_capacity, 'to_dict'):
                props['SpotTargetCapacity'] = self.spot_target_capacity.to_dict()
            elif isinstance(self.spot_target_capacity, list):
                props['SpotTargetCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_target_capacity
                ]
            else:
                props['SpotTargetCapacity'] = self.spot_target_capacity

        if self.target_capacity_unit_type is not None:
            if hasattr(self.target_capacity_unit_type, 'to_dict'):
                props['TargetCapacityUnitType'] = self.target_capacity_unit_type.to_dict()
            elif isinstance(self.target_capacity_unit_type, list):
                props['TargetCapacityUnitType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_capacity_unit_type
                ]
            else:
                props['TargetCapacityUnitType'] = self.target_capacity_unit_type

        return props


@dataclass
class TotalLocalStorageGBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class VCpuCountRangeRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class EC2Fleet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-e"""

    resource_type: ClassVar[str] = "AWS::EC2::EC2Fleet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    context: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_capacity_specification: Optional[TargetCapacitySpecificationRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    on_demand_options: Optional[OnDemandOptionsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    excess_capacity_termination_policy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tag_specifications: Optional[list[TagSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    spot_options: Optional[SpotOptionsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    valid_from: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    replace_unhealthy_instances: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_template_configs: Optional[list[FleetLaunchTemplateConfigRequest]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    terminate_instances_with_expiration: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    valid_until: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.context is not None:
            # Serialize context (handle intrinsic functions)
            if hasattr(self.context, 'to_dict'):
                props["Context"] = self.context.to_dict()
            elif isinstance(self.context, list):
                # Serialize list items (may contain intrinsic functions)
                props['Context'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.context
                ]
            else:
                props["Context"] = self.context

        if self.target_capacity_specification is not None:
            # Serialize target_capacity_specification (handle intrinsic functions)
            if hasattr(self.target_capacity_specification, 'to_dict'):
                props["TargetCapacitySpecification"] = self.target_capacity_specification.to_dict()
            elif isinstance(self.target_capacity_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetCapacitySpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_capacity_specification
                ]
            else:
                props["TargetCapacitySpecification"] = self.target_capacity_specification

        if self.on_demand_options is not None:
            # Serialize on_demand_options (handle intrinsic functions)
            if hasattr(self.on_demand_options, 'to_dict'):
                props["OnDemandOptions"] = self.on_demand_options.to_dict()
            elif isinstance(self.on_demand_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['OnDemandOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_options
                ]
            else:
                props["OnDemandOptions"] = self.on_demand_options

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.excess_capacity_termination_policy is not None:
            # Serialize excess_capacity_termination_policy (handle intrinsic functions)
            if hasattr(self.excess_capacity_termination_policy, 'to_dict'):
                props["ExcessCapacityTerminationPolicy"] = self.excess_capacity_termination_policy.to_dict()
            elif isinstance(self.excess_capacity_termination_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExcessCapacityTerminationPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.excess_capacity_termination_policy
                ]
            else:
                props["ExcessCapacityTerminationPolicy"] = self.excess_capacity_termination_policy

        if self.tag_specifications is not None:
            # Serialize tag_specifications (handle intrinsic functions)
            if hasattr(self.tag_specifications, 'to_dict'):
                props["TagSpecifications"] = self.tag_specifications.to_dict()
            elif isinstance(self.tag_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['TagSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_specifications
                ]
            else:
                props["TagSpecifications"] = self.tag_specifications

        if self.spot_options is not None:
            # Serialize spot_options (handle intrinsic functions)
            if hasattr(self.spot_options, 'to_dict'):
                props["SpotOptions"] = self.spot_options.to_dict()
            elif isinstance(self.spot_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['SpotOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_options
                ]
            else:
                props["SpotOptions"] = self.spot_options

        if self.valid_from is not None:
            # Serialize valid_from (handle intrinsic functions)
            if hasattr(self.valid_from, 'to_dict'):
                props["ValidFrom"] = self.valid_from.to_dict()
            elif isinstance(self.valid_from, list):
                # Serialize list items (may contain intrinsic functions)
                props['ValidFrom'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.valid_from
                ]
            else:
                props["ValidFrom"] = self.valid_from

        if self.replace_unhealthy_instances is not None:
            # Serialize replace_unhealthy_instances (handle intrinsic functions)
            if hasattr(self.replace_unhealthy_instances, 'to_dict'):
                props["ReplaceUnhealthyInstances"] = self.replace_unhealthy_instances.to_dict()
            elif isinstance(self.replace_unhealthy_instances, list):
                # Serialize list items (may contain intrinsic functions)
                props['ReplaceUnhealthyInstances'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.replace_unhealthy_instances
                ]
            else:
                props["ReplaceUnhealthyInstances"] = self.replace_unhealthy_instances

        if self.launch_template_configs is not None:
            # Serialize launch_template_configs (handle intrinsic functions)
            if hasattr(self.launch_template_configs, 'to_dict'):
                props["LaunchTemplateConfigs"] = self.launch_template_configs.to_dict()
            elif isinstance(self.launch_template_configs, list):
                # Serialize list items (may contain intrinsic functions)
                props['LaunchTemplateConfigs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_configs
                ]
            else:
                props["LaunchTemplateConfigs"] = self.launch_template_configs

        if self.terminate_instances_with_expiration is not None:
            # Serialize terminate_instances_with_expiration (handle intrinsic functions)
            if hasattr(self.terminate_instances_with_expiration, 'to_dict'):
                props["TerminateInstancesWithExpiration"] = self.terminate_instances_with_expiration.to_dict()
            elif isinstance(self.terminate_instances_with_expiration, list):
                # Serialize list items (may contain intrinsic functions)
                props['TerminateInstancesWithExpiration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.terminate_instances_with_expiration
                ]
            else:
                props["TerminateInstancesWithExpiration"] = self.terminate_instances_with_expiration

        if self.valid_until is not None:
            # Serialize valid_until (handle intrinsic functions)
            if hasattr(self.valid_until, 'to_dict'):
                props["ValidUntil"] = self.valid_until.to_dict()
            elif isinstance(self.valid_until, list):
                # Serialize list items (may contain intrinsic functions)
                props['ValidUntil'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.valid_until
                ]
            else:
                props["ValidUntil"] = self.valid_until

        return props

    @property
    def attr_fleet_id(self) -> GetAtt:
        """Get the FleetId attribute."""
        return self.get_att("FleetId")




@dataclass
class EIP(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-e"""

    resource_type: ClassVar[str] = "AWS::EC2::EIP"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    public_ipv4_pool: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transfer_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_border_group: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.address is not None:
            # Serialize address (handle intrinsic functions)
            if hasattr(self.address, 'to_dict'):
                props["Address"] = self.address.to_dict()
            elif isinstance(self.address, list):
                # Serialize list items (may contain intrinsic functions)
                props['Address'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.address
                ]
            else:
                props["Address"] = self.address

        if self.instance_id is not None:
            # Serialize instance_id (handle intrinsic functions)
            if hasattr(self.instance_id, 'to_dict'):
                props["InstanceId"] = self.instance_id.to_dict()
            elif isinstance(self.instance_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_id
                ]
            else:
                props["InstanceId"] = self.instance_id

        if self.ipam_pool_id is not None:
            # Serialize ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipam_pool_id, 'to_dict'):
                props["IpamPoolId"] = self.ipam_pool_id.to_dict()
            elif isinstance(self.ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipam_pool_id
                ]
            else:
                props["IpamPoolId"] = self.ipam_pool_id

        if self.public_ipv4_pool is not None:
            # Serialize public_ipv4_pool (handle intrinsic functions)
            if hasattr(self.public_ipv4_pool, 'to_dict'):
                props["PublicIpv4Pool"] = self.public_ipv4_pool.to_dict()
            elif isinstance(self.public_ipv4_pool, list):
                # Serialize list items (may contain intrinsic functions)
                props['PublicIpv4Pool'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_ipv4_pool
                ]
            else:
                props["PublicIpv4Pool"] = self.public_ipv4_pool

        if self.transfer_address is not None:
            # Serialize transfer_address (handle intrinsic functions)
            if hasattr(self.transfer_address, 'to_dict'):
                props["TransferAddress"] = self.transfer_address.to_dict()
            elif isinstance(self.transfer_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransferAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transfer_address
                ]
            else:
                props["TransferAddress"] = self.transfer_address

        if self.domain is not None:
            # Serialize domain (handle intrinsic functions)
            if hasattr(self.domain, 'to_dict'):
                props["Domain"] = self.domain.to_dict()
            elif isinstance(self.domain, list):
                # Serialize list items (may contain intrinsic functions)
                props['Domain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain
                ]
            else:
                props["Domain"] = self.domain

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.network_border_group is not None:
            # Serialize network_border_group (handle intrinsic functions)
            if hasattr(self.network_border_group, 'to_dict'):
                props["NetworkBorderGroup"] = self.network_border_group.to_dict()
            elif isinstance(self.network_border_group, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkBorderGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_border_group
                ]
            else:
                props["NetworkBorderGroup"] = self.network_border_group

        return props

    @property
    def attr_public_ip(self) -> GetAtt:
        """Get the PublicIp attribute."""
        return self.get_att("PublicIp")

    @property
    def attr_allocation_id(self) -> GetAtt:
        """Get the AllocationId attribute."""
        return self.get_att("AllocationId")




@dataclass
class EIPAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-e"""

    resource_type: ClassVar[str] = "AWS::EC2::EIPAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allocation_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.private_ip_address is not None:
            # Serialize private_ip_address (handle intrinsic functions)
            if hasattr(self.private_ip_address, 'to_dict'):
                props["PrivateIpAddress"] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props["PrivateIpAddress"] = self.private_ip_address

        if self.instance_id is not None:
            # Serialize instance_id (handle intrinsic functions)
            if hasattr(self.instance_id, 'to_dict'):
                props["InstanceId"] = self.instance_id.to_dict()
            elif isinstance(self.instance_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_id
                ]
            else:
                props["InstanceId"] = self.instance_id

        if self.allocation_id is not None:
            # Serialize allocation_id (handle intrinsic functions)
            if hasattr(self.allocation_id, 'to_dict'):
                props["AllocationId"] = self.allocation_id.to_dict()
            elif isinstance(self.allocation_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllocationId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_id
                ]
            else:
                props["AllocationId"] = self.allocation_id

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class EgressOnlyInternetGateway(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-e"""

    resource_type: ClassVar[str] = "AWS::EC2::EgressOnlyInternetGateway"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class EnclaveCertificateIamRoleAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-e"""

    resource_type: ClassVar[str] = "AWS::EC2::EnclaveCertificateIamRoleAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    certificate_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        if self.certificate_arn is not None:
            # Serialize certificate_arn (handle intrinsic functions)
            if hasattr(self.certificate_arn, 'to_dict'):
                props["CertificateArn"] = self.certificate_arn.to_dict()
            elif isinstance(self.certificate_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['CertificateArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certificate_arn
                ]
            else:
                props["CertificateArn"] = self.certificate_arn

        return props

    @property
    def attr_encryption_kms_key_id(self) -> GetAtt:
        """Get the EncryptionKmsKeyId attribute."""
        return self.get_att("EncryptionKmsKeyId")

    @property
    def attr_certificate_s3_bucket_name(self) -> GetAtt:
        """Get the CertificateS3BucketName attribute."""
        return self.get_att("CertificateS3BucketName")

    @property
    def attr_certificate_s3_object_key(self) -> GetAtt:
        """Get the CertificateS3ObjectKey attribute."""
        return self.get_att("CertificateS3ObjectKey")




@dataclass
class DestinationOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    per_hour_partition: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hive_compatible_partitions: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_format: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.per_hour_partition is not None:
            if hasattr(self.per_hour_partition, 'to_dict'):
                props['PerHourPartition'] = self.per_hour_partition.to_dict()
            elif isinstance(self.per_hour_partition, list):
                props['PerHourPartition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.per_hour_partition
                ]
            else:
                props['PerHourPartition'] = self.per_hour_partition

        if self.hive_compatible_partitions is not None:
            if hasattr(self.hive_compatible_partitions, 'to_dict'):
                props['HiveCompatiblePartitions'] = self.hive_compatible_partitions.to_dict()
            elif isinstance(self.hive_compatible_partitions, list):
                props['HiveCompatiblePartitions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hive_compatible_partitions
                ]
            else:
                props['HiveCompatiblePartitions'] = self.hive_compatible_partitions

        if self.file_format is not None:
            if hasattr(self.file_format, 'to_dict'):
                props['FileFormat'] = self.file_format.to_dict()
            elif isinstance(self.file_format, list):
                props['FileFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_format
                ]
            else:
                props['FileFormat'] = self.file_format

        return props


@dataclass
class FlowLog(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-f"""

    resource_type: ClassVar[str] = "AWS::EC2::FlowLog"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_aggregation_interval: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_options: Optional[DestinationOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    deliver_cross_account_role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_destination: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    deliver_logs_permission_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_destination_type: Optional[Union[str, LogDestinationType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    traffic_type: Optional[Union[str, TrafficType, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.log_format is not None:
            # Serialize log_format (handle intrinsic functions)
            if hasattr(self.log_format, 'to_dict'):
                props["LogFormat"] = self.log_format.to_dict()
            elif isinstance(self.log_format, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_format
                ]
            else:
                props["LogFormat"] = self.log_format

        if self.resource_id is not None:
            # Serialize resource_id (handle intrinsic functions)
            if hasattr(self.resource_id, 'to_dict'):
                props["ResourceId"] = self.resource_id.to_dict()
            elif isinstance(self.resource_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_id
                ]
            else:
                props["ResourceId"] = self.resource_id

        if self.max_aggregation_interval is not None:
            # Serialize max_aggregation_interval (handle intrinsic functions)
            if hasattr(self.max_aggregation_interval, 'to_dict'):
                props["MaxAggregationInterval"] = self.max_aggregation_interval.to_dict()
            elif isinstance(self.max_aggregation_interval, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxAggregationInterval'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_aggregation_interval
                ]
            else:
                props["MaxAggregationInterval"] = self.max_aggregation_interval

        if self.destination_options is not None:
            # Serialize destination_options (handle intrinsic functions)
            if hasattr(self.destination_options, 'to_dict'):
                props["DestinationOptions"] = self.destination_options.to_dict()
            elif isinstance(self.destination_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_options
                ]
            else:
                props["DestinationOptions"] = self.destination_options

        if self.resource_type is not None:
            # Serialize resource_type (handle intrinsic functions)
            if hasattr(self.resource_type, 'to_dict'):
                props["ResourceType"] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props["ResourceType"] = self.resource_type

        if self.deliver_cross_account_role is not None:
            # Serialize deliver_cross_account_role (handle intrinsic functions)
            if hasattr(self.deliver_cross_account_role, 'to_dict'):
                props["DeliverCrossAccountRole"] = self.deliver_cross_account_role.to_dict()
            elif isinstance(self.deliver_cross_account_role, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeliverCrossAccountRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.deliver_cross_account_role
                ]
            else:
                props["DeliverCrossAccountRole"] = self.deliver_cross_account_role

        if self.log_destination is not None:
            # Serialize log_destination (handle intrinsic functions)
            if hasattr(self.log_destination, 'to_dict'):
                props["LogDestination"] = self.log_destination.to_dict()
            elif isinstance(self.log_destination, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogDestination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_destination
                ]
            else:
                props["LogDestination"] = self.log_destination

        if self.log_group_name is not None:
            # Serialize log_group_name (handle intrinsic functions)
            if hasattr(self.log_group_name, 'to_dict'):
                props["LogGroupName"] = self.log_group_name.to_dict()
            elif isinstance(self.log_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_name
                ]
            else:
                props["LogGroupName"] = self.log_group_name

        if self.deliver_logs_permission_arn is not None:
            # Serialize deliver_logs_permission_arn (handle intrinsic functions)
            if hasattr(self.deliver_logs_permission_arn, 'to_dict'):
                props["DeliverLogsPermissionArn"] = self.deliver_logs_permission_arn.to_dict()
            elif isinstance(self.deliver_logs_permission_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeliverLogsPermissionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.deliver_logs_permission_arn
                ]
            else:
                props["DeliverLogsPermissionArn"] = self.deliver_logs_permission_arn

        if self.log_destination_type is not None:
            # Serialize log_destination_type (handle intrinsic functions)
            if hasattr(self.log_destination_type, 'to_dict'):
                props["LogDestinationType"] = self.log_destination_type.to_dict()
            elif isinstance(self.log_destination_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogDestinationType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_destination_type
                ]
            else:
                props["LogDestinationType"] = self.log_destination_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.traffic_type is not None:
            # Serialize traffic_type (handle intrinsic functions)
            if hasattr(self.traffic_type, 'to_dict'):
                props["TrafficType"] = self.traffic_type.to_dict()
            elif isinstance(self.traffic_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['TrafficType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.traffic_type
                ]
            else:
                props["TrafficType"] = self.traffic_type

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class GatewayRouteTableAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-g"""

    resource_type: ClassVar[str] = "AWS::EC2::GatewayRouteTableAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.route_table_id is not None:
            # Serialize route_table_id (handle intrinsic functions)
            if hasattr(self.route_table_id, 'to_dict'):
                props["RouteTableId"] = self.route_table_id.to_dict()
            elif isinstance(self.route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_id
                ]
            else:
                props["RouteTableId"] = self.route_table_id

        if self.gateway_id is not None:
            # Serialize gateway_id (handle intrinsic functions)
            if hasattr(self.gateway_id, 'to_dict'):
                props["GatewayId"] = self.gateway_id.to_dict()
            elif isinstance(self.gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['GatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gateway_id
                ]
            else:
                props["GatewayId"] = self.gateway_id

        return props

    @property
    def attr_association_id(self) -> GetAtt:
        """Get the AssociationId attribute."""
        return self.get_att("AssociationId")




@dataclass
class Host(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-h"""

    resource_type: ClassVar[str] = "AWS::EC2::Host"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    host_recovery: Optional[Union[str, HostRecovery, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_family: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_placement: Optional[Union[str, AutoPlacement, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    outpost_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    host_maintenance: Optional[Union[str, HostMaintenance, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    asset_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.host_recovery is not None:
            # Serialize host_recovery (handle intrinsic functions)
            if hasattr(self.host_recovery, 'to_dict'):
                props["HostRecovery"] = self.host_recovery.to_dict()
            elif isinstance(self.host_recovery, list):
                # Serialize list items (may contain intrinsic functions)
                props['HostRecovery'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_recovery
                ]
            else:
                props["HostRecovery"] = self.host_recovery

        if self.instance_family is not None:
            # Serialize instance_family (handle intrinsic functions)
            if hasattr(self.instance_family, 'to_dict'):
                props["InstanceFamily"] = self.instance_family.to_dict()
            elif isinstance(self.instance_family, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceFamily'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_family
                ]
            else:
                props["InstanceFamily"] = self.instance_family

        if self.auto_placement is not None:
            # Serialize auto_placement (handle intrinsic functions)
            if hasattr(self.auto_placement, 'to_dict'):
                props["AutoPlacement"] = self.auto_placement.to_dict()
            elif isinstance(self.auto_placement, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoPlacement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_placement
                ]
            else:
                props["AutoPlacement"] = self.auto_placement

        if self.outpost_arn is not None:
            # Serialize outpost_arn (handle intrinsic functions)
            if hasattr(self.outpost_arn, 'to_dict'):
                props["OutpostArn"] = self.outpost_arn.to_dict()
            elif isinstance(self.outpost_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutpostArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.outpost_arn
                ]
            else:
                props["OutpostArn"] = self.outpost_arn

        if self.host_maintenance is not None:
            # Serialize host_maintenance (handle intrinsic functions)
            if hasattr(self.host_maintenance, 'to_dict'):
                props["HostMaintenance"] = self.host_maintenance.to_dict()
            elif isinstance(self.host_maintenance, list):
                # Serialize list items (may contain intrinsic functions)
                props['HostMaintenance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_maintenance
                ]
            else:
                props["HostMaintenance"] = self.host_maintenance

        if self.availability_zone is not None:
            # Serialize availability_zone (handle intrinsic functions)
            if hasattr(self.availability_zone, 'to_dict'):
                props["AvailabilityZone"] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props["AvailabilityZone"] = self.availability_zone

        if self.instance_type is not None:
            # Serialize instance_type (handle intrinsic functions)
            if hasattr(self.instance_type, 'to_dict'):
                props["InstanceType"] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props["InstanceType"] = self.instance_type

        if self.asset_id is not None:
            # Serialize asset_id (handle intrinsic functions)
            if hasattr(self.asset_id, 'to_dict'):
                props["AssetId"] = self.asset_id.to_dict()
            elif isinstance(self.asset_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AssetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.asset_id
                ]
            else:
                props["AssetId"] = self.asset_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_host_id(self) -> GetAtt:
        """Get the HostId attribute."""
        return self.get_att("HostId")




@dataclass
class IpamOperatingRegion:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    region_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.region_name is not None:
            if hasattr(self.region_name, 'to_dict'):
                props['RegionName'] = self.region_name.to_dict()
            elif isinstance(self.region_name, list):
                props['RegionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.region_name
                ]
            else:
                props['RegionName'] = self.region_name

        return props


@dataclass
class IpamOrganizationalUnitExclusion:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    organizations_entity_path: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.organizations_entity_path is not None:
            if hasattr(self.organizations_entity_path, 'to_dict'):
                props['OrganizationsEntityPath'] = self.organizations_entity_path.to_dict()
            elif isinstance(self.organizations_entity_path, list):
                props['OrganizationsEntityPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organizations_entity_path
                ]
            else:
                props['OrganizationsEntityPath'] = self.organizations_entity_path

        return props


@dataclass
class IPAM(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::IPAM"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_resource_discovery_organizational_unit_exclusions: Optional[list[IpamOrganizationalUnitExclusion]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metered_account: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_private_gua: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    operating_regions: Optional[list[IpamOperatingRegion]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_resource_discovery_organizational_unit_exclusions is not None:
            # Serialize default_resource_discovery_organizational_unit_exclusions (handle intrinsic functions)
            if hasattr(self.default_resource_discovery_organizational_unit_exclusions, 'to_dict'):
                props["DefaultResourceDiscoveryOrganizationalUnitExclusions"] = self.default_resource_discovery_organizational_unit_exclusions.to_dict()
            elif isinstance(self.default_resource_discovery_organizational_unit_exclusions, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultResourceDiscoveryOrganizationalUnitExclusions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_resource_discovery_organizational_unit_exclusions
                ]
            else:
                props["DefaultResourceDiscoveryOrganizationalUnitExclusions"] = self.default_resource_discovery_organizational_unit_exclusions

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.metered_account is not None:
            # Serialize metered_account (handle intrinsic functions)
            if hasattr(self.metered_account, 'to_dict'):
                props["MeteredAccount"] = self.metered_account.to_dict()
            elif isinstance(self.metered_account, list):
                # Serialize list items (may contain intrinsic functions)
                props['MeteredAccount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metered_account
                ]
            else:
                props["MeteredAccount"] = self.metered_account

        if self.tier is not None:
            # Serialize tier (handle intrinsic functions)
            if hasattr(self.tier, 'to_dict'):
                props["Tier"] = self.tier.to_dict()
            elif isinstance(self.tier, list):
                # Serialize list items (may contain intrinsic functions)
                props['Tier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tier
                ]
            else:
                props["Tier"] = self.tier

        if self.enable_private_gua is not None:
            # Serialize enable_private_gua (handle intrinsic functions)
            if hasattr(self.enable_private_gua, 'to_dict'):
                props["EnablePrivateGua"] = self.enable_private_gua.to_dict()
            elif isinstance(self.enable_private_gua, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnablePrivateGua'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_private_gua
                ]
            else:
                props["EnablePrivateGua"] = self.enable_private_gua

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.operating_regions is not None:
            # Serialize operating_regions (handle intrinsic functions)
            if hasattr(self.operating_regions, 'to_dict'):
                props["OperatingRegions"] = self.operating_regions.to_dict()
            elif isinstance(self.operating_regions, list):
                # Serialize list items (may contain intrinsic functions)
                props['OperatingRegions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.operating_regions
                ]
            else:
                props["OperatingRegions"] = self.operating_regions

        return props

    @property
    def attr_default_resource_discovery_association_id(self) -> GetAtt:
        """Get the DefaultResourceDiscoveryAssociationId attribute."""
        return self.get_att("DefaultResourceDiscoveryAssociationId")

    @property
    def attr_default_resource_discovery_id(self) -> GetAtt:
        """Get the DefaultResourceDiscoveryId attribute."""
        return self.get_att("DefaultResourceDiscoveryId")

    @property
    def attr_ipam_id(self) -> GetAtt:
        """Get the IpamId attribute."""
        return self.get_att("IpamId")

    @property
    def attr_resource_discovery_association_count(self) -> GetAtt:
        """Get the ResourceDiscoveryAssociationCount attribute."""
        return self.get_att("ResourceDiscoveryAssociationCount")

    @property
    def attr_scope_count(self) -> GetAtt:
        """Get the ScopeCount attribute."""
        return self.get_att("ScopeCount")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_private_default_scope_id(self) -> GetAtt:
        """Get the PrivateDefaultScopeId attribute."""
        return self.get_att("PrivateDefaultScopeId")

    @property
    def attr_public_default_scope_id(self) -> GetAtt:
        """Get the PublicDefaultScopeId attribute."""
        return self.get_att("PublicDefaultScopeId")




@dataclass
class IPAMAllocation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::IPAMAllocation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.cidr is not None:
            # Serialize cidr (handle intrinsic functions)
            if hasattr(self.cidr, 'to_dict'):
                props["Cidr"] = self.cidr.to_dict()
            elif isinstance(self.cidr, list):
                # Serialize list items (may contain intrinsic functions)
                props['Cidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr
                ]
            else:
                props["Cidr"] = self.cidr

        if self.netmask_length is not None:
            # Serialize netmask_length (handle intrinsic functions)
            if hasattr(self.netmask_length, 'to_dict'):
                props["NetmaskLength"] = self.netmask_length.to_dict()
            elif isinstance(self.netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.netmask_length
                ]
            else:
                props["NetmaskLength"] = self.netmask_length

        if self.ipam_pool_id is not None:
            # Serialize ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipam_pool_id, 'to_dict'):
                props["IpamPoolId"] = self.ipam_pool_id.to_dict()
            elif isinstance(self.ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipam_pool_id
                ]
            else:
                props["IpamPoolId"] = self.ipam_pool_id

        return props

    @property
    def attr_ipam_pool_allocation_id(self) -> GetAtt:
        """Get the IpamPoolAllocationId attribute."""
        return self.get_att("IpamPoolAllocationId")




@dataclass
class ProvisionedCidr:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cidr is not None:
            if hasattr(self.cidr, 'to_dict'):
                props['Cidr'] = self.cidr.to_dict()
            elif isinstance(self.cidr, list):
                props['Cidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr
                ]
            else:
                props['Cidr'] = self.cidr

        return props


@dataclass
class SourceResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_owner: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_region is not None:
            if hasattr(self.resource_region, 'to_dict'):
                props['ResourceRegion'] = self.resource_region.to_dict()
            elif isinstance(self.resource_region, list):
                props['ResourceRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_region
                ]
            else:
                props['ResourceRegion'] = self.resource_region

        if self.resource_id is not None:
            if hasattr(self.resource_id, 'to_dict'):
                props['ResourceId'] = self.resource_id.to_dict()
            elif isinstance(self.resource_id, list):
                props['ResourceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_id
                ]
            else:
                props['ResourceId'] = self.resource_id

        if self.resource_owner is not None:
            if hasattr(self.resource_owner, 'to_dict'):
                props['ResourceOwner'] = self.resource_owner.to_dict()
            elif isinstance(self.resource_owner, list):
                props['ResourceOwner'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_owner
                ]
            else:
                props['ResourceOwner'] = self.resource_owner

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        return props


@dataclass
class IPAMPool(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::IPAMPool"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    aws_service: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    locale: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    public_ip_source: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_resource: Optional[SourceResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allocation_min_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipam_scope_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    provisioned_cidrs: Optional[list[ProvisionedCidr]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allocation_max_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allocation_default_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_import: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    address_family: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allocation_resource_tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    publicly_advertisable: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.aws_service is not None:
            # Serialize aws_service (handle intrinsic functions)
            if hasattr(self.aws_service, 'to_dict'):
                props["AwsService"] = self.aws_service.to_dict()
            elif isinstance(self.aws_service, list):
                # Serialize list items (may contain intrinsic functions)
                props['AwsService'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.aws_service
                ]
            else:
                props["AwsService"] = self.aws_service

        if self.locale is not None:
            # Serialize locale (handle intrinsic functions)
            if hasattr(self.locale, 'to_dict'):
                props["Locale"] = self.locale.to_dict()
            elif isinstance(self.locale, list):
                # Serialize list items (may contain intrinsic functions)
                props['Locale'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.locale
                ]
            else:
                props["Locale"] = self.locale

        if self.public_ip_source is not None:
            # Serialize public_ip_source (handle intrinsic functions)
            if hasattr(self.public_ip_source, 'to_dict'):
                props["PublicIpSource"] = self.public_ip_source.to_dict()
            elif isinstance(self.public_ip_source, list):
                # Serialize list items (may contain intrinsic functions)
                props['PublicIpSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_ip_source
                ]
            else:
                props["PublicIpSource"] = self.public_ip_source

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.source_resource is not None:
            # Serialize source_resource (handle intrinsic functions)
            if hasattr(self.source_resource, 'to_dict'):
                props["SourceResource"] = self.source_resource.to_dict()
            elif isinstance(self.source_resource, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceResource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_resource
                ]
            else:
                props["SourceResource"] = self.source_resource

        if self.source_ipam_pool_id is not None:
            # Serialize source_ipam_pool_id (handle intrinsic functions)
            if hasattr(self.source_ipam_pool_id, 'to_dict'):
                props["SourceIpamPoolId"] = self.source_ipam_pool_id.to_dict()
            elif isinstance(self.source_ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceIpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_ipam_pool_id
                ]
            else:
                props["SourceIpamPoolId"] = self.source_ipam_pool_id

        if self.allocation_min_netmask_length is not None:
            # Serialize allocation_min_netmask_length (handle intrinsic functions)
            if hasattr(self.allocation_min_netmask_length, 'to_dict'):
                props["AllocationMinNetmaskLength"] = self.allocation_min_netmask_length.to_dict()
            elif isinstance(self.allocation_min_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllocationMinNetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_min_netmask_length
                ]
            else:
                props["AllocationMinNetmaskLength"] = self.allocation_min_netmask_length

        if self.ipam_scope_id is not None:
            # Serialize ipam_scope_id (handle intrinsic functions)
            if hasattr(self.ipam_scope_id, 'to_dict'):
                props["IpamScopeId"] = self.ipam_scope_id.to_dict()
            elif isinstance(self.ipam_scope_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpamScopeId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipam_scope_id
                ]
            else:
                props["IpamScopeId"] = self.ipam_scope_id

        if self.provisioned_cidrs is not None:
            # Serialize provisioned_cidrs (handle intrinsic functions)
            if hasattr(self.provisioned_cidrs, 'to_dict'):
                props["ProvisionedCidrs"] = self.provisioned_cidrs.to_dict()
            elif isinstance(self.provisioned_cidrs, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProvisionedCidrs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.provisioned_cidrs
                ]
            else:
                props["ProvisionedCidrs"] = self.provisioned_cidrs

        if self.allocation_max_netmask_length is not None:
            # Serialize allocation_max_netmask_length (handle intrinsic functions)
            if hasattr(self.allocation_max_netmask_length, 'to_dict'):
                props["AllocationMaxNetmaskLength"] = self.allocation_max_netmask_length.to_dict()
            elif isinstance(self.allocation_max_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllocationMaxNetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_max_netmask_length
                ]
            else:
                props["AllocationMaxNetmaskLength"] = self.allocation_max_netmask_length

        if self.allocation_default_netmask_length is not None:
            # Serialize allocation_default_netmask_length (handle intrinsic functions)
            if hasattr(self.allocation_default_netmask_length, 'to_dict'):
                props["AllocationDefaultNetmaskLength"] = self.allocation_default_netmask_length.to_dict()
            elif isinstance(self.allocation_default_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllocationDefaultNetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_default_netmask_length
                ]
            else:
                props["AllocationDefaultNetmaskLength"] = self.allocation_default_netmask_length

        if self.auto_import is not None:
            # Serialize auto_import (handle intrinsic functions)
            if hasattr(self.auto_import, 'to_dict'):
                props["AutoImport"] = self.auto_import.to_dict()
            elif isinstance(self.auto_import, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoImport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_import
                ]
            else:
                props["AutoImport"] = self.auto_import

        if self.address_family is not None:
            # Serialize address_family (handle intrinsic functions)
            if hasattr(self.address_family, 'to_dict'):
                props["AddressFamily"] = self.address_family.to_dict()
            elif isinstance(self.address_family, list):
                # Serialize list items (may contain intrinsic functions)
                props['AddressFamily'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.address_family
                ]
            else:
                props["AddressFamily"] = self.address_family

        if self.allocation_resource_tags is not None:
            # Serialize allocation_resource_tags (handle intrinsic functions)
            if hasattr(self.allocation_resource_tags, 'to_dict'):
                props["AllocationResourceTags"] = self.allocation_resource_tags.to_dict()
            elif isinstance(self.allocation_resource_tags, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllocationResourceTags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_resource_tags
                ]
            else:
                props["AllocationResourceTags"] = self.allocation_resource_tags

        if self.publicly_advertisable is not None:
            # Serialize publicly_advertisable (handle intrinsic functions)
            if hasattr(self.publicly_advertisable, 'to_dict'):
                props["PubliclyAdvertisable"] = self.publicly_advertisable.to_dict()
            elif isinstance(self.publicly_advertisable, list):
                # Serialize list items (may contain intrinsic functions)
                props['PubliclyAdvertisable'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.publicly_advertisable
                ]
            else:
                props["PubliclyAdvertisable"] = self.publicly_advertisable

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_ipam_pool_id(self) -> GetAtt:
        """Get the IpamPoolId attribute."""
        return self.get_att("IpamPoolId")

    @property
    def attr_ipam_arn(self) -> GetAtt:
        """Get the IpamArn attribute."""
        return self.get_att("IpamArn")

    @property
    def attr_pool_depth(self) -> GetAtt:
        """Get the PoolDepth attribute."""
        return self.get_att("PoolDepth")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_ipam_scope_arn(self) -> GetAtt:
        """Get the IpamScopeArn attribute."""
        return self.get_att("IpamScopeArn")

    @property
    def attr_ipam_scope_type(self) -> GetAtt:
        """Get the IpamScopeType attribute."""
        return self.get_att("IpamScopeType")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_state_message(self) -> GetAtt:
        """Get the StateMessage attribute."""
        return self.get_att("StateMessage")




@dataclass
class IPAMPoolCidr(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::IPAMPoolCidr"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cidr is not None:
            # Serialize cidr (handle intrinsic functions)
            if hasattr(self.cidr, 'to_dict'):
                props["Cidr"] = self.cidr.to_dict()
            elif isinstance(self.cidr, list):
                # Serialize list items (may contain intrinsic functions)
                props['Cidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr
                ]
            else:
                props["Cidr"] = self.cidr

        if self.netmask_length is not None:
            # Serialize netmask_length (handle intrinsic functions)
            if hasattr(self.netmask_length, 'to_dict'):
                props["NetmaskLength"] = self.netmask_length.to_dict()
            elif isinstance(self.netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.netmask_length
                ]
            else:
                props["NetmaskLength"] = self.netmask_length

        if self.ipam_pool_id is not None:
            # Serialize ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipam_pool_id, 'to_dict'):
                props["IpamPoolId"] = self.ipam_pool_id.to_dict()
            elif isinstance(self.ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipam_pool_id
                ]
            else:
                props["IpamPoolId"] = self.ipam_pool_id

        return props

    @property
    def attr_ipam_pool_cidr_id(self) -> GetAtt:
        """Get the IpamPoolCidrId attribute."""
        return self.get_att("IpamPoolCidrId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")




@dataclass
class IpamOperatingRegion:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    region_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.region_name is not None:
            if hasattr(self.region_name, 'to_dict'):
                props['RegionName'] = self.region_name.to_dict()
            elif isinstance(self.region_name, list):
                props['RegionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.region_name
                ]
            else:
                props['RegionName'] = self.region_name

        return props


@dataclass
class IpamResourceDiscoveryOrganizationalUnitExclusion:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    organizations_entity_path: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.organizations_entity_path is not None:
            if hasattr(self.organizations_entity_path, 'to_dict'):
                props['OrganizationsEntityPath'] = self.organizations_entity_path.to_dict()
            elif isinstance(self.organizations_entity_path, list):
                props['OrganizationsEntityPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organizations_entity_path
                ]
            else:
                props['OrganizationsEntityPath'] = self.organizations_entity_path

        return props


@dataclass
class IPAMResourceDiscovery(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::IPAMResourceDiscovery"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    organizational_unit_exclusions: Optional[list[IpamResourceDiscoveryOrganizationalUnitExclusion]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    operating_regions: Optional[list[IpamOperatingRegion]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.organizational_unit_exclusions is not None:
            # Serialize organizational_unit_exclusions (handle intrinsic functions)
            if hasattr(self.organizational_unit_exclusions, 'to_dict'):
                props["OrganizationalUnitExclusions"] = self.organizational_unit_exclusions.to_dict()
            elif isinstance(self.organizational_unit_exclusions, list):
                # Serialize list items (may contain intrinsic functions)
                props['OrganizationalUnitExclusions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organizational_unit_exclusions
                ]
            else:
                props["OrganizationalUnitExclusions"] = self.organizational_unit_exclusions

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.operating_regions is not None:
            # Serialize operating_regions (handle intrinsic functions)
            if hasattr(self.operating_regions, 'to_dict'):
                props["OperatingRegions"] = self.operating_regions.to_dict()
            elif isinstance(self.operating_regions, list):
                # Serialize list items (may contain intrinsic functions)
                props['OperatingRegions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.operating_regions
                ]
            else:
                props["OperatingRegions"] = self.operating_regions

        return props

    @property
    def attr_is_default(self) -> GetAtt:
        """Get the IsDefault attribute."""
        return self.get_att("IsDefault")

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_ipam_resource_discovery_region(self) -> GetAtt:
        """Get the IpamResourceDiscoveryRegion attribute."""
        return self.get_att("IpamResourceDiscoveryRegion")

    @property
    def attr_ipam_resource_discovery_arn(self) -> GetAtt:
        """Get the IpamResourceDiscoveryArn attribute."""
        return self.get_att("IpamResourceDiscoveryArn")

    @property
    def attr_ipam_resource_discovery_id(self) -> GetAtt:
        """Get the IpamResourceDiscoveryId attribute."""
        return self.get_att("IpamResourceDiscoveryId")




@dataclass
class IPAMResourceDiscoveryAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::IPAMResourceDiscoveryAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipam_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipam_resource_discovery_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipam_id is not None:
            # Serialize ipam_id (handle intrinsic functions)
            if hasattr(self.ipam_id, 'to_dict'):
                props["IpamId"] = self.ipam_id.to_dict()
            elif isinstance(self.ipam_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpamId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipam_id
                ]
            else:
                props["IpamId"] = self.ipam_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.ipam_resource_discovery_id is not None:
            # Serialize ipam_resource_discovery_id (handle intrinsic functions)
            if hasattr(self.ipam_resource_discovery_id, 'to_dict'):
                props["IpamResourceDiscoveryId"] = self.ipam_resource_discovery_id.to_dict()
            elif isinstance(self.ipam_resource_discovery_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpamResourceDiscoveryId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipam_resource_discovery_id
                ]
            else:
                props["IpamResourceDiscoveryId"] = self.ipam_resource_discovery_id

        return props

    @property
    def attr_is_default(self) -> GetAtt:
        """Get the IsDefault attribute."""
        return self.get_att("IsDefault")

    @property
    def attr_resource_discovery_status(self) -> GetAtt:
        """Get the ResourceDiscoveryStatus attribute."""
        return self.get_att("ResourceDiscoveryStatus")

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_ipam_arn(self) -> GetAtt:
        """Get the IpamArn attribute."""
        return self.get_att("IpamArn")

    @property
    def attr_ipam_resource_discovery_association_id(self) -> GetAtt:
        """Get the IpamResourceDiscoveryAssociationId attribute."""
        return self.get_att("IpamResourceDiscoveryAssociationId")

    @property
    def attr_ipam_resource_discovery_association_arn(self) -> GetAtt:
        """Get the IpamResourceDiscoveryAssociationArn attribute."""
        return self.get_att("IpamResourceDiscoveryAssociationArn")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_ipam_region(self) -> GetAtt:
        """Get the IpamRegion attribute."""
        return self.get_att("IpamRegion")




@dataclass
class IpamScopeExternalAuthorityConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    external_resource_identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipam_scope_external_authority_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.external_resource_identifier is not None:
            if hasattr(self.external_resource_identifier, 'to_dict'):
                props['ExternalResourceIdentifier'] = self.external_resource_identifier.to_dict()
            elif isinstance(self.external_resource_identifier, list):
                props['ExternalResourceIdentifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.external_resource_identifier
                ]
            else:
                props['ExternalResourceIdentifier'] = self.external_resource_identifier

        if self.ipam_scope_external_authority_type is not None:
            if hasattr(self.ipam_scope_external_authority_type, 'to_dict'):
                props['IpamScopeExternalAuthorityType'] = self.ipam_scope_external_authority_type.to_dict()
            elif isinstance(self.ipam_scope_external_authority_type, list):
                props['IpamScopeExternalAuthorityType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipam_scope_external_authority_type
                ]
            else:
                props['IpamScopeExternalAuthorityType'] = self.ipam_scope_external_authority_type

        return props


@dataclass
class IPAMScope(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::IPAMScope"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipam_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    external_authority_configuration: Optional[IpamScopeExternalAuthorityConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.ipam_id is not None:
            # Serialize ipam_id (handle intrinsic functions)
            if hasattr(self.ipam_id, 'to_dict'):
                props["IpamId"] = self.ipam_id.to_dict()
            elif isinstance(self.ipam_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpamId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipam_id
                ]
            else:
                props["IpamId"] = self.ipam_id

        if self.external_authority_configuration is not None:
            # Serialize external_authority_configuration (handle intrinsic functions)
            if hasattr(self.external_authority_configuration, 'to_dict'):
                props["ExternalAuthorityConfiguration"] = self.external_authority_configuration.to_dict()
            elif isinstance(self.external_authority_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExternalAuthorityConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.external_authority_configuration
                ]
            else:
                props["ExternalAuthorityConfiguration"] = self.external_authority_configuration

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_ipam_scope_id(self) -> GetAtt:
        """Get the IpamScopeId attribute."""
        return self.get_att("IpamScopeId")

    @property
    def attr_is_default(self) -> GetAtt:
        """Get the IsDefault attribute."""
        return self.get_att("IsDefault")

    @property
    def attr_ipam_arn(self) -> GetAtt:
        """Get the IpamArn attribute."""
        return self.get_att("IpamArn")

    @property
    def attr_ipam_scope_type(self) -> GetAtt:
        """Get the IpamScopeType attribute."""
        return self.get_att("IpamScopeType")

    @property
    def attr_pool_count(self) -> GetAtt:
        """Get the PoolCount attribute."""
        return self.get_att("PoolCount")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class AssociationParameter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class BlockDeviceMapping:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs: Optional[Ebs] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    no_device: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    virtual_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ebs is not None:
            if hasattr(self.ebs, 'to_dict'):
                props['Ebs'] = self.ebs.to_dict()
            elif isinstance(self.ebs, list):
                props['Ebs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs
                ]
            else:
                props['Ebs'] = self.ebs

        if self.no_device is not None:
            if hasattr(self.no_device, 'to_dict'):
                props['NoDevice'] = self.no_device.to_dict()
            elif isinstance(self.no_device, list):
                props['NoDevice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.no_device
                ]
            else:
                props['NoDevice'] = self.no_device

        if self.virtual_name is not None:
            if hasattr(self.virtual_name, 'to_dict'):
                props['VirtualName'] = self.virtual_name.to_dict()
            elif isinstance(self.virtual_name, list):
                props['VirtualName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.virtual_name
                ]
            else:
                props['VirtualName'] = self.virtual_name

        if self.device_name is not None:
            if hasattr(self.device_name, 'to_dict'):
                props['DeviceName'] = self.device_name.to_dict()
            elif isinstance(self.device_name, list):
                props['DeviceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_name
                ]
            else:
                props['DeviceName'] = self.device_name

        return props


@dataclass
class CpuOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    threads_per_core: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    core_count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.threads_per_core is not None:
            if hasattr(self.threads_per_core, 'to_dict'):
                props['ThreadsPerCore'] = self.threads_per_core.to_dict()
            elif isinstance(self.threads_per_core, list):
                props['ThreadsPerCore'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.threads_per_core
                ]
            else:
                props['ThreadsPerCore'] = self.threads_per_core

        if self.core_count is not None:
            if hasattr(self.core_count, 'to_dict'):
                props['CoreCount'] = self.core_count.to_dict()
            elif isinstance(self.core_count, list):
                props['CoreCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.core_count
                ]
            else:
                props['CoreCount'] = self.core_count

        return props


@dataclass
class CreditSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_credits: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cpu_credits is not None:
            if hasattr(self.cpu_credits, 'to_dict'):
                props['CPUCredits'] = self.cpu_credits.to_dict()
            elif isinstance(self.cpu_credits, list):
                props['CPUCredits'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_credits
                ]
            else:
                props['CPUCredits'] = self.cpu_credits

        return props


@dataclass
class Ebs:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snapshot_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encrypted: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.snapshot_id is not None:
            if hasattr(self.snapshot_id, 'to_dict'):
                props['SnapshotId'] = self.snapshot_id.to_dict()
            elif isinstance(self.snapshot_id, list):
                props['SnapshotId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snapshot_id
                ]
            else:
                props['SnapshotId'] = self.snapshot_id

        if self.volume_type is not None:
            if hasattr(self.volume_type, 'to_dict'):
                props['VolumeType'] = self.volume_type.to_dict()
            elif isinstance(self.volume_type, list):
                props['VolumeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_type
                ]
            else:
                props['VolumeType'] = self.volume_type

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.encrypted is not None:
            if hasattr(self.encrypted, 'to_dict'):
                props['Encrypted'] = self.encrypted.to_dict()
            elif isinstance(self.encrypted, list):
                props['Encrypted'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encrypted
                ]
            else:
                props['Encrypted'] = self.encrypted

        if self.iops is not None:
            if hasattr(self.iops, 'to_dict'):
                props['Iops'] = self.iops.to_dict()
            elif isinstance(self.iops, list):
                props['Iops'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iops
                ]
            else:
                props['Iops'] = self.iops

        if self.volume_size is not None:
            if hasattr(self.volume_size, 'to_dict'):
                props['VolumeSize'] = self.volume_size.to_dict()
            elif isinstance(self.volume_size, list):
                props['VolumeSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size
                ]
            else:
                props['VolumeSize'] = self.volume_size

        if self.delete_on_termination is not None:
            if hasattr(self.delete_on_termination, 'to_dict'):
                props['DeleteOnTermination'] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props['DeleteOnTermination'] = self.delete_on_termination

        return props


@dataclass
class ElasticGpuSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        return props


@dataclass
class ElasticInferenceAccelerator:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.count is not None:
            if hasattr(self.count, 'to_dict'):
                props['Count'] = self.count.to_dict()
            elif isinstance(self.count, list):
                props['Count'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.count
                ]
            else:
                props['Count'] = self.count

        return props


@dataclass
class EnaSrdSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_udp_specification: Optional[EnaSrdUdpSpecification] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ena_srd_enabled is not None:
            if hasattr(self.ena_srd_enabled, 'to_dict'):
                props['EnaSrdEnabled'] = self.ena_srd_enabled.to_dict()
            elif isinstance(self.ena_srd_enabled, list):
                props['EnaSrdEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_enabled
                ]
            else:
                props['EnaSrdEnabled'] = self.ena_srd_enabled

        if self.ena_srd_udp_specification is not None:
            if hasattr(self.ena_srd_udp_specification, 'to_dict'):
                props['EnaSrdUdpSpecification'] = self.ena_srd_udp_specification.to_dict()
            elif isinstance(self.ena_srd_udp_specification, list):
                props['EnaSrdUdpSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_udp_specification
                ]
            else:
                props['EnaSrdUdpSpecification'] = self.ena_srd_udp_specification

        return props


@dataclass
class EnaSrdUdpSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_udp_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ena_srd_udp_enabled is not None:
            if hasattr(self.ena_srd_udp_enabled, 'to_dict'):
                props['EnaSrdUdpEnabled'] = self.ena_srd_udp_enabled.to_dict()
            elif isinstance(self.ena_srd_udp_enabled, list):
                props['EnaSrdUdpEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_udp_enabled
                ]
            else:
                props['EnaSrdUdpEnabled'] = self.ena_srd_udp_enabled

        return props


@dataclass
class EnclaveOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class HibernationOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    configured: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.configured is not None:
            if hasattr(self.configured, 'to_dict'):
                props['Configured'] = self.configured.to_dict()
            elif isinstance(self.configured, list):
                props['Configured'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.configured
                ]
            else:
                props['Configured'] = self.configured

        return props


@dataclass
class InstanceIpv6Address:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_address: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_address is not None:
            if hasattr(self.ipv6_address, 'to_dict'):
                props['Ipv6Address'] = self.ipv6_address.to_dict()
            elif isinstance(self.ipv6_address, list):
                props['Ipv6Address'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address
                ]
            else:
                props['Ipv6Address'] = self.ipv6_address

        return props


@dataclass
class LaunchTemplateSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.launch_template_name is not None:
            if hasattr(self.launch_template_name, 'to_dict'):
                props['LaunchTemplateName'] = self.launch_template_name.to_dict()
            elif isinstance(self.launch_template_name, list):
                props['LaunchTemplateName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_name
                ]
            else:
                props['LaunchTemplateName'] = self.launch_template_name

        if self.version is not None:
            if hasattr(self.version, 'to_dict'):
                props['Version'] = self.version.to_dict()
            elif isinstance(self.version, list):
                props['Version'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version
                ]
            else:
                props['Version'] = self.version

        if self.launch_template_id is not None:
            if hasattr(self.launch_template_id, 'to_dict'):
                props['LaunchTemplateId'] = self.launch_template_id.to_dict()
            elif isinstance(self.launch_template_id, list):
                props['LaunchTemplateId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_id
                ]
            else:
                props['LaunchTemplateId'] = self.launch_template_id

        return props


@dataclass
class LicenseSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    license_configuration_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.license_configuration_arn is not None:
            if hasattr(self.license_configuration_arn, 'to_dict'):
                props['LicenseConfigurationArn'] = self.license_configuration_arn.to_dict()
            elif isinstance(self.license_configuration_arn, list):
                props['LicenseConfigurationArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.license_configuration_arn
                ]
            else:
                props['LicenseConfigurationArn'] = self.license_configuration_arn

        return props


@dataclass
class MetadataOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_put_response_hop_limit: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_protocol_ipv6: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_tokens: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_metadata_tags: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.http_put_response_hop_limit is not None:
            if hasattr(self.http_put_response_hop_limit, 'to_dict'):
                props['HttpPutResponseHopLimit'] = self.http_put_response_hop_limit.to_dict()
            elif isinstance(self.http_put_response_hop_limit, list):
                props['HttpPutResponseHopLimit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_put_response_hop_limit
                ]
            else:
                props['HttpPutResponseHopLimit'] = self.http_put_response_hop_limit

        if self.http_protocol_ipv6 is not None:
            if hasattr(self.http_protocol_ipv6, 'to_dict'):
                props['HttpProtocolIpv6'] = self.http_protocol_ipv6.to_dict()
            elif isinstance(self.http_protocol_ipv6, list):
                props['HttpProtocolIpv6'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_protocol_ipv6
                ]
            else:
                props['HttpProtocolIpv6'] = self.http_protocol_ipv6

        if self.http_tokens is not None:
            if hasattr(self.http_tokens, 'to_dict'):
                props['HttpTokens'] = self.http_tokens.to_dict()
            elif isinstance(self.http_tokens, list):
                props['HttpTokens'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_tokens
                ]
            else:
                props['HttpTokens'] = self.http_tokens

        if self.instance_metadata_tags is not None:
            if hasattr(self.instance_metadata_tags, 'to_dict'):
                props['InstanceMetadataTags'] = self.instance_metadata_tags.to_dict()
            elif isinstance(self.instance_metadata_tags, list):
                props['InstanceMetadataTags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_metadata_tags
                ]
            else:
                props['InstanceMetadataTags'] = self.instance_metadata_tags

        if self.http_endpoint is not None:
            if hasattr(self.http_endpoint, 'to_dict'):
                props['HttpEndpoint'] = self.http_endpoint.to_dict()
            elif isinstance(self.http_endpoint, list):
                props['HttpEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_endpoint
                ]
            else:
                props['HttpEndpoint'] = self.http_endpoint

        return props


@dataclass
class NetworkInterface:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_addresses: Optional[list[PrivateIpAddressSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    secondary_private_ip_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_index: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    group_set: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_addresses: Optional[list[InstanceIpv6Address]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    associate_public_ip_address: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    associate_carrier_ip_address: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_specification: Optional[EnaSrdSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.private_ip_address is not None:
            if hasattr(self.private_ip_address, 'to_dict'):
                props['PrivateIpAddress'] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props['PrivateIpAddress'] = self.private_ip_address

        if self.private_ip_addresses is not None:
            if hasattr(self.private_ip_addresses, 'to_dict'):
                props['PrivateIpAddresses'] = self.private_ip_addresses.to_dict()
            elif isinstance(self.private_ip_addresses, list):
                props['PrivateIpAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_addresses
                ]
            else:
                props['PrivateIpAddresses'] = self.private_ip_addresses

        if self.secondary_private_ip_address_count is not None:
            if hasattr(self.secondary_private_ip_address_count, 'to_dict'):
                props['SecondaryPrivateIpAddressCount'] = self.secondary_private_ip_address_count.to_dict()
            elif isinstance(self.secondary_private_ip_address_count, list):
                props['SecondaryPrivateIpAddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_private_ip_address_count
                ]
            else:
                props['SecondaryPrivateIpAddressCount'] = self.secondary_private_ip_address_count

        if self.device_index is not None:
            if hasattr(self.device_index, 'to_dict'):
                props['DeviceIndex'] = self.device_index.to_dict()
            elif isinstance(self.device_index, list):
                props['DeviceIndex'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_index
                ]
            else:
                props['DeviceIndex'] = self.device_index

        if self.group_set is not None:
            if hasattr(self.group_set, 'to_dict'):
                props['GroupSet'] = self.group_set.to_dict()
            elif isinstance(self.group_set, list):
                props['GroupSet'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_set
                ]
            else:
                props['GroupSet'] = self.group_set

        if self.ipv6_addresses is not None:
            if hasattr(self.ipv6_addresses, 'to_dict'):
                props['Ipv6Addresses'] = self.ipv6_addresses.to_dict()
            elif isinstance(self.ipv6_addresses, list):
                props['Ipv6Addresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_addresses
                ]
            else:
                props['Ipv6Addresses'] = self.ipv6_addresses

        if self.subnet_id is not None:
            if hasattr(self.subnet_id, 'to_dict'):
                props['SubnetId'] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props['SubnetId'] = self.subnet_id

        if self.associate_public_ip_address is not None:
            if hasattr(self.associate_public_ip_address, 'to_dict'):
                props['AssociatePublicIpAddress'] = self.associate_public_ip_address.to_dict()
            elif isinstance(self.associate_public_ip_address, list):
                props['AssociatePublicIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.associate_public_ip_address
                ]
            else:
                props['AssociatePublicIpAddress'] = self.associate_public_ip_address

        if self.network_interface_id is not None:
            if hasattr(self.network_interface_id, 'to_dict'):
                props['NetworkInterfaceId'] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props['NetworkInterfaceId'] = self.network_interface_id

        if self.associate_carrier_ip_address is not None:
            if hasattr(self.associate_carrier_ip_address, 'to_dict'):
                props['AssociateCarrierIpAddress'] = self.associate_carrier_ip_address.to_dict()
            elif isinstance(self.associate_carrier_ip_address, list):
                props['AssociateCarrierIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.associate_carrier_ip_address
                ]
            else:
                props['AssociateCarrierIpAddress'] = self.associate_carrier_ip_address

        if self.ena_srd_specification is not None:
            if hasattr(self.ena_srd_specification, 'to_dict'):
                props['EnaSrdSpecification'] = self.ena_srd_specification.to_dict()
            elif isinstance(self.ena_srd_specification, list):
                props['EnaSrdSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_specification
                ]
            else:
                props['EnaSrdSpecification'] = self.ena_srd_specification

        if self.ipv6_address_count is not None:
            if hasattr(self.ipv6_address_count, 'to_dict'):
                props['Ipv6AddressCount'] = self.ipv6_address_count.to_dict()
            elif isinstance(self.ipv6_address_count, list):
                props['Ipv6AddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address_count
                ]
            else:
                props['Ipv6AddressCount'] = self.ipv6_address_count

        if self.delete_on_termination is not None:
            if hasattr(self.delete_on_termination, 'to_dict'):
                props['DeleteOnTermination'] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props['DeleteOnTermination'] = self.delete_on_termination

        return props


@dataclass
class PrivateDnsNameOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_resource_name_dns_a_record: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hostname_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_resource_name_dns_aaaa_record: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enable_resource_name_dns_a_record is not None:
            if hasattr(self.enable_resource_name_dns_a_record, 'to_dict'):
                props['EnableResourceNameDnsARecord'] = self.enable_resource_name_dns_a_record.to_dict()
            elif isinstance(self.enable_resource_name_dns_a_record, list):
                props['EnableResourceNameDnsARecord'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_resource_name_dns_a_record
                ]
            else:
                props['EnableResourceNameDnsARecord'] = self.enable_resource_name_dns_a_record

        if self.hostname_type is not None:
            if hasattr(self.hostname_type, 'to_dict'):
                props['HostnameType'] = self.hostname_type.to_dict()
            elif isinstance(self.hostname_type, list):
                props['HostnameType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hostname_type
                ]
            else:
                props['HostnameType'] = self.hostname_type

        if self.enable_resource_name_dns_aaaa_record is not None:
            if hasattr(self.enable_resource_name_dns_aaaa_record, 'to_dict'):
                props['EnableResourceNameDnsAAAARecord'] = self.enable_resource_name_dns_aaaa_record.to_dict()
            elif isinstance(self.enable_resource_name_dns_aaaa_record, list):
                props['EnableResourceNameDnsAAAARecord'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_resource_name_dns_aaaa_record
                ]
            else:
                props['EnableResourceNameDnsAAAARecord'] = self.enable_resource_name_dns_aaaa_record

        return props


@dataclass
class PrivateIpAddressSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    primary: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.private_ip_address is not None:
            if hasattr(self.private_ip_address, 'to_dict'):
                props['PrivateIpAddress'] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props['PrivateIpAddress'] = self.private_ip_address

        if self.primary is not None:
            if hasattr(self.primary, 'to_dict'):
                props['Primary'] = self.primary.to_dict()
            elif isinstance(self.primary, list):
                props['Primary'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.primary
                ]
            else:
                props['Primary'] = self.primary

        return props


@dataclass
class SsmAssociation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    association_parameters: Optional[list[AssociationParameter]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    document_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.association_parameters is not None:
            if hasattr(self.association_parameters, 'to_dict'):
                props['AssociationParameters'] = self.association_parameters.to_dict()
            elif isinstance(self.association_parameters, list):
                props['AssociationParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.association_parameters
                ]
            else:
                props['AssociationParameters'] = self.association_parameters

        if self.document_name is not None:
            if hasattr(self.document_name, 'to_dict'):
                props['DocumentName'] = self.document_name.to_dict()
            elif isinstance(self.document_name, list):
                props['DocumentName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_name
                ]
            else:
                props['DocumentName'] = self.document_name

        return props


@dataclass
class State:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    code: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.code is not None:
            if hasattr(self.code, 'to_dict'):
                props['Code'] = self.code.to_dict()
            elif isinstance(self.code, list):
                props['Code'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code
                ]
            else:
                props['Code'] = self.code

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class Volume:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.volume_id is not None:
            if hasattr(self.volume_id, 'to_dict'):
                props['VolumeId'] = self.volume_id.to_dict()
            elif isinstance(self.volume_id, list):
                props['VolumeId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_id
                ]
            else:
                props['VolumeId'] = self.volume_id

        if self.device is not None:
            if hasattr(self.device, 'to_dict'):
                props['Device'] = self.device.to_dict()
            elif isinstance(self.device, list):
                props['Device'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device
                ]
            else:
                props['Device'] = self.device

        return props


@dataclass
class Instance(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::Instance"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tenancy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    user_data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    block_device_mappings: Optional[list[BlockDeviceMapping]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    iam_instance_profile: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_addresses: Optional[list[InstanceIpv6Address]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kernel_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ebs_optimized: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    propagate_tags_to_volume_on_creation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    elastic_gpu_specifications: Optional[list[ElasticGpuSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    elastic_inference_accelerators: Optional[list[ElasticInferenceAccelerator]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    volumes: Optional[list[Volume]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_template: Optional[LaunchTemplateSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enclave_options: Optional[EnclaveOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interfaces: Optional[list[NetworkInterface]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    image_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_type: Optional[Union[str, InstanceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    monitoring: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    additional_info: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    hibernation_options: Optional[HibernationOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    license_specifications: Optional[list[LicenseSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metadata_options: Optional[MetadataOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_initiated_shutdown_behavior: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cpu_options: Optional[CpuOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_dns_name_options: Optional[PrivateDnsNameOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    host_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    host_resource_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    disable_api_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    key_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ramdisk_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_dest_check: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    placement_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ssm_associations: Optional[list[SsmAssociation]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    affinity: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    credit_specification: Optional[CreditSpecification] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.tenancy is not None:
            # Serialize tenancy (handle intrinsic functions)
            if hasattr(self.tenancy, 'to_dict'):
                props["Tenancy"] = self.tenancy.to_dict()
            elif isinstance(self.tenancy, list):
                # Serialize list items (may contain intrinsic functions)
                props['Tenancy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tenancy
                ]
            else:
                props["Tenancy"] = self.tenancy

        if self.security_groups is not None:
            # Serialize security_groups (handle intrinsic functions)
            if hasattr(self.security_groups, 'to_dict'):
                props["SecurityGroups"] = self.security_groups.to_dict()
            elif isinstance(self.security_groups, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_groups
                ]
            else:
                props["SecurityGroups"] = self.security_groups

        if self.private_ip_address is not None:
            # Serialize private_ip_address (handle intrinsic functions)
            if hasattr(self.private_ip_address, 'to_dict'):
                props["PrivateIpAddress"] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props["PrivateIpAddress"] = self.private_ip_address

        if self.user_data is not None:
            # Serialize user_data (handle intrinsic functions)
            if hasattr(self.user_data, 'to_dict'):
                props["UserData"] = self.user_data.to_dict()
            elif isinstance(self.user_data, list):
                # Serialize list items (may contain intrinsic functions)
                props['UserData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_data
                ]
            else:
                props["UserData"] = self.user_data

        if self.block_device_mappings is not None:
            # Serialize block_device_mappings (handle intrinsic functions)
            if hasattr(self.block_device_mappings, 'to_dict'):
                props["BlockDeviceMappings"] = self.block_device_mappings.to_dict()
            elif isinstance(self.block_device_mappings, list):
                # Serialize list items (may contain intrinsic functions)
                props['BlockDeviceMappings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.block_device_mappings
                ]
            else:
                props["BlockDeviceMappings"] = self.block_device_mappings

        if self.iam_instance_profile is not None:
            # Serialize iam_instance_profile (handle intrinsic functions)
            if hasattr(self.iam_instance_profile, 'to_dict'):
                props["IamInstanceProfile"] = self.iam_instance_profile.to_dict()
            elif isinstance(self.iam_instance_profile, list):
                # Serialize list items (may contain intrinsic functions)
                props['IamInstanceProfile'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iam_instance_profile
                ]
            else:
                props["IamInstanceProfile"] = self.iam_instance_profile

        if self.ipv6_addresses is not None:
            # Serialize ipv6_addresses (handle intrinsic functions)
            if hasattr(self.ipv6_addresses, 'to_dict'):
                props["Ipv6Addresses"] = self.ipv6_addresses.to_dict()
            elif isinstance(self.ipv6_addresses, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6Addresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_addresses
                ]
            else:
                props["Ipv6Addresses"] = self.ipv6_addresses

        if self.kernel_id is not None:
            # Serialize kernel_id (handle intrinsic functions)
            if hasattr(self.kernel_id, 'to_dict'):
                props["KernelId"] = self.kernel_id.to_dict()
            elif isinstance(self.kernel_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['KernelId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kernel_id
                ]
            else:
                props["KernelId"] = self.kernel_id

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        if self.ebs_optimized is not None:
            # Serialize ebs_optimized (handle intrinsic functions)
            if hasattr(self.ebs_optimized, 'to_dict'):
                props["EbsOptimized"] = self.ebs_optimized.to_dict()
            elif isinstance(self.ebs_optimized, list):
                # Serialize list items (may contain intrinsic functions)
                props['EbsOptimized'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_optimized
                ]
            else:
                props["EbsOptimized"] = self.ebs_optimized

        if self.propagate_tags_to_volume_on_creation is not None:
            # Serialize propagate_tags_to_volume_on_creation (handle intrinsic functions)
            if hasattr(self.propagate_tags_to_volume_on_creation, 'to_dict'):
                props["PropagateTagsToVolumeOnCreation"] = self.propagate_tags_to_volume_on_creation.to_dict()
            elif isinstance(self.propagate_tags_to_volume_on_creation, list):
                # Serialize list items (may contain intrinsic functions)
                props['PropagateTagsToVolumeOnCreation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.propagate_tags_to_volume_on_creation
                ]
            else:
                props["PropagateTagsToVolumeOnCreation"] = self.propagate_tags_to_volume_on_creation

        if self.elastic_gpu_specifications is not None:
            # Serialize elastic_gpu_specifications (handle intrinsic functions)
            if hasattr(self.elastic_gpu_specifications, 'to_dict'):
                props["ElasticGpuSpecifications"] = self.elastic_gpu_specifications.to_dict()
            elif isinstance(self.elastic_gpu_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['ElasticGpuSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.elastic_gpu_specifications
                ]
            else:
                props["ElasticGpuSpecifications"] = self.elastic_gpu_specifications

        if self.elastic_inference_accelerators is not None:
            # Serialize elastic_inference_accelerators (handle intrinsic functions)
            if hasattr(self.elastic_inference_accelerators, 'to_dict'):
                props["ElasticInferenceAccelerators"] = self.elastic_inference_accelerators.to_dict()
            elif isinstance(self.elastic_inference_accelerators, list):
                # Serialize list items (may contain intrinsic functions)
                props['ElasticInferenceAccelerators'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.elastic_inference_accelerators
                ]
            else:
                props["ElasticInferenceAccelerators"] = self.elastic_inference_accelerators

        if self.volumes is not None:
            # Serialize volumes (handle intrinsic functions)
            if hasattr(self.volumes, 'to_dict'):
                props["Volumes"] = self.volumes.to_dict()
            elif isinstance(self.volumes, list):
                # Serialize list items (may contain intrinsic functions)
                props['Volumes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volumes
                ]
            else:
                props["Volumes"] = self.volumes

        if self.ipv6_address_count is not None:
            # Serialize ipv6_address_count (handle intrinsic functions)
            if hasattr(self.ipv6_address_count, 'to_dict'):
                props["Ipv6AddressCount"] = self.ipv6_address_count.to_dict()
            elif isinstance(self.ipv6_address_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6AddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address_count
                ]
            else:
                props["Ipv6AddressCount"] = self.ipv6_address_count

        if self.launch_template is not None:
            # Serialize launch_template (handle intrinsic functions)
            if hasattr(self.launch_template, 'to_dict'):
                props["LaunchTemplate"] = self.launch_template.to_dict()
            elif isinstance(self.launch_template, list):
                # Serialize list items (may contain intrinsic functions)
                props['LaunchTemplate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template
                ]
            else:
                props["LaunchTemplate"] = self.launch_template

        if self.enclave_options is not None:
            # Serialize enclave_options (handle intrinsic functions)
            if hasattr(self.enclave_options, 'to_dict'):
                props["EnclaveOptions"] = self.enclave_options.to_dict()
            elif isinstance(self.enclave_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnclaveOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enclave_options
                ]
            else:
                props["EnclaveOptions"] = self.enclave_options

        if self.network_interfaces is not None:
            # Serialize network_interfaces (handle intrinsic functions)
            if hasattr(self.network_interfaces, 'to_dict'):
                props["NetworkInterfaces"] = self.network_interfaces.to_dict()
            elif isinstance(self.network_interfaces, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaces'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interfaces
                ]
            else:
                props["NetworkInterfaces"] = self.network_interfaces

        if self.image_id is not None:
            # Serialize image_id (handle intrinsic functions)
            if hasattr(self.image_id, 'to_dict'):
                props["ImageId"] = self.image_id.to_dict()
            elif isinstance(self.image_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ImageId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_id
                ]
            else:
                props["ImageId"] = self.image_id

        if self.instance_type is not None:
            # Serialize instance_type (handle intrinsic functions)
            if hasattr(self.instance_type, 'to_dict'):
                props["InstanceType"] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props["InstanceType"] = self.instance_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.monitoring is not None:
            # Serialize monitoring (handle intrinsic functions)
            if hasattr(self.monitoring, 'to_dict'):
                props["Monitoring"] = self.monitoring.to_dict()
            elif isinstance(self.monitoring, list):
                # Serialize list items (may contain intrinsic functions)
                props['Monitoring'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring
                ]
            else:
                props["Monitoring"] = self.monitoring

        if self.additional_info is not None:
            # Serialize additional_info (handle intrinsic functions)
            if hasattr(self.additional_info, 'to_dict'):
                props["AdditionalInfo"] = self.additional_info.to_dict()
            elif isinstance(self.additional_info, list):
                # Serialize list items (may contain intrinsic functions)
                props['AdditionalInfo'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_info
                ]
            else:
                props["AdditionalInfo"] = self.additional_info

        if self.hibernation_options is not None:
            # Serialize hibernation_options (handle intrinsic functions)
            if hasattr(self.hibernation_options, 'to_dict'):
                props["HibernationOptions"] = self.hibernation_options.to_dict()
            elif isinstance(self.hibernation_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['HibernationOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hibernation_options
                ]
            else:
                props["HibernationOptions"] = self.hibernation_options

        if self.license_specifications is not None:
            # Serialize license_specifications (handle intrinsic functions)
            if hasattr(self.license_specifications, 'to_dict'):
                props["LicenseSpecifications"] = self.license_specifications.to_dict()
            elif isinstance(self.license_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['LicenseSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.license_specifications
                ]
            else:
                props["LicenseSpecifications"] = self.license_specifications

        if self.metadata_options is not None:
            # Serialize metadata_options (handle intrinsic functions)
            if hasattr(self.metadata_options, 'to_dict'):
                props["MetadataOptions"] = self.metadata_options.to_dict()
            elif isinstance(self.metadata_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['MetadataOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metadata_options
                ]
            else:
                props["MetadataOptions"] = self.metadata_options

        if self.instance_initiated_shutdown_behavior is not None:
            # Serialize instance_initiated_shutdown_behavior (handle intrinsic functions)
            if hasattr(self.instance_initiated_shutdown_behavior, 'to_dict'):
                props["InstanceInitiatedShutdownBehavior"] = self.instance_initiated_shutdown_behavior.to_dict()
            elif isinstance(self.instance_initiated_shutdown_behavior, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceInitiatedShutdownBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_initiated_shutdown_behavior
                ]
            else:
                props["InstanceInitiatedShutdownBehavior"] = self.instance_initiated_shutdown_behavior

        if self.cpu_options is not None:
            # Serialize cpu_options (handle intrinsic functions)
            if hasattr(self.cpu_options, 'to_dict'):
                props["CpuOptions"] = self.cpu_options.to_dict()
            elif isinstance(self.cpu_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['CpuOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_options
                ]
            else:
                props["CpuOptions"] = self.cpu_options

        if self.availability_zone is not None:
            # Serialize availability_zone (handle intrinsic functions)
            if hasattr(self.availability_zone, 'to_dict'):
                props["AvailabilityZone"] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props["AvailabilityZone"] = self.availability_zone

        if self.private_dns_name_options is not None:
            # Serialize private_dns_name_options (handle intrinsic functions)
            if hasattr(self.private_dns_name_options, 'to_dict'):
                props["PrivateDnsNameOptions"] = self.private_dns_name_options.to_dict()
            elif isinstance(self.private_dns_name_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateDnsNameOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_dns_name_options
                ]
            else:
                props["PrivateDnsNameOptions"] = self.private_dns_name_options

        if self.host_id is not None:
            # Serialize host_id (handle intrinsic functions)
            if hasattr(self.host_id, 'to_dict'):
                props["HostId"] = self.host_id.to_dict()
            elif isinstance(self.host_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['HostId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_id
                ]
            else:
                props["HostId"] = self.host_id

        if self.host_resource_group_arn is not None:
            # Serialize host_resource_group_arn (handle intrinsic functions)
            if hasattr(self.host_resource_group_arn, 'to_dict'):
                props["HostResourceGroupArn"] = self.host_resource_group_arn.to_dict()
            elif isinstance(self.host_resource_group_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['HostResourceGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_resource_group_arn
                ]
            else:
                props["HostResourceGroupArn"] = self.host_resource_group_arn

        if self.security_group_ids is not None:
            # Serialize security_group_ids (handle intrinsic functions)
            if hasattr(self.security_group_ids, 'to_dict'):
                props["SecurityGroupIds"] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props["SecurityGroupIds"] = self.security_group_ids

        if self.disable_api_termination is not None:
            # Serialize disable_api_termination (handle intrinsic functions)
            if hasattr(self.disable_api_termination, 'to_dict'):
                props["DisableApiTermination"] = self.disable_api_termination.to_dict()
            elif isinstance(self.disable_api_termination, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisableApiTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disable_api_termination
                ]
            else:
                props["DisableApiTermination"] = self.disable_api_termination

        if self.key_name is not None:
            # Serialize key_name (handle intrinsic functions)
            if hasattr(self.key_name, 'to_dict'):
                props["KeyName"] = self.key_name.to_dict()
            elif isinstance(self.key_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['KeyName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_name
                ]
            else:
                props["KeyName"] = self.key_name

        if self.ramdisk_id is not None:
            # Serialize ramdisk_id (handle intrinsic functions)
            if hasattr(self.ramdisk_id, 'to_dict'):
                props["RamdiskId"] = self.ramdisk_id.to_dict()
            elif isinstance(self.ramdisk_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RamdiskId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ramdisk_id
                ]
            else:
                props["RamdiskId"] = self.ramdisk_id

        if self.source_dest_check is not None:
            # Serialize source_dest_check (handle intrinsic functions)
            if hasattr(self.source_dest_check, 'to_dict'):
                props["SourceDestCheck"] = self.source_dest_check.to_dict()
            elif isinstance(self.source_dest_check, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceDestCheck'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_dest_check
                ]
            else:
                props["SourceDestCheck"] = self.source_dest_check

        if self.placement_group_name is not None:
            # Serialize placement_group_name (handle intrinsic functions)
            if hasattr(self.placement_group_name, 'to_dict'):
                props["PlacementGroupName"] = self.placement_group_name.to_dict()
            elif isinstance(self.placement_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['PlacementGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.placement_group_name
                ]
            else:
                props["PlacementGroupName"] = self.placement_group_name

        if self.ssm_associations is not None:
            # Serialize ssm_associations (handle intrinsic functions)
            if hasattr(self.ssm_associations, 'to_dict'):
                props["SsmAssociations"] = self.ssm_associations.to_dict()
            elif isinstance(self.ssm_associations, list):
                # Serialize list items (may contain intrinsic functions)
                props['SsmAssociations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ssm_associations
                ]
            else:
                props["SsmAssociations"] = self.ssm_associations

        if self.affinity is not None:
            # Serialize affinity (handle intrinsic functions)
            if hasattr(self.affinity, 'to_dict'):
                props["Affinity"] = self.affinity.to_dict()
            elif isinstance(self.affinity, list):
                # Serialize list items (may contain intrinsic functions)
                props['Affinity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.affinity
                ]
            else:
                props["Affinity"] = self.affinity

        if self.credit_specification is not None:
            # Serialize credit_specification (handle intrinsic functions)
            if hasattr(self.credit_specification, 'to_dict'):
                props["CreditSpecification"] = self.credit_specification.to_dict()
            elif isinstance(self.credit_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['CreditSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.credit_specification
                ]
            else:
                props["CreditSpecification"] = self.credit_specification

        return props

    @property
    def attr_state__code(self) -> GetAtt:
        """Get the State.Code attribute."""
        return self.get_att("State.Code")

    @property
    def attr_private_dns_name(self) -> GetAtt:
        """Get the PrivateDnsName attribute."""
        return self.get_att("PrivateDnsName")

    @property
    def attr_vpc_id(self) -> GetAtt:
        """Get the VpcId attribute."""
        return self.get_att("VpcId")

    @property
    def attr_private_ip(self) -> GetAtt:
        """Get the PrivateIp attribute."""
        return self.get_att("PrivateIp")

    @property
    def attr_instance_id(self) -> GetAtt:
        """Get the InstanceId attribute."""
        return self.get_att("InstanceId")

    @property
    def attr_public_ip(self) -> GetAtt:
        """Get the PublicIp attribute."""
        return self.get_att("PublicIp")

    @property
    def attr_state__name(self) -> GetAtt:
        """Get the State.Name attribute."""
        return self.get_att("State.Name")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_availability_zone(self) -> GetAtt:
        """Get the AvailabilityZone attribute."""
        return self.get_att("AvailabilityZone")

    @property
    def attr_public_dns_name(self) -> GetAtt:
        """Get the PublicDnsName attribute."""
        return self.get_att("PublicDnsName")




@dataclass
class InstanceConnectEndpoint(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::InstanceConnectEndpoint"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    preserve_client_ip: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_token: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.preserve_client_ip is not None:
            # Serialize preserve_client_ip (handle intrinsic functions)
            if hasattr(self.preserve_client_ip, 'to_dict'):
                props["PreserveClientIp"] = self.preserve_client_ip.to_dict()
            elif isinstance(self.preserve_client_ip, list):
                # Serialize list items (may contain intrinsic functions)
                props['PreserveClientIp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.preserve_client_ip
                ]
            else:
                props["PreserveClientIp"] = self.preserve_client_ip

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        if self.client_token is not None:
            # Serialize client_token (handle intrinsic functions)
            if hasattr(self.client_token, 'to_dict'):
                props["ClientToken"] = self.client_token.to_dict()
            elif isinstance(self.client_token, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientToken'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_token
                ]
            else:
                props["ClientToken"] = self.client_token

        if self.security_group_ids is not None:
            # Serialize security_group_ids (handle intrinsic functions)
            if hasattr(self.security_group_ids, 'to_dict'):
                props["SecurityGroupIds"] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props["SecurityGroupIds"] = self.security_group_ids

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class InternetGateway(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::InternetGateway"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_internet_gateway_id(self) -> GetAtt:
        """Get the InternetGatewayId attribute."""
        return self.get_att("InternetGatewayId")




@dataclass
class IpPoolRouteTableAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-i"""

    resource_type: ClassVar[str] = "AWS::EC2::IpPoolRouteTableAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    public_ipv4_pool: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.route_table_id is not None:
            # Serialize route_table_id (handle intrinsic functions)
            if hasattr(self.route_table_id, 'to_dict'):
                props["RouteTableId"] = self.route_table_id.to_dict()
            elif isinstance(self.route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_id
                ]
            else:
                props["RouteTableId"] = self.route_table_id

        if self.public_ipv4_pool is not None:
            # Serialize public_ipv4_pool (handle intrinsic functions)
            if hasattr(self.public_ipv4_pool, 'to_dict'):
                props["PublicIpv4Pool"] = self.public_ipv4_pool.to_dict()
            elif isinstance(self.public_ipv4_pool, list):
                # Serialize list items (may contain intrinsic functions)
                props['PublicIpv4Pool'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_ipv4_pool
                ]
            else:
                props["PublicIpv4Pool"] = self.public_ipv4_pool

        return props

    @property
    def attr_association_id(self) -> GetAtt:
        """Get the AssociationId attribute."""
        return self.get_att("AssociationId")




@dataclass
class KeyPair(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-k"""

    resource_type: ClassVar[str] = "AWS::EC2::KeyPair"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    key_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    key_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    key_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    public_key_material: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.key_name is not None:
            # Serialize key_name (handle intrinsic functions)
            if hasattr(self.key_name, 'to_dict'):
                props["KeyName"] = self.key_name.to_dict()
            elif isinstance(self.key_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['KeyName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_name
                ]
            else:
                props["KeyName"] = self.key_name

        if self.key_type is not None:
            # Serialize key_type (handle intrinsic functions)
            if hasattr(self.key_type, 'to_dict'):
                props["KeyType"] = self.key_type.to_dict()
            elif isinstance(self.key_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['KeyType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_type
                ]
            else:
                props["KeyType"] = self.key_type

        if self.key_format is not None:
            # Serialize key_format (handle intrinsic functions)
            if hasattr(self.key_format, 'to_dict'):
                props["KeyFormat"] = self.key_format.to_dict()
            elif isinstance(self.key_format, list):
                # Serialize list items (may contain intrinsic functions)
                props['KeyFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_format
                ]
            else:
                props["KeyFormat"] = self.key_format

        if self.public_key_material is not None:
            # Serialize public_key_material (handle intrinsic functions)
            if hasattr(self.public_key_material, 'to_dict'):
                props["PublicKeyMaterial"] = self.public_key_material.to_dict()
            elif isinstance(self.public_key_material, list):
                # Serialize list items (may contain intrinsic functions)
                props['PublicKeyMaterial'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_key_material
                ]
            else:
                props["PublicKeyMaterial"] = self.public_key_material

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_key_pair_id(self) -> GetAtt:
        """Get the KeyPairId attribute."""
        return self.get_att("KeyPairId")

    @property
    def attr_key_fingerprint(self) -> GetAtt:
        """Get the KeyFingerprint attribute."""
        return self.get_att("KeyFingerprint")




@dataclass
class AcceleratorCount:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class AcceleratorTotalMemoryMiB:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class BaselineEbsBandwidthMbps:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class BaselinePerformanceFactors:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu: Optional[Cpu] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cpu is not None:
            if hasattr(self.cpu, 'to_dict'):
                props['Cpu'] = self.cpu.to_dict()
            elif isinstance(self.cpu, list):
                props['Cpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu
                ]
            else:
                props['Cpu'] = self.cpu

        return props


@dataclass
class BlockDeviceMapping:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs: Optional[Ebs] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    no_device: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    virtual_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ebs is not None:
            if hasattr(self.ebs, 'to_dict'):
                props['Ebs'] = self.ebs.to_dict()
            elif isinstance(self.ebs, list):
                props['Ebs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs
                ]
            else:
                props['Ebs'] = self.ebs

        if self.no_device is not None:
            if hasattr(self.no_device, 'to_dict'):
                props['NoDevice'] = self.no_device.to_dict()
            elif isinstance(self.no_device, list):
                props['NoDevice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.no_device
                ]
            else:
                props['NoDevice'] = self.no_device

        if self.virtual_name is not None:
            if hasattr(self.virtual_name, 'to_dict'):
                props['VirtualName'] = self.virtual_name.to_dict()
            elif isinstance(self.virtual_name, list):
                props['VirtualName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.virtual_name
                ]
            else:
                props['VirtualName'] = self.virtual_name

        if self.device_name is not None:
            if hasattr(self.device_name, 'to_dict'):
                props['DeviceName'] = self.device_name.to_dict()
            elif isinstance(self.device_name, list):
                props['DeviceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_name
                ]
            else:
                props['DeviceName'] = self.device_name

        return props


@dataclass
class CapacityReservationSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_preference: Optional[Union[str, CapacityReservationPreference, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_target: Optional[CapacityReservationTarget] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capacity_reservation_preference is not None:
            if hasattr(self.capacity_reservation_preference, 'to_dict'):
                props['CapacityReservationPreference'] = self.capacity_reservation_preference.to_dict()
            elif isinstance(self.capacity_reservation_preference, list):
                props['CapacityReservationPreference'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_preference
                ]
            else:
                props['CapacityReservationPreference'] = self.capacity_reservation_preference

        if self.capacity_reservation_target is not None:
            if hasattr(self.capacity_reservation_target, 'to_dict'):
                props['CapacityReservationTarget'] = self.capacity_reservation_target.to_dict()
            elif isinstance(self.capacity_reservation_target, list):
                props['CapacityReservationTarget'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_target
                ]
            else:
                props['CapacityReservationTarget'] = self.capacity_reservation_target

        return props


@dataclass
class CapacityReservationTarget:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_resource_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capacity_reservation_resource_group_arn is not None:
            if hasattr(self.capacity_reservation_resource_group_arn, 'to_dict'):
                props['CapacityReservationResourceGroupArn'] = self.capacity_reservation_resource_group_arn.to_dict()
            elif isinstance(self.capacity_reservation_resource_group_arn, list):
                props['CapacityReservationResourceGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_resource_group_arn
                ]
            else:
                props['CapacityReservationResourceGroupArn'] = self.capacity_reservation_resource_group_arn

        if self.capacity_reservation_id is not None:
            if hasattr(self.capacity_reservation_id, 'to_dict'):
                props['CapacityReservationId'] = self.capacity_reservation_id.to_dict()
            elif isinstance(self.capacity_reservation_id, list):
                props['CapacityReservationId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_id
                ]
            else:
                props['CapacityReservationId'] = self.capacity_reservation_id

        return props


@dataclass
class ConnectionTrackingSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    udp_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tcp_established_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    udp_stream_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.udp_timeout is not None:
            if hasattr(self.udp_timeout, 'to_dict'):
                props['UdpTimeout'] = self.udp_timeout.to_dict()
            elif isinstance(self.udp_timeout, list):
                props['UdpTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.udp_timeout
                ]
            else:
                props['UdpTimeout'] = self.udp_timeout

        if self.tcp_established_timeout is not None:
            if hasattr(self.tcp_established_timeout, 'to_dict'):
                props['TcpEstablishedTimeout'] = self.tcp_established_timeout.to_dict()
            elif isinstance(self.tcp_established_timeout, list):
                props['TcpEstablishedTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tcp_established_timeout
                ]
            else:
                props['TcpEstablishedTimeout'] = self.tcp_established_timeout

        if self.udp_stream_timeout is not None:
            if hasattr(self.udp_stream_timeout, 'to_dict'):
                props['UdpStreamTimeout'] = self.udp_stream_timeout.to_dict()
            elif isinstance(self.udp_stream_timeout, list):
                props['UdpStreamTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.udp_stream_timeout
                ]
            else:
                props['UdpStreamTimeout'] = self.udp_stream_timeout

        return props


@dataclass
class Cpu:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    references: Optional[list[Reference]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.references is not None:
            if hasattr(self.references, 'to_dict'):
                props['References'] = self.references.to_dict()
            elif isinstance(self.references, list):
                props['References'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.references
                ]
            else:
                props['References'] = self.references

        return props


@dataclass
class CpuOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    threads_per_core: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    amd_sev_snp: Optional[Union[str, AmdSevSnpSpecification, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    core_count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.threads_per_core is not None:
            if hasattr(self.threads_per_core, 'to_dict'):
                props['ThreadsPerCore'] = self.threads_per_core.to_dict()
            elif isinstance(self.threads_per_core, list):
                props['ThreadsPerCore'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.threads_per_core
                ]
            else:
                props['ThreadsPerCore'] = self.threads_per_core

        if self.amd_sev_snp is not None:
            if hasattr(self.amd_sev_snp, 'to_dict'):
                props['AmdSevSnp'] = self.amd_sev_snp.to_dict()
            elif isinstance(self.amd_sev_snp, list):
                props['AmdSevSnp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.amd_sev_snp
                ]
            else:
                props['AmdSevSnp'] = self.amd_sev_snp

        if self.core_count is not None:
            if hasattr(self.core_count, 'to_dict'):
                props['CoreCount'] = self.core_count.to_dict()
            elif isinstance(self.core_count, list):
                props['CoreCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.core_count
                ]
            else:
                props['CoreCount'] = self.core_count

        return props


@dataclass
class CreditSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_credits: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cpu_credits is not None:
            if hasattr(self.cpu_credits, 'to_dict'):
                props['CpuCredits'] = self.cpu_credits.to_dict()
            elif isinstance(self.cpu_credits, list):
                props['CpuCredits'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_credits
                ]
            else:
                props['CpuCredits'] = self.cpu_credits

        return props


@dataclass
class Ebs:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snapshot_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encrypted: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    throughput: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_initialization_rate: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.snapshot_id is not None:
            if hasattr(self.snapshot_id, 'to_dict'):
                props['SnapshotId'] = self.snapshot_id.to_dict()
            elif isinstance(self.snapshot_id, list):
                props['SnapshotId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snapshot_id
                ]
            else:
                props['SnapshotId'] = self.snapshot_id

        if self.volume_type is not None:
            if hasattr(self.volume_type, 'to_dict'):
                props['VolumeType'] = self.volume_type.to_dict()
            elif isinstance(self.volume_type, list):
                props['VolumeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_type
                ]
            else:
                props['VolumeType'] = self.volume_type

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.encrypted is not None:
            if hasattr(self.encrypted, 'to_dict'):
                props['Encrypted'] = self.encrypted.to_dict()
            elif isinstance(self.encrypted, list):
                props['Encrypted'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encrypted
                ]
            else:
                props['Encrypted'] = self.encrypted

        if self.throughput is not None:
            if hasattr(self.throughput, 'to_dict'):
                props['Throughput'] = self.throughput.to_dict()
            elif isinstance(self.throughput, list):
                props['Throughput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.throughput
                ]
            else:
                props['Throughput'] = self.throughput

        if self.iops is not None:
            if hasattr(self.iops, 'to_dict'):
                props['Iops'] = self.iops.to_dict()
            elif isinstance(self.iops, list):
                props['Iops'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iops
                ]
            else:
                props['Iops'] = self.iops

        if self.volume_initialization_rate is not None:
            if hasattr(self.volume_initialization_rate, 'to_dict'):
                props['VolumeInitializationRate'] = self.volume_initialization_rate.to_dict()
            elif isinstance(self.volume_initialization_rate, list):
                props['VolumeInitializationRate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_initialization_rate
                ]
            else:
                props['VolumeInitializationRate'] = self.volume_initialization_rate

        if self.volume_size is not None:
            if hasattr(self.volume_size, 'to_dict'):
                props['VolumeSize'] = self.volume_size.to_dict()
            elif isinstance(self.volume_size, list):
                props['VolumeSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size
                ]
            else:
                props['VolumeSize'] = self.volume_size

        if self.delete_on_termination is not None:
            if hasattr(self.delete_on_termination, 'to_dict'):
                props['DeleteOnTermination'] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props['DeleteOnTermination'] = self.delete_on_termination

        return props


@dataclass
class EnaSrdSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_udp_specification: Optional[EnaSrdUdpSpecification] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ena_srd_enabled is not None:
            if hasattr(self.ena_srd_enabled, 'to_dict'):
                props['EnaSrdEnabled'] = self.ena_srd_enabled.to_dict()
            elif isinstance(self.ena_srd_enabled, list):
                props['EnaSrdEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_enabled
                ]
            else:
                props['EnaSrdEnabled'] = self.ena_srd_enabled

        if self.ena_srd_udp_specification is not None:
            if hasattr(self.ena_srd_udp_specification, 'to_dict'):
                props['EnaSrdUdpSpecification'] = self.ena_srd_udp_specification.to_dict()
            elif isinstance(self.ena_srd_udp_specification, list):
                props['EnaSrdUdpSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_udp_specification
                ]
            else:
                props['EnaSrdUdpSpecification'] = self.ena_srd_udp_specification

        return props


@dataclass
class EnaSrdUdpSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_udp_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ena_srd_udp_enabled is not None:
            if hasattr(self.ena_srd_udp_enabled, 'to_dict'):
                props['EnaSrdUdpEnabled'] = self.ena_srd_udp_enabled.to_dict()
            elif isinstance(self.ena_srd_udp_enabled, list):
                props['EnaSrdUdpEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_udp_enabled
                ]
            else:
                props['EnaSrdUdpEnabled'] = self.ena_srd_udp_enabled

        return props


@dataclass
class EnclaveOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class HibernationOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    configured: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.configured is not None:
            if hasattr(self.configured, 'to_dict'):
                props['Configured'] = self.configured.to_dict()
            elif isinstance(self.configured, list):
                props['Configured'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.configured
                ]
            else:
                props['Configured'] = self.configured

        return props


@dataclass
class IamInstanceProfile:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.arn is not None:
            if hasattr(self.arn, 'to_dict'):
                props['Arn'] = self.arn.to_dict()
            elif isinstance(self.arn, list):
                props['Arn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.arn
                ]
            else:
                props['Arn'] = self.arn

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class InstanceMarketOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_options: Optional[SpotOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    market_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.spot_options is not None:
            if hasattr(self.spot_options, 'to_dict'):
                props['SpotOptions'] = self.spot_options.to_dict()
            elif isinstance(self.spot_options, list):
                props['SpotOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_options
                ]
            else:
                props['SpotOptions'] = self.spot_options

        if self.market_type is not None:
            if hasattr(self.market_type, 'to_dict'):
                props['MarketType'] = self.market_type.to_dict()
            elif isinstance(self.market_type, list):
                props['MarketType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.market_type
                ]
            else:
                props['MarketType'] = self.market_type

        return props


@dataclass
class InstanceRequirements:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_generations: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_gi_b_per_v_cpu: Optional[MemoryGiBPerVCpu] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    v_cpu_count: Optional[VCpuCount] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_manufacturers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_storage: Optional[Union[str, LocalStorage, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_manufacturers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bare_metal: Optional[Union[str, BareMetal, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    require_hibernate_support: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_max_price_percentage_over_lowest_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_mi_b: Optional[MemoryMiB] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_storage_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_count: Optional[NetworkInterfaceCount] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    excluded_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allowed_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_count: Optional[AcceleratorCount] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_bandwidth_gbps: Optional[NetworkBandwidthGbps] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_performance_factors: Optional[BaselinePerformanceFactors] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_max_price_percentage_over_lowest_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_ebs_bandwidth_mbps: Optional[BaselineEbsBandwidthMbps] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_total_memory_mi_b: Optional[AcceleratorTotalMemoryMiB] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    burstable_performance: Optional[Union[str, BurstablePerformance, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    total_local_storage_gb: Optional[TotalLocalStorageGB] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_generations is not None:
            if hasattr(self.instance_generations, 'to_dict'):
                props['InstanceGenerations'] = self.instance_generations.to_dict()
            elif isinstance(self.instance_generations, list):
                props['InstanceGenerations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_generations
                ]
            else:
                props['InstanceGenerations'] = self.instance_generations

        if self.memory_gi_b_per_v_cpu is not None:
            if hasattr(self.memory_gi_b_per_v_cpu, 'to_dict'):
                props['MemoryGiBPerVCpu'] = self.memory_gi_b_per_v_cpu.to_dict()
            elif isinstance(self.memory_gi_b_per_v_cpu, list):
                props['MemoryGiBPerVCpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_gi_b_per_v_cpu
                ]
            else:
                props['MemoryGiBPerVCpu'] = self.memory_gi_b_per_v_cpu

        if self.accelerator_types is not None:
            if hasattr(self.accelerator_types, 'to_dict'):
                props['AcceleratorTypes'] = self.accelerator_types.to_dict()
            elif isinstance(self.accelerator_types, list):
                props['AcceleratorTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_types
                ]
            else:
                props['AcceleratorTypes'] = self.accelerator_types

        if self.v_cpu_count is not None:
            if hasattr(self.v_cpu_count, 'to_dict'):
                props['VCpuCount'] = self.v_cpu_count.to_dict()
            elif isinstance(self.v_cpu_count, list):
                props['VCpuCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.v_cpu_count
                ]
            else:
                props['VCpuCount'] = self.v_cpu_count

        if self.accelerator_manufacturers is not None:
            if hasattr(self.accelerator_manufacturers, 'to_dict'):
                props['AcceleratorManufacturers'] = self.accelerator_manufacturers.to_dict()
            elif isinstance(self.accelerator_manufacturers, list):
                props['AcceleratorManufacturers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_manufacturers
                ]
            else:
                props['AcceleratorManufacturers'] = self.accelerator_manufacturers

        if self.local_storage is not None:
            if hasattr(self.local_storage, 'to_dict'):
                props['LocalStorage'] = self.local_storage.to_dict()
            elif isinstance(self.local_storage, list):
                props['LocalStorage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_storage
                ]
            else:
                props['LocalStorage'] = self.local_storage

        if self.cpu_manufacturers is not None:
            if hasattr(self.cpu_manufacturers, 'to_dict'):
                props['CpuManufacturers'] = self.cpu_manufacturers.to_dict()
            elif isinstance(self.cpu_manufacturers, list):
                props['CpuManufacturers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_manufacturers
                ]
            else:
                props['CpuManufacturers'] = self.cpu_manufacturers

        if self.bare_metal is not None:
            if hasattr(self.bare_metal, 'to_dict'):
                props['BareMetal'] = self.bare_metal.to_dict()
            elif isinstance(self.bare_metal, list):
                props['BareMetal'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bare_metal
                ]
            else:
                props['BareMetal'] = self.bare_metal

        if self.require_hibernate_support is not None:
            if hasattr(self.require_hibernate_support, 'to_dict'):
                props['RequireHibernateSupport'] = self.require_hibernate_support.to_dict()
            elif isinstance(self.require_hibernate_support, list):
                props['RequireHibernateSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.require_hibernate_support
                ]
            else:
                props['RequireHibernateSupport'] = self.require_hibernate_support

        if self.max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            if hasattr(self.max_spot_price_as_percentage_of_optimal_on_demand_price, 'to_dict'):
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = self.max_spot_price_as_percentage_of_optimal_on_demand_price.to_dict()
            elif isinstance(self.max_spot_price_as_percentage_of_optimal_on_demand_price, list):
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_spot_price_as_percentage_of_optimal_on_demand_price
                ]
            else:
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = self.max_spot_price_as_percentage_of_optimal_on_demand_price

        if self.on_demand_max_price_percentage_over_lowest_price is not None:
            if hasattr(self.on_demand_max_price_percentage_over_lowest_price, 'to_dict'):
                props['OnDemandMaxPricePercentageOverLowestPrice'] = self.on_demand_max_price_percentage_over_lowest_price.to_dict()
            elif isinstance(self.on_demand_max_price_percentage_over_lowest_price, list):
                props['OnDemandMaxPricePercentageOverLowestPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_max_price_percentage_over_lowest_price
                ]
            else:
                props['OnDemandMaxPricePercentageOverLowestPrice'] = self.on_demand_max_price_percentage_over_lowest_price

        if self.memory_mi_b is not None:
            if hasattr(self.memory_mi_b, 'to_dict'):
                props['MemoryMiB'] = self.memory_mi_b.to_dict()
            elif isinstance(self.memory_mi_b, list):
                props['MemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_mi_b
                ]
            else:
                props['MemoryMiB'] = self.memory_mi_b

        if self.local_storage_types is not None:
            if hasattr(self.local_storage_types, 'to_dict'):
                props['LocalStorageTypes'] = self.local_storage_types.to_dict()
            elif isinstance(self.local_storage_types, list):
                props['LocalStorageTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_storage_types
                ]
            else:
                props['LocalStorageTypes'] = self.local_storage_types

        if self.network_interface_count is not None:
            if hasattr(self.network_interface_count, 'to_dict'):
                props['NetworkInterfaceCount'] = self.network_interface_count.to_dict()
            elif isinstance(self.network_interface_count, list):
                props['NetworkInterfaceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_count
                ]
            else:
                props['NetworkInterfaceCount'] = self.network_interface_count

        if self.excluded_instance_types is not None:
            if hasattr(self.excluded_instance_types, 'to_dict'):
                props['ExcludedInstanceTypes'] = self.excluded_instance_types.to_dict()
            elif isinstance(self.excluded_instance_types, list):
                props['ExcludedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.excluded_instance_types
                ]
            else:
                props['ExcludedInstanceTypes'] = self.excluded_instance_types

        if self.allowed_instance_types is not None:
            if hasattr(self.allowed_instance_types, 'to_dict'):
                props['AllowedInstanceTypes'] = self.allowed_instance_types.to_dict()
            elif isinstance(self.allowed_instance_types, list):
                props['AllowedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_instance_types
                ]
            else:
                props['AllowedInstanceTypes'] = self.allowed_instance_types

        if self.accelerator_count is not None:
            if hasattr(self.accelerator_count, 'to_dict'):
                props['AcceleratorCount'] = self.accelerator_count.to_dict()
            elif isinstance(self.accelerator_count, list):
                props['AcceleratorCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_count
                ]
            else:
                props['AcceleratorCount'] = self.accelerator_count

        if self.network_bandwidth_gbps is not None:
            if hasattr(self.network_bandwidth_gbps, 'to_dict'):
                props['NetworkBandwidthGbps'] = self.network_bandwidth_gbps.to_dict()
            elif isinstance(self.network_bandwidth_gbps, list):
                props['NetworkBandwidthGbps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_bandwidth_gbps
                ]
            else:
                props['NetworkBandwidthGbps'] = self.network_bandwidth_gbps

        if self.baseline_performance_factors is not None:
            if hasattr(self.baseline_performance_factors, 'to_dict'):
                props['BaselinePerformanceFactors'] = self.baseline_performance_factors.to_dict()
            elif isinstance(self.baseline_performance_factors, list):
                props['BaselinePerformanceFactors'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baseline_performance_factors
                ]
            else:
                props['BaselinePerformanceFactors'] = self.baseline_performance_factors

        if self.spot_max_price_percentage_over_lowest_price is not None:
            if hasattr(self.spot_max_price_percentage_over_lowest_price, 'to_dict'):
                props['SpotMaxPricePercentageOverLowestPrice'] = self.spot_max_price_percentage_over_lowest_price.to_dict()
            elif isinstance(self.spot_max_price_percentage_over_lowest_price, list):
                props['SpotMaxPricePercentageOverLowestPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_max_price_percentage_over_lowest_price
                ]
            else:
                props['SpotMaxPricePercentageOverLowestPrice'] = self.spot_max_price_percentage_over_lowest_price

        if self.baseline_ebs_bandwidth_mbps is not None:
            if hasattr(self.baseline_ebs_bandwidth_mbps, 'to_dict'):
                props['BaselineEbsBandwidthMbps'] = self.baseline_ebs_bandwidth_mbps.to_dict()
            elif isinstance(self.baseline_ebs_bandwidth_mbps, list):
                props['BaselineEbsBandwidthMbps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baseline_ebs_bandwidth_mbps
                ]
            else:
                props['BaselineEbsBandwidthMbps'] = self.baseline_ebs_bandwidth_mbps

        if self.accelerator_names is not None:
            if hasattr(self.accelerator_names, 'to_dict'):
                props['AcceleratorNames'] = self.accelerator_names.to_dict()
            elif isinstance(self.accelerator_names, list):
                props['AcceleratorNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_names
                ]
            else:
                props['AcceleratorNames'] = self.accelerator_names

        if self.accelerator_total_memory_mi_b is not None:
            if hasattr(self.accelerator_total_memory_mi_b, 'to_dict'):
                props['AcceleratorTotalMemoryMiB'] = self.accelerator_total_memory_mi_b.to_dict()
            elif isinstance(self.accelerator_total_memory_mi_b, list):
                props['AcceleratorTotalMemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_total_memory_mi_b
                ]
            else:
                props['AcceleratorTotalMemoryMiB'] = self.accelerator_total_memory_mi_b

        if self.burstable_performance is not None:
            if hasattr(self.burstable_performance, 'to_dict'):
                props['BurstablePerformance'] = self.burstable_performance.to_dict()
            elif isinstance(self.burstable_performance, list):
                props['BurstablePerformance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.burstable_performance
                ]
            else:
                props['BurstablePerformance'] = self.burstable_performance

        if self.total_local_storage_gb is not None:
            if hasattr(self.total_local_storage_gb, 'to_dict'):
                props['TotalLocalStorageGB'] = self.total_local_storage_gb.to_dict()
            elif isinstance(self.total_local_storage_gb, list):
                props['TotalLocalStorageGB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_local_storage_gb
                ]
            else:
                props['TotalLocalStorageGB'] = self.total_local_storage_gb

        return props


@dataclass
class Ipv4PrefixSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv4_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv4_prefix is not None:
            if hasattr(self.ipv4_prefix, 'to_dict'):
                props['Ipv4Prefix'] = self.ipv4_prefix.to_dict()
            elif isinstance(self.ipv4_prefix, list):
                props['Ipv4Prefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_prefix
                ]
            else:
                props['Ipv4Prefix'] = self.ipv4_prefix

        return props


@dataclass
class Ipv6Add:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_address: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_address is not None:
            if hasattr(self.ipv6_address, 'to_dict'):
                props['Ipv6Address'] = self.ipv6_address.to_dict()
            elif isinstance(self.ipv6_address, list):
                props['Ipv6Address'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address
                ]
            else:
                props['Ipv6Address'] = self.ipv6_address

        return props


@dataclass
class Ipv6PrefixSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_prefix is not None:
            if hasattr(self.ipv6_prefix, 'to_dict'):
                props['Ipv6Prefix'] = self.ipv6_prefix.to_dict()
            elif isinstance(self.ipv6_prefix, list):
                props['Ipv6Prefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_prefix
                ]
            else:
                props['Ipv6Prefix'] = self.ipv6_prefix

        return props


@dataclass
class LaunchTemplateData:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_specifications: Optional[list[TagSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_performance_options: Optional[NetworkPerformanceOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    block_device_mappings: Optional[list[BlockDeviceMapping]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maintenance_options: Optional[MaintenanceOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iam_instance_profile: Optional[IamInstanceProfile] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kernel_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs_optimized: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    placement: Optional[Placement] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interfaces: Optional[list[NetworkInterface]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enclave_options: Optional[EnclaveOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring: Optional[Monitoring] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hibernation_options: Optional[HibernationOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metadata_options: Optional[MetadataOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    license_specifications: Optional[list[LicenseSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_initiated_shutdown_behavior: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    disable_api_stop: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_options: Optional[CpuOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_dns_name_options: Optional[PrivateDnsNameOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    disable_api_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_market_options: Optional[InstanceMarketOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_requirements: Optional[InstanceRequirements] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ram_disk_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_specification: Optional[CapacityReservationSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    credit_specification: Optional[CreditSpecification] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.security_groups is not None:
            if hasattr(self.security_groups, 'to_dict'):
                props['SecurityGroups'] = self.security_groups.to_dict()
            elif isinstance(self.security_groups, list):
                props['SecurityGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_groups
                ]
            else:
                props['SecurityGroups'] = self.security_groups

        if self.tag_specifications is not None:
            if hasattr(self.tag_specifications, 'to_dict'):
                props['TagSpecifications'] = self.tag_specifications.to_dict()
            elif isinstance(self.tag_specifications, list):
                props['TagSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_specifications
                ]
            else:
                props['TagSpecifications'] = self.tag_specifications

        if self.network_performance_options is not None:
            if hasattr(self.network_performance_options, 'to_dict'):
                props['NetworkPerformanceOptions'] = self.network_performance_options.to_dict()
            elif isinstance(self.network_performance_options, list):
                props['NetworkPerformanceOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_performance_options
                ]
            else:
                props['NetworkPerformanceOptions'] = self.network_performance_options

        if self.user_data is not None:
            if hasattr(self.user_data, 'to_dict'):
                props['UserData'] = self.user_data.to_dict()
            elif isinstance(self.user_data, list):
                props['UserData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_data
                ]
            else:
                props['UserData'] = self.user_data

        if self.block_device_mappings is not None:
            if hasattr(self.block_device_mappings, 'to_dict'):
                props['BlockDeviceMappings'] = self.block_device_mappings.to_dict()
            elif isinstance(self.block_device_mappings, list):
                props['BlockDeviceMappings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.block_device_mappings
                ]
            else:
                props['BlockDeviceMappings'] = self.block_device_mappings

        if self.maintenance_options is not None:
            if hasattr(self.maintenance_options, 'to_dict'):
                props['MaintenanceOptions'] = self.maintenance_options.to_dict()
            elif isinstance(self.maintenance_options, list):
                props['MaintenanceOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maintenance_options
                ]
            else:
                props['MaintenanceOptions'] = self.maintenance_options

        if self.iam_instance_profile is not None:
            if hasattr(self.iam_instance_profile, 'to_dict'):
                props['IamInstanceProfile'] = self.iam_instance_profile.to_dict()
            elif isinstance(self.iam_instance_profile, list):
                props['IamInstanceProfile'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iam_instance_profile
                ]
            else:
                props['IamInstanceProfile'] = self.iam_instance_profile

        if self.kernel_id is not None:
            if hasattr(self.kernel_id, 'to_dict'):
                props['KernelId'] = self.kernel_id.to_dict()
            elif isinstance(self.kernel_id, list):
                props['KernelId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kernel_id
                ]
            else:
                props['KernelId'] = self.kernel_id

        if self.ebs_optimized is not None:
            if hasattr(self.ebs_optimized, 'to_dict'):
                props['EbsOptimized'] = self.ebs_optimized.to_dict()
            elif isinstance(self.ebs_optimized, list):
                props['EbsOptimized'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_optimized
                ]
            else:
                props['EbsOptimized'] = self.ebs_optimized

        if self.placement is not None:
            if hasattr(self.placement, 'to_dict'):
                props['Placement'] = self.placement.to_dict()
            elif isinstance(self.placement, list):
                props['Placement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.placement
                ]
            else:
                props['Placement'] = self.placement

        if self.network_interfaces is not None:
            if hasattr(self.network_interfaces, 'to_dict'):
                props['NetworkInterfaces'] = self.network_interfaces.to_dict()
            elif isinstance(self.network_interfaces, list):
                props['NetworkInterfaces'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interfaces
                ]
            else:
                props['NetworkInterfaces'] = self.network_interfaces

        if self.enclave_options is not None:
            if hasattr(self.enclave_options, 'to_dict'):
                props['EnclaveOptions'] = self.enclave_options.to_dict()
            elif isinstance(self.enclave_options, list):
                props['EnclaveOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enclave_options
                ]
            else:
                props['EnclaveOptions'] = self.enclave_options

        if self.image_id is not None:
            if hasattr(self.image_id, 'to_dict'):
                props['ImageId'] = self.image_id.to_dict()
            elif isinstance(self.image_id, list):
                props['ImageId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_id
                ]
            else:
                props['ImageId'] = self.image_id

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        if self.monitoring is not None:
            if hasattr(self.monitoring, 'to_dict'):
                props['Monitoring'] = self.monitoring.to_dict()
            elif isinstance(self.monitoring, list):
                props['Monitoring'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring
                ]
            else:
                props['Monitoring'] = self.monitoring

        if self.hibernation_options is not None:
            if hasattr(self.hibernation_options, 'to_dict'):
                props['HibernationOptions'] = self.hibernation_options.to_dict()
            elif isinstance(self.hibernation_options, list):
                props['HibernationOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hibernation_options
                ]
            else:
                props['HibernationOptions'] = self.hibernation_options

        if self.metadata_options is not None:
            if hasattr(self.metadata_options, 'to_dict'):
                props['MetadataOptions'] = self.metadata_options.to_dict()
            elif isinstance(self.metadata_options, list):
                props['MetadataOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metadata_options
                ]
            else:
                props['MetadataOptions'] = self.metadata_options

        if self.license_specifications is not None:
            if hasattr(self.license_specifications, 'to_dict'):
                props['LicenseSpecifications'] = self.license_specifications.to_dict()
            elif isinstance(self.license_specifications, list):
                props['LicenseSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.license_specifications
                ]
            else:
                props['LicenseSpecifications'] = self.license_specifications

        if self.instance_initiated_shutdown_behavior is not None:
            if hasattr(self.instance_initiated_shutdown_behavior, 'to_dict'):
                props['InstanceInitiatedShutdownBehavior'] = self.instance_initiated_shutdown_behavior.to_dict()
            elif isinstance(self.instance_initiated_shutdown_behavior, list):
                props['InstanceInitiatedShutdownBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_initiated_shutdown_behavior
                ]
            else:
                props['InstanceInitiatedShutdownBehavior'] = self.instance_initiated_shutdown_behavior

        if self.disable_api_stop is not None:
            if hasattr(self.disable_api_stop, 'to_dict'):
                props['DisableApiStop'] = self.disable_api_stop.to_dict()
            elif isinstance(self.disable_api_stop, list):
                props['DisableApiStop'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disable_api_stop
                ]
            else:
                props['DisableApiStop'] = self.disable_api_stop

        if self.cpu_options is not None:
            if hasattr(self.cpu_options, 'to_dict'):
                props['CpuOptions'] = self.cpu_options.to_dict()
            elif isinstance(self.cpu_options, list):
                props['CpuOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_options
                ]
            else:
                props['CpuOptions'] = self.cpu_options

        if self.private_dns_name_options is not None:
            if hasattr(self.private_dns_name_options, 'to_dict'):
                props['PrivateDnsNameOptions'] = self.private_dns_name_options.to_dict()
            elif isinstance(self.private_dns_name_options, list):
                props['PrivateDnsNameOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_dns_name_options
                ]
            else:
                props['PrivateDnsNameOptions'] = self.private_dns_name_options

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        if self.key_name is not None:
            if hasattr(self.key_name, 'to_dict'):
                props['KeyName'] = self.key_name.to_dict()
            elif isinstance(self.key_name, list):
                props['KeyName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_name
                ]
            else:
                props['KeyName'] = self.key_name

        if self.disable_api_termination is not None:
            if hasattr(self.disable_api_termination, 'to_dict'):
                props['DisableApiTermination'] = self.disable_api_termination.to_dict()
            elif isinstance(self.disable_api_termination, list):
                props['DisableApiTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disable_api_termination
                ]
            else:
                props['DisableApiTermination'] = self.disable_api_termination

        if self.instance_market_options is not None:
            if hasattr(self.instance_market_options, 'to_dict'):
                props['InstanceMarketOptions'] = self.instance_market_options.to_dict()
            elif isinstance(self.instance_market_options, list):
                props['InstanceMarketOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_market_options
                ]
            else:
                props['InstanceMarketOptions'] = self.instance_market_options

        if self.instance_requirements is not None:
            if hasattr(self.instance_requirements, 'to_dict'):
                props['InstanceRequirements'] = self.instance_requirements.to_dict()
            elif isinstance(self.instance_requirements, list):
                props['InstanceRequirements'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_requirements
                ]
            else:
                props['InstanceRequirements'] = self.instance_requirements

        if self.ram_disk_id is not None:
            if hasattr(self.ram_disk_id, 'to_dict'):
                props['RamDiskId'] = self.ram_disk_id.to_dict()
            elif isinstance(self.ram_disk_id, list):
                props['RamDiskId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ram_disk_id
                ]
            else:
                props['RamDiskId'] = self.ram_disk_id

        if self.capacity_reservation_specification is not None:
            if hasattr(self.capacity_reservation_specification, 'to_dict'):
                props['CapacityReservationSpecification'] = self.capacity_reservation_specification.to_dict()
            elif isinstance(self.capacity_reservation_specification, list):
                props['CapacityReservationSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_specification
                ]
            else:
                props['CapacityReservationSpecification'] = self.capacity_reservation_specification

        if self.credit_specification is not None:
            if hasattr(self.credit_specification, 'to_dict'):
                props['CreditSpecification'] = self.credit_specification.to_dict()
            elif isinstance(self.credit_specification, list):
                props['CreditSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.credit_specification
                ]
            else:
                props['CreditSpecification'] = self.credit_specification

        return props


@dataclass
class LaunchTemplateTagSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, ResourceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tags: Optional[list[Tag]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        if self.tags is not None:
            if hasattr(self.tags, 'to_dict'):
                props['Tags'] = self.tags.to_dict()
            elif isinstance(self.tags, list):
                props['Tags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tags
                ]
            else:
                props['Tags'] = self.tags

        return props


@dataclass
class LicenseSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    license_configuration_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.license_configuration_arn is not None:
            if hasattr(self.license_configuration_arn, 'to_dict'):
                props['LicenseConfigurationArn'] = self.license_configuration_arn.to_dict()
            elif isinstance(self.license_configuration_arn, list):
                props['LicenseConfigurationArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.license_configuration_arn
                ]
            else:
                props['LicenseConfigurationArn'] = self.license_configuration_arn

        return props


@dataclass
class MaintenanceOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auto_recovery: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.auto_recovery is not None:
            if hasattr(self.auto_recovery, 'to_dict'):
                props['AutoRecovery'] = self.auto_recovery.to_dict()
            elif isinstance(self.auto_recovery, list):
                props['AutoRecovery'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_recovery
                ]
            else:
                props['AutoRecovery'] = self.auto_recovery

        return props


@dataclass
class MemoryGiBPerVCpu:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class MemoryMiB:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class MetadataOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_put_response_hop_limit: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_tokens: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_protocol_ipv6: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_metadata_tags: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    http_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.http_put_response_hop_limit is not None:
            if hasattr(self.http_put_response_hop_limit, 'to_dict'):
                props['HttpPutResponseHopLimit'] = self.http_put_response_hop_limit.to_dict()
            elif isinstance(self.http_put_response_hop_limit, list):
                props['HttpPutResponseHopLimit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_put_response_hop_limit
                ]
            else:
                props['HttpPutResponseHopLimit'] = self.http_put_response_hop_limit

        if self.http_tokens is not None:
            if hasattr(self.http_tokens, 'to_dict'):
                props['HttpTokens'] = self.http_tokens.to_dict()
            elif isinstance(self.http_tokens, list):
                props['HttpTokens'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_tokens
                ]
            else:
                props['HttpTokens'] = self.http_tokens

        if self.http_protocol_ipv6 is not None:
            if hasattr(self.http_protocol_ipv6, 'to_dict'):
                props['HttpProtocolIpv6'] = self.http_protocol_ipv6.to_dict()
            elif isinstance(self.http_protocol_ipv6, list):
                props['HttpProtocolIpv6'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_protocol_ipv6
                ]
            else:
                props['HttpProtocolIpv6'] = self.http_protocol_ipv6

        if self.instance_metadata_tags is not None:
            if hasattr(self.instance_metadata_tags, 'to_dict'):
                props['InstanceMetadataTags'] = self.instance_metadata_tags.to_dict()
            elif isinstance(self.instance_metadata_tags, list):
                props['InstanceMetadataTags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_metadata_tags
                ]
            else:
                props['InstanceMetadataTags'] = self.instance_metadata_tags

        if self.http_endpoint is not None:
            if hasattr(self.http_endpoint, 'to_dict'):
                props['HttpEndpoint'] = self.http_endpoint.to_dict()
            elif isinstance(self.http_endpoint, list):
                props['HttpEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.http_endpoint
                ]
            else:
                props['HttpEndpoint'] = self.http_endpoint

        return props


@dataclass
class Monitoring:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class NetworkBandwidthGbps:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class NetworkInterface:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_addresses: Optional[list[PrivateIpAdd]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    secondary_private_ip_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_prefix_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv4_prefixes: Optional[list[Ipv4PrefixSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_index: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    primary_ipv6: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv4_prefix_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_queue_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_prefixes: Optional[list[Ipv6PrefixSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_addresses: Optional[list[Ipv6Add]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    associate_public_ip_address: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_card_index: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    interface_type: Optional[Union[str, NetworkInterfaceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    associate_carrier_ip_address: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_specification: Optional[EnaSrdSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    connection_tracking_specification: Optional[ConnectionTrackingSpecification] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.private_ip_address is not None:
            if hasattr(self.private_ip_address, 'to_dict'):
                props['PrivateIpAddress'] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props['PrivateIpAddress'] = self.private_ip_address

        if self.private_ip_addresses is not None:
            if hasattr(self.private_ip_addresses, 'to_dict'):
                props['PrivateIpAddresses'] = self.private_ip_addresses.to_dict()
            elif isinstance(self.private_ip_addresses, list):
                props['PrivateIpAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_addresses
                ]
            else:
                props['PrivateIpAddresses'] = self.private_ip_addresses

        if self.secondary_private_ip_address_count is not None:
            if hasattr(self.secondary_private_ip_address_count, 'to_dict'):
                props['SecondaryPrivateIpAddressCount'] = self.secondary_private_ip_address_count.to_dict()
            elif isinstance(self.secondary_private_ip_address_count, list):
                props['SecondaryPrivateIpAddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_private_ip_address_count
                ]
            else:
                props['SecondaryPrivateIpAddressCount'] = self.secondary_private_ip_address_count

        if self.ipv6_prefix_count is not None:
            if hasattr(self.ipv6_prefix_count, 'to_dict'):
                props['Ipv6PrefixCount'] = self.ipv6_prefix_count.to_dict()
            elif isinstance(self.ipv6_prefix_count, list):
                props['Ipv6PrefixCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_prefix_count
                ]
            else:
                props['Ipv6PrefixCount'] = self.ipv6_prefix_count

        if self.ipv4_prefixes is not None:
            if hasattr(self.ipv4_prefixes, 'to_dict'):
                props['Ipv4Prefixes'] = self.ipv4_prefixes.to_dict()
            elif isinstance(self.ipv4_prefixes, list):
                props['Ipv4Prefixes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_prefixes
                ]
            else:
                props['Ipv4Prefixes'] = self.ipv4_prefixes

        if self.device_index is not None:
            if hasattr(self.device_index, 'to_dict'):
                props['DeviceIndex'] = self.device_index.to_dict()
            elif isinstance(self.device_index, list):
                props['DeviceIndex'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_index
                ]
            else:
                props['DeviceIndex'] = self.device_index

        if self.primary_ipv6 is not None:
            if hasattr(self.primary_ipv6, 'to_dict'):
                props['PrimaryIpv6'] = self.primary_ipv6.to_dict()
            elif isinstance(self.primary_ipv6, list):
                props['PrimaryIpv6'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.primary_ipv6
                ]
            else:
                props['PrimaryIpv6'] = self.primary_ipv6

        if self.ipv4_prefix_count is not None:
            if hasattr(self.ipv4_prefix_count, 'to_dict'):
                props['Ipv4PrefixCount'] = self.ipv4_prefix_count.to_dict()
            elif isinstance(self.ipv4_prefix_count, list):
                props['Ipv4PrefixCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_prefix_count
                ]
            else:
                props['Ipv4PrefixCount'] = self.ipv4_prefix_count

        if self.ena_queue_count is not None:
            if hasattr(self.ena_queue_count, 'to_dict'):
                props['EnaQueueCount'] = self.ena_queue_count.to_dict()
            elif isinstance(self.ena_queue_count, list):
                props['EnaQueueCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_queue_count
                ]
            else:
                props['EnaQueueCount'] = self.ena_queue_count

        if self.ipv6_prefixes is not None:
            if hasattr(self.ipv6_prefixes, 'to_dict'):
                props['Ipv6Prefixes'] = self.ipv6_prefixes.to_dict()
            elif isinstance(self.ipv6_prefixes, list):
                props['Ipv6Prefixes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_prefixes
                ]
            else:
                props['Ipv6Prefixes'] = self.ipv6_prefixes

        if self.subnet_id is not None:
            if hasattr(self.subnet_id, 'to_dict'):
                props['SubnetId'] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props['SubnetId'] = self.subnet_id

        if self.ipv6_addresses is not None:
            if hasattr(self.ipv6_addresses, 'to_dict'):
                props['Ipv6Addresses'] = self.ipv6_addresses.to_dict()
            elif isinstance(self.ipv6_addresses, list):
                props['Ipv6Addresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_addresses
                ]
            else:
                props['Ipv6Addresses'] = self.ipv6_addresses

        if self.associate_public_ip_address is not None:
            if hasattr(self.associate_public_ip_address, 'to_dict'):
                props['AssociatePublicIpAddress'] = self.associate_public_ip_address.to_dict()
            elif isinstance(self.associate_public_ip_address, list):
                props['AssociatePublicIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.associate_public_ip_address
                ]
            else:
                props['AssociatePublicIpAddress'] = self.associate_public_ip_address

        if self.network_interface_id is not None:
            if hasattr(self.network_interface_id, 'to_dict'):
                props['NetworkInterfaceId'] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props['NetworkInterfaceId'] = self.network_interface_id

        if self.network_card_index is not None:
            if hasattr(self.network_card_index, 'to_dict'):
                props['NetworkCardIndex'] = self.network_card_index.to_dict()
            elif isinstance(self.network_card_index, list):
                props['NetworkCardIndex'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_card_index
                ]
            else:
                props['NetworkCardIndex'] = self.network_card_index

        if self.interface_type is not None:
            if hasattr(self.interface_type, 'to_dict'):
                props['InterfaceType'] = self.interface_type.to_dict()
            elif isinstance(self.interface_type, list):
                props['InterfaceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.interface_type
                ]
            else:
                props['InterfaceType'] = self.interface_type

        if self.associate_carrier_ip_address is not None:
            if hasattr(self.associate_carrier_ip_address, 'to_dict'):
                props['AssociateCarrierIpAddress'] = self.associate_carrier_ip_address.to_dict()
            elif isinstance(self.associate_carrier_ip_address, list):
                props['AssociateCarrierIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.associate_carrier_ip_address
                ]
            else:
                props['AssociateCarrierIpAddress'] = self.associate_carrier_ip_address

        if self.ena_srd_specification is not None:
            if hasattr(self.ena_srd_specification, 'to_dict'):
                props['EnaSrdSpecification'] = self.ena_srd_specification.to_dict()
            elif isinstance(self.ena_srd_specification, list):
                props['EnaSrdSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_specification
                ]
            else:
                props['EnaSrdSpecification'] = self.ena_srd_specification

        if self.ipv6_address_count is not None:
            if hasattr(self.ipv6_address_count, 'to_dict'):
                props['Ipv6AddressCount'] = self.ipv6_address_count.to_dict()
            elif isinstance(self.ipv6_address_count, list):
                props['Ipv6AddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address_count
                ]
            else:
                props['Ipv6AddressCount'] = self.ipv6_address_count

        if self.groups is not None:
            if hasattr(self.groups, 'to_dict'):
                props['Groups'] = self.groups.to_dict()
            elif isinstance(self.groups, list):
                props['Groups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.groups
                ]
            else:
                props['Groups'] = self.groups

        if self.delete_on_termination is not None:
            if hasattr(self.delete_on_termination, 'to_dict'):
                props['DeleteOnTermination'] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props['DeleteOnTermination'] = self.delete_on_termination

        if self.connection_tracking_specification is not None:
            if hasattr(self.connection_tracking_specification, 'to_dict'):
                props['ConnectionTrackingSpecification'] = self.connection_tracking_specification.to_dict()
            elif isinstance(self.connection_tracking_specification, list):
                props['ConnectionTrackingSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connection_tracking_specification
                ]
            else:
                props['ConnectionTrackingSpecification'] = self.connection_tracking_specification

        return props


@dataclass
class NetworkInterfaceCount:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class NetworkPerformanceOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bandwidth_weighting: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.bandwidth_weighting is not None:
            if hasattr(self.bandwidth_weighting, 'to_dict'):
                props['BandwidthWeighting'] = self.bandwidth_weighting.to_dict()
            elif isinstance(self.bandwidth_weighting, list):
                props['BandwidthWeighting'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bandwidth_weighting
                ]
            else:
                props['BandwidthWeighting'] = self.bandwidth_weighting

        return props


@dataclass
class Placement:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tenancy: Optional[Union[str, Tenancy, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spread_domain: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    partition_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    affinity: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    host_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    host_resource_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.group_name is not None:
            if hasattr(self.group_name, 'to_dict'):
                props['GroupName'] = self.group_name.to_dict()
            elif isinstance(self.group_name, list):
                props['GroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_name
                ]
            else:
                props['GroupName'] = self.group_name

        if self.tenancy is not None:
            if hasattr(self.tenancy, 'to_dict'):
                props['Tenancy'] = self.tenancy.to_dict()
            elif isinstance(self.tenancy, list):
                props['Tenancy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tenancy
                ]
            else:
                props['Tenancy'] = self.tenancy

        if self.spread_domain is not None:
            if hasattr(self.spread_domain, 'to_dict'):
                props['SpreadDomain'] = self.spread_domain.to_dict()
            elif isinstance(self.spread_domain, list):
                props['SpreadDomain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spread_domain
                ]
            else:
                props['SpreadDomain'] = self.spread_domain

        if self.partition_number is not None:
            if hasattr(self.partition_number, 'to_dict'):
                props['PartitionNumber'] = self.partition_number.to_dict()
            elif isinstance(self.partition_number, list):
                props['PartitionNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.partition_number
                ]
            else:
                props['PartitionNumber'] = self.partition_number

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        if self.affinity is not None:
            if hasattr(self.affinity, 'to_dict'):
                props['Affinity'] = self.affinity.to_dict()
            elif isinstance(self.affinity, list):
                props['Affinity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.affinity
                ]
            else:
                props['Affinity'] = self.affinity

        if self.host_id is not None:
            if hasattr(self.host_id, 'to_dict'):
                props['HostId'] = self.host_id.to_dict()
            elif isinstance(self.host_id, list):
                props['HostId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_id
                ]
            else:
                props['HostId'] = self.host_id

        if self.host_resource_group_arn is not None:
            if hasattr(self.host_resource_group_arn, 'to_dict'):
                props['HostResourceGroupArn'] = self.host_resource_group_arn.to_dict()
            elif isinstance(self.host_resource_group_arn, list):
                props['HostResourceGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_resource_group_arn
                ]
            else:
                props['HostResourceGroupArn'] = self.host_resource_group_arn

        if self.group_id is not None:
            if hasattr(self.group_id, 'to_dict'):
                props['GroupId'] = self.group_id.to_dict()
            elif isinstance(self.group_id, list):
                props['GroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_id
                ]
            else:
                props['GroupId'] = self.group_id

        return props


@dataclass
class PrivateDnsNameOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_resource_name_dns_a_record: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hostname_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_resource_name_dns_aaaa_record: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enable_resource_name_dns_a_record is not None:
            if hasattr(self.enable_resource_name_dns_a_record, 'to_dict'):
                props['EnableResourceNameDnsARecord'] = self.enable_resource_name_dns_a_record.to_dict()
            elif isinstance(self.enable_resource_name_dns_a_record, list):
                props['EnableResourceNameDnsARecord'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_resource_name_dns_a_record
                ]
            else:
                props['EnableResourceNameDnsARecord'] = self.enable_resource_name_dns_a_record

        if self.hostname_type is not None:
            if hasattr(self.hostname_type, 'to_dict'):
                props['HostnameType'] = self.hostname_type.to_dict()
            elif isinstance(self.hostname_type, list):
                props['HostnameType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hostname_type
                ]
            else:
                props['HostnameType'] = self.hostname_type

        if self.enable_resource_name_dns_aaaa_record is not None:
            if hasattr(self.enable_resource_name_dns_aaaa_record, 'to_dict'):
                props['EnableResourceNameDnsAAAARecord'] = self.enable_resource_name_dns_aaaa_record.to_dict()
            elif isinstance(self.enable_resource_name_dns_aaaa_record, list):
                props['EnableResourceNameDnsAAAARecord'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_resource_name_dns_aaaa_record
                ]
            else:
                props['EnableResourceNameDnsAAAARecord'] = self.enable_resource_name_dns_aaaa_record

        return props


@dataclass
class PrivateIpAdd:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    primary: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.private_ip_address is not None:
            if hasattr(self.private_ip_address, 'to_dict'):
                props['PrivateIpAddress'] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props['PrivateIpAddress'] = self.private_ip_address

        if self.primary is not None:
            if hasattr(self.primary, 'to_dict'):
                props['Primary'] = self.primary.to_dict()
            elif isinstance(self.primary, list):
                props['Primary'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.primary
                ]
            else:
                props['Primary'] = self.primary

        return props


@dataclass
class Reference:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_family: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_family is not None:
            if hasattr(self.instance_family, 'to_dict'):
                props['InstanceFamily'] = self.instance_family.to_dict()
            elif isinstance(self.instance_family, list):
                props['InstanceFamily'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_family
                ]
            else:
                props['InstanceFamily'] = self.instance_family

        return props


@dataclass
class SpotOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_interruption_behavior: Optional[Union[str, SpotInstanceInterruptionBehavior, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    block_duration_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    valid_until: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.spot_instance_type is not None:
            if hasattr(self.spot_instance_type, 'to_dict'):
                props['SpotInstanceType'] = self.spot_instance_type.to_dict()
            elif isinstance(self.spot_instance_type, list):
                props['SpotInstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_instance_type
                ]
            else:
                props['SpotInstanceType'] = self.spot_instance_type

        if self.instance_interruption_behavior is not None:
            if hasattr(self.instance_interruption_behavior, 'to_dict'):
                props['InstanceInterruptionBehavior'] = self.instance_interruption_behavior.to_dict()
            elif isinstance(self.instance_interruption_behavior, list):
                props['InstanceInterruptionBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_interruption_behavior
                ]
            else:
                props['InstanceInterruptionBehavior'] = self.instance_interruption_behavior

        if self.max_price is not None:
            if hasattr(self.max_price, 'to_dict'):
                props['MaxPrice'] = self.max_price.to_dict()
            elif isinstance(self.max_price, list):
                props['MaxPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_price
                ]
            else:
                props['MaxPrice'] = self.max_price

        if self.block_duration_minutes is not None:
            if hasattr(self.block_duration_minutes, 'to_dict'):
                props['BlockDurationMinutes'] = self.block_duration_minutes.to_dict()
            elif isinstance(self.block_duration_minutes, list):
                props['BlockDurationMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.block_duration_minutes
                ]
            else:
                props['BlockDurationMinutes'] = self.block_duration_minutes

        if self.valid_until is not None:
            if hasattr(self.valid_until, 'to_dict'):
                props['ValidUntil'] = self.valid_until.to_dict()
            elif isinstance(self.valid_until, list):
                props['ValidUntil'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.valid_until
                ]
            else:
                props['ValidUntil'] = self.valid_until

        return props


@dataclass
class TagSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, ResourceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tags: Optional[list[Tag]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        if self.tags is not None:
            if hasattr(self.tags, 'to_dict'):
                props['Tags'] = self.tags.to_dict()
            elif isinstance(self.tags, list):
                props['Tags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tags
                ]
            else:
                props['Tags'] = self.tags

        return props


@dataclass
class TotalLocalStorageGB:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class VCpuCount:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class LaunchTemplate(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-l"""

    resource_type: ClassVar[str] = "AWS::EC2::LaunchTemplate"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_template_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    launch_template_data: Optional[LaunchTemplateData] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    version_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tag_specifications: Optional[list[LaunchTemplateTagSpecification]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.launch_template_name is not None:
            # Serialize launch_template_name (handle intrinsic functions)
            if hasattr(self.launch_template_name, 'to_dict'):
                props["LaunchTemplateName"] = self.launch_template_name.to_dict()
            elif isinstance(self.launch_template_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LaunchTemplateName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_name
                ]
            else:
                props["LaunchTemplateName"] = self.launch_template_name

        if self.launch_template_data is not None:
            # Serialize launch_template_data (handle intrinsic functions)
            if hasattr(self.launch_template_data, 'to_dict'):
                props["LaunchTemplateData"] = self.launch_template_data.to_dict()
            elif isinstance(self.launch_template_data, list):
                # Serialize list items (may contain intrinsic functions)
                props['LaunchTemplateData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_data
                ]
            else:
                props["LaunchTemplateData"] = self.launch_template_data

        if self.version_description is not None:
            # Serialize version_description (handle intrinsic functions)
            if hasattr(self.version_description, 'to_dict'):
                props["VersionDescription"] = self.version_description.to_dict()
            elif isinstance(self.version_description, list):
                # Serialize list items (may contain intrinsic functions)
                props['VersionDescription'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version_description
                ]
            else:
                props["VersionDescription"] = self.version_description

        if self.tag_specifications is not None:
            # Serialize tag_specifications (handle intrinsic functions)
            if hasattr(self.tag_specifications, 'to_dict'):
                props["TagSpecifications"] = self.tag_specifications.to_dict()
            elif isinstance(self.tag_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['TagSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_specifications
                ]
            else:
                props["TagSpecifications"] = self.tag_specifications

        return props

    @property
    def attr_latest_version_number(self) -> GetAtt:
        """Get the LatestVersionNumber attribute."""
        return self.get_att("LatestVersionNumber")

    @property
    def attr_launch_template_id(self) -> GetAtt:
        """Get the LaunchTemplateId attribute."""
        return self.get_att("LaunchTemplateId")

    @property
    def attr_default_version_number(self) -> GetAtt:
        """Get the DefaultVersionNumber attribute."""
        return self.get_att("DefaultVersionNumber")




@dataclass
class LocalGatewayRoute(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-l"""

    resource_type: ClassVar[str] = "AWS::EC2::LocalGatewayRoute"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_virtual_interface_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.local_gateway_route_table_id is not None:
            # Serialize local_gateway_route_table_id (handle intrinsic functions)
            if hasattr(self.local_gateway_route_table_id, 'to_dict'):
                props["LocalGatewayRouteTableId"] = self.local_gateway_route_table_id.to_dict()
            elif isinstance(self.local_gateway_route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayRouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_route_table_id
                ]
            else:
                props["LocalGatewayRouteTableId"] = self.local_gateway_route_table_id

        if self.destination_cidr_block is not None:
            # Serialize destination_cidr_block (handle intrinsic functions)
            if hasattr(self.destination_cidr_block, 'to_dict'):
                props["DestinationCidrBlock"] = self.destination_cidr_block.to_dict()
            elif isinstance(self.destination_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr_block
                ]
            else:
                props["DestinationCidrBlock"] = self.destination_cidr_block

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        if self.local_gateway_virtual_interface_group_id is not None:
            # Serialize local_gateway_virtual_interface_group_id (handle intrinsic functions)
            if hasattr(self.local_gateway_virtual_interface_group_id, 'to_dict'):
                props["LocalGatewayVirtualInterfaceGroupId"] = self.local_gateway_virtual_interface_group_id.to_dict()
            elif isinstance(self.local_gateway_virtual_interface_group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayVirtualInterfaceGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_virtual_interface_group_id
                ]
            else:
                props["LocalGatewayVirtualInterfaceGroupId"] = self.local_gateway_virtual_interface_group_id

        return props

    @property
    def attr_type(self) -> GetAtt:
        """Get the Type attribute."""
        return self.get_att("Type")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")




@dataclass
class LocalGatewayRouteTable(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-l"""

    resource_type: ClassVar[str] = "AWS::EC2::LocalGatewayRouteTable"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    mode: Optional[Union[str, LocalGatewayRouteTableMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.local_gateway_id is not None:
            # Serialize local_gateway_id (handle intrinsic functions)
            if hasattr(self.local_gateway_id, 'to_dict'):
                props["LocalGatewayId"] = self.local_gateway_id.to_dict()
            elif isinstance(self.local_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_id
                ]
            else:
                props["LocalGatewayId"] = self.local_gateway_id

        if self.mode is not None:
            # Serialize mode (handle intrinsic functions)
            if hasattr(self.mode, 'to_dict'):
                props["Mode"] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props["Mode"] = self.mode

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_outpost_arn(self) -> GetAtt:
        """Get the OutpostArn attribute."""
        return self.get_att("OutpostArn")

    @property
    def attr_local_gateway_route_table_id(self) -> GetAtt:
        """Get the LocalGatewayRouteTableId attribute."""
        return self.get_att("LocalGatewayRouteTableId")

    @property
    def attr_local_gateway_route_table_arn(self) -> GetAtt:
        """Get the LocalGatewayRouteTableArn attribute."""
        return self.get_att("LocalGatewayRouteTableArn")




@dataclass
class LocalGatewayRouteTableVPCAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-l"""

    resource_type: ClassVar[str] = "AWS::EC2::LocalGatewayRouteTableVPCAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.local_gateway_route_table_id is not None:
            # Serialize local_gateway_route_table_id (handle intrinsic functions)
            if hasattr(self.local_gateway_route_table_id, 'to_dict'):
                props["LocalGatewayRouteTableId"] = self.local_gateway_route_table_id.to_dict()
            elif isinstance(self.local_gateway_route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayRouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_route_table_id
                ]
            else:
                props["LocalGatewayRouteTableId"] = self.local_gateway_route_table_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_local_gateway_id(self) -> GetAtt:
        """Get the LocalGatewayId attribute."""
        return self.get_att("LocalGatewayId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_local_gateway_route_table_vpc_association_id(self) -> GetAtt:
        """Get the LocalGatewayRouteTableVpcAssociationId attribute."""
        return self.get_att("LocalGatewayRouteTableVpcAssociationId")




@dataclass
class LocalGatewayRouteTableVirtualInterfaceGroupAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-l"""

    resource_type: ClassVar[str] = "AWS::EC2::LocalGatewayRouteTableVirtualInterfaceGroupAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_virtual_interface_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.local_gateway_route_table_id is not None:
            # Serialize local_gateway_route_table_id (handle intrinsic functions)
            if hasattr(self.local_gateway_route_table_id, 'to_dict'):
                props["LocalGatewayRouteTableId"] = self.local_gateway_route_table_id.to_dict()
            elif isinstance(self.local_gateway_route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayRouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_route_table_id
                ]
            else:
                props["LocalGatewayRouteTableId"] = self.local_gateway_route_table_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.local_gateway_virtual_interface_group_id is not None:
            # Serialize local_gateway_virtual_interface_group_id (handle intrinsic functions)
            if hasattr(self.local_gateway_virtual_interface_group_id, 'to_dict'):
                props["LocalGatewayVirtualInterfaceGroupId"] = self.local_gateway_virtual_interface_group_id.to_dict()
            elif isinstance(self.local_gateway_virtual_interface_group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayVirtualInterfaceGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_virtual_interface_group_id
                ]
            else:
                props["LocalGatewayVirtualInterfaceGroupId"] = self.local_gateway_virtual_interface_group_id

        return props

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_local_gateway_id(self) -> GetAtt:
        """Get the LocalGatewayId attribute."""
        return self.get_att("LocalGatewayId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_local_gateway_route_table_virtual_interface_group_association_id(self) -> GetAtt:
        """Get the LocalGatewayRouteTableVirtualInterfaceGroupAssociationId attribute."""
        return self.get_att("LocalGatewayRouteTableVirtualInterfaceGroupAssociationId")

    @property
    def attr_local_gateway_route_table_arn(self) -> GetAtt:
        """Get the LocalGatewayRouteTableArn attribute."""
        return self.get_att("LocalGatewayRouteTableArn")




@dataclass
class LocalGatewayVirtualInterface(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-l"""

    resource_type: ClassVar[str] = "AWS::EC2::LocalGatewayVirtualInterface"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    outpost_lag_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vlan: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_bgp_asn: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_virtual_interface_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_bgp_asn_extended: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.outpost_lag_id is not None:
            # Serialize outpost_lag_id (handle intrinsic functions)
            if hasattr(self.outpost_lag_id, 'to_dict'):
                props["OutpostLagId"] = self.outpost_lag_id.to_dict()
            elif isinstance(self.outpost_lag_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutpostLagId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.outpost_lag_id
                ]
            else:
                props["OutpostLagId"] = self.outpost_lag_id

        if self.local_address is not None:
            # Serialize local_address (handle intrinsic functions)
            if hasattr(self.local_address, 'to_dict'):
                props["LocalAddress"] = self.local_address.to_dict()
            elif isinstance(self.local_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_address
                ]
            else:
                props["LocalAddress"] = self.local_address

        if self.peer_address is not None:
            # Serialize peer_address (handle intrinsic functions)
            if hasattr(self.peer_address, 'to_dict'):
                props["PeerAddress"] = self.peer_address.to_dict()
            elif isinstance(self.peer_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_address
                ]
            else:
                props["PeerAddress"] = self.peer_address

        if self.vlan is not None:
            # Serialize vlan (handle intrinsic functions)
            if hasattr(self.vlan, 'to_dict'):
                props["Vlan"] = self.vlan.to_dict()
            elif isinstance(self.vlan, list):
                # Serialize list items (may contain intrinsic functions)
                props['Vlan'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vlan
                ]
            else:
                props["Vlan"] = self.vlan

        if self.peer_bgp_asn is not None:
            # Serialize peer_bgp_asn (handle intrinsic functions)
            if hasattr(self.peer_bgp_asn, 'to_dict'):
                props["PeerBgpAsn"] = self.peer_bgp_asn.to_dict()
            elif isinstance(self.peer_bgp_asn, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerBgpAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_bgp_asn
                ]
            else:
                props["PeerBgpAsn"] = self.peer_bgp_asn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.local_gateway_virtual_interface_group_id is not None:
            # Serialize local_gateway_virtual_interface_group_id (handle intrinsic functions)
            if hasattr(self.local_gateway_virtual_interface_group_id, 'to_dict'):
                props["LocalGatewayVirtualInterfaceGroupId"] = self.local_gateway_virtual_interface_group_id.to_dict()
            elif isinstance(self.local_gateway_virtual_interface_group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayVirtualInterfaceGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_virtual_interface_group_id
                ]
            else:
                props["LocalGatewayVirtualInterfaceGroupId"] = self.local_gateway_virtual_interface_group_id

        if self.peer_bgp_asn_extended is not None:
            # Serialize peer_bgp_asn_extended (handle intrinsic functions)
            if hasattr(self.peer_bgp_asn_extended, 'to_dict'):
                props["PeerBgpAsnExtended"] = self.peer_bgp_asn_extended.to_dict()
            elif isinstance(self.peer_bgp_asn_extended, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerBgpAsnExtended'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_bgp_asn_extended
                ]
            else:
                props["PeerBgpAsnExtended"] = self.peer_bgp_asn_extended

        return props

    @property
    def attr_configuration_state(self) -> GetAtt:
        """Get the ConfigurationState attribute."""
        return self.get_att("ConfigurationState")

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_local_gateway_id(self) -> GetAtt:
        """Get the LocalGatewayId attribute."""
        return self.get_att("LocalGatewayId")

    @property
    def attr_local_bgp_asn(self) -> GetAtt:
        """Get the LocalBgpAsn attribute."""
        return self.get_att("LocalBgpAsn")

    @property
    def attr_local_gateway_virtual_interface_id(self) -> GetAtt:
        """Get the LocalGatewayVirtualInterfaceId attribute."""
        return self.get_att("LocalGatewayVirtualInterfaceId")




@dataclass
class LocalGatewayVirtualInterfaceGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-l"""

    resource_type: ClassVar[str] = "AWS::EC2::LocalGatewayVirtualInterfaceGroup"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_bgp_asn_extended: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_bgp_asn: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.local_gateway_id is not None:
            # Serialize local_gateway_id (handle intrinsic functions)
            if hasattr(self.local_gateway_id, 'to_dict'):
                props["LocalGatewayId"] = self.local_gateway_id.to_dict()
            elif isinstance(self.local_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_id
                ]
            else:
                props["LocalGatewayId"] = self.local_gateway_id

        if self.local_bgp_asn_extended is not None:
            # Serialize local_bgp_asn_extended (handle intrinsic functions)
            if hasattr(self.local_bgp_asn_extended, 'to_dict'):
                props["LocalBgpAsnExtended"] = self.local_bgp_asn_extended.to_dict()
            elif isinstance(self.local_bgp_asn_extended, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalBgpAsnExtended'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_bgp_asn_extended
                ]
            else:
                props["LocalBgpAsnExtended"] = self.local_bgp_asn_extended

        if self.local_bgp_asn is not None:
            # Serialize local_bgp_asn (handle intrinsic functions)
            if hasattr(self.local_bgp_asn, 'to_dict'):
                props["LocalBgpAsn"] = self.local_bgp_asn.to_dict()
            elif isinstance(self.local_bgp_asn, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalBgpAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_bgp_asn
                ]
            else:
                props["LocalBgpAsn"] = self.local_bgp_asn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_local_gateway_virtual_interface_ids(self) -> GetAtt:
        """Get the LocalGatewayVirtualInterfaceIds attribute."""
        return self.get_att("LocalGatewayVirtualInterfaceIds")

    @property
    def attr_configuration_state(self) -> GetAtt:
        """Get the ConfigurationState attribute."""
        return self.get_att("ConfigurationState")

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_local_gateway_virtual_interface_group_arn(self) -> GetAtt:
        """Get the LocalGatewayVirtualInterfaceGroupArn attribute."""
        return self.get_att("LocalGatewayVirtualInterfaceGroupArn")

    @property
    def attr_local_gateway_virtual_interface_group_id(self) -> GetAtt:
        """Get the LocalGatewayVirtualInterfaceGroupId attribute."""
        return self.get_att("LocalGatewayVirtualInterfaceGroupId")




@dataclass
class AvailabilityZoneAddress:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allocation_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.availability_zone_id is not None:
            if hasattr(self.availability_zone_id, 'to_dict'):
                props['AvailabilityZoneId'] = self.availability_zone_id.to_dict()
            elif isinstance(self.availability_zone_id, list):
                props['AvailabilityZoneId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone_id
                ]
            else:
                props['AvailabilityZoneId'] = self.availability_zone_id

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        if self.allocation_ids is not None:
            if hasattr(self.allocation_ids, 'to_dict'):
                props['AllocationIds'] = self.allocation_ids.to_dict()
            elif isinstance(self.allocation_ids, list):
                props['AllocationIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_ids
                ]
            else:
                props['AllocationIds'] = self.allocation_ids

        return props


@dataclass
class NatGateway(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NatGateway"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    secondary_allocation_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    secondary_private_ip_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connectivity_type: Optional[Union[str, ConnectivityType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    secondary_private_ip_addresses: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone_addresses: Optional[list[AvailabilityZoneAddress]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_mode: Optional[Union[str, AvailabilityMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allocation_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_drain_duration_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.secondary_allocation_ids is not None:
            # Serialize secondary_allocation_ids (handle intrinsic functions)
            if hasattr(self.secondary_allocation_ids, 'to_dict'):
                props["SecondaryAllocationIds"] = self.secondary_allocation_ids.to_dict()
            elif isinstance(self.secondary_allocation_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecondaryAllocationIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_allocation_ids
                ]
            else:
                props["SecondaryAllocationIds"] = self.secondary_allocation_ids

        if self.private_ip_address is not None:
            # Serialize private_ip_address (handle intrinsic functions)
            if hasattr(self.private_ip_address, 'to_dict'):
                props["PrivateIpAddress"] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props["PrivateIpAddress"] = self.private_ip_address

        if self.secondary_private_ip_address_count is not None:
            # Serialize secondary_private_ip_address_count (handle intrinsic functions)
            if hasattr(self.secondary_private_ip_address_count, 'to_dict'):
                props["SecondaryPrivateIpAddressCount"] = self.secondary_private_ip_address_count.to_dict()
            elif isinstance(self.secondary_private_ip_address_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecondaryPrivateIpAddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_private_ip_address_count
                ]
            else:
                props["SecondaryPrivateIpAddressCount"] = self.secondary_private_ip_address_count

        if self.connectivity_type is not None:
            # Serialize connectivity_type (handle intrinsic functions)
            if hasattr(self.connectivity_type, 'to_dict'):
                props["ConnectivityType"] = self.connectivity_type.to_dict()
            elif isinstance(self.connectivity_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConnectivityType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connectivity_type
                ]
            else:
                props["ConnectivityType"] = self.connectivity_type

        if self.secondary_private_ip_addresses is not None:
            # Serialize secondary_private_ip_addresses (handle intrinsic functions)
            if hasattr(self.secondary_private_ip_addresses, 'to_dict'):
                props["SecondaryPrivateIpAddresses"] = self.secondary_private_ip_addresses.to_dict()
            elif isinstance(self.secondary_private_ip_addresses, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecondaryPrivateIpAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_private_ip_addresses
                ]
            else:
                props["SecondaryPrivateIpAddresses"] = self.secondary_private_ip_addresses

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.availability_zone_addresses is not None:
            # Serialize availability_zone_addresses (handle intrinsic functions)
            if hasattr(self.availability_zone_addresses, 'to_dict'):
                props["AvailabilityZoneAddresses"] = self.availability_zone_addresses.to_dict()
            elif isinstance(self.availability_zone_addresses, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZoneAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone_addresses
                ]
            else:
                props["AvailabilityZoneAddresses"] = self.availability_zone_addresses

        if self.availability_mode is not None:
            # Serialize availability_mode (handle intrinsic functions)
            if hasattr(self.availability_mode, 'to_dict'):
                props["AvailabilityMode"] = self.availability_mode.to_dict()
            elif isinstance(self.availability_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_mode
                ]
            else:
                props["AvailabilityMode"] = self.availability_mode

        if self.allocation_id is not None:
            # Serialize allocation_id (handle intrinsic functions)
            if hasattr(self.allocation_id, 'to_dict'):
                props["AllocationId"] = self.allocation_id.to_dict()
            elif isinstance(self.allocation_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllocationId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_id
                ]
            else:
                props["AllocationId"] = self.allocation_id

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.max_drain_duration_seconds is not None:
            # Serialize max_drain_duration_seconds (handle intrinsic functions)
            if hasattr(self.max_drain_duration_seconds, 'to_dict'):
                props["MaxDrainDurationSeconds"] = self.max_drain_duration_seconds.to_dict()
            elif isinstance(self.max_drain_duration_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxDrainDurationSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_drain_duration_seconds
                ]
            else:
                props["MaxDrainDurationSeconds"] = self.max_drain_duration_seconds

        return props

    @property
    def attr_route_table_id(self) -> GetAtt:
        """Get the RouteTableId attribute."""
        return self.get_att("RouteTableId")

    @property
    def attr_eni_id(self) -> GetAtt:
        """Get the EniId attribute."""
        return self.get_att("EniId")

    @property
    def attr_auto_provision_zones(self) -> GetAtt:
        """Get the AutoProvisionZones attribute."""
        return self.get_att("AutoProvisionZones")

    @property
    def attr_auto_scaling_ips(self) -> GetAtt:
        """Get the AutoScalingIps attribute."""
        return self.get_att("AutoScalingIps")

    @property
    def attr_nat_gateway_id(self) -> GetAtt:
        """Get the NatGatewayId attribute."""
        return self.get_att("NatGatewayId")




@dataclass
class NetworkAcl(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkAcl"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class Icmp:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    code: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.code is not None:
            if hasattr(self.code, 'to_dict'):
                props['Code'] = self.code.to_dict()
            elif isinstance(self.code, list):
                props['Code'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code
                ]
            else:
                props['Code'] = self.code

        return props


@dataclass
class PortRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.from_ is not None:
            if hasattr(self.from_, 'to_dict'):
                props['From'] = self.from_.to_dict()
            elif isinstance(self.from_, list):
                props['From'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_
                ]
            else:
                props['From'] = self.from_

        if self.to is not None:
            if hasattr(self.to, 'to_dict'):
                props['To'] = self.to.to_dict()
            elif isinstance(self.to, list):
                props['To'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to
                ]
            else:
                props['To'] = self.to

        return props


@dataclass
class NetworkAclEntry(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkAclEntry"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    port_range: Optional[PortRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_acl_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rule_action: Optional[Union[str, RuleAction, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    egress: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rule_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    protocol: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    icmp: Optional[Icmp] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.port_range is not None:
            # Serialize port_range (handle intrinsic functions)
            if hasattr(self.port_range, 'to_dict'):
                props["PortRange"] = self.port_range.to_dict()
            elif isinstance(self.port_range, list):
                # Serialize list items (may contain intrinsic functions)
                props['PortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port_range
                ]
            else:
                props["PortRange"] = self.port_range

        if self.network_acl_id is not None:
            # Serialize network_acl_id (handle intrinsic functions)
            if hasattr(self.network_acl_id, 'to_dict'):
                props["NetworkAclId"] = self.network_acl_id.to_dict()
            elif isinstance(self.network_acl_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkAclId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_acl_id
                ]
            else:
                props["NetworkAclId"] = self.network_acl_id

        if self.rule_action is not None:
            # Serialize rule_action (handle intrinsic functions)
            if hasattr(self.rule_action, 'to_dict'):
                props["RuleAction"] = self.rule_action.to_dict()
            elif isinstance(self.rule_action, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuleAction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_action
                ]
            else:
                props["RuleAction"] = self.rule_action

        if self.cidr_block is not None:
            # Serialize cidr_block (handle intrinsic functions)
            if hasattr(self.cidr_block, 'to_dict'):
                props["CidrBlock"] = self.cidr_block.to_dict()
            elif isinstance(self.cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_block
                ]
            else:
                props["CidrBlock"] = self.cidr_block

        if self.egress is not None:
            # Serialize egress (handle intrinsic functions)
            if hasattr(self.egress, 'to_dict'):
                props["Egress"] = self.egress.to_dict()
            elif isinstance(self.egress, list):
                # Serialize list items (may contain intrinsic functions)
                props['Egress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.egress
                ]
            else:
                props["Egress"] = self.egress

        if self.rule_number is not None:
            # Serialize rule_number (handle intrinsic functions)
            if hasattr(self.rule_number, 'to_dict'):
                props["RuleNumber"] = self.rule_number.to_dict()
            elif isinstance(self.rule_number, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuleNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_number
                ]
            else:
                props["RuleNumber"] = self.rule_number

        if self.ipv6_cidr_block is not None:
            # Serialize ipv6_cidr_block (handle intrinsic functions)
            if hasattr(self.ipv6_cidr_block, 'to_dict'):
                props["Ipv6CidrBlock"] = self.ipv6_cidr_block.to_dict()
            elif isinstance(self.ipv6_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_cidr_block
                ]
            else:
                props["Ipv6CidrBlock"] = self.ipv6_cidr_block

        if self.protocol is not None:
            # Serialize protocol (handle intrinsic functions)
            if hasattr(self.protocol, 'to_dict'):
                props["Protocol"] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                # Serialize list items (may contain intrinsic functions)
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props["Protocol"] = self.protocol

        if self.icmp is not None:
            # Serialize icmp (handle intrinsic functions)
            if hasattr(self.icmp, 'to_dict'):
                props["Icmp"] = self.icmp.to_dict()
            elif isinstance(self.icmp, list):
                # Serialize list items (may contain intrinsic functions)
                props['Icmp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.icmp
                ]
            else:
                props["Icmp"] = self.icmp

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class AccessScopePathRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination: Optional[PathStatementRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    through_resources: Optional[list[ThroughResourcesStatementRequest]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source: Optional[PathStatementRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination is not None:
            if hasattr(self.destination, 'to_dict'):
                props['Destination'] = self.destination.to_dict()
            elif isinstance(self.destination, list):
                props['Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination
                ]
            else:
                props['Destination'] = self.destination

        if self.through_resources is not None:
            if hasattr(self.through_resources, 'to_dict'):
                props['ThroughResources'] = self.through_resources.to_dict()
            elif isinstance(self.through_resources, list):
                props['ThroughResources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.through_resources
                ]
            else:
                props['ThroughResources'] = self.through_resources

        if self.source is not None:
            if hasattr(self.source, 'to_dict'):
                props['Source'] = self.source.to_dict()
            elif isinstance(self.source, list):
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props['Source'] = self.source

        return props


@dataclass
class PacketHeaderStatementRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocols: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_ports: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_addresses: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_prefix_lists: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_addresses: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_ports: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_prefix_lists: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.protocols is not None:
            if hasattr(self.protocols, 'to_dict'):
                props['Protocols'] = self.protocols.to_dict()
            elif isinstance(self.protocols, list):
                props['Protocols'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocols
                ]
            else:
                props['Protocols'] = self.protocols

        if self.destination_ports is not None:
            if hasattr(self.destination_ports, 'to_dict'):
                props['DestinationPorts'] = self.destination_ports.to_dict()
            elif isinstance(self.destination_ports, list):
                props['DestinationPorts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_ports
                ]
            else:
                props['DestinationPorts'] = self.destination_ports

        if self.destination_addresses is not None:
            if hasattr(self.destination_addresses, 'to_dict'):
                props['DestinationAddresses'] = self.destination_addresses.to_dict()
            elif isinstance(self.destination_addresses, list):
                props['DestinationAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_addresses
                ]
            else:
                props['DestinationAddresses'] = self.destination_addresses

        if self.destination_prefix_lists is not None:
            if hasattr(self.destination_prefix_lists, 'to_dict'):
                props['DestinationPrefixLists'] = self.destination_prefix_lists.to_dict()
            elif isinstance(self.destination_prefix_lists, list):
                props['DestinationPrefixLists'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_prefix_lists
                ]
            else:
                props['DestinationPrefixLists'] = self.destination_prefix_lists

        if self.source_addresses is not None:
            if hasattr(self.source_addresses, 'to_dict'):
                props['SourceAddresses'] = self.source_addresses.to_dict()
            elif isinstance(self.source_addresses, list):
                props['SourceAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_addresses
                ]
            else:
                props['SourceAddresses'] = self.source_addresses

        if self.source_ports is not None:
            if hasattr(self.source_ports, 'to_dict'):
                props['SourcePorts'] = self.source_ports.to_dict()
            elif isinstance(self.source_ports, list):
                props['SourcePorts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_ports
                ]
            else:
                props['SourcePorts'] = self.source_ports

        if self.source_prefix_lists is not None:
            if hasattr(self.source_prefix_lists, 'to_dict'):
                props['SourcePrefixLists'] = self.source_prefix_lists.to_dict()
            elif isinstance(self.source_prefix_lists, list):
                props['SourcePrefixLists'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_prefix_lists
                ]
            else:
                props['SourcePrefixLists'] = self.source_prefix_lists

        return props


@dataclass
class PathStatementRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_statement: Optional[ResourceStatementRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    packet_header_statement: Optional[PacketHeaderStatementRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_statement is not None:
            if hasattr(self.resource_statement, 'to_dict'):
                props['ResourceStatement'] = self.resource_statement.to_dict()
            elif isinstance(self.resource_statement, list):
                props['ResourceStatement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_statement
                ]
            else:
                props['ResourceStatement'] = self.resource_statement

        if self.packet_header_statement is not None:
            if hasattr(self.packet_header_statement, 'to_dict'):
                props['PacketHeaderStatement'] = self.packet_header_statement.to_dict()
            elif isinstance(self.packet_header_statement, list):
                props['PacketHeaderStatement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.packet_header_statement
                ]
            else:
                props['PacketHeaderStatement'] = self.packet_header_statement

        return props


@dataclass
class ResourceStatementRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resources: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_types is not None:
            if hasattr(self.resource_types, 'to_dict'):
                props['ResourceTypes'] = self.resource_types.to_dict()
            elif isinstance(self.resource_types, list):
                props['ResourceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_types
                ]
            else:
                props['ResourceTypes'] = self.resource_types

        if self.resources is not None:
            if hasattr(self.resources, 'to_dict'):
                props['Resources'] = self.resources.to_dict()
            elif isinstance(self.resources, list):
                props['Resources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resources
                ]
            else:
                props['Resources'] = self.resources

        return props


@dataclass
class ThroughResourcesStatementRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_statement: Optional[ResourceStatementRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_statement is not None:
            if hasattr(self.resource_statement, 'to_dict'):
                props['ResourceStatement'] = self.resource_statement.to_dict()
            elif isinstance(self.resource_statement, list):
                props['ResourceStatement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_statement
                ]
            else:
                props['ResourceStatement'] = self.resource_statement

        return props


@dataclass
class NetworkInsightsAccessScope(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkInsightsAccessScope"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    exclude_paths: Optional[list[AccessScopePathRequest]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    match_paths: Optional[list[AccessScopePathRequest]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.exclude_paths is not None:
            # Serialize exclude_paths (handle intrinsic functions)
            if hasattr(self.exclude_paths, 'to_dict'):
                props["ExcludePaths"] = self.exclude_paths.to_dict()
            elif isinstance(self.exclude_paths, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExcludePaths'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.exclude_paths
                ]
            else:
                props["ExcludePaths"] = self.exclude_paths

        if self.match_paths is not None:
            # Serialize match_paths (handle intrinsic functions)
            if hasattr(self.match_paths, 'to_dict'):
                props["MatchPaths"] = self.match_paths.to_dict()
            elif isinstance(self.match_paths, list):
                # Serialize list items (may contain intrinsic functions)
                props['MatchPaths'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.match_paths
                ]
            else:
                props["MatchPaths"] = self.match_paths

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_updated_date(self) -> GetAtt:
        """Get the UpdatedDate attribute."""
        return self.get_att("UpdatedDate")

    @property
    def attr_created_date(self) -> GetAtt:
        """Get the CreatedDate attribute."""
        return self.get_att("CreatedDate")

    @property
    def attr_network_insights_access_scope_arn(self) -> GetAtt:
        """Get the NetworkInsightsAccessScopeArn attribute."""
        return self.get_att("NetworkInsightsAccessScopeArn")

    @property
    def attr_network_insights_access_scope_id(self) -> GetAtt:
        """Get the NetworkInsightsAccessScopeId attribute."""
        return self.get_att("NetworkInsightsAccessScopeId")




@dataclass
class NetworkInsightsAccessScopeAnalysis(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkInsightsAccessScopeAnalysis"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_insights_access_scope_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.network_insights_access_scope_id is not None:
            # Serialize network_insights_access_scope_id (handle intrinsic functions)
            if hasattr(self.network_insights_access_scope_id, 'to_dict'):
                props["NetworkInsightsAccessScopeId"] = self.network_insights_access_scope_id.to_dict()
            elif isinstance(self.network_insights_access_scope_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInsightsAccessScopeId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_insights_access_scope_id
                ]
            else:
                props["NetworkInsightsAccessScopeId"] = self.network_insights_access_scope_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_start_date(self) -> GetAtt:
        """Get the StartDate attribute."""
        return self.get_att("StartDate")

    @property
    def attr_network_insights_access_scope_analysis_id(self) -> GetAtt:
        """Get the NetworkInsightsAccessScopeAnalysisId attribute."""
        return self.get_att("NetworkInsightsAccessScopeAnalysisId")

    @property
    def attr_network_insights_access_scope_analysis_arn(self) -> GetAtt:
        """Get the NetworkInsightsAccessScopeAnalysisArn attribute."""
        return self.get_att("NetworkInsightsAccessScopeAnalysisArn")

    @property
    def attr_end_date(self) -> GetAtt:
        """Get the EndDate attribute."""
        return self.get_att("EndDate")

    @property
    def attr_analyzed_eni_count(self) -> GetAtt:
        """Get the AnalyzedEniCount attribute."""
        return self.get_att("AnalyzedEniCount")

    @property
    def attr_findings_found(self) -> GetAtt:
        """Get the FindingsFound attribute."""
        return self.get_att("FindingsFound")

    @property
    def attr_status_message(self) -> GetAtt:
        """Get the StatusMessage attribute."""
        return self.get_att("StatusMessage")




@dataclass
class AdditionalDetail:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    service_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    additional_detail_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancers: Optional[list[AnalysisComponent]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    component: Optional[AnalysisComponent] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.service_name is not None:
            if hasattr(self.service_name, 'to_dict'):
                props['ServiceName'] = self.service_name.to_dict()
            elif isinstance(self.service_name, list):
                props['ServiceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_name
                ]
            else:
                props['ServiceName'] = self.service_name

        if self.additional_detail_type is not None:
            if hasattr(self.additional_detail_type, 'to_dict'):
                props['AdditionalDetailType'] = self.additional_detail_type.to_dict()
            elif isinstance(self.additional_detail_type, list):
                props['AdditionalDetailType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_detail_type
                ]
            else:
                props['AdditionalDetailType'] = self.additional_detail_type

        if self.load_balancers is not None:
            if hasattr(self.load_balancers, 'to_dict'):
                props['LoadBalancers'] = self.load_balancers.to_dict()
            elif isinstance(self.load_balancers, list):
                props['LoadBalancers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancers
                ]
            else:
                props['LoadBalancers'] = self.load_balancers

        if self.component is not None:
            if hasattr(self.component, 'to_dict'):
                props['Component'] = self.component.to_dict()
            elif isinstance(self.component, list):
                props['Component'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.component
                ]
            else:
                props['Component'] = self.component

        return props


@dataclass
class AlternatePathHint:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    component_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    component_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.component_arn is not None:
            if hasattr(self.component_arn, 'to_dict'):
                props['ComponentArn'] = self.component_arn.to_dict()
            elif isinstance(self.component_arn, list):
                props['ComponentArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.component_arn
                ]
            else:
                props['ComponentArn'] = self.component_arn

        if self.component_id is not None:
            if hasattr(self.component_id, 'to_dict'):
                props['ComponentId'] = self.component_id.to_dict()
            elif isinstance(self.component_id, list):
                props['ComponentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.component_id
                ]
            else:
                props['ComponentId'] = self.component_id

        return props


@dataclass
class AnalysisAclRule:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port_range: Optional[PortRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    egress: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.port_range is not None:
            if hasattr(self.port_range, 'to_dict'):
                props['PortRange'] = self.port_range.to_dict()
            elif isinstance(self.port_range, list):
                props['PortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port_range
                ]
            else:
                props['PortRange'] = self.port_range

        if self.cidr is not None:
            if hasattr(self.cidr, 'to_dict'):
                props['Cidr'] = self.cidr.to_dict()
            elif isinstance(self.cidr, list):
                props['Cidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr
                ]
            else:
                props['Cidr'] = self.cidr

        if self.rule_action is not None:
            if hasattr(self.rule_action, 'to_dict'):
                props['RuleAction'] = self.rule_action.to_dict()
            elif isinstance(self.rule_action, list):
                props['RuleAction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_action
                ]
            else:
                props['RuleAction'] = self.rule_action

        if self.egress is not None:
            if hasattr(self.egress, 'to_dict'):
                props['Egress'] = self.egress.to_dict()
            elif isinstance(self.egress, list):
                props['Egress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.egress
                ]
            else:
                props['Egress'] = self.egress

        if self.rule_number is not None:
            if hasattr(self.rule_number, 'to_dict'):
                props['RuleNumber'] = self.rule_number.to_dict()
            elif isinstance(self.rule_number, list):
                props['RuleNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_number
                ]
            else:
                props['RuleNumber'] = self.rule_number

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        return props


@dataclass
class AnalysisComponent:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.id is not None:
            if hasattr(self.id, 'to_dict'):
                props['Id'] = self.id.to_dict()
            elif isinstance(self.id, list):
                props['Id'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.id
                ]
            else:
                props['Id'] = self.id

        if self.arn is not None:
            if hasattr(self.arn, 'to_dict'):
                props['Arn'] = self.arn.to_dict()
            elif isinstance(self.arn, list):
                props['Arn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.arn
                ]
            else:
                props['Arn'] = self.arn

        return props


@dataclass
class AnalysisLoadBalancerListener:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancer_port: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_port is not None:
            if hasattr(self.instance_port, 'to_dict'):
                props['InstancePort'] = self.instance_port.to_dict()
            elif isinstance(self.instance_port, list):
                props['InstancePort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_port
                ]
            else:
                props['InstancePort'] = self.instance_port

        if self.load_balancer_port is not None:
            if hasattr(self.load_balancer_port, 'to_dict'):
                props['LoadBalancerPort'] = self.load_balancer_port.to_dict()
            elif isinstance(self.load_balancer_port, list):
                props['LoadBalancerPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_port
                ]
            else:
                props['LoadBalancerPort'] = self.load_balancer_port

        return props


@dataclass
class AnalysisLoadBalancerTarget:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.address is not None:
            if hasattr(self.address, 'to_dict'):
                props['Address'] = self.address.to_dict()
            elif isinstance(self.address, list):
                props['Address'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.address
                ]
            else:
                props['Address'] = self.address

        if self.instance is not None:
            if hasattr(self.instance, 'to_dict'):
                props['Instance'] = self.instance.to_dict()
            elif isinstance(self.instance, list):
                props['Instance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance
                ]
            else:
                props['Instance'] = self.instance

        if self.port is not None:
            if hasattr(self.port, 'to_dict'):
                props['Port'] = self.port.to_dict()
            elif isinstance(self.port, list):
                props['Port'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port
                ]
            else:
                props['Port'] = self.port

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        return props


@dataclass
class AnalysisPacketHeader:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_port_ranges: Optional[list[PortRange]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_port_ranges: Optional[list[PortRange]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_addresses: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_addresses: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination_port_ranges is not None:
            if hasattr(self.destination_port_ranges, 'to_dict'):
                props['DestinationPortRanges'] = self.destination_port_ranges.to_dict()
            elif isinstance(self.destination_port_ranges, list):
                props['DestinationPortRanges'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_port_ranges
                ]
            else:
                props['DestinationPortRanges'] = self.destination_port_ranges

        if self.source_port_ranges is not None:
            if hasattr(self.source_port_ranges, 'to_dict'):
                props['SourcePortRanges'] = self.source_port_ranges.to_dict()
            elif isinstance(self.source_port_ranges, list):
                props['SourcePortRanges'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_port_ranges
                ]
            else:
                props['SourcePortRanges'] = self.source_port_ranges

        if self.destination_addresses is not None:
            if hasattr(self.destination_addresses, 'to_dict'):
                props['DestinationAddresses'] = self.destination_addresses.to_dict()
            elif isinstance(self.destination_addresses, list):
                props['DestinationAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_addresses
                ]
            else:
                props['DestinationAddresses'] = self.destination_addresses

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        if self.source_addresses is not None:
            if hasattr(self.source_addresses, 'to_dict'):
                props['SourceAddresses'] = self.source_addresses.to_dict()
            elif isinstance(self.source_addresses, list):
                props['SourceAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_addresses
                ]
            else:
                props['SourceAddresses'] = self.source_addresses

        return props


@dataclass
class AnalysisRouteTableRoute:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    origin: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_prefix_list_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_peering_connection_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    state: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    egress_only_internet_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    nat_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.origin is not None:
            if hasattr(self.origin, 'to_dict'):
                props['Origin'] = self.origin.to_dict()
            elif isinstance(self.origin, list):
                props['Origin'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.origin
                ]
            else:
                props['Origin'] = self.origin

        if self.destination_prefix_list_id is not None:
            if hasattr(self.destination_prefix_list_id, 'to_dict'):
                props['destinationPrefixListId'] = self.destination_prefix_list_id.to_dict()
            elif isinstance(self.destination_prefix_list_id, list):
                props['destinationPrefixListId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_prefix_list_id
                ]
            else:
                props['destinationPrefixListId'] = self.destination_prefix_list_id

        if self.transit_gateway_id is not None:
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props['TransitGatewayId'] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props['TransitGatewayId'] = self.transit_gateway_id

        if self.vpc_peering_connection_id is not None:
            if hasattr(self.vpc_peering_connection_id, 'to_dict'):
                props['VpcPeeringConnectionId'] = self.vpc_peering_connection_id.to_dict()
            elif isinstance(self.vpc_peering_connection_id, list):
                props['VpcPeeringConnectionId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_peering_connection_id
                ]
            else:
                props['VpcPeeringConnectionId'] = self.vpc_peering_connection_id

        if self.instance_id is not None:
            if hasattr(self.instance_id, 'to_dict'):
                props['instanceId'] = self.instance_id.to_dict()
            elif isinstance(self.instance_id, list):
                props['instanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_id
                ]
            else:
                props['instanceId'] = self.instance_id

        if self.state is not None:
            if hasattr(self.state, 'to_dict'):
                props['State'] = self.state.to_dict()
            elif isinstance(self.state, list):
                props['State'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state
                ]
            else:
                props['State'] = self.state

        if self.egress_only_internet_gateway_id is not None:
            if hasattr(self.egress_only_internet_gateway_id, 'to_dict'):
                props['egressOnlyInternetGatewayId'] = self.egress_only_internet_gateway_id.to_dict()
            elif isinstance(self.egress_only_internet_gateway_id, list):
                props['egressOnlyInternetGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.egress_only_internet_gateway_id
                ]
            else:
                props['egressOnlyInternetGatewayId'] = self.egress_only_internet_gateway_id

        if self.destination_cidr is not None:
            if hasattr(self.destination_cidr, 'to_dict'):
                props['destinationCidr'] = self.destination_cidr.to_dict()
            elif isinstance(self.destination_cidr, list):
                props['destinationCidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr
                ]
            else:
                props['destinationCidr'] = self.destination_cidr

        if self.network_interface_id is not None:
            if hasattr(self.network_interface_id, 'to_dict'):
                props['NetworkInterfaceId'] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props['NetworkInterfaceId'] = self.network_interface_id

        if self.nat_gateway_id is not None:
            if hasattr(self.nat_gateway_id, 'to_dict'):
                props['NatGatewayId'] = self.nat_gateway_id.to_dict()
            elif isinstance(self.nat_gateway_id, list):
                props['NatGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.nat_gateway_id
                ]
            else:
                props['NatGatewayId'] = self.nat_gateway_id

        if self.gateway_id is not None:
            if hasattr(self.gateway_id, 'to_dict'):
                props['gatewayId'] = self.gateway_id.to_dict()
            elif isinstance(self.gateway_id, list):
                props['gatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gateway_id
                ]
            else:
                props['gatewayId'] = self.gateway_id

        return props


@dataclass
class AnalysisSecurityGroupRule:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port_range: Optional[PortRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    prefix_list_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    direction: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.port_range is not None:
            if hasattr(self.port_range, 'to_dict'):
                props['PortRange'] = self.port_range.to_dict()
            elif isinstance(self.port_range, list):
                props['PortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port_range
                ]
            else:
                props['PortRange'] = self.port_range

        if self.cidr is not None:
            if hasattr(self.cidr, 'to_dict'):
                props['Cidr'] = self.cidr.to_dict()
            elif isinstance(self.cidr, list):
                props['Cidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr
                ]
            else:
                props['Cidr'] = self.cidr

        if self.prefix_list_id is not None:
            if hasattr(self.prefix_list_id, 'to_dict'):
                props['PrefixListId'] = self.prefix_list_id.to_dict()
            elif isinstance(self.prefix_list_id, list):
                props['PrefixListId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.prefix_list_id
                ]
            else:
                props['PrefixListId'] = self.prefix_list_id

        if self.security_group_id is not None:
            if hasattr(self.security_group_id, 'to_dict'):
                props['SecurityGroupId'] = self.security_group_id.to_dict()
            elif isinstance(self.security_group_id, list):
                props['SecurityGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_id
                ]
            else:
                props['SecurityGroupId'] = self.security_group_id

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        if self.direction is not None:
            if hasattr(self.direction, 'to_dict'):
                props['Direction'] = self.direction.to_dict()
            elif isinstance(self.direction, list):
                props['Direction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.direction
                ]
            else:
                props['Direction'] = self.direction

        return props


@dataclass
class Explanation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpn_gateway: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    packet_field: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway_attachment: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocols: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ingress_route_table: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    classic_load_balancer_listener: Optional[AnalysisLoadBalancerListener] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_peering_connection: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    addresses: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    elastic_load_balancer_listener: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway_route_table: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    explanation_code: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    internet_gateway: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_vpc: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attached_to: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    prefix_list: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway_route_table_route: Optional[TransitGatewayRouteTableRoute] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    component_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancer_target_group: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customer_gateway: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_vpc: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    route_table: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    state: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancer_listener_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_endpoint: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidrs: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_groups: Optional[list[AnalysisComponent]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    component_account: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpn_connection: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    nat_gateway: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    direction: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancer_target_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancer_target: Optional[AnalysisLoadBalancerTarget] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancer_target_groups: Optional[list[AnalysisComponent]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    component: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    missing_component: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    route_table_route: Optional[AnalysisRouteTableRoute] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zones: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port_ranges: Optional[list[PortRange]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    acl: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_rule: Optional[AnalysisSecurityGroupRule] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_route_table: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancer_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    acl_rule: Optional[AnalysisAclRule] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpn_gateway is not None:
            if hasattr(self.vpn_gateway, 'to_dict'):
                props['VpnGateway'] = self.vpn_gateway.to_dict()
            elif isinstance(self.vpn_gateway, list):
                props['VpnGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_gateway
                ]
            else:
                props['VpnGateway'] = self.vpn_gateway

        if self.packet_field is not None:
            if hasattr(self.packet_field, 'to_dict'):
                props['PacketField'] = self.packet_field.to_dict()
            elif isinstance(self.packet_field, list):
                props['PacketField'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.packet_field
                ]
            else:
                props['PacketField'] = self.packet_field

        if self.transit_gateway_attachment is not None:
            if hasattr(self.transit_gateway_attachment, 'to_dict'):
                props['TransitGatewayAttachment'] = self.transit_gateway_attachment.to_dict()
            elif isinstance(self.transit_gateway_attachment, list):
                props['TransitGatewayAttachment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_attachment
                ]
            else:
                props['TransitGatewayAttachment'] = self.transit_gateway_attachment

        if self.protocols is not None:
            if hasattr(self.protocols, 'to_dict'):
                props['Protocols'] = self.protocols.to_dict()
            elif isinstance(self.protocols, list):
                props['Protocols'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocols
                ]
            else:
                props['Protocols'] = self.protocols

        if self.ingress_route_table is not None:
            if hasattr(self.ingress_route_table, 'to_dict'):
                props['IngressRouteTable'] = self.ingress_route_table.to_dict()
            elif isinstance(self.ingress_route_table, list):
                props['IngressRouteTable'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ingress_route_table
                ]
            else:
                props['IngressRouteTable'] = self.ingress_route_table

        if self.classic_load_balancer_listener is not None:
            if hasattr(self.classic_load_balancer_listener, 'to_dict'):
                props['ClassicLoadBalancerListener'] = self.classic_load_balancer_listener.to_dict()
            elif isinstance(self.classic_load_balancer_listener, list):
                props['ClassicLoadBalancerListener'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.classic_load_balancer_listener
                ]
            else:
                props['ClassicLoadBalancerListener'] = self.classic_load_balancer_listener

        if self.vpc_peering_connection is not None:
            if hasattr(self.vpc_peering_connection, 'to_dict'):
                props['VpcPeeringConnection'] = self.vpc_peering_connection.to_dict()
            elif isinstance(self.vpc_peering_connection, list):
                props['VpcPeeringConnection'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_peering_connection
                ]
            else:
                props['VpcPeeringConnection'] = self.vpc_peering_connection

        if self.address is not None:
            if hasattr(self.address, 'to_dict'):
                props['Address'] = self.address.to_dict()
            elif isinstance(self.address, list):
                props['Address'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.address
                ]
            else:
                props['Address'] = self.address

        if self.port is not None:
            if hasattr(self.port, 'to_dict'):
                props['Port'] = self.port.to_dict()
            elif isinstance(self.port, list):
                props['Port'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port
                ]
            else:
                props['Port'] = self.port

        if self.addresses is not None:
            if hasattr(self.addresses, 'to_dict'):
                props['Addresses'] = self.addresses.to_dict()
            elif isinstance(self.addresses, list):
                props['Addresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.addresses
                ]
            else:
                props['Addresses'] = self.addresses

        if self.elastic_load_balancer_listener is not None:
            if hasattr(self.elastic_load_balancer_listener, 'to_dict'):
                props['ElasticLoadBalancerListener'] = self.elastic_load_balancer_listener.to_dict()
            elif isinstance(self.elastic_load_balancer_listener, list):
                props['ElasticLoadBalancerListener'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.elastic_load_balancer_listener
                ]
            else:
                props['ElasticLoadBalancerListener'] = self.elastic_load_balancer_listener

        if self.transit_gateway_route_table is not None:
            if hasattr(self.transit_gateway_route_table, 'to_dict'):
                props['TransitGatewayRouteTable'] = self.transit_gateway_route_table.to_dict()
            elif isinstance(self.transit_gateway_route_table, list):
                props['TransitGatewayRouteTable'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_route_table
                ]
            else:
                props['TransitGatewayRouteTable'] = self.transit_gateway_route_table

        if self.explanation_code is not None:
            if hasattr(self.explanation_code, 'to_dict'):
                props['ExplanationCode'] = self.explanation_code.to_dict()
            elif isinstance(self.explanation_code, list):
                props['ExplanationCode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.explanation_code
                ]
            else:
                props['ExplanationCode'] = self.explanation_code

        if self.internet_gateway is not None:
            if hasattr(self.internet_gateway, 'to_dict'):
                props['InternetGateway'] = self.internet_gateway.to_dict()
            elif isinstance(self.internet_gateway, list):
                props['InternetGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internet_gateway
                ]
            else:
                props['InternetGateway'] = self.internet_gateway

        if self.source_vpc is not None:
            if hasattr(self.source_vpc, 'to_dict'):
                props['SourceVpc'] = self.source_vpc.to_dict()
            elif isinstance(self.source_vpc, list):
                props['SourceVpc'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_vpc
                ]
            else:
                props['SourceVpc'] = self.source_vpc

        if self.attached_to is not None:
            if hasattr(self.attached_to, 'to_dict'):
                props['AttachedTo'] = self.attached_to.to_dict()
            elif isinstance(self.attached_to, list):
                props['AttachedTo'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attached_to
                ]
            else:
                props['AttachedTo'] = self.attached_to

        if self.prefix_list is not None:
            if hasattr(self.prefix_list, 'to_dict'):
                props['PrefixList'] = self.prefix_list.to_dict()
            elif isinstance(self.prefix_list, list):
                props['PrefixList'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.prefix_list
                ]
            else:
                props['PrefixList'] = self.prefix_list

        if self.transit_gateway_route_table_route is not None:
            if hasattr(self.transit_gateway_route_table_route, 'to_dict'):
                props['TransitGatewayRouteTableRoute'] = self.transit_gateway_route_table_route.to_dict()
            elif isinstance(self.transit_gateway_route_table_route, list):
                props['TransitGatewayRouteTableRoute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_route_table_route
                ]
            else:
                props['TransitGatewayRouteTableRoute'] = self.transit_gateway_route_table_route

        if self.component_region is not None:
            if hasattr(self.component_region, 'to_dict'):
                props['ComponentRegion'] = self.component_region.to_dict()
            elif isinstance(self.component_region, list):
                props['ComponentRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.component_region
                ]
            else:
                props['ComponentRegion'] = self.component_region

        if self.load_balancer_target_group is not None:
            if hasattr(self.load_balancer_target_group, 'to_dict'):
                props['LoadBalancerTargetGroup'] = self.load_balancer_target_group.to_dict()
            elif isinstance(self.load_balancer_target_group, list):
                props['LoadBalancerTargetGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_target_group
                ]
            else:
                props['LoadBalancerTargetGroup'] = self.load_balancer_target_group

        if self.network_interface is not None:
            if hasattr(self.network_interface, 'to_dict'):
                props['NetworkInterface'] = self.network_interface.to_dict()
            elif isinstance(self.network_interface, list):
                props['NetworkInterface'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface
                ]
            else:
                props['NetworkInterface'] = self.network_interface

        if self.customer_gateway is not None:
            if hasattr(self.customer_gateway, 'to_dict'):
                props['CustomerGateway'] = self.customer_gateway.to_dict()
            elif isinstance(self.customer_gateway, list):
                props['CustomerGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customer_gateway
                ]
            else:
                props['CustomerGateway'] = self.customer_gateway

        if self.destination_vpc is not None:
            if hasattr(self.destination_vpc, 'to_dict'):
                props['DestinationVpc'] = self.destination_vpc.to_dict()
            elif isinstance(self.destination_vpc, list):
                props['DestinationVpc'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_vpc
                ]
            else:
                props['DestinationVpc'] = self.destination_vpc

        if self.security_group is not None:
            if hasattr(self.security_group, 'to_dict'):
                props['SecurityGroup'] = self.security_group.to_dict()
            elif isinstance(self.security_group, list):
                props['SecurityGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group
                ]
            else:
                props['SecurityGroup'] = self.security_group

        if self.transit_gateway is not None:
            if hasattr(self.transit_gateway, 'to_dict'):
                props['TransitGateway'] = self.transit_gateway.to_dict()
            elif isinstance(self.transit_gateway, list):
                props['TransitGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway
                ]
            else:
                props['TransitGateway'] = self.transit_gateway

        if self.route_table is not None:
            if hasattr(self.route_table, 'to_dict'):
                props['RouteTable'] = self.route_table.to_dict()
            elif isinstance(self.route_table, list):
                props['RouteTable'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table
                ]
            else:
                props['RouteTable'] = self.route_table

        if self.state is not None:
            if hasattr(self.state, 'to_dict'):
                props['State'] = self.state.to_dict()
            elif isinstance(self.state, list):
                props['State'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state
                ]
            else:
                props['State'] = self.state

        if self.load_balancer_listener_port is not None:
            if hasattr(self.load_balancer_listener_port, 'to_dict'):
                props['LoadBalancerListenerPort'] = self.load_balancer_listener_port.to_dict()
            elif isinstance(self.load_balancer_listener_port, list):
                props['LoadBalancerListenerPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_listener_port
                ]
            else:
                props['LoadBalancerListenerPort'] = self.load_balancer_listener_port

        if self.vpc_endpoint is not None:
            if hasattr(self.vpc_endpoint, 'to_dict'):
                props['vpcEndpoint'] = self.vpc_endpoint.to_dict()
            elif isinstance(self.vpc_endpoint, list):
                props['vpcEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_endpoint
                ]
            else:
                props['vpcEndpoint'] = self.vpc_endpoint

        if self.subnet is not None:
            if hasattr(self.subnet, 'to_dict'):
                props['Subnet'] = self.subnet.to_dict()
            elif isinstance(self.subnet, list):
                props['Subnet'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet
                ]
            else:
                props['Subnet'] = self.subnet

        if self.cidrs is not None:
            if hasattr(self.cidrs, 'to_dict'):
                props['Cidrs'] = self.cidrs.to_dict()
            elif isinstance(self.cidrs, list):
                props['Cidrs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidrs
                ]
            else:
                props['Cidrs'] = self.cidrs

        if self.destination is not None:
            if hasattr(self.destination, 'to_dict'):
                props['Destination'] = self.destination.to_dict()
            elif isinstance(self.destination, list):
                props['Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination
                ]
            else:
                props['Destination'] = self.destination

        if self.security_groups is not None:
            if hasattr(self.security_groups, 'to_dict'):
                props['SecurityGroups'] = self.security_groups.to_dict()
            elif isinstance(self.security_groups, list):
                props['SecurityGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_groups
                ]
            else:
                props['SecurityGroups'] = self.security_groups

        if self.component_account is not None:
            if hasattr(self.component_account, 'to_dict'):
                props['ComponentAccount'] = self.component_account.to_dict()
            elif isinstance(self.component_account, list):
                props['ComponentAccount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.component_account
                ]
            else:
                props['ComponentAccount'] = self.component_account

        if self.vpn_connection is not None:
            if hasattr(self.vpn_connection, 'to_dict'):
                props['VpnConnection'] = self.vpn_connection.to_dict()
            elif isinstance(self.vpn_connection, list):
                props['VpnConnection'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_connection
                ]
            else:
                props['VpnConnection'] = self.vpn_connection

        if self.vpc is not None:
            if hasattr(self.vpc, 'to_dict'):
                props['Vpc'] = self.vpc.to_dict()
            elif isinstance(self.vpc, list):
                props['Vpc'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc
                ]
            else:
                props['Vpc'] = self.vpc

        if self.nat_gateway is not None:
            if hasattr(self.nat_gateway, 'to_dict'):
                props['NatGateway'] = self.nat_gateway.to_dict()
            elif isinstance(self.nat_gateway, list):
                props['NatGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.nat_gateway
                ]
            else:
                props['NatGateway'] = self.nat_gateway

        if self.direction is not None:
            if hasattr(self.direction, 'to_dict'):
                props['Direction'] = self.direction.to_dict()
            elif isinstance(self.direction, list):
                props['Direction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.direction
                ]
            else:
                props['Direction'] = self.direction

        if self.load_balancer_target_port is not None:
            if hasattr(self.load_balancer_target_port, 'to_dict'):
                props['LoadBalancerTargetPort'] = self.load_balancer_target_port.to_dict()
            elif isinstance(self.load_balancer_target_port, list):
                props['LoadBalancerTargetPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_target_port
                ]
            else:
                props['LoadBalancerTargetPort'] = self.load_balancer_target_port

        if self.load_balancer_target is not None:
            if hasattr(self.load_balancer_target, 'to_dict'):
                props['LoadBalancerTarget'] = self.load_balancer_target.to_dict()
            elif isinstance(self.load_balancer_target, list):
                props['LoadBalancerTarget'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_target
                ]
            else:
                props['LoadBalancerTarget'] = self.load_balancer_target

        if self.load_balancer_target_groups is not None:
            if hasattr(self.load_balancer_target_groups, 'to_dict'):
                props['LoadBalancerTargetGroups'] = self.load_balancer_target_groups.to_dict()
            elif isinstance(self.load_balancer_target_groups, list):
                props['LoadBalancerTargetGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_target_groups
                ]
            else:
                props['LoadBalancerTargetGroups'] = self.load_balancer_target_groups

        if self.component is not None:
            if hasattr(self.component, 'to_dict'):
                props['Component'] = self.component.to_dict()
            elif isinstance(self.component, list):
                props['Component'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.component
                ]
            else:
                props['Component'] = self.component

        if self.missing_component is not None:
            if hasattr(self.missing_component, 'to_dict'):
                props['MissingComponent'] = self.missing_component.to_dict()
            elif isinstance(self.missing_component, list):
                props['MissingComponent'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.missing_component
                ]
            else:
                props['MissingComponent'] = self.missing_component

        if self.route_table_route is not None:
            if hasattr(self.route_table_route, 'to_dict'):
                props['RouteTableRoute'] = self.route_table_route.to_dict()
            elif isinstance(self.route_table_route, list):
                props['RouteTableRoute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_route
                ]
            else:
                props['RouteTableRoute'] = self.route_table_route

        if self.availability_zones is not None:
            if hasattr(self.availability_zones, 'to_dict'):
                props['AvailabilityZones'] = self.availability_zones.to_dict()
            elif isinstance(self.availability_zones, list):
                props['AvailabilityZones'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zones
                ]
            else:
                props['AvailabilityZones'] = self.availability_zones

        if self.port_ranges is not None:
            if hasattr(self.port_ranges, 'to_dict'):
                props['PortRanges'] = self.port_ranges.to_dict()
            elif isinstance(self.port_ranges, list):
                props['PortRanges'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port_ranges
                ]
            else:
                props['PortRanges'] = self.port_ranges

        if self.acl is not None:
            if hasattr(self.acl, 'to_dict'):
                props['Acl'] = self.acl.to_dict()
            elif isinstance(self.acl, list):
                props['Acl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.acl
                ]
            else:
                props['Acl'] = self.acl

        if self.security_group_rule is not None:
            if hasattr(self.security_group_rule, 'to_dict'):
                props['SecurityGroupRule'] = self.security_group_rule.to_dict()
            elif isinstance(self.security_group_rule, list):
                props['SecurityGroupRule'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_rule
                ]
            else:
                props['SecurityGroupRule'] = self.security_group_rule

        if self.subnet_route_table is not None:
            if hasattr(self.subnet_route_table, 'to_dict'):
                props['SubnetRouteTable'] = self.subnet_route_table.to_dict()
            elif isinstance(self.subnet_route_table, list):
                props['SubnetRouteTable'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_route_table
                ]
            else:
                props['SubnetRouteTable'] = self.subnet_route_table

        if self.load_balancer_arn is not None:
            if hasattr(self.load_balancer_arn, 'to_dict'):
                props['LoadBalancerArn'] = self.load_balancer_arn.to_dict()
            elif isinstance(self.load_balancer_arn, list):
                props['LoadBalancerArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_arn
                ]
            else:
                props['LoadBalancerArn'] = self.load_balancer_arn

        if self.acl_rule is not None:
            if hasattr(self.acl_rule, 'to_dict'):
                props['AclRule'] = self.acl_rule.to_dict()
            elif isinstance(self.acl_rule, list):
                props['AclRule'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.acl_rule
                ]
            else:
                props['AclRule'] = self.acl_rule

        return props


@dataclass
class PathComponent:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    additional_details: Optional[list[AdditionalDetail]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inbound_header: Optional[AnalysisPacketHeader] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_vpc: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_rule: Optional[AnalysisSecurityGroupRule] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    elastic_load_balancer_listener: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    explanations: Optional[list[Explanation]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    service_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sequence_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_vpc: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    outbound_header: Optional[AnalysisPacketHeader] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    acl_rule: Optional[AnalysisAclRule] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway_route_table_route: Optional[TransitGatewayRouteTableRoute] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    component: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet: Optional[AnalysisComponent] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    route_table_route: Optional[AnalysisRouteTableRoute] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.additional_details is not None:
            if hasattr(self.additional_details, 'to_dict'):
                props['AdditionalDetails'] = self.additional_details.to_dict()
            elif isinstance(self.additional_details, list):
                props['AdditionalDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_details
                ]
            else:
                props['AdditionalDetails'] = self.additional_details

        if self.inbound_header is not None:
            if hasattr(self.inbound_header, 'to_dict'):
                props['InboundHeader'] = self.inbound_header.to_dict()
            elif isinstance(self.inbound_header, list):
                props['InboundHeader'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inbound_header
                ]
            else:
                props['InboundHeader'] = self.inbound_header

        if self.vpc is not None:
            if hasattr(self.vpc, 'to_dict'):
                props['Vpc'] = self.vpc.to_dict()
            elif isinstance(self.vpc, list):
                props['Vpc'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc
                ]
            else:
                props['Vpc'] = self.vpc

        if self.destination_vpc is not None:
            if hasattr(self.destination_vpc, 'to_dict'):
                props['DestinationVpc'] = self.destination_vpc.to_dict()
            elif isinstance(self.destination_vpc, list):
                props['DestinationVpc'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_vpc
                ]
            else:
                props['DestinationVpc'] = self.destination_vpc

        if self.security_group_rule is not None:
            if hasattr(self.security_group_rule, 'to_dict'):
                props['SecurityGroupRule'] = self.security_group_rule.to_dict()
            elif isinstance(self.security_group_rule, list):
                props['SecurityGroupRule'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_rule
                ]
            else:
                props['SecurityGroupRule'] = self.security_group_rule

        if self.transit_gateway is not None:
            if hasattr(self.transit_gateway, 'to_dict'):
                props['TransitGateway'] = self.transit_gateway.to_dict()
            elif isinstance(self.transit_gateway, list):
                props['TransitGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway
                ]
            else:
                props['TransitGateway'] = self.transit_gateway

        if self.elastic_load_balancer_listener is not None:
            if hasattr(self.elastic_load_balancer_listener, 'to_dict'):
                props['ElasticLoadBalancerListener'] = self.elastic_load_balancer_listener.to_dict()
            elif isinstance(self.elastic_load_balancer_listener, list):
                props['ElasticLoadBalancerListener'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.elastic_load_balancer_listener
                ]
            else:
                props['ElasticLoadBalancerListener'] = self.elastic_load_balancer_listener

        if self.explanations is not None:
            if hasattr(self.explanations, 'to_dict'):
                props['Explanations'] = self.explanations.to_dict()
            elif isinstance(self.explanations, list):
                props['Explanations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.explanations
                ]
            else:
                props['Explanations'] = self.explanations

        if self.service_name is not None:
            if hasattr(self.service_name, 'to_dict'):
                props['ServiceName'] = self.service_name.to_dict()
            elif isinstance(self.service_name, list):
                props['ServiceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_name
                ]
            else:
                props['ServiceName'] = self.service_name

        if self.sequence_number is not None:
            if hasattr(self.sequence_number, 'to_dict'):
                props['SequenceNumber'] = self.sequence_number.to_dict()
            elif isinstance(self.sequence_number, list):
                props['SequenceNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sequence_number
                ]
            else:
                props['SequenceNumber'] = self.sequence_number

        if self.source_vpc is not None:
            if hasattr(self.source_vpc, 'to_dict'):
                props['SourceVpc'] = self.source_vpc.to_dict()
            elif isinstance(self.source_vpc, list):
                props['SourceVpc'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_vpc
                ]
            else:
                props['SourceVpc'] = self.source_vpc

        if self.outbound_header is not None:
            if hasattr(self.outbound_header, 'to_dict'):
                props['OutboundHeader'] = self.outbound_header.to_dict()
            elif isinstance(self.outbound_header, list):
                props['OutboundHeader'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.outbound_header
                ]
            else:
                props['OutboundHeader'] = self.outbound_header

        if self.acl_rule is not None:
            if hasattr(self.acl_rule, 'to_dict'):
                props['AclRule'] = self.acl_rule.to_dict()
            elif isinstance(self.acl_rule, list):
                props['AclRule'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.acl_rule
                ]
            else:
                props['AclRule'] = self.acl_rule

        if self.transit_gateway_route_table_route is not None:
            if hasattr(self.transit_gateway_route_table_route, 'to_dict'):
                props['TransitGatewayRouteTableRoute'] = self.transit_gateway_route_table_route.to_dict()
            elif isinstance(self.transit_gateway_route_table_route, list):
                props['TransitGatewayRouteTableRoute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_route_table_route
                ]
            else:
                props['TransitGatewayRouteTableRoute'] = self.transit_gateway_route_table_route

        if self.component is not None:
            if hasattr(self.component, 'to_dict'):
                props['Component'] = self.component.to_dict()
            elif isinstance(self.component, list):
                props['Component'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.component
                ]
            else:
                props['Component'] = self.component

        if self.subnet is not None:
            if hasattr(self.subnet, 'to_dict'):
                props['Subnet'] = self.subnet.to_dict()
            elif isinstance(self.subnet, list):
                props['Subnet'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet
                ]
            else:
                props['Subnet'] = self.subnet

        if self.route_table_route is not None:
            if hasattr(self.route_table_route, 'to_dict'):
                props['RouteTableRoute'] = self.route_table_route.to_dict()
            elif isinstance(self.route_table_route, list):
                props['RouteTableRoute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_route
                ]
            else:
                props['RouteTableRoute'] = self.route_table_route

        return props


@dataclass
class PortRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.from_ is not None:
            if hasattr(self.from_, 'to_dict'):
                props['From'] = self.from_.to_dict()
            elif isinstance(self.from_, list):
                props['From'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_
                ]
            else:
                props['From'] = self.from_

        if self.to is not None:
            if hasattr(self.to, 'to_dict'):
                props['To'] = self.to.to_dict()
            elif isinstance(self.to, list):
                props['To'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to
                ]
            else:
                props['To'] = self.to

        return props


@dataclass
class TransitGatewayRouteTableRoute:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    prefix_list_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    state: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    route_origin: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.prefix_list_id is not None:
            if hasattr(self.prefix_list_id, 'to_dict'):
                props['PrefixListId'] = self.prefix_list_id.to_dict()
            elif isinstance(self.prefix_list_id, list):
                props['PrefixListId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.prefix_list_id
                ]
            else:
                props['PrefixListId'] = self.prefix_list_id

        if self.resource_id is not None:
            if hasattr(self.resource_id, 'to_dict'):
                props['ResourceId'] = self.resource_id.to_dict()
            elif isinstance(self.resource_id, list):
                props['ResourceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_id
                ]
            else:
                props['ResourceId'] = self.resource_id

        if self.state is not None:
            if hasattr(self.state, 'to_dict'):
                props['State'] = self.state.to_dict()
            elif isinstance(self.state, list):
                props['State'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state
                ]
            else:
                props['State'] = self.state

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        if self.route_origin is not None:
            if hasattr(self.route_origin, 'to_dict'):
                props['RouteOrigin'] = self.route_origin.to_dict()
            elif isinstance(self.route_origin, list):
                props['RouteOrigin'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_origin
                ]
            else:
                props['RouteOrigin'] = self.route_origin

        if self.destination_cidr is not None:
            if hasattr(self.destination_cidr, 'to_dict'):
                props['DestinationCidr'] = self.destination_cidr.to_dict()
            elif isinstance(self.destination_cidr, list):
                props['DestinationCidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr
                ]
            else:
                props['DestinationCidr'] = self.destination_cidr

        if self.attachment_id is not None:
            if hasattr(self.attachment_id, 'to_dict'):
                props['AttachmentId'] = self.attachment_id.to_dict()
            elif isinstance(self.attachment_id, list):
                props['AttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attachment_id
                ]
            else:
                props['AttachmentId'] = self.attachment_id

        return props


@dataclass
class NetworkInsightsAnalysis(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkInsightsAnalysis"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    filter_out_arns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_insights_path_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    filter_in_arns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    additional_accounts: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.filter_out_arns is not None:
            # Serialize filter_out_arns (handle intrinsic functions)
            if hasattr(self.filter_out_arns, 'to_dict'):
                props["FilterOutArns"] = self.filter_out_arns.to_dict()
            elif isinstance(self.filter_out_arns, list):
                # Serialize list items (may contain intrinsic functions)
                props['FilterOutArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter_out_arns
                ]
            else:
                props["FilterOutArns"] = self.filter_out_arns

        if self.network_insights_path_id is not None:
            # Serialize network_insights_path_id (handle intrinsic functions)
            if hasattr(self.network_insights_path_id, 'to_dict'):
                props["NetworkInsightsPathId"] = self.network_insights_path_id.to_dict()
            elif isinstance(self.network_insights_path_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInsightsPathId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_insights_path_id
                ]
            else:
                props["NetworkInsightsPathId"] = self.network_insights_path_id

        if self.filter_in_arns is not None:
            # Serialize filter_in_arns (handle intrinsic functions)
            if hasattr(self.filter_in_arns, 'to_dict'):
                props["FilterInArns"] = self.filter_in_arns.to_dict()
            elif isinstance(self.filter_in_arns, list):
                # Serialize list items (may contain intrinsic functions)
                props['FilterInArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter_in_arns
                ]
            else:
                props["FilterInArns"] = self.filter_in_arns

        if self.additional_accounts is not None:
            # Serialize additional_accounts (handle intrinsic functions)
            if hasattr(self.additional_accounts, 'to_dict'):
                props["AdditionalAccounts"] = self.additional_accounts.to_dict()
            elif isinstance(self.additional_accounts, list):
                # Serialize list items (may contain intrinsic functions)
                props['AdditionalAccounts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_accounts
                ]
            else:
                props["AdditionalAccounts"] = self.additional_accounts

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_return_path_components(self) -> GetAtt:
        """Get the ReturnPathComponents attribute."""
        return self.get_att("ReturnPathComponents")

    @property
    def attr_start_date(self) -> GetAtt:
        """Get the StartDate attribute."""
        return self.get_att("StartDate")

    @property
    def attr_network_insights_analysis_id(self) -> GetAtt:
        """Get the NetworkInsightsAnalysisId attribute."""
        return self.get_att("NetworkInsightsAnalysisId")

    @property
    def attr_alternate_path_hints(self) -> GetAtt:
        """Get the AlternatePathHints attribute."""
        return self.get_att("AlternatePathHints")

    @property
    def attr_explanations(self) -> GetAtt:
        """Get the Explanations attribute."""
        return self.get_att("Explanations")

    @property
    def attr_network_path_found(self) -> GetAtt:
        """Get the NetworkPathFound attribute."""
        return self.get_att("NetworkPathFound")

    @property
    def attr_suggested_accounts(self) -> GetAtt:
        """Get the SuggestedAccounts attribute."""
        return self.get_att("SuggestedAccounts")

    @property
    def attr_forward_path_components(self) -> GetAtt:
        """Get the ForwardPathComponents attribute."""
        return self.get_att("ForwardPathComponents")

    @property
    def attr_network_insights_analysis_arn(self) -> GetAtt:
        """Get the NetworkInsightsAnalysisArn attribute."""
        return self.get_att("NetworkInsightsAnalysisArn")

    @property
    def attr_status_message(self) -> GetAtt:
        """Get the StatusMessage attribute."""
        return self.get_att("StatusMessage")




@dataclass
class FilterPortRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.from_port is not None:
            if hasattr(self.from_port, 'to_dict'):
                props['FromPort'] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props['FromPort'] = self.from_port

        if self.to_port is not None:
            if hasattr(self.to_port, 'to_dict'):
                props['ToPort'] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props['ToPort'] = self.to_port

        return props


@dataclass
class PathFilter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_port_range: Optional[FilterPortRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_port_range: Optional[FilterPortRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_address: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.source_address is not None:
            if hasattr(self.source_address, 'to_dict'):
                props['SourceAddress'] = self.source_address.to_dict()
            elif isinstance(self.source_address, list):
                props['SourceAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_address
                ]
            else:
                props['SourceAddress'] = self.source_address

        if self.destination_port_range is not None:
            if hasattr(self.destination_port_range, 'to_dict'):
                props['DestinationPortRange'] = self.destination_port_range.to_dict()
            elif isinstance(self.destination_port_range, list):
                props['DestinationPortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_port_range
                ]
            else:
                props['DestinationPortRange'] = self.destination_port_range

        if self.source_port_range is not None:
            if hasattr(self.source_port_range, 'to_dict'):
                props['SourcePortRange'] = self.source_port_range.to_dict()
            elif isinstance(self.source_port_range, list):
                props['SourcePortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_port_range
                ]
            else:
                props['SourcePortRange'] = self.source_port_range

        if self.destination_address is not None:
            if hasattr(self.destination_address, 'to_dict'):
                props['DestinationAddress'] = self.destination_address.to_dict()
            elif isinstance(self.destination_address, list):
                props['DestinationAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_address
                ]
            else:
                props['DestinationAddress'] = self.destination_address

        return props


@dataclass
class NetworkInsightsPath(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkInsightsPath"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_ip: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_ip: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    filter_at_destination: Optional[PathFilter] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    filter_at_source: Optional[PathFilter] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    protocol: Optional[Union[str, Protocol, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination is not None:
            # Serialize destination (handle intrinsic functions)
            if hasattr(self.destination, 'to_dict'):
                props["Destination"] = self.destination.to_dict()
            elif isinstance(self.destination, list):
                # Serialize list items (may contain intrinsic functions)
                props['Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination
                ]
            else:
                props["Destination"] = self.destination

        if self.destination_ip is not None:
            # Serialize destination_ip (handle intrinsic functions)
            if hasattr(self.destination_ip, 'to_dict'):
                props["DestinationIp"] = self.destination_ip.to_dict()
            elif isinstance(self.destination_ip, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationIp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_ip
                ]
            else:
                props["DestinationIp"] = self.destination_ip

        if self.source_ip is not None:
            # Serialize source_ip (handle intrinsic functions)
            if hasattr(self.source_ip, 'to_dict'):
                props["SourceIp"] = self.source_ip.to_dict()
            elif isinstance(self.source_ip, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceIp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_ip
                ]
            else:
                props["SourceIp"] = self.source_ip

        if self.filter_at_destination is not None:
            # Serialize filter_at_destination (handle intrinsic functions)
            if hasattr(self.filter_at_destination, 'to_dict'):
                props["FilterAtDestination"] = self.filter_at_destination.to_dict()
            elif isinstance(self.filter_at_destination, list):
                # Serialize list items (may contain intrinsic functions)
                props['FilterAtDestination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter_at_destination
                ]
            else:
                props["FilterAtDestination"] = self.filter_at_destination

        if self.filter_at_source is not None:
            # Serialize filter_at_source (handle intrinsic functions)
            if hasattr(self.filter_at_source, 'to_dict'):
                props["FilterAtSource"] = self.filter_at_source.to_dict()
            elif isinstance(self.filter_at_source, list):
                # Serialize list items (may contain intrinsic functions)
                props['FilterAtSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter_at_source
                ]
            else:
                props["FilterAtSource"] = self.filter_at_source

        if self.protocol is not None:
            # Serialize protocol (handle intrinsic functions)
            if hasattr(self.protocol, 'to_dict'):
                props["Protocol"] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                # Serialize list items (may contain intrinsic functions)
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props["Protocol"] = self.protocol

        if self.destination_port is not None:
            # Serialize destination_port (handle intrinsic functions)
            if hasattr(self.destination_port, 'to_dict'):
                props["DestinationPort"] = self.destination_port.to_dict()
            elif isinstance(self.destination_port, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_port
                ]
            else:
                props["DestinationPort"] = self.destination_port

        if self.source is not None:
            # Serialize source (handle intrinsic functions)
            if hasattr(self.source, 'to_dict'):
                props["Source"] = self.source.to_dict()
            elif isinstance(self.source, list):
                # Serialize list items (may contain intrinsic functions)
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props["Source"] = self.source

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_source_arn(self) -> GetAtt:
        """Get the SourceArn attribute."""
        return self.get_att("SourceArn")

    @property
    def attr_network_insights_path_id(self) -> GetAtt:
        """Get the NetworkInsightsPathId attribute."""
        return self.get_att("NetworkInsightsPathId")

    @property
    def attr_created_date(self) -> GetAtt:
        """Get the CreatedDate attribute."""
        return self.get_att("CreatedDate")

    @property
    def attr_network_insights_path_arn(self) -> GetAtt:
        """Get the NetworkInsightsPathArn attribute."""
        return self.get_att("NetworkInsightsPathArn")

    @property
    def attr_destination_arn(self) -> GetAtt:
        """Get the DestinationArn attribute."""
        return self.get_att("DestinationArn")




@dataclass
class ConnectionTrackingSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    udp_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tcp_established_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    udp_stream_timeout: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.udp_timeout is not None:
            if hasattr(self.udp_timeout, 'to_dict'):
                props['UdpTimeout'] = self.udp_timeout.to_dict()
            elif isinstance(self.udp_timeout, list):
                props['UdpTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.udp_timeout
                ]
            else:
                props['UdpTimeout'] = self.udp_timeout

        if self.tcp_established_timeout is not None:
            if hasattr(self.tcp_established_timeout, 'to_dict'):
                props['TcpEstablishedTimeout'] = self.tcp_established_timeout.to_dict()
            elif isinstance(self.tcp_established_timeout, list):
                props['TcpEstablishedTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tcp_established_timeout
                ]
            else:
                props['TcpEstablishedTimeout'] = self.tcp_established_timeout

        if self.udp_stream_timeout is not None:
            if hasattr(self.udp_stream_timeout, 'to_dict'):
                props['UdpStreamTimeout'] = self.udp_stream_timeout.to_dict()
            elif isinstance(self.udp_stream_timeout, list):
                props['UdpStreamTimeout'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.udp_stream_timeout
                ]
            else:
                props['UdpStreamTimeout'] = self.udp_stream_timeout

        return props


@dataclass
class InstanceIpv6Address:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_address: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_address is not None:
            if hasattr(self.ipv6_address, 'to_dict'):
                props['Ipv6Address'] = self.ipv6_address.to_dict()
            elif isinstance(self.ipv6_address, list):
                props['Ipv6Address'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address
                ]
            else:
                props['Ipv6Address'] = self.ipv6_address

        return props


@dataclass
class Ipv4PrefixSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv4_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv4_prefix is not None:
            if hasattr(self.ipv4_prefix, 'to_dict'):
                props['Ipv4Prefix'] = self.ipv4_prefix.to_dict()
            elif isinstance(self.ipv4_prefix, list):
                props['Ipv4Prefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_prefix
                ]
            else:
                props['Ipv4Prefix'] = self.ipv4_prefix

        return props


@dataclass
class Ipv6PrefixSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_prefix is not None:
            if hasattr(self.ipv6_prefix, 'to_dict'):
                props['Ipv6Prefix'] = self.ipv6_prefix.to_dict()
            elif isinstance(self.ipv6_prefix, list):
                props['Ipv6Prefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_prefix
                ]
            else:
                props['Ipv6Prefix'] = self.ipv6_prefix

        return props


@dataclass
class PrivateIpAddressSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    primary: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.private_ip_address is not None:
            if hasattr(self.private_ip_address, 'to_dict'):
                props['PrivateIpAddress'] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props['PrivateIpAddress'] = self.private_ip_address

        if self.primary is not None:
            if hasattr(self.primary, 'to_dict'):
                props['Primary'] = self.primary.to_dict()
            elif isinstance(self.primary, list):
                props['Primary'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.primary
                ]
            else:
                props['Primary'] = self.primary

        return props


@dataclass
class PublicIpDnsNameOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dns_hostname_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    public_ipv4_dns_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    public_dual_stack_dns_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    public_ipv6_dns_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.dns_hostname_type is not None:
            if hasattr(self.dns_hostname_type, 'to_dict'):
                props['DnsHostnameType'] = self.dns_hostname_type.to_dict()
            elif isinstance(self.dns_hostname_type, list):
                props['DnsHostnameType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dns_hostname_type
                ]
            else:
                props['DnsHostnameType'] = self.dns_hostname_type

        if self.public_ipv4_dns_name is not None:
            if hasattr(self.public_ipv4_dns_name, 'to_dict'):
                props['PublicIpv4DnsName'] = self.public_ipv4_dns_name.to_dict()
            elif isinstance(self.public_ipv4_dns_name, list):
                props['PublicIpv4DnsName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_ipv4_dns_name
                ]
            else:
                props['PublicIpv4DnsName'] = self.public_ipv4_dns_name

        if self.public_dual_stack_dns_name is not None:
            if hasattr(self.public_dual_stack_dns_name, 'to_dict'):
                props['PublicDualStackDnsName'] = self.public_dual_stack_dns_name.to_dict()
            elif isinstance(self.public_dual_stack_dns_name, list):
                props['PublicDualStackDnsName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_dual_stack_dns_name
                ]
            else:
                props['PublicDualStackDnsName'] = self.public_dual_stack_dns_name

        if self.public_ipv6_dns_name is not None:
            if hasattr(self.public_ipv6_dns_name, 'to_dict'):
                props['PublicIpv6DnsName'] = self.public_ipv6_dns_name.to_dict()
            elif isinstance(self.public_ipv6_dns_name, list):
                props['PublicIpv6DnsName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_ipv6_dns_name
                ]
            else:
                props['PublicIpv6DnsName'] = self.public_ipv6_dns_name

        return props


@dataclass
class NetworkInterface(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkInterface"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_ip_addresses: Optional[list[PrivateIpAddressSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    secondary_private_ip_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    public_ip_dns_hostname_type_specification: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_prefix_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv4_prefixes: Optional[list[Ipv4PrefixSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv4_prefix_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_set: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_addresses: Optional[list[InstanceIpv6Address]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_prefixes: Optional[list[Ipv6PrefixSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_dest_check: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    interface_type: Optional[Union[str, NetworkInterfaceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connection_tracking_specification: Optional[ConnectionTrackingSpecification] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.private_ip_address is not None:
            # Serialize private_ip_address (handle intrinsic functions)
            if hasattr(self.private_ip_address, 'to_dict'):
                props["PrivateIpAddress"] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props["PrivateIpAddress"] = self.private_ip_address

        if self.private_ip_addresses is not None:
            # Serialize private_ip_addresses (handle intrinsic functions)
            if hasattr(self.private_ip_addresses, 'to_dict'):
                props["PrivateIpAddresses"] = self.private_ip_addresses.to_dict()
            elif isinstance(self.private_ip_addresses, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateIpAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_addresses
                ]
            else:
                props["PrivateIpAddresses"] = self.private_ip_addresses

        if self.secondary_private_ip_address_count is not None:
            # Serialize secondary_private_ip_address_count (handle intrinsic functions)
            if hasattr(self.secondary_private_ip_address_count, 'to_dict'):
                props["SecondaryPrivateIpAddressCount"] = self.secondary_private_ip_address_count.to_dict()
            elif isinstance(self.secondary_private_ip_address_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecondaryPrivateIpAddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_private_ip_address_count
                ]
            else:
                props["SecondaryPrivateIpAddressCount"] = self.secondary_private_ip_address_count

        if self.public_ip_dns_hostname_type_specification is not None:
            # Serialize public_ip_dns_hostname_type_specification (handle intrinsic functions)
            if hasattr(self.public_ip_dns_hostname_type_specification, 'to_dict'):
                props["PublicIpDnsHostnameTypeSpecification"] = self.public_ip_dns_hostname_type_specification.to_dict()
            elif isinstance(self.public_ip_dns_hostname_type_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['PublicIpDnsHostnameTypeSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_ip_dns_hostname_type_specification
                ]
            else:
                props["PublicIpDnsHostnameTypeSpecification"] = self.public_ip_dns_hostname_type_specification

        if self.ipv6_prefix_count is not None:
            # Serialize ipv6_prefix_count (handle intrinsic functions)
            if hasattr(self.ipv6_prefix_count, 'to_dict'):
                props["Ipv6PrefixCount"] = self.ipv6_prefix_count.to_dict()
            elif isinstance(self.ipv6_prefix_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6PrefixCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_prefix_count
                ]
            else:
                props["Ipv6PrefixCount"] = self.ipv6_prefix_count

        if self.ipv4_prefixes is not None:
            # Serialize ipv4_prefixes (handle intrinsic functions)
            if hasattr(self.ipv4_prefixes, 'to_dict'):
                props["Ipv4Prefixes"] = self.ipv4_prefixes.to_dict()
            elif isinstance(self.ipv4_prefixes, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv4Prefixes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_prefixes
                ]
            else:
                props["Ipv4Prefixes"] = self.ipv4_prefixes

        if self.ipv4_prefix_count is not None:
            # Serialize ipv4_prefix_count (handle intrinsic functions)
            if hasattr(self.ipv4_prefix_count, 'to_dict'):
                props["Ipv4PrefixCount"] = self.ipv4_prefix_count.to_dict()
            elif isinstance(self.ipv4_prefix_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv4PrefixCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_prefix_count
                ]
            else:
                props["Ipv4PrefixCount"] = self.ipv4_prefix_count

        if self.group_set is not None:
            # Serialize group_set (handle intrinsic functions)
            if hasattr(self.group_set, 'to_dict'):
                props["GroupSet"] = self.group_set.to_dict()
            elif isinstance(self.group_set, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupSet'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_set
                ]
            else:
                props["GroupSet"] = self.group_set

        if self.ipv6_addresses is not None:
            # Serialize ipv6_addresses (handle intrinsic functions)
            if hasattr(self.ipv6_addresses, 'to_dict'):
                props["Ipv6Addresses"] = self.ipv6_addresses.to_dict()
            elif isinstance(self.ipv6_addresses, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6Addresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_addresses
                ]
            else:
                props["Ipv6Addresses"] = self.ipv6_addresses

        if self.ipv6_prefixes is not None:
            # Serialize ipv6_prefixes (handle intrinsic functions)
            if hasattr(self.ipv6_prefixes, 'to_dict'):
                props["Ipv6Prefixes"] = self.ipv6_prefixes.to_dict()
            elif isinstance(self.ipv6_prefixes, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6Prefixes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_prefixes
                ]
            else:
                props["Ipv6Prefixes"] = self.ipv6_prefixes

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        if self.source_dest_check is not None:
            # Serialize source_dest_check (handle intrinsic functions)
            if hasattr(self.source_dest_check, 'to_dict'):
                props["SourceDestCheck"] = self.source_dest_check.to_dict()
            elif isinstance(self.source_dest_check, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceDestCheck'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_dest_check
                ]
            else:
                props["SourceDestCheck"] = self.source_dest_check

        if self.interface_type is not None:
            # Serialize interface_type (handle intrinsic functions)
            if hasattr(self.interface_type, 'to_dict'):
                props["InterfaceType"] = self.interface_type.to_dict()
            elif isinstance(self.interface_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['InterfaceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.interface_type
                ]
            else:
                props["InterfaceType"] = self.interface_type

        if self.ipv6_address_count is not None:
            # Serialize ipv6_address_count (handle intrinsic functions)
            if hasattr(self.ipv6_address_count, 'to_dict'):
                props["Ipv6AddressCount"] = self.ipv6_address_count.to_dict()
            elif isinstance(self.ipv6_address_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6AddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address_count
                ]
            else:
                props["Ipv6AddressCount"] = self.ipv6_address_count

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.connection_tracking_specification is not None:
            # Serialize connection_tracking_specification (handle intrinsic functions)
            if hasattr(self.connection_tracking_specification, 'to_dict'):
                props["ConnectionTrackingSpecification"] = self.connection_tracking_specification.to_dict()
            elif isinstance(self.connection_tracking_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConnectionTrackingSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connection_tracking_specification
                ]
            else:
                props["ConnectionTrackingSpecification"] = self.connection_tracking_specification

        return props

    @property
    def attr_public_ip_dns_name_options__public_ipv6_dns_name(self) -> GetAtt:
        """Get the PublicIpDnsNameOptions.PublicIpv6DnsName attribute."""
        return self.get_att("PublicIpDnsNameOptions.PublicIpv6DnsName")

    @property
    def attr_primary_ipv6_address(self) -> GetAtt:
        """Get the PrimaryIpv6Address attribute."""
        return self.get_att("PrimaryIpv6Address")

    @property
    def attr_secondary_private_ip_addresses(self) -> GetAtt:
        """Get the SecondaryPrivateIpAddresses attribute."""
        return self.get_att("SecondaryPrivateIpAddresses")

    @property
    def attr_vpc_id(self) -> GetAtt:
        """Get the VpcId attribute."""
        return self.get_att("VpcId")

    @property
    def attr_primary_private_ip_address(self) -> GetAtt:
        """Get the PrimaryPrivateIpAddress attribute."""
        return self.get_att("PrimaryPrivateIpAddress")

    @property
    def attr_public_ip_dns_name_options__dns_hostname_type(self) -> GetAtt:
        """Get the PublicIpDnsNameOptions.DnsHostnameType attribute."""
        return self.get_att("PublicIpDnsNameOptions.DnsHostnameType")

    @property
    def attr_public_ip_dns_name_options__public_dual_stack_dns_name(self) -> GetAtt:
        """Get the PublicIpDnsNameOptions.PublicDualStackDnsName attribute."""
        return self.get_att("PublicIpDnsNameOptions.PublicDualStackDnsName")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")

    @property
    def attr_public_ip_dns_name_options(self) -> GetAtt:
        """Get the PublicIpDnsNameOptions attribute."""
        return self.get_att("PublicIpDnsNameOptions")

    @property
    def attr_public_ip_dns_name_options__public_ipv4_dns_name(self) -> GetAtt:
        """Get the PublicIpDnsNameOptions.PublicIpv4DnsName attribute."""
        return self.get_att("PublicIpDnsNameOptions.PublicIpv4DnsName")




@dataclass
class EnaSrdSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_udp_specification: Optional[EnaSrdUdpSpecification] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ena_srd_enabled is not None:
            if hasattr(self.ena_srd_enabled, 'to_dict'):
                props['EnaSrdEnabled'] = self.ena_srd_enabled.to_dict()
            elif isinstance(self.ena_srd_enabled, list):
                props['EnaSrdEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_enabled
                ]
            else:
                props['EnaSrdEnabled'] = self.ena_srd_enabled

        if self.ena_srd_udp_specification is not None:
            if hasattr(self.ena_srd_udp_specification, 'to_dict'):
                props['EnaSrdUdpSpecification'] = self.ena_srd_udp_specification.to_dict()
            elif isinstance(self.ena_srd_udp_specification, list):
                props['EnaSrdUdpSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_udp_specification
                ]
            else:
                props['EnaSrdUdpSpecification'] = self.ena_srd_udp_specification

        return props


@dataclass
class EnaSrdUdpSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ena_srd_udp_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ena_srd_udp_enabled is not None:
            if hasattr(self.ena_srd_udp_enabled, 'to_dict'):
                props['EnaSrdUdpEnabled'] = self.ena_srd_udp_enabled.to_dict()
            elif isinstance(self.ena_srd_udp_enabled, list):
                props['EnaSrdUdpEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_udp_enabled
                ]
            else:
                props['EnaSrdUdpEnabled'] = self.ena_srd_udp_enabled

        return props


@dataclass
class NetworkInterfaceAttachment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkInterfaceAttachment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ena_srd_specification: Optional[EnaSrdSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    device_index: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ena_queue_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ena_srd_specification is not None:
            # Serialize ena_srd_specification (handle intrinsic functions)
            if hasattr(self.ena_srd_specification, 'to_dict'):
                props["EnaSrdSpecification"] = self.ena_srd_specification.to_dict()
            elif isinstance(self.ena_srd_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnaSrdSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_srd_specification
                ]
            else:
                props["EnaSrdSpecification"] = self.ena_srd_specification

        if self.instance_id is not None:
            # Serialize instance_id (handle intrinsic functions)
            if hasattr(self.instance_id, 'to_dict'):
                props["InstanceId"] = self.instance_id.to_dict()
            elif isinstance(self.instance_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_id
                ]
            else:
                props["InstanceId"] = self.instance_id

        if self.device_index is not None:
            # Serialize device_index (handle intrinsic functions)
            if hasattr(self.device_index, 'to_dict'):
                props["DeviceIndex"] = self.device_index.to_dict()
            elif isinstance(self.device_index, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeviceIndex'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_index
                ]
            else:
                props["DeviceIndex"] = self.device_index

        if self.ena_queue_count is not None:
            # Serialize ena_queue_count (handle intrinsic functions)
            if hasattr(self.ena_queue_count, 'to_dict'):
                props["EnaQueueCount"] = self.ena_queue_count.to_dict()
            elif isinstance(self.ena_queue_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnaQueueCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ena_queue_count
                ]
            else:
                props["EnaQueueCount"] = self.ena_queue_count

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        if self.delete_on_termination is not None:
            # Serialize delete_on_termination (handle intrinsic functions)
            if hasattr(self.delete_on_termination, 'to_dict'):
                props["DeleteOnTermination"] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props["DeleteOnTermination"] = self.delete_on_termination

        return props

    @property
    def attr_attachment_id(self) -> GetAtt:
        """Get the AttachmentId attribute."""
        return self.get_att("AttachmentId")




@dataclass
class NetworkInterfacePermission(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkInterfacePermission"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    aws_account_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    permission: Optional[Union[str, InterfacePermissionType, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.aws_account_id is not None:
            # Serialize aws_account_id (handle intrinsic functions)
            if hasattr(self.aws_account_id, 'to_dict'):
                props["AwsAccountId"] = self.aws_account_id.to_dict()
            elif isinstance(self.aws_account_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AwsAccountId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.aws_account_id
                ]
            else:
                props["AwsAccountId"] = self.aws_account_id

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        if self.permission is not None:
            # Serialize permission (handle intrinsic functions)
            if hasattr(self.permission, 'to_dict'):
                props["Permission"] = self.permission.to_dict()
            elif isinstance(self.permission, list):
                # Serialize list items (may contain intrinsic functions)
                props['Permission'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.permission
                ]
            else:
                props["Permission"] = self.permission

        return props



@dataclass
class NetworkPerformanceMetricSubscription(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-n"""

    resource_type: ClassVar[str] = "AWS::EC2::NetworkPerformanceMetricSubscription"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    statistic: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metric: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination is not None:
            # Serialize destination (handle intrinsic functions)
            if hasattr(self.destination, 'to_dict'):
                props["Destination"] = self.destination.to_dict()
            elif isinstance(self.destination, list):
                # Serialize list items (may contain intrinsic functions)
                props['Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination
                ]
            else:
                props["Destination"] = self.destination

        if self.statistic is not None:
            # Serialize statistic (handle intrinsic functions)
            if hasattr(self.statistic, 'to_dict'):
                props["Statistic"] = self.statistic.to_dict()
            elif isinstance(self.statistic, list):
                # Serialize list items (may contain intrinsic functions)
                props['Statistic'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.statistic
                ]
            else:
                props["Statistic"] = self.statistic

        if self.metric is not None:
            # Serialize metric (handle intrinsic functions)
            if hasattr(self.metric, 'to_dict'):
                props["Metric"] = self.metric.to_dict()
            elif isinstance(self.metric, list):
                # Serialize list items (may contain intrinsic functions)
                props['Metric'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric
                ]
            else:
                props["Metric"] = self.metric

        if self.source is not None:
            # Serialize source (handle intrinsic functions)
            if hasattr(self.source, 'to_dict'):
                props["Source"] = self.source.to_dict()
            elif isinstance(self.source, list):
                # Serialize list items (may contain intrinsic functions)
                props['Source'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source
                ]
            else:
                props["Source"] = self.source

        return props



@dataclass
class PlacementGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-p"""

    resource_type: ClassVar[str] = "AWS::EC2::PlacementGroup"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    spread_level: Optional[Union[str, SpreadLevel, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    strategy: Optional[Union[str, PlacementStrategy, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    partition_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.spread_level is not None:
            # Serialize spread_level (handle intrinsic functions)
            if hasattr(self.spread_level, 'to_dict'):
                props["SpreadLevel"] = self.spread_level.to_dict()
            elif isinstance(self.spread_level, list):
                # Serialize list items (may contain intrinsic functions)
                props['SpreadLevel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spread_level
                ]
            else:
                props["SpreadLevel"] = self.spread_level

        if self.strategy is not None:
            # Serialize strategy (handle intrinsic functions)
            if hasattr(self.strategy, 'to_dict'):
                props["Strategy"] = self.strategy.to_dict()
            elif isinstance(self.strategy, list):
                # Serialize list items (may contain intrinsic functions)
                props['Strategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.strategy
                ]
            else:
                props["Strategy"] = self.strategy

        if self.partition_count is not None:
            # Serialize partition_count (handle intrinsic functions)
            if hasattr(self.partition_count, 'to_dict'):
                props["PartitionCount"] = self.partition_count.to_dict()
            elif isinstance(self.partition_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['PartitionCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.partition_count
                ]
            else:
                props["PartitionCount"] = self.partition_count

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_group_name(self) -> GetAtt:
        """Get the GroupName attribute."""
        return self.get_att("GroupName")




@dataclass
class Entry:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.cidr is not None:
            if hasattr(self.cidr, 'to_dict'):
                props['Cidr'] = self.cidr.to_dict()
            elif isinstance(self.cidr, list):
                props['Cidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr
                ]
            else:
                props['Cidr'] = self.cidr

        return props


@dataclass
class PrefixList(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-p"""

    resource_type: ClassVar[str] = "AWS::EC2::PrefixList"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_entries: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    prefix_list_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    entries: Optional[list[Entry]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    address_family: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_entries is not None:
            # Serialize max_entries (handle intrinsic functions)
            if hasattr(self.max_entries, 'to_dict'):
                props["MaxEntries"] = self.max_entries.to_dict()
            elif isinstance(self.max_entries, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxEntries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_entries
                ]
            else:
                props["MaxEntries"] = self.max_entries

        if self.prefix_list_name is not None:
            # Serialize prefix_list_name (handle intrinsic functions)
            if hasattr(self.prefix_list_name, 'to_dict'):
                props["PrefixListName"] = self.prefix_list_name.to_dict()
            elif isinstance(self.prefix_list_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrefixListName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.prefix_list_name
                ]
            else:
                props["PrefixListName"] = self.prefix_list_name

        if self.entries is not None:
            # Serialize entries (handle intrinsic functions)
            if hasattr(self.entries, 'to_dict'):
                props["Entries"] = self.entries.to_dict()
            elif isinstance(self.entries, list):
                # Serialize list items (may contain intrinsic functions)
                props['Entries'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.entries
                ]
            else:
                props["Entries"] = self.entries

        if self.address_family is not None:
            # Serialize address_family (handle intrinsic functions)
            if hasattr(self.address_family, 'to_dict'):
                props["AddressFamily"] = self.address_family.to_dict()
            elif isinstance(self.address_family, list):
                # Serialize list items (may contain intrinsic functions)
                props['AddressFamily'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.address_family
                ]
            else:
                props["AddressFamily"] = self.address_family

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_owner_id(self) -> GetAtt:
        """Get the OwnerId attribute."""
        return self.get_att("OwnerId")

    @property
    def attr_prefix_list_id(self) -> GetAtt:
        """Get the PrefixListId attribute."""
        return self.get_att("PrefixListId")

    @property
    def attr_version(self) -> GetAtt:
        """Get the Version attribute."""
        return self.get_att("Version")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class Route(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-r"""

    resource_type: ClassVar[str] = "AWS::EC2::Route"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_ipv6_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    carrier_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_endpoint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    core_network_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_peering_connection_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    egress_only_internet_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_prefix_list_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    nat_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination_ipv6_cidr_block is not None:
            # Serialize destination_ipv6_cidr_block (handle intrinsic functions)
            if hasattr(self.destination_ipv6_cidr_block, 'to_dict'):
                props["DestinationIpv6CidrBlock"] = self.destination_ipv6_cidr_block.to_dict()
            elif isinstance(self.destination_ipv6_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationIpv6CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_ipv6_cidr_block
                ]
            else:
                props["DestinationIpv6CidrBlock"] = self.destination_ipv6_cidr_block

        if self.route_table_id is not None:
            # Serialize route_table_id (handle intrinsic functions)
            if hasattr(self.route_table_id, 'to_dict'):
                props["RouteTableId"] = self.route_table_id.to_dict()
            elif isinstance(self.route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_id
                ]
            else:
                props["RouteTableId"] = self.route_table_id

        if self.instance_id is not None:
            # Serialize instance_id (handle intrinsic functions)
            if hasattr(self.instance_id, 'to_dict'):
                props["InstanceId"] = self.instance_id.to_dict()
            elif isinstance(self.instance_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_id
                ]
            else:
                props["InstanceId"] = self.instance_id

        if self.local_gateway_id is not None:
            # Serialize local_gateway_id (handle intrinsic functions)
            if hasattr(self.local_gateway_id, 'to_dict'):
                props["LocalGatewayId"] = self.local_gateway_id.to_dict()
            elif isinstance(self.local_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_gateway_id
                ]
            else:
                props["LocalGatewayId"] = self.local_gateway_id

        if self.carrier_gateway_id is not None:
            # Serialize carrier_gateway_id (handle intrinsic functions)
            if hasattr(self.carrier_gateway_id, 'to_dict'):
                props["CarrierGatewayId"] = self.carrier_gateway_id.to_dict()
            elif isinstance(self.carrier_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['CarrierGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.carrier_gateway_id
                ]
            else:
                props["CarrierGatewayId"] = self.carrier_gateway_id

        if self.destination_cidr_block is not None:
            # Serialize destination_cidr_block (handle intrinsic functions)
            if hasattr(self.destination_cidr_block, 'to_dict'):
                props["DestinationCidrBlock"] = self.destination_cidr_block.to_dict()
            elif isinstance(self.destination_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr_block
                ]
            else:
                props["DestinationCidrBlock"] = self.destination_cidr_block

        if self.gateway_id is not None:
            # Serialize gateway_id (handle intrinsic functions)
            if hasattr(self.gateway_id, 'to_dict'):
                props["GatewayId"] = self.gateway_id.to_dict()
            elif isinstance(self.gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['GatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gateway_id
                ]
            else:
                props["GatewayId"] = self.gateway_id

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        if self.vpc_endpoint_id is not None:
            # Serialize vpc_endpoint_id (handle intrinsic functions)
            if hasattr(self.vpc_endpoint_id, 'to_dict'):
                props["VpcEndpointId"] = self.vpc_endpoint_id.to_dict()
            elif isinstance(self.vpc_endpoint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcEndpointId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_endpoint_id
                ]
            else:
                props["VpcEndpointId"] = self.vpc_endpoint_id

        if self.core_network_arn is not None:
            # Serialize core_network_arn (handle intrinsic functions)
            if hasattr(self.core_network_arn, 'to_dict'):
                props["CoreNetworkArn"] = self.core_network_arn.to_dict()
            elif isinstance(self.core_network_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['CoreNetworkArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.core_network_arn
                ]
            else:
                props["CoreNetworkArn"] = self.core_network_arn

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        if self.vpc_peering_connection_id is not None:
            # Serialize vpc_peering_connection_id (handle intrinsic functions)
            if hasattr(self.vpc_peering_connection_id, 'to_dict'):
                props["VpcPeeringConnectionId"] = self.vpc_peering_connection_id.to_dict()
            elif isinstance(self.vpc_peering_connection_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcPeeringConnectionId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_peering_connection_id
                ]
            else:
                props["VpcPeeringConnectionId"] = self.vpc_peering_connection_id

        if self.egress_only_internet_gateway_id is not None:
            # Serialize egress_only_internet_gateway_id (handle intrinsic functions)
            if hasattr(self.egress_only_internet_gateway_id, 'to_dict'):
                props["EgressOnlyInternetGatewayId"] = self.egress_only_internet_gateway_id.to_dict()
            elif isinstance(self.egress_only_internet_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['EgressOnlyInternetGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.egress_only_internet_gateway_id
                ]
            else:
                props["EgressOnlyInternetGatewayId"] = self.egress_only_internet_gateway_id

        if self.destination_prefix_list_id is not None:
            # Serialize destination_prefix_list_id (handle intrinsic functions)
            if hasattr(self.destination_prefix_list_id, 'to_dict'):
                props["DestinationPrefixListId"] = self.destination_prefix_list_id.to_dict()
            elif isinstance(self.destination_prefix_list_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationPrefixListId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_prefix_list_id
                ]
            else:
                props["DestinationPrefixListId"] = self.destination_prefix_list_id

        if self.nat_gateway_id is not None:
            # Serialize nat_gateway_id (handle intrinsic functions)
            if hasattr(self.nat_gateway_id, 'to_dict'):
                props["NatGatewayId"] = self.nat_gateway_id.to_dict()
            elif isinstance(self.nat_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NatGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.nat_gateway_id
                ]
            else:
                props["NatGatewayId"] = self.nat_gateway_id

        return props

    @property
    def attr_cidr_block(self) -> GetAtt:
        """Get the CidrBlock attribute."""
        return self.get_att("CidrBlock")




@dataclass
class RouteServer(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-r"""

    resource_type: ClassVar[str] = "AWS::EC2::RouteServer"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    persist_routes: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sns_notifications_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    persist_routes_duration: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    amazon_side_asn: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.persist_routes is not None:
            # Serialize persist_routes (handle intrinsic functions)
            if hasattr(self.persist_routes, 'to_dict'):
                props["PersistRoutes"] = self.persist_routes.to_dict()
            elif isinstance(self.persist_routes, list):
                # Serialize list items (may contain intrinsic functions)
                props['PersistRoutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.persist_routes
                ]
            else:
                props["PersistRoutes"] = self.persist_routes

        if self.sns_notifications_enabled is not None:
            # Serialize sns_notifications_enabled (handle intrinsic functions)
            if hasattr(self.sns_notifications_enabled, 'to_dict'):
                props["SnsNotificationsEnabled"] = self.sns_notifications_enabled.to_dict()
            elif isinstance(self.sns_notifications_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['SnsNotificationsEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sns_notifications_enabled
                ]
            else:
                props["SnsNotificationsEnabled"] = self.sns_notifications_enabled

        if self.persist_routes_duration is not None:
            # Serialize persist_routes_duration (handle intrinsic functions)
            if hasattr(self.persist_routes_duration, 'to_dict'):
                props["PersistRoutesDuration"] = self.persist_routes_duration.to_dict()
            elif isinstance(self.persist_routes_duration, list):
                # Serialize list items (may contain intrinsic functions)
                props['PersistRoutesDuration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.persist_routes_duration
                ]
            else:
                props["PersistRoutesDuration"] = self.persist_routes_duration

        if self.amazon_side_asn is not None:
            # Serialize amazon_side_asn (handle intrinsic functions)
            if hasattr(self.amazon_side_asn, 'to_dict'):
                props["AmazonSideAsn"] = self.amazon_side_asn.to_dict()
            elif isinstance(self.amazon_side_asn, list):
                # Serialize list items (may contain intrinsic functions)
                props['AmazonSideAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.amazon_side_asn
                ]
            else:
                props["AmazonSideAsn"] = self.amazon_side_asn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class RouteServerAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-r"""

    resource_type: ClassVar[str] = "AWS::EC2::RouteServerAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_server_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.route_server_id is not None:
            # Serialize route_server_id (handle intrinsic functions)
            if hasattr(self.route_server_id, 'to_dict'):
                props["RouteServerId"] = self.route_server_id.to_dict()
            elif isinstance(self.route_server_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteServerId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_server_id
                ]
            else:
                props["RouteServerId"] = self.route_server_id

        return props



@dataclass
class RouteServerEndpoint(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-r"""

    resource_type: ClassVar[str] = "AWS::EC2::RouteServerEndpoint"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_server_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        if self.route_server_id is not None:
            # Serialize route_server_id (handle intrinsic functions)
            if hasattr(self.route_server_id, 'to_dict'):
                props["RouteServerId"] = self.route_server_id.to_dict()
            elif isinstance(self.route_server_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteServerId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_server_id
                ]
            else:
                props["RouteServerId"] = self.route_server_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_vpc_id(self) -> GetAtt:
        """Get the VpcId attribute."""
        return self.get_att("VpcId")

    @property
    def attr_eni_id(self) -> GetAtt:
        """Get the EniId attribute."""
        return self.get_att("EniId")

    @property
    def attr_eni_address(self) -> GetAtt:
        """Get the EniAddress attribute."""
        return self.get_att("EniAddress")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class BgpOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    peer_liveness_detection: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    peer_asn: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.peer_liveness_detection is not None:
            if hasattr(self.peer_liveness_detection, 'to_dict'):
                props['PeerLivenessDetection'] = self.peer_liveness_detection.to_dict()
            elif isinstance(self.peer_liveness_detection, list):
                props['PeerLivenessDetection'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_liveness_detection
                ]
            else:
                props['PeerLivenessDetection'] = self.peer_liveness_detection

        if self.peer_asn is not None:
            if hasattr(self.peer_asn, 'to_dict'):
                props['PeerAsn'] = self.peer_asn.to_dict()
            elif isinstance(self.peer_asn, list):
                props['PeerAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_asn
                ]
            else:
                props['PeerAsn'] = self.peer_asn

        return props


@dataclass
class RouteServerPeer(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-r"""

    resource_type: ClassVar[str] = "AWS::EC2::RouteServerPeer"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    bgp_options: Optional[BgpOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_server_endpoint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.peer_address is not None:
            # Serialize peer_address (handle intrinsic functions)
            if hasattr(self.peer_address, 'to_dict'):
                props["PeerAddress"] = self.peer_address.to_dict()
            elif isinstance(self.peer_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_address
                ]
            else:
                props["PeerAddress"] = self.peer_address

        if self.bgp_options is not None:
            # Serialize bgp_options (handle intrinsic functions)
            if hasattr(self.bgp_options, 'to_dict'):
                props["BgpOptions"] = self.bgp_options.to_dict()
            elif isinstance(self.bgp_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['BgpOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bgp_options
                ]
            else:
                props["BgpOptions"] = self.bgp_options

        if self.route_server_endpoint_id is not None:
            # Serialize route_server_endpoint_id (handle intrinsic functions)
            if hasattr(self.route_server_endpoint_id, 'to_dict'):
                props["RouteServerEndpointId"] = self.route_server_endpoint_id.to_dict()
            elif isinstance(self.route_server_endpoint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteServerEndpointId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_server_endpoint_id
                ]
            else:
                props["RouteServerEndpointId"] = self.route_server_endpoint_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_endpoint_eni_id(self) -> GetAtt:
        """Get the EndpointEniId attribute."""
        return self.get_att("EndpointEniId")

    @property
    def attr_vpc_id(self) -> GetAtt:
        """Get the VpcId attribute."""
        return self.get_att("VpcId")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")

    @property
    def attr_subnet_id(self) -> GetAtt:
        """Get the SubnetId attribute."""
        return self.get_att("SubnetId")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_endpoint_eni_address(self) -> GetAtt:
        """Get the EndpointEniAddress attribute."""
        return self.get_att("EndpointEniAddress")

    @property
    def attr_route_server_id(self) -> GetAtt:
        """Get the RouteServerId attribute."""
        return self.get_att("RouteServerId")




@dataclass
class RouteServerPropagation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-r"""

    resource_type: ClassVar[str] = "AWS::EC2::RouteServerPropagation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_server_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.route_table_id is not None:
            # Serialize route_table_id (handle intrinsic functions)
            if hasattr(self.route_table_id, 'to_dict'):
                props["RouteTableId"] = self.route_table_id.to_dict()
            elif isinstance(self.route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_id
                ]
            else:
                props["RouteTableId"] = self.route_table_id

        if self.route_server_id is not None:
            # Serialize route_server_id (handle intrinsic functions)
            if hasattr(self.route_server_id, 'to_dict'):
                props["RouteServerId"] = self.route_server_id.to_dict()
            elif isinstance(self.route_server_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteServerId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_server_id
                ]
            else:
                props["RouteServerId"] = self.route_server_id

        return props



@dataclass
class RouteTable(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-r"""

    resource_type: ClassVar[str] = "AWS::EC2::RouteTable"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_route_table_id(self) -> GetAtt:
        """Get the RouteTableId attribute."""
        return self.get_att("RouteTableId")




@dataclass
class Egress:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr_ip: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr_ipv6: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ip_protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_security_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_prefix_list_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cidr_ip is not None:
            if hasattr(self.cidr_ip, 'to_dict'):
                props['CidrIp'] = self.cidr_ip.to_dict()
            elif isinstance(self.cidr_ip, list):
                props['CidrIp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_ip
                ]
            else:
                props['CidrIp'] = self.cidr_ip

        if self.cidr_ipv6 is not None:
            if hasattr(self.cidr_ipv6, 'to_dict'):
                props['CidrIpv6'] = self.cidr_ipv6.to_dict()
            elif isinstance(self.cidr_ipv6, list):
                props['CidrIpv6'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_ipv6
                ]
            else:
                props['CidrIpv6'] = self.cidr_ipv6

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.from_port is not None:
            if hasattr(self.from_port, 'to_dict'):
                props['FromPort'] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props['FromPort'] = self.from_port

        if self.to_port is not None:
            if hasattr(self.to_port, 'to_dict'):
                props['ToPort'] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props['ToPort'] = self.to_port

        if self.ip_protocol is not None:
            if hasattr(self.ip_protocol, 'to_dict'):
                props['IpProtocol'] = self.ip_protocol.to_dict()
            elif isinstance(self.ip_protocol, list):
                props['IpProtocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_protocol
                ]
            else:
                props['IpProtocol'] = self.ip_protocol

        if self.destination_security_group_id is not None:
            if hasattr(self.destination_security_group_id, 'to_dict'):
                props['DestinationSecurityGroupId'] = self.destination_security_group_id.to_dict()
            elif isinstance(self.destination_security_group_id, list):
                props['DestinationSecurityGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_security_group_id
                ]
            else:
                props['DestinationSecurityGroupId'] = self.destination_security_group_id

        if self.destination_prefix_list_id is not None:
            if hasattr(self.destination_prefix_list_id, 'to_dict'):
                props['DestinationPrefixListId'] = self.destination_prefix_list_id.to_dict()
            elif isinstance(self.destination_prefix_list_id, list):
                props['DestinationPrefixListId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_prefix_list_id
                ]
            else:
                props['DestinationPrefixListId'] = self.destination_prefix_list_id

        return props


@dataclass
class Ingress:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr_ip: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr_ipv6: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_security_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_security_group_owner_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ip_protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_security_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_prefix_list_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cidr_ip is not None:
            if hasattr(self.cidr_ip, 'to_dict'):
                props['CidrIp'] = self.cidr_ip.to_dict()
            elif isinstance(self.cidr_ip, list):
                props['CidrIp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_ip
                ]
            else:
                props['CidrIp'] = self.cidr_ip

        if self.cidr_ipv6 is not None:
            if hasattr(self.cidr_ipv6, 'to_dict'):
                props['CidrIpv6'] = self.cidr_ipv6.to_dict()
            elif isinstance(self.cidr_ipv6, list):
                props['CidrIpv6'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_ipv6
                ]
            else:
                props['CidrIpv6'] = self.cidr_ipv6

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.from_port is not None:
            if hasattr(self.from_port, 'to_dict'):
                props['FromPort'] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props['FromPort'] = self.from_port

        if self.source_security_group_name is not None:
            if hasattr(self.source_security_group_name, 'to_dict'):
                props['SourceSecurityGroupName'] = self.source_security_group_name.to_dict()
            elif isinstance(self.source_security_group_name, list):
                props['SourceSecurityGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_security_group_name
                ]
            else:
                props['SourceSecurityGroupName'] = self.source_security_group_name

        if self.to_port is not None:
            if hasattr(self.to_port, 'to_dict'):
                props['ToPort'] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props['ToPort'] = self.to_port

        if self.source_security_group_owner_id is not None:
            if hasattr(self.source_security_group_owner_id, 'to_dict'):
                props['SourceSecurityGroupOwnerId'] = self.source_security_group_owner_id.to_dict()
            elif isinstance(self.source_security_group_owner_id, list):
                props['SourceSecurityGroupOwnerId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_security_group_owner_id
                ]
            else:
                props['SourceSecurityGroupOwnerId'] = self.source_security_group_owner_id

        if self.ip_protocol is not None:
            if hasattr(self.ip_protocol, 'to_dict'):
                props['IpProtocol'] = self.ip_protocol.to_dict()
            elif isinstance(self.ip_protocol, list):
                props['IpProtocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_protocol
                ]
            else:
                props['IpProtocol'] = self.ip_protocol

        if self.source_security_group_id is not None:
            if hasattr(self.source_security_group_id, 'to_dict'):
                props['SourceSecurityGroupId'] = self.source_security_group_id.to_dict()
            elif isinstance(self.source_security_group_id, list):
                props['SourceSecurityGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_security_group_id
                ]
            else:
                props['SourceSecurityGroupId'] = self.source_security_group_id

        if self.source_prefix_list_id is not None:
            if hasattr(self.source_prefix_list_id, 'to_dict'):
                props['SourcePrefixListId'] = self.source_prefix_list_id.to_dict()
            elif isinstance(self.source_prefix_list_id, list):
                props['SourcePrefixListId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_prefix_list_id
                ]
            else:
                props['SourcePrefixListId'] = self.source_prefix_list_id

        return props


@dataclass
class SecurityGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SecurityGroup"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_ingress: Optional[list[Ingress]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_egress: Optional[list[Egress]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.group_description is not None:
            # Serialize group_description (handle intrinsic functions)
            if hasattr(self.group_description, 'to_dict'):
                props["GroupDescription"] = self.group_description.to_dict()
            elif isinstance(self.group_description, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupDescription'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_description
                ]
            else:
                props["GroupDescription"] = self.group_description

        if self.group_name is not None:
            # Serialize group_name (handle intrinsic functions)
            if hasattr(self.group_name, 'to_dict'):
                props["GroupName"] = self.group_name.to_dict()
            elif isinstance(self.group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_name
                ]
            else:
                props["GroupName"] = self.group_name

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.security_group_ingress is not None:
            # Serialize security_group_ingress (handle intrinsic functions)
            if hasattr(self.security_group_ingress, 'to_dict'):
                props["SecurityGroupIngress"] = self.security_group_ingress.to_dict()
            elif isinstance(self.security_group_ingress, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupIngress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ingress
                ]
            else:
                props["SecurityGroupIngress"] = self.security_group_ingress

        if self.security_group_egress is not None:
            # Serialize security_group_egress (handle intrinsic functions)
            if hasattr(self.security_group_egress, 'to_dict'):
                props["SecurityGroupEgress"] = self.security_group_egress.to_dict()
            elif isinstance(self.security_group_egress, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupEgress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_egress
                ]
            else:
                props["SecurityGroupEgress"] = self.security_group_egress

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_vpc_id(self) -> GetAtt:
        """Get the VpcId attribute."""
        return self.get_att("VpcId")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")

    @property
    def attr_group_id(self) -> GetAtt:
        """Get the GroupId attribute."""
        return self.get_att("GroupId")




@dataclass
class SecurityGroupEgress(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SecurityGroupEgress"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_ip: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_ipv6: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ip_protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_security_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_prefix_list_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cidr_ip is not None:
            # Serialize cidr_ip (handle intrinsic functions)
            if hasattr(self.cidr_ip, 'to_dict'):
                props["CidrIp"] = self.cidr_ip.to_dict()
            elif isinstance(self.cidr_ip, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrIp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_ip
                ]
            else:
                props["CidrIp"] = self.cidr_ip

        if self.cidr_ipv6 is not None:
            # Serialize cidr_ipv6 (handle intrinsic functions)
            if hasattr(self.cidr_ipv6, 'to_dict'):
                props["CidrIpv6"] = self.cidr_ipv6.to_dict()
            elif isinstance(self.cidr_ipv6, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrIpv6'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_ipv6
                ]
            else:
                props["CidrIpv6"] = self.cidr_ipv6

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.from_port is not None:
            # Serialize from_port (handle intrinsic functions)
            if hasattr(self.from_port, 'to_dict'):
                props["FromPort"] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                # Serialize list items (may contain intrinsic functions)
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props["FromPort"] = self.from_port

        if self.to_port is not None:
            # Serialize to_port (handle intrinsic functions)
            if hasattr(self.to_port, 'to_dict'):
                props["ToPort"] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                # Serialize list items (may contain intrinsic functions)
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props["ToPort"] = self.to_port

        if self.ip_protocol is not None:
            # Serialize ip_protocol (handle intrinsic functions)
            if hasattr(self.ip_protocol, 'to_dict'):
                props["IpProtocol"] = self.ip_protocol.to_dict()
            elif isinstance(self.ip_protocol, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpProtocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_protocol
                ]
            else:
                props["IpProtocol"] = self.ip_protocol

        if self.destination_security_group_id is not None:
            # Serialize destination_security_group_id (handle intrinsic functions)
            if hasattr(self.destination_security_group_id, 'to_dict'):
                props["DestinationSecurityGroupId"] = self.destination_security_group_id.to_dict()
            elif isinstance(self.destination_security_group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationSecurityGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_security_group_id
                ]
            else:
                props["DestinationSecurityGroupId"] = self.destination_security_group_id

        if self.destination_prefix_list_id is not None:
            # Serialize destination_prefix_list_id (handle intrinsic functions)
            if hasattr(self.destination_prefix_list_id, 'to_dict'):
                props["DestinationPrefixListId"] = self.destination_prefix_list_id.to_dict()
            elif isinstance(self.destination_prefix_list_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationPrefixListId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_prefix_list_id
                ]
            else:
                props["DestinationPrefixListId"] = self.destination_prefix_list_id

        if self.group_id is not None:
            # Serialize group_id (handle intrinsic functions)
            if hasattr(self.group_id, 'to_dict'):
                props["GroupId"] = self.group_id.to_dict()
            elif isinstance(self.group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_id
                ]
            else:
                props["GroupId"] = self.group_id

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class SecurityGroupIngress(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SecurityGroupIngress"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_ip: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_ipv6: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_security_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_security_group_owner_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ip_protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_security_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_prefix_list_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.group_name is not None:
            # Serialize group_name (handle intrinsic functions)
            if hasattr(self.group_name, 'to_dict'):
                props["GroupName"] = self.group_name.to_dict()
            elif isinstance(self.group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_name
                ]
            else:
                props["GroupName"] = self.group_name

        if self.cidr_ip is not None:
            # Serialize cidr_ip (handle intrinsic functions)
            if hasattr(self.cidr_ip, 'to_dict'):
                props["CidrIp"] = self.cidr_ip.to_dict()
            elif isinstance(self.cidr_ip, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrIp'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_ip
                ]
            else:
                props["CidrIp"] = self.cidr_ip

        if self.cidr_ipv6 is not None:
            # Serialize cidr_ipv6 (handle intrinsic functions)
            if hasattr(self.cidr_ipv6, 'to_dict'):
                props["CidrIpv6"] = self.cidr_ipv6.to_dict()
            elif isinstance(self.cidr_ipv6, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrIpv6'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_ipv6
                ]
            else:
                props["CidrIpv6"] = self.cidr_ipv6

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.from_port is not None:
            # Serialize from_port (handle intrinsic functions)
            if hasattr(self.from_port, 'to_dict'):
                props["FromPort"] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                # Serialize list items (may contain intrinsic functions)
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props["FromPort"] = self.from_port

        if self.source_security_group_name is not None:
            # Serialize source_security_group_name (handle intrinsic functions)
            if hasattr(self.source_security_group_name, 'to_dict'):
                props["SourceSecurityGroupName"] = self.source_security_group_name.to_dict()
            elif isinstance(self.source_security_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceSecurityGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_security_group_name
                ]
            else:
                props["SourceSecurityGroupName"] = self.source_security_group_name

        if self.to_port is not None:
            # Serialize to_port (handle intrinsic functions)
            if hasattr(self.to_port, 'to_dict'):
                props["ToPort"] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                # Serialize list items (may contain intrinsic functions)
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props["ToPort"] = self.to_port

        if self.source_security_group_owner_id is not None:
            # Serialize source_security_group_owner_id (handle intrinsic functions)
            if hasattr(self.source_security_group_owner_id, 'to_dict'):
                props["SourceSecurityGroupOwnerId"] = self.source_security_group_owner_id.to_dict()
            elif isinstance(self.source_security_group_owner_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceSecurityGroupOwnerId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_security_group_owner_id
                ]
            else:
                props["SourceSecurityGroupOwnerId"] = self.source_security_group_owner_id

        if self.ip_protocol is not None:
            # Serialize ip_protocol (handle intrinsic functions)
            if hasattr(self.ip_protocol, 'to_dict'):
                props["IpProtocol"] = self.ip_protocol.to_dict()
            elif isinstance(self.ip_protocol, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpProtocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_protocol
                ]
            else:
                props["IpProtocol"] = self.ip_protocol

        if self.source_security_group_id is not None:
            # Serialize source_security_group_id (handle intrinsic functions)
            if hasattr(self.source_security_group_id, 'to_dict'):
                props["SourceSecurityGroupId"] = self.source_security_group_id.to_dict()
            elif isinstance(self.source_security_group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceSecurityGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_security_group_id
                ]
            else:
                props["SourceSecurityGroupId"] = self.source_security_group_id

        if self.source_prefix_list_id is not None:
            # Serialize source_prefix_list_id (handle intrinsic functions)
            if hasattr(self.source_prefix_list_id, 'to_dict'):
                props["SourcePrefixListId"] = self.source_prefix_list_id.to_dict()
            elif isinstance(self.source_prefix_list_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourcePrefixListId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_prefix_list_id
                ]
            else:
                props["SourcePrefixListId"] = self.source_prefix_list_id

        if self.group_id is not None:
            # Serialize group_id (handle intrinsic functions)
            if hasattr(self.group_id, 'to_dict'):
                props["GroupId"] = self.group_id.to_dict()
            elif isinstance(self.group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_id
                ]
            else:
                props["GroupId"] = self.group_id

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class SecurityGroupVpcAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SecurityGroupVpcAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.group_id is not None:
            # Serialize group_id (handle intrinsic functions)
            if hasattr(self.group_id, 'to_dict'):
                props["GroupId"] = self.group_id.to_dict()
            elif isinstance(self.group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_id
                ]
            else:
                props["GroupId"] = self.group_id

        return props

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_state_reason(self) -> GetAtt:
        """Get the StateReason attribute."""
        return self.get_att("StateReason")

    @property
    def attr_vpc_owner_id(self) -> GetAtt:
        """Get the VpcOwnerId attribute."""
        return self.get_att("VpcOwnerId")




@dataclass
class SnapshotBlockPublicAccess(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SnapshotBlockPublicAccess"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    state: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.state is not None:
            # Serialize state (handle intrinsic functions)
            if hasattr(self.state, 'to_dict'):
                props["State"] = self.state.to_dict()
            elif isinstance(self.state, list):
                # Serialize list items (may contain intrinsic functions)
                props['State'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state
                ]
            else:
                props["State"] = self.state

        return props

    @property
    def attr_account_id(self) -> GetAtt:
        """Get the AccountId attribute."""
        return self.get_att("AccountId")




@dataclass
class AcceleratorCountRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class AcceleratorTotalMemoryMiBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class BaselineEbsBandwidthMbpsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class BaselinePerformanceFactorsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu: Optional[CpuPerformanceFactorRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cpu is not None:
            if hasattr(self.cpu, 'to_dict'):
                props['Cpu'] = self.cpu.to_dict()
            elif isinstance(self.cpu, list):
                props['Cpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu
                ]
            else:
                props['Cpu'] = self.cpu

        return props


@dataclass
class BlockDeviceMapping:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs: Optional[EbsBlockDevice] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    no_device: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    virtual_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ebs is not None:
            if hasattr(self.ebs, 'to_dict'):
                props['Ebs'] = self.ebs.to_dict()
            elif isinstance(self.ebs, list):
                props['Ebs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs
                ]
            else:
                props['Ebs'] = self.ebs

        if self.no_device is not None:
            if hasattr(self.no_device, 'to_dict'):
                props['NoDevice'] = self.no_device.to_dict()
            elif isinstance(self.no_device, list):
                props['NoDevice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.no_device
                ]
            else:
                props['NoDevice'] = self.no_device

        if self.virtual_name is not None:
            if hasattr(self.virtual_name, 'to_dict'):
                props['VirtualName'] = self.virtual_name.to_dict()
            elif isinstance(self.virtual_name, list):
                props['VirtualName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.virtual_name
                ]
            else:
                props['VirtualName'] = self.virtual_name

        if self.device_name is not None:
            if hasattr(self.device_name, 'to_dict'):
                props['DeviceName'] = self.device_name.to_dict()
            elif isinstance(self.device_name, list):
                props['DeviceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_name
                ]
            else:
                props['DeviceName'] = self.device_name

        return props


@dataclass
class ClassicLoadBalancer:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class ClassicLoadBalancersConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    classic_load_balancers: Optional[list[ClassicLoadBalancer]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.classic_load_balancers is not None:
            if hasattr(self.classic_load_balancers, 'to_dict'):
                props['ClassicLoadBalancers'] = self.classic_load_balancers.to_dict()
            elif isinstance(self.classic_load_balancers, list):
                props['ClassicLoadBalancers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.classic_load_balancers
                ]
            else:
                props['ClassicLoadBalancers'] = self.classic_load_balancers

        return props


@dataclass
class CpuPerformanceFactorRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    references: Optional[list[PerformanceFactorReferenceRequest]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.references is not None:
            if hasattr(self.references, 'to_dict'):
                props['References'] = self.references.to_dict()
            elif isinstance(self.references, list):
                props['References'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.references
                ]
            else:
                props['References'] = self.references

        return props


@dataclass
class EbsBlockDevice:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    snapshot_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_type: Optional[Union[str, VolumeType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    encrypted: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.snapshot_id is not None:
            if hasattr(self.snapshot_id, 'to_dict'):
                props['SnapshotId'] = self.snapshot_id.to_dict()
            elif isinstance(self.snapshot_id, list):
                props['SnapshotId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snapshot_id
                ]
            else:
                props['SnapshotId'] = self.snapshot_id

        if self.volume_type is not None:
            if hasattr(self.volume_type, 'to_dict'):
                props['VolumeType'] = self.volume_type.to_dict()
            elif isinstance(self.volume_type, list):
                props['VolumeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_type
                ]
            else:
                props['VolumeType'] = self.volume_type

        if self.encrypted is not None:
            if hasattr(self.encrypted, 'to_dict'):
                props['Encrypted'] = self.encrypted.to_dict()
            elif isinstance(self.encrypted, list):
                props['Encrypted'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encrypted
                ]
            else:
                props['Encrypted'] = self.encrypted

        if self.iops is not None:
            if hasattr(self.iops, 'to_dict'):
                props['Iops'] = self.iops.to_dict()
            elif isinstance(self.iops, list):
                props['Iops'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iops
                ]
            else:
                props['Iops'] = self.iops

        if self.volume_size is not None:
            if hasattr(self.volume_size, 'to_dict'):
                props['VolumeSize'] = self.volume_size.to_dict()
            elif isinstance(self.volume_size, list):
                props['VolumeSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size
                ]
            else:
                props['VolumeSize'] = self.volume_size

        if self.delete_on_termination is not None:
            if hasattr(self.delete_on_termination, 'to_dict'):
                props['DeleteOnTermination'] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props['DeleteOnTermination'] = self.delete_on_termination

        return props


@dataclass
class FleetLaunchTemplateSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.launch_template_name is not None:
            if hasattr(self.launch_template_name, 'to_dict'):
                props['LaunchTemplateName'] = self.launch_template_name.to_dict()
            elif isinstance(self.launch_template_name, list):
                props['LaunchTemplateName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_name
                ]
            else:
                props['LaunchTemplateName'] = self.launch_template_name

        if self.version is not None:
            if hasattr(self.version, 'to_dict'):
                props['Version'] = self.version.to_dict()
            elif isinstance(self.version, list):
                props['Version'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version
                ]
            else:
                props['Version'] = self.version

        if self.launch_template_id is not None:
            if hasattr(self.launch_template_id, 'to_dict'):
                props['LaunchTemplateId'] = self.launch_template_id.to_dict()
            elif isinstance(self.launch_template_id, list):
                props['LaunchTemplateId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_id
                ]
            else:
                props['LaunchTemplateId'] = self.launch_template_id

        return props


@dataclass
class GroupIdentifier:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.group_id is not None:
            if hasattr(self.group_id, 'to_dict'):
                props['GroupId'] = self.group_id.to_dict()
            elif isinstance(self.group_id, list):
                props['GroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_id
                ]
            else:
                props['GroupId'] = self.group_id

        return props


@dataclass
class IamInstanceProfileSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.arn is not None:
            if hasattr(self.arn, 'to_dict'):
                props['Arn'] = self.arn.to_dict()
            elif isinstance(self.arn, list):
                props['Arn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.arn
                ]
            else:
                props['Arn'] = self.arn

        return props


@dataclass
class InstanceIpv6Address:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_address: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_address is not None:
            if hasattr(self.ipv6_address, 'to_dict'):
                props['Ipv6Address'] = self.ipv6_address.to_dict()
            elif isinstance(self.ipv6_address, list):
                props['Ipv6Address'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address
                ]
            else:
                props['Ipv6Address'] = self.ipv6_address

        return props


@dataclass
class InstanceNetworkInterfaceSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_addresses: Optional[list[PrivateIpAddressSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    secondary_private_ip_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_index: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_address_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_addresses: Optional[list[InstanceIpv6Address]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    associate_public_ip_address: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delete_on_termination: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.private_ip_addresses is not None:
            if hasattr(self.private_ip_addresses, 'to_dict'):
                props['PrivateIpAddresses'] = self.private_ip_addresses.to_dict()
            elif isinstance(self.private_ip_addresses, list):
                props['PrivateIpAddresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_addresses
                ]
            else:
                props['PrivateIpAddresses'] = self.private_ip_addresses

        if self.secondary_private_ip_address_count is not None:
            if hasattr(self.secondary_private_ip_address_count, 'to_dict'):
                props['SecondaryPrivateIpAddressCount'] = self.secondary_private_ip_address_count.to_dict()
            elif isinstance(self.secondary_private_ip_address_count, list):
                props['SecondaryPrivateIpAddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secondary_private_ip_address_count
                ]
            else:
                props['SecondaryPrivateIpAddressCount'] = self.secondary_private_ip_address_count

        if self.device_index is not None:
            if hasattr(self.device_index, 'to_dict'):
                props['DeviceIndex'] = self.device_index.to_dict()
            elif isinstance(self.device_index, list):
                props['DeviceIndex'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_index
                ]
            else:
                props['DeviceIndex'] = self.device_index

        if self.groups is not None:
            if hasattr(self.groups, 'to_dict'):
                props['Groups'] = self.groups.to_dict()
            elif isinstance(self.groups, list):
                props['Groups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.groups
                ]
            else:
                props['Groups'] = self.groups

        if self.ipv6_address_count is not None:
            if hasattr(self.ipv6_address_count, 'to_dict'):
                props['Ipv6AddressCount'] = self.ipv6_address_count.to_dict()
            elif isinstance(self.ipv6_address_count, list):
                props['Ipv6AddressCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_address_count
                ]
            else:
                props['Ipv6AddressCount'] = self.ipv6_address_count

        if self.ipv6_addresses is not None:
            if hasattr(self.ipv6_addresses, 'to_dict'):
                props['Ipv6Addresses'] = self.ipv6_addresses.to_dict()
            elif isinstance(self.ipv6_addresses, list):
                props['Ipv6Addresses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_addresses
                ]
            else:
                props['Ipv6Addresses'] = self.ipv6_addresses

        if self.subnet_id is not None:
            if hasattr(self.subnet_id, 'to_dict'):
                props['SubnetId'] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props['SubnetId'] = self.subnet_id

        if self.associate_public_ip_address is not None:
            if hasattr(self.associate_public_ip_address, 'to_dict'):
                props['AssociatePublicIpAddress'] = self.associate_public_ip_address.to_dict()
            elif isinstance(self.associate_public_ip_address, list):
                props['AssociatePublicIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.associate_public_ip_address
                ]
            else:
                props['AssociatePublicIpAddress'] = self.associate_public_ip_address

        if self.network_interface_id is not None:
            if hasattr(self.network_interface_id, 'to_dict'):
                props['NetworkInterfaceId'] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props['NetworkInterfaceId'] = self.network_interface_id

        if self.delete_on_termination is not None:
            if hasattr(self.delete_on_termination, 'to_dict'):
                props['DeleteOnTermination'] = self.delete_on_termination.to_dict()
            elif isinstance(self.delete_on_termination, list):
                props['DeleteOnTermination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delete_on_termination
                ]
            else:
                props['DeleteOnTermination'] = self.delete_on_termination

        return props


@dataclass
class InstanceRequirementsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_generations: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    require_encryption_in_transit: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_gi_b_per_v_cpu: Optional[MemoryGiBPerVCpuRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    v_cpu_count: Optional[VCpuCountRangeRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_manufacturers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_storage: Optional[Union[str, LocalStorage, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_manufacturers: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bare_metal: Optional[Union[str, BareMetal, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    require_hibernate_support: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_max_price_percentage_over_lowest_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_mi_b: Optional[MemoryMiBRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_storage_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_count: Optional[NetworkInterfaceCountRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    excluded_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allowed_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_bandwidth_gbps: Optional[NetworkBandwidthGbpsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_count: Optional[AcceleratorCountRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_performance_factors: Optional[BaselinePerformanceFactorsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_max_price_percentage_over_lowest_price: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_ebs_bandwidth_mbps: Optional[BaselineEbsBandwidthMbpsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_total_memory_mi_b: Optional[AcceleratorTotalMemoryMiBRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    burstable_performance: Optional[Union[str, BurstablePerformance, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    total_local_storage_gb: Optional[TotalLocalStorageGBRequest] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_generations is not None:
            if hasattr(self.instance_generations, 'to_dict'):
                props['InstanceGenerations'] = self.instance_generations.to_dict()
            elif isinstance(self.instance_generations, list):
                props['InstanceGenerations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_generations
                ]
            else:
                props['InstanceGenerations'] = self.instance_generations

        if self.require_encryption_in_transit is not None:
            if hasattr(self.require_encryption_in_transit, 'to_dict'):
                props['RequireEncryptionInTransit'] = self.require_encryption_in_transit.to_dict()
            elif isinstance(self.require_encryption_in_transit, list):
                props['RequireEncryptionInTransit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.require_encryption_in_transit
                ]
            else:
                props['RequireEncryptionInTransit'] = self.require_encryption_in_transit

        if self.memory_gi_b_per_v_cpu is not None:
            if hasattr(self.memory_gi_b_per_v_cpu, 'to_dict'):
                props['MemoryGiBPerVCpu'] = self.memory_gi_b_per_v_cpu.to_dict()
            elif isinstance(self.memory_gi_b_per_v_cpu, list):
                props['MemoryGiBPerVCpu'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_gi_b_per_v_cpu
                ]
            else:
                props['MemoryGiBPerVCpu'] = self.memory_gi_b_per_v_cpu

        if self.accelerator_types is not None:
            if hasattr(self.accelerator_types, 'to_dict'):
                props['AcceleratorTypes'] = self.accelerator_types.to_dict()
            elif isinstance(self.accelerator_types, list):
                props['AcceleratorTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_types
                ]
            else:
                props['AcceleratorTypes'] = self.accelerator_types

        if self.v_cpu_count is not None:
            if hasattr(self.v_cpu_count, 'to_dict'):
                props['VCpuCount'] = self.v_cpu_count.to_dict()
            elif isinstance(self.v_cpu_count, list):
                props['VCpuCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.v_cpu_count
                ]
            else:
                props['VCpuCount'] = self.v_cpu_count

        if self.accelerator_manufacturers is not None:
            if hasattr(self.accelerator_manufacturers, 'to_dict'):
                props['AcceleratorManufacturers'] = self.accelerator_manufacturers.to_dict()
            elif isinstance(self.accelerator_manufacturers, list):
                props['AcceleratorManufacturers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_manufacturers
                ]
            else:
                props['AcceleratorManufacturers'] = self.accelerator_manufacturers

        if self.local_storage is not None:
            if hasattr(self.local_storage, 'to_dict'):
                props['LocalStorage'] = self.local_storage.to_dict()
            elif isinstance(self.local_storage, list):
                props['LocalStorage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_storage
                ]
            else:
                props['LocalStorage'] = self.local_storage

        if self.cpu_manufacturers is not None:
            if hasattr(self.cpu_manufacturers, 'to_dict'):
                props['CpuManufacturers'] = self.cpu_manufacturers.to_dict()
            elif isinstance(self.cpu_manufacturers, list):
                props['CpuManufacturers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_manufacturers
                ]
            else:
                props['CpuManufacturers'] = self.cpu_manufacturers

        if self.bare_metal is not None:
            if hasattr(self.bare_metal, 'to_dict'):
                props['BareMetal'] = self.bare_metal.to_dict()
            elif isinstance(self.bare_metal, list):
                props['BareMetal'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bare_metal
                ]
            else:
                props['BareMetal'] = self.bare_metal

        if self.require_hibernate_support is not None:
            if hasattr(self.require_hibernate_support, 'to_dict'):
                props['RequireHibernateSupport'] = self.require_hibernate_support.to_dict()
            elif isinstance(self.require_hibernate_support, list):
                props['RequireHibernateSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.require_hibernate_support
                ]
            else:
                props['RequireHibernateSupport'] = self.require_hibernate_support

        if self.max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            if hasattr(self.max_spot_price_as_percentage_of_optimal_on_demand_price, 'to_dict'):
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = self.max_spot_price_as_percentage_of_optimal_on_demand_price.to_dict()
            elif isinstance(self.max_spot_price_as_percentage_of_optimal_on_demand_price, list):
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_spot_price_as_percentage_of_optimal_on_demand_price
                ]
            else:
                props['MaxSpotPriceAsPercentageOfOptimalOnDemandPrice'] = self.max_spot_price_as_percentage_of_optimal_on_demand_price

        if self.on_demand_max_price_percentage_over_lowest_price is not None:
            if hasattr(self.on_demand_max_price_percentage_over_lowest_price, 'to_dict'):
                props['OnDemandMaxPricePercentageOverLowestPrice'] = self.on_demand_max_price_percentage_over_lowest_price.to_dict()
            elif isinstance(self.on_demand_max_price_percentage_over_lowest_price, list):
                props['OnDemandMaxPricePercentageOverLowestPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_max_price_percentage_over_lowest_price
                ]
            else:
                props['OnDemandMaxPricePercentageOverLowestPrice'] = self.on_demand_max_price_percentage_over_lowest_price

        if self.memory_mi_b is not None:
            if hasattr(self.memory_mi_b, 'to_dict'):
                props['MemoryMiB'] = self.memory_mi_b.to_dict()
            elif isinstance(self.memory_mi_b, list):
                props['MemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_mi_b
                ]
            else:
                props['MemoryMiB'] = self.memory_mi_b

        if self.local_storage_types is not None:
            if hasattr(self.local_storage_types, 'to_dict'):
                props['LocalStorageTypes'] = self.local_storage_types.to_dict()
            elif isinstance(self.local_storage_types, list):
                props['LocalStorageTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_storage_types
                ]
            else:
                props['LocalStorageTypes'] = self.local_storage_types

        if self.network_interface_count is not None:
            if hasattr(self.network_interface_count, 'to_dict'):
                props['NetworkInterfaceCount'] = self.network_interface_count.to_dict()
            elif isinstance(self.network_interface_count, list):
                props['NetworkInterfaceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_count
                ]
            else:
                props['NetworkInterfaceCount'] = self.network_interface_count

        if self.excluded_instance_types is not None:
            if hasattr(self.excluded_instance_types, 'to_dict'):
                props['ExcludedInstanceTypes'] = self.excluded_instance_types.to_dict()
            elif isinstance(self.excluded_instance_types, list):
                props['ExcludedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.excluded_instance_types
                ]
            else:
                props['ExcludedInstanceTypes'] = self.excluded_instance_types

        if self.allowed_instance_types is not None:
            if hasattr(self.allowed_instance_types, 'to_dict'):
                props['AllowedInstanceTypes'] = self.allowed_instance_types.to_dict()
            elif isinstance(self.allowed_instance_types, list):
                props['AllowedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_instance_types
                ]
            else:
                props['AllowedInstanceTypes'] = self.allowed_instance_types

        if self.network_bandwidth_gbps is not None:
            if hasattr(self.network_bandwidth_gbps, 'to_dict'):
                props['NetworkBandwidthGbps'] = self.network_bandwidth_gbps.to_dict()
            elif isinstance(self.network_bandwidth_gbps, list):
                props['NetworkBandwidthGbps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_bandwidth_gbps
                ]
            else:
                props['NetworkBandwidthGbps'] = self.network_bandwidth_gbps

        if self.accelerator_count is not None:
            if hasattr(self.accelerator_count, 'to_dict'):
                props['AcceleratorCount'] = self.accelerator_count.to_dict()
            elif isinstance(self.accelerator_count, list):
                props['AcceleratorCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_count
                ]
            else:
                props['AcceleratorCount'] = self.accelerator_count

        if self.baseline_performance_factors is not None:
            if hasattr(self.baseline_performance_factors, 'to_dict'):
                props['BaselinePerformanceFactors'] = self.baseline_performance_factors.to_dict()
            elif isinstance(self.baseline_performance_factors, list):
                props['BaselinePerformanceFactors'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baseline_performance_factors
                ]
            else:
                props['BaselinePerformanceFactors'] = self.baseline_performance_factors

        if self.spot_max_price_percentage_over_lowest_price is not None:
            if hasattr(self.spot_max_price_percentage_over_lowest_price, 'to_dict'):
                props['SpotMaxPricePercentageOverLowestPrice'] = self.spot_max_price_percentage_over_lowest_price.to_dict()
            elif isinstance(self.spot_max_price_percentage_over_lowest_price, list):
                props['SpotMaxPricePercentageOverLowestPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_max_price_percentage_over_lowest_price
                ]
            else:
                props['SpotMaxPricePercentageOverLowestPrice'] = self.spot_max_price_percentage_over_lowest_price

        if self.baseline_ebs_bandwidth_mbps is not None:
            if hasattr(self.baseline_ebs_bandwidth_mbps, 'to_dict'):
                props['BaselineEbsBandwidthMbps'] = self.baseline_ebs_bandwidth_mbps.to_dict()
            elif isinstance(self.baseline_ebs_bandwidth_mbps, list):
                props['BaselineEbsBandwidthMbps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baseline_ebs_bandwidth_mbps
                ]
            else:
                props['BaselineEbsBandwidthMbps'] = self.baseline_ebs_bandwidth_mbps

        if self.accelerator_names is not None:
            if hasattr(self.accelerator_names, 'to_dict'):
                props['AcceleratorNames'] = self.accelerator_names.to_dict()
            elif isinstance(self.accelerator_names, list):
                props['AcceleratorNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_names
                ]
            else:
                props['AcceleratorNames'] = self.accelerator_names

        if self.accelerator_total_memory_mi_b is not None:
            if hasattr(self.accelerator_total_memory_mi_b, 'to_dict'):
                props['AcceleratorTotalMemoryMiB'] = self.accelerator_total_memory_mi_b.to_dict()
            elif isinstance(self.accelerator_total_memory_mi_b, list):
                props['AcceleratorTotalMemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_total_memory_mi_b
                ]
            else:
                props['AcceleratorTotalMemoryMiB'] = self.accelerator_total_memory_mi_b

        if self.burstable_performance is not None:
            if hasattr(self.burstable_performance, 'to_dict'):
                props['BurstablePerformance'] = self.burstable_performance.to_dict()
            elif isinstance(self.burstable_performance, list):
                props['BurstablePerformance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.burstable_performance
                ]
            else:
                props['BurstablePerformance'] = self.burstable_performance

        if self.total_local_storage_gb is not None:
            if hasattr(self.total_local_storage_gb, 'to_dict'):
                props['TotalLocalStorageGB'] = self.total_local_storage_gb.to_dict()
            elif isinstance(self.total_local_storage_gb, list):
                props['TotalLocalStorageGB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.total_local_storage_gb
                ]
            else:
                props['TotalLocalStorageGB'] = self.total_local_storage_gb

        return props


@dataclass
class LaunchTemplateConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_specification: Optional[FleetLaunchTemplateSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    overrides: Optional[list[LaunchTemplateOverrides]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.launch_template_specification is not None:
            if hasattr(self.launch_template_specification, 'to_dict'):
                props['LaunchTemplateSpecification'] = self.launch_template_specification.to_dict()
            elif isinstance(self.launch_template_specification, list):
                props['LaunchTemplateSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_specification
                ]
            else:
                props['LaunchTemplateSpecification'] = self.launch_template_specification

        if self.overrides is not None:
            if hasattr(self.overrides, 'to_dict'):
                props['Overrides'] = self.overrides.to_dict()
            elif isinstance(self.overrides, list):
                props['Overrides'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.overrides
                ]
            else:
                props['Overrides'] = self.overrides

        return props


@dataclass
class LaunchTemplateOverrides:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    weighted_capacity: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    priority: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_requirements: Optional[InstanceRequirementsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, InstanceType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.spot_price is not None:
            if hasattr(self.spot_price, 'to_dict'):
                props['SpotPrice'] = self.spot_price.to_dict()
            elif isinstance(self.spot_price, list):
                props['SpotPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_price
                ]
            else:
                props['SpotPrice'] = self.spot_price

        if self.weighted_capacity is not None:
            if hasattr(self.weighted_capacity, 'to_dict'):
                props['WeightedCapacity'] = self.weighted_capacity.to_dict()
            elif isinstance(self.weighted_capacity, list):
                props['WeightedCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weighted_capacity
                ]
            else:
                props['WeightedCapacity'] = self.weighted_capacity

        if self.priority is not None:
            if hasattr(self.priority, 'to_dict'):
                props['Priority'] = self.priority.to_dict()
            elif isinstance(self.priority, list):
                props['Priority'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.priority
                ]
            else:
                props['Priority'] = self.priority

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        if self.subnet_id is not None:
            if hasattr(self.subnet_id, 'to_dict'):
                props['SubnetId'] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props['SubnetId'] = self.subnet_id

        if self.instance_requirements is not None:
            if hasattr(self.instance_requirements, 'to_dict'):
                props['InstanceRequirements'] = self.instance_requirements.to_dict()
            elif isinstance(self.instance_requirements, list):
                props['InstanceRequirements'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_requirements
                ]
            else:
                props['InstanceRequirements'] = self.instance_requirements

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        return props


@dataclass
class LoadBalancersConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    classic_load_balancers_config: Optional[ClassicLoadBalancersConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_groups_config: Optional[TargetGroupsConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.classic_load_balancers_config is not None:
            if hasattr(self.classic_load_balancers_config, 'to_dict'):
                props['ClassicLoadBalancersConfig'] = self.classic_load_balancers_config.to_dict()
            elif isinstance(self.classic_load_balancers_config, list):
                props['ClassicLoadBalancersConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.classic_load_balancers_config
                ]
            else:
                props['ClassicLoadBalancersConfig'] = self.classic_load_balancers_config

        if self.target_groups_config is not None:
            if hasattr(self.target_groups_config, 'to_dict'):
                props['TargetGroupsConfig'] = self.target_groups_config.to_dict()
            elif isinstance(self.target_groups_config, list):
                props['TargetGroupsConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_groups_config
                ]
            else:
                props['TargetGroupsConfig'] = self.target_groups_config

        return props


@dataclass
class MemoryGiBPerVCpuRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class MemoryMiBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class NetworkBandwidthGbpsRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class NetworkInterfaceCountRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class PerformanceFactorReferenceRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_family: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_family is not None:
            if hasattr(self.instance_family, 'to_dict'):
                props['InstanceFamily'] = self.instance_family.to_dict()
            elif isinstance(self.instance_family, list):
                props['InstanceFamily'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_family
                ]
            else:
                props['InstanceFamily'] = self.instance_family

        return props


@dataclass
class PrivateIpAddressSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    primary: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.private_ip_address is not None:
            if hasattr(self.private_ip_address, 'to_dict'):
                props['PrivateIpAddress'] = self.private_ip_address.to_dict()
            elif isinstance(self.private_ip_address, list):
                props['PrivateIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_ip_address
                ]
            else:
                props['PrivateIpAddress'] = self.private_ip_address

        if self.primary is not None:
            if hasattr(self.primary, 'to_dict'):
                props['Primary'] = self.primary.to_dict()
            elif isinstance(self.primary, list):
                props['Primary'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.primary
                ]
            else:
                props['Primary'] = self.primary

        return props


@dataclass
class SpotCapacityRebalance:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    termination_delay: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    replacement_strategy: Optional[Union[str, ReplacementStrategy, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.termination_delay is not None:
            if hasattr(self.termination_delay, 'to_dict'):
                props['TerminationDelay'] = self.termination_delay.to_dict()
            elif isinstance(self.termination_delay, list):
                props['TerminationDelay'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.termination_delay
                ]
            else:
                props['TerminationDelay'] = self.termination_delay

        if self.replacement_strategy is not None:
            if hasattr(self.replacement_strategy, 'to_dict'):
                props['ReplacementStrategy'] = self.replacement_strategy.to_dict()
            elif isinstance(self.replacement_strategy, list):
                props['ReplacementStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.replacement_strategy
                ]
            else:
                props['ReplacementStrategy'] = self.replacement_strategy

        return props


@dataclass
class SpotFleetLaunchSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_groups: Optional[list[GroupIdentifier]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_specifications: Optional[list[SpotFleetTagSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    block_device_mappings: Optional[list[BlockDeviceMapping]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iam_instance_profile: Optional[IamInstanceProfileSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kernel_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs_optimized: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ramdisk_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    weighted_capacity: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    placement: Optional[SpotPlacement] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interfaces: Optional[list[InstanceNetworkInterfaceSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_requirements: Optional[InstanceRequirementsRequest] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, InstanceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring: Optional[SpotFleetMonitoring] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.security_groups is not None:
            if hasattr(self.security_groups, 'to_dict'):
                props['SecurityGroups'] = self.security_groups.to_dict()
            elif isinstance(self.security_groups, list):
                props['SecurityGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_groups
                ]
            else:
                props['SecurityGroups'] = self.security_groups

        if self.tag_specifications is not None:
            if hasattr(self.tag_specifications, 'to_dict'):
                props['TagSpecifications'] = self.tag_specifications.to_dict()
            elif isinstance(self.tag_specifications, list):
                props['TagSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_specifications
                ]
            else:
                props['TagSpecifications'] = self.tag_specifications

        if self.user_data is not None:
            if hasattr(self.user_data, 'to_dict'):
                props['UserData'] = self.user_data.to_dict()
            elif isinstance(self.user_data, list):
                props['UserData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_data
                ]
            else:
                props['UserData'] = self.user_data

        if self.block_device_mappings is not None:
            if hasattr(self.block_device_mappings, 'to_dict'):
                props['BlockDeviceMappings'] = self.block_device_mappings.to_dict()
            elif isinstance(self.block_device_mappings, list):
                props['BlockDeviceMappings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.block_device_mappings
                ]
            else:
                props['BlockDeviceMappings'] = self.block_device_mappings

        if self.iam_instance_profile is not None:
            if hasattr(self.iam_instance_profile, 'to_dict'):
                props['IamInstanceProfile'] = self.iam_instance_profile.to_dict()
            elif isinstance(self.iam_instance_profile, list):
                props['IamInstanceProfile'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iam_instance_profile
                ]
            else:
                props['IamInstanceProfile'] = self.iam_instance_profile

        if self.kernel_id is not None:
            if hasattr(self.kernel_id, 'to_dict'):
                props['KernelId'] = self.kernel_id.to_dict()
            elif isinstance(self.kernel_id, list):
                props['KernelId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kernel_id
                ]
            else:
                props['KernelId'] = self.kernel_id

        if self.subnet_id is not None:
            if hasattr(self.subnet_id, 'to_dict'):
                props['SubnetId'] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props['SubnetId'] = self.subnet_id

        if self.ebs_optimized is not None:
            if hasattr(self.ebs_optimized, 'to_dict'):
                props['EbsOptimized'] = self.ebs_optimized.to_dict()
            elif isinstance(self.ebs_optimized, list):
                props['EbsOptimized'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_optimized
                ]
            else:
                props['EbsOptimized'] = self.ebs_optimized

        if self.key_name is not None:
            if hasattr(self.key_name, 'to_dict'):
                props['KeyName'] = self.key_name.to_dict()
            elif isinstance(self.key_name, list):
                props['KeyName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_name
                ]
            else:
                props['KeyName'] = self.key_name

        if self.ramdisk_id is not None:
            if hasattr(self.ramdisk_id, 'to_dict'):
                props['RamdiskId'] = self.ramdisk_id.to_dict()
            elif isinstance(self.ramdisk_id, list):
                props['RamdiskId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ramdisk_id
                ]
            else:
                props['RamdiskId'] = self.ramdisk_id

        if self.spot_price is not None:
            if hasattr(self.spot_price, 'to_dict'):
                props['SpotPrice'] = self.spot_price.to_dict()
            elif isinstance(self.spot_price, list):
                props['SpotPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_price
                ]
            else:
                props['SpotPrice'] = self.spot_price

        if self.weighted_capacity is not None:
            if hasattr(self.weighted_capacity, 'to_dict'):
                props['WeightedCapacity'] = self.weighted_capacity.to_dict()
            elif isinstance(self.weighted_capacity, list):
                props['WeightedCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weighted_capacity
                ]
            else:
                props['WeightedCapacity'] = self.weighted_capacity

        if self.placement is not None:
            if hasattr(self.placement, 'to_dict'):
                props['Placement'] = self.placement.to_dict()
            elif isinstance(self.placement, list):
                props['Placement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.placement
                ]
            else:
                props['Placement'] = self.placement

        if self.network_interfaces is not None:
            if hasattr(self.network_interfaces, 'to_dict'):
                props['NetworkInterfaces'] = self.network_interfaces.to_dict()
            elif isinstance(self.network_interfaces, list):
                props['NetworkInterfaces'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interfaces
                ]
            else:
                props['NetworkInterfaces'] = self.network_interfaces

        if self.image_id is not None:
            if hasattr(self.image_id, 'to_dict'):
                props['ImageId'] = self.image_id.to_dict()
            elif isinstance(self.image_id, list):
                props['ImageId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_id
                ]
            else:
                props['ImageId'] = self.image_id

        if self.instance_requirements is not None:
            if hasattr(self.instance_requirements, 'to_dict'):
                props['InstanceRequirements'] = self.instance_requirements.to_dict()
            elif isinstance(self.instance_requirements, list):
                props['InstanceRequirements'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_requirements
                ]
            else:
                props['InstanceRequirements'] = self.instance_requirements

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        if self.monitoring is not None:
            if hasattr(self.monitoring, 'to_dict'):
                props['Monitoring'] = self.monitoring.to_dict()
            elif isinstance(self.monitoring, list):
                props['Monitoring'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring
                ]
            else:
                props['Monitoring'] = self.monitoring

        return props


@dataclass
class SpotFleetMonitoring:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class SpotFleetRequestConfigData:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    context: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_max_total_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    excess_capacity_termination_policy: Optional[Union[str, ExcessCapacityTerminationPolicy, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_specifications: Optional[list[SpotFleetTagSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_pools_to_use_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_template_configs: Optional[list[LaunchTemplateConfig]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_capacity_unit_type: Optional[Union[str, TargetCapacityUnitType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iam_fleet_role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_maintenance_strategies: Optional[SpotMaintenanceStrategies] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    terminate_instances_with_expiration: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    valid_until: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_max_total_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_allocation_strategy: Optional[Union[str, OnDemandAllocationStrategy, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot_price: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allocation_strategy: Optional[Union[str, AllocationStrategy, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand_target_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, FleetType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    launch_specifications: Optional[list[SpotFleetLaunchSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_interruption_behavior: Optional[Union[str, InstanceInterruptionBehavior, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancers_config: Optional[LoadBalancersConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    valid_from: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    replace_unhealthy_instances: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_capacity: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.context is not None:
            if hasattr(self.context, 'to_dict'):
                props['Context'] = self.context.to_dict()
            elif isinstance(self.context, list):
                props['Context'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.context
                ]
            else:
                props['Context'] = self.context

        if self.spot_max_total_price is not None:
            if hasattr(self.spot_max_total_price, 'to_dict'):
                props['SpotMaxTotalPrice'] = self.spot_max_total_price.to_dict()
            elif isinstance(self.spot_max_total_price, list):
                props['SpotMaxTotalPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_max_total_price
                ]
            else:
                props['SpotMaxTotalPrice'] = self.spot_max_total_price

        if self.excess_capacity_termination_policy is not None:
            if hasattr(self.excess_capacity_termination_policy, 'to_dict'):
                props['ExcessCapacityTerminationPolicy'] = self.excess_capacity_termination_policy.to_dict()
            elif isinstance(self.excess_capacity_termination_policy, list):
                props['ExcessCapacityTerminationPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.excess_capacity_termination_policy
                ]
            else:
                props['ExcessCapacityTerminationPolicy'] = self.excess_capacity_termination_policy

        if self.tag_specifications is not None:
            if hasattr(self.tag_specifications, 'to_dict'):
                props['TagSpecifications'] = self.tag_specifications.to_dict()
            elif isinstance(self.tag_specifications, list):
                props['TagSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_specifications
                ]
            else:
                props['TagSpecifications'] = self.tag_specifications

        if self.instance_pools_to_use_count is not None:
            if hasattr(self.instance_pools_to_use_count, 'to_dict'):
                props['InstancePoolsToUseCount'] = self.instance_pools_to_use_count.to_dict()
            elif isinstance(self.instance_pools_to_use_count, list):
                props['InstancePoolsToUseCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_pools_to_use_count
                ]
            else:
                props['InstancePoolsToUseCount'] = self.instance_pools_to_use_count

        if self.launch_template_configs is not None:
            if hasattr(self.launch_template_configs, 'to_dict'):
                props['LaunchTemplateConfigs'] = self.launch_template_configs.to_dict()
            elif isinstance(self.launch_template_configs, list):
                props['LaunchTemplateConfigs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_template_configs
                ]
            else:
                props['LaunchTemplateConfigs'] = self.launch_template_configs

        if self.target_capacity_unit_type is not None:
            if hasattr(self.target_capacity_unit_type, 'to_dict'):
                props['TargetCapacityUnitType'] = self.target_capacity_unit_type.to_dict()
            elif isinstance(self.target_capacity_unit_type, list):
                props['TargetCapacityUnitType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_capacity_unit_type
                ]
            else:
                props['TargetCapacityUnitType'] = self.target_capacity_unit_type

        if self.iam_fleet_role is not None:
            if hasattr(self.iam_fleet_role, 'to_dict'):
                props['IamFleetRole'] = self.iam_fleet_role.to_dict()
            elif isinstance(self.iam_fleet_role, list):
                props['IamFleetRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iam_fleet_role
                ]
            else:
                props['IamFleetRole'] = self.iam_fleet_role

        if self.spot_maintenance_strategies is not None:
            if hasattr(self.spot_maintenance_strategies, 'to_dict'):
                props['SpotMaintenanceStrategies'] = self.spot_maintenance_strategies.to_dict()
            elif isinstance(self.spot_maintenance_strategies, list):
                props['SpotMaintenanceStrategies'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_maintenance_strategies
                ]
            else:
                props['SpotMaintenanceStrategies'] = self.spot_maintenance_strategies

        if self.terminate_instances_with_expiration is not None:
            if hasattr(self.terminate_instances_with_expiration, 'to_dict'):
                props['TerminateInstancesWithExpiration'] = self.terminate_instances_with_expiration.to_dict()
            elif isinstance(self.terminate_instances_with_expiration, list):
                props['TerminateInstancesWithExpiration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.terminate_instances_with_expiration
                ]
            else:
                props['TerminateInstancesWithExpiration'] = self.terminate_instances_with_expiration

        if self.valid_until is not None:
            if hasattr(self.valid_until, 'to_dict'):
                props['ValidUntil'] = self.valid_until.to_dict()
            elif isinstance(self.valid_until, list):
                props['ValidUntil'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.valid_until
                ]
            else:
                props['ValidUntil'] = self.valid_until

        if self.on_demand_max_total_price is not None:
            if hasattr(self.on_demand_max_total_price, 'to_dict'):
                props['OnDemandMaxTotalPrice'] = self.on_demand_max_total_price.to_dict()
            elif isinstance(self.on_demand_max_total_price, list):
                props['OnDemandMaxTotalPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_max_total_price
                ]
            else:
                props['OnDemandMaxTotalPrice'] = self.on_demand_max_total_price

        if self.on_demand_allocation_strategy is not None:
            if hasattr(self.on_demand_allocation_strategy, 'to_dict'):
                props['OnDemandAllocationStrategy'] = self.on_demand_allocation_strategy.to_dict()
            elif isinstance(self.on_demand_allocation_strategy, list):
                props['OnDemandAllocationStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_allocation_strategy
                ]
            else:
                props['OnDemandAllocationStrategy'] = self.on_demand_allocation_strategy

        if self.spot_price is not None:
            if hasattr(self.spot_price, 'to_dict'):
                props['SpotPrice'] = self.spot_price.to_dict()
            elif isinstance(self.spot_price, list):
                props['SpotPrice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_price
                ]
            else:
                props['SpotPrice'] = self.spot_price

        if self.allocation_strategy is not None:
            if hasattr(self.allocation_strategy, 'to_dict'):
                props['AllocationStrategy'] = self.allocation_strategy.to_dict()
            elif isinstance(self.allocation_strategy, list):
                props['AllocationStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allocation_strategy
                ]
            else:
                props['AllocationStrategy'] = self.allocation_strategy

        if self.on_demand_target_capacity is not None:
            if hasattr(self.on_demand_target_capacity, 'to_dict'):
                props['OnDemandTargetCapacity'] = self.on_demand_target_capacity.to_dict()
            elif isinstance(self.on_demand_target_capacity, list):
                props['OnDemandTargetCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand_target_capacity
                ]
            else:
                props['OnDemandTargetCapacity'] = self.on_demand_target_capacity

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.launch_specifications is not None:
            if hasattr(self.launch_specifications, 'to_dict'):
                props['LaunchSpecifications'] = self.launch_specifications.to_dict()
            elif isinstance(self.launch_specifications, list):
                props['LaunchSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.launch_specifications
                ]
            else:
                props['LaunchSpecifications'] = self.launch_specifications

        if self.instance_interruption_behavior is not None:
            if hasattr(self.instance_interruption_behavior, 'to_dict'):
                props['InstanceInterruptionBehavior'] = self.instance_interruption_behavior.to_dict()
            elif isinstance(self.instance_interruption_behavior, list):
                props['InstanceInterruptionBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_interruption_behavior
                ]
            else:
                props['InstanceInterruptionBehavior'] = self.instance_interruption_behavior

        if self.load_balancers_config is not None:
            if hasattr(self.load_balancers_config, 'to_dict'):
                props['LoadBalancersConfig'] = self.load_balancers_config.to_dict()
            elif isinstance(self.load_balancers_config, list):
                props['LoadBalancersConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancers_config
                ]
            else:
                props['LoadBalancersConfig'] = self.load_balancers_config

        if self.valid_from is not None:
            if hasattr(self.valid_from, 'to_dict'):
                props['ValidFrom'] = self.valid_from.to_dict()
            elif isinstance(self.valid_from, list):
                props['ValidFrom'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.valid_from
                ]
            else:
                props['ValidFrom'] = self.valid_from

        if self.replace_unhealthy_instances is not None:
            if hasattr(self.replace_unhealthy_instances, 'to_dict'):
                props['ReplaceUnhealthyInstances'] = self.replace_unhealthy_instances.to_dict()
            elif isinstance(self.replace_unhealthy_instances, list):
                props['ReplaceUnhealthyInstances'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.replace_unhealthy_instances
                ]
            else:
                props['ReplaceUnhealthyInstances'] = self.replace_unhealthy_instances

        if self.target_capacity is not None:
            if hasattr(self.target_capacity, 'to_dict'):
                props['TargetCapacity'] = self.target_capacity.to_dict()
            elif isinstance(self.target_capacity, list):
                props['TargetCapacity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_capacity
                ]
            else:
                props['TargetCapacity'] = self.target_capacity

        return props


@dataclass
class SpotFleetTagSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_type: Optional[Union[str, ResourceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tags: Optional[list[Tag]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_type is not None:
            if hasattr(self.resource_type, 'to_dict'):
                props['ResourceType'] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props['ResourceType'] = self.resource_type

        if self.tags is not None:
            if hasattr(self.tags, 'to_dict'):
                props['Tags'] = self.tags.to_dict()
            elif isinstance(self.tags, list):
                props['Tags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tags
                ]
            else:
                props['Tags'] = self.tags

        return props


@dataclass
class SpotMaintenanceStrategies:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_rebalance: Optional[SpotCapacityRebalance] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capacity_rebalance is not None:
            if hasattr(self.capacity_rebalance, 'to_dict'):
                props['CapacityRebalance'] = self.capacity_rebalance.to_dict()
            elif isinstance(self.capacity_rebalance, list):
                props['CapacityRebalance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_rebalance
                ]
            else:
                props['CapacityRebalance'] = self.capacity_rebalance

        return props


@dataclass
class SpotPlacement:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tenancy: Optional[Union[str, Tenancy, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.group_name is not None:
            if hasattr(self.group_name, 'to_dict'):
                props['GroupName'] = self.group_name.to_dict()
            elif isinstance(self.group_name, list):
                props['GroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_name
                ]
            else:
                props['GroupName'] = self.group_name

        if self.tenancy is not None:
            if hasattr(self.tenancy, 'to_dict'):
                props['Tenancy'] = self.tenancy.to_dict()
            elif isinstance(self.tenancy, list):
                props['Tenancy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tenancy
                ]
            else:
                props['Tenancy'] = self.tenancy

        if self.availability_zone is not None:
            if hasattr(self.availability_zone, 'to_dict'):
                props['AvailabilityZone'] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props['AvailabilityZone'] = self.availability_zone

        return props


@dataclass
class TargetGroup:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.arn is not None:
            if hasattr(self.arn, 'to_dict'):
                props['Arn'] = self.arn.to_dict()
            elif isinstance(self.arn, list):
                props['Arn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.arn
                ]
            else:
                props['Arn'] = self.arn

        return props


@dataclass
class TargetGroupsConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_groups: Optional[list[TargetGroup]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.target_groups is not None:
            if hasattr(self.target_groups, 'to_dict'):
                props['TargetGroups'] = self.target_groups.to_dict()
            elif isinstance(self.target_groups, list):
                props['TargetGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_groups
                ]
            else:
                props['TargetGroups'] = self.target_groups

        return props


@dataclass
class TotalLocalStorageGBRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class VCpuCountRangeRequest:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class SpotFleet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SpotFleet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    spot_fleet_request_config_data: Optional[SpotFleetRequestConfigData] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.spot_fleet_request_config_data is not None:
            # Serialize spot_fleet_request_config_data (handle intrinsic functions)
            if hasattr(self.spot_fleet_request_config_data, 'to_dict'):
                props["SpotFleetRequestConfigData"] = self.spot_fleet_request_config_data.to_dict()
            elif isinstance(self.spot_fleet_request_config_data, list):
                # Serialize list items (may contain intrinsic functions)
                props['SpotFleetRequestConfigData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot_fleet_request_config_data
                ]
            else:
                props["SpotFleetRequestConfigData"] = self.spot_fleet_request_config_data

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class BlockPublicAccessStates:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    internet_gateway_block_mode: Optional[Union[str, BlockPublicAccessMode, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.internet_gateway_block_mode is not None:
            if hasattr(self.internet_gateway_block_mode, 'to_dict'):
                props['InternetGatewayBlockMode'] = self.internet_gateway_block_mode.to_dict()
            elif isinstance(self.internet_gateway_block_mode, list):
                props['InternetGatewayBlockMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internet_gateway_block_mode
                ]
            else:
                props['InternetGatewayBlockMode'] = self.internet_gateway_block_mode

        return props


@dataclass
class PrivateDnsNameOptionsOnLaunch:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_resource_name_dns_a_record: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hostname_type: Optional[Union[str, HostnameType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_resource_name_dns_aaaa_record: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enable_resource_name_dns_a_record is not None:
            if hasattr(self.enable_resource_name_dns_a_record, 'to_dict'):
                props['EnableResourceNameDnsARecord'] = self.enable_resource_name_dns_a_record.to_dict()
            elif isinstance(self.enable_resource_name_dns_a_record, list):
                props['EnableResourceNameDnsARecord'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_resource_name_dns_a_record
                ]
            else:
                props['EnableResourceNameDnsARecord'] = self.enable_resource_name_dns_a_record

        if self.hostname_type is not None:
            if hasattr(self.hostname_type, 'to_dict'):
                props['HostnameType'] = self.hostname_type.to_dict()
            elif isinstance(self.hostname_type, list):
                props['HostnameType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hostname_type
                ]
            else:
                props['HostnameType'] = self.hostname_type

        if self.enable_resource_name_dns_aaaa_record is not None:
            if hasattr(self.enable_resource_name_dns_aaaa_record, 'to_dict'):
                props['EnableResourceNameDnsAAAARecord'] = self.enable_resource_name_dns_aaaa_record.to_dict()
            elif isinstance(self.enable_resource_name_dns_aaaa_record, list):
                props['EnableResourceNameDnsAAAARecord'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_resource_name_dns_aaaa_record
                ]
            else:
                props['EnableResourceNameDnsAAAARecord'] = self.enable_resource_name_dns_aaaa_record

        return props


@dataclass
class Subnet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::Subnet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    map_public_ip_on_launch: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_dns64: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    outpost_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_lni_at_device_index: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    assign_ipv6_address_on_creation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv4_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_dns_name_options_on_launch: Optional[PrivateDnsNameOptionsOnLaunch] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv4_ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_native: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.map_public_ip_on_launch is not None:
            # Serialize map_public_ip_on_launch (handle intrinsic functions)
            if hasattr(self.map_public_ip_on_launch, 'to_dict'):
                props["MapPublicIpOnLaunch"] = self.map_public_ip_on_launch.to_dict()
            elif isinstance(self.map_public_ip_on_launch, list):
                # Serialize list items (may contain intrinsic functions)
                props['MapPublicIpOnLaunch'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.map_public_ip_on_launch
                ]
            else:
                props["MapPublicIpOnLaunch"] = self.map_public_ip_on_launch

        if self.enable_dns64 is not None:
            # Serialize enable_dns64 (handle intrinsic functions)
            if hasattr(self.enable_dns64, 'to_dict'):
                props["EnableDns64"] = self.enable_dns64.to_dict()
            elif isinstance(self.enable_dns64, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableDns64'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_dns64
                ]
            else:
                props["EnableDns64"] = self.enable_dns64

        if self.availability_zone_id is not None:
            # Serialize availability_zone_id (handle intrinsic functions)
            if hasattr(self.availability_zone_id, 'to_dict'):
                props["AvailabilityZoneId"] = self.availability_zone_id.to_dict()
            elif isinstance(self.availability_zone_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZoneId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone_id
                ]
            else:
                props["AvailabilityZoneId"] = self.availability_zone_id

        if self.outpost_arn is not None:
            # Serialize outpost_arn (handle intrinsic functions)
            if hasattr(self.outpost_arn, 'to_dict'):
                props["OutpostArn"] = self.outpost_arn.to_dict()
            elif isinstance(self.outpost_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutpostArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.outpost_arn
                ]
            else:
                props["OutpostArn"] = self.outpost_arn

        if self.availability_zone is not None:
            # Serialize availability_zone (handle intrinsic functions)
            if hasattr(self.availability_zone, 'to_dict'):
                props["AvailabilityZone"] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props["AvailabilityZone"] = self.availability_zone

        if self.cidr_block is not None:
            # Serialize cidr_block (handle intrinsic functions)
            if hasattr(self.cidr_block, 'to_dict'):
                props["CidrBlock"] = self.cidr_block.to_dict()
            elif isinstance(self.cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_block
                ]
            else:
                props["CidrBlock"] = self.cidr_block

        if self.enable_lni_at_device_index is not None:
            # Serialize enable_lni_at_device_index (handle intrinsic functions)
            if hasattr(self.enable_lni_at_device_index, 'to_dict'):
                props["EnableLniAtDeviceIndex"] = self.enable_lni_at_device_index.to_dict()
            elif isinstance(self.enable_lni_at_device_index, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableLniAtDeviceIndex'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_lni_at_device_index
                ]
            else:
                props["EnableLniAtDeviceIndex"] = self.enable_lni_at_device_index

        if self.ipv6_netmask_length is not None:
            # Serialize ipv6_netmask_length (handle intrinsic functions)
            if hasattr(self.ipv6_netmask_length, 'to_dict'):
                props["Ipv6NetmaskLength"] = self.ipv6_netmask_length.to_dict()
            elif isinstance(self.ipv6_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6NetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_netmask_length
                ]
            else:
                props["Ipv6NetmaskLength"] = self.ipv6_netmask_length

        if self.ipv6_ipam_pool_id is not None:
            # Serialize ipv6_ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipv6_ipam_pool_id, 'to_dict'):
                props["Ipv6IpamPoolId"] = self.ipv6_ipam_pool_id.to_dict()
            elif isinstance(self.ipv6_ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_ipam_pool_id
                ]
            else:
                props["Ipv6IpamPoolId"] = self.ipv6_ipam_pool_id

        if self.assign_ipv6_address_on_creation is not None:
            # Serialize assign_ipv6_address_on_creation (handle intrinsic functions)
            if hasattr(self.assign_ipv6_address_on_creation, 'to_dict'):
                props["AssignIpv6AddressOnCreation"] = self.assign_ipv6_address_on_creation.to_dict()
            elif isinstance(self.assign_ipv6_address_on_creation, list):
                # Serialize list items (may contain intrinsic functions)
                props['AssignIpv6AddressOnCreation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.assign_ipv6_address_on_creation
                ]
            else:
                props["AssignIpv6AddressOnCreation"] = self.assign_ipv6_address_on_creation

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.ipv4_netmask_length is not None:
            # Serialize ipv4_netmask_length (handle intrinsic functions)
            if hasattr(self.ipv4_netmask_length, 'to_dict'):
                props["Ipv4NetmaskLength"] = self.ipv4_netmask_length.to_dict()
            elif isinstance(self.ipv4_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv4NetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_netmask_length
                ]
            else:
                props["Ipv4NetmaskLength"] = self.ipv4_netmask_length

        if self.private_dns_name_options_on_launch is not None:
            # Serialize private_dns_name_options_on_launch (handle intrinsic functions)
            if hasattr(self.private_dns_name_options_on_launch, 'to_dict'):
                props["PrivateDnsNameOptionsOnLaunch"] = self.private_dns_name_options_on_launch.to_dict()
            elif isinstance(self.private_dns_name_options_on_launch, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateDnsNameOptionsOnLaunch'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_dns_name_options_on_launch
                ]
            else:
                props["PrivateDnsNameOptionsOnLaunch"] = self.private_dns_name_options_on_launch

        if self.ipv4_ipam_pool_id is not None:
            # Serialize ipv4_ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipv4_ipam_pool_id, 'to_dict'):
                props["Ipv4IpamPoolId"] = self.ipv4_ipam_pool_id.to_dict()
            elif isinstance(self.ipv4_ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv4IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_ipam_pool_id
                ]
            else:
                props["Ipv4IpamPoolId"] = self.ipv4_ipam_pool_id

        if self.ipv6_native is not None:
            # Serialize ipv6_native (handle intrinsic functions)
            if hasattr(self.ipv6_native, 'to_dict'):
                props["Ipv6Native"] = self.ipv6_native.to_dict()
            elif isinstance(self.ipv6_native, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6Native'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_native
                ]
            else:
                props["Ipv6Native"] = self.ipv6_native

        if self.ipv6_cidr_block is not None:
            # Serialize ipv6_cidr_block (handle intrinsic functions)
            if hasattr(self.ipv6_cidr_block, 'to_dict'):
                props["Ipv6CidrBlock"] = self.ipv6_cidr_block.to_dict()
            elif isinstance(self.ipv6_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_cidr_block
                ]
            else:
                props["Ipv6CidrBlock"] = self.ipv6_cidr_block

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_block_public_access_states__internet_gateway_block_mode(self) -> GetAtt:
        """Get the BlockPublicAccessStates.InternetGatewayBlockMode attribute."""
        return self.get_att("BlockPublicAccessStates.InternetGatewayBlockMode")

    @property
    def attr_vpc_id(self) -> GetAtt:
        """Get the VpcId attribute."""
        return self.get_att("VpcId")

    @property
    def attr_network_acl_association_id(self) -> GetAtt:
        """Get the NetworkAclAssociationId attribute."""
        return self.get_att("NetworkAclAssociationId")

    @property
    def attr_availability_zone_id(self) -> GetAtt:
        """Get the AvailabilityZoneId attribute."""
        return self.get_att("AvailabilityZoneId")

    @property
    def attr_outpost_arn(self) -> GetAtt:
        """Get the OutpostArn attribute."""
        return self.get_att("OutpostArn")

    @property
    def attr_availability_zone(self) -> GetAtt:
        """Get the AvailabilityZone attribute."""
        return self.get_att("AvailabilityZone")

    @property
    def attr_cidr_block(self) -> GetAtt:
        """Get the CidrBlock attribute."""
        return self.get_att("CidrBlock")

    @property
    def attr_subnet_id(self) -> GetAtt:
        """Get the SubnetId attribute."""
        return self.get_att("SubnetId")

    @property
    def attr_block_public_access_states(self) -> GetAtt:
        """Get the BlockPublicAccessStates attribute."""
        return self.get_att("BlockPublicAccessStates")

    @property
    def attr_ipv6_cidr_blocks(self) -> GetAtt:
        """Get the Ipv6CidrBlocks attribute."""
        return self.get_att("Ipv6CidrBlocks")




@dataclass
class SubnetCidrBlock(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SubnetCidrBlock"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_netmask_length is not None:
            # Serialize ipv6_netmask_length (handle intrinsic functions)
            if hasattr(self.ipv6_netmask_length, 'to_dict'):
                props["Ipv6NetmaskLength"] = self.ipv6_netmask_length.to_dict()
            elif isinstance(self.ipv6_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6NetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_netmask_length
                ]
            else:
                props["Ipv6NetmaskLength"] = self.ipv6_netmask_length

        if self.ipv6_ipam_pool_id is not None:
            # Serialize ipv6_ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipv6_ipam_pool_id, 'to_dict'):
                props["Ipv6IpamPoolId"] = self.ipv6_ipam_pool_id.to_dict()
            elif isinstance(self.ipv6_ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_ipam_pool_id
                ]
            else:
                props["Ipv6IpamPoolId"] = self.ipv6_ipam_pool_id

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        if self.ipv6_cidr_block is not None:
            # Serialize ipv6_cidr_block (handle intrinsic functions)
            if hasattr(self.ipv6_cidr_block, 'to_dict'):
                props["Ipv6CidrBlock"] = self.ipv6_cidr_block.to_dict()
            elif isinstance(self.ipv6_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_cidr_block
                ]
            else:
                props["Ipv6CidrBlock"] = self.ipv6_cidr_block

        return props

    @property
    def attr_ipv6_address_attribute(self) -> GetAtt:
        """Get the Ipv6AddressAttribute attribute."""
        return self.get_att("Ipv6AddressAttribute")

    @property
    def attr_ip_source(self) -> GetAtt:
        """Get the IpSource attribute."""
        return self.get_att("IpSource")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class SubnetNetworkAclAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SubnetNetworkAclAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_acl_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.network_acl_id is not None:
            # Serialize network_acl_id (handle intrinsic functions)
            if hasattr(self.network_acl_id, 'to_dict'):
                props["NetworkAclId"] = self.network_acl_id.to_dict()
            elif isinstance(self.network_acl_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkAclId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_acl_id
                ]
            else:
                props["NetworkAclId"] = self.network_acl_id

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        return props

    @property
    def attr_association_id(self) -> GetAtt:
        """Get the AssociationId attribute."""
        return self.get_att("AssociationId")




@dataclass
class SubnetRouteTableAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-s"""

    resource_type: ClassVar[str] = "AWS::EC2::SubnetRouteTableAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.route_table_id is not None:
            # Serialize route_table_id (handle intrinsic functions)
            if hasattr(self.route_table_id, 'to_dict'):
                props["RouteTableId"] = self.route_table_id.to_dict()
            elif isinstance(self.route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_id
                ]
            else:
                props["RouteTableId"] = self.route_table_id

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class TrafficMirrorFilter(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TrafficMirrorFilter"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_services: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.network_services is not None:
            # Serialize network_services (handle intrinsic functions)
            if hasattr(self.network_services, 'to_dict'):
                props["NetworkServices"] = self.network_services.to_dict()
            elif isinstance(self.network_services, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkServices'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_services
                ]
            else:
                props["NetworkServices"] = self.network_services

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class TrafficMirrorPortRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.from_port is not None:
            if hasattr(self.from_port, 'to_dict'):
                props['FromPort'] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props['FromPort'] = self.from_port

        if self.to_port is not None:
            if hasattr(self.to_port, 'to_dict'):
                props['ToPort'] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props['ToPort'] = self.to_port

        return props


@dataclass
class TrafficMirrorFilterRule(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TrafficMirrorFilterRule"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_port_range: Optional[TrafficMirrorPortRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_port_range: Optional[TrafficMirrorPortRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rule_action: Optional[Union[str, TrafficMirrorRuleAction, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rule_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    traffic_mirror_filter_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    traffic_direction: Optional[Union[str, TrafficDirection, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    protocol: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination_port_range is not None:
            # Serialize destination_port_range (handle intrinsic functions)
            if hasattr(self.destination_port_range, 'to_dict'):
                props["DestinationPortRange"] = self.destination_port_range.to_dict()
            elif isinstance(self.destination_port_range, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationPortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_port_range
                ]
            else:
                props["DestinationPortRange"] = self.destination_port_range

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.source_port_range is not None:
            # Serialize source_port_range (handle intrinsic functions)
            if hasattr(self.source_port_range, 'to_dict'):
                props["SourcePortRange"] = self.source_port_range.to_dict()
            elif isinstance(self.source_port_range, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourcePortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_port_range
                ]
            else:
                props["SourcePortRange"] = self.source_port_range

        if self.rule_action is not None:
            # Serialize rule_action (handle intrinsic functions)
            if hasattr(self.rule_action, 'to_dict'):
                props["RuleAction"] = self.rule_action.to_dict()
            elif isinstance(self.rule_action, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuleAction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_action
                ]
            else:
                props["RuleAction"] = self.rule_action

        if self.source_cidr_block is not None:
            # Serialize source_cidr_block (handle intrinsic functions)
            if hasattr(self.source_cidr_block, 'to_dict'):
                props["SourceCidrBlock"] = self.source_cidr_block.to_dict()
            elif isinstance(self.source_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_cidr_block
                ]
            else:
                props["SourceCidrBlock"] = self.source_cidr_block

        if self.rule_number is not None:
            # Serialize rule_number (handle intrinsic functions)
            if hasattr(self.rule_number, 'to_dict'):
                props["RuleNumber"] = self.rule_number.to_dict()
            elif isinstance(self.rule_number, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuleNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_number
                ]
            else:
                props["RuleNumber"] = self.rule_number

        if self.destination_cidr_block is not None:
            # Serialize destination_cidr_block (handle intrinsic functions)
            if hasattr(self.destination_cidr_block, 'to_dict'):
                props["DestinationCidrBlock"] = self.destination_cidr_block.to_dict()
            elif isinstance(self.destination_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr_block
                ]
            else:
                props["DestinationCidrBlock"] = self.destination_cidr_block

        if self.traffic_mirror_filter_id is not None:
            # Serialize traffic_mirror_filter_id (handle intrinsic functions)
            if hasattr(self.traffic_mirror_filter_id, 'to_dict'):
                props["TrafficMirrorFilterId"] = self.traffic_mirror_filter_id.to_dict()
            elif isinstance(self.traffic_mirror_filter_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TrafficMirrorFilterId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.traffic_mirror_filter_id
                ]
            else:
                props["TrafficMirrorFilterId"] = self.traffic_mirror_filter_id

        if self.traffic_direction is not None:
            # Serialize traffic_direction (handle intrinsic functions)
            if hasattr(self.traffic_direction, 'to_dict'):
                props["TrafficDirection"] = self.traffic_direction.to_dict()
            elif isinstance(self.traffic_direction, list):
                # Serialize list items (may contain intrinsic functions)
                props['TrafficDirection'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.traffic_direction
                ]
            else:
                props["TrafficDirection"] = self.traffic_direction

        if self.protocol is not None:
            # Serialize protocol (handle intrinsic functions)
            if hasattr(self.protocol, 'to_dict'):
                props["Protocol"] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                # Serialize list items (may contain intrinsic functions)
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props["Protocol"] = self.protocol

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_traffic_mirror_filter_rule_id(self) -> GetAtt:
        """Get the TrafficMirrorFilterRuleId attribute."""
        return self.get_att("TrafficMirrorFilterRuleId")




@dataclass
class TrafficMirrorSession(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TrafficMirrorSession"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    traffic_mirror_target_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    owner_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    session_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    virtual_network_id: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    packet_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    traffic_mirror_filter_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.traffic_mirror_target_id is not None:
            # Serialize traffic_mirror_target_id (handle intrinsic functions)
            if hasattr(self.traffic_mirror_target_id, 'to_dict'):
                props["TrafficMirrorTargetId"] = self.traffic_mirror_target_id.to_dict()
            elif isinstance(self.traffic_mirror_target_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TrafficMirrorTargetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.traffic_mirror_target_id
                ]
            else:
                props["TrafficMirrorTargetId"] = self.traffic_mirror_target_id

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.owner_id is not None:
            # Serialize owner_id (handle intrinsic functions)
            if hasattr(self.owner_id, 'to_dict'):
                props["OwnerId"] = self.owner_id.to_dict()
            elif isinstance(self.owner_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['OwnerId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.owner_id
                ]
            else:
                props["OwnerId"] = self.owner_id

        if self.session_number is not None:
            # Serialize session_number (handle intrinsic functions)
            if hasattr(self.session_number, 'to_dict'):
                props["SessionNumber"] = self.session_number.to_dict()
            elif isinstance(self.session_number, list):
                # Serialize list items (may contain intrinsic functions)
                props['SessionNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.session_number
                ]
            else:
                props["SessionNumber"] = self.session_number

        if self.virtual_network_id is not None:
            # Serialize virtual_network_id (handle intrinsic functions)
            if hasattr(self.virtual_network_id, 'to_dict'):
                props["VirtualNetworkId"] = self.virtual_network_id.to_dict()
            elif isinstance(self.virtual_network_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VirtualNetworkId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.virtual_network_id
                ]
            else:
                props["VirtualNetworkId"] = self.virtual_network_id

        if self.packet_length is not None:
            # Serialize packet_length (handle intrinsic functions)
            if hasattr(self.packet_length, 'to_dict'):
                props["PacketLength"] = self.packet_length.to_dict()
            elif isinstance(self.packet_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['PacketLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.packet_length
                ]
            else:
                props["PacketLength"] = self.packet_length

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        if self.traffic_mirror_filter_id is not None:
            # Serialize traffic_mirror_filter_id (handle intrinsic functions)
            if hasattr(self.traffic_mirror_filter_id, 'to_dict'):
                props["TrafficMirrorFilterId"] = self.traffic_mirror_filter_id.to_dict()
            elif isinstance(self.traffic_mirror_filter_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TrafficMirrorFilterId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.traffic_mirror_filter_id
                ]
            else:
                props["TrafficMirrorFilterId"] = self.traffic_mirror_filter_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class TrafficMirrorTarget(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TrafficMirrorTarget"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_load_balancer_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    gateway_load_balancer_endpoint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.network_load_balancer_arn is not None:
            # Serialize network_load_balancer_arn (handle intrinsic functions)
            if hasattr(self.network_load_balancer_arn, 'to_dict'):
                props["NetworkLoadBalancerArn"] = self.network_load_balancer_arn.to_dict()
            elif isinstance(self.network_load_balancer_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkLoadBalancerArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_load_balancer_arn
                ]
            else:
                props["NetworkLoadBalancerArn"] = self.network_load_balancer_arn

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        if self.gateway_load_balancer_endpoint_id is not None:
            # Serialize gateway_load_balancer_endpoint_id (handle intrinsic functions)
            if hasattr(self.gateway_load_balancer_endpoint_id, 'to_dict'):
                props["GatewayLoadBalancerEndpointId"] = self.gateway_load_balancer_endpoint_id.to_dict()
            elif isinstance(self.gateway_load_balancer_endpoint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['GatewayLoadBalancerEndpointId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gateway_load_balancer_endpoint_id
                ]
            else:
                props["GatewayLoadBalancerEndpointId"] = self.gateway_load_balancer_endpoint_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class TransitGateway(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGateway"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    association_default_route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_accept_shared_attachments: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_route_table_propagation: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_cidr_blocks: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    propagation_default_route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_route_table_association: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpn_ecmp_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_referencing_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    dns_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    multicast_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    amazon_side_asn: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    encryption_support: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.association_default_route_table_id is not None:
            # Serialize association_default_route_table_id (handle intrinsic functions)
            if hasattr(self.association_default_route_table_id, 'to_dict'):
                props["AssociationDefaultRouteTableId"] = self.association_default_route_table_id.to_dict()
            elif isinstance(self.association_default_route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AssociationDefaultRouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.association_default_route_table_id
                ]
            else:
                props["AssociationDefaultRouteTableId"] = self.association_default_route_table_id

        if self.auto_accept_shared_attachments is not None:
            # Serialize auto_accept_shared_attachments (handle intrinsic functions)
            if hasattr(self.auto_accept_shared_attachments, 'to_dict'):
                props["AutoAcceptSharedAttachments"] = self.auto_accept_shared_attachments.to_dict()
            elif isinstance(self.auto_accept_shared_attachments, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoAcceptSharedAttachments'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_accept_shared_attachments
                ]
            else:
                props["AutoAcceptSharedAttachments"] = self.auto_accept_shared_attachments

        if self.default_route_table_propagation is not None:
            # Serialize default_route_table_propagation (handle intrinsic functions)
            if hasattr(self.default_route_table_propagation, 'to_dict'):
                props["DefaultRouteTablePropagation"] = self.default_route_table_propagation.to_dict()
            elif isinstance(self.default_route_table_propagation, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultRouteTablePropagation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_route_table_propagation
                ]
            else:
                props["DefaultRouteTablePropagation"] = self.default_route_table_propagation

        if self.transit_gateway_cidr_blocks is not None:
            # Serialize transit_gateway_cidr_blocks (handle intrinsic functions)
            if hasattr(self.transit_gateway_cidr_blocks, 'to_dict'):
                props["TransitGatewayCidrBlocks"] = self.transit_gateway_cidr_blocks.to_dict()
            elif isinstance(self.transit_gateway_cidr_blocks, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayCidrBlocks'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_cidr_blocks
                ]
            else:
                props["TransitGatewayCidrBlocks"] = self.transit_gateway_cidr_blocks

        if self.propagation_default_route_table_id is not None:
            # Serialize propagation_default_route_table_id (handle intrinsic functions)
            if hasattr(self.propagation_default_route_table_id, 'to_dict'):
                props["PropagationDefaultRouteTableId"] = self.propagation_default_route_table_id.to_dict()
            elif isinstance(self.propagation_default_route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['PropagationDefaultRouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.propagation_default_route_table_id
                ]
            else:
                props["PropagationDefaultRouteTableId"] = self.propagation_default_route_table_id

        if self.default_route_table_association is not None:
            # Serialize default_route_table_association (handle intrinsic functions)
            if hasattr(self.default_route_table_association, 'to_dict'):
                props["DefaultRouteTableAssociation"] = self.default_route_table_association.to_dict()
            elif isinstance(self.default_route_table_association, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultRouteTableAssociation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_route_table_association
                ]
            else:
                props["DefaultRouteTableAssociation"] = self.default_route_table_association

        if self.vpn_ecmp_support is not None:
            # Serialize vpn_ecmp_support (handle intrinsic functions)
            if hasattr(self.vpn_ecmp_support, 'to_dict'):
                props["VpnEcmpSupport"] = self.vpn_ecmp_support.to_dict()
            elif isinstance(self.vpn_ecmp_support, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpnEcmpSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_ecmp_support
                ]
            else:
                props["VpnEcmpSupport"] = self.vpn_ecmp_support

        if self.security_group_referencing_support is not None:
            # Serialize security_group_referencing_support (handle intrinsic functions)
            if hasattr(self.security_group_referencing_support, 'to_dict'):
                props["SecurityGroupReferencingSupport"] = self.security_group_referencing_support.to_dict()
            elif isinstance(self.security_group_referencing_support, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupReferencingSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_referencing_support
                ]
            else:
                props["SecurityGroupReferencingSupport"] = self.security_group_referencing_support

        if self.dns_support is not None:
            # Serialize dns_support (handle intrinsic functions)
            if hasattr(self.dns_support, 'to_dict'):
                props["DnsSupport"] = self.dns_support.to_dict()
            elif isinstance(self.dns_support, list):
                # Serialize list items (may contain intrinsic functions)
                props['DnsSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dns_support
                ]
            else:
                props["DnsSupport"] = self.dns_support

        if self.multicast_support is not None:
            # Serialize multicast_support (handle intrinsic functions)
            if hasattr(self.multicast_support, 'to_dict'):
                props["MulticastSupport"] = self.multicast_support.to_dict()
            elif isinstance(self.multicast_support, list):
                # Serialize list items (may contain intrinsic functions)
                props['MulticastSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.multicast_support
                ]
            else:
                props["MulticastSupport"] = self.multicast_support

        if self.amazon_side_asn is not None:
            # Serialize amazon_side_asn (handle intrinsic functions)
            if hasattr(self.amazon_side_asn, 'to_dict'):
                props["AmazonSideAsn"] = self.amazon_side_asn.to_dict()
            elif isinstance(self.amazon_side_asn, list):
                # Serialize list items (may contain intrinsic functions)
                props['AmazonSideAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.amazon_side_asn
                ]
            else:
                props["AmazonSideAsn"] = self.amazon_side_asn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.encryption_support is not None:
            # Serialize encryption_support (handle intrinsic functions)
            if hasattr(self.encryption_support, 'to_dict'):
                props["EncryptionSupport"] = self.encryption_support.to_dict()
            elif isinstance(self.encryption_support, list):
                # Serialize list items (may contain intrinsic functions)
                props['EncryptionSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encryption_support
                ]
            else:
                props["EncryptionSupport"] = self.encryption_support

        return props

    @property
    def attr_encryption_support_state(self) -> GetAtt:
        """Get the EncryptionSupportState attribute."""
        return self.get_att("EncryptionSupportState")

    @property
    def attr_transit_gateway_arn(self) -> GetAtt:
        """Get the TransitGatewayArn attribute."""
        return self.get_att("TransitGatewayArn")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class Options:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    appliance_mode_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_referencing_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dns_support: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_support is not None:
            if hasattr(self.ipv6_support, 'to_dict'):
                props['Ipv6Support'] = self.ipv6_support.to_dict()
            elif isinstance(self.ipv6_support, list):
                props['Ipv6Support'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_support
                ]
            else:
                props['Ipv6Support'] = self.ipv6_support

        if self.appliance_mode_support is not None:
            if hasattr(self.appliance_mode_support, 'to_dict'):
                props['ApplianceModeSupport'] = self.appliance_mode_support.to_dict()
            elif isinstance(self.appliance_mode_support, list):
                props['ApplianceModeSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.appliance_mode_support
                ]
            else:
                props['ApplianceModeSupport'] = self.appliance_mode_support

        if self.security_group_referencing_support is not None:
            if hasattr(self.security_group_referencing_support, 'to_dict'):
                props['SecurityGroupReferencingSupport'] = self.security_group_referencing_support.to_dict()
            elif isinstance(self.security_group_referencing_support, list):
                props['SecurityGroupReferencingSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_referencing_support
                ]
            else:
                props['SecurityGroupReferencingSupport'] = self.security_group_referencing_support

        if self.dns_support is not None:
            if hasattr(self.dns_support, 'to_dict'):
                props['DnsSupport'] = self.dns_support.to_dict()
            elif isinstance(self.dns_support, list):
                props['DnsSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dns_support
                ]
            else:
                props['DnsSupport'] = self.dns_support

        return props


@dataclass
class TransitGatewayAttachment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayAttachment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    options: Optional[Options] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.options is not None:
            # Serialize options (handle intrinsic functions)
            if hasattr(self.options, 'to_dict'):
                props["Options"] = self.options.to_dict()
            elif isinstance(self.options, list):
                # Serialize list items (may contain intrinsic functions)
                props['Options'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.options
                ]
            else:
                props["Options"] = self.options

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.subnet_ids is not None:
            # Serialize subnet_ids (handle intrinsic functions)
            if hasattr(self.subnet_ids, 'to_dict'):
                props["SubnetIds"] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props["SubnetIds"] = self.subnet_ids

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class TransitGatewayConnectOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, ProtocolValue, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        return props


@dataclass
class TransitGatewayConnect(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayConnect"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    options: Optional[TransitGatewayConnectOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transport_transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.options is not None:
            # Serialize options (handle intrinsic functions)
            if hasattr(self.options, 'to_dict'):
                props["Options"] = self.options.to_dict()
            elif isinstance(self.options, list):
                # Serialize list items (may contain intrinsic functions)
                props['Options'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.options
                ]
            else:
                props["Options"] = self.options

        if self.transport_transit_gateway_attachment_id is not None:
            # Serialize transport_transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.transport_transit_gateway_attachment_id, 'to_dict'):
                props["TransportTransitGatewayAttachmentId"] = self.transport_transit_gateway_attachment_id.to_dict()
            elif isinstance(self.transport_transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransportTransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transport_transit_gateway_attachment_id
                ]
            else:
                props["TransportTransitGatewayAttachmentId"] = self.transport_transit_gateway_attachment_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_transit_gateway_id(self) -> GetAtt:
        """Get the TransitGatewayId attribute."""
        return self.get_att("TransitGatewayId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_transit_gateway_attachment_id(self) -> GetAtt:
        """Get the TransitGatewayAttachmentId attribute."""
        return self.get_att("TransitGatewayAttachmentId")




@dataclass
class TransitGatewayAttachmentBgpConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    peer_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bgp_status: Optional[Union[str, BgpStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    peer_asn: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway_asn: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_address is not None:
            if hasattr(self.transit_gateway_address, 'to_dict'):
                props['TransitGatewayAddress'] = self.transit_gateway_address.to_dict()
            elif isinstance(self.transit_gateway_address, list):
                props['TransitGatewayAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_address
                ]
            else:
                props['TransitGatewayAddress'] = self.transit_gateway_address

        if self.peer_address is not None:
            if hasattr(self.peer_address, 'to_dict'):
                props['PeerAddress'] = self.peer_address.to_dict()
            elif isinstance(self.peer_address, list):
                props['PeerAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_address
                ]
            else:
                props['PeerAddress'] = self.peer_address

        if self.bgp_status is not None:
            if hasattr(self.bgp_status, 'to_dict'):
                props['BgpStatus'] = self.bgp_status.to_dict()
            elif isinstance(self.bgp_status, list):
                props['BgpStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bgp_status
                ]
            else:
                props['BgpStatus'] = self.bgp_status

        if self.peer_asn is not None:
            if hasattr(self.peer_asn, 'to_dict'):
                props['PeerAsn'] = self.peer_asn.to_dict()
            elif isinstance(self.peer_asn, list):
                props['PeerAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_asn
                ]
            else:
                props['PeerAsn'] = self.peer_asn

        if self.transit_gateway_asn is not None:
            if hasattr(self.transit_gateway_asn, 'to_dict'):
                props['TransitGatewayAsn'] = self.transit_gateway_asn.to_dict()
            elif isinstance(self.transit_gateway_asn, list):
                props['TransitGatewayAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_asn
                ]
            else:
                props['TransitGatewayAsn'] = self.transit_gateway_asn

        return props


@dataclass
class TransitGatewayConnectPeerConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transit_gateway_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bgp_configurations: Optional[list[TransitGatewayAttachmentBgpConfiguration]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    peer_address: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inside_cidr_blocks: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, ProtocolValue, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_address is not None:
            if hasattr(self.transit_gateway_address, 'to_dict'):
                props['TransitGatewayAddress'] = self.transit_gateway_address.to_dict()
            elif isinstance(self.transit_gateway_address, list):
                props['TransitGatewayAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_address
                ]
            else:
                props['TransitGatewayAddress'] = self.transit_gateway_address

        if self.bgp_configurations is not None:
            if hasattr(self.bgp_configurations, 'to_dict'):
                props['BgpConfigurations'] = self.bgp_configurations.to_dict()
            elif isinstance(self.bgp_configurations, list):
                props['BgpConfigurations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bgp_configurations
                ]
            else:
                props['BgpConfigurations'] = self.bgp_configurations

        if self.peer_address is not None:
            if hasattr(self.peer_address, 'to_dict'):
                props['PeerAddress'] = self.peer_address.to_dict()
            elif isinstance(self.peer_address, list):
                props['PeerAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_address
                ]
            else:
                props['PeerAddress'] = self.peer_address

        if self.inside_cidr_blocks is not None:
            if hasattr(self.inside_cidr_blocks, 'to_dict'):
                props['InsideCidrBlocks'] = self.inside_cidr_blocks.to_dict()
            elif isinstance(self.inside_cidr_blocks, list):
                props['InsideCidrBlocks'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inside_cidr_blocks
                ]
            else:
                props['InsideCidrBlocks'] = self.inside_cidr_blocks

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        return props


@dataclass
class TransitGatewayConnectPeer(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayConnectPeer"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connect_peer_configuration: Optional[TransitGatewayConnectPeerConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.connect_peer_configuration is not None:
            # Serialize connect_peer_configuration (handle intrinsic functions)
            if hasattr(self.connect_peer_configuration, 'to_dict'):
                props["ConnectPeerConfiguration"] = self.connect_peer_configuration.to_dict()
            elif isinstance(self.connect_peer_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConnectPeerConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connect_peer_configuration
                ]
            else:
                props["ConnectPeerConfiguration"] = self.connect_peer_configuration

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.transit_gateway_attachment_id is not None:
            # Serialize transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_attachment_id, 'to_dict'):
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id.to_dict()
            elif isinstance(self.transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_attachment_id
                ]
            else:
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id

        return props

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_transit_gateway_connect_peer_id(self) -> GetAtt:
        """Get the TransitGatewayConnectPeerId attribute."""
        return self.get_att("TransitGatewayConnectPeerId")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_connect_peer_configuration__protocol(self) -> GetAtt:
        """Get the ConnectPeerConfiguration.Protocol attribute."""
        return self.get_att("ConnectPeerConfiguration.Protocol")

    @property
    def attr_connect_peer_configuration__bgp_configurations(self) -> GetAtt:
        """Get the ConnectPeerConfiguration.BgpConfigurations attribute."""
        return self.get_att("ConnectPeerConfiguration.BgpConfigurations")




@dataclass
class TransitGatewayMeteringPolicy(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayMeteringPolicy"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    middlebox_attachment_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        if self.middlebox_attachment_ids is not None:
            # Serialize middlebox_attachment_ids (handle intrinsic functions)
            if hasattr(self.middlebox_attachment_ids, 'to_dict'):
                props["MiddleboxAttachmentIds"] = self.middlebox_attachment_ids.to_dict()
            elif isinstance(self.middlebox_attachment_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['MiddleboxAttachmentIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.middlebox_attachment_ids
                ]
            else:
                props["MiddleboxAttachmentIds"] = self.middlebox_attachment_ids

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_update_effective_at(self) -> GetAtt:
        """Get the UpdateEffectiveAt attribute."""
        return self.get_att("UpdateEffectiveAt")

    @property
    def attr_transit_gateway_metering_policy_id(self) -> GetAtt:
        """Get the TransitGatewayMeteringPolicyId attribute."""
        return self.get_att("TransitGatewayMeteringPolicyId")




@dataclass
class TransitGatewayMeteringPolicyEntry(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayMeteringPolicyEntry"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_port_range: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metered_account: Optional[Union[str, TransitGatewayMeteringPayerType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_port_range: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_rule_number: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_transit_gateway_attachment_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_metering_policy_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_transit_gateway_attachment_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination_port_range is not None:
            # Serialize destination_port_range (handle intrinsic functions)
            if hasattr(self.destination_port_range, 'to_dict'):
                props["DestinationPortRange"] = self.destination_port_range.to_dict()
            elif isinstance(self.destination_port_range, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationPortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_port_range
                ]
            else:
                props["DestinationPortRange"] = self.destination_port_range

        if self.destination_transit_gateway_attachment_id is not None:
            # Serialize destination_transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.destination_transit_gateway_attachment_id, 'to_dict'):
                props["DestinationTransitGatewayAttachmentId"] = self.destination_transit_gateway_attachment_id.to_dict()
            elif isinstance(self.destination_transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationTransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_transit_gateway_attachment_id
                ]
            else:
                props["DestinationTransitGatewayAttachmentId"] = self.destination_transit_gateway_attachment_id

        if self.metered_account is not None:
            # Serialize metered_account (handle intrinsic functions)
            if hasattr(self.metered_account, 'to_dict'):
                props["MeteredAccount"] = self.metered_account.to_dict()
            elif isinstance(self.metered_account, list):
                # Serialize list items (may contain intrinsic functions)
                props['MeteredAccount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metered_account
                ]
            else:
                props["MeteredAccount"] = self.metered_account

        if self.source_port_range is not None:
            # Serialize source_port_range (handle intrinsic functions)
            if hasattr(self.source_port_range, 'to_dict'):
                props["SourcePortRange"] = self.source_port_range.to_dict()
            elif isinstance(self.source_port_range, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourcePortRange'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_port_range
                ]
            else:
                props["SourcePortRange"] = self.source_port_range

        if self.policy_rule_number is not None:
            # Serialize policy_rule_number (handle intrinsic functions)
            if hasattr(self.policy_rule_number, 'to_dict'):
                props["PolicyRuleNumber"] = self.policy_rule_number.to_dict()
            elif isinstance(self.policy_rule_number, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyRuleNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_rule_number
                ]
            else:
                props["PolicyRuleNumber"] = self.policy_rule_number

        if self.destination_transit_gateway_attachment_type is not None:
            # Serialize destination_transit_gateway_attachment_type (handle intrinsic functions)
            if hasattr(self.destination_transit_gateway_attachment_type, 'to_dict'):
                props["DestinationTransitGatewayAttachmentType"] = self.destination_transit_gateway_attachment_type.to_dict()
            elif isinstance(self.destination_transit_gateway_attachment_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationTransitGatewayAttachmentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_transit_gateway_attachment_type
                ]
            else:
                props["DestinationTransitGatewayAttachmentType"] = self.destination_transit_gateway_attachment_type

        if self.source_cidr_block is not None:
            # Serialize source_cidr_block (handle intrinsic functions)
            if hasattr(self.source_cidr_block, 'to_dict'):
                props["SourceCidrBlock"] = self.source_cidr_block.to_dict()
            elif isinstance(self.source_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_cidr_block
                ]
            else:
                props["SourceCidrBlock"] = self.source_cidr_block

        if self.destination_cidr_block is not None:
            # Serialize destination_cidr_block (handle intrinsic functions)
            if hasattr(self.destination_cidr_block, 'to_dict'):
                props["DestinationCidrBlock"] = self.destination_cidr_block.to_dict()
            elif isinstance(self.destination_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr_block
                ]
            else:
                props["DestinationCidrBlock"] = self.destination_cidr_block

        if self.protocol is not None:
            # Serialize protocol (handle intrinsic functions)
            if hasattr(self.protocol, 'to_dict'):
                props["Protocol"] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                # Serialize list items (may contain intrinsic functions)
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props["Protocol"] = self.protocol

        if self.transit_gateway_metering_policy_id is not None:
            # Serialize transit_gateway_metering_policy_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_metering_policy_id, 'to_dict'):
                props["TransitGatewayMeteringPolicyId"] = self.transit_gateway_metering_policy_id.to_dict()
            elif isinstance(self.transit_gateway_metering_policy_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayMeteringPolicyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_metering_policy_id
                ]
            else:
                props["TransitGatewayMeteringPolicyId"] = self.transit_gateway_metering_policy_id

        if self.source_transit_gateway_attachment_id is not None:
            # Serialize source_transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.source_transit_gateway_attachment_id, 'to_dict'):
                props["SourceTransitGatewayAttachmentId"] = self.source_transit_gateway_attachment_id.to_dict()
            elif isinstance(self.source_transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceTransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_transit_gateway_attachment_id
                ]
            else:
                props["SourceTransitGatewayAttachmentId"] = self.source_transit_gateway_attachment_id

        if self.source_transit_gateway_attachment_type is not None:
            # Serialize source_transit_gateway_attachment_type (handle intrinsic functions)
            if hasattr(self.source_transit_gateway_attachment_type, 'to_dict'):
                props["SourceTransitGatewayAttachmentType"] = self.source_transit_gateway_attachment_type.to_dict()
            elif isinstance(self.source_transit_gateway_attachment_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceTransitGatewayAttachmentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_transit_gateway_attachment_type
                ]
            else:
                props["SourceTransitGatewayAttachmentType"] = self.source_transit_gateway_attachment_type

        return props

    @property
    def attr_update_effective_at(self) -> GetAtt:
        """Get the UpdateEffectiveAt attribute."""
        return self.get_att("UpdateEffectiveAt")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")




@dataclass
class Options:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    static_sources_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auto_accept_shared_associations: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    igmpv2_support: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.static_sources_support is not None:
            if hasattr(self.static_sources_support, 'to_dict'):
                props['StaticSourcesSupport'] = self.static_sources_support.to_dict()
            elif isinstance(self.static_sources_support, list):
                props['StaticSourcesSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.static_sources_support
                ]
            else:
                props['StaticSourcesSupport'] = self.static_sources_support

        if self.auto_accept_shared_associations is not None:
            if hasattr(self.auto_accept_shared_associations, 'to_dict'):
                props['AutoAcceptSharedAssociations'] = self.auto_accept_shared_associations.to_dict()
            elif isinstance(self.auto_accept_shared_associations, list):
                props['AutoAcceptSharedAssociations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_accept_shared_associations
                ]
            else:
                props['AutoAcceptSharedAssociations'] = self.auto_accept_shared_associations

        if self.igmpv2_support is not None:
            if hasattr(self.igmpv2_support, 'to_dict'):
                props['Igmpv2Support'] = self.igmpv2_support.to_dict()
            elif isinstance(self.igmpv2_support, list):
                props['Igmpv2Support'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.igmpv2_support
                ]
            else:
                props['Igmpv2Support'] = self.igmpv2_support

        return props


@dataclass
class TransitGatewayMulticastDomain(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayMulticastDomain"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    options: Optional[Options] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.options is not None:
            # Serialize options (handle intrinsic functions)
            if hasattr(self.options, 'to_dict'):
                props["Options"] = self.options.to_dict()
            elif isinstance(self.options, list):
                # Serialize list items (may contain intrinsic functions)
                props['Options'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.options
                ]
            else:
                props["Options"] = self.options

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_transit_gateway_multicast_domain_arn(self) -> GetAtt:
        """Get the TransitGatewayMulticastDomainArn attribute."""
        return self.get_att("TransitGatewayMulticastDomainArn")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_transit_gateway_multicast_domain_id(self) -> GetAtt:
        """Get the TransitGatewayMulticastDomainId attribute."""
        return self.get_att("TransitGatewayMulticastDomainId")




@dataclass
class TransitGatewayMulticastDomainAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayMulticastDomainAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_multicast_domain_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_multicast_domain_id is not None:
            # Serialize transit_gateway_multicast_domain_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_multicast_domain_id, 'to_dict'):
                props["TransitGatewayMulticastDomainId"] = self.transit_gateway_multicast_domain_id.to_dict()
            elif isinstance(self.transit_gateway_multicast_domain_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayMulticastDomainId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_multicast_domain_id
                ]
            else:
                props["TransitGatewayMulticastDomainId"] = self.transit_gateway_multicast_domain_id

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        if self.transit_gateway_attachment_id is not None:
            # Serialize transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_attachment_id, 'to_dict'):
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id.to_dict()
            elif isinstance(self.transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_attachment_id
                ]
            else:
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id

        return props

    @property
    def attr_resource_id(self) -> GetAtt:
        """Get the ResourceId attribute."""
        return self.get_att("ResourceId")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_resource_type(self) -> GetAtt:
        """Get the ResourceType attribute."""
        return self.get_att("ResourceType")




@dataclass
class TransitGatewayMulticastGroupMember(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayMulticastGroupMember"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_multicast_domain_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_multicast_domain_id is not None:
            # Serialize transit_gateway_multicast_domain_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_multicast_domain_id, 'to_dict'):
                props["TransitGatewayMulticastDomainId"] = self.transit_gateway_multicast_domain_id.to_dict()
            elif isinstance(self.transit_gateway_multicast_domain_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayMulticastDomainId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_multicast_domain_id
                ]
            else:
                props["TransitGatewayMulticastDomainId"] = self.transit_gateway_multicast_domain_id

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        if self.group_ip_address is not None:
            # Serialize group_ip_address (handle intrinsic functions)
            if hasattr(self.group_ip_address, 'to_dict'):
                props["GroupIpAddress"] = self.group_ip_address.to_dict()
            elif isinstance(self.group_ip_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_ip_address
                ]
            else:
                props["GroupIpAddress"] = self.group_ip_address

        return props

    @property
    def attr_group_member(self) -> GetAtt:
        """Get the GroupMember attribute."""
        return self.get_att("GroupMember")

    @property
    def attr_resource_id(self) -> GetAtt:
        """Get the ResourceId attribute."""
        return self.get_att("ResourceId")

    @property
    def attr_member_type(self) -> GetAtt:
        """Get the MemberType attribute."""
        return self.get_att("MemberType")

    @property
    def attr_resource_type(self) -> GetAtt:
        """Get the ResourceType attribute."""
        return self.get_att("ResourceType")

    @property
    def attr_subnet_id(self) -> GetAtt:
        """Get the SubnetId attribute."""
        return self.get_att("SubnetId")

    @property
    def attr_group_source(self) -> GetAtt:
        """Get the GroupSource attribute."""
        return self.get_att("GroupSource")

    @property
    def attr_transit_gateway_attachment_id(self) -> GetAtt:
        """Get the TransitGatewayAttachmentId attribute."""
        return self.get_att("TransitGatewayAttachmentId")




@dataclass
class TransitGatewayMulticastGroupSource(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayMulticastGroupSource"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_multicast_domain_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    group_ip_address: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_multicast_domain_id is not None:
            # Serialize transit_gateway_multicast_domain_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_multicast_domain_id, 'to_dict'):
                props["TransitGatewayMulticastDomainId"] = self.transit_gateway_multicast_domain_id.to_dict()
            elif isinstance(self.transit_gateway_multicast_domain_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayMulticastDomainId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_multicast_domain_id
                ]
            else:
                props["TransitGatewayMulticastDomainId"] = self.transit_gateway_multicast_domain_id

        if self.network_interface_id is not None:
            # Serialize network_interface_id (handle intrinsic functions)
            if hasattr(self.network_interface_id, 'to_dict'):
                props["NetworkInterfaceId"] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props["NetworkInterfaceId"] = self.network_interface_id

        if self.group_ip_address is not None:
            # Serialize group_ip_address (handle intrinsic functions)
            if hasattr(self.group_ip_address, 'to_dict'):
                props["GroupIpAddress"] = self.group_ip_address.to_dict()
            elif isinstance(self.group_ip_address, list):
                # Serialize list items (may contain intrinsic functions)
                props['GroupIpAddress'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group_ip_address
                ]
            else:
                props["GroupIpAddress"] = self.group_ip_address

        return props

    @property
    def attr_group_member(self) -> GetAtt:
        """Get the GroupMember attribute."""
        return self.get_att("GroupMember")

    @property
    def attr_resource_id(self) -> GetAtt:
        """Get the ResourceId attribute."""
        return self.get_att("ResourceId")

    @property
    def attr_source_type(self) -> GetAtt:
        """Get the SourceType attribute."""
        return self.get_att("SourceType")

    @property
    def attr_resource_type(self) -> GetAtt:
        """Get the ResourceType attribute."""
        return self.get_att("ResourceType")

    @property
    def attr_subnet_id(self) -> GetAtt:
        """Get the SubnetId attribute."""
        return self.get_att("SubnetId")

    @property
    def attr_group_source(self) -> GetAtt:
        """Get the GroupSource attribute."""
        return self.get_att("GroupSource")

    @property
    def attr_transit_gateway_attachment_id(self) -> GetAtt:
        """Get the TransitGatewayAttachmentId attribute."""
        return self.get_att("TransitGatewayAttachmentId")




@dataclass
class PeeringAttachmentStatus:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    message: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    code: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.message is not None:
            if hasattr(self.message, 'to_dict'):
                props['Message'] = self.message.to_dict()
            elif isinstance(self.message, list):
                props['Message'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.message
                ]
            else:
                props['Message'] = self.message

        if self.code is not None:
            if hasattr(self.code, 'to_dict'):
                props['Code'] = self.code.to_dict()
            elif isinstance(self.code, list):
                props['Code'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code
                ]
            else:
                props['Code'] = self.code

        return props


@dataclass
class TransitGatewayPeeringAttachment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayPeeringAttachment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_account_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        if self.peer_transit_gateway_id is not None:
            # Serialize peer_transit_gateway_id (handle intrinsic functions)
            if hasattr(self.peer_transit_gateway_id, 'to_dict'):
                props["PeerTransitGatewayId"] = self.peer_transit_gateway_id.to_dict()
            elif isinstance(self.peer_transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerTransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_transit_gateway_id
                ]
            else:
                props["PeerTransitGatewayId"] = self.peer_transit_gateway_id

        if self.peer_account_id is not None:
            # Serialize peer_account_id (handle intrinsic functions)
            if hasattr(self.peer_account_id, 'to_dict'):
                props["PeerAccountId"] = self.peer_account_id.to_dict()
            elif isinstance(self.peer_account_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerAccountId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_account_id
                ]
            else:
                props["PeerAccountId"] = self.peer_account_id

        if self.peer_region is not None:
            # Serialize peer_region (handle intrinsic functions)
            if hasattr(self.peer_region, 'to_dict'):
                props["PeerRegion"] = self.peer_region.to_dict()
            elif isinstance(self.peer_region, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_region
                ]
            else:
                props["PeerRegion"] = self.peer_region

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_status__message(self) -> GetAtt:
        """Get the Status.Message attribute."""
        return self.get_att("Status.Message")

    @property
    def attr_status__code(self) -> GetAtt:
        """Get the Status.Code attribute."""
        return self.get_att("Status.Code")

    @property
    def attr_transit_gateway_attachment_id(self) -> GetAtt:
        """Get the TransitGatewayAttachmentId attribute."""
        return self.get_att("TransitGatewayAttachmentId")




@dataclass
class TransitGatewayRoute(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayRoute"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    blackhole: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_route_table_id is not None:
            # Serialize transit_gateway_route_table_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_route_table_id, 'to_dict'):
                props["TransitGatewayRouteTableId"] = self.transit_gateway_route_table_id.to_dict()
            elif isinstance(self.transit_gateway_route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayRouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_route_table_id
                ]
            else:
                props["TransitGatewayRouteTableId"] = self.transit_gateway_route_table_id

        if self.destination_cidr_block is not None:
            # Serialize destination_cidr_block (handle intrinsic functions)
            if hasattr(self.destination_cidr_block, 'to_dict'):
                props["DestinationCidrBlock"] = self.destination_cidr_block.to_dict()
            elif isinstance(self.destination_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr_block
                ]
            else:
                props["DestinationCidrBlock"] = self.destination_cidr_block

        if self.blackhole is not None:
            # Serialize blackhole (handle intrinsic functions)
            if hasattr(self.blackhole, 'to_dict'):
                props["Blackhole"] = self.blackhole.to_dict()
            elif isinstance(self.blackhole, list):
                # Serialize list items (may contain intrinsic functions)
                props['Blackhole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.blackhole
                ]
            else:
                props["Blackhole"] = self.blackhole

        if self.transit_gateway_attachment_id is not None:
            # Serialize transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_attachment_id, 'to_dict'):
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id.to_dict()
            elif isinstance(self.transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_attachment_id
                ]
            else:
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id

        return props



@dataclass
class TransitGatewayRouteTable(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayRouteTable"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_transit_gateway_route_table_id(self) -> GetAtt:
        """Get the TransitGatewayRouteTableId attribute."""
        return self.get_att("TransitGatewayRouteTableId")




@dataclass
class TransitGatewayRouteTableAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayRouteTableAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_route_table_id is not None:
            # Serialize transit_gateway_route_table_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_route_table_id, 'to_dict'):
                props["TransitGatewayRouteTableId"] = self.transit_gateway_route_table_id.to_dict()
            elif isinstance(self.transit_gateway_route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayRouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_route_table_id
                ]
            else:
                props["TransitGatewayRouteTableId"] = self.transit_gateway_route_table_id

        if self.transit_gateway_attachment_id is not None:
            # Serialize transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_attachment_id, 'to_dict'):
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id.to_dict()
            elif isinstance(self.transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_attachment_id
                ]
            else:
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id

        return props



@dataclass
class TransitGatewayRouteTablePropagation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayRouteTablePropagation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_route_table_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_route_table_id is not None:
            # Serialize transit_gateway_route_table_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_route_table_id, 'to_dict'):
                props["TransitGatewayRouteTableId"] = self.transit_gateway_route_table_id.to_dict()
            elif isinstance(self.transit_gateway_route_table_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayRouteTableId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_route_table_id
                ]
            else:
                props["TransitGatewayRouteTableId"] = self.transit_gateway_route_table_id

        if self.transit_gateway_attachment_id is not None:
            # Serialize transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_attachment_id, 'to_dict'):
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id.to_dict()
            elif isinstance(self.transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_attachment_id
                ]
            else:
                props["TransitGatewayAttachmentId"] = self.transit_gateway_attachment_id

        return props



@dataclass
class Options:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ipv6_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    appliance_mode_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_referencing_support: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dns_support: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_support is not None:
            if hasattr(self.ipv6_support, 'to_dict'):
                props['Ipv6Support'] = self.ipv6_support.to_dict()
            elif isinstance(self.ipv6_support, list):
                props['Ipv6Support'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_support
                ]
            else:
                props['Ipv6Support'] = self.ipv6_support

        if self.appliance_mode_support is not None:
            if hasattr(self.appliance_mode_support, 'to_dict'):
                props['ApplianceModeSupport'] = self.appliance_mode_support.to_dict()
            elif isinstance(self.appliance_mode_support, list):
                props['ApplianceModeSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.appliance_mode_support
                ]
            else:
                props['ApplianceModeSupport'] = self.appliance_mode_support

        if self.security_group_referencing_support is not None:
            if hasattr(self.security_group_referencing_support, 'to_dict'):
                props['SecurityGroupReferencingSupport'] = self.security_group_referencing_support.to_dict()
            elif isinstance(self.security_group_referencing_support, list):
                props['SecurityGroupReferencingSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_referencing_support
                ]
            else:
                props['SecurityGroupReferencingSupport'] = self.security_group_referencing_support

        if self.dns_support is not None:
            if hasattr(self.dns_support, 'to_dict'):
                props['DnsSupport'] = self.dns_support.to_dict()
            elif isinstance(self.dns_support, list):
                props['DnsSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dns_support
                ]
            else:
                props['DnsSupport'] = self.dns_support

        return props


@dataclass
class TransitGatewayVpcAttachment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-t"""

    resource_type: ClassVar[str] = "AWS::EC2::TransitGatewayVpcAttachment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    options: Optional[Options] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    remove_subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    add_subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.options is not None:
            # Serialize options (handle intrinsic functions)
            if hasattr(self.options, 'to_dict'):
                props["Options"] = self.options.to_dict()
            elif isinstance(self.options, list):
                # Serialize list items (may contain intrinsic functions)
                props['Options'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.options
                ]
            else:
                props["Options"] = self.options

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.remove_subnet_ids is not None:
            # Serialize remove_subnet_ids (handle intrinsic functions)
            if hasattr(self.remove_subnet_ids, 'to_dict'):
                props["RemoveSubnetIds"] = self.remove_subnet_ids.to_dict()
            elif isinstance(self.remove_subnet_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['RemoveSubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.remove_subnet_ids
                ]
            else:
                props["RemoveSubnetIds"] = self.remove_subnet_ids

        if self.subnet_ids is not None:
            # Serialize subnet_ids (handle intrinsic functions)
            if hasattr(self.subnet_ids, 'to_dict'):
                props["SubnetIds"] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props["SubnetIds"] = self.subnet_ids

        if self.add_subnet_ids is not None:
            # Serialize add_subnet_ids (handle intrinsic functions)
            if hasattr(self.add_subnet_ids, 'to_dict'):
                props["AddSubnetIds"] = self.add_subnet_ids.to_dict()
            elif isinstance(self.add_subnet_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['AddSubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.add_subnet_ids
                ]
            else:
                props["AddSubnetIds"] = self.add_subnet_ids

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class VPC(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPC"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_tenancy: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv4_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv4_ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_dns_support: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_dns_hostnames: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_tenancy is not None:
            # Serialize instance_tenancy (handle intrinsic functions)
            if hasattr(self.instance_tenancy, 'to_dict'):
                props["InstanceTenancy"] = self.instance_tenancy.to_dict()
            elif isinstance(self.instance_tenancy, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceTenancy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_tenancy
                ]
            else:
                props["InstanceTenancy"] = self.instance_tenancy

        if self.ipv4_netmask_length is not None:
            # Serialize ipv4_netmask_length (handle intrinsic functions)
            if hasattr(self.ipv4_netmask_length, 'to_dict'):
                props["Ipv4NetmaskLength"] = self.ipv4_netmask_length.to_dict()
            elif isinstance(self.ipv4_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv4NetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_netmask_length
                ]
            else:
                props["Ipv4NetmaskLength"] = self.ipv4_netmask_length

        if self.cidr_block is not None:
            # Serialize cidr_block (handle intrinsic functions)
            if hasattr(self.cidr_block, 'to_dict'):
                props["CidrBlock"] = self.cidr_block.to_dict()
            elif isinstance(self.cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_block
                ]
            else:
                props["CidrBlock"] = self.cidr_block

        if self.ipv4_ipam_pool_id is not None:
            # Serialize ipv4_ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipv4_ipam_pool_id, 'to_dict'):
                props["Ipv4IpamPoolId"] = self.ipv4_ipam_pool_id.to_dict()
            elif isinstance(self.ipv4_ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv4IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_ipam_pool_id
                ]
            else:
                props["Ipv4IpamPoolId"] = self.ipv4_ipam_pool_id

        if self.enable_dns_support is not None:
            # Serialize enable_dns_support (handle intrinsic functions)
            if hasattr(self.enable_dns_support, 'to_dict'):
                props["EnableDnsSupport"] = self.enable_dns_support.to_dict()
            elif isinstance(self.enable_dns_support, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableDnsSupport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_dns_support
                ]
            else:
                props["EnableDnsSupport"] = self.enable_dns_support

        if self.enable_dns_hostnames is not None:
            # Serialize enable_dns_hostnames (handle intrinsic functions)
            if hasattr(self.enable_dns_hostnames, 'to_dict'):
                props["EnableDnsHostnames"] = self.enable_dns_hostnames.to_dict()
            elif isinstance(self.enable_dns_hostnames, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableDnsHostnames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_dns_hostnames
                ]
            else:
                props["EnableDnsHostnames"] = self.enable_dns_hostnames

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_vpc_id(self) -> GetAtt:
        """Get the VpcId attribute."""
        return self.get_att("VpcId")

    @property
    def attr_cidr_block_associations(self) -> GetAtt:
        """Get the CidrBlockAssociations attribute."""
        return self.get_att("CidrBlockAssociations")

    @property
    def attr_cidr_block(self) -> GetAtt:
        """Get the CidrBlock attribute."""
        return self.get_att("CidrBlock")

    @property
    def attr_default_network_acl(self) -> GetAtt:
        """Get the DefaultNetworkAcl attribute."""
        return self.get_att("DefaultNetworkAcl")

    @property
    def attr_ipv6_cidr_blocks(self) -> GetAtt:
        """Get the Ipv6CidrBlocks attribute."""
        return self.get_att("Ipv6CidrBlocks")

    @property
    def attr_default_security_group(self) -> GetAtt:
        """Get the DefaultSecurityGroup attribute."""
        return self.get_att("DefaultSecurityGroup")




@dataclass
class VPCBlockPublicAccessExclusion(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCBlockPublicAccessExclusion"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    internet_gateway_exclusion_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.internet_gateway_exclusion_mode is not None:
            # Serialize internet_gateway_exclusion_mode (handle intrinsic functions)
            if hasattr(self.internet_gateway_exclusion_mode, 'to_dict'):
                props["InternetGatewayExclusionMode"] = self.internet_gateway_exclusion_mode.to_dict()
            elif isinstance(self.internet_gateway_exclusion_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['InternetGatewayExclusionMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internet_gateway_exclusion_mode
                ]
            else:
                props["InternetGatewayExclusionMode"] = self.internet_gateway_exclusion_mode

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_exclusion_id(self) -> GetAtt:
        """Get the ExclusionId attribute."""
        return self.get_att("ExclusionId")




@dataclass
class VPCBlockPublicAccessOptions(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCBlockPublicAccessOptions"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    internet_gateway_block_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.internet_gateway_block_mode is not None:
            # Serialize internet_gateway_block_mode (handle intrinsic functions)
            if hasattr(self.internet_gateway_block_mode, 'to_dict'):
                props["InternetGatewayBlockMode"] = self.internet_gateway_block_mode.to_dict()
            elif isinstance(self.internet_gateway_block_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['InternetGatewayBlockMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internet_gateway_block_mode
                ]
            else:
                props["InternetGatewayBlockMode"] = self.internet_gateway_block_mode

        return props

    @property
    def attr_account_id(self) -> GetAtt:
        """Get the AccountId attribute."""
        return self.get_att("AccountId")

    @property
    def attr_exclusions_allowed(self) -> GetAtt:
        """Get the ExclusionsAllowed attribute."""
        return self.get_att("ExclusionsAllowed")




@dataclass
class VPCCidrBlock(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCCidrBlock"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv4_netmask_length: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_cidr_block_network_border_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_pool: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv4_ipam_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ipv6_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    amazon_provided_ipv6_cidr_block: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ipv6_netmask_length is not None:
            # Serialize ipv6_netmask_length (handle intrinsic functions)
            if hasattr(self.ipv6_netmask_length, 'to_dict'):
                props["Ipv6NetmaskLength"] = self.ipv6_netmask_length.to_dict()
            elif isinstance(self.ipv6_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6NetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_netmask_length
                ]
            else:
                props["Ipv6NetmaskLength"] = self.ipv6_netmask_length

        if self.ipv6_ipam_pool_id is not None:
            # Serialize ipv6_ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipv6_ipam_pool_id, 'to_dict'):
                props["Ipv6IpamPoolId"] = self.ipv6_ipam_pool_id.to_dict()
            elif isinstance(self.ipv6_ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_ipam_pool_id
                ]
            else:
                props["Ipv6IpamPoolId"] = self.ipv6_ipam_pool_id

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.ipv4_netmask_length is not None:
            # Serialize ipv4_netmask_length (handle intrinsic functions)
            if hasattr(self.ipv4_netmask_length, 'to_dict'):
                props["Ipv4NetmaskLength"] = self.ipv4_netmask_length.to_dict()
            elif isinstance(self.ipv4_netmask_length, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv4NetmaskLength'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_netmask_length
                ]
            else:
                props["Ipv4NetmaskLength"] = self.ipv4_netmask_length

        if self.ipv6_cidr_block_network_border_group is not None:
            # Serialize ipv6_cidr_block_network_border_group (handle intrinsic functions)
            if hasattr(self.ipv6_cidr_block_network_border_group, 'to_dict'):
                props["Ipv6CidrBlockNetworkBorderGroup"] = self.ipv6_cidr_block_network_border_group.to_dict()
            elif isinstance(self.ipv6_cidr_block_network_border_group, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6CidrBlockNetworkBorderGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_cidr_block_network_border_group
                ]
            else:
                props["Ipv6CidrBlockNetworkBorderGroup"] = self.ipv6_cidr_block_network_border_group

        if self.cidr_block is not None:
            # Serialize cidr_block (handle intrinsic functions)
            if hasattr(self.cidr_block, 'to_dict'):
                props["CidrBlock"] = self.cidr_block.to_dict()
            elif isinstance(self.cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_block
                ]
            else:
                props["CidrBlock"] = self.cidr_block

        if self.ipv6_pool is not None:
            # Serialize ipv6_pool (handle intrinsic functions)
            if hasattr(self.ipv6_pool, 'to_dict'):
                props["Ipv6Pool"] = self.ipv6_pool.to_dict()
            elif isinstance(self.ipv6_pool, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6Pool'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_pool
                ]
            else:
                props["Ipv6Pool"] = self.ipv6_pool

        if self.ipv4_ipam_pool_id is not None:
            # Serialize ipv4_ipam_pool_id (handle intrinsic functions)
            if hasattr(self.ipv4_ipam_pool_id, 'to_dict'):
                props["Ipv4IpamPoolId"] = self.ipv4_ipam_pool_id.to_dict()
            elif isinstance(self.ipv4_ipam_pool_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv4IpamPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv4_ipam_pool_id
                ]
            else:
                props["Ipv4IpamPoolId"] = self.ipv4_ipam_pool_id

        if self.ipv6_cidr_block is not None:
            # Serialize ipv6_cidr_block (handle intrinsic functions)
            if hasattr(self.ipv6_cidr_block, 'to_dict'):
                props["Ipv6CidrBlock"] = self.ipv6_cidr_block.to_dict()
            elif isinstance(self.ipv6_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['Ipv6CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ipv6_cidr_block
                ]
            else:
                props["Ipv6CidrBlock"] = self.ipv6_cidr_block

        if self.amazon_provided_ipv6_cidr_block is not None:
            # Serialize amazon_provided_ipv6_cidr_block (handle intrinsic functions)
            if hasattr(self.amazon_provided_ipv6_cidr_block, 'to_dict'):
                props["AmazonProvidedIpv6CidrBlock"] = self.amazon_provided_ipv6_cidr_block.to_dict()
            elif isinstance(self.amazon_provided_ipv6_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['AmazonProvidedIpv6CidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.amazon_provided_ipv6_cidr_block
                ]
            else:
                props["AmazonProvidedIpv6CidrBlock"] = self.amazon_provided_ipv6_cidr_block

        return props

    @property
    def attr_ipv6_address_attribute(self) -> GetAtt:
        """Get the Ipv6AddressAttribute attribute."""
        return self.get_att("Ipv6AddressAttribute")

    @property
    def attr_ip_source(self) -> GetAtt:
        """Get the IpSource attribute."""
        return self.get_att("IpSource")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class VPCDHCPOptionsAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCDHCPOptionsAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    dhcp_options_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.dhcp_options_id is not None:
            # Serialize dhcp_options_id (handle intrinsic functions)
            if hasattr(self.dhcp_options_id, 'to_dict'):
                props["DhcpOptionsId"] = self.dhcp_options_id.to_dict()
            elif isinstance(self.dhcp_options_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DhcpOptionsId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dhcp_options_id
                ]
            else:
                props["DhcpOptionsId"] = self.dhcp_options_id

        return props



@dataclass
class ResourceExclusions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    elastic_file_system: Optional[VpcEncryptionControlExclusion] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_lattice: Optional[VpcEncryptionControlExclusion] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_peering: Optional[VpcEncryptionControlExclusion] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    internet_gateway: Optional[VpcEncryptionControlExclusion] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    egress_only_internet_gateway: Optional[VpcEncryptionControlExclusion] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    virtual_private_gateway: Optional[VpcEncryptionControlExclusion] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    nat_gateway: Optional[VpcEncryptionControlExclusion] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lambda_: Optional[VpcEncryptionControlExclusion] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.elastic_file_system is not None:
            if hasattr(self.elastic_file_system, 'to_dict'):
                props['ElasticFileSystem'] = self.elastic_file_system.to_dict()
            elif isinstance(self.elastic_file_system, list):
                props['ElasticFileSystem'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.elastic_file_system
                ]
            else:
                props['ElasticFileSystem'] = self.elastic_file_system

        if self.vpc_lattice is not None:
            if hasattr(self.vpc_lattice, 'to_dict'):
                props['VpcLattice'] = self.vpc_lattice.to_dict()
            elif isinstance(self.vpc_lattice, list):
                props['VpcLattice'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_lattice
                ]
            else:
                props['VpcLattice'] = self.vpc_lattice

        if self.vpc_peering is not None:
            if hasattr(self.vpc_peering, 'to_dict'):
                props['VpcPeering'] = self.vpc_peering.to_dict()
            elif isinstance(self.vpc_peering, list):
                props['VpcPeering'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_peering
                ]
            else:
                props['VpcPeering'] = self.vpc_peering

        if self.internet_gateway is not None:
            if hasattr(self.internet_gateway, 'to_dict'):
                props['InternetGateway'] = self.internet_gateway.to_dict()
            elif isinstance(self.internet_gateway, list):
                props['InternetGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internet_gateway
                ]
            else:
                props['InternetGateway'] = self.internet_gateway

        if self.egress_only_internet_gateway is not None:
            if hasattr(self.egress_only_internet_gateway, 'to_dict'):
                props['EgressOnlyInternetGateway'] = self.egress_only_internet_gateway.to_dict()
            elif isinstance(self.egress_only_internet_gateway, list):
                props['EgressOnlyInternetGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.egress_only_internet_gateway
                ]
            else:
                props['EgressOnlyInternetGateway'] = self.egress_only_internet_gateway

        if self.virtual_private_gateway is not None:
            if hasattr(self.virtual_private_gateway, 'to_dict'):
                props['VirtualPrivateGateway'] = self.virtual_private_gateway.to_dict()
            elif isinstance(self.virtual_private_gateway, list):
                props['VirtualPrivateGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.virtual_private_gateway
                ]
            else:
                props['VirtualPrivateGateway'] = self.virtual_private_gateway

        if self.nat_gateway is not None:
            if hasattr(self.nat_gateway, 'to_dict'):
                props['NatGateway'] = self.nat_gateway.to_dict()
            elif isinstance(self.nat_gateway, list):
                props['NatGateway'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.nat_gateway
                ]
            else:
                props['NatGateway'] = self.nat_gateway

        if self.lambda_ is not None:
            if hasattr(self.lambda_, 'to_dict'):
                props['Lambda'] = self.lambda_.to_dict()
            elif isinstance(self.lambda_, list):
                props['Lambda'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lambda_
                ]
            else:
                props['Lambda'] = self.lambda_

        return props


@dataclass
class VpcEncryptionControlExclusion:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    state: Optional[Union[str, VpcEncryptionControlExclusionState, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    state_message: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.state is not None:
            if hasattr(self.state, 'to_dict'):
                props['State'] = self.state.to_dict()
            elif isinstance(self.state, list):
                props['State'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state
                ]
            else:
                props['State'] = self.state

        if self.state_message is not None:
            if hasattr(self.state_message, 'to_dict'):
                props['StateMessage'] = self.state_message.to_dict()
            elif isinstance(self.state_message, list):
                props['StateMessage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.state_message
                ]
            else:
                props['StateMessage'] = self.state_message

        return props


@dataclass
class VPCEncryptionControl(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCEncryptionControl"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_peering_exclusion_input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    elastic_file_system_exclusion_input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_lattice_exclusion_input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    nat_gateway_exclusion_input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    egress_only_internet_gateway_exclusion_input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    virtual_private_gateway_exclusion_input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    internet_gateway_exclusion_input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    lambda_exclusion_input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_peering_exclusion_input is not None:
            # Serialize vpc_peering_exclusion_input (handle intrinsic functions)
            if hasattr(self.vpc_peering_exclusion_input, 'to_dict'):
                props["VpcPeeringExclusionInput"] = self.vpc_peering_exclusion_input.to_dict()
            elif isinstance(self.vpc_peering_exclusion_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcPeeringExclusionInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_peering_exclusion_input
                ]
            else:
                props["VpcPeeringExclusionInput"] = self.vpc_peering_exclusion_input

        if self.elastic_file_system_exclusion_input is not None:
            # Serialize elastic_file_system_exclusion_input (handle intrinsic functions)
            if hasattr(self.elastic_file_system_exclusion_input, 'to_dict'):
                props["ElasticFileSystemExclusionInput"] = self.elastic_file_system_exclusion_input.to_dict()
            elif isinstance(self.elastic_file_system_exclusion_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['ElasticFileSystemExclusionInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.elastic_file_system_exclusion_input
                ]
            else:
                props["ElasticFileSystemExclusionInput"] = self.elastic_file_system_exclusion_input

        if self.vpc_lattice_exclusion_input is not None:
            # Serialize vpc_lattice_exclusion_input (handle intrinsic functions)
            if hasattr(self.vpc_lattice_exclusion_input, 'to_dict'):
                props["VpcLatticeExclusionInput"] = self.vpc_lattice_exclusion_input.to_dict()
            elif isinstance(self.vpc_lattice_exclusion_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcLatticeExclusionInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_lattice_exclusion_input
                ]
            else:
                props["VpcLatticeExclusionInput"] = self.vpc_lattice_exclusion_input

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.nat_gateway_exclusion_input is not None:
            # Serialize nat_gateway_exclusion_input (handle intrinsic functions)
            if hasattr(self.nat_gateway_exclusion_input, 'to_dict'):
                props["NatGatewayExclusionInput"] = self.nat_gateway_exclusion_input.to_dict()
            elif isinstance(self.nat_gateway_exclusion_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['NatGatewayExclusionInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.nat_gateway_exclusion_input
                ]
            else:
                props["NatGatewayExclusionInput"] = self.nat_gateway_exclusion_input

        if self.egress_only_internet_gateway_exclusion_input is not None:
            # Serialize egress_only_internet_gateway_exclusion_input (handle intrinsic functions)
            if hasattr(self.egress_only_internet_gateway_exclusion_input, 'to_dict'):
                props["EgressOnlyInternetGatewayExclusionInput"] = self.egress_only_internet_gateway_exclusion_input.to_dict()
            elif isinstance(self.egress_only_internet_gateway_exclusion_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['EgressOnlyInternetGatewayExclusionInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.egress_only_internet_gateway_exclusion_input
                ]
            else:
                props["EgressOnlyInternetGatewayExclusionInput"] = self.egress_only_internet_gateway_exclusion_input

        if self.virtual_private_gateway_exclusion_input is not None:
            # Serialize virtual_private_gateway_exclusion_input (handle intrinsic functions)
            if hasattr(self.virtual_private_gateway_exclusion_input, 'to_dict'):
                props["VirtualPrivateGatewayExclusionInput"] = self.virtual_private_gateway_exclusion_input.to_dict()
            elif isinstance(self.virtual_private_gateway_exclusion_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['VirtualPrivateGatewayExclusionInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.virtual_private_gateway_exclusion_input
                ]
            else:
                props["VirtualPrivateGatewayExclusionInput"] = self.virtual_private_gateway_exclusion_input

        if self.mode is not None:
            # Serialize mode (handle intrinsic functions)
            if hasattr(self.mode, 'to_dict'):
                props["Mode"] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props["Mode"] = self.mode

        if self.internet_gateway_exclusion_input is not None:
            # Serialize internet_gateway_exclusion_input (handle intrinsic functions)
            if hasattr(self.internet_gateway_exclusion_input, 'to_dict'):
                props["InternetGatewayExclusionInput"] = self.internet_gateway_exclusion_input.to_dict()
            elif isinstance(self.internet_gateway_exclusion_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['InternetGatewayExclusionInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internet_gateway_exclusion_input
                ]
            else:
                props["InternetGatewayExclusionInput"] = self.internet_gateway_exclusion_input

        if self.lambda_exclusion_input is not None:
            # Serialize lambda_exclusion_input (handle intrinsic functions)
            if hasattr(self.lambda_exclusion_input, 'to_dict'):
                props["LambdaExclusionInput"] = self.lambda_exclusion_input.to_dict()
            elif isinstance(self.lambda_exclusion_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['LambdaExclusionInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lambda_exclusion_input
                ]
            else:
                props["LambdaExclusionInput"] = self.lambda_exclusion_input

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_resource_exclusions__elastic_file_system__state(self) -> GetAtt:
        """Get the ResourceExclusions.ElasticFileSystem.State attribute."""
        return self.get_att("ResourceExclusions.ElasticFileSystem.State")

    @property
    def attr_resource_exclusions__vpc_lattice__state(self) -> GetAtt:
        """Get the ResourceExclusions.VpcLattice.State attribute."""
        return self.get_att("ResourceExclusions.VpcLattice.State")

    @property
    def attr_resource_exclusions__virtual_private_gateway__state_message(self) -> GetAtt:
        """Get the ResourceExclusions.VirtualPrivateGateway.StateMessage attribute."""
        return self.get_att("ResourceExclusions.VirtualPrivateGateway.StateMessage")

    @property
    def attr_vpc_encryption_control_id(self) -> GetAtt:
        """Get the VpcEncryptionControlId attribute."""
        return self.get_att("VpcEncryptionControlId")

    @property
    def attr_resource_exclusions__vpc_lattice(self) -> GetAtt:
        """Get the ResourceExclusions.VpcLattice attribute."""
        return self.get_att("ResourceExclusions.VpcLattice")

    @property
    def attr_resource_exclusions__lambda(self) -> GetAtt:
        """Get the ResourceExclusions.Lambda attribute."""
        return self.get_att("ResourceExclusions.Lambda")

    @property
    def attr_resource_exclusions__nat_gateway__state(self) -> GetAtt:
        """Get the ResourceExclusions.NatGateway.State attribute."""
        return self.get_att("ResourceExclusions.NatGateway.State")

    @property
    def attr_resource_exclusions__internet_gateway(self) -> GetAtt:
        """Get the ResourceExclusions.InternetGateway attribute."""
        return self.get_att("ResourceExclusions.InternetGateway")

    @property
    def attr_resource_exclusions__virtual_private_gateway(self) -> GetAtt:
        """Get the ResourceExclusions.VirtualPrivateGateway attribute."""
        return self.get_att("ResourceExclusions.VirtualPrivateGateway")

    @property
    def attr_state_message(self) -> GetAtt:
        """Get the StateMessage attribute."""
        return self.get_att("StateMessage")

    @property
    def attr_resource_exclusions__egress_only_internet_gateway__state_message(self) -> GetAtt:
        """Get the ResourceExclusions.EgressOnlyInternetGateway.StateMessage attribute."""
        return self.get_att("ResourceExclusions.EgressOnlyInternetGateway.StateMessage")

    @property
    def attr_resource_exclusions__nat_gateway(self) -> GetAtt:
        """Get the ResourceExclusions.NatGateway attribute."""
        return self.get_att("ResourceExclusions.NatGateway")

    @property
    def attr_resource_exclusions__vpc_peering(self) -> GetAtt:
        """Get the ResourceExclusions.VpcPeering attribute."""
        return self.get_att("ResourceExclusions.VpcPeering")

    @property
    def attr_resource_exclusions__egress_only_internet_gateway(self) -> GetAtt:
        """Get the ResourceExclusions.EgressOnlyInternetGateway attribute."""
        return self.get_att("ResourceExclusions.EgressOnlyInternetGateway")

    @property
    def attr_resource_exclusions__internet_gateway__state(self) -> GetAtt:
        """Get the ResourceExclusions.InternetGateway.State attribute."""
        return self.get_att("ResourceExclusions.InternetGateway.State")

    @property
    def attr_resource_exclusions__elastic_file_system__state_message(self) -> GetAtt:
        """Get the ResourceExclusions.ElasticFileSystem.StateMessage attribute."""
        return self.get_att("ResourceExclusions.ElasticFileSystem.StateMessage")

    @property
    def attr_resource_exclusions__elastic_file_system(self) -> GetAtt:
        """Get the ResourceExclusions.ElasticFileSystem attribute."""
        return self.get_att("ResourceExclusions.ElasticFileSystem")

    @property
    def attr_resource_exclusions__egress_only_internet_gateway__state(self) -> GetAtt:
        """Get the ResourceExclusions.EgressOnlyInternetGateway.State attribute."""
        return self.get_att("ResourceExclusions.EgressOnlyInternetGateway.State")

    @property
    def attr_resource_exclusions__nat_gateway__state_message(self) -> GetAtt:
        """Get the ResourceExclusions.NatGateway.StateMessage attribute."""
        return self.get_att("ResourceExclusions.NatGateway.StateMessage")

    @property
    def attr_resource_exclusions__lambda__state(self) -> GetAtt:
        """Get the ResourceExclusions.Lambda.State attribute."""
        return self.get_att("ResourceExclusions.Lambda.State")

    @property
    def attr_resource_exclusions__internet_gateway__state_message(self) -> GetAtt:
        """Get the ResourceExclusions.InternetGateway.StateMessage attribute."""
        return self.get_att("ResourceExclusions.InternetGateway.StateMessage")

    @property
    def attr_resource_exclusions__lambda__state_message(self) -> GetAtt:
        """Get the ResourceExclusions.Lambda.StateMessage attribute."""
        return self.get_att("ResourceExclusions.Lambda.StateMessage")

    @property
    def attr_resource_exclusions__vpc_peering__state(self) -> GetAtt:
        """Get the ResourceExclusions.VpcPeering.State attribute."""
        return self.get_att("ResourceExclusions.VpcPeering.State")

    @property
    def attr_state(self) -> GetAtt:
        """Get the State attribute."""
        return self.get_att("State")

    @property
    def attr_resource_exclusions__vpc_peering__state_message(self) -> GetAtt:
        """Get the ResourceExclusions.VpcPeering.StateMessage attribute."""
        return self.get_att("ResourceExclusions.VpcPeering.StateMessage")

    @property
    def attr_resource_exclusions__vpc_lattice__state_message(self) -> GetAtt:
        """Get the ResourceExclusions.VpcLattice.StateMessage attribute."""
        return self.get_att("ResourceExclusions.VpcLattice.StateMessage")

    @property
    def attr_resource_exclusions(self) -> GetAtt:
        """Get the ResourceExclusions attribute."""
        return self.get_att("ResourceExclusions")

    @property
    def attr_resource_exclusions__virtual_private_gateway__state(self) -> GetAtt:
        """Get the ResourceExclusions.VirtualPrivateGateway.State attribute."""
        return self.get_att("ResourceExclusions.VirtualPrivateGateway.State")




@dataclass
class DnsOptionsSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_dns_only_for_inbound_resolver_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_dns_specified_domains: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dns_record_ip_type: Optional[Union[str, DnsRecordIpType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    private_dns_preference: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.private_dns_only_for_inbound_resolver_endpoint is not None:
            if hasattr(self.private_dns_only_for_inbound_resolver_endpoint, 'to_dict'):
                props['PrivateDnsOnlyForInboundResolverEndpoint'] = self.private_dns_only_for_inbound_resolver_endpoint.to_dict()
            elif isinstance(self.private_dns_only_for_inbound_resolver_endpoint, list):
                props['PrivateDnsOnlyForInboundResolverEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_dns_only_for_inbound_resolver_endpoint
                ]
            else:
                props['PrivateDnsOnlyForInboundResolverEndpoint'] = self.private_dns_only_for_inbound_resolver_endpoint

        if self.private_dns_specified_domains is not None:
            if hasattr(self.private_dns_specified_domains, 'to_dict'):
                props['PrivateDnsSpecifiedDomains'] = self.private_dns_specified_domains.to_dict()
            elif isinstance(self.private_dns_specified_domains, list):
                props['PrivateDnsSpecifiedDomains'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_dns_specified_domains
                ]
            else:
                props['PrivateDnsSpecifiedDomains'] = self.private_dns_specified_domains

        if self.dns_record_ip_type is not None:
            if hasattr(self.dns_record_ip_type, 'to_dict'):
                props['DnsRecordIpType'] = self.dns_record_ip_type.to_dict()
            elif isinstance(self.dns_record_ip_type, list):
                props['DnsRecordIpType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dns_record_ip_type
                ]
            else:
                props['DnsRecordIpType'] = self.dns_record_ip_type

        if self.private_dns_preference is not None:
            if hasattr(self.private_dns_preference, 'to_dict'):
                props['PrivateDnsPreference'] = self.private_dns_preference.to_dict()
            elif isinstance(self.private_dns_preference, list):
                props['PrivateDnsPreference'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_dns_preference
                ]
            else:
                props['PrivateDnsPreference'] = self.private_dns_preference

        return props


@dataclass
class VPCEndpoint(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCEndpoint"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    private_dns_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ip_address_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    dns_options: Optional[DnsOptionsSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_configuration_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_network_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_table_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_document: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_endpoint_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.private_dns_enabled is not None:
            # Serialize private_dns_enabled (handle intrinsic functions)
            if hasattr(self.private_dns_enabled, 'to_dict'):
                props["PrivateDnsEnabled"] = self.private_dns_enabled.to_dict()
            elif isinstance(self.private_dns_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrivateDnsEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.private_dns_enabled
                ]
            else:
                props["PrivateDnsEnabled"] = self.private_dns_enabled

        if self.ip_address_type is not None:
            # Serialize ip_address_type (handle intrinsic functions)
            if hasattr(self.ip_address_type, 'to_dict'):
                props["IpAddressType"] = self.ip_address_type.to_dict()
            elif isinstance(self.ip_address_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['IpAddressType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_address_type
                ]
            else:
                props["IpAddressType"] = self.ip_address_type

        if self.service_region is not None:
            # Serialize service_region (handle intrinsic functions)
            if hasattr(self.service_region, 'to_dict'):
                props["ServiceRegion"] = self.service_region.to_dict()
            elif isinstance(self.service_region, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_region
                ]
            else:
                props["ServiceRegion"] = self.service_region

        if self.dns_options is not None:
            # Serialize dns_options (handle intrinsic functions)
            if hasattr(self.dns_options, 'to_dict'):
                props["DnsOptions"] = self.dns_options.to_dict()
            elif isinstance(self.dns_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['DnsOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dns_options
                ]
            else:
                props["DnsOptions"] = self.dns_options

        if self.resource_configuration_arn is not None:
            # Serialize resource_configuration_arn (handle intrinsic functions)
            if hasattr(self.resource_configuration_arn, 'to_dict'):
                props["ResourceConfigurationArn"] = self.resource_configuration_arn.to_dict()
            elif isinstance(self.resource_configuration_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceConfigurationArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_configuration_arn
                ]
            else:
                props["ResourceConfigurationArn"] = self.resource_configuration_arn

        if self.security_group_ids is not None:
            # Serialize security_group_ids (handle intrinsic functions)
            if hasattr(self.security_group_ids, 'to_dict'):
                props["SecurityGroupIds"] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props["SecurityGroupIds"] = self.security_group_ids

        if self.subnet_ids is not None:
            # Serialize subnet_ids (handle intrinsic functions)
            if hasattr(self.subnet_ids, 'to_dict'):
                props["SubnetIds"] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props["SubnetIds"] = self.subnet_ids

        if self.service_network_arn is not None:
            # Serialize service_network_arn (handle intrinsic functions)
            if hasattr(self.service_network_arn, 'to_dict'):
                props["ServiceNetworkArn"] = self.service_network_arn.to_dict()
            elif isinstance(self.service_network_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceNetworkArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_network_arn
                ]
            else:
                props["ServiceNetworkArn"] = self.service_network_arn

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.route_table_ids is not None:
            # Serialize route_table_ids (handle intrinsic functions)
            if hasattr(self.route_table_ids, 'to_dict'):
                props["RouteTableIds"] = self.route_table_ids.to_dict()
            elif isinstance(self.route_table_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteTableIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_ids
                ]
            else:
                props["RouteTableIds"] = self.route_table_ids

        if self.service_name is not None:
            # Serialize service_name (handle intrinsic functions)
            if hasattr(self.service_name, 'to_dict'):
                props["ServiceName"] = self.service_name.to_dict()
            elif isinstance(self.service_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_name
                ]
            else:
                props["ServiceName"] = self.service_name

        if self.policy_document is not None:
            # Serialize policy_document (handle intrinsic functions)
            if hasattr(self.policy_document, 'to_dict'):
                props["PolicyDocument"] = self.policy_document.to_dict()
            elif isinstance(self.policy_document, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyDocument'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_document
                ]
            else:
                props["PolicyDocument"] = self.policy_document

        if self.vpc_endpoint_type is not None:
            # Serialize vpc_endpoint_type (handle intrinsic functions)
            if hasattr(self.vpc_endpoint_type, 'to_dict'):
                props["VpcEndpointType"] = self.vpc_endpoint_type.to_dict()
            elif isinstance(self.vpc_endpoint_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcEndpointType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_endpoint_type
                ]
            else:
                props["VpcEndpointType"] = self.vpc_endpoint_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_creation_timestamp(self) -> GetAtt:
        """Get the CreationTimestamp attribute."""
        return self.get_att("CreationTimestamp")

    @property
    def attr_network_interface_ids(self) -> GetAtt:
        """Get the NetworkInterfaceIds attribute."""
        return self.get_att("NetworkInterfaceIds")

    @property
    def attr_dns_entries(self) -> GetAtt:
        """Get the DnsEntries attribute."""
        return self.get_att("DnsEntries")

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class VPCEndpointConnectionNotification(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCEndpointConnectionNotification"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connection_events: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_endpoint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connection_notification_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.connection_events is not None:
            # Serialize connection_events (handle intrinsic functions)
            if hasattr(self.connection_events, 'to_dict'):
                props["ConnectionEvents"] = self.connection_events.to_dict()
            elif isinstance(self.connection_events, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConnectionEvents'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connection_events
                ]
            else:
                props["ConnectionEvents"] = self.connection_events

        if self.vpc_endpoint_id is not None:
            # Serialize vpc_endpoint_id (handle intrinsic functions)
            if hasattr(self.vpc_endpoint_id, 'to_dict'):
                props["VPCEndpointId"] = self.vpc_endpoint_id.to_dict()
            elif isinstance(self.vpc_endpoint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VPCEndpointId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_endpoint_id
                ]
            else:
                props["VPCEndpointId"] = self.vpc_endpoint_id

        if self.connection_notification_arn is not None:
            # Serialize connection_notification_arn (handle intrinsic functions)
            if hasattr(self.connection_notification_arn, 'to_dict'):
                props["ConnectionNotificationArn"] = self.connection_notification_arn.to_dict()
            elif isinstance(self.connection_notification_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConnectionNotificationArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connection_notification_arn
                ]
            else:
                props["ConnectionNotificationArn"] = self.connection_notification_arn

        if self.service_id is not None:
            # Serialize service_id (handle intrinsic functions)
            if hasattr(self.service_id, 'to_dict'):
                props["ServiceId"] = self.service_id.to_dict()
            elif isinstance(self.service_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_id
                ]
            else:
                props["ServiceId"] = self.service_id

        return props

    @property
    def attr_vpc_endpoint_connection_notification_id(self) -> GetAtt:
        """Get the VPCEndpointConnectionNotificationId attribute."""
        return self.get_att("VPCEndpointConnectionNotificationId")




@dataclass
class VPCEndpointService(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCEndpointService"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_load_balancer_arns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    payer_responsibility: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    acceptance_required: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    contributor_insights_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    supported_ip_address_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    gateway_load_balancer_arns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    supported_regions: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.network_load_balancer_arns is not None:
            # Serialize network_load_balancer_arns (handle intrinsic functions)
            if hasattr(self.network_load_balancer_arns, 'to_dict'):
                props["NetworkLoadBalancerArns"] = self.network_load_balancer_arns.to_dict()
            elif isinstance(self.network_load_balancer_arns, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkLoadBalancerArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_load_balancer_arns
                ]
            else:
                props["NetworkLoadBalancerArns"] = self.network_load_balancer_arns

        if self.payer_responsibility is not None:
            # Serialize payer_responsibility (handle intrinsic functions)
            if hasattr(self.payer_responsibility, 'to_dict'):
                props["PayerResponsibility"] = self.payer_responsibility.to_dict()
            elif isinstance(self.payer_responsibility, list):
                # Serialize list items (may contain intrinsic functions)
                props['PayerResponsibility'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.payer_responsibility
                ]
            else:
                props["PayerResponsibility"] = self.payer_responsibility

        if self.acceptance_required is not None:
            # Serialize acceptance_required (handle intrinsic functions)
            if hasattr(self.acceptance_required, 'to_dict'):
                props["AcceptanceRequired"] = self.acceptance_required.to_dict()
            elif isinstance(self.acceptance_required, list):
                # Serialize list items (may contain intrinsic functions)
                props['AcceptanceRequired'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.acceptance_required
                ]
            else:
                props["AcceptanceRequired"] = self.acceptance_required

        if self.contributor_insights_enabled is not None:
            # Serialize contributor_insights_enabled (handle intrinsic functions)
            if hasattr(self.contributor_insights_enabled, 'to_dict'):
                props["ContributorInsightsEnabled"] = self.contributor_insights_enabled.to_dict()
            elif isinstance(self.contributor_insights_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['ContributorInsightsEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.contributor_insights_enabled
                ]
            else:
                props["ContributorInsightsEnabled"] = self.contributor_insights_enabled

        if self.supported_ip_address_types is not None:
            # Serialize supported_ip_address_types (handle intrinsic functions)
            if hasattr(self.supported_ip_address_types, 'to_dict'):
                props["SupportedIpAddressTypes"] = self.supported_ip_address_types.to_dict()
            elif isinstance(self.supported_ip_address_types, list):
                # Serialize list items (may contain intrinsic functions)
                props['SupportedIpAddressTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.supported_ip_address_types
                ]
            else:
                props["SupportedIpAddressTypes"] = self.supported_ip_address_types

        if self.gateway_load_balancer_arns is not None:
            # Serialize gateway_load_balancer_arns (handle intrinsic functions)
            if hasattr(self.gateway_load_balancer_arns, 'to_dict'):
                props["GatewayLoadBalancerArns"] = self.gateway_load_balancer_arns.to_dict()
            elif isinstance(self.gateway_load_balancer_arns, list):
                # Serialize list items (may contain intrinsic functions)
                props['GatewayLoadBalancerArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gateway_load_balancer_arns
                ]
            else:
                props["GatewayLoadBalancerArns"] = self.gateway_load_balancer_arns

        if self.supported_regions is not None:
            # Serialize supported_regions (handle intrinsic functions)
            if hasattr(self.supported_regions, 'to_dict'):
                props["SupportedRegions"] = self.supported_regions.to_dict()
            elif isinstance(self.supported_regions, list):
                # Serialize list items (may contain intrinsic functions)
                props['SupportedRegions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.supported_regions
                ]
            else:
                props["SupportedRegions"] = self.supported_regions

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_service_id(self) -> GetAtt:
        """Get the ServiceId attribute."""
        return self.get_att("ServiceId")




@dataclass
class VPCEndpointServicePermissions(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCEndpointServicePermissions"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allowed_principals: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.allowed_principals is not None:
            # Serialize allowed_principals (handle intrinsic functions)
            if hasattr(self.allowed_principals, 'to_dict'):
                props["AllowedPrincipals"] = self.allowed_principals.to_dict()
            elif isinstance(self.allowed_principals, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllowedPrincipals'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_principals
                ]
            else:
                props["AllowedPrincipals"] = self.allowed_principals

        if self.service_id is not None:
            # Serialize service_id (handle intrinsic functions)
            if hasattr(self.service_id, 'to_dict'):
                props["ServiceId"] = self.service_id.to_dict()
            elif isinstance(self.service_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_id
                ]
            else:
                props["ServiceId"] = self.service_id

        return props



@dataclass
class VPCGatewayAttachment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCGatewayAttachment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    internet_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpn_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.internet_gateway_id is not None:
            # Serialize internet_gateway_id (handle intrinsic functions)
            if hasattr(self.internet_gateway_id, 'to_dict'):
                props["InternetGatewayId"] = self.internet_gateway_id.to_dict()
            elif isinstance(self.internet_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['InternetGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internet_gateway_id
                ]
            else:
                props["InternetGatewayId"] = self.internet_gateway_id

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.vpn_gateway_id is not None:
            # Serialize vpn_gateway_id (handle intrinsic functions)
            if hasattr(self.vpn_gateway_id, 'to_dict'):
                props["VpnGatewayId"] = self.vpn_gateway_id.to_dict()
            elif isinstance(self.vpn_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpnGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_gateway_id
                ]
            else:
                props["VpnGatewayId"] = self.vpn_gateway_id

        return props

    @property
    def attr_attachment_type(self) -> GetAtt:
        """Get the AttachmentType attribute."""
        return self.get_att("AttachmentType")




@dataclass
class VPCPeeringConnection(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPCPeeringConnection"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    peer_owner_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.peer_role_arn is not None:
            # Serialize peer_role_arn (handle intrinsic functions)
            if hasattr(self.peer_role_arn, 'to_dict'):
                props["PeerRoleArn"] = self.peer_role_arn.to_dict()
            elif isinstance(self.peer_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_role_arn
                ]
            else:
                props["PeerRoleArn"] = self.peer_role_arn

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.peer_vpc_id is not None:
            # Serialize peer_vpc_id (handle intrinsic functions)
            if hasattr(self.peer_vpc_id, 'to_dict'):
                props["PeerVpcId"] = self.peer_vpc_id.to_dict()
            elif isinstance(self.peer_vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerVpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_vpc_id
                ]
            else:
                props["PeerVpcId"] = self.peer_vpc_id

        if self.peer_region is not None:
            # Serialize peer_region (handle intrinsic functions)
            if hasattr(self.peer_region, 'to_dict'):
                props["PeerRegion"] = self.peer_region.to_dict()
            elif isinstance(self.peer_region, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_region
                ]
            else:
                props["PeerRegion"] = self.peer_region

        if self.peer_owner_id is not None:
            # Serialize peer_owner_id (handle intrinsic functions)
            if hasattr(self.peer_owner_id, 'to_dict'):
                props["PeerOwnerId"] = self.peer_owner_id.to_dict()
            elif isinstance(self.peer_owner_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['PeerOwnerId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.peer_owner_id
                ]
            else:
                props["PeerOwnerId"] = self.peer_owner_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class VPNConcentrator(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPNConcentrator"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_vpn_concentrator_id(self) -> GetAtt:
        """Get the VpnConcentratorId attribute."""
        return self.get_att("VpnConcentratorId")

    @property
    def attr_transit_gateway_attachment_id(self) -> GetAtt:
        """Get the TransitGatewayAttachmentId attribute."""
        return self.get_att("TransitGatewayAttachmentId")




@dataclass
class CloudwatchLogOptionsSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bgp_log_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_output_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bgp_log_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bgp_log_output_format: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.bgp_log_enabled is not None:
            if hasattr(self.bgp_log_enabled, 'to_dict'):
                props['BgpLogEnabled'] = self.bgp_log_enabled.to_dict()
            elif isinstance(self.bgp_log_enabled, list):
                props['BgpLogEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bgp_log_enabled
                ]
            else:
                props['BgpLogEnabled'] = self.bgp_log_enabled

        if self.log_enabled is not None:
            if hasattr(self.log_enabled, 'to_dict'):
                props['LogEnabled'] = self.log_enabled.to_dict()
            elif isinstance(self.log_enabled, list):
                props['LogEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_enabled
                ]
            else:
                props['LogEnabled'] = self.log_enabled

        if self.log_output_format is not None:
            if hasattr(self.log_output_format, 'to_dict'):
                props['LogOutputFormat'] = self.log_output_format.to_dict()
            elif isinstance(self.log_output_format, list):
                props['LogOutputFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_output_format
                ]
            else:
                props['LogOutputFormat'] = self.log_output_format

        if self.bgp_log_group_arn is not None:
            if hasattr(self.bgp_log_group_arn, 'to_dict'):
                props['BgpLogGroupArn'] = self.bgp_log_group_arn.to_dict()
            elif isinstance(self.bgp_log_group_arn, list):
                props['BgpLogGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bgp_log_group_arn
                ]
            else:
                props['BgpLogGroupArn'] = self.bgp_log_group_arn

        if self.log_group_arn is not None:
            if hasattr(self.log_group_arn, 'to_dict'):
                props['LogGroupArn'] = self.log_group_arn.to_dict()
            elif isinstance(self.log_group_arn, list):
                props['LogGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group_arn
                ]
            else:
                props['LogGroupArn'] = self.log_group_arn

        if self.bgp_log_output_format is not None:
            if hasattr(self.bgp_log_output_format, 'to_dict'):
                props['BgpLogOutputFormat'] = self.bgp_log_output_format.to_dict()
            elif isinstance(self.bgp_log_output_format, list):
                props['BgpLogOutputFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bgp_log_output_format
                ]
            else:
                props['BgpLogOutputFormat'] = self.bgp_log_output_format

        return props


@dataclass
class IKEVersionsRequestListValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class Phase1DHGroupNumbersRequestListValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class Phase1EncryptionAlgorithmsRequestListValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class Phase1IntegrityAlgorithmsRequestListValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class Phase2DHGroupNumbersRequestListValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class Phase2EncryptionAlgorithmsRequestListValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class Phase2IntegrityAlgorithmsRequestListValue:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class VpnTunnelLogOptionsSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloudwatch_log_options: Optional[CloudwatchLogOptionsSpecification] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cloudwatch_log_options is not None:
            if hasattr(self.cloudwatch_log_options, 'to_dict'):
                props['CloudwatchLogOptions'] = self.cloudwatch_log_options.to_dict()
            elif isinstance(self.cloudwatch_log_options, list):
                props['CloudwatchLogOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cloudwatch_log_options
                ]
            else:
                props['CloudwatchLogOptions'] = self.cloudwatch_log_options

        return props


@dataclass
class VpnTunnelOptionsSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    phase2_encryption_algorithms: Optional[list[Phase2EncryptionAlgorithmsRequestListValue]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    phase2_dh_group_numbers: Optional[list[Phase2DHGroupNumbersRequestListValue]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tunnel_inside_ipv6_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    startup_action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tunnel_inside_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ike_versions: Optional[list[IKEVersionsRequestListValue]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_options: Optional[VpnTunnelLogOptionsSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    phase1_dh_group_numbers: Optional[list[Phase1DHGroupNumbersRequestListValue]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    replay_window_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_tunnel_lifecycle_control: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rekey_margin_time_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dpd_timeout_action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    phase2_lifetime_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    phase2_integrity_algorithms: Optional[list[Phase2IntegrityAlgorithmsRequestListValue]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    phase1_integrity_algorithms: Optional[list[Phase1IntegrityAlgorithmsRequestListValue]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    pre_shared_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    phase1_lifetime_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rekey_fuzz_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    phase1_encryption_algorithms: Optional[list[Phase1EncryptionAlgorithmsRequestListValue]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dpd_timeout_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.phase2_encryption_algorithms is not None:
            if hasattr(self.phase2_encryption_algorithms, 'to_dict'):
                props['Phase2EncryptionAlgorithms'] = self.phase2_encryption_algorithms.to_dict()
            elif isinstance(self.phase2_encryption_algorithms, list):
                props['Phase2EncryptionAlgorithms'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.phase2_encryption_algorithms
                ]
            else:
                props['Phase2EncryptionAlgorithms'] = self.phase2_encryption_algorithms

        if self.phase2_dh_group_numbers is not None:
            if hasattr(self.phase2_dh_group_numbers, 'to_dict'):
                props['Phase2DHGroupNumbers'] = self.phase2_dh_group_numbers.to_dict()
            elif isinstance(self.phase2_dh_group_numbers, list):
                props['Phase2DHGroupNumbers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.phase2_dh_group_numbers
                ]
            else:
                props['Phase2DHGroupNumbers'] = self.phase2_dh_group_numbers

        if self.tunnel_inside_ipv6_cidr is not None:
            if hasattr(self.tunnel_inside_ipv6_cidr, 'to_dict'):
                props['TunnelInsideIpv6Cidr'] = self.tunnel_inside_ipv6_cidr.to_dict()
            elif isinstance(self.tunnel_inside_ipv6_cidr, list):
                props['TunnelInsideIpv6Cidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tunnel_inside_ipv6_cidr
                ]
            else:
                props['TunnelInsideIpv6Cidr'] = self.tunnel_inside_ipv6_cidr

        if self.startup_action is not None:
            if hasattr(self.startup_action, 'to_dict'):
                props['StartupAction'] = self.startup_action.to_dict()
            elif isinstance(self.startup_action, list):
                props['StartupAction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.startup_action
                ]
            else:
                props['StartupAction'] = self.startup_action

        if self.tunnel_inside_cidr is not None:
            if hasattr(self.tunnel_inside_cidr, 'to_dict'):
                props['TunnelInsideCidr'] = self.tunnel_inside_cidr.to_dict()
            elif isinstance(self.tunnel_inside_cidr, list):
                props['TunnelInsideCidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tunnel_inside_cidr
                ]
            else:
                props['TunnelInsideCidr'] = self.tunnel_inside_cidr

        if self.ike_versions is not None:
            if hasattr(self.ike_versions, 'to_dict'):
                props['IKEVersions'] = self.ike_versions.to_dict()
            elif isinstance(self.ike_versions, list):
                props['IKEVersions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ike_versions
                ]
            else:
                props['IKEVersions'] = self.ike_versions

        if self.log_options is not None:
            if hasattr(self.log_options, 'to_dict'):
                props['LogOptions'] = self.log_options.to_dict()
            elif isinstance(self.log_options, list):
                props['LogOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_options
                ]
            else:
                props['LogOptions'] = self.log_options

        if self.phase1_dh_group_numbers is not None:
            if hasattr(self.phase1_dh_group_numbers, 'to_dict'):
                props['Phase1DHGroupNumbers'] = self.phase1_dh_group_numbers.to_dict()
            elif isinstance(self.phase1_dh_group_numbers, list):
                props['Phase1DHGroupNumbers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.phase1_dh_group_numbers
                ]
            else:
                props['Phase1DHGroupNumbers'] = self.phase1_dh_group_numbers

        if self.replay_window_size is not None:
            if hasattr(self.replay_window_size, 'to_dict'):
                props['ReplayWindowSize'] = self.replay_window_size.to_dict()
            elif isinstance(self.replay_window_size, list):
                props['ReplayWindowSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.replay_window_size
                ]
            else:
                props['ReplayWindowSize'] = self.replay_window_size

        if self.enable_tunnel_lifecycle_control is not None:
            if hasattr(self.enable_tunnel_lifecycle_control, 'to_dict'):
                props['EnableTunnelLifecycleControl'] = self.enable_tunnel_lifecycle_control.to_dict()
            elif isinstance(self.enable_tunnel_lifecycle_control, list):
                props['EnableTunnelLifecycleControl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_tunnel_lifecycle_control
                ]
            else:
                props['EnableTunnelLifecycleControl'] = self.enable_tunnel_lifecycle_control

        if self.rekey_margin_time_seconds is not None:
            if hasattr(self.rekey_margin_time_seconds, 'to_dict'):
                props['RekeyMarginTimeSeconds'] = self.rekey_margin_time_seconds.to_dict()
            elif isinstance(self.rekey_margin_time_seconds, list):
                props['RekeyMarginTimeSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rekey_margin_time_seconds
                ]
            else:
                props['RekeyMarginTimeSeconds'] = self.rekey_margin_time_seconds

        if self.dpd_timeout_action is not None:
            if hasattr(self.dpd_timeout_action, 'to_dict'):
                props['DPDTimeoutAction'] = self.dpd_timeout_action.to_dict()
            elif isinstance(self.dpd_timeout_action, list):
                props['DPDTimeoutAction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dpd_timeout_action
                ]
            else:
                props['DPDTimeoutAction'] = self.dpd_timeout_action

        if self.phase2_lifetime_seconds is not None:
            if hasattr(self.phase2_lifetime_seconds, 'to_dict'):
                props['Phase2LifetimeSeconds'] = self.phase2_lifetime_seconds.to_dict()
            elif isinstance(self.phase2_lifetime_seconds, list):
                props['Phase2LifetimeSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.phase2_lifetime_seconds
                ]
            else:
                props['Phase2LifetimeSeconds'] = self.phase2_lifetime_seconds

        if self.phase2_integrity_algorithms is not None:
            if hasattr(self.phase2_integrity_algorithms, 'to_dict'):
                props['Phase2IntegrityAlgorithms'] = self.phase2_integrity_algorithms.to_dict()
            elif isinstance(self.phase2_integrity_algorithms, list):
                props['Phase2IntegrityAlgorithms'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.phase2_integrity_algorithms
                ]
            else:
                props['Phase2IntegrityAlgorithms'] = self.phase2_integrity_algorithms

        if self.phase1_integrity_algorithms is not None:
            if hasattr(self.phase1_integrity_algorithms, 'to_dict'):
                props['Phase1IntegrityAlgorithms'] = self.phase1_integrity_algorithms.to_dict()
            elif isinstance(self.phase1_integrity_algorithms, list):
                props['Phase1IntegrityAlgorithms'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.phase1_integrity_algorithms
                ]
            else:
                props['Phase1IntegrityAlgorithms'] = self.phase1_integrity_algorithms

        if self.pre_shared_key is not None:
            if hasattr(self.pre_shared_key, 'to_dict'):
                props['PreSharedKey'] = self.pre_shared_key.to_dict()
            elif isinstance(self.pre_shared_key, list):
                props['PreSharedKey'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pre_shared_key
                ]
            else:
                props['PreSharedKey'] = self.pre_shared_key

        if self.phase1_lifetime_seconds is not None:
            if hasattr(self.phase1_lifetime_seconds, 'to_dict'):
                props['Phase1LifetimeSeconds'] = self.phase1_lifetime_seconds.to_dict()
            elif isinstance(self.phase1_lifetime_seconds, list):
                props['Phase1LifetimeSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.phase1_lifetime_seconds
                ]
            else:
                props['Phase1LifetimeSeconds'] = self.phase1_lifetime_seconds

        if self.rekey_fuzz_percentage is not None:
            if hasattr(self.rekey_fuzz_percentage, 'to_dict'):
                props['RekeyFuzzPercentage'] = self.rekey_fuzz_percentage.to_dict()
            elif isinstance(self.rekey_fuzz_percentage, list):
                props['RekeyFuzzPercentage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rekey_fuzz_percentage
                ]
            else:
                props['RekeyFuzzPercentage'] = self.rekey_fuzz_percentage

        if self.phase1_encryption_algorithms is not None:
            if hasattr(self.phase1_encryption_algorithms, 'to_dict'):
                props['Phase1EncryptionAlgorithms'] = self.phase1_encryption_algorithms.to_dict()
            elif isinstance(self.phase1_encryption_algorithms, list):
                props['Phase1EncryptionAlgorithms'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.phase1_encryption_algorithms
                ]
            else:
                props['Phase1EncryptionAlgorithms'] = self.phase1_encryption_algorithms

        if self.dpd_timeout_seconds is not None:
            if hasattr(self.dpd_timeout_seconds, 'to_dict'):
                props['DPDTimeoutSeconds'] = self.dpd_timeout_seconds.to_dict()
            elif isinstance(self.dpd_timeout_seconds, list):
                props['DPDTimeoutSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dpd_timeout_seconds
                ]
            else:
                props['DPDTimeoutSeconds'] = self.dpd_timeout_seconds

        return props


@dataclass
class VPNConnection(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPNConnection"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    remote_ipv6_network_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    remote_ipv4_network_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpn_tunnel_options_specifications: Optional[list[VpnTunnelOptionsSpecification]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    customer_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    outside_ip_address_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    static_routes_only: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_acceleration: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transit_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tunnel_bandwidth: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_ipv4_network_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpn_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpn_concentrator_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    pre_shared_key_storage: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    transport_transit_gateway_attachment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    local_ipv6_network_cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tunnel_inside_ip_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.remote_ipv6_network_cidr is not None:
            # Serialize remote_ipv6_network_cidr (handle intrinsic functions)
            if hasattr(self.remote_ipv6_network_cidr, 'to_dict'):
                props["RemoteIpv6NetworkCidr"] = self.remote_ipv6_network_cidr.to_dict()
            elif isinstance(self.remote_ipv6_network_cidr, list):
                # Serialize list items (may contain intrinsic functions)
                props['RemoteIpv6NetworkCidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.remote_ipv6_network_cidr
                ]
            else:
                props["RemoteIpv6NetworkCidr"] = self.remote_ipv6_network_cidr

        if self.remote_ipv4_network_cidr is not None:
            # Serialize remote_ipv4_network_cidr (handle intrinsic functions)
            if hasattr(self.remote_ipv4_network_cidr, 'to_dict'):
                props["RemoteIpv4NetworkCidr"] = self.remote_ipv4_network_cidr.to_dict()
            elif isinstance(self.remote_ipv4_network_cidr, list):
                # Serialize list items (may contain intrinsic functions)
                props['RemoteIpv4NetworkCidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.remote_ipv4_network_cidr
                ]
            else:
                props["RemoteIpv4NetworkCidr"] = self.remote_ipv4_network_cidr

        if self.vpn_tunnel_options_specifications is not None:
            # Serialize vpn_tunnel_options_specifications (handle intrinsic functions)
            if hasattr(self.vpn_tunnel_options_specifications, 'to_dict'):
                props["VpnTunnelOptionsSpecifications"] = self.vpn_tunnel_options_specifications.to_dict()
            elif isinstance(self.vpn_tunnel_options_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpnTunnelOptionsSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_tunnel_options_specifications
                ]
            else:
                props["VpnTunnelOptionsSpecifications"] = self.vpn_tunnel_options_specifications

        if self.customer_gateway_id is not None:
            # Serialize customer_gateway_id (handle intrinsic functions)
            if hasattr(self.customer_gateway_id, 'to_dict'):
                props["CustomerGatewayId"] = self.customer_gateway_id.to_dict()
            elif isinstance(self.customer_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['CustomerGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customer_gateway_id
                ]
            else:
                props["CustomerGatewayId"] = self.customer_gateway_id

        if self.outside_ip_address_type is not None:
            # Serialize outside_ip_address_type (handle intrinsic functions)
            if hasattr(self.outside_ip_address_type, 'to_dict'):
                props["OutsideIpAddressType"] = self.outside_ip_address_type.to_dict()
            elif isinstance(self.outside_ip_address_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutsideIpAddressType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.outside_ip_address_type
                ]
            else:
                props["OutsideIpAddressType"] = self.outside_ip_address_type

        if self.static_routes_only is not None:
            # Serialize static_routes_only (handle intrinsic functions)
            if hasattr(self.static_routes_only, 'to_dict'):
                props["StaticRoutesOnly"] = self.static_routes_only.to_dict()
            elif isinstance(self.static_routes_only, list):
                # Serialize list items (may contain intrinsic functions)
                props['StaticRoutesOnly'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.static_routes_only
                ]
            else:
                props["StaticRoutesOnly"] = self.static_routes_only

        if self.enable_acceleration is not None:
            # Serialize enable_acceleration (handle intrinsic functions)
            if hasattr(self.enable_acceleration, 'to_dict'):
                props["EnableAcceleration"] = self.enable_acceleration.to_dict()
            elif isinstance(self.enable_acceleration, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableAcceleration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_acceleration
                ]
            else:
                props["EnableAcceleration"] = self.enable_acceleration

        if self.transit_gateway_id is not None:
            # Serialize transit_gateway_id (handle intrinsic functions)
            if hasattr(self.transit_gateway_id, 'to_dict'):
                props["TransitGatewayId"] = self.transit_gateway_id.to_dict()
            elif isinstance(self.transit_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransitGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transit_gateway_id
                ]
            else:
                props["TransitGatewayId"] = self.transit_gateway_id

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.tunnel_bandwidth is not None:
            # Serialize tunnel_bandwidth (handle intrinsic functions)
            if hasattr(self.tunnel_bandwidth, 'to_dict'):
                props["TunnelBandwidth"] = self.tunnel_bandwidth.to_dict()
            elif isinstance(self.tunnel_bandwidth, list):
                # Serialize list items (may contain intrinsic functions)
                props['TunnelBandwidth'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tunnel_bandwidth
                ]
            else:
                props["TunnelBandwidth"] = self.tunnel_bandwidth

        if self.local_ipv4_network_cidr is not None:
            # Serialize local_ipv4_network_cidr (handle intrinsic functions)
            if hasattr(self.local_ipv4_network_cidr, 'to_dict'):
                props["LocalIpv4NetworkCidr"] = self.local_ipv4_network_cidr.to_dict()
            elif isinstance(self.local_ipv4_network_cidr, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalIpv4NetworkCidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_ipv4_network_cidr
                ]
            else:
                props["LocalIpv4NetworkCidr"] = self.local_ipv4_network_cidr

        if self.vpn_gateway_id is not None:
            # Serialize vpn_gateway_id (handle intrinsic functions)
            if hasattr(self.vpn_gateway_id, 'to_dict'):
                props["VpnGatewayId"] = self.vpn_gateway_id.to_dict()
            elif isinstance(self.vpn_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpnGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_gateway_id
                ]
            else:
                props["VpnGatewayId"] = self.vpn_gateway_id

        if self.vpn_concentrator_id is not None:
            # Serialize vpn_concentrator_id (handle intrinsic functions)
            if hasattr(self.vpn_concentrator_id, 'to_dict'):
                props["VpnConcentratorId"] = self.vpn_concentrator_id.to_dict()
            elif isinstance(self.vpn_concentrator_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpnConcentratorId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_concentrator_id
                ]
            else:
                props["VpnConcentratorId"] = self.vpn_concentrator_id

        if self.pre_shared_key_storage is not None:
            # Serialize pre_shared_key_storage (handle intrinsic functions)
            if hasattr(self.pre_shared_key_storage, 'to_dict'):
                props["PreSharedKeyStorage"] = self.pre_shared_key_storage.to_dict()
            elif isinstance(self.pre_shared_key_storage, list):
                # Serialize list items (may contain intrinsic functions)
                props['PreSharedKeyStorage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pre_shared_key_storage
                ]
            else:
                props["PreSharedKeyStorage"] = self.pre_shared_key_storage

        if self.transport_transit_gateway_attachment_id is not None:
            # Serialize transport_transit_gateway_attachment_id (handle intrinsic functions)
            if hasattr(self.transport_transit_gateway_attachment_id, 'to_dict'):
                props["TransportTransitGatewayAttachmentId"] = self.transport_transit_gateway_attachment_id.to_dict()
            elif isinstance(self.transport_transit_gateway_attachment_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TransportTransitGatewayAttachmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transport_transit_gateway_attachment_id
                ]
            else:
                props["TransportTransitGatewayAttachmentId"] = self.transport_transit_gateway_attachment_id

        if self.local_ipv6_network_cidr is not None:
            # Serialize local_ipv6_network_cidr (handle intrinsic functions)
            if hasattr(self.local_ipv6_network_cidr, 'to_dict'):
                props["LocalIpv6NetworkCidr"] = self.local_ipv6_network_cidr.to_dict()
            elif isinstance(self.local_ipv6_network_cidr, list):
                # Serialize list items (may contain intrinsic functions)
                props['LocalIpv6NetworkCidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_ipv6_network_cidr
                ]
            else:
                props["LocalIpv6NetworkCidr"] = self.local_ipv6_network_cidr

        if self.tunnel_inside_ip_version is not None:
            # Serialize tunnel_inside_ip_version (handle intrinsic functions)
            if hasattr(self.tunnel_inside_ip_version, 'to_dict'):
                props["TunnelInsideIpVersion"] = self.tunnel_inside_ip_version.to_dict()
            elif isinstance(self.tunnel_inside_ip_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['TunnelInsideIpVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tunnel_inside_ip_version
                ]
            else:
                props["TunnelInsideIpVersion"] = self.tunnel_inside_ip_version

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_vpn_connection_id(self) -> GetAtt:
        """Get the VpnConnectionId attribute."""
        return self.get_att("VpnConnectionId")




@dataclass
class VPNConnectionRoute(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPNConnectionRoute"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    destination_cidr_block: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpn_connection_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination_cidr_block is not None:
            # Serialize destination_cidr_block (handle intrinsic functions)
            if hasattr(self.destination_cidr_block, 'to_dict'):
                props["DestinationCidrBlock"] = self.destination_cidr_block.to_dict()
            elif isinstance(self.destination_cidr_block, list):
                # Serialize list items (may contain intrinsic functions)
                props['DestinationCidrBlock'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_cidr_block
                ]
            else:
                props["DestinationCidrBlock"] = self.destination_cidr_block

        if self.vpn_connection_id is not None:
            # Serialize vpn_connection_id (handle intrinsic functions)
            if hasattr(self.vpn_connection_id, 'to_dict'):
                props["VpnConnectionId"] = self.vpn_connection_id.to_dict()
            elif isinstance(self.vpn_connection_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpnConnectionId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_connection_id
                ]
            else:
                props["VpnConnectionId"] = self.vpn_connection_id

        return props



@dataclass
class VPNGateway(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPNGateway"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    amazon_side_asn: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.amazon_side_asn is not None:
            # Serialize amazon_side_asn (handle intrinsic functions)
            if hasattr(self.amazon_side_asn, 'to_dict'):
                props["AmazonSideAsn"] = self.amazon_side_asn.to_dict()
            elif isinstance(self.amazon_side_asn, list):
                # Serialize list items (may contain intrinsic functions)
                props['AmazonSideAsn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.amazon_side_asn
                ]
            else:
                props["AmazonSideAsn"] = self.amazon_side_asn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_vpn_gateway_id(self) -> GetAtt:
        """Get the VPNGatewayId attribute."""
        return self.get_att("VPNGatewayId")




@dataclass
class VPNGatewayRoutePropagation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VPNGatewayRoutePropagation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    route_table_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpn_gateway_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.route_table_ids is not None:
            # Serialize route_table_ids (handle intrinsic functions)
            if hasattr(self.route_table_ids, 'to_dict'):
                props["RouteTableIds"] = self.route_table_ids.to_dict()
            elif isinstance(self.route_table_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['RouteTableIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.route_table_ids
                ]
            else:
                props["RouteTableIds"] = self.route_table_ids

        if self.vpn_gateway_id is not None:
            # Serialize vpn_gateway_id (handle intrinsic functions)
            if hasattr(self.vpn_gateway_id, 'to_dict'):
                props["VpnGatewayId"] = self.vpn_gateway_id.to_dict()
            elif isinstance(self.vpn_gateway_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpnGatewayId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpn_gateway_id
                ]
            else:
                props["VpnGatewayId"] = self.vpn_gateway_id

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class CidrOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cidr: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port_ranges: Optional[list[PortRange]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cidr is not None:
            if hasattr(self.cidr, 'to_dict'):
                props['Cidr'] = self.cidr.to_dict()
            elif isinstance(self.cidr, list):
                props['Cidr'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr
                ]
            else:
                props['Cidr'] = self.cidr

        if self.port_ranges is not None:
            if hasattr(self.port_ranges, 'to_dict'):
                props['PortRanges'] = self.port_ranges.to_dict()
            elif isinstance(self.port_ranges, list):
                props['PortRanges'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port_ranges
                ]
            else:
                props['PortRanges'] = self.port_ranges

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        if self.subnet_ids is not None:
            if hasattr(self.subnet_ids, 'to_dict'):
                props['SubnetIds'] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props['SubnetIds'] = self.subnet_ids

        return props


@dataclass
class LoadBalancerOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    load_balancer_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port_ranges: Optional[list[PortRange]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.load_balancer_arn is not None:
            if hasattr(self.load_balancer_arn, 'to_dict'):
                props['LoadBalancerArn'] = self.load_balancer_arn.to_dict()
            elif isinstance(self.load_balancer_arn, list):
                props['LoadBalancerArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_arn
                ]
            else:
                props['LoadBalancerArn'] = self.load_balancer_arn

        if self.port is not None:
            if hasattr(self.port, 'to_dict'):
                props['Port'] = self.port.to_dict()
            elif isinstance(self.port, list):
                props['Port'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port
                ]
            else:
                props['Port'] = self.port

        if self.port_ranges is not None:
            if hasattr(self.port_ranges, 'to_dict'):
                props['PortRanges'] = self.port_ranges.to_dict()
            elif isinstance(self.port_ranges, list):
                props['PortRanges'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port_ranges
                ]
            else:
                props['PortRanges'] = self.port_ranges

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        if self.subnet_ids is not None:
            if hasattr(self.subnet_ids, 'to_dict'):
                props['SubnetIds'] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props['SubnetIds'] = self.subnet_ids

        return props


@dataclass
class NetworkInterfaceOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port_ranges: Optional[list[PortRange]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_interface_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.port is not None:
            if hasattr(self.port, 'to_dict'):
                props['Port'] = self.port.to_dict()
            elif isinstance(self.port, list):
                props['Port'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port
                ]
            else:
                props['Port'] = self.port

        if self.port_ranges is not None:
            if hasattr(self.port_ranges, 'to_dict'):
                props['PortRanges'] = self.port_ranges.to_dict()
            elif isinstance(self.port_ranges, list):
                props['PortRanges'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port_ranges
                ]
            else:
                props['PortRanges'] = self.port_ranges

        if self.network_interface_id is not None:
            if hasattr(self.network_interface_id, 'to_dict'):
                props['NetworkInterfaceId'] = self.network_interface_id.to_dict()
            elif isinstance(self.network_interface_id, list):
                props['NetworkInterfaceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_id
                ]
            else:
                props['NetworkInterfaceId'] = self.network_interface_id

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        return props


@dataclass
class PortRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    from_port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    to_port: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.from_port is not None:
            if hasattr(self.from_port, 'to_dict'):
                props['FromPort'] = self.from_port.to_dict()
            elif isinstance(self.from_port, list):
                props['FromPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.from_port
                ]
            else:
                props['FromPort'] = self.from_port

        if self.to_port is not None:
            if hasattr(self.to_port, 'to_dict'):
                props['ToPort'] = self.to_port.to_dict()
            elif isinstance(self.to_port, list):
                props['ToPort'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.to_port
                ]
            else:
                props['ToPort'] = self.to_port

        return props


@dataclass
class RdsOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rds_db_proxy_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rds_db_cluster_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rds_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    port: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rds_db_instance_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    protocol: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.rds_db_proxy_arn is not None:
            if hasattr(self.rds_db_proxy_arn, 'to_dict'):
                props['RdsDbProxyArn'] = self.rds_db_proxy_arn.to_dict()
            elif isinstance(self.rds_db_proxy_arn, list):
                props['RdsDbProxyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rds_db_proxy_arn
                ]
            else:
                props['RdsDbProxyArn'] = self.rds_db_proxy_arn

        if self.rds_db_cluster_arn is not None:
            if hasattr(self.rds_db_cluster_arn, 'to_dict'):
                props['RdsDbClusterArn'] = self.rds_db_cluster_arn.to_dict()
            elif isinstance(self.rds_db_cluster_arn, list):
                props['RdsDbClusterArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rds_db_cluster_arn
                ]
            else:
                props['RdsDbClusterArn'] = self.rds_db_cluster_arn

        if self.rds_endpoint is not None:
            if hasattr(self.rds_endpoint, 'to_dict'):
                props['RdsEndpoint'] = self.rds_endpoint.to_dict()
            elif isinstance(self.rds_endpoint, list):
                props['RdsEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rds_endpoint
                ]
            else:
                props['RdsEndpoint'] = self.rds_endpoint

        if self.port is not None:
            if hasattr(self.port, 'to_dict'):
                props['Port'] = self.port.to_dict()
            elif isinstance(self.port, list):
                props['Port'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.port
                ]
            else:
                props['Port'] = self.port

        if self.rds_db_instance_arn is not None:
            if hasattr(self.rds_db_instance_arn, 'to_dict'):
                props['RdsDbInstanceArn'] = self.rds_db_instance_arn.to_dict()
            elif isinstance(self.rds_db_instance_arn, list):
                props['RdsDbInstanceArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rds_db_instance_arn
                ]
            else:
                props['RdsDbInstanceArn'] = self.rds_db_instance_arn

        if self.protocol is not None:
            if hasattr(self.protocol, 'to_dict'):
                props['Protocol'] = self.protocol.to_dict()
            elif isinstance(self.protocol, list):
                props['Protocol'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.protocol
                ]
            else:
                props['Protocol'] = self.protocol

        if self.subnet_ids is not None:
            if hasattr(self.subnet_ids, 'to_dict'):
                props['SubnetIds'] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props['SubnetIds'] = self.subnet_ids

        return props


@dataclass
class SseSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customer_managed_key_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.customer_managed_key_enabled is not None:
            if hasattr(self.customer_managed_key_enabled, 'to_dict'):
                props['CustomerManagedKeyEnabled'] = self.customer_managed_key_enabled.to_dict()
            elif isinstance(self.customer_managed_key_enabled, list):
                props['CustomerManagedKeyEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customer_managed_key_enabled
                ]
            else:
                props['CustomerManagedKeyEnabled'] = self.customer_managed_key_enabled

        if self.kms_key_arn is not None:
            if hasattr(self.kms_key_arn, 'to_dict'):
                props['KmsKeyArn'] = self.kms_key_arn.to_dict()
            elif isinstance(self.kms_key_arn, list):
                props['KmsKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_arn
                ]
            else:
                props['KmsKeyArn'] = self.kms_key_arn

        return props


@dataclass
class VerifiedAccessEndpoint(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VerifiedAccessEndpoint"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    attachment_type: Optional[Union[str, VerifiedAccessEndpointAttachmentType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_certificate_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    verified_access_group_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    load_balancer_options: Optional[LoadBalancerOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    application_domain: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_options: Optional[CidrOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    endpoint_domain_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    endpoint_type: Optional[Union[str, VerifiedAccessEndpointType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_document: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rds_options: Optional[RdsOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sse_specification: Optional[SseSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_interface_options: Optional[NetworkInterfaceOptions] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.attachment_type is not None:
            # Serialize attachment_type (handle intrinsic functions)
            if hasattr(self.attachment_type, 'to_dict'):
                props["AttachmentType"] = self.attachment_type.to_dict()
            elif isinstance(self.attachment_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['AttachmentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attachment_type
                ]
            else:
                props["AttachmentType"] = self.attachment_type

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.domain_certificate_arn is not None:
            # Serialize domain_certificate_arn (handle intrinsic functions)
            if hasattr(self.domain_certificate_arn, 'to_dict'):
                props["DomainCertificateArn"] = self.domain_certificate_arn.to_dict()
            elif isinstance(self.domain_certificate_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainCertificateArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_certificate_arn
                ]
            else:
                props["DomainCertificateArn"] = self.domain_certificate_arn

        if self.verified_access_group_id is not None:
            # Serialize verified_access_group_id (handle intrinsic functions)
            if hasattr(self.verified_access_group_id, 'to_dict'):
                props["VerifiedAccessGroupId"] = self.verified_access_group_id.to_dict()
            elif isinstance(self.verified_access_group_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VerifiedAccessGroupId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.verified_access_group_id
                ]
            else:
                props["VerifiedAccessGroupId"] = self.verified_access_group_id

        if self.security_group_ids is not None:
            # Serialize security_group_ids (handle intrinsic functions)
            if hasattr(self.security_group_ids, 'to_dict'):
                props["SecurityGroupIds"] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props["SecurityGroupIds"] = self.security_group_ids

        if self.load_balancer_options is not None:
            # Serialize load_balancer_options (handle intrinsic functions)
            if hasattr(self.load_balancer_options, 'to_dict'):
                props["LoadBalancerOptions"] = self.load_balancer_options.to_dict()
            elif isinstance(self.load_balancer_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['LoadBalancerOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.load_balancer_options
                ]
            else:
                props["LoadBalancerOptions"] = self.load_balancer_options

        if self.application_domain is not None:
            # Serialize application_domain (handle intrinsic functions)
            if hasattr(self.application_domain, 'to_dict'):
                props["ApplicationDomain"] = self.application_domain.to_dict()
            elif isinstance(self.application_domain, list):
                # Serialize list items (may contain intrinsic functions)
                props['ApplicationDomain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.application_domain
                ]
            else:
                props["ApplicationDomain"] = self.application_domain

        if self.policy_enabled is not None:
            # Serialize policy_enabled (handle intrinsic functions)
            if hasattr(self.policy_enabled, 'to_dict'):
                props["PolicyEnabled"] = self.policy_enabled.to_dict()
            elif isinstance(self.policy_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_enabled
                ]
            else:
                props["PolicyEnabled"] = self.policy_enabled

        if self.cidr_options is not None:
            # Serialize cidr_options (handle intrinsic functions)
            if hasattr(self.cidr_options, 'to_dict'):
                props["CidrOptions"] = self.cidr_options.to_dict()
            elif isinstance(self.cidr_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_options
                ]
            else:
                props["CidrOptions"] = self.cidr_options

        if self.endpoint_domain_prefix is not None:
            # Serialize endpoint_domain_prefix (handle intrinsic functions)
            if hasattr(self.endpoint_domain_prefix, 'to_dict'):
                props["EndpointDomainPrefix"] = self.endpoint_domain_prefix.to_dict()
            elif isinstance(self.endpoint_domain_prefix, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndpointDomainPrefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_domain_prefix
                ]
            else:
                props["EndpointDomainPrefix"] = self.endpoint_domain_prefix

        if self.endpoint_type is not None:
            # Serialize endpoint_type (handle intrinsic functions)
            if hasattr(self.endpoint_type, 'to_dict'):
                props["EndpointType"] = self.endpoint_type.to_dict()
            elif isinstance(self.endpoint_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndpointType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_type
                ]
            else:
                props["EndpointType"] = self.endpoint_type

        if self.policy_document is not None:
            # Serialize policy_document (handle intrinsic functions)
            if hasattr(self.policy_document, 'to_dict'):
                props["PolicyDocument"] = self.policy_document.to_dict()
            elif isinstance(self.policy_document, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyDocument'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_document
                ]
            else:
                props["PolicyDocument"] = self.policy_document

        if self.rds_options is not None:
            # Serialize rds_options (handle intrinsic functions)
            if hasattr(self.rds_options, 'to_dict'):
                props["RdsOptions"] = self.rds_options.to_dict()
            elif isinstance(self.rds_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['RdsOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rds_options
                ]
            else:
                props["RdsOptions"] = self.rds_options

        if self.sse_specification is not None:
            # Serialize sse_specification (handle intrinsic functions)
            if hasattr(self.sse_specification, 'to_dict'):
                props["SseSpecification"] = self.sse_specification.to_dict()
            elif isinstance(self.sse_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['SseSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sse_specification
                ]
            else:
                props["SseSpecification"] = self.sse_specification

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.network_interface_options is not None:
            # Serialize network_interface_options (handle intrinsic functions)
            if hasattr(self.network_interface_options, 'to_dict'):
                props["NetworkInterfaceOptions"] = self.network_interface_options.to_dict()
            elif isinstance(self.network_interface_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkInterfaceOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_interface_options
                ]
            else:
                props["NetworkInterfaceOptions"] = self.network_interface_options

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_endpoint_domain(self) -> GetAtt:
        """Get the EndpointDomain attribute."""
        return self.get_att("EndpointDomain")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_last_updated_time(self) -> GetAtt:
        """Get the LastUpdatedTime attribute."""
        return self.get_att("LastUpdatedTime")

    @property
    def attr_device_validation_domain(self) -> GetAtt:
        """Get the DeviceValidationDomain attribute."""
        return self.get_att("DeviceValidationDomain")

    @property
    def attr_verified_access_instance_id(self) -> GetAtt:
        """Get the VerifiedAccessInstanceId attribute."""
        return self.get_att("VerifiedAccessInstanceId")

    @property
    def attr_verified_access_endpoint_id(self) -> GetAtt:
        """Get the VerifiedAccessEndpointId attribute."""
        return self.get_att("VerifiedAccessEndpointId")




@dataclass
class SseSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customer_managed_key_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.customer_managed_key_enabled is not None:
            if hasattr(self.customer_managed_key_enabled, 'to_dict'):
                props['CustomerManagedKeyEnabled'] = self.customer_managed_key_enabled.to_dict()
            elif isinstance(self.customer_managed_key_enabled, list):
                props['CustomerManagedKeyEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customer_managed_key_enabled
                ]
            else:
                props['CustomerManagedKeyEnabled'] = self.customer_managed_key_enabled

        if self.kms_key_arn is not None:
            if hasattr(self.kms_key_arn, 'to_dict'):
                props['KmsKeyArn'] = self.kms_key_arn.to_dict()
            elif isinstance(self.kms_key_arn, list):
                props['KmsKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_arn
                ]
            else:
                props['KmsKeyArn'] = self.kms_key_arn

        return props


@dataclass
class VerifiedAccessGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VerifiedAccessGroup"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_document: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sse_specification: Optional[SseSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    verified_access_instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.policy_document is not None:
            # Serialize policy_document (handle intrinsic functions)
            if hasattr(self.policy_document, 'to_dict'):
                props["PolicyDocument"] = self.policy_document.to_dict()
            elif isinstance(self.policy_document, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyDocument'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_document
                ]
            else:
                props["PolicyDocument"] = self.policy_document

        if self.sse_specification is not None:
            # Serialize sse_specification (handle intrinsic functions)
            if hasattr(self.sse_specification, 'to_dict'):
                props["SseSpecification"] = self.sse_specification.to_dict()
            elif isinstance(self.sse_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['SseSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sse_specification
                ]
            else:
                props["SseSpecification"] = self.sse_specification

        if self.verified_access_instance_id is not None:
            # Serialize verified_access_instance_id (handle intrinsic functions)
            if hasattr(self.verified_access_instance_id, 'to_dict'):
                props["VerifiedAccessInstanceId"] = self.verified_access_instance_id.to_dict()
            elif isinstance(self.verified_access_instance_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VerifiedAccessInstanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.verified_access_instance_id
                ]
            else:
                props["VerifiedAccessInstanceId"] = self.verified_access_instance_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.policy_enabled is not None:
            # Serialize policy_enabled (handle intrinsic functions)
            if hasattr(self.policy_enabled, 'to_dict'):
                props["PolicyEnabled"] = self.policy_enabled.to_dict()
            elif isinstance(self.policy_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_enabled
                ]
            else:
                props["PolicyEnabled"] = self.policy_enabled

        return props

    @property
    def attr_owner(self) -> GetAtt:
        """Get the Owner attribute."""
        return self.get_att("Owner")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_last_updated_time(self) -> GetAtt:
        """Get the LastUpdatedTime attribute."""
        return self.get_att("LastUpdatedTime")

    @property
    def attr_verified_access_group_id(self) -> GetAtt:
        """Get the VerifiedAccessGroupId attribute."""
        return self.get_att("VerifiedAccessGroupId")

    @property
    def attr_verified_access_group_arn(self) -> GetAtt:
        """Get the VerifiedAccessGroupArn attribute."""
        return self.get_att("VerifiedAccessGroupArn")




@dataclass
class CloudWatchLogs:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.log_group is not None:
            if hasattr(self.log_group, 'to_dict'):
                props['LogGroup'] = self.log_group.to_dict()
            elif isinstance(self.log_group, list):
                props['LogGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_group
                ]
            else:
                props['LogGroup'] = self.log_group

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class KinesisDataFirehose:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    delivery_stream: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.delivery_stream is not None:
            if hasattr(self.delivery_stream, 'to_dict'):
                props['DeliveryStream'] = self.delivery_stream.to_dict()
            elif isinstance(self.delivery_stream, list):
                props['DeliveryStream'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.delivery_stream
                ]
            else:
                props['DeliveryStream'] = self.delivery_stream

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class S3:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket_owner: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.bucket_name is not None:
            if hasattr(self.bucket_name, 'to_dict'):
                props['BucketName'] = self.bucket_name.to_dict()
            elif isinstance(self.bucket_name, list):
                props['BucketName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket_name
                ]
            else:
                props['BucketName'] = self.bucket_name

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        if self.prefix is not None:
            if hasattr(self.prefix, 'to_dict'):
                props['Prefix'] = self.prefix.to_dict()
            elif isinstance(self.prefix, list):
                props['Prefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.prefix
                ]
            else:
                props['Prefix'] = self.prefix

        if self.bucket_owner is not None:
            if hasattr(self.bucket_owner, 'to_dict'):
                props['BucketOwner'] = self.bucket_owner.to_dict()
            elif isinstance(self.bucket_owner, list):
                props['BucketOwner'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket_owner
                ]
            else:
                props['BucketOwner'] = self.bucket_owner

        return props


@dataclass
class VerifiedAccessLogs:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3: Optional[S3] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    log_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kinesis_data_firehose: Optional[KinesisDataFirehose] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logs: Optional[CloudWatchLogs] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    include_trust_context: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3 is not None:
            if hasattr(self.s3, 'to_dict'):
                props['S3'] = self.s3.to_dict()
            elif isinstance(self.s3, list):
                props['S3'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3
                ]
            else:
                props['S3'] = self.s3

        if self.log_version is not None:
            if hasattr(self.log_version, 'to_dict'):
                props['LogVersion'] = self.log_version.to_dict()
            elif isinstance(self.log_version, list):
                props['LogVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_version
                ]
            else:
                props['LogVersion'] = self.log_version

        if self.kinesis_data_firehose is not None:
            if hasattr(self.kinesis_data_firehose, 'to_dict'):
                props['KinesisDataFirehose'] = self.kinesis_data_firehose.to_dict()
            elif isinstance(self.kinesis_data_firehose, list):
                props['KinesisDataFirehose'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kinesis_data_firehose
                ]
            else:
                props['KinesisDataFirehose'] = self.kinesis_data_firehose

        if self.cloud_watch_logs is not None:
            if hasattr(self.cloud_watch_logs, 'to_dict'):
                props['CloudWatchLogs'] = self.cloud_watch_logs.to_dict()
            elif isinstance(self.cloud_watch_logs, list):
                props['CloudWatchLogs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cloud_watch_logs
                ]
            else:
                props['CloudWatchLogs'] = self.cloud_watch_logs

        if self.include_trust_context is not None:
            if hasattr(self.include_trust_context, 'to_dict'):
                props['IncludeTrustContext'] = self.include_trust_context.to_dict()
            elif isinstance(self.include_trust_context, list):
                props['IncludeTrustContext'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.include_trust_context
                ]
            else:
                props['IncludeTrustContext'] = self.include_trust_context

        return props


@dataclass
class VerifiedAccessTrustProvider:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_trust_provider_type: Optional[Union[str, DeviceTrustProviderType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    verified_access_trust_provider_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    trust_provider_type: Optional[Union[str, TrustProviderType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_trust_provider_type: Optional[Union[str, UserTrustProviderType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.device_trust_provider_type is not None:
            if hasattr(self.device_trust_provider_type, 'to_dict'):
                props['DeviceTrustProviderType'] = self.device_trust_provider_type.to_dict()
            elif isinstance(self.device_trust_provider_type, list):
                props['DeviceTrustProviderType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_trust_provider_type
                ]
            else:
                props['DeviceTrustProviderType'] = self.device_trust_provider_type

        if self.verified_access_trust_provider_id is not None:
            if hasattr(self.verified_access_trust_provider_id, 'to_dict'):
                props['VerifiedAccessTrustProviderId'] = self.verified_access_trust_provider_id.to_dict()
            elif isinstance(self.verified_access_trust_provider_id, list):
                props['VerifiedAccessTrustProviderId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.verified_access_trust_provider_id
                ]
            else:
                props['VerifiedAccessTrustProviderId'] = self.verified_access_trust_provider_id

        if self.trust_provider_type is not None:
            if hasattr(self.trust_provider_type, 'to_dict'):
                props['TrustProviderType'] = self.trust_provider_type.to_dict()
            elif isinstance(self.trust_provider_type, list):
                props['TrustProviderType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.trust_provider_type
                ]
            else:
                props['TrustProviderType'] = self.trust_provider_type

        if self.user_trust_provider_type is not None:
            if hasattr(self.user_trust_provider_type, 'to_dict'):
                props['UserTrustProviderType'] = self.user_trust_provider_type.to_dict()
            elif isinstance(self.user_trust_provider_type, list):
                props['UserTrustProviderType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_trust_provider_type
                ]
            else:
                props['UserTrustProviderType'] = self.user_trust_provider_type

        return props


@dataclass
class VerifiedAccessInstance(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VerifiedAccessInstance"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    verified_access_trust_providers: Optional[list[VerifiedAccessTrustProvider]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    fips_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    logging_configurations: Optional[VerifiedAccessLogs] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cidr_endpoints_custom_sub_domain: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    verified_access_trust_provider_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.verified_access_trust_providers is not None:
            # Serialize verified_access_trust_providers (handle intrinsic functions)
            if hasattr(self.verified_access_trust_providers, 'to_dict'):
                props["VerifiedAccessTrustProviders"] = self.verified_access_trust_providers.to_dict()
            elif isinstance(self.verified_access_trust_providers, list):
                # Serialize list items (may contain intrinsic functions)
                props['VerifiedAccessTrustProviders'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.verified_access_trust_providers
                ]
            else:
                props["VerifiedAccessTrustProviders"] = self.verified_access_trust_providers

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.fips_enabled is not None:
            # Serialize fips_enabled (handle intrinsic functions)
            if hasattr(self.fips_enabled, 'to_dict'):
                props["FipsEnabled"] = self.fips_enabled.to_dict()
            elif isinstance(self.fips_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['FipsEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fips_enabled
                ]
            else:
                props["FipsEnabled"] = self.fips_enabled

        if self.logging_configurations is not None:
            # Serialize logging_configurations (handle intrinsic functions)
            if hasattr(self.logging_configurations, 'to_dict'):
                props["LoggingConfigurations"] = self.logging_configurations.to_dict()
            elif isinstance(self.logging_configurations, list):
                # Serialize list items (may contain intrinsic functions)
                props['LoggingConfigurations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.logging_configurations
                ]
            else:
                props["LoggingConfigurations"] = self.logging_configurations

        if self.cidr_endpoints_custom_sub_domain is not None:
            # Serialize cidr_endpoints_custom_sub_domain (handle intrinsic functions)
            if hasattr(self.cidr_endpoints_custom_sub_domain, 'to_dict'):
                props["CidrEndpointsCustomSubDomain"] = self.cidr_endpoints_custom_sub_domain.to_dict()
            elif isinstance(self.cidr_endpoints_custom_sub_domain, list):
                # Serialize list items (may contain intrinsic functions)
                props['CidrEndpointsCustomSubDomain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cidr_endpoints_custom_sub_domain
                ]
            else:
                props["CidrEndpointsCustomSubDomain"] = self.cidr_endpoints_custom_sub_domain

        if self.verified_access_trust_provider_ids is not None:
            # Serialize verified_access_trust_provider_ids (handle intrinsic functions)
            if hasattr(self.verified_access_trust_provider_ids, 'to_dict'):
                props["VerifiedAccessTrustProviderIds"] = self.verified_access_trust_provider_ids.to_dict()
            elif isinstance(self.verified_access_trust_provider_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['VerifiedAccessTrustProviderIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.verified_access_trust_provider_ids
                ]
            else:
                props["VerifiedAccessTrustProviderIds"] = self.verified_access_trust_provider_ids

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_cidr_endpoints_custom_sub_domain_name_servers(self) -> GetAtt:
        """Get the CidrEndpointsCustomSubDomainNameServers attribute."""
        return self.get_att("CidrEndpointsCustomSubDomainNameServers")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_last_updated_time(self) -> GetAtt:
        """Get the LastUpdatedTime attribute."""
        return self.get_att("LastUpdatedTime")

    @property
    def attr_verified_access_instance_id(self) -> GetAtt:
        """Get the VerifiedAccessInstanceId attribute."""
        return self.get_att("VerifiedAccessInstanceId")




@dataclass
class DeviceOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tenant_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    public_signing_key_url: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.tenant_id is not None:
            if hasattr(self.tenant_id, 'to_dict'):
                props['TenantId'] = self.tenant_id.to_dict()
            elif isinstance(self.tenant_id, list):
                props['TenantId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tenant_id
                ]
            else:
                props['TenantId'] = self.tenant_id

        if self.public_signing_key_url is not None:
            if hasattr(self.public_signing_key_url, 'to_dict'):
                props['PublicSigningKeyUrl'] = self.public_signing_key_url.to_dict()
            elif isinstance(self.public_signing_key_url, list):
                props['PublicSigningKeyUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_signing_key_url
                ]
            else:
                props['PublicSigningKeyUrl'] = self.public_signing_key_url

        return props


@dataclass
class NativeApplicationOidcOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    token_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scope: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    issuer: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    client_secret: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_info_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    client_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    authorization_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    public_signing_key_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.token_endpoint is not None:
            if hasattr(self.token_endpoint, 'to_dict'):
                props['TokenEndpoint'] = self.token_endpoint.to_dict()
            elif isinstance(self.token_endpoint, list):
                props['TokenEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.token_endpoint
                ]
            else:
                props['TokenEndpoint'] = self.token_endpoint

        if self.scope is not None:
            if hasattr(self.scope, 'to_dict'):
                props['Scope'] = self.scope.to_dict()
            elif isinstance(self.scope, list):
                props['Scope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scope
                ]
            else:
                props['Scope'] = self.scope

        if self.issuer is not None:
            if hasattr(self.issuer, 'to_dict'):
                props['Issuer'] = self.issuer.to_dict()
            elif isinstance(self.issuer, list):
                props['Issuer'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.issuer
                ]
            else:
                props['Issuer'] = self.issuer

        if self.client_secret is not None:
            if hasattr(self.client_secret, 'to_dict'):
                props['ClientSecret'] = self.client_secret.to_dict()
            elif isinstance(self.client_secret, list):
                props['ClientSecret'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_secret
                ]
            else:
                props['ClientSecret'] = self.client_secret

        if self.user_info_endpoint is not None:
            if hasattr(self.user_info_endpoint, 'to_dict'):
                props['UserInfoEndpoint'] = self.user_info_endpoint.to_dict()
            elif isinstance(self.user_info_endpoint, list):
                props['UserInfoEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_info_endpoint
                ]
            else:
                props['UserInfoEndpoint'] = self.user_info_endpoint

        if self.client_id is not None:
            if hasattr(self.client_id, 'to_dict'):
                props['ClientId'] = self.client_id.to_dict()
            elif isinstance(self.client_id, list):
                props['ClientId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_id
                ]
            else:
                props['ClientId'] = self.client_id

        if self.authorization_endpoint is not None:
            if hasattr(self.authorization_endpoint, 'to_dict'):
                props['AuthorizationEndpoint'] = self.authorization_endpoint.to_dict()
            elif isinstance(self.authorization_endpoint, list):
                props['AuthorizationEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.authorization_endpoint
                ]
            else:
                props['AuthorizationEndpoint'] = self.authorization_endpoint

        if self.public_signing_key_endpoint is not None:
            if hasattr(self.public_signing_key_endpoint, 'to_dict'):
                props['PublicSigningKeyEndpoint'] = self.public_signing_key_endpoint.to_dict()
            elif isinstance(self.public_signing_key_endpoint, list):
                props['PublicSigningKeyEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.public_signing_key_endpoint
                ]
            else:
                props['PublicSigningKeyEndpoint'] = self.public_signing_key_endpoint

        return props


@dataclass
class OidcOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    token_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scope: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    issuer: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    client_secret: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_info_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    client_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    authorization_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.token_endpoint is not None:
            if hasattr(self.token_endpoint, 'to_dict'):
                props['TokenEndpoint'] = self.token_endpoint.to_dict()
            elif isinstance(self.token_endpoint, list):
                props['TokenEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.token_endpoint
                ]
            else:
                props['TokenEndpoint'] = self.token_endpoint

        if self.scope is not None:
            if hasattr(self.scope, 'to_dict'):
                props['Scope'] = self.scope.to_dict()
            elif isinstance(self.scope, list):
                props['Scope'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scope
                ]
            else:
                props['Scope'] = self.scope

        if self.issuer is not None:
            if hasattr(self.issuer, 'to_dict'):
                props['Issuer'] = self.issuer.to_dict()
            elif isinstance(self.issuer, list):
                props['Issuer'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.issuer
                ]
            else:
                props['Issuer'] = self.issuer

        if self.client_secret is not None:
            if hasattr(self.client_secret, 'to_dict'):
                props['ClientSecret'] = self.client_secret.to_dict()
            elif isinstance(self.client_secret, list):
                props['ClientSecret'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_secret
                ]
            else:
                props['ClientSecret'] = self.client_secret

        if self.user_info_endpoint is not None:
            if hasattr(self.user_info_endpoint, 'to_dict'):
                props['UserInfoEndpoint'] = self.user_info_endpoint.to_dict()
            elif isinstance(self.user_info_endpoint, list):
                props['UserInfoEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_info_endpoint
                ]
            else:
                props['UserInfoEndpoint'] = self.user_info_endpoint

        if self.client_id is not None:
            if hasattr(self.client_id, 'to_dict'):
                props['ClientId'] = self.client_id.to_dict()
            elif isinstance(self.client_id, list):
                props['ClientId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_id
                ]
            else:
                props['ClientId'] = self.client_id

        if self.authorization_endpoint is not None:
            if hasattr(self.authorization_endpoint, 'to_dict'):
                props['AuthorizationEndpoint'] = self.authorization_endpoint.to_dict()
            elif isinstance(self.authorization_endpoint, list):
                props['AuthorizationEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.authorization_endpoint
                ]
            else:
                props['AuthorizationEndpoint'] = self.authorization_endpoint

        return props


@dataclass
class SseSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customer_managed_key_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.customer_managed_key_enabled is not None:
            if hasattr(self.customer_managed_key_enabled, 'to_dict'):
                props['CustomerManagedKeyEnabled'] = self.customer_managed_key_enabled.to_dict()
            elif isinstance(self.customer_managed_key_enabled, list):
                props['CustomerManagedKeyEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customer_managed_key_enabled
                ]
            else:
                props['CustomerManagedKeyEnabled'] = self.customer_managed_key_enabled

        if self.kms_key_arn is not None:
            if hasattr(self.kms_key_arn, 'to_dict'):
                props['KmsKeyArn'] = self.kms_key_arn.to_dict()
            elif isinstance(self.kms_key_arn, list):
                props['KmsKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_arn
                ]
            else:
                props['KmsKeyArn'] = self.kms_key_arn

        return props


@dataclass
class VerifiedAccessTrustProvider(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VerifiedAccessTrustProvider"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy_reference_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    device_options: Optional[DeviceOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    native_application_oidc_options: Optional[NativeApplicationOidcOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    device_trust_provider_type: Optional[Union[str, DeviceTrustProviderType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    oidc_options: Optional[OidcOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    trust_provider_type: Optional[Union[str, TrustProviderType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sse_specification: Optional[SseSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    user_trust_provider_type: Optional[Union[str, UserTrustProviderType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.policy_reference_name is not None:
            # Serialize policy_reference_name (handle intrinsic functions)
            if hasattr(self.policy_reference_name, 'to_dict'):
                props["PolicyReferenceName"] = self.policy_reference_name.to_dict()
            elif isinstance(self.policy_reference_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolicyReferenceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy_reference_name
                ]
            else:
                props["PolicyReferenceName"] = self.policy_reference_name

        if self.device_options is not None:
            # Serialize device_options (handle intrinsic functions)
            if hasattr(self.device_options, 'to_dict'):
                props["DeviceOptions"] = self.device_options.to_dict()
            elif isinstance(self.device_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeviceOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_options
                ]
            else:
                props["DeviceOptions"] = self.device_options

        if self.native_application_oidc_options is not None:
            # Serialize native_application_oidc_options (handle intrinsic functions)
            if hasattr(self.native_application_oidc_options, 'to_dict'):
                props["NativeApplicationOidcOptions"] = self.native_application_oidc_options.to_dict()
            elif isinstance(self.native_application_oidc_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['NativeApplicationOidcOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.native_application_oidc_options
                ]
            else:
                props["NativeApplicationOidcOptions"] = self.native_application_oidc_options

        if self.device_trust_provider_type is not None:
            # Serialize device_trust_provider_type (handle intrinsic functions)
            if hasattr(self.device_trust_provider_type, 'to_dict'):
                props["DeviceTrustProviderType"] = self.device_trust_provider_type.to_dict()
            elif isinstance(self.device_trust_provider_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeviceTrustProviderType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_trust_provider_type
                ]
            else:
                props["DeviceTrustProviderType"] = self.device_trust_provider_type

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.oidc_options is not None:
            # Serialize oidc_options (handle intrinsic functions)
            if hasattr(self.oidc_options, 'to_dict'):
                props["OidcOptions"] = self.oidc_options.to_dict()
            elif isinstance(self.oidc_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['OidcOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.oidc_options
                ]
            else:
                props["OidcOptions"] = self.oidc_options

        if self.trust_provider_type is not None:
            # Serialize trust_provider_type (handle intrinsic functions)
            if hasattr(self.trust_provider_type, 'to_dict'):
                props["TrustProviderType"] = self.trust_provider_type.to_dict()
            elif isinstance(self.trust_provider_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['TrustProviderType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.trust_provider_type
                ]
            else:
                props["TrustProviderType"] = self.trust_provider_type

        if self.sse_specification is not None:
            # Serialize sse_specification (handle intrinsic functions)
            if hasattr(self.sse_specification, 'to_dict'):
                props["SseSpecification"] = self.sse_specification.to_dict()
            elif isinstance(self.sse_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['SseSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sse_specification
                ]
            else:
                props["SseSpecification"] = self.sse_specification

        if self.user_trust_provider_type is not None:
            # Serialize user_trust_provider_type (handle intrinsic functions)
            if hasattr(self.user_trust_provider_type, 'to_dict'):
                props["UserTrustProviderType"] = self.user_trust_provider_type.to_dict()
            elif isinstance(self.user_trust_provider_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['UserTrustProviderType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_trust_provider_type
                ]
            else:
                props["UserTrustProviderType"] = self.user_trust_provider_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_verified_access_trust_provider_id(self) -> GetAtt:
        """Get the VerifiedAccessTrustProviderId attribute."""
        return self.get_att("VerifiedAccessTrustProviderId")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_last_updated_time(self) -> GetAtt:
        """Get the LastUpdatedTime attribute."""
        return self.get_att("LastUpdatedTime")




@dataclass
class Volume(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::Volume"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    multi_attach_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    encrypted: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_enable_io: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    outpost_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    availability_zone: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    throughput: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    volume_initialization_rate: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    snapshot_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    volume_type: Optional[Union[str, VolumeType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_volume_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.multi_attach_enabled is not None:
            # Serialize multi_attach_enabled (handle intrinsic functions)
            if hasattr(self.multi_attach_enabled, 'to_dict'):
                props["MultiAttachEnabled"] = self.multi_attach_enabled.to_dict()
            elif isinstance(self.multi_attach_enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['MultiAttachEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.multi_attach_enabled
                ]
            else:
                props["MultiAttachEnabled"] = self.multi_attach_enabled

        if self.kms_key_id is not None:
            # Serialize kms_key_id (handle intrinsic functions)
            if hasattr(self.kms_key_id, 'to_dict'):
                props["KmsKeyId"] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props["KmsKeyId"] = self.kms_key_id

        if self.encrypted is not None:
            # Serialize encrypted (handle intrinsic functions)
            if hasattr(self.encrypted, 'to_dict'):
                props["Encrypted"] = self.encrypted.to_dict()
            elif isinstance(self.encrypted, list):
                # Serialize list items (may contain intrinsic functions)
                props['Encrypted'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encrypted
                ]
            else:
                props["Encrypted"] = self.encrypted

        if self.size is not None:
            # Serialize size (handle intrinsic functions)
            if hasattr(self.size, 'to_dict'):
                props["Size"] = self.size.to_dict()
            elif isinstance(self.size, list):
                # Serialize list items (may contain intrinsic functions)
                props['Size'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.size
                ]
            else:
                props["Size"] = self.size

        if self.auto_enable_io is not None:
            # Serialize auto_enable_io (handle intrinsic functions)
            if hasattr(self.auto_enable_io, 'to_dict'):
                props["AutoEnableIO"] = self.auto_enable_io.to_dict()
            elif isinstance(self.auto_enable_io, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoEnableIO'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_enable_io
                ]
            else:
                props["AutoEnableIO"] = self.auto_enable_io

        if self.outpost_arn is not None:
            # Serialize outpost_arn (handle intrinsic functions)
            if hasattr(self.outpost_arn, 'to_dict'):
                props["OutpostArn"] = self.outpost_arn.to_dict()
            elif isinstance(self.outpost_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutpostArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.outpost_arn
                ]
            else:
                props["OutpostArn"] = self.outpost_arn

        if self.availability_zone_id is not None:
            # Serialize availability_zone_id (handle intrinsic functions)
            if hasattr(self.availability_zone_id, 'to_dict'):
                props["AvailabilityZoneId"] = self.availability_zone_id.to_dict()
            elif isinstance(self.availability_zone_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZoneId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone_id
                ]
            else:
                props["AvailabilityZoneId"] = self.availability_zone_id

        if self.availability_zone is not None:
            # Serialize availability_zone (handle intrinsic functions)
            if hasattr(self.availability_zone, 'to_dict'):
                props["AvailabilityZone"] = self.availability_zone.to_dict()
            elif isinstance(self.availability_zone, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailabilityZone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone
                ]
            else:
                props["AvailabilityZone"] = self.availability_zone

        if self.throughput is not None:
            # Serialize throughput (handle intrinsic functions)
            if hasattr(self.throughput, 'to_dict'):
                props["Throughput"] = self.throughput.to_dict()
            elif isinstance(self.throughput, list):
                # Serialize list items (may contain intrinsic functions)
                props['Throughput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.throughput
                ]
            else:
                props["Throughput"] = self.throughput

        if self.iops is not None:
            # Serialize iops (handle intrinsic functions)
            if hasattr(self.iops, 'to_dict'):
                props["Iops"] = self.iops.to_dict()
            elif isinstance(self.iops, list):
                # Serialize list items (may contain intrinsic functions)
                props['Iops'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iops
                ]
            else:
                props["Iops"] = self.iops

        if self.volume_initialization_rate is not None:
            # Serialize volume_initialization_rate (handle intrinsic functions)
            if hasattr(self.volume_initialization_rate, 'to_dict'):
                props["VolumeInitializationRate"] = self.volume_initialization_rate.to_dict()
            elif isinstance(self.volume_initialization_rate, list):
                # Serialize list items (may contain intrinsic functions)
                props['VolumeInitializationRate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_initialization_rate
                ]
            else:
                props["VolumeInitializationRate"] = self.volume_initialization_rate

        if self.snapshot_id is not None:
            # Serialize snapshot_id (handle intrinsic functions)
            if hasattr(self.snapshot_id, 'to_dict'):
                props["SnapshotId"] = self.snapshot_id.to_dict()
            elif isinstance(self.snapshot_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SnapshotId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snapshot_id
                ]
            else:
                props["SnapshotId"] = self.snapshot_id

        if self.volume_type is not None:
            # Serialize volume_type (handle intrinsic functions)
            if hasattr(self.volume_type, 'to_dict'):
                props["VolumeType"] = self.volume_type.to_dict()
            elif isinstance(self.volume_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['VolumeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_type
                ]
            else:
                props["VolumeType"] = self.volume_type

        if self.source_volume_id is not None:
            # Serialize source_volume_id (handle intrinsic functions)
            if hasattr(self.source_volume_id, 'to_dict'):
                props["SourceVolumeId"] = self.source_volume_id.to_dict()
            elif isinstance(self.source_volume_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceVolumeId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_volume_id
                ]
            else:
                props["SourceVolumeId"] = self.source_volume_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_volume_id(self) -> GetAtt:
        """Get the VolumeId attribute."""
        return self.get_att("VolumeId")




@dataclass
class VolumeAttachment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-v"""

    resource_type: ClassVar[str] = "AWS::EC2::VolumeAttachment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    volume_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    device: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.volume_id is not None:
            # Serialize volume_id (handle intrinsic functions)
            if hasattr(self.volume_id, 'to_dict'):
                props["VolumeId"] = self.volume_id.to_dict()
            elif isinstance(self.volume_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VolumeId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_id
                ]
            else:
                props["VolumeId"] = self.volume_id

        if self.instance_id is not None:
            # Serialize instance_id (handle intrinsic functions)
            if hasattr(self.instance_id, 'to_dict'):
                props["InstanceId"] = self.instance_id.to_dict()
            elif isinstance(self.instance_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_id
                ]
            else:
                props["InstanceId"] = self.instance_id

        if self.device is not None:
            # Serialize device (handle intrinsic functions)
            if hasattr(self.device, 'to_dict'):
                props["Device"] = self.device.to_dict()
            elif isinstance(self.device, list):
                # Serialize list items (may contain intrinsic functions)
                props['Device'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device
                ]
            else:
                props["Device"] = self.device

        return props


