"""
AWS CloudFormation Elasticsearch Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:36

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service Elasticsearch
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AutoTuneDesiredState:
    """AutoTuneDesiredState enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class AutoTuneState:
    """AutoTuneState enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"
    ENABLE_IN_PROGRESS = "ENABLE_IN_PROGRESS"
    DISABLE_IN_PROGRESS = "DISABLE_IN_PROGRESS"
    DISABLED_AND_ROLLBACK_SCHEDULED = "DISABLED_AND_ROLLBACK_SCHEDULED"
    DISABLED_AND_ROLLBACK_IN_PROGRESS = "DISABLED_AND_ROLLBACK_IN_PROGRESS"
    DISABLED_AND_ROLLBACK_COMPLETE = "DISABLED_AND_ROLLBACK_COMPLETE"
    DISABLED_AND_ROLLBACK_ERROR = "DISABLED_AND_ROLLBACK_ERROR"
    ERROR = "ERROR"


class AutoTuneType:
    """AutoTuneType enum values."""

    SCHEDULED_ACTION = "SCHEDULED_ACTION"


class ConfigChangeStatus:
    """ConfigChangeStatus enum values."""

    PENDING = "Pending"
    INITIALIZING = "Initializing"
    VALIDATING = "Validating"
    VALIDATIONFAILED = "ValidationFailed"
    APPLYINGCHANGES = "ApplyingChanges"
    COMPLETED = "Completed"
    PENDINGUSERINPUT = "PendingUserInput"
    CANCELLED = "Cancelled"


class DeploymentStatus:
    """DeploymentStatus enum values."""

    PENDING_UPDATE = "PENDING_UPDATE"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    NOT_ELIGIBLE = "NOT_ELIGIBLE"
    ELIGIBLE = "ELIGIBLE"


class DescribePackagesFilterName:
    """DescribePackagesFilterName enum values."""

    PACKAGEID = "PackageID"
    PACKAGENAME = "PackageName"
    PACKAGESTATUS = "PackageStatus"


class DomainPackageStatus:
    """DomainPackageStatus enum values."""

    ASSOCIATING = "ASSOCIATING"
    ASSOCIATION_FAILED = "ASSOCIATION_FAILED"
    ACTIVE = "ACTIVE"
    DISSOCIATING = "DISSOCIATING"
    DISSOCIATION_FAILED = "DISSOCIATION_FAILED"


class DomainProcessingStatusType:
    """DomainProcessingStatusType enum values."""

    CREATING = "Creating"
    ACTIVE = "Active"
    MODIFYING = "Modifying"
    UPGRADINGENGINEVERSION = "UpgradingEngineVersion"
    UPDATINGSERVICESOFTWARE = "UpdatingServiceSoftware"
    ISOLATED = "Isolated"
    DELETING = "Deleting"


class ESPartitionInstanceType:
    """ESPartitionInstanceType enum values."""

    M3_MEDIUM_ELASTICSEARCH = "m3.medium.elasticsearch"
    M3_LARGE_ELASTICSEARCH = "m3.large.elasticsearch"
    M3_XLARGE_ELASTICSEARCH = "m3.xlarge.elasticsearch"
    M3_2XLARGE_ELASTICSEARCH = "m3.2xlarge.elasticsearch"
    M4_LARGE_ELASTICSEARCH = "m4.large.elasticsearch"
    M4_XLARGE_ELASTICSEARCH = "m4.xlarge.elasticsearch"
    M4_2XLARGE_ELASTICSEARCH = "m4.2xlarge.elasticsearch"
    M4_4XLARGE_ELASTICSEARCH = "m4.4xlarge.elasticsearch"
    M4_10XLARGE_ELASTICSEARCH = "m4.10xlarge.elasticsearch"
    M5_LARGE_ELASTICSEARCH = "m5.large.elasticsearch"
    M5_XLARGE_ELASTICSEARCH = "m5.xlarge.elasticsearch"
    M5_2XLARGE_ELASTICSEARCH = "m5.2xlarge.elasticsearch"
    M5_4XLARGE_ELASTICSEARCH = "m5.4xlarge.elasticsearch"
    M5_12XLARGE_ELASTICSEARCH = "m5.12xlarge.elasticsearch"
    R5_LARGE_ELASTICSEARCH = "r5.large.elasticsearch"
    R5_XLARGE_ELASTICSEARCH = "r5.xlarge.elasticsearch"
    R5_2XLARGE_ELASTICSEARCH = "r5.2xlarge.elasticsearch"
    R5_4XLARGE_ELASTICSEARCH = "r5.4xlarge.elasticsearch"
    R5_12XLARGE_ELASTICSEARCH = "r5.12xlarge.elasticsearch"
    C5_LARGE_ELASTICSEARCH = "c5.large.elasticsearch"
    C5_XLARGE_ELASTICSEARCH = "c5.xlarge.elasticsearch"
    C5_2XLARGE_ELASTICSEARCH = "c5.2xlarge.elasticsearch"
    C5_4XLARGE_ELASTICSEARCH = "c5.4xlarge.elasticsearch"
    C5_9XLARGE_ELASTICSEARCH = "c5.9xlarge.elasticsearch"
    C5_18XLARGE_ELASTICSEARCH = "c5.18xlarge.elasticsearch"
    ULTRAWARM1_MEDIUM_ELASTICSEARCH = "ultrawarm1.medium.elasticsearch"
    ULTRAWARM1_LARGE_ELASTICSEARCH = "ultrawarm1.large.elasticsearch"
    T2_MICRO_ELASTICSEARCH = "t2.micro.elasticsearch"
    T2_SMALL_ELASTICSEARCH = "t2.small.elasticsearch"
    T2_MEDIUM_ELASTICSEARCH = "t2.medium.elasticsearch"
    R3_LARGE_ELASTICSEARCH = "r3.large.elasticsearch"
    R3_XLARGE_ELASTICSEARCH = "r3.xlarge.elasticsearch"
    R3_2XLARGE_ELASTICSEARCH = "r3.2xlarge.elasticsearch"
    R3_4XLARGE_ELASTICSEARCH = "r3.4xlarge.elasticsearch"
    R3_8XLARGE_ELASTICSEARCH = "r3.8xlarge.elasticsearch"
    I2_XLARGE_ELASTICSEARCH = "i2.xlarge.elasticsearch"
    I2_2XLARGE_ELASTICSEARCH = "i2.2xlarge.elasticsearch"
    D2_XLARGE_ELASTICSEARCH = "d2.xlarge.elasticsearch"
    D2_2XLARGE_ELASTICSEARCH = "d2.2xlarge.elasticsearch"
    D2_4XLARGE_ELASTICSEARCH = "d2.4xlarge.elasticsearch"
    D2_8XLARGE_ELASTICSEARCH = "d2.8xlarge.elasticsearch"
    C4_LARGE_ELASTICSEARCH = "c4.large.elasticsearch"
    C4_XLARGE_ELASTICSEARCH = "c4.xlarge.elasticsearch"
    C4_2XLARGE_ELASTICSEARCH = "c4.2xlarge.elasticsearch"
    C4_4XLARGE_ELASTICSEARCH = "c4.4xlarge.elasticsearch"
    C4_8XLARGE_ELASTICSEARCH = "c4.8xlarge.elasticsearch"
    R4_LARGE_ELASTICSEARCH = "r4.large.elasticsearch"
    R4_XLARGE_ELASTICSEARCH = "r4.xlarge.elasticsearch"
    R4_2XLARGE_ELASTICSEARCH = "r4.2xlarge.elasticsearch"
    R4_4XLARGE_ELASTICSEARCH = "r4.4xlarge.elasticsearch"
    R4_8XLARGE_ELASTICSEARCH = "r4.8xlarge.elasticsearch"
    R4_16XLARGE_ELASTICSEARCH = "r4.16xlarge.elasticsearch"
    I3_LARGE_ELASTICSEARCH = "i3.large.elasticsearch"
    I3_XLARGE_ELASTICSEARCH = "i3.xlarge.elasticsearch"
    I3_2XLARGE_ELASTICSEARCH = "i3.2xlarge.elasticsearch"
    I3_4XLARGE_ELASTICSEARCH = "i3.4xlarge.elasticsearch"
    I3_8XLARGE_ELASTICSEARCH = "i3.8xlarge.elasticsearch"
    I3_16XLARGE_ELASTICSEARCH = "i3.16xlarge.elasticsearch"


class ESWarmPartitionInstanceType:
    """ESWarmPartitionInstanceType enum values."""

    ULTRAWARM1_MEDIUM_ELASTICSEARCH = "ultrawarm1.medium.elasticsearch"
    ULTRAWARM1_LARGE_ELASTICSEARCH = "ultrawarm1.large.elasticsearch"


class EngineType:
    """EngineType enum values."""

    OPENSEARCH = "OpenSearch"
    ELASTICSEARCH = "Elasticsearch"


class InboundCrossClusterSearchConnectionStatusCode:
    """InboundCrossClusterSearchConnectionStatusCode enum values."""

    PENDING_ACCEPTANCE = "PENDING_ACCEPTANCE"
    APPROVED = "APPROVED"
    REJECTING = "REJECTING"
    REJECTED = "REJECTED"
    DELETING = "DELETING"
    DELETED = "DELETED"


class InitiatedBy:
    """InitiatedBy enum values."""

    CUSTOMER = "CUSTOMER"
    SERVICE = "SERVICE"


class LogType:
    """LogType enum values."""

    INDEX_SLOW_LOGS = "INDEX_SLOW_LOGS"
    SEARCH_SLOW_LOGS = "SEARCH_SLOW_LOGS"
    ES_APPLICATION_LOGS = "ES_APPLICATION_LOGS"
    AUDIT_LOGS = "AUDIT_LOGS"


class OptionState:
    """OptionState enum values."""

    REQUIRESINDEXDOCUMENTS = "RequiresIndexDocuments"
    PROCESSING = "Processing"
    ACTIVE = "Active"


class OutboundCrossClusterSearchConnectionStatusCode:
    """OutboundCrossClusterSearchConnectionStatusCode enum values."""

    PENDING_ACCEPTANCE = "PENDING_ACCEPTANCE"
    VALIDATING = "VALIDATING"
    VALIDATION_FAILED = "VALIDATION_FAILED"
    PROVISIONING = "PROVISIONING"
    ACTIVE = "ACTIVE"
    REJECTED = "REJECTED"
    DELETING = "DELETING"
    DELETED = "DELETED"


class OverallChangeStatus:
    """OverallChangeStatus enum values."""

    PENDING = "PENDING"
    PROCESSING = "PROCESSING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"


class PackageStatus:
    """PackageStatus enum values."""

    COPYING = "COPYING"
    COPY_FAILED = "COPY_FAILED"
    VALIDATING = "VALIDATING"
    VALIDATION_FAILED = "VALIDATION_FAILED"
    AVAILABLE = "AVAILABLE"
    DELETING = "DELETING"
    DELETED = "DELETED"
    DELETE_FAILED = "DELETE_FAILED"


class PackageType:
    """PackageType enum values."""

    TXT_DICTIONARY = "TXT-DICTIONARY"


class PrincipalType:
    """PrincipalType enum values."""

    AWS_ACCOUNT = "AWS_ACCOUNT"
    AWS_SERVICE = "AWS_SERVICE"


class PropertyValueType:
    """PropertyValueType enum values."""

    PLAIN_TEXT = "PLAIN_TEXT"
    STRINGIFIED_JSON = "STRINGIFIED_JSON"


class ReservedElasticsearchInstancePaymentOption:
    """ReservedElasticsearchInstancePaymentOption enum values."""

    ALL_UPFRONT = "ALL_UPFRONT"
    PARTIAL_UPFRONT = "PARTIAL_UPFRONT"
    NO_UPFRONT = "NO_UPFRONT"


class RollbackOnDisable:
    """RollbackOnDisable enum values."""

    NO_ROLLBACK = "NO_ROLLBACK"
    DEFAULT_ROLLBACK = "DEFAULT_ROLLBACK"


class ScheduledAutoTuneActionType:
    """ScheduledAutoTuneActionType enum values."""

    JVM_HEAP_SIZE_TUNING = "JVM_HEAP_SIZE_TUNING"
    JVM_YOUNG_GEN_TUNING = "JVM_YOUNG_GEN_TUNING"


class ScheduledAutoTuneSeverityType:
    """ScheduledAutoTuneSeverityType enum values."""

    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"


class TLSSecurityPolicy:
    """TLSSecurityPolicy enum values."""

    POLICY_MIN_TLS_1_0_2019_07 = "Policy-Min-TLS-1-0-2019-07"
    POLICY_MIN_TLS_1_2_2019_07 = "Policy-Min-TLS-1-2-2019-07"
    POLICY_MIN_TLS_1_2_PFS_2023_10 = "Policy-Min-TLS-1-2-PFS-2023-10"


class TimeUnit:
    """TimeUnit enum values."""

    HOURS = "HOURS"


class UpgradeStatus:
    """UpgradeStatus enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    SUCCEEDED = "SUCCEEDED"
    SUCCEEDED_WITH_ISSUES = "SUCCEEDED_WITH_ISSUES"
    FAILED = "FAILED"


class UpgradeStep:
    """UpgradeStep enum values."""

    PRE_UPGRADE_CHECK = "PRE_UPGRADE_CHECK"
    SNAPSHOT = "SNAPSHOT"
    UPGRADE = "UPGRADE"


class VolumeType:
    """VolumeType enum values."""

    STANDARD = "standard"
    GP2 = "gp2"
    IO1 = "io1"
    GP3 = "gp3"


class VpcEndpointErrorCode:
    """VpcEndpointErrorCode enum values."""

    ENDPOINT_NOT_FOUND = "ENDPOINT_NOT_FOUND"
    SERVER_ERROR = "SERVER_ERROR"


class VpcEndpointStatus:
    """VpcEndpointStatus enum values."""

    CREATING = "CREATING"
    CREATE_FAILED = "CREATE_FAILED"
    ACTIVE = "ACTIVE"
    UPDATING = "UPDATING"
    UPDATE_FAILED = "UPDATE_FAILED"
    DELETING = "DELETING"
    DELETE_FAILED = "DELETE_FAILED"


# Convenient aliases for enum values
ENABLED = AutoTuneDesiredState.ENABLED
DISABLED = AutoTuneDesiredState.DISABLED
ENABLED = AutoTuneState.ENABLED
DISABLED = AutoTuneState.DISABLED
ENABLE_IN_PROGRESS = AutoTuneState.ENABLE_IN_PROGRESS
DISABLE_IN_PROGRESS = AutoTuneState.DISABLE_IN_PROGRESS
DISABLED_AND_ROLLBACK_SCHEDULED = AutoTuneState.DISABLED_AND_ROLLBACK_SCHEDULED
DISABLED_AND_ROLLBACK_IN_PROGRESS = AutoTuneState.DISABLED_AND_ROLLBACK_IN_PROGRESS
DISABLED_AND_ROLLBACK_COMPLETE = AutoTuneState.DISABLED_AND_ROLLBACK_COMPLETE
DISABLED_AND_ROLLBACK_ERROR = AutoTuneState.DISABLED_AND_ROLLBACK_ERROR
ERROR = AutoTuneState.ERROR
SCHEDULED_ACTION = AutoTuneType.SCHEDULED_ACTION
PENDING = ConfigChangeStatus.PENDING
INITIALIZING = ConfigChangeStatus.INITIALIZING
VALIDATING = ConfigChangeStatus.VALIDATING
VALIDATIONFAILED = ConfigChangeStatus.VALIDATIONFAILED
APPLYINGCHANGES = ConfigChangeStatus.APPLYINGCHANGES
COMPLETED = ConfigChangeStatus.COMPLETED
PENDINGUSERINPUT = ConfigChangeStatus.PENDINGUSERINPUT
CANCELLED = ConfigChangeStatus.CANCELLED
PENDING_UPDATE = DeploymentStatus.PENDING_UPDATE
IN_PROGRESS = DeploymentStatus.IN_PROGRESS
COMPLETED = DeploymentStatus.COMPLETED
NOT_ELIGIBLE = DeploymentStatus.NOT_ELIGIBLE
ELIGIBLE = DeploymentStatus.ELIGIBLE
PACKAGEID = DescribePackagesFilterName.PACKAGEID
PACKAGENAME = DescribePackagesFilterName.PACKAGENAME
PACKAGESTATUS = DescribePackagesFilterName.PACKAGESTATUS
ASSOCIATING = DomainPackageStatus.ASSOCIATING
ASSOCIATION_FAILED = DomainPackageStatus.ASSOCIATION_FAILED
ACTIVE = DomainPackageStatus.ACTIVE
DISSOCIATING = DomainPackageStatus.DISSOCIATING
DISSOCIATION_FAILED = DomainPackageStatus.DISSOCIATION_FAILED
CREATING = DomainProcessingStatusType.CREATING
ACTIVE = DomainProcessingStatusType.ACTIVE
MODIFYING = DomainProcessingStatusType.MODIFYING
UPGRADINGENGINEVERSION = DomainProcessingStatusType.UPGRADINGENGINEVERSION
UPDATINGSERVICESOFTWARE = DomainProcessingStatusType.UPDATINGSERVICESOFTWARE
ISOLATED = DomainProcessingStatusType.ISOLATED
DELETING = DomainProcessingStatusType.DELETING
M3_MEDIUM_ELASTICSEARCH = ESPartitionInstanceType.M3_MEDIUM_ELASTICSEARCH
M3_LARGE_ELASTICSEARCH = ESPartitionInstanceType.M3_LARGE_ELASTICSEARCH
M3_XLARGE_ELASTICSEARCH = ESPartitionInstanceType.M3_XLARGE_ELASTICSEARCH
M3_2XLARGE_ELASTICSEARCH = ESPartitionInstanceType.M3_2XLARGE_ELASTICSEARCH
M4_LARGE_ELASTICSEARCH = ESPartitionInstanceType.M4_LARGE_ELASTICSEARCH
M4_XLARGE_ELASTICSEARCH = ESPartitionInstanceType.M4_XLARGE_ELASTICSEARCH
M4_2XLARGE_ELASTICSEARCH = ESPartitionInstanceType.M4_2XLARGE_ELASTICSEARCH
M4_4XLARGE_ELASTICSEARCH = ESPartitionInstanceType.M4_4XLARGE_ELASTICSEARCH
M4_10XLARGE_ELASTICSEARCH = ESPartitionInstanceType.M4_10XLARGE_ELASTICSEARCH
M5_LARGE_ELASTICSEARCH = ESPartitionInstanceType.M5_LARGE_ELASTICSEARCH
M5_XLARGE_ELASTICSEARCH = ESPartitionInstanceType.M5_XLARGE_ELASTICSEARCH
M5_2XLARGE_ELASTICSEARCH = ESPartitionInstanceType.M5_2XLARGE_ELASTICSEARCH
M5_4XLARGE_ELASTICSEARCH = ESPartitionInstanceType.M5_4XLARGE_ELASTICSEARCH
M5_12XLARGE_ELASTICSEARCH = ESPartitionInstanceType.M5_12XLARGE_ELASTICSEARCH
R5_LARGE_ELASTICSEARCH = ESPartitionInstanceType.R5_LARGE_ELASTICSEARCH
R5_XLARGE_ELASTICSEARCH = ESPartitionInstanceType.R5_XLARGE_ELASTICSEARCH
R5_2XLARGE_ELASTICSEARCH = ESPartitionInstanceType.R5_2XLARGE_ELASTICSEARCH
R5_4XLARGE_ELASTICSEARCH = ESPartitionInstanceType.R5_4XLARGE_ELASTICSEARCH
R5_12XLARGE_ELASTICSEARCH = ESPartitionInstanceType.R5_12XLARGE_ELASTICSEARCH
C5_LARGE_ELASTICSEARCH = ESPartitionInstanceType.C5_LARGE_ELASTICSEARCH
C5_XLARGE_ELASTICSEARCH = ESPartitionInstanceType.C5_XLARGE_ELASTICSEARCH
C5_2XLARGE_ELASTICSEARCH = ESPartitionInstanceType.C5_2XLARGE_ELASTICSEARCH
C5_4XLARGE_ELASTICSEARCH = ESPartitionInstanceType.C5_4XLARGE_ELASTICSEARCH
C5_9XLARGE_ELASTICSEARCH = ESPartitionInstanceType.C5_9XLARGE_ELASTICSEARCH
C5_18XLARGE_ELASTICSEARCH = ESPartitionInstanceType.C5_18XLARGE_ELASTICSEARCH
ULTRAWARM1_MEDIUM_ELASTICSEARCH = ESPartitionInstanceType.ULTRAWARM1_MEDIUM_ELASTICSEARCH
ULTRAWARM1_LARGE_ELASTICSEARCH = ESPartitionInstanceType.ULTRAWARM1_LARGE_ELASTICSEARCH
T2_MICRO_ELASTICSEARCH = ESPartitionInstanceType.T2_MICRO_ELASTICSEARCH
T2_SMALL_ELASTICSEARCH = ESPartitionInstanceType.T2_SMALL_ELASTICSEARCH
T2_MEDIUM_ELASTICSEARCH = ESPartitionInstanceType.T2_MEDIUM_ELASTICSEARCH
R3_LARGE_ELASTICSEARCH = ESPartitionInstanceType.R3_LARGE_ELASTICSEARCH
R3_XLARGE_ELASTICSEARCH = ESPartitionInstanceType.R3_XLARGE_ELASTICSEARCH
R3_2XLARGE_ELASTICSEARCH = ESPartitionInstanceType.R3_2XLARGE_ELASTICSEARCH
R3_4XLARGE_ELASTICSEARCH = ESPartitionInstanceType.R3_4XLARGE_ELASTICSEARCH
R3_8XLARGE_ELASTICSEARCH = ESPartitionInstanceType.R3_8XLARGE_ELASTICSEARCH
I2_XLARGE_ELASTICSEARCH = ESPartitionInstanceType.I2_XLARGE_ELASTICSEARCH
I2_2XLARGE_ELASTICSEARCH = ESPartitionInstanceType.I2_2XLARGE_ELASTICSEARCH
D2_XLARGE_ELASTICSEARCH = ESPartitionInstanceType.D2_XLARGE_ELASTICSEARCH
D2_2XLARGE_ELASTICSEARCH = ESPartitionInstanceType.D2_2XLARGE_ELASTICSEARCH
D2_4XLARGE_ELASTICSEARCH = ESPartitionInstanceType.D2_4XLARGE_ELASTICSEARCH
D2_8XLARGE_ELASTICSEARCH = ESPartitionInstanceType.D2_8XLARGE_ELASTICSEARCH
C4_LARGE_ELASTICSEARCH = ESPartitionInstanceType.C4_LARGE_ELASTICSEARCH
C4_XLARGE_ELASTICSEARCH = ESPartitionInstanceType.C4_XLARGE_ELASTICSEARCH
C4_2XLARGE_ELASTICSEARCH = ESPartitionInstanceType.C4_2XLARGE_ELASTICSEARCH
C4_4XLARGE_ELASTICSEARCH = ESPartitionInstanceType.C4_4XLARGE_ELASTICSEARCH
C4_8XLARGE_ELASTICSEARCH = ESPartitionInstanceType.C4_8XLARGE_ELASTICSEARCH
R4_LARGE_ELASTICSEARCH = ESPartitionInstanceType.R4_LARGE_ELASTICSEARCH
R4_XLARGE_ELASTICSEARCH = ESPartitionInstanceType.R4_XLARGE_ELASTICSEARCH
R4_2XLARGE_ELASTICSEARCH = ESPartitionInstanceType.R4_2XLARGE_ELASTICSEARCH
R4_4XLARGE_ELASTICSEARCH = ESPartitionInstanceType.R4_4XLARGE_ELASTICSEARCH
R4_8XLARGE_ELASTICSEARCH = ESPartitionInstanceType.R4_8XLARGE_ELASTICSEARCH
R4_16XLARGE_ELASTICSEARCH = ESPartitionInstanceType.R4_16XLARGE_ELASTICSEARCH
I3_LARGE_ELASTICSEARCH = ESPartitionInstanceType.I3_LARGE_ELASTICSEARCH
I3_XLARGE_ELASTICSEARCH = ESPartitionInstanceType.I3_XLARGE_ELASTICSEARCH
I3_2XLARGE_ELASTICSEARCH = ESPartitionInstanceType.I3_2XLARGE_ELASTICSEARCH
I3_4XLARGE_ELASTICSEARCH = ESPartitionInstanceType.I3_4XLARGE_ELASTICSEARCH
I3_8XLARGE_ELASTICSEARCH = ESPartitionInstanceType.I3_8XLARGE_ELASTICSEARCH
I3_16XLARGE_ELASTICSEARCH = ESPartitionInstanceType.I3_16XLARGE_ELASTICSEARCH
ULTRAWARM1_MEDIUM_ELASTICSEARCH = ESWarmPartitionInstanceType.ULTRAWARM1_MEDIUM_ELASTICSEARCH
ULTRAWARM1_LARGE_ELASTICSEARCH = ESWarmPartitionInstanceType.ULTRAWARM1_LARGE_ELASTICSEARCH
OPENSEARCH = EngineType.OPENSEARCH
ELASTICSEARCH = EngineType.ELASTICSEARCH
PENDING_ACCEPTANCE = InboundCrossClusterSearchConnectionStatusCode.PENDING_ACCEPTANCE
APPROVED = InboundCrossClusterSearchConnectionStatusCode.APPROVED
REJECTING = InboundCrossClusterSearchConnectionStatusCode.REJECTING
REJECTED = InboundCrossClusterSearchConnectionStatusCode.REJECTED
DELETING = InboundCrossClusterSearchConnectionStatusCode.DELETING
DELETED = InboundCrossClusterSearchConnectionStatusCode.DELETED
CUSTOMER = InitiatedBy.CUSTOMER
SERVICE = InitiatedBy.SERVICE
INDEX_SLOW_LOGS = LogType.INDEX_SLOW_LOGS
SEARCH_SLOW_LOGS = LogType.SEARCH_SLOW_LOGS
ES_APPLICATION_LOGS = LogType.ES_APPLICATION_LOGS
AUDIT_LOGS = LogType.AUDIT_LOGS
REQUIRESINDEXDOCUMENTS = OptionState.REQUIRESINDEXDOCUMENTS
PROCESSING = OptionState.PROCESSING
ACTIVE = OptionState.ACTIVE
PENDING_ACCEPTANCE = OutboundCrossClusterSearchConnectionStatusCode.PENDING_ACCEPTANCE
VALIDATING = OutboundCrossClusterSearchConnectionStatusCode.VALIDATING
VALIDATION_FAILED = OutboundCrossClusterSearchConnectionStatusCode.VALIDATION_FAILED
PROVISIONING = OutboundCrossClusterSearchConnectionStatusCode.PROVISIONING
ACTIVE = OutboundCrossClusterSearchConnectionStatusCode.ACTIVE
REJECTED = OutboundCrossClusterSearchConnectionStatusCode.REJECTED
DELETING = OutboundCrossClusterSearchConnectionStatusCode.DELETING
DELETED = OutboundCrossClusterSearchConnectionStatusCode.DELETED
PENDING = OverallChangeStatus.PENDING
PROCESSING = OverallChangeStatus.PROCESSING
COMPLETED = OverallChangeStatus.COMPLETED
FAILED = OverallChangeStatus.FAILED
COPYING = PackageStatus.COPYING
COPY_FAILED = PackageStatus.COPY_FAILED
VALIDATING = PackageStatus.VALIDATING
VALIDATION_FAILED = PackageStatus.VALIDATION_FAILED
AVAILABLE = PackageStatus.AVAILABLE
DELETING = PackageStatus.DELETING
DELETED = PackageStatus.DELETED
DELETE_FAILED = PackageStatus.DELETE_FAILED
TXT_DICTIONARY = PackageType.TXT_DICTIONARY
AWS_ACCOUNT = PrincipalType.AWS_ACCOUNT
AWS_SERVICE = PrincipalType.AWS_SERVICE
PLAIN_TEXT = PropertyValueType.PLAIN_TEXT
STRINGIFIED_JSON = PropertyValueType.STRINGIFIED_JSON
ALL_UPFRONT = ReservedElasticsearchInstancePaymentOption.ALL_UPFRONT
PARTIAL_UPFRONT = ReservedElasticsearchInstancePaymentOption.PARTIAL_UPFRONT
NO_UPFRONT = ReservedElasticsearchInstancePaymentOption.NO_UPFRONT
NO_ROLLBACK = RollbackOnDisable.NO_ROLLBACK
DEFAULT_ROLLBACK = RollbackOnDisable.DEFAULT_ROLLBACK
JVM_HEAP_SIZE_TUNING = ScheduledAutoTuneActionType.JVM_HEAP_SIZE_TUNING
JVM_YOUNG_GEN_TUNING = ScheduledAutoTuneActionType.JVM_YOUNG_GEN_TUNING
LOW = ScheduledAutoTuneSeverityType.LOW
MEDIUM = ScheduledAutoTuneSeverityType.MEDIUM
HIGH = ScheduledAutoTuneSeverityType.HIGH
POLICY_MIN_TLS_1_0_2019_07 = TLSSecurityPolicy.POLICY_MIN_TLS_1_0_2019_07
POLICY_MIN_TLS_1_2_2019_07 = TLSSecurityPolicy.POLICY_MIN_TLS_1_2_2019_07
POLICY_MIN_TLS_1_2_PFS_2023_10 = TLSSecurityPolicy.POLICY_MIN_TLS_1_2_PFS_2023_10
HOURS = TimeUnit.HOURS
IN_PROGRESS = UpgradeStatus.IN_PROGRESS
SUCCEEDED = UpgradeStatus.SUCCEEDED
SUCCEEDED_WITH_ISSUES = UpgradeStatus.SUCCEEDED_WITH_ISSUES
FAILED = UpgradeStatus.FAILED
PRE_UPGRADE_CHECK = UpgradeStep.PRE_UPGRADE_CHECK
SNAPSHOT = UpgradeStep.SNAPSHOT
UPGRADE = UpgradeStep.UPGRADE
STANDARD = VolumeType.STANDARD
GP2 = VolumeType.GP2
IO1 = VolumeType.IO1
GP3 = VolumeType.GP3
ENDPOINT_NOT_FOUND = VpcEndpointErrorCode.ENDPOINT_NOT_FOUND
SERVER_ERROR = VpcEndpointErrorCode.SERVER_ERROR
CREATING = VpcEndpointStatus.CREATING
CREATE_FAILED = VpcEndpointStatus.CREATE_FAILED
ACTIVE = VpcEndpointStatus.ACTIVE
UPDATING = VpcEndpointStatus.UPDATING
UPDATE_FAILED = VpcEndpointStatus.UPDATE_FAILED
DELETING = VpcEndpointStatus.DELETING
DELETE_FAILED = VpcEndpointStatus.DELETE_FAILED


@dataclass
class AdvancedSecurityOptionsInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ela"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    anonymous_auth_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    internal_user_database_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    master_user_options: Optional[MasterUserOptions] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.anonymous_auth_enabled is not None:
            if hasattr(self.anonymous_auth_enabled, 'to_dict'):
                props['AnonymousAuthEnabled'] = self.anonymous_auth_enabled.to_dict()
            elif isinstance(self.anonymous_auth_enabled, list):
                props['AnonymousAuthEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.anonymous_auth_enabled
                ]
            else:
                props['AnonymousAuthEnabled'] = self.anonymous_auth_enabled

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        if self.internal_user_database_enabled is not None:
            if hasattr(self.internal_user_database_enabled, 'to_dict'):
                props['InternalUserDatabaseEnabled'] = self.internal_user_database_enabled.to_dict()
            elif isinstance(self.internal_user_database_enabled, list):
                props['InternalUserDatabaseEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internal_user_database_enabled
                ]
            else:
                props['InternalUserDatabaseEnabled'] = self.internal_user_database_enabled

        if self.master_user_options is not None:
            if hasattr(self.master_user_options, 'to_dict'):
                props['MasterUserOptions'] = self.master_user_options.to_dict()
            elif isinstance(self.master_user_options, list):
                props['MasterUserOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.master_user_options
                ]
            else:
                props['MasterUserOptions'] = self.master_user_options

        return props


@dataclass
class CognitoOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ela"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    identity_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_pool_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        if self.identity_pool_id is not None:
            if hasattr(self.identity_pool_id, 'to_dict'):
                props['IdentityPoolId'] = self.identity_pool_id.to_dict()
            elif isinstance(self.identity_pool_id, list):
                props['IdentityPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.identity_pool_id
                ]
            else:
                props['IdentityPoolId'] = self.identity_pool_id

        if self.role_arn is not None:
            if hasattr(self.role_arn, 'to_dict'):
                props['RoleArn'] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props['RoleArn'] = self.role_arn

        if self.user_pool_id is not None:
            if hasattr(self.user_pool_id, 'to_dict'):
                props['UserPoolId'] = self.user_pool_id.to_dict()
            elif isinstance(self.user_pool_id, list):
                props['UserPoolId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_pool_id
                ]
            else:
                props['UserPoolId'] = self.user_pool_id

        return props


@dataclass
class ColdStorageOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ela"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class DomainEndpointOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ela"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_endpoint: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_endpoint_certificate_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_endpoint_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enforce_https: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tls_security_policy: Optional[Union[str, TLSSecurityPolicy, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.custom_endpoint is not None:
            if hasattr(self.custom_endpoint, 'to_dict'):
                props['CustomEndpoint'] = self.custom_endpoint.to_dict()
            elif isinstance(self.custom_endpoint, list):
                props['CustomEndpoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_endpoint
                ]
            else:
                props['CustomEndpoint'] = self.custom_endpoint

        if self.custom_endpoint_certificate_arn is not None:
            if hasattr(self.custom_endpoint_certificate_arn, 'to_dict'):
                props['CustomEndpointCertificateArn'] = self.custom_endpoint_certificate_arn.to_dict()
            elif isinstance(self.custom_endpoint_certificate_arn, list):
                props['CustomEndpointCertificateArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_endpoint_certificate_arn
                ]
            else:
                props['CustomEndpointCertificateArn'] = self.custom_endpoint_certificate_arn

        if self.custom_endpoint_enabled is not None:
            if hasattr(self.custom_endpoint_enabled, 'to_dict'):
                props['CustomEndpointEnabled'] = self.custom_endpoint_enabled.to_dict()
            elif isinstance(self.custom_endpoint_enabled, list):
                props['CustomEndpointEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_endpoint_enabled
                ]
            else:
                props['CustomEndpointEnabled'] = self.custom_endpoint_enabled

        if self.enforce_https is not None:
            if hasattr(self.enforce_https, 'to_dict'):
                props['EnforceHTTPS'] = self.enforce_https.to_dict()
            elif isinstance(self.enforce_https, list):
                props['EnforceHTTPS'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enforce_https
                ]
            else:
                props['EnforceHTTPS'] = self.enforce_https

        if self.tls_security_policy is not None:
            if hasattr(self.tls_security_policy, 'to_dict'):
                props['TLSSecurityPolicy'] = self.tls_security_policy.to_dict()
            elif isinstance(self.tls_security_policy, list):
                props['TLSSecurityPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tls_security_policy
                ]
            else:
                props['TLSSecurityPolicy'] = self.tls_security_policy

        return props


@dataclass
class EBSOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ela"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_type: Optional[Union[str, VolumeType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ebs_enabled is not None:
            if hasattr(self.ebs_enabled, 'to_dict'):
                props['EBSEnabled'] = self.ebs_enabled.to_dict()
            elif isinstance(self.ebs_enabled, list):
                props['EBSEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_enabled
                ]
            else:
                props['EBSEnabled'] = self.ebs_enabled

        if self.iops is not None:
            if hasattr(self.iops, 'to_dict'):
                props['Iops'] = self.iops.to_dict()
            elif isinstance(self.iops, list):
                props['Iops'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iops
                ]
            else:
                props['Iops'] = self.iops

        if self.volume_size is not None:
            if hasattr(self.volume_size, 'to_dict'):
                props['VolumeSize'] = self.volume_size.to_dict()
            elif isinstance(self.volume_size, list):
                props['VolumeSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size
                ]
            else:
                props['VolumeSize'] = self.volume_size

        if self.volume_type is not None:
            if hasattr(self.volume_type, 'to_dict'):
                props['VolumeType'] = self.volume_type.to_dict()
            elif isinstance(self.volume_type, list):
                props['VolumeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_type
                ]
            else:
                props['VolumeType'] = self.volume_type

        return props


@dataclass
class ElasticsearchClusterConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ela"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cold_storage_options: Optional[ColdStorageOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dedicated_master_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dedicated_master_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dedicated_master_type: Optional[Union[str, ESPartitionInstanceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, ESPartitionInstanceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    warm_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    warm_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    warm_type: Optional[Union[str, ESWarmPartitionInstanceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    zone_awareness_config: Optional[ZoneAwarenessConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    zone_awareness_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cold_storage_options is not None:
            if hasattr(self.cold_storage_options, 'to_dict'):
                props['ColdStorageOptions'] = self.cold_storage_options.to_dict()
            elif isinstance(self.cold_storage_options, list):
                props['ColdStorageOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cold_storage_options
                ]
            else:
                props['ColdStorageOptions'] = self.cold_storage_options

        if self.dedicated_master_count is not None:
            if hasattr(self.dedicated_master_count, 'to_dict'):
                props['DedicatedMasterCount'] = self.dedicated_master_count.to_dict()
            elif isinstance(self.dedicated_master_count, list):
                props['DedicatedMasterCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dedicated_master_count
                ]
            else:
                props['DedicatedMasterCount'] = self.dedicated_master_count

        if self.dedicated_master_enabled is not None:
            if hasattr(self.dedicated_master_enabled, 'to_dict'):
                props['DedicatedMasterEnabled'] = self.dedicated_master_enabled.to_dict()
            elif isinstance(self.dedicated_master_enabled, list):
                props['DedicatedMasterEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dedicated_master_enabled
                ]
            else:
                props['DedicatedMasterEnabled'] = self.dedicated_master_enabled

        if self.dedicated_master_type is not None:
            if hasattr(self.dedicated_master_type, 'to_dict'):
                props['DedicatedMasterType'] = self.dedicated_master_type.to_dict()
            elif isinstance(self.dedicated_master_type, list):
                props['DedicatedMasterType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dedicated_master_type
                ]
            else:
                props['DedicatedMasterType'] = self.dedicated_master_type

        if self.instance_count is not None:
            if hasattr(self.instance_count, 'to_dict'):
                props['InstanceCount'] = self.instance_count.to_dict()
            elif isinstance(self.instance_count, list):
                props['InstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_count
                ]
            else:
                props['InstanceCount'] = self.instance_count

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        if self.warm_count is not None:
            if hasattr(self.warm_count, 'to_dict'):
                props['WarmCount'] = self.warm_count.to_dict()
            elif isinstance(self.warm_count, list):
                props['WarmCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.warm_count
                ]
            else:
                props['WarmCount'] = self.warm_count

        if self.warm_enabled is not None:
            if hasattr(self.warm_enabled, 'to_dict'):
                props['WarmEnabled'] = self.warm_enabled.to_dict()
            elif isinstance(self.warm_enabled, list):
                props['WarmEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.warm_enabled
                ]
            else:
                props['WarmEnabled'] = self.warm_enabled

        if self.warm_type is not None:
            if hasattr(self.warm_type, 'to_dict'):
                props['WarmType'] = self.warm_type.to_dict()
            elif isinstance(self.warm_type, list):
                props['WarmType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.warm_type
                ]
            else:
                props['WarmType'] = self.warm_type

        if self.zone_awareness_config is not None:
            if hasattr(self.zone_awareness_config, 'to_dict'):
                props['ZoneAwarenessConfig'] = self.zone_awareness_config.to_dict()
            elif isinstance(self.zone_awareness_config, list):
                props['ZoneAwarenessConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.zone_awareness_config
                ]
            else:
                props['ZoneAwarenessConfig'] = self.zone_awareness_config

        if self.zone_awareness_enabled is not None:
            if hasattr(self.zone_awareness_enabled, 'to_dict'):
                props['ZoneAwarenessEnabled'] = self.zone_awareness_enabled.to_dict()
            elif isinstance(self.zone_awareness_enabled, list):
                props['ZoneAwarenessEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.zone_awareness_enabled
                ]
            else:
                props['ZoneAwarenessEnabled'] = self.zone_awareness_enabled

        return props


@dataclass
class EncryptionAtRestOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ela"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        return props


@dataclass
class LogPublishingOption:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ela"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_logs_log_group_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cloud_watch_logs_log_group_arn is not None:
            if hasattr(self.cloud_watch_logs_log_group_arn, 'to_dict'):
                props['CloudWatchLogsLogGroupArn'] = self.cloud_watch_logs_log_group_arn.to_dict()
            elif isinstance(self.cloud_watch_logs_log_group_arn, list):
                props['CloudWatchLogsLogGroupArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cloud_watch_logs_log_group_arn
                ]
            else:
                props['CloudWatchLogsLogGroupArn'] = self.cloud_watch_logs_log_group_arn

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class MasterUserOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ela"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    master_user_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    master_user_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    master_user_password: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.master_user_arn is not None:
            if hasattr(self.master_user_arn, 'to_dict'):
                props['MasterUserARN'] = self.master_user_arn.to_dict()
            elif isinstance(self.master_user_arn, list):
                props['MasterUserARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.master_user_arn
                ]
            else:
                props['MasterUserARN'] = self.master_user_arn

        if self.master_user_name is not None:
            if hasattr(self.master_user_name, 'to_dict'):
                props['MasterUserName'] = self.master_user_name.to_dict()
            elif isinstance(self.master_user_name, list):
                props['MasterUserName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.master_user_name
                ]
            else:
                props['MasterUserName'] = self.master_user_name

        if self.master_user_password is not None:
            if hasattr(self.master_user_password, 'to_dict'):
                props['MasterUserPassword'] = self.master_user_password.to_dict()
            elif isinstance(self.master_user_password, list):
                props['MasterUserPassword'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.master_user_password
                ]
            else:
                props['MasterUserPassword'] = self.master_user_password

        return props


@dataclass
class NodeToNodeEncryptionOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ela"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enabled is not None:
            if hasattr(self.enabled, 'to_dict'):
                props['Enabled'] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props['Enabled'] = self.enabled

        return props


@dataclass
class SnapshotOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ela"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    automated_snapshot_start_hour: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.automated_snapshot_start_hour is not None:
            if hasattr(self.automated_snapshot_start_hour, 'to_dict'):
                props['AutomatedSnapshotStartHour'] = self.automated_snapshot_start_hour.to_dict()
            elif isinstance(self.automated_snapshot_start_hour, list):
                props['AutomatedSnapshotStartHour'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.automated_snapshot_start_hour
                ]
            else:
                props['AutomatedSnapshotStartHour'] = self.automated_snapshot_start_hour

        return props


@dataclass
class VPCOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ela"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnet_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        if self.subnet_ids is not None:
            if hasattr(self.subnet_ids, 'to_dict'):
                props['SubnetIds'] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props['SubnetIds'] = self.subnet_ids

        return props


@dataclass
class ZoneAwarenessConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ela"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    availability_zone_count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.availability_zone_count is not None:
            if hasattr(self.availability_zone_count, 'to_dict'):
                props['AvailabilityZoneCount'] = self.availability_zone_count.to_dict()
            elif isinstance(self.availability_zone_count, list):
                props['AvailabilityZoneCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.availability_zone_count
                ]
            else:
                props['AvailabilityZoneCount'] = self.availability_zone_count

        return props


@dataclass
class Domain(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elast"""

    resource_type: ClassVar[str] = "AWS::Elasticsearch::Domain"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    access_policies: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    advanced_options: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    advanced_security_options: Optional[AdvancedSecurityOptionsInput] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cognito_options: Optional[CognitoOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_endpoint_options: Optional[DomainEndpointOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ebs_options: Optional[EBSOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    elasticsearch_cluster_config: Optional[ElasticsearchClusterConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    elasticsearch_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    encryption_at_rest_options: Optional[EncryptionAtRestOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    log_publishing_options: Optional[dict[str, Any]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    node_to_node_encryption_options: Optional[NodeToNodeEncryptionOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    snapshot_options: Optional[SnapshotOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_options: Optional[VPCOptions] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.access_policies is not None:
            # Serialize access_policies (handle intrinsic functions)
            if hasattr(self.access_policies, 'to_dict'):
                props["AccessPolicies"] = self.access_policies.to_dict()
            elif isinstance(self.access_policies, list):
                # Serialize list items (may contain intrinsic functions)
                props['AccessPolicies'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.access_policies
                ]
            else:
                props["AccessPolicies"] = self.access_policies

        if self.advanced_options is not None:
            # Serialize advanced_options (handle intrinsic functions)
            if hasattr(self.advanced_options, 'to_dict'):
                props["AdvancedOptions"] = self.advanced_options.to_dict()
            elif isinstance(self.advanced_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['AdvancedOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.advanced_options
                ]
            else:
                props["AdvancedOptions"] = self.advanced_options

        if self.advanced_security_options is not None:
            # Serialize advanced_security_options (handle intrinsic functions)
            if hasattr(self.advanced_security_options, 'to_dict'):
                props["AdvancedSecurityOptions"] = self.advanced_security_options.to_dict()
            elif isinstance(self.advanced_security_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['AdvancedSecurityOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.advanced_security_options
                ]
            else:
                props["AdvancedSecurityOptions"] = self.advanced_security_options

        if self.cognito_options is not None:
            # Serialize cognito_options (handle intrinsic functions)
            if hasattr(self.cognito_options, 'to_dict'):
                props["CognitoOptions"] = self.cognito_options.to_dict()
            elif isinstance(self.cognito_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['CognitoOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cognito_options
                ]
            else:
                props["CognitoOptions"] = self.cognito_options

        if self.domain_endpoint_options is not None:
            # Serialize domain_endpoint_options (handle intrinsic functions)
            if hasattr(self.domain_endpoint_options, 'to_dict'):
                props["DomainEndpointOptions"] = self.domain_endpoint_options.to_dict()
            elif isinstance(self.domain_endpoint_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainEndpointOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_endpoint_options
                ]
            else:
                props["DomainEndpointOptions"] = self.domain_endpoint_options

        if self.domain_name is not None:
            # Serialize domain_name (handle intrinsic functions)
            if hasattr(self.domain_name, 'to_dict'):
                props["DomainName"] = self.domain_name.to_dict()
            elif isinstance(self.domain_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_name
                ]
            else:
                props["DomainName"] = self.domain_name

        if self.ebs_options is not None:
            # Serialize ebs_options (handle intrinsic functions)
            if hasattr(self.ebs_options, 'to_dict'):
                props["EBSOptions"] = self.ebs_options.to_dict()
            elif isinstance(self.ebs_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['EBSOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_options
                ]
            else:
                props["EBSOptions"] = self.ebs_options

        if self.elasticsearch_cluster_config is not None:
            # Serialize elasticsearch_cluster_config (handle intrinsic functions)
            if hasattr(self.elasticsearch_cluster_config, 'to_dict'):
                props["ElasticsearchClusterConfig"] = self.elasticsearch_cluster_config.to_dict()
            elif isinstance(self.elasticsearch_cluster_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ElasticsearchClusterConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.elasticsearch_cluster_config
                ]
            else:
                props["ElasticsearchClusterConfig"] = self.elasticsearch_cluster_config

        if self.elasticsearch_version is not None:
            # Serialize elasticsearch_version (handle intrinsic functions)
            if hasattr(self.elasticsearch_version, 'to_dict'):
                props["ElasticsearchVersion"] = self.elasticsearch_version.to_dict()
            elif isinstance(self.elasticsearch_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['ElasticsearchVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.elasticsearch_version
                ]
            else:
                props["ElasticsearchVersion"] = self.elasticsearch_version

        if self.encryption_at_rest_options is not None:
            # Serialize encryption_at_rest_options (handle intrinsic functions)
            if hasattr(self.encryption_at_rest_options, 'to_dict'):
                props["EncryptionAtRestOptions"] = self.encryption_at_rest_options.to_dict()
            elif isinstance(self.encryption_at_rest_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['EncryptionAtRestOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encryption_at_rest_options
                ]
            else:
                props["EncryptionAtRestOptions"] = self.encryption_at_rest_options

        if self.log_publishing_options is not None:
            # Serialize log_publishing_options (handle intrinsic functions)
            if hasattr(self.log_publishing_options, 'to_dict'):
                props["LogPublishingOptions"] = self.log_publishing_options.to_dict()
            elif isinstance(self.log_publishing_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['LogPublishingOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.log_publishing_options
                ]
            else:
                props["LogPublishingOptions"] = self.log_publishing_options

        if self.node_to_node_encryption_options is not None:
            # Serialize node_to_node_encryption_options (handle intrinsic functions)
            if hasattr(self.node_to_node_encryption_options, 'to_dict'):
                props["NodeToNodeEncryptionOptions"] = self.node_to_node_encryption_options.to_dict()
            elif isinstance(self.node_to_node_encryption_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['NodeToNodeEncryptionOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.node_to_node_encryption_options
                ]
            else:
                props["NodeToNodeEncryptionOptions"] = self.node_to_node_encryption_options

        if self.snapshot_options is not None:
            # Serialize snapshot_options (handle intrinsic functions)
            if hasattr(self.snapshot_options, 'to_dict'):
                props["SnapshotOptions"] = self.snapshot_options.to_dict()
            elif isinstance(self.snapshot_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['SnapshotOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.snapshot_options
                ]
            else:
                props["SnapshotOptions"] = self.snapshot_options

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.vpc_options is not None:
            # Serialize vpc_options (handle intrinsic functions)
            if hasattr(self.vpc_options, 'to_dict'):
                props["VPCOptions"] = self.vpc_options.to_dict()
            elif isinstance(self.vpc_options, list):
                # Serialize list items (may contain intrinsic functions)
                props['VPCOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_options
                ]
            else:
                props["VPCOptions"] = self.vpc_options

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_domain_arn(self) -> GetAtt:
        """Get the DomainArn attribute."""
        return self.get_att("DomainArn")

    @property
    def attr_domain_endpoint(self) -> GetAtt:
        """Get the DomainEndpoint attribute."""
        return self.get_att("DomainEndpoint")



