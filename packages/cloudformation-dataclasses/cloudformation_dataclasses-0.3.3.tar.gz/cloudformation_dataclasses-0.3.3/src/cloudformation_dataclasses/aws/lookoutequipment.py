"""
AWS CloudFormation LookoutEquipment Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:37

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service LookoutEquipment
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AutoPromotionResult:
    """AutoPromotionResult enum values."""

    MODEL_PROMOTED = "MODEL_PROMOTED"
    MODEL_NOT_PROMOTED = "MODEL_NOT_PROMOTED"
    RETRAINING_INTERNAL_ERROR = "RETRAINING_INTERNAL_ERROR"
    RETRAINING_CUSTOMER_ERROR = "RETRAINING_CUSTOMER_ERROR"
    RETRAINING_CANCELLED = "RETRAINING_CANCELLED"


class DataUploadFrequency:
    """DataUploadFrequency enum values."""

    PT5M = "PT5M"
    PT10M = "PT10M"
    PT15M = "PT15M"
    PT30M = "PT30M"
    PT1H = "PT1H"


class DatasetStatus:
    """DatasetStatus enum values."""

    CREATED = "CREATED"
    INGESTION_IN_PROGRESS = "INGESTION_IN_PROGRESS"
    ACTIVE = "ACTIVE"
    IMPORT_IN_PROGRESS = "IMPORT_IN_PROGRESS"


class InferenceDataImportStrategy:
    """InferenceDataImportStrategy enum values."""

    NO_IMPORT = "NO_IMPORT"
    ADD_WHEN_EMPTY = "ADD_WHEN_EMPTY"
    OVERWRITE = "OVERWRITE"


class InferenceExecutionStatus:
    """InferenceExecutionStatus enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    SUCCESS = "SUCCESS"
    FAILED = "FAILED"


class InferenceSchedulerStatus:
    """InferenceSchedulerStatus enum values."""

    PENDING = "PENDING"
    RUNNING = "RUNNING"
    STOPPING = "STOPPING"
    STOPPED = "STOPPED"


class IngestionJobStatus:
    """IngestionJobStatus enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    SUCCESS = "SUCCESS"
    FAILED = "FAILED"
    IMPORT_IN_PROGRESS = "IMPORT_IN_PROGRESS"


class LabelRating:
    """LabelRating enum values."""

    ANOMALY = "ANOMALY"
    NO_ANOMALY = "NO_ANOMALY"
    NEUTRAL = "NEUTRAL"


class LatestInferenceResult:
    """LatestInferenceResult enum values."""

    ANOMALOUS = "ANOMALOUS"
    NORMAL = "NORMAL"


class ModelPromoteMode:
    """ModelPromoteMode enum values."""

    MANAGED = "MANAGED"
    MANUAL = "MANUAL"


class ModelQuality:
    """ModelQuality enum values."""

    QUALITY_THRESHOLD_MET = "QUALITY_THRESHOLD_MET"
    CANNOT_DETERMINE_QUALITY = "CANNOT_DETERMINE_QUALITY"
    POOR_QUALITY_DETECTED = "POOR_QUALITY_DETECTED"


class ModelStatus:
    """ModelStatus enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    SUCCESS = "SUCCESS"
    FAILED = "FAILED"
    IMPORT_IN_PROGRESS = "IMPORT_IN_PROGRESS"


class ModelVersionSourceType:
    """ModelVersionSourceType enum values."""

    TRAINING = "TRAINING"
    RETRAINING = "RETRAINING"
    IMPORT = "IMPORT"


class ModelVersionStatus:
    """ModelVersionStatus enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    SUCCESS = "SUCCESS"
    FAILED = "FAILED"
    IMPORT_IN_PROGRESS = "IMPORT_IN_PROGRESS"
    CANCELED = "CANCELED"


class Monotonicity:
    """Monotonicity enum values."""

    DECREASING = "DECREASING"
    INCREASING = "INCREASING"
    STATIC = "STATIC"


class RetrainingSchedulerStatus:
    """RetrainingSchedulerStatus enum values."""

    PENDING = "PENDING"
    RUNNING = "RUNNING"
    STOPPING = "STOPPING"
    STOPPED = "STOPPED"


class StatisticalIssueStatus:
    """StatisticalIssueStatus enum values."""

    POTENTIAL_ISSUE_DETECTED = "POTENTIAL_ISSUE_DETECTED"
    NO_ISSUE_DETECTED = "NO_ISSUE_DETECTED"


class TargetSamplingRate:
    """TargetSamplingRate enum values."""

    PT1S = "PT1S"
    PT5S = "PT5S"
    PT10S = "PT10S"
    PT15S = "PT15S"
    PT30S = "PT30S"
    PT1M = "PT1M"
    PT5M = "PT5M"
    PT10M = "PT10M"
    PT15M = "PT15M"
    PT30M = "PT30M"
    PT1H = "PT1H"


# Convenient aliases for enum values
MODEL_PROMOTED = AutoPromotionResult.MODEL_PROMOTED
MODEL_NOT_PROMOTED = AutoPromotionResult.MODEL_NOT_PROMOTED
RETRAINING_INTERNAL_ERROR = AutoPromotionResult.RETRAINING_INTERNAL_ERROR
RETRAINING_CUSTOMER_ERROR = AutoPromotionResult.RETRAINING_CUSTOMER_ERROR
RETRAINING_CANCELLED = AutoPromotionResult.RETRAINING_CANCELLED
PT5M = DataUploadFrequency.PT5M
PT10M = DataUploadFrequency.PT10M
PT15M = DataUploadFrequency.PT15M
PT30M = DataUploadFrequency.PT30M
PT1H = DataUploadFrequency.PT1H
CREATED = DatasetStatus.CREATED
INGESTION_IN_PROGRESS = DatasetStatus.INGESTION_IN_PROGRESS
ACTIVE = DatasetStatus.ACTIVE
IMPORT_IN_PROGRESS = DatasetStatus.IMPORT_IN_PROGRESS
NO_IMPORT = InferenceDataImportStrategy.NO_IMPORT
ADD_WHEN_EMPTY = InferenceDataImportStrategy.ADD_WHEN_EMPTY
OVERWRITE = InferenceDataImportStrategy.OVERWRITE
IN_PROGRESS = InferenceExecutionStatus.IN_PROGRESS
SUCCESS = InferenceExecutionStatus.SUCCESS
FAILED = InferenceExecutionStatus.FAILED
PENDING = InferenceSchedulerStatus.PENDING
RUNNING = InferenceSchedulerStatus.RUNNING
STOPPING = InferenceSchedulerStatus.STOPPING
STOPPED = InferenceSchedulerStatus.STOPPED
IN_PROGRESS = IngestionJobStatus.IN_PROGRESS
SUCCESS = IngestionJobStatus.SUCCESS
FAILED = IngestionJobStatus.FAILED
IMPORT_IN_PROGRESS = IngestionJobStatus.IMPORT_IN_PROGRESS
ANOMALY = LabelRating.ANOMALY
NO_ANOMALY = LabelRating.NO_ANOMALY
NEUTRAL = LabelRating.NEUTRAL
ANOMALOUS = LatestInferenceResult.ANOMALOUS
NORMAL = LatestInferenceResult.NORMAL
MANAGED = ModelPromoteMode.MANAGED
MANUAL = ModelPromoteMode.MANUAL
QUALITY_THRESHOLD_MET = ModelQuality.QUALITY_THRESHOLD_MET
CANNOT_DETERMINE_QUALITY = ModelQuality.CANNOT_DETERMINE_QUALITY
POOR_QUALITY_DETECTED = ModelQuality.POOR_QUALITY_DETECTED
IN_PROGRESS = ModelStatus.IN_PROGRESS
SUCCESS = ModelStatus.SUCCESS
FAILED = ModelStatus.FAILED
IMPORT_IN_PROGRESS = ModelStatus.IMPORT_IN_PROGRESS
TRAINING = ModelVersionSourceType.TRAINING
RETRAINING = ModelVersionSourceType.RETRAINING
IMPORT = ModelVersionSourceType.IMPORT
IN_PROGRESS = ModelVersionStatus.IN_PROGRESS
SUCCESS = ModelVersionStatus.SUCCESS
FAILED = ModelVersionStatus.FAILED
IMPORT_IN_PROGRESS = ModelVersionStatus.IMPORT_IN_PROGRESS
CANCELED = ModelVersionStatus.CANCELED
DECREASING = Monotonicity.DECREASING
INCREASING = Monotonicity.INCREASING
STATIC = Monotonicity.STATIC
PENDING = RetrainingSchedulerStatus.PENDING
RUNNING = RetrainingSchedulerStatus.RUNNING
STOPPING = RetrainingSchedulerStatus.STOPPING
STOPPED = RetrainingSchedulerStatus.STOPPED
POTENTIAL_ISSUE_DETECTED = StatisticalIssueStatus.POTENTIAL_ISSUE_DETECTED
NO_ISSUE_DETECTED = StatisticalIssueStatus.NO_ISSUE_DETECTED
PT1S = TargetSamplingRate.PT1S
PT5S = TargetSamplingRate.PT5S
PT10S = TargetSamplingRate.PT10S
PT15S = TargetSamplingRate.PT15S
PT30S = TargetSamplingRate.PT30S
PT1M = TargetSamplingRate.PT1M
PT5M = TargetSamplingRate.PT5M
PT10M = TargetSamplingRate.PT10M
PT15M = TargetSamplingRate.PT15M
PT30M = TargetSamplingRate.PT30M
PT1H = TargetSamplingRate.PT1H


@dataclass
class DataInputConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-loo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inference_input_name_configuration: Optional[InputNameConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_input_configuration: Optional[S3InputConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    input_time_zone_offset: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.inference_input_name_configuration is not None:
            if hasattr(self.inference_input_name_configuration, 'to_dict'):
                props['InferenceInputNameConfiguration'] = self.inference_input_name_configuration.to_dict()
            elif isinstance(self.inference_input_name_configuration, list):
                props['InferenceInputNameConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inference_input_name_configuration
                ]
            else:
                props['InferenceInputNameConfiguration'] = self.inference_input_name_configuration

        if self.s3_input_configuration is not None:
            if hasattr(self.s3_input_configuration, 'to_dict'):
                props['S3InputConfiguration'] = self.s3_input_configuration.to_dict()
            elif isinstance(self.s3_input_configuration, list):
                props['S3InputConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_input_configuration
                ]
            else:
                props['S3InputConfiguration'] = self.s3_input_configuration

        if self.input_time_zone_offset is not None:
            if hasattr(self.input_time_zone_offset, 'to_dict'):
                props['InputTimeZoneOffset'] = self.input_time_zone_offset.to_dict()
            elif isinstance(self.input_time_zone_offset, list):
                props['InputTimeZoneOffset'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.input_time_zone_offset
                ]
            else:
                props['InputTimeZoneOffset'] = self.input_time_zone_offset

        return props


@dataclass
class DataOutputConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-loo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_output_configuration: Optional[S3OutputConfiguration] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.s3_output_configuration is not None:
            if hasattr(self.s3_output_configuration, 'to_dict'):
                props['S3OutputConfiguration'] = self.s3_output_configuration.to_dict()
            elif isinstance(self.s3_output_configuration, list):
                props['S3OutputConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_output_configuration
                ]
            else:
                props['S3OutputConfiguration'] = self.s3_output_configuration

        return props


@dataclass
class InputNameConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-loo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    component_timestamp_delimiter: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    timestamp_format: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.component_timestamp_delimiter is not None:
            if hasattr(self.component_timestamp_delimiter, 'to_dict'):
                props['ComponentTimestampDelimiter'] = self.component_timestamp_delimiter.to_dict()
            elif isinstance(self.component_timestamp_delimiter, list):
                props['ComponentTimestampDelimiter'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.component_timestamp_delimiter
                ]
            else:
                props['ComponentTimestampDelimiter'] = self.component_timestamp_delimiter

        if self.timestamp_format is not None:
            if hasattr(self.timestamp_format, 'to_dict'):
                props['TimestampFormat'] = self.timestamp_format.to_dict()
            elif isinstance(self.timestamp_format, list):
                props['TimestampFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.timestamp_format
                ]
            else:
                props['TimestampFormat'] = self.timestamp_format

        return props


@dataclass
class S3InputConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-loo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.bucket is not None:
            if hasattr(self.bucket, 'to_dict'):
                props['Bucket'] = self.bucket.to_dict()
            elif isinstance(self.bucket, list):
                props['Bucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket
                ]
            else:
                props['Bucket'] = self.bucket

        if self.prefix is not None:
            if hasattr(self.prefix, 'to_dict'):
                props['Prefix'] = self.prefix.to_dict()
            elif isinstance(self.prefix, list):
                props['Prefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.prefix
                ]
            else:
                props['Prefix'] = self.prefix

        return props


@dataclass
class S3OutputConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-loo"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.bucket is not None:
            if hasattr(self.bucket, 'to_dict'):
                props['Bucket'] = self.bucket.to_dict()
            elif isinstance(self.bucket, list):
                props['Bucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket
                ]
            else:
                props['Bucket'] = self.bucket

        if self.prefix is not None:
            if hasattr(self.prefix, 'to_dict'):
                props['Prefix'] = self.prefix.to_dict()
            elif isinstance(self.prefix, list):
                props['Prefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.prefix
                ]
            else:
                props['Prefix'] = self.prefix

        return props


@dataclass
class InferenceScheduler(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-looko"""

    resource_type: ClassVar[str] = "AWS::LookoutEquipment::InferenceScheduler"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    inference_scheduler_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_upload_frequency: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_input_configuration: Optional[DataInputConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_output_configuration: Optional[DataOutputConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    server_side_kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_delay_offset_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.inference_scheduler_name is not None:
            # Serialize inference_scheduler_name (handle intrinsic functions)
            if hasattr(self.inference_scheduler_name, 'to_dict'):
                props["InferenceSchedulerName"] = self.inference_scheduler_name.to_dict()
            elif isinstance(self.inference_scheduler_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['InferenceSchedulerName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inference_scheduler_name
                ]
            else:
                props["InferenceSchedulerName"] = self.inference_scheduler_name

        if self.data_upload_frequency is not None:
            # Serialize data_upload_frequency (handle intrinsic functions)
            if hasattr(self.data_upload_frequency, 'to_dict'):
                props["DataUploadFrequency"] = self.data_upload_frequency.to_dict()
            elif isinstance(self.data_upload_frequency, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataUploadFrequency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_upload_frequency
                ]
            else:
                props["DataUploadFrequency"] = self.data_upload_frequency

        if self.model_name is not None:
            # Serialize model_name (handle intrinsic functions)
            if hasattr(self.model_name, 'to_dict'):
                props["ModelName"] = self.model_name.to_dict()
            elif isinstance(self.model_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_name
                ]
            else:
                props["ModelName"] = self.model_name

        if self.data_input_configuration is not None:
            # Serialize data_input_configuration (handle intrinsic functions)
            if hasattr(self.data_input_configuration, 'to_dict'):
                props["DataInputConfiguration"] = self.data_input_configuration.to_dict()
            elif isinstance(self.data_input_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataInputConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_input_configuration
                ]
            else:
                props["DataInputConfiguration"] = self.data_input_configuration

        if self.data_output_configuration is not None:
            # Serialize data_output_configuration (handle intrinsic functions)
            if hasattr(self.data_output_configuration, 'to_dict'):
                props["DataOutputConfiguration"] = self.data_output_configuration.to_dict()
            elif isinstance(self.data_output_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataOutputConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_output_configuration
                ]
            else:
                props["DataOutputConfiguration"] = self.data_output_configuration

        if self.server_side_kms_key_id is not None:
            # Serialize server_side_kms_key_id (handle intrinsic functions)
            if hasattr(self.server_side_kms_key_id, 'to_dict'):
                props["ServerSideKmsKeyId"] = self.server_side_kms_key_id.to_dict()
            elif isinstance(self.server_side_kms_key_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServerSideKmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.server_side_kms_key_id
                ]
            else:
                props["ServerSideKmsKeyId"] = self.server_side_kms_key_id

        if self.data_delay_offset_in_minutes is not None:
            # Serialize data_delay_offset_in_minutes (handle intrinsic functions)
            if hasattr(self.data_delay_offset_in_minutes, 'to_dict'):
                props["DataDelayOffsetInMinutes"] = self.data_delay_offset_in_minutes.to_dict()
            elif isinstance(self.data_delay_offset_in_minutes, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataDelayOffsetInMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_delay_offset_in_minutes
                ]
            else:
                props["DataDelayOffsetInMinutes"] = self.data_delay_offset_in_minutes

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_inference_scheduler_arn(self) -> GetAtt:
        """Get the InferenceSchedulerArn attribute."""
        return self.get_att("InferenceSchedulerArn")



