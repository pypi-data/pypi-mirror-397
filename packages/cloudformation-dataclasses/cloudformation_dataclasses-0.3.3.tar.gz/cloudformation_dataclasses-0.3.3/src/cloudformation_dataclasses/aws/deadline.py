"""
AWS CloudFormation Deadline Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:36

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service Deadline
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AcceleratorName:
    """AcceleratorName enum values."""

    T4 = "t4"
    A10G = "a10g"
    L4 = "l4"
    L40S = "l40s"


class AcceleratorType:
    """AcceleratorType enum values."""

    GPU = "gpu"


class AutoScalingMode:
    """AutoScalingMode enum values."""

    NO_SCALING = "NO_SCALING"
    EVENT_BASED_AUTO_SCALING = "EVENT_BASED_AUTO_SCALING"


class AutoScalingStatus:
    """AutoScalingStatus enum values."""

    GROWING = "GROWING"
    STEADY = "STEADY"
    SHRINKING = "SHRINKING"


class BudgetActionType:
    """BudgetActionType enum values."""

    STOP_SCHEDULING_AND_COMPLETE_TASKS = "STOP_SCHEDULING_AND_COMPLETE_TASKS"
    STOP_SCHEDULING_AND_CANCEL_TASKS = "STOP_SCHEDULING_AND_CANCEL_TASKS"


class BudgetStatus:
    """BudgetStatus enum values."""

    ACTIVE = "ACTIVE"
    INACTIVE = "INACTIVE"


class ComparisonOperator:
    """ComparisonOperator enum values."""

    EQUAL = "EQUAL"
    NOT_EQUAL = "NOT_EQUAL"
    GREATER_THAN_EQUAL_TO = "GREATER_THAN_EQUAL_TO"
    GREATER_THAN = "GREATER_THAN"
    LESS_THAN_EQUAL_TO = "LESS_THAN_EQUAL_TO"
    LESS_THAN = "LESS_THAN"


class CompletedStatus:
    """CompletedStatus enum values."""

    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    INTERRUPTED = "INTERRUPTED"
    CANCELED = "CANCELED"
    NEVER_ATTEMPTED = "NEVER_ATTEMPTED"


class ConflictExceptionReason:
    """ConflictExceptionReason enum values."""

    CONFLICT_EXCEPTION = "CONFLICT_EXCEPTION"
    CONCURRENT_MODIFICATION = "CONCURRENT_MODIFICATION"
    RESOURCE_ALREADY_EXISTS = "RESOURCE_ALREADY_EXISTS"
    RESOURCE_IN_USE = "RESOURCE_IN_USE"
    STATUS_CONFLICT = "STATUS_CONFLICT"


class CpuArchitectureType:
    """CpuArchitectureType enum values."""

    X86_64 = "x86_64"
    ARM64 = "arm64"


class CreateJobTargetTaskRunStatus:
    """CreateJobTargetTaskRunStatus enum values."""

    READY = "READY"
    SUSPENDED = "SUSPENDED"


class CustomerManagedFleetOperatingSystemFamily:
    """CustomerManagedFleetOperatingSystemFamily enum values."""

    WINDOWS = "WINDOWS"
    LINUX = "LINUX"
    MACOS = "MACOS"


class DefaultQueueBudgetAction:
    """DefaultQueueBudgetAction enum values."""

    NONE = "NONE"
    STOP_SCHEDULING_AND_COMPLETE_TASKS = "STOP_SCHEDULING_AND_COMPLETE_TASKS"
    STOP_SCHEDULING_AND_CANCEL_TASKS = "STOP_SCHEDULING_AND_CANCEL_TASKS"


class DependencyConsumerResolutionStatus:
    """DependencyConsumerResolutionStatus enum values."""

    RESOLVED = "RESOLVED"
    UNRESOLVED = "UNRESOLVED"


class DesiredWorkerStatus:
    """DesiredWorkerStatus enum values."""

    STOPPED = "STOPPED"


class Ec2MarketType:
    """Ec2MarketType enum values."""

    ON_DEMAND = "on-demand"
    SPOT = "spot"
    WAIT_AND_SAVE = "wait-and-save"


class EnvironmentTemplateType:
    """EnvironmentTemplateType enum values."""

    JSON = "JSON"
    YAML = "YAML"


class FileSystemLocationType:
    """FileSystemLocationType enum values."""

    SHARED = "SHARED"
    LOCAL = "LOCAL"


class FleetStatus:
    """FleetStatus enum values."""

    ACTIVE = "ACTIVE"
    CREATE_IN_PROGRESS = "CREATE_IN_PROGRESS"
    UPDATE_IN_PROGRESS = "UPDATE_IN_PROGRESS"
    CREATE_FAILED = "CREATE_FAILED"
    UPDATE_FAILED = "UPDATE_FAILED"
    SUSPENDED = "SUSPENDED"


class JobAttachmentsFileSystem:
    """JobAttachmentsFileSystem enum values."""

    COPIED = "COPIED"
    VIRTUAL = "VIRTUAL"


class JobEntityErrorCode:
    """JobEntityErrorCode enum values."""

    ACCESSDENIEDEXCEPTION = "AccessDeniedException"
    INTERNALSERVEREXCEPTION = "InternalServerException"
    VALIDATIONEXCEPTION = "ValidationException"
    RESOURCENOTFOUNDEXCEPTION = "ResourceNotFoundException"
    MAXPAYLOADSIZEEXCEEDED = "MaxPayloadSizeExceeded"
    CONFLICTEXCEPTION = "ConflictException"


class JobLifecycleStatus:
    """JobLifecycleStatus enum values."""

    CREATE_IN_PROGRESS = "CREATE_IN_PROGRESS"
    CREATE_FAILED = "CREATE_FAILED"
    CREATE_COMPLETE = "CREATE_COMPLETE"
    UPLOAD_IN_PROGRESS = "UPLOAD_IN_PROGRESS"
    UPLOAD_FAILED = "UPLOAD_FAILED"
    UPDATE_IN_PROGRESS = "UPDATE_IN_PROGRESS"
    UPDATE_FAILED = "UPDATE_FAILED"
    UPDATE_SUCCEEDED = "UPDATE_SUCCEEDED"
    ARCHIVED = "ARCHIVED"


class JobTargetTaskRunStatus:
    """JobTargetTaskRunStatus enum values."""

    READY = "READY"
    FAILED = "FAILED"
    SUCCEEDED = "SUCCEEDED"
    CANCELED = "CANCELED"
    SUSPENDED = "SUSPENDED"
    PENDING = "PENDING"


class JobTemplateType:
    """JobTemplateType enum values."""

    JSON = "JSON"
    YAML = "YAML"


class LicenseEndpointStatus:
    """LicenseEndpointStatus enum values."""

    CREATE_IN_PROGRESS = "CREATE_IN_PROGRESS"
    DELETE_IN_PROGRESS = "DELETE_IN_PROGRESS"
    READY = "READY"
    NOT_READY = "NOT_READY"


class LogicalOperator:
    """LogicalOperator enum values."""

    AND = "AND"
    OR = "OR"


class MembershipLevel:
    """MembershipLevel enum values."""

    VIEWER = "VIEWER"
    CONTRIBUTOR = "CONTRIBUTOR"
    OWNER = "OWNER"
    MANAGER = "MANAGER"


class PathFormat:
    """PathFormat enum values."""

    WINDOWS = "windows"
    POSIX = "posix"


class Period:
    """Period enum values."""

    HOURLY = "HOURLY"
    DAILY = "DAILY"
    WEEKLY = "WEEKLY"
    MONTHLY = "MONTHLY"


class PrincipalType:
    """PrincipalType enum values."""

    USER = "USER"
    GROUP = "GROUP"


class QueueBlockedReason:
    """QueueBlockedReason enum values."""

    NO_BUDGET_CONFIGURED = "NO_BUDGET_CONFIGURED"
    BUDGET_THRESHOLD_REACHED = "BUDGET_THRESHOLD_REACHED"


class QueueFleetAssociationStatus:
    """QueueFleetAssociationStatus enum values."""

    ACTIVE = "ACTIVE"
    STOP_SCHEDULING_AND_COMPLETE_TASKS = "STOP_SCHEDULING_AND_COMPLETE_TASKS"
    STOP_SCHEDULING_AND_CANCEL_TASKS = "STOP_SCHEDULING_AND_CANCEL_TASKS"
    STOPPED = "STOPPED"


class QueueLimitAssociationStatus:
    """QueueLimitAssociationStatus enum values."""

    ACTIVE = "ACTIVE"
    STOP_LIMIT_USAGE_AND_COMPLETE_TASKS = "STOP_LIMIT_USAGE_AND_COMPLETE_TASKS"
    STOP_LIMIT_USAGE_AND_CANCEL_TASKS = "STOP_LIMIT_USAGE_AND_CANCEL_TASKS"
    STOPPED = "STOPPED"


class QueueStatus:
    """QueueStatus enum values."""

    IDLE = "IDLE"
    SCHEDULING = "SCHEDULING"
    SCHEDULING_BLOCKED = "SCHEDULING_BLOCKED"


class RunAs:
    """RunAs enum values."""

    QUEUE_CONFIGURED_USER = "QUEUE_CONFIGURED_USER"
    WORKER_AGENT_USER = "WORKER_AGENT_USER"


class SearchTermMatchingType:
    """SearchTermMatchingType enum values."""

    FUZZY_MATCH = "FUZZY_MATCH"
    CONTAINS = "CONTAINS"


class ServiceManagedFleetOperatingSystemFamily:
    """ServiceManagedFleetOperatingSystemFamily enum values."""

    WINDOWS = "WINDOWS"
    LINUX = "LINUX"


class ServiceQuotaExceededExceptionReason:
    """ServiceQuotaExceededExceptionReason enum values."""

    SERVICE_QUOTA_EXCEEDED_EXCEPTION = "SERVICE_QUOTA_EXCEEDED_EXCEPTION"
    KMS_KEY_LIMIT_EXCEEDED = "KMS_KEY_LIMIT_EXCEEDED"
    DEPENDENCY_LIMIT_EXCEEDED = "DEPENDENCY_LIMIT_EXCEEDED"


class SessionActionStatus:
    """SessionActionStatus enum values."""

    ASSIGNED = "ASSIGNED"
    RUNNING = "RUNNING"
    CANCELING = "CANCELING"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    INTERRUPTED = "INTERRUPTED"
    CANCELED = "CANCELED"
    NEVER_ATTEMPTED = "NEVER_ATTEMPTED"
    SCHEDULED = "SCHEDULED"
    RECLAIMING = "RECLAIMING"
    RECLAIMED = "RECLAIMED"


class SessionLifecycleStatus:
    """SessionLifecycleStatus enum values."""

    STARTED = "STARTED"
    UPDATE_IN_PROGRESS = "UPDATE_IN_PROGRESS"
    UPDATE_SUCCEEDED = "UPDATE_SUCCEEDED"
    UPDATE_FAILED = "UPDATE_FAILED"
    ENDED = "ENDED"


class SessionLifecycleTargetStatus:
    """SessionLifecycleTargetStatus enum values."""

    ENDED = "ENDED"


class SessionsStatisticsAggregationStatus:
    """SessionsStatisticsAggregationStatus enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    TIMEOUT = "TIMEOUT"
    FAILED = "FAILED"
    COMPLETED = "COMPLETED"


class SortOrder:
    """SortOrder enum values."""

    ASCENDING = "ASCENDING"
    DESCENDING = "DESCENDING"


class StepLifecycleStatus:
    """StepLifecycleStatus enum values."""

    CREATE_COMPLETE = "CREATE_COMPLETE"
    UPDATE_IN_PROGRESS = "UPDATE_IN_PROGRESS"
    UPDATE_FAILED = "UPDATE_FAILED"
    UPDATE_SUCCEEDED = "UPDATE_SUCCEEDED"


class StepParameterType:
    """StepParameterType enum values."""

    INT = "INT"
    FLOAT = "FLOAT"
    STRING = "STRING"
    PATH = "PATH"
    CHUNK_INT = "CHUNK_INT"


class StepTargetTaskRunStatus:
    """StepTargetTaskRunStatus enum values."""

    READY = "READY"
    FAILED = "FAILED"
    SUCCEEDED = "SUCCEEDED"
    CANCELED = "CANCELED"
    SUSPENDED = "SUSPENDED"
    PENDING = "PENDING"


class StorageProfileOperatingSystemFamily:
    """StorageProfileOperatingSystemFamily enum values."""

    WINDOWS = "WINDOWS"
    LINUX = "LINUX"
    MACOS = "MACOS"


class TagPropagationMode:
    """TagPropagationMode enum values."""

    NO_PROPAGATION = "NO_PROPAGATION"
    PROPAGATE_TAGS_TO_WORKERS_AT_LAUNCH = "PROPAGATE_TAGS_TO_WORKERS_AT_LAUNCH"


class TaskRunStatus:
    """TaskRunStatus enum values."""

    PENDING = "PENDING"
    READY = "READY"
    ASSIGNED = "ASSIGNED"
    STARTING = "STARTING"
    SCHEDULED = "SCHEDULED"
    INTERRUPTING = "INTERRUPTING"
    RUNNING = "RUNNING"
    SUSPENDED = "SUSPENDED"
    CANCELED = "CANCELED"
    FAILED = "FAILED"
    SUCCEEDED = "SUCCEEDED"
    NOT_COMPATIBLE = "NOT_COMPATIBLE"


class TaskTargetRunStatus:
    """TaskTargetRunStatus enum values."""

    READY = "READY"
    FAILED = "FAILED"
    SUCCEEDED = "SUCCEEDED"
    CANCELED = "CANCELED"
    SUSPENDED = "SUSPENDED"
    PENDING = "PENDING"


class UpdateJobLifecycleStatus:
    """UpdateJobLifecycleStatus enum values."""

    ARCHIVED = "ARCHIVED"


class UpdateQueueFleetAssociationStatus:
    """UpdateQueueFleetAssociationStatus enum values."""

    ACTIVE = "ACTIVE"
    STOP_SCHEDULING_AND_COMPLETE_TASKS = "STOP_SCHEDULING_AND_COMPLETE_TASKS"
    STOP_SCHEDULING_AND_CANCEL_TASKS = "STOP_SCHEDULING_AND_CANCEL_TASKS"


class UpdateQueueLimitAssociationStatus:
    """UpdateQueueLimitAssociationStatus enum values."""

    ACTIVE = "ACTIVE"
    STOP_LIMIT_USAGE_AND_COMPLETE_TASKS = "STOP_LIMIT_USAGE_AND_COMPLETE_TASKS"
    STOP_LIMIT_USAGE_AND_CANCEL_TASKS = "STOP_LIMIT_USAGE_AND_CANCEL_TASKS"


class UpdatedWorkerStatus:
    """UpdatedWorkerStatus enum values."""

    STARTED = "STARTED"
    STOPPING = "STOPPING"
    STOPPED = "STOPPED"


class UsageGroupByField:
    """UsageGroupByField enum values."""

    QUEUE_ID = "QUEUE_ID"
    FLEET_ID = "FLEET_ID"
    JOB_ID = "JOB_ID"
    USER_ID = "USER_ID"
    USAGE_TYPE = "USAGE_TYPE"
    INSTANCE_TYPE = "INSTANCE_TYPE"
    LICENSE_PRODUCT = "LICENSE_PRODUCT"


class UsageStatistic:
    """UsageStatistic enum values."""

    SUM = "SUM"
    MIN = "MIN"
    MAX = "MAX"
    AVG = "AVG"


class UsageType:
    """UsageType enum values."""

    COMPUTE = "COMPUTE"
    LICENSE = "LICENSE"


class ValidationExceptionReason:
    """ValidationExceptionReason enum values."""

    UNKNOWN_OPERATION = "UNKNOWN_OPERATION"
    CANNOT_PARSE = "CANNOT_PARSE"
    FIELD_VALIDATION_FAILED = "FIELD_VALIDATION_FAILED"
    OTHER = "OTHER"


class WorkerStatus:
    """WorkerStatus enum values."""

    CREATED = "CREATED"
    STARTED = "STARTED"
    STOPPING = "STOPPING"
    STOPPED = "STOPPED"
    NOT_RESPONDING = "NOT_RESPONDING"
    NOT_COMPATIBLE = "NOT_COMPATIBLE"
    RUNNING = "RUNNING"
    IDLE = "IDLE"


# Convenient aliases for enum values
T4 = AcceleratorName.T4
A10G = AcceleratorName.A10G
L4 = AcceleratorName.L4
L40S = AcceleratorName.L40S
GPU = AcceleratorType.GPU
NO_SCALING = AutoScalingMode.NO_SCALING
EVENT_BASED_AUTO_SCALING = AutoScalingMode.EVENT_BASED_AUTO_SCALING
GROWING = AutoScalingStatus.GROWING
STEADY = AutoScalingStatus.STEADY
SHRINKING = AutoScalingStatus.SHRINKING
STOP_SCHEDULING_AND_COMPLETE_TASKS = BudgetActionType.STOP_SCHEDULING_AND_COMPLETE_TASKS
STOP_SCHEDULING_AND_CANCEL_TASKS = BudgetActionType.STOP_SCHEDULING_AND_CANCEL_TASKS
ACTIVE = BudgetStatus.ACTIVE
INACTIVE = BudgetStatus.INACTIVE
EQUAL = ComparisonOperator.EQUAL
NOT_EQUAL = ComparisonOperator.NOT_EQUAL
GREATER_THAN_EQUAL_TO = ComparisonOperator.GREATER_THAN_EQUAL_TO
GREATER_THAN = ComparisonOperator.GREATER_THAN
LESS_THAN_EQUAL_TO = ComparisonOperator.LESS_THAN_EQUAL_TO
LESS_THAN = ComparisonOperator.LESS_THAN
SUCCEEDED = CompletedStatus.SUCCEEDED
FAILED = CompletedStatus.FAILED
INTERRUPTED = CompletedStatus.INTERRUPTED
CANCELED = CompletedStatus.CANCELED
NEVER_ATTEMPTED = CompletedStatus.NEVER_ATTEMPTED
CONFLICT_EXCEPTION = ConflictExceptionReason.CONFLICT_EXCEPTION
CONCURRENT_MODIFICATION = ConflictExceptionReason.CONCURRENT_MODIFICATION
RESOURCE_ALREADY_EXISTS = ConflictExceptionReason.RESOURCE_ALREADY_EXISTS
RESOURCE_IN_USE = ConflictExceptionReason.RESOURCE_IN_USE
STATUS_CONFLICT = ConflictExceptionReason.STATUS_CONFLICT
X86_64 = CpuArchitectureType.X86_64
ARM64 = CpuArchitectureType.ARM64
READY = CreateJobTargetTaskRunStatus.READY
SUSPENDED = CreateJobTargetTaskRunStatus.SUSPENDED
WINDOWS = CustomerManagedFleetOperatingSystemFamily.WINDOWS
LINUX = CustomerManagedFleetOperatingSystemFamily.LINUX
MACOS = CustomerManagedFleetOperatingSystemFamily.MACOS
NONE = DefaultQueueBudgetAction.NONE
STOP_SCHEDULING_AND_COMPLETE_TASKS = DefaultQueueBudgetAction.STOP_SCHEDULING_AND_COMPLETE_TASKS
STOP_SCHEDULING_AND_CANCEL_TASKS = DefaultQueueBudgetAction.STOP_SCHEDULING_AND_CANCEL_TASKS
RESOLVED = DependencyConsumerResolutionStatus.RESOLVED
UNRESOLVED = DependencyConsumerResolutionStatus.UNRESOLVED
STOPPED = DesiredWorkerStatus.STOPPED
ON_DEMAND = Ec2MarketType.ON_DEMAND
SPOT = Ec2MarketType.SPOT
WAIT_AND_SAVE = Ec2MarketType.WAIT_AND_SAVE
JSON = EnvironmentTemplateType.JSON
YAML = EnvironmentTemplateType.YAML
SHARED = FileSystemLocationType.SHARED
LOCAL = FileSystemLocationType.LOCAL
ACTIVE = FleetStatus.ACTIVE
CREATE_IN_PROGRESS = FleetStatus.CREATE_IN_PROGRESS
UPDATE_IN_PROGRESS = FleetStatus.UPDATE_IN_PROGRESS
CREATE_FAILED = FleetStatus.CREATE_FAILED
UPDATE_FAILED = FleetStatus.UPDATE_FAILED
SUSPENDED = FleetStatus.SUSPENDED
COPIED = JobAttachmentsFileSystem.COPIED
VIRTUAL = JobAttachmentsFileSystem.VIRTUAL
ACCESSDENIEDEXCEPTION = JobEntityErrorCode.ACCESSDENIEDEXCEPTION
INTERNALSERVEREXCEPTION = JobEntityErrorCode.INTERNALSERVEREXCEPTION
VALIDATIONEXCEPTION = JobEntityErrorCode.VALIDATIONEXCEPTION
RESOURCENOTFOUNDEXCEPTION = JobEntityErrorCode.RESOURCENOTFOUNDEXCEPTION
MAXPAYLOADSIZEEXCEEDED = JobEntityErrorCode.MAXPAYLOADSIZEEXCEEDED
CONFLICTEXCEPTION = JobEntityErrorCode.CONFLICTEXCEPTION
CREATE_IN_PROGRESS = JobLifecycleStatus.CREATE_IN_PROGRESS
CREATE_FAILED = JobLifecycleStatus.CREATE_FAILED
CREATE_COMPLETE = JobLifecycleStatus.CREATE_COMPLETE
UPLOAD_IN_PROGRESS = JobLifecycleStatus.UPLOAD_IN_PROGRESS
UPLOAD_FAILED = JobLifecycleStatus.UPLOAD_FAILED
UPDATE_IN_PROGRESS = JobLifecycleStatus.UPDATE_IN_PROGRESS
UPDATE_FAILED = JobLifecycleStatus.UPDATE_FAILED
UPDATE_SUCCEEDED = JobLifecycleStatus.UPDATE_SUCCEEDED
ARCHIVED = JobLifecycleStatus.ARCHIVED
READY = JobTargetTaskRunStatus.READY
FAILED = JobTargetTaskRunStatus.FAILED
SUCCEEDED = JobTargetTaskRunStatus.SUCCEEDED
CANCELED = JobTargetTaskRunStatus.CANCELED
SUSPENDED = JobTargetTaskRunStatus.SUSPENDED
PENDING = JobTargetTaskRunStatus.PENDING
JSON = JobTemplateType.JSON
YAML = JobTemplateType.YAML
CREATE_IN_PROGRESS = LicenseEndpointStatus.CREATE_IN_PROGRESS
DELETE_IN_PROGRESS = LicenseEndpointStatus.DELETE_IN_PROGRESS
READY = LicenseEndpointStatus.READY
NOT_READY = LicenseEndpointStatus.NOT_READY
AND = LogicalOperator.AND
OR = LogicalOperator.OR
VIEWER = MembershipLevel.VIEWER
CONTRIBUTOR = MembershipLevel.CONTRIBUTOR
OWNER = MembershipLevel.OWNER
MANAGER = MembershipLevel.MANAGER
WINDOWS = PathFormat.WINDOWS
POSIX = PathFormat.POSIX
HOURLY = Period.HOURLY
DAILY = Period.DAILY
WEEKLY = Period.WEEKLY
MONTHLY = Period.MONTHLY
USER = PrincipalType.USER
GROUP = PrincipalType.GROUP
NO_BUDGET_CONFIGURED = QueueBlockedReason.NO_BUDGET_CONFIGURED
BUDGET_THRESHOLD_REACHED = QueueBlockedReason.BUDGET_THRESHOLD_REACHED
ACTIVE = QueueFleetAssociationStatus.ACTIVE
STOP_SCHEDULING_AND_COMPLETE_TASKS = QueueFleetAssociationStatus.STOP_SCHEDULING_AND_COMPLETE_TASKS
STOP_SCHEDULING_AND_CANCEL_TASKS = QueueFleetAssociationStatus.STOP_SCHEDULING_AND_CANCEL_TASKS
STOPPED = QueueFleetAssociationStatus.STOPPED
ACTIVE = QueueLimitAssociationStatus.ACTIVE
STOP_LIMIT_USAGE_AND_COMPLETE_TASKS = QueueLimitAssociationStatus.STOP_LIMIT_USAGE_AND_COMPLETE_TASKS
STOP_LIMIT_USAGE_AND_CANCEL_TASKS = QueueLimitAssociationStatus.STOP_LIMIT_USAGE_AND_CANCEL_TASKS
STOPPED = QueueLimitAssociationStatus.STOPPED
IDLE = QueueStatus.IDLE
SCHEDULING = QueueStatus.SCHEDULING
SCHEDULING_BLOCKED = QueueStatus.SCHEDULING_BLOCKED
QUEUE_CONFIGURED_USER = RunAs.QUEUE_CONFIGURED_USER
WORKER_AGENT_USER = RunAs.WORKER_AGENT_USER
FUZZY_MATCH = SearchTermMatchingType.FUZZY_MATCH
CONTAINS = SearchTermMatchingType.CONTAINS
WINDOWS = ServiceManagedFleetOperatingSystemFamily.WINDOWS
LINUX = ServiceManagedFleetOperatingSystemFamily.LINUX
SERVICE_QUOTA_EXCEEDED_EXCEPTION = ServiceQuotaExceededExceptionReason.SERVICE_QUOTA_EXCEEDED_EXCEPTION
KMS_KEY_LIMIT_EXCEEDED = ServiceQuotaExceededExceptionReason.KMS_KEY_LIMIT_EXCEEDED
DEPENDENCY_LIMIT_EXCEEDED = ServiceQuotaExceededExceptionReason.DEPENDENCY_LIMIT_EXCEEDED
ASSIGNED = SessionActionStatus.ASSIGNED
RUNNING = SessionActionStatus.RUNNING
CANCELING = SessionActionStatus.CANCELING
SUCCEEDED = SessionActionStatus.SUCCEEDED
FAILED = SessionActionStatus.FAILED
INTERRUPTED = SessionActionStatus.INTERRUPTED
CANCELED = SessionActionStatus.CANCELED
NEVER_ATTEMPTED = SessionActionStatus.NEVER_ATTEMPTED
SCHEDULED = SessionActionStatus.SCHEDULED
RECLAIMING = SessionActionStatus.RECLAIMING
RECLAIMED = SessionActionStatus.RECLAIMED
STARTED = SessionLifecycleStatus.STARTED
UPDATE_IN_PROGRESS = SessionLifecycleStatus.UPDATE_IN_PROGRESS
UPDATE_SUCCEEDED = SessionLifecycleStatus.UPDATE_SUCCEEDED
UPDATE_FAILED = SessionLifecycleStatus.UPDATE_FAILED
ENDED = SessionLifecycleStatus.ENDED
ENDED = SessionLifecycleTargetStatus.ENDED
IN_PROGRESS = SessionsStatisticsAggregationStatus.IN_PROGRESS
TIMEOUT = SessionsStatisticsAggregationStatus.TIMEOUT
FAILED = SessionsStatisticsAggregationStatus.FAILED
COMPLETED = SessionsStatisticsAggregationStatus.COMPLETED
ASCENDING = SortOrder.ASCENDING
DESCENDING = SortOrder.DESCENDING
CREATE_COMPLETE = StepLifecycleStatus.CREATE_COMPLETE
UPDATE_IN_PROGRESS = StepLifecycleStatus.UPDATE_IN_PROGRESS
UPDATE_FAILED = StepLifecycleStatus.UPDATE_FAILED
UPDATE_SUCCEEDED = StepLifecycleStatus.UPDATE_SUCCEEDED
INT = StepParameterType.INT
FLOAT = StepParameterType.FLOAT
STRING = StepParameterType.STRING
PATH = StepParameterType.PATH
CHUNK_INT = StepParameterType.CHUNK_INT
READY = StepTargetTaskRunStatus.READY
FAILED = StepTargetTaskRunStatus.FAILED
SUCCEEDED = StepTargetTaskRunStatus.SUCCEEDED
CANCELED = StepTargetTaskRunStatus.CANCELED
SUSPENDED = StepTargetTaskRunStatus.SUSPENDED
PENDING = StepTargetTaskRunStatus.PENDING
WINDOWS = StorageProfileOperatingSystemFamily.WINDOWS
LINUX = StorageProfileOperatingSystemFamily.LINUX
MACOS = StorageProfileOperatingSystemFamily.MACOS
NO_PROPAGATION = TagPropagationMode.NO_PROPAGATION
PROPAGATE_TAGS_TO_WORKERS_AT_LAUNCH = TagPropagationMode.PROPAGATE_TAGS_TO_WORKERS_AT_LAUNCH
PENDING = TaskRunStatus.PENDING
READY = TaskRunStatus.READY
ASSIGNED = TaskRunStatus.ASSIGNED
STARTING = TaskRunStatus.STARTING
SCHEDULED = TaskRunStatus.SCHEDULED
INTERRUPTING = TaskRunStatus.INTERRUPTING
RUNNING = TaskRunStatus.RUNNING
SUSPENDED = TaskRunStatus.SUSPENDED
CANCELED = TaskRunStatus.CANCELED
FAILED = TaskRunStatus.FAILED
SUCCEEDED = TaskRunStatus.SUCCEEDED
NOT_COMPATIBLE = TaskRunStatus.NOT_COMPATIBLE
READY = TaskTargetRunStatus.READY
FAILED = TaskTargetRunStatus.FAILED
SUCCEEDED = TaskTargetRunStatus.SUCCEEDED
CANCELED = TaskTargetRunStatus.CANCELED
SUSPENDED = TaskTargetRunStatus.SUSPENDED
PENDING = TaskTargetRunStatus.PENDING
ARCHIVED = UpdateJobLifecycleStatus.ARCHIVED
ACTIVE = UpdateQueueFleetAssociationStatus.ACTIVE
STOP_SCHEDULING_AND_COMPLETE_TASKS = UpdateQueueFleetAssociationStatus.STOP_SCHEDULING_AND_COMPLETE_TASKS
STOP_SCHEDULING_AND_CANCEL_TASKS = UpdateQueueFleetAssociationStatus.STOP_SCHEDULING_AND_CANCEL_TASKS
ACTIVE = UpdateQueueLimitAssociationStatus.ACTIVE
STOP_LIMIT_USAGE_AND_COMPLETE_TASKS = UpdateQueueLimitAssociationStatus.STOP_LIMIT_USAGE_AND_COMPLETE_TASKS
STOP_LIMIT_USAGE_AND_CANCEL_TASKS = UpdateQueueLimitAssociationStatus.STOP_LIMIT_USAGE_AND_CANCEL_TASKS
STARTED = UpdatedWorkerStatus.STARTED
STOPPING = UpdatedWorkerStatus.STOPPING
STOPPED = UpdatedWorkerStatus.STOPPED
QUEUE_ID = UsageGroupByField.QUEUE_ID
FLEET_ID = UsageGroupByField.FLEET_ID
JOB_ID = UsageGroupByField.JOB_ID
USER_ID = UsageGroupByField.USER_ID
USAGE_TYPE = UsageGroupByField.USAGE_TYPE
INSTANCE_TYPE = UsageGroupByField.INSTANCE_TYPE
LICENSE_PRODUCT = UsageGroupByField.LICENSE_PRODUCT
SUM = UsageStatistic.SUM
MIN = UsageStatistic.MIN
MAX = UsageStatistic.MAX
AVG = UsageStatistic.AVG
COMPUTE = UsageType.COMPUTE
LICENSE = UsageType.LICENSE
UNKNOWN_OPERATION = ValidationExceptionReason.UNKNOWN_OPERATION
CANNOT_PARSE = ValidationExceptionReason.CANNOT_PARSE
FIELD_VALIDATION_FAILED = ValidationExceptionReason.FIELD_VALIDATION_FAILED
OTHER = ValidationExceptionReason.OTHER
CREATED = WorkerStatus.CREATED
STARTED = WorkerStatus.STARTED
STOPPING = WorkerStatus.STOPPING
STOPPED = WorkerStatus.STOPPED
NOT_RESPONDING = WorkerStatus.NOT_RESPONDING
NOT_COMPATIBLE = WorkerStatus.NOT_COMPATIBLE
RUNNING = WorkerStatus.RUNNING
IDLE = WorkerStatus.IDLE


@dataclass
class Farm(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-deadl"""

    resource_type: ClassVar[str] = "AWS::Deadline::Farm"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.kms_key_arn is not None:
            # Serialize kms_key_arn (handle intrinsic functions)
            if hasattr(self.kms_key_arn, 'to_dict'):
                props["KmsKeyArn"] = self.kms_key_arn.to_dict()
            elif isinstance(self.kms_key_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_arn
                ]
            else:
                props["KmsKeyArn"] = self.kms_key_arn

        if self.display_name is not None:
            # Serialize display_name (handle intrinsic functions)
            if hasattr(self.display_name, 'to_dict'):
                props["DisplayName"] = self.display_name.to_dict()
            elif isinstance(self.display_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.display_name
                ]
            else:
                props["DisplayName"] = self.display_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_farm_id(self) -> GetAtt:
        """Get the FarmId attribute."""
        return self.get_att("FarmId")




@dataclass
class AcceleratorCapabilities:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    selections: Optional[list[AcceleratorSelection]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    count: Optional[AcceleratorCountRange] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.selections is not None:
            if hasattr(self.selections, 'to_dict'):
                props['Selections'] = self.selections.to_dict()
            elif isinstance(self.selections, list):
                props['Selections'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.selections
                ]
            else:
                props['Selections'] = self.selections

        if self.count is not None:
            if hasattr(self.count, 'to_dict'):
                props['Count'] = self.count.to_dict()
            elif isinstance(self.count, list):
                props['Count'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.count
                ]
            else:
                props['Count'] = self.count

        return props


@dataclass
class AcceleratorCountRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class AcceleratorSelection:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    runtime: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.runtime is not None:
            if hasattr(self.runtime, 'to_dict'):
                props['Runtime'] = self.runtime.to_dict()
            elif isinstance(self.runtime, list):
                props['Runtime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.runtime
                ]
            else:
                props['Runtime'] = self.runtime

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class AcceleratorTotalMemoryMiBRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class CustomerManagedFleetConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    storage_profile_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    worker_capabilities: Optional[CustomerManagedWorkerCapabilities] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    tag_propagation_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.storage_profile_id is not None:
            if hasattr(self.storage_profile_id, 'to_dict'):
                props['StorageProfileId'] = self.storage_profile_id.to_dict()
            elif isinstance(self.storage_profile_id, list):
                props['StorageProfileId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_profile_id
                ]
            else:
                props['StorageProfileId'] = self.storage_profile_id

        if self.mode is not None:
            if hasattr(self.mode, 'to_dict'):
                props['Mode'] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props['Mode'] = self.mode

        if self.worker_capabilities is not None:
            if hasattr(self.worker_capabilities, 'to_dict'):
                props['WorkerCapabilities'] = self.worker_capabilities.to_dict()
            elif isinstance(self.worker_capabilities, list):
                props['WorkerCapabilities'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.worker_capabilities
                ]
            else:
                props['WorkerCapabilities'] = self.worker_capabilities

        if self.tag_propagation_mode is not None:
            if hasattr(self.tag_propagation_mode, 'to_dict'):
                props['TagPropagationMode'] = self.tag_propagation_mode.to_dict()
            elif isinstance(self.tag_propagation_mode, list):
                props['TagPropagationMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_propagation_mode
                ]
            else:
                props['TagPropagationMode'] = self.tag_propagation_mode

        return props


@dataclass
class CustomerManagedWorkerCapabilities:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_attributes: Optional[list[FleetAttributeCapability]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_count: Optional[AcceleratorCountRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_amounts: Optional[list[FleetAmountCapability]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_total_memory_mi_b: Optional[AcceleratorTotalMemoryMiBRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    v_cpu_count: Optional[VCpuCountRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_mi_b: Optional[MemoryMiBRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    os_family: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_architecture_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.custom_attributes is not None:
            if hasattr(self.custom_attributes, 'to_dict'):
                props['CustomAttributes'] = self.custom_attributes.to_dict()
            elif isinstance(self.custom_attributes, list):
                props['CustomAttributes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_attributes
                ]
            else:
                props['CustomAttributes'] = self.custom_attributes

        if self.accelerator_count is not None:
            if hasattr(self.accelerator_count, 'to_dict'):
                props['AcceleratorCount'] = self.accelerator_count.to_dict()
            elif isinstance(self.accelerator_count, list):
                props['AcceleratorCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_count
                ]
            else:
                props['AcceleratorCount'] = self.accelerator_count

        if self.custom_amounts is not None:
            if hasattr(self.custom_amounts, 'to_dict'):
                props['CustomAmounts'] = self.custom_amounts.to_dict()
            elif isinstance(self.custom_amounts, list):
                props['CustomAmounts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_amounts
                ]
            else:
                props['CustomAmounts'] = self.custom_amounts

        if self.accelerator_types is not None:
            if hasattr(self.accelerator_types, 'to_dict'):
                props['AcceleratorTypes'] = self.accelerator_types.to_dict()
            elif isinstance(self.accelerator_types, list):
                props['AcceleratorTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_types
                ]
            else:
                props['AcceleratorTypes'] = self.accelerator_types

        if self.accelerator_total_memory_mi_b is not None:
            if hasattr(self.accelerator_total_memory_mi_b, 'to_dict'):
                props['AcceleratorTotalMemoryMiB'] = self.accelerator_total_memory_mi_b.to_dict()
            elif isinstance(self.accelerator_total_memory_mi_b, list):
                props['AcceleratorTotalMemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_total_memory_mi_b
                ]
            else:
                props['AcceleratorTotalMemoryMiB'] = self.accelerator_total_memory_mi_b

        if self.v_cpu_count is not None:
            if hasattr(self.v_cpu_count, 'to_dict'):
                props['VCpuCount'] = self.v_cpu_count.to_dict()
            elif isinstance(self.v_cpu_count, list):
                props['VCpuCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.v_cpu_count
                ]
            else:
                props['VCpuCount'] = self.v_cpu_count

        if self.memory_mi_b is not None:
            if hasattr(self.memory_mi_b, 'to_dict'):
                props['MemoryMiB'] = self.memory_mi_b.to_dict()
            elif isinstance(self.memory_mi_b, list):
                props['MemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_mi_b
                ]
            else:
                props['MemoryMiB'] = self.memory_mi_b

        if self.os_family is not None:
            if hasattr(self.os_family, 'to_dict'):
                props['OsFamily'] = self.os_family.to_dict()
            elif isinstance(self.os_family, list):
                props['OsFamily'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.os_family
                ]
            else:
                props['OsFamily'] = self.os_family

        if self.cpu_architecture_type is not None:
            if hasattr(self.cpu_architecture_type, 'to_dict'):
                props['CpuArchitectureType'] = self.cpu_architecture_type.to_dict()
            elif isinstance(self.cpu_architecture_type, list):
                props['CpuArchitectureType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_architecture_type
                ]
            else:
                props['CpuArchitectureType'] = self.cpu_architecture_type

        return props


@dataclass
class Ec2EbsVolume:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    size_gi_b: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    throughput_mi_b: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iops: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.size_gi_b is not None:
            if hasattr(self.size_gi_b, 'to_dict'):
                props['SizeGiB'] = self.size_gi_b.to_dict()
            elif isinstance(self.size_gi_b, list):
                props['SizeGiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.size_gi_b
                ]
            else:
                props['SizeGiB'] = self.size_gi_b

        if self.throughput_mi_b is not None:
            if hasattr(self.throughput_mi_b, 'to_dict'):
                props['ThroughputMiB'] = self.throughput_mi_b.to_dict()
            elif isinstance(self.throughput_mi_b, list):
                props['ThroughputMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.throughput_mi_b
                ]
            else:
                props['ThroughputMiB'] = self.throughput_mi_b

        if self.iops is not None:
            if hasattr(self.iops, 'to_dict'):
                props['Iops'] = self.iops.to_dict()
            elif isinstance(self.iops, list):
                props['Iops'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iops
                ]
            else:
                props['Iops'] = self.iops

        return props


@dataclass
class FleetAmountCapability:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class FleetAttributeCapability:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    values: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.values is not None:
            if hasattr(self.values, 'to_dict'):
                props['Values'] = self.values.to_dict()
            elif isinstance(self.values, list):
                props['Values'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.values
                ]
            else:
                props['Values'] = self.values

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class FleetCapabilities:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    amounts: Optional[list[FleetAmountCapability]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attributes: Optional[list[FleetAttributeCapability]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.amounts is not None:
            if hasattr(self.amounts, 'to_dict'):
                props['Amounts'] = self.amounts.to_dict()
            elif isinstance(self.amounts, list):
                props['Amounts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.amounts
                ]
            else:
                props['Amounts'] = self.amounts

        if self.attributes is not None:
            if hasattr(self.attributes, 'to_dict'):
                props['Attributes'] = self.attributes.to_dict()
            elif isinstance(self.attributes, list):
                props['Attributes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attributes
                ]
            else:
                props['Attributes'] = self.attributes

        return props


@dataclass
class FleetConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    service_managed_ec2: Optional[ServiceManagedEc2FleetConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    customer_managed: Optional[CustomerManagedFleetConfiguration] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.service_managed_ec2 is not None:
            if hasattr(self.service_managed_ec2, 'to_dict'):
                props['ServiceManagedEc2'] = self.service_managed_ec2.to_dict()
            elif isinstance(self.service_managed_ec2, list):
                props['ServiceManagedEc2'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_managed_ec2
                ]
            else:
                props['ServiceManagedEc2'] = self.service_managed_ec2

        if self.customer_managed is not None:
            if hasattr(self.customer_managed, 'to_dict'):
                props['CustomerManaged'] = self.customer_managed.to_dict()
            elif isinstance(self.customer_managed, list):
                props['CustomerManaged'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customer_managed
                ]
            else:
                props['CustomerManaged'] = self.customer_managed

        return props


@dataclass
class HostConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    script_timeout_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    script_body: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.script_timeout_seconds is not None:
            if hasattr(self.script_timeout_seconds, 'to_dict'):
                props['ScriptTimeoutSeconds'] = self.script_timeout_seconds.to_dict()
            elif isinstance(self.script_timeout_seconds, list):
                props['ScriptTimeoutSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.script_timeout_seconds
                ]
            else:
                props['ScriptTimeoutSeconds'] = self.script_timeout_seconds

        if self.script_body is not None:
            if hasattr(self.script_body, 'to_dict'):
                props['ScriptBody'] = self.script_body.to_dict()
            elif isinstance(self.script_body, list):
                props['ScriptBody'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.script_body
                ]
            else:
                props['ScriptBody'] = self.script_body

        return props


@dataclass
class MemoryMiBRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class ServiceManagedEc2FleetConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    storage_profile_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_market_options: Optional[ServiceManagedEc2InstanceMarketOptions] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_capabilities: Optional[ServiceManagedEc2InstanceCapabilities] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_configuration: Optional[VpcConfiguration] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.storage_profile_id is not None:
            if hasattr(self.storage_profile_id, 'to_dict'):
                props['StorageProfileId'] = self.storage_profile_id.to_dict()
            elif isinstance(self.storage_profile_id, list):
                props['StorageProfileId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_profile_id
                ]
            else:
                props['StorageProfileId'] = self.storage_profile_id

        if self.instance_market_options is not None:
            if hasattr(self.instance_market_options, 'to_dict'):
                props['InstanceMarketOptions'] = self.instance_market_options.to_dict()
            elif isinstance(self.instance_market_options, list):
                props['InstanceMarketOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_market_options
                ]
            else:
                props['InstanceMarketOptions'] = self.instance_market_options

        if self.instance_capabilities is not None:
            if hasattr(self.instance_capabilities, 'to_dict'):
                props['InstanceCapabilities'] = self.instance_capabilities.to_dict()
            elif isinstance(self.instance_capabilities, list):
                props['InstanceCapabilities'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_capabilities
                ]
            else:
                props['InstanceCapabilities'] = self.instance_capabilities

        if self.vpc_configuration is not None:
            if hasattr(self.vpc_configuration, 'to_dict'):
                props['VpcConfiguration'] = self.vpc_configuration.to_dict()
            elif isinstance(self.vpc_configuration, list):
                props['VpcConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_configuration
                ]
            else:
                props['VpcConfiguration'] = self.vpc_configuration

        return props


@dataclass
class ServiceManagedEc2InstanceCapabilities:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allowed_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_attributes: Optional[list[FleetAttributeCapability]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accelerator_capabilities: Optional[AcceleratorCapabilities] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_amounts: Optional[list[FleetAmountCapability]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    v_cpu_count: Optional[VCpuCountRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    excluded_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_mi_b: Optional[MemoryMiBRange] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    os_family: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cpu_architecture_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    root_ebs_volume: Optional[Ec2EbsVolume] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.allowed_instance_types is not None:
            if hasattr(self.allowed_instance_types, 'to_dict'):
                props['AllowedInstanceTypes'] = self.allowed_instance_types.to_dict()
            elif isinstance(self.allowed_instance_types, list):
                props['AllowedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_instance_types
                ]
            else:
                props['AllowedInstanceTypes'] = self.allowed_instance_types

        if self.custom_attributes is not None:
            if hasattr(self.custom_attributes, 'to_dict'):
                props['CustomAttributes'] = self.custom_attributes.to_dict()
            elif isinstance(self.custom_attributes, list):
                props['CustomAttributes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_attributes
                ]
            else:
                props['CustomAttributes'] = self.custom_attributes

        if self.accelerator_capabilities is not None:
            if hasattr(self.accelerator_capabilities, 'to_dict'):
                props['AcceleratorCapabilities'] = self.accelerator_capabilities.to_dict()
            elif isinstance(self.accelerator_capabilities, list):
                props['AcceleratorCapabilities'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_capabilities
                ]
            else:
                props['AcceleratorCapabilities'] = self.accelerator_capabilities

        if self.custom_amounts is not None:
            if hasattr(self.custom_amounts, 'to_dict'):
                props['CustomAmounts'] = self.custom_amounts.to_dict()
            elif isinstance(self.custom_amounts, list):
                props['CustomAmounts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_amounts
                ]
            else:
                props['CustomAmounts'] = self.custom_amounts

        if self.v_cpu_count is not None:
            if hasattr(self.v_cpu_count, 'to_dict'):
                props['VCpuCount'] = self.v_cpu_count.to_dict()
            elif isinstance(self.v_cpu_count, list):
                props['VCpuCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.v_cpu_count
                ]
            else:
                props['VCpuCount'] = self.v_cpu_count

        if self.excluded_instance_types is not None:
            if hasattr(self.excluded_instance_types, 'to_dict'):
                props['ExcludedInstanceTypes'] = self.excluded_instance_types.to_dict()
            elif isinstance(self.excluded_instance_types, list):
                props['ExcludedInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.excluded_instance_types
                ]
            else:
                props['ExcludedInstanceTypes'] = self.excluded_instance_types

        if self.memory_mi_b is not None:
            if hasattr(self.memory_mi_b, 'to_dict'):
                props['MemoryMiB'] = self.memory_mi_b.to_dict()
            elif isinstance(self.memory_mi_b, list):
                props['MemoryMiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_mi_b
                ]
            else:
                props['MemoryMiB'] = self.memory_mi_b

        if self.os_family is not None:
            if hasattr(self.os_family, 'to_dict'):
                props['OsFamily'] = self.os_family.to_dict()
            elif isinstance(self.os_family, list):
                props['OsFamily'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.os_family
                ]
            else:
                props['OsFamily'] = self.os_family

        if self.cpu_architecture_type is not None:
            if hasattr(self.cpu_architecture_type, 'to_dict'):
                props['CpuArchitectureType'] = self.cpu_architecture_type.to_dict()
            elif isinstance(self.cpu_architecture_type, list):
                props['CpuArchitectureType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cpu_architecture_type
                ]
            else:
                props['CpuArchitectureType'] = self.cpu_architecture_type

        if self.root_ebs_volume is not None:
            if hasattr(self.root_ebs_volume, 'to_dict'):
                props['RootEbsVolume'] = self.root_ebs_volume.to_dict()
            elif isinstance(self.root_ebs_volume, list):
                props['RootEbsVolume'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.root_ebs_volume
                ]
            else:
                props['RootEbsVolume'] = self.root_ebs_volume

        return props


@dataclass
class ServiceManagedEc2InstanceMarketOptions:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        return props


@dataclass
class VCpuCountRange:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min is not None:
            if hasattr(self.min, 'to_dict'):
                props['Min'] = self.min.to_dict()
            elif isinstance(self.min, list):
                props['Min'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min
                ]
            else:
                props['Min'] = self.min

        if self.max is not None:
            if hasattr(self.max, 'to_dict'):
                props['Max'] = self.max.to_dict()
            elif isinstance(self.max, list):
                props['Max'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max
                ]
            else:
                props['Max'] = self.max

        return props


@dataclass
class VpcConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_configuration_arns: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_configuration_arns is not None:
            if hasattr(self.resource_configuration_arns, 'to_dict'):
                props['ResourceConfigurationArns'] = self.resource_configuration_arns.to_dict()
            elif isinstance(self.resource_configuration_arns, list):
                props['ResourceConfigurationArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_configuration_arns
                ]
            else:
                props['ResourceConfigurationArns'] = self.resource_configuration_arns

        return props


@dataclass
class Fleet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-deadl"""

    resource_type: ClassVar[str] = "AWS::Deadline::Fleet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    configuration: Optional[FleetConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    host_configuration: Optional[HostConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_worker_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    min_worker_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    farm_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.configuration is not None:
            # Serialize configuration (handle intrinsic functions)
            if hasattr(self.configuration, 'to_dict'):
                props["Configuration"] = self.configuration.to_dict()
            elif isinstance(self.configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['Configuration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.configuration
                ]
            else:
                props["Configuration"] = self.configuration

        if self.host_configuration is not None:
            # Serialize host_configuration (handle intrinsic functions)
            if hasattr(self.host_configuration, 'to_dict'):
                props["HostConfiguration"] = self.host_configuration.to_dict()
            elif isinstance(self.host_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['HostConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.host_configuration
                ]
            else:
                props["HostConfiguration"] = self.host_configuration

        if self.max_worker_count is not None:
            # Serialize max_worker_count (handle intrinsic functions)
            if hasattr(self.max_worker_count, 'to_dict'):
                props["MaxWorkerCount"] = self.max_worker_count.to_dict()
            elif isinstance(self.max_worker_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxWorkerCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_worker_count
                ]
            else:
                props["MaxWorkerCount"] = self.max_worker_count

        if self.display_name is not None:
            # Serialize display_name (handle intrinsic functions)
            if hasattr(self.display_name, 'to_dict'):
                props["DisplayName"] = self.display_name.to_dict()
            elif isinstance(self.display_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.display_name
                ]
            else:
                props["DisplayName"] = self.display_name

        if self.min_worker_count is not None:
            # Serialize min_worker_count (handle intrinsic functions)
            if hasattr(self.min_worker_count, 'to_dict'):
                props["MinWorkerCount"] = self.min_worker_count.to_dict()
            elif isinstance(self.min_worker_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['MinWorkerCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_worker_count
                ]
            else:
                props["MinWorkerCount"] = self.min_worker_count

        if self.farm_id is not None:
            # Serialize farm_id (handle intrinsic functions)
            if hasattr(self.farm_id, 'to_dict'):
                props["FarmId"] = self.farm_id.to_dict()
            elif isinstance(self.farm_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['FarmId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.farm_id
                ]
            else:
                props["FarmId"] = self.farm_id

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_capabilities__amounts(self) -> GetAtt:
        """Get the Capabilities.Amounts attribute."""
        return self.get_att("Capabilities.Amounts")

    @property
    def attr_capabilities__attributes(self) -> GetAtt:
        """Get the Capabilities.Attributes attribute."""
        return self.get_att("Capabilities.Attributes")

    @property
    def attr_capabilities(self) -> GetAtt:
        """Get the Capabilities attribute."""
        return self.get_att("Capabilities")

    @property
    def attr_fleet_id(self) -> GetAtt:
        """Get the FleetId attribute."""
        return self.get_att("FleetId")

    @property
    def attr_worker_count(self) -> GetAtt:
        """Get the WorkerCount attribute."""
        return self.get_att("WorkerCount")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_status_message(self) -> GetAtt:
        """Get the StatusMessage attribute."""
        return self.get_att("StatusMessage")




@dataclass
class LicenseEndpoint(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-deadl"""

    resource_type: ClassVar[str] = "AWS::Deadline::LicenseEndpoint"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.security_group_ids is not None:
            # Serialize security_group_ids (handle intrinsic functions)
            if hasattr(self.security_group_ids, 'to_dict'):
                props["SecurityGroupIds"] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props["SecurityGroupIds"] = self.security_group_ids

        if self.subnet_ids is not None:
            # Serialize subnet_ids (handle intrinsic functions)
            if hasattr(self.subnet_ids, 'to_dict'):
                props["SubnetIds"] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props["SubnetIds"] = self.subnet_ids

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_dns_name(self) -> GetAtt:
        """Get the DnsName attribute."""
        return self.get_att("DnsName")

    @property
    def attr_license_endpoint_id(self) -> GetAtt:
        """Get the LicenseEndpointId attribute."""
        return self.get_att("LicenseEndpointId")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_status_message(self) -> GetAtt:
        """Get the StatusMessage attribute."""
        return self.get_att("StatusMessage")




@dataclass
class Limit(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-deadl"""

    resource_type: ClassVar[str] = "AWS::Deadline::Limit"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    amount_requirement_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    farm_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.amount_requirement_name is not None:
            # Serialize amount_requirement_name (handle intrinsic functions)
            if hasattr(self.amount_requirement_name, 'to_dict'):
                props["AmountRequirementName"] = self.amount_requirement_name.to_dict()
            elif isinstance(self.amount_requirement_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['AmountRequirementName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.amount_requirement_name
                ]
            else:
                props["AmountRequirementName"] = self.amount_requirement_name

        if self.display_name is not None:
            # Serialize display_name (handle intrinsic functions)
            if hasattr(self.display_name, 'to_dict'):
                props["DisplayName"] = self.display_name.to_dict()
            elif isinstance(self.display_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.display_name
                ]
            else:
                props["DisplayName"] = self.display_name

        if self.max_count is not None:
            # Serialize max_count (handle intrinsic functions)
            if hasattr(self.max_count, 'to_dict'):
                props["MaxCount"] = self.max_count.to_dict()
            elif isinstance(self.max_count, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_count
                ]
            else:
                props["MaxCount"] = self.max_count

        if self.farm_id is not None:
            # Serialize farm_id (handle intrinsic functions)
            if hasattr(self.farm_id, 'to_dict'):
                props["FarmId"] = self.farm_id.to_dict()
            elif isinstance(self.farm_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['FarmId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.farm_id
                ]
            else:
                props["FarmId"] = self.farm_id

        return props

    @property
    def attr_limit_id(self) -> GetAtt:
        """Get the LimitId attribute."""
        return self.get_att("LimitId")

    @property
    def attr_current_count(self) -> GetAtt:
        """Get the CurrentCount attribute."""
        return self.get_att("CurrentCount")




@dataclass
class MeteredProduct(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-deadl"""

    resource_type: ClassVar[str] = "AWS::Deadline::MeteredProduct"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    license_endpoint_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    product_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.license_endpoint_id is not None:
            # Serialize license_endpoint_id (handle intrinsic functions)
            if hasattr(self.license_endpoint_id, 'to_dict'):
                props["LicenseEndpointId"] = self.license_endpoint_id.to_dict()
            elif isinstance(self.license_endpoint_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LicenseEndpointId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.license_endpoint_id
                ]
            else:
                props["LicenseEndpointId"] = self.license_endpoint_id

        if self.product_id is not None:
            # Serialize product_id (handle intrinsic functions)
            if hasattr(self.product_id, 'to_dict'):
                props["ProductId"] = self.product_id.to_dict()
            elif isinstance(self.product_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProductId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.product_id
                ]
            else:
                props["ProductId"] = self.product_id

        return props

    @property
    def attr_port(self) -> GetAtt:
        """Get the Port attribute."""
        return self.get_att("Port")

    @property
    def attr_family(self) -> GetAtt:
        """Get the Family attribute."""
        return self.get_att("Family")

    @property
    def attr_vendor(self) -> GetAtt:
        """Get the Vendor attribute."""
        return self.get_att("Vendor")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class Monitor(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-deadl"""

    resource_type: ClassVar[str] = "AWS::Deadline::Monitor"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    identity_center_instance_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subdomain: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.identity_center_instance_arn is not None:
            # Serialize identity_center_instance_arn (handle intrinsic functions)
            if hasattr(self.identity_center_instance_arn, 'to_dict'):
                props["IdentityCenterInstanceArn"] = self.identity_center_instance_arn.to_dict()
            elif isinstance(self.identity_center_instance_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['IdentityCenterInstanceArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.identity_center_instance_arn
                ]
            else:
                props["IdentityCenterInstanceArn"] = self.identity_center_instance_arn

        if self.subdomain is not None:
            # Serialize subdomain (handle intrinsic functions)
            if hasattr(self.subdomain, 'to_dict'):
                props["Subdomain"] = self.subdomain.to_dict()
            elif isinstance(self.subdomain, list):
                # Serialize list items (may contain intrinsic functions)
                props['Subdomain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subdomain
                ]
            else:
                props["Subdomain"] = self.subdomain

        if self.display_name is not None:
            # Serialize display_name (handle intrinsic functions)
            if hasattr(self.display_name, 'to_dict'):
                props["DisplayName"] = self.display_name.to_dict()
            elif isinstance(self.display_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.display_name
                ]
            else:
                props["DisplayName"] = self.display_name

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_identity_center_application_arn(self) -> GetAtt:
        """Get the IdentityCenterApplicationArn attribute."""
        return self.get_att("IdentityCenterApplicationArn")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_monitor_id(self) -> GetAtt:
        """Get the MonitorId attribute."""
        return self.get_att("MonitorId")

    @property
    def attr_url(self) -> GetAtt:
        """Get the Url attribute."""
        return self.get_att("Url")




@dataclass
class JobAttachmentSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    root_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_bucket_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.root_prefix is not None:
            if hasattr(self.root_prefix, 'to_dict'):
                props['RootPrefix'] = self.root_prefix.to_dict()
            elif isinstance(self.root_prefix, list):
                props['RootPrefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.root_prefix
                ]
            else:
                props['RootPrefix'] = self.root_prefix

        if self.s3_bucket_name is not None:
            if hasattr(self.s3_bucket_name, 'to_dict'):
                props['S3BucketName'] = self.s3_bucket_name.to_dict()
            elif isinstance(self.s3_bucket_name, list):
                props['S3BucketName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_bucket_name
                ]
            else:
                props['S3BucketName'] = self.s3_bucket_name

        return props


@dataclass
class JobRunAsUser:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    run_as: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    posix: Optional[PosixUser] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    windows: Optional[WindowsUser] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.run_as is not None:
            if hasattr(self.run_as, 'to_dict'):
                props['RunAs'] = self.run_as.to_dict()
            elif isinstance(self.run_as, list):
                props['RunAs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.run_as
                ]
            else:
                props['RunAs'] = self.run_as

        if self.posix is not None:
            if hasattr(self.posix, 'to_dict'):
                props['Posix'] = self.posix.to_dict()
            elif isinstance(self.posix, list):
                props['Posix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.posix
                ]
            else:
                props['Posix'] = self.posix

        if self.windows is not None:
            if hasattr(self.windows, 'to_dict'):
                props['Windows'] = self.windows.to_dict()
            elif isinstance(self.windows, list):
                props['Windows'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.windows
                ]
            else:
                props['Windows'] = self.windows

        return props


@dataclass
class PosixUser:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.group is not None:
            if hasattr(self.group, 'to_dict'):
                props['Group'] = self.group.to_dict()
            elif isinstance(self.group, list):
                props['Group'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.group
                ]
            else:
                props['Group'] = self.group

        if self.user is not None:
            if hasattr(self.user, 'to_dict'):
                props['User'] = self.user.to_dict()
            elif isinstance(self.user, list):
                props['User'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user
                ]
            else:
                props['User'] = self.user

        return props


@dataclass
class WindowsUser:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    password_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.user is not None:
            if hasattr(self.user, 'to_dict'):
                props['User'] = self.user.to_dict()
            elif isinstance(self.user, list):
                props['User'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user
                ]
            else:
                props['User'] = self.user

        if self.password_arn is not None:
            if hasattr(self.password_arn, 'to_dict'):
                props['PasswordArn'] = self.password_arn.to_dict()
            elif isinstance(self.password_arn, list):
                props['PasswordArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.password_arn
                ]
            else:
                props['PasswordArn'] = self.password_arn

        return props


@dataclass
class Queue(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-deadl"""

    resource_type: ClassVar[str] = "AWS::Deadline::Queue"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    job_run_as_user: Optional[JobRunAsUser] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allowed_storage_profile_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    job_attachment_settings: Optional[JobAttachmentSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_budget_action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    required_file_system_location_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    farm_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.job_run_as_user is not None:
            # Serialize job_run_as_user (handle intrinsic functions)
            if hasattr(self.job_run_as_user, 'to_dict'):
                props["JobRunAsUser"] = self.job_run_as_user.to_dict()
            elif isinstance(self.job_run_as_user, list):
                # Serialize list items (may contain intrinsic functions)
                props['JobRunAsUser'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.job_run_as_user
                ]
            else:
                props["JobRunAsUser"] = self.job_run_as_user

        if self.allowed_storage_profile_ids is not None:
            # Serialize allowed_storage_profile_ids (handle intrinsic functions)
            if hasattr(self.allowed_storage_profile_ids, 'to_dict'):
                props["AllowedStorageProfileIds"] = self.allowed_storage_profile_ids.to_dict()
            elif isinstance(self.allowed_storage_profile_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllowedStorageProfileIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_storage_profile_ids
                ]
            else:
                props["AllowedStorageProfileIds"] = self.allowed_storage_profile_ids

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.job_attachment_settings is not None:
            # Serialize job_attachment_settings (handle intrinsic functions)
            if hasattr(self.job_attachment_settings, 'to_dict'):
                props["JobAttachmentSettings"] = self.job_attachment_settings.to_dict()
            elif isinstance(self.job_attachment_settings, list):
                # Serialize list items (may contain intrinsic functions)
                props['JobAttachmentSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.job_attachment_settings
                ]
            else:
                props["JobAttachmentSettings"] = self.job_attachment_settings

        if self.default_budget_action is not None:
            # Serialize default_budget_action (handle intrinsic functions)
            if hasattr(self.default_budget_action, 'to_dict'):
                props["DefaultBudgetAction"] = self.default_budget_action.to_dict()
            elif isinstance(self.default_budget_action, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultBudgetAction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_budget_action
                ]
            else:
                props["DefaultBudgetAction"] = self.default_budget_action

        if self.display_name is not None:
            # Serialize display_name (handle intrinsic functions)
            if hasattr(self.display_name, 'to_dict'):
                props["DisplayName"] = self.display_name.to_dict()
            elif isinstance(self.display_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.display_name
                ]
            else:
                props["DisplayName"] = self.display_name

        if self.required_file_system_location_names is not None:
            # Serialize required_file_system_location_names (handle intrinsic functions)
            if hasattr(self.required_file_system_location_names, 'to_dict'):
                props["RequiredFileSystemLocationNames"] = self.required_file_system_location_names.to_dict()
            elif isinstance(self.required_file_system_location_names, list):
                # Serialize list items (may contain intrinsic functions)
                props['RequiredFileSystemLocationNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.required_file_system_location_names
                ]
            else:
                props["RequiredFileSystemLocationNames"] = self.required_file_system_location_names

        if self.farm_id is not None:
            # Serialize farm_id (handle intrinsic functions)
            if hasattr(self.farm_id, 'to_dict'):
                props["FarmId"] = self.farm_id.to_dict()
            elif isinstance(self.farm_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['FarmId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.farm_id
                ]
            else:
                props["FarmId"] = self.farm_id

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_queue_id(self) -> GetAtt:
        """Get the QueueId attribute."""
        return self.get_att("QueueId")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class QueueEnvironment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-deadl"""

    resource_type: ClassVar[str] = "AWS::Deadline::QueueEnvironment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    priority: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    queue_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    template_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    farm_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    template: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.priority is not None:
            # Serialize priority (handle intrinsic functions)
            if hasattr(self.priority, 'to_dict'):
                props["Priority"] = self.priority.to_dict()
            elif isinstance(self.priority, list):
                # Serialize list items (may contain intrinsic functions)
                props['Priority'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.priority
                ]
            else:
                props["Priority"] = self.priority

        if self.queue_id is not None:
            # Serialize queue_id (handle intrinsic functions)
            if hasattr(self.queue_id, 'to_dict'):
                props["QueueId"] = self.queue_id.to_dict()
            elif isinstance(self.queue_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['QueueId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.queue_id
                ]
            else:
                props["QueueId"] = self.queue_id

        if self.template_type is not None:
            # Serialize template_type (handle intrinsic functions)
            if hasattr(self.template_type, 'to_dict'):
                props["TemplateType"] = self.template_type.to_dict()
            elif isinstance(self.template_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['TemplateType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.template_type
                ]
            else:
                props["TemplateType"] = self.template_type

        if self.farm_id is not None:
            # Serialize farm_id (handle intrinsic functions)
            if hasattr(self.farm_id, 'to_dict'):
                props["FarmId"] = self.farm_id.to_dict()
            elif isinstance(self.farm_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['FarmId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.farm_id
                ]
            else:
                props["FarmId"] = self.farm_id

        if self.template is not None:
            # Serialize template (handle intrinsic functions)
            if hasattr(self.template, 'to_dict'):
                props["Template"] = self.template.to_dict()
            elif isinstance(self.template, list):
                # Serialize list items (may contain intrinsic functions)
                props['Template'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.template
                ]
            else:
                props["Template"] = self.template

        return props

    @property
    def attr_queue_environment_id(self) -> GetAtt:
        """Get the QueueEnvironmentId attribute."""
        return self.get_att("QueueEnvironmentId")

    @property
    def attr_name(self) -> GetAtt:
        """Get the Name attribute."""
        return self.get_att("Name")




@dataclass
class QueueFleetAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-deadl"""

    resource_type: ClassVar[str] = "AWS::Deadline::QueueFleetAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    fleet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    queue_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    farm_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.fleet_id is not None:
            # Serialize fleet_id (handle intrinsic functions)
            if hasattr(self.fleet_id, 'to_dict'):
                props["FleetId"] = self.fleet_id.to_dict()
            elif isinstance(self.fleet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['FleetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.fleet_id
                ]
            else:
                props["FleetId"] = self.fleet_id

        if self.queue_id is not None:
            # Serialize queue_id (handle intrinsic functions)
            if hasattr(self.queue_id, 'to_dict'):
                props["QueueId"] = self.queue_id.to_dict()
            elif isinstance(self.queue_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['QueueId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.queue_id
                ]
            else:
                props["QueueId"] = self.queue_id

        if self.farm_id is not None:
            # Serialize farm_id (handle intrinsic functions)
            if hasattr(self.farm_id, 'to_dict'):
                props["FarmId"] = self.farm_id.to_dict()
            elif isinstance(self.farm_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['FarmId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.farm_id
                ]
            else:
                props["FarmId"] = self.farm_id

        return props



@dataclass
class QueueLimitAssociation(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-deadl"""

    resource_type: ClassVar[str] = "AWS::Deadline::QueueLimitAssociation"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    limit_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    queue_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    farm_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.limit_id is not None:
            # Serialize limit_id (handle intrinsic functions)
            if hasattr(self.limit_id, 'to_dict'):
                props["LimitId"] = self.limit_id.to_dict()
            elif isinstance(self.limit_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['LimitId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.limit_id
                ]
            else:
                props["LimitId"] = self.limit_id

        if self.queue_id is not None:
            # Serialize queue_id (handle intrinsic functions)
            if hasattr(self.queue_id, 'to_dict'):
                props["QueueId"] = self.queue_id.to_dict()
            elif isinstance(self.queue_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['QueueId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.queue_id
                ]
            else:
                props["QueueId"] = self.queue_id

        if self.farm_id is not None:
            # Serialize farm_id (handle intrinsic functions)
            if hasattr(self.farm_id, 'to_dict'):
                props["FarmId"] = self.farm_id.to_dict()
            elif isinstance(self.farm_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['FarmId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.farm_id
                ]
            else:
                props["FarmId"] = self.farm_id

        return props



@dataclass
class FileSystemLocation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dea"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.path is not None:
            if hasattr(self.path, 'to_dict'):
                props['Path'] = self.path.to_dict()
            elif isinstance(self.path, list):
                props['Path'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.path
                ]
            else:
                props['Path'] = self.path

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class StorageProfile(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-deadl"""

    resource_type: ClassVar[str] = "AWS::Deadline::StorageProfile"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    file_system_locations: Optional[list[FileSystemLocation]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    farm_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    os_family: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.display_name is not None:
            # Serialize display_name (handle intrinsic functions)
            if hasattr(self.display_name, 'to_dict'):
                props["DisplayName"] = self.display_name.to_dict()
            elif isinstance(self.display_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.display_name
                ]
            else:
                props["DisplayName"] = self.display_name

        if self.file_system_locations is not None:
            # Serialize file_system_locations (handle intrinsic functions)
            if hasattr(self.file_system_locations, 'to_dict'):
                props["FileSystemLocations"] = self.file_system_locations.to_dict()
            elif isinstance(self.file_system_locations, list):
                # Serialize list items (may contain intrinsic functions)
                props['FileSystemLocations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_locations
                ]
            else:
                props["FileSystemLocations"] = self.file_system_locations

        if self.farm_id is not None:
            # Serialize farm_id (handle intrinsic functions)
            if hasattr(self.farm_id, 'to_dict'):
                props["FarmId"] = self.farm_id.to_dict()
            elif isinstance(self.farm_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['FarmId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.farm_id
                ]
            else:
                props["FarmId"] = self.farm_id

        if self.os_family is not None:
            # Serialize os_family (handle intrinsic functions)
            if hasattr(self.os_family, 'to_dict'):
                props["OsFamily"] = self.os_family.to_dict()
            elif isinstance(self.os_family, list):
                # Serialize list items (may contain intrinsic functions)
                props['OsFamily'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.os_family
                ]
            else:
                props["OsFamily"] = self.os_family

        return props

    @property
    def attr_storage_profile_id(self) -> GetAtt:
        """Get the StorageProfileId attribute."""
        return self.get_att("StorageProfileId")



