"""
AWS CloudFormation WAF Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:39

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service WAF
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class ChangeAction:
    """ChangeAction enum values."""

    INSERT = "INSERT"
    DELETE = "DELETE"


class ChangeTokenStatus:
    """ChangeTokenStatus enum values."""

    PROVISIONED = "PROVISIONED"
    PENDING = "PENDING"
    INSYNC = "INSYNC"


class ComparisonOperator:
    """ComparisonOperator enum values."""

    EQ = "EQ"
    NE = "NE"
    LE = "LE"
    LT = "LT"
    GE = "GE"
    GT = "GT"


class GeoMatchConstraintType:
    """GeoMatchConstraintType enum values."""

    COUNTRY = "Country"


class GeoMatchConstraintValue:
    """GeoMatchConstraintValue enum values."""

    AF = "AF"
    AX = "AX"
    AL = "AL"
    DZ = "DZ"
    AS = "AS"
    AD = "AD"
    AO = "AO"
    AI = "AI"
    AQ = "AQ"
    AG = "AG"
    AR = "AR"
    AM = "AM"
    AW = "AW"
    AU = "AU"
    AT = "AT"
    AZ = "AZ"
    BS = "BS"
    BH = "BH"
    BD = "BD"
    BB = "BB"
    BY = "BY"
    BE = "BE"
    BZ = "BZ"
    BJ = "BJ"
    BM = "BM"
    BT = "BT"
    BO = "BO"
    BQ = "BQ"
    BA = "BA"
    BW = "BW"
    BV = "BV"
    BR = "BR"
    IO = "IO"
    BN = "BN"
    BG = "BG"
    BF = "BF"
    BI = "BI"
    KH = "KH"
    CM = "CM"
    CA = "CA"
    CV = "CV"
    KY = "KY"
    CF = "CF"
    TD = "TD"
    CL = "CL"
    CN = "CN"
    CX = "CX"
    CC = "CC"
    CO = "CO"
    KM = "KM"
    CG = "CG"
    CD = "CD"
    CK = "CK"
    CR = "CR"
    CI = "CI"
    HR = "HR"
    CU = "CU"
    CW = "CW"
    CY = "CY"
    CZ = "CZ"
    DK = "DK"
    DJ = "DJ"
    DM = "DM"
    DO = "DO"
    EC = "EC"
    EG = "EG"
    SV = "SV"
    GQ = "GQ"
    ER = "ER"
    EE = "EE"
    ET = "ET"
    FK = "FK"
    FO = "FO"
    FJ = "FJ"
    FI = "FI"
    FR = "FR"
    GF = "GF"
    PF = "PF"
    TF = "TF"
    GA = "GA"
    GM = "GM"
    GE = "GE"
    DE = "DE"
    GH = "GH"
    GI = "GI"
    GR = "GR"
    GL = "GL"
    GD = "GD"
    GP = "GP"
    GU = "GU"
    GT = "GT"
    GG = "GG"
    GN = "GN"
    GW = "GW"
    GY = "GY"
    HT = "HT"
    HM = "HM"
    VA = "VA"
    HN = "HN"
    HK = "HK"
    HU = "HU"
    IS = "IS"
    IN = "IN"
    ID = "ID"
    IR = "IR"
    IQ = "IQ"
    IE = "IE"
    IM = "IM"
    IL = "IL"
    IT = "IT"
    JM = "JM"
    JP = "JP"
    JE = "JE"
    JO = "JO"
    KZ = "KZ"
    KE = "KE"
    KI = "KI"
    KP = "KP"
    KR = "KR"
    KW = "KW"
    KG = "KG"
    LA = "LA"
    LV = "LV"
    LB = "LB"
    LS = "LS"
    LR = "LR"
    LY = "LY"
    LI = "LI"
    LT = "LT"
    LU = "LU"
    MO = "MO"
    MK = "MK"
    MG = "MG"
    MW = "MW"
    MY = "MY"
    MV = "MV"
    ML = "ML"
    MT = "MT"
    MH = "MH"
    MQ = "MQ"
    MR = "MR"
    MU = "MU"
    YT = "YT"
    MX = "MX"
    FM = "FM"
    MD = "MD"
    MC = "MC"
    MN = "MN"
    ME = "ME"
    MS = "MS"
    MA = "MA"
    MZ = "MZ"
    MM = "MM"
    NA = "NA"
    NR = "NR"
    NP = "NP"
    NL = "NL"
    NC = "NC"
    NZ = "NZ"
    NI = "NI"
    NE = "NE"
    NG = "NG"
    NU = "NU"
    NF = "NF"
    MP = "MP"
    NO = "NO"
    OM = "OM"
    PK = "PK"
    PW = "PW"
    PS = "PS"
    PA = "PA"
    PG = "PG"
    PY = "PY"
    PE = "PE"
    PH = "PH"
    PN = "PN"
    PL = "PL"
    PT = "PT"
    PR = "PR"
    QA = "QA"
    RE = "RE"
    RO = "RO"
    RU = "RU"
    RW = "RW"
    BL = "BL"
    SH = "SH"
    KN = "KN"
    LC = "LC"
    MF = "MF"
    PM = "PM"
    VC = "VC"
    WS = "WS"
    SM = "SM"
    ST = "ST"
    SA = "SA"
    SN = "SN"
    RS = "RS"
    SC = "SC"
    SL = "SL"
    SG = "SG"
    SX = "SX"
    SK = "SK"
    SI = "SI"
    SB = "SB"
    SO = "SO"
    ZA = "ZA"
    GS = "GS"
    SS = "SS"
    ES = "ES"
    LK = "LK"
    SD = "SD"
    SR = "SR"
    SJ = "SJ"
    SZ = "SZ"
    SE = "SE"
    CH = "CH"
    SY = "SY"
    TW = "TW"
    TJ = "TJ"
    TZ = "TZ"
    TH = "TH"
    TL = "TL"
    TG = "TG"
    TK = "TK"
    TO = "TO"
    TT = "TT"
    TN = "TN"
    TR = "TR"
    TM = "TM"
    TC = "TC"
    TV = "TV"
    UG = "UG"
    UA = "UA"
    AE = "AE"
    GB = "GB"
    US = "US"
    UM = "UM"
    UY = "UY"
    UZ = "UZ"
    VU = "VU"
    VE = "VE"
    VN = "VN"
    VG = "VG"
    VI = "VI"
    WF = "WF"
    EH = "EH"
    YE = "YE"
    ZM = "ZM"
    ZW = "ZW"


class IPSetDescriptorType:
    """IPSetDescriptorType enum values."""

    IPV4 = "IPV4"
    IPV6 = "IPV6"


class MatchFieldType:
    """MatchFieldType enum values."""

    URI = "URI"
    QUERY_STRING = "QUERY_STRING"
    HEADER = "HEADER"
    METHOD = "METHOD"
    BODY = "BODY"
    SINGLE_QUERY_ARG = "SINGLE_QUERY_ARG"
    ALL_QUERY_ARGS = "ALL_QUERY_ARGS"


class MigrationErrorType:
    """MigrationErrorType enum values."""

    ENTITY_NOT_SUPPORTED = "ENTITY_NOT_SUPPORTED"
    ENTITY_NOT_FOUND = "ENTITY_NOT_FOUND"
    S3_BUCKET_NO_PERMISSION = "S3_BUCKET_NO_PERMISSION"
    S3_BUCKET_NOT_ACCESSIBLE = "S3_BUCKET_NOT_ACCESSIBLE"
    S3_BUCKET_NOT_FOUND = "S3_BUCKET_NOT_FOUND"
    S3_BUCKET_INVALID_REGION = "S3_BUCKET_INVALID_REGION"
    S3_INTERNAL_ERROR = "S3_INTERNAL_ERROR"


class ParameterExceptionField:
    """ParameterExceptionField enum values."""

    CHANGE_ACTION = "CHANGE_ACTION"
    WAF_ACTION = "WAF_ACTION"
    WAF_OVERRIDE_ACTION = "WAF_OVERRIDE_ACTION"
    PREDICATE_TYPE = "PREDICATE_TYPE"
    IPSET_TYPE = "IPSET_TYPE"
    BYTE_MATCH_FIELD_TYPE = "BYTE_MATCH_FIELD_TYPE"
    SQL_INJECTION_MATCH_FIELD_TYPE = "SQL_INJECTION_MATCH_FIELD_TYPE"
    BYTE_MATCH_TEXT_TRANSFORMATION = "BYTE_MATCH_TEXT_TRANSFORMATION"
    BYTE_MATCH_POSITIONAL_CONSTRAINT = "BYTE_MATCH_POSITIONAL_CONSTRAINT"
    SIZE_CONSTRAINT_COMPARISON_OPERATOR = "SIZE_CONSTRAINT_COMPARISON_OPERATOR"
    GEO_MATCH_LOCATION_TYPE = "GEO_MATCH_LOCATION_TYPE"
    GEO_MATCH_LOCATION_VALUE = "GEO_MATCH_LOCATION_VALUE"
    RATE_KEY = "RATE_KEY"
    RULE_TYPE = "RULE_TYPE"
    NEXT_MARKER = "NEXT_MARKER"
    RESOURCE_ARN = "RESOURCE_ARN"
    TAGS = "TAGS"
    TAG_KEYS = "TAG_KEYS"


class ParameterExceptionReason:
    """ParameterExceptionReason enum values."""

    INVALID_OPTION = "INVALID_OPTION"
    ILLEGAL_COMBINATION = "ILLEGAL_COMBINATION"
    ILLEGAL_ARGUMENT = "ILLEGAL_ARGUMENT"
    INVALID_TAG_KEY = "INVALID_TAG_KEY"


class PositionalConstraint:
    """PositionalConstraint enum values."""

    EXACTLY = "EXACTLY"
    STARTS_WITH = "STARTS_WITH"
    ENDS_WITH = "ENDS_WITH"
    CONTAINS = "CONTAINS"
    CONTAINS_WORD = "CONTAINS_WORD"


class PredicateType:
    """PredicateType enum values."""

    IPMATCH = "IPMatch"
    BYTEMATCH = "ByteMatch"
    SQLINJECTIONMATCH = "SqlInjectionMatch"
    GEOMATCH = "GeoMatch"
    SIZECONSTRAINT = "SizeConstraint"
    XSSMATCH = "XssMatch"
    REGEXMATCH = "RegexMatch"


class RateKey:
    """RateKey enum values."""

    IP = "IP"


class TextTransformation:
    """TextTransformation enum values."""

    NONE = "NONE"
    COMPRESS_WHITE_SPACE = "COMPRESS_WHITE_SPACE"
    HTML_ENTITY_DECODE = "HTML_ENTITY_DECODE"
    LOWERCASE = "LOWERCASE"
    CMD_LINE = "CMD_LINE"
    URL_DECODE = "URL_DECODE"


class WafActionType:
    """WafActionType enum values."""

    BLOCK = "BLOCK"
    ALLOW = "ALLOW"
    COUNT = "COUNT"


class WafOverrideActionType:
    """WafOverrideActionType enum values."""

    NONE = "NONE"
    COUNT = "COUNT"


class WafRuleType:
    """WafRuleType enum values."""

    REGULAR = "REGULAR"
    RATE_BASED = "RATE_BASED"
    GROUP = "GROUP"


# Convenient aliases for enum values
INSERT = ChangeAction.INSERT
DELETE = ChangeAction.DELETE
PROVISIONED = ChangeTokenStatus.PROVISIONED
PENDING = ChangeTokenStatus.PENDING
INSYNC = ChangeTokenStatus.INSYNC
EQ = ComparisonOperator.EQ
NE = ComparisonOperator.NE
LE = ComparisonOperator.LE
LT = ComparisonOperator.LT
GE = ComparisonOperator.GE
GT = ComparisonOperator.GT
COUNTRY = GeoMatchConstraintType.COUNTRY
AF = GeoMatchConstraintValue.AF
AX = GeoMatchConstraintValue.AX
AL = GeoMatchConstraintValue.AL
DZ = GeoMatchConstraintValue.DZ
AS = GeoMatchConstraintValue.AS
AD = GeoMatchConstraintValue.AD
AO = GeoMatchConstraintValue.AO
AI = GeoMatchConstraintValue.AI
AQ = GeoMatchConstraintValue.AQ
AG = GeoMatchConstraintValue.AG
AR = GeoMatchConstraintValue.AR
AM = GeoMatchConstraintValue.AM
AW = GeoMatchConstraintValue.AW
AU = GeoMatchConstraintValue.AU
AT = GeoMatchConstraintValue.AT
AZ = GeoMatchConstraintValue.AZ
BS = GeoMatchConstraintValue.BS
BH = GeoMatchConstraintValue.BH
BD = GeoMatchConstraintValue.BD
BB = GeoMatchConstraintValue.BB
BY = GeoMatchConstraintValue.BY
BE = GeoMatchConstraintValue.BE
BZ = GeoMatchConstraintValue.BZ
BJ = GeoMatchConstraintValue.BJ
BM = GeoMatchConstraintValue.BM
BT = GeoMatchConstraintValue.BT
BO = GeoMatchConstraintValue.BO
BQ = GeoMatchConstraintValue.BQ
BA = GeoMatchConstraintValue.BA
BW = GeoMatchConstraintValue.BW
BV = GeoMatchConstraintValue.BV
BR = GeoMatchConstraintValue.BR
IO = GeoMatchConstraintValue.IO
BN = GeoMatchConstraintValue.BN
BG = GeoMatchConstraintValue.BG
BF = GeoMatchConstraintValue.BF
BI = GeoMatchConstraintValue.BI
KH = GeoMatchConstraintValue.KH
CM = GeoMatchConstraintValue.CM
CA = GeoMatchConstraintValue.CA
CV = GeoMatchConstraintValue.CV
KY = GeoMatchConstraintValue.KY
CF = GeoMatchConstraintValue.CF
TD = GeoMatchConstraintValue.TD
CL = GeoMatchConstraintValue.CL
CN = GeoMatchConstraintValue.CN
CX = GeoMatchConstraintValue.CX
CC = GeoMatchConstraintValue.CC
CO = GeoMatchConstraintValue.CO
KM = GeoMatchConstraintValue.KM
CG = GeoMatchConstraintValue.CG
CD = GeoMatchConstraintValue.CD
CK = GeoMatchConstraintValue.CK
CR = GeoMatchConstraintValue.CR
CI = GeoMatchConstraintValue.CI
HR = GeoMatchConstraintValue.HR
CU = GeoMatchConstraintValue.CU
CW = GeoMatchConstraintValue.CW
CY = GeoMatchConstraintValue.CY
CZ = GeoMatchConstraintValue.CZ
DK = GeoMatchConstraintValue.DK
DJ = GeoMatchConstraintValue.DJ
DM = GeoMatchConstraintValue.DM
DO = GeoMatchConstraintValue.DO
EC = GeoMatchConstraintValue.EC
EG = GeoMatchConstraintValue.EG
SV = GeoMatchConstraintValue.SV
GQ = GeoMatchConstraintValue.GQ
ER = GeoMatchConstraintValue.ER
EE = GeoMatchConstraintValue.EE
ET = GeoMatchConstraintValue.ET
FK = GeoMatchConstraintValue.FK
FO = GeoMatchConstraintValue.FO
FJ = GeoMatchConstraintValue.FJ
FI = GeoMatchConstraintValue.FI
FR = GeoMatchConstraintValue.FR
GF = GeoMatchConstraintValue.GF
PF = GeoMatchConstraintValue.PF
TF = GeoMatchConstraintValue.TF
GA = GeoMatchConstraintValue.GA
GM = GeoMatchConstraintValue.GM
GE = GeoMatchConstraintValue.GE
DE = GeoMatchConstraintValue.DE
GH = GeoMatchConstraintValue.GH
GI = GeoMatchConstraintValue.GI
GR = GeoMatchConstraintValue.GR
GL = GeoMatchConstraintValue.GL
GD = GeoMatchConstraintValue.GD
GP = GeoMatchConstraintValue.GP
GU = GeoMatchConstraintValue.GU
GT = GeoMatchConstraintValue.GT
GG = GeoMatchConstraintValue.GG
GN = GeoMatchConstraintValue.GN
GW = GeoMatchConstraintValue.GW
GY = GeoMatchConstraintValue.GY
HT = GeoMatchConstraintValue.HT
HM = GeoMatchConstraintValue.HM
VA = GeoMatchConstraintValue.VA
HN = GeoMatchConstraintValue.HN
HK = GeoMatchConstraintValue.HK
HU = GeoMatchConstraintValue.HU
IS = GeoMatchConstraintValue.IS
IN = GeoMatchConstraintValue.IN
ID = GeoMatchConstraintValue.ID
IR = GeoMatchConstraintValue.IR
IQ = GeoMatchConstraintValue.IQ
IE = GeoMatchConstraintValue.IE
IM = GeoMatchConstraintValue.IM
IL = GeoMatchConstraintValue.IL
IT = GeoMatchConstraintValue.IT
JM = GeoMatchConstraintValue.JM
JP = GeoMatchConstraintValue.JP
JE = GeoMatchConstraintValue.JE
JO = GeoMatchConstraintValue.JO
KZ = GeoMatchConstraintValue.KZ
KE = GeoMatchConstraintValue.KE
KI = GeoMatchConstraintValue.KI
KP = GeoMatchConstraintValue.KP
KR = GeoMatchConstraintValue.KR
KW = GeoMatchConstraintValue.KW
KG = GeoMatchConstraintValue.KG
LA = GeoMatchConstraintValue.LA
LV = GeoMatchConstraintValue.LV
LB = GeoMatchConstraintValue.LB
LS = GeoMatchConstraintValue.LS
LR = GeoMatchConstraintValue.LR
LY = GeoMatchConstraintValue.LY
LI = GeoMatchConstraintValue.LI
LT = GeoMatchConstraintValue.LT
LU = GeoMatchConstraintValue.LU
MO = GeoMatchConstraintValue.MO
MK = GeoMatchConstraintValue.MK
MG = GeoMatchConstraintValue.MG
MW = GeoMatchConstraintValue.MW
MY = GeoMatchConstraintValue.MY
MV = GeoMatchConstraintValue.MV
ML = GeoMatchConstraintValue.ML
MT = GeoMatchConstraintValue.MT
MH = GeoMatchConstraintValue.MH
MQ = GeoMatchConstraintValue.MQ
MR = GeoMatchConstraintValue.MR
MU = GeoMatchConstraintValue.MU
YT = GeoMatchConstraintValue.YT
MX = GeoMatchConstraintValue.MX
FM = GeoMatchConstraintValue.FM
MD = GeoMatchConstraintValue.MD
MC = GeoMatchConstraintValue.MC
MN = GeoMatchConstraintValue.MN
ME = GeoMatchConstraintValue.ME
MS = GeoMatchConstraintValue.MS
MA = GeoMatchConstraintValue.MA
MZ = GeoMatchConstraintValue.MZ
MM = GeoMatchConstraintValue.MM
NA = GeoMatchConstraintValue.NA
NR = GeoMatchConstraintValue.NR
NP = GeoMatchConstraintValue.NP
NL = GeoMatchConstraintValue.NL
NC = GeoMatchConstraintValue.NC
NZ = GeoMatchConstraintValue.NZ
NI = GeoMatchConstraintValue.NI
NE = GeoMatchConstraintValue.NE
NG = GeoMatchConstraintValue.NG
NU = GeoMatchConstraintValue.NU
NF = GeoMatchConstraintValue.NF
MP = GeoMatchConstraintValue.MP
NO = GeoMatchConstraintValue.NO
OM = GeoMatchConstraintValue.OM
PK = GeoMatchConstraintValue.PK
PW = GeoMatchConstraintValue.PW
PS = GeoMatchConstraintValue.PS
PA = GeoMatchConstraintValue.PA
PG = GeoMatchConstraintValue.PG
PY = GeoMatchConstraintValue.PY
PE = GeoMatchConstraintValue.PE
PH = GeoMatchConstraintValue.PH
PN = GeoMatchConstraintValue.PN
PL = GeoMatchConstraintValue.PL
PT = GeoMatchConstraintValue.PT
PR = GeoMatchConstraintValue.PR
QA = GeoMatchConstraintValue.QA
RE = GeoMatchConstraintValue.RE
RO = GeoMatchConstraintValue.RO
RU = GeoMatchConstraintValue.RU
RW = GeoMatchConstraintValue.RW
BL = GeoMatchConstraintValue.BL
SH = GeoMatchConstraintValue.SH
KN = GeoMatchConstraintValue.KN
LC = GeoMatchConstraintValue.LC
MF = GeoMatchConstraintValue.MF
PM = GeoMatchConstraintValue.PM
VC = GeoMatchConstraintValue.VC
WS = GeoMatchConstraintValue.WS
SM = GeoMatchConstraintValue.SM
ST = GeoMatchConstraintValue.ST
SA = GeoMatchConstraintValue.SA
SN = GeoMatchConstraintValue.SN
RS = GeoMatchConstraintValue.RS
SC = GeoMatchConstraintValue.SC
SL = GeoMatchConstraintValue.SL
SG = GeoMatchConstraintValue.SG
SX = GeoMatchConstraintValue.SX
SK = GeoMatchConstraintValue.SK
SI = GeoMatchConstraintValue.SI
SB = GeoMatchConstraintValue.SB
SO = GeoMatchConstraintValue.SO
ZA = GeoMatchConstraintValue.ZA
GS = GeoMatchConstraintValue.GS
SS = GeoMatchConstraintValue.SS
ES = GeoMatchConstraintValue.ES
LK = GeoMatchConstraintValue.LK
SD = GeoMatchConstraintValue.SD
SR = GeoMatchConstraintValue.SR
SJ = GeoMatchConstraintValue.SJ
SZ = GeoMatchConstraintValue.SZ
SE = GeoMatchConstraintValue.SE
CH = GeoMatchConstraintValue.CH
SY = GeoMatchConstraintValue.SY
TW = GeoMatchConstraintValue.TW
TJ = GeoMatchConstraintValue.TJ
TZ = GeoMatchConstraintValue.TZ
TH = GeoMatchConstraintValue.TH
TL = GeoMatchConstraintValue.TL
TG = GeoMatchConstraintValue.TG
TK = GeoMatchConstraintValue.TK
TO = GeoMatchConstraintValue.TO
TT = GeoMatchConstraintValue.TT
TN = GeoMatchConstraintValue.TN
TR = GeoMatchConstraintValue.TR
TM = GeoMatchConstraintValue.TM
TC = GeoMatchConstraintValue.TC
TV = GeoMatchConstraintValue.TV
UG = GeoMatchConstraintValue.UG
UA = GeoMatchConstraintValue.UA
AE = GeoMatchConstraintValue.AE
GB = GeoMatchConstraintValue.GB
US = GeoMatchConstraintValue.US
UM = GeoMatchConstraintValue.UM
UY = GeoMatchConstraintValue.UY
UZ = GeoMatchConstraintValue.UZ
VU = GeoMatchConstraintValue.VU
VE = GeoMatchConstraintValue.VE
VN = GeoMatchConstraintValue.VN
VG = GeoMatchConstraintValue.VG
VI = GeoMatchConstraintValue.VI
WF = GeoMatchConstraintValue.WF
EH = GeoMatchConstraintValue.EH
YE = GeoMatchConstraintValue.YE
ZM = GeoMatchConstraintValue.ZM
ZW = GeoMatchConstraintValue.ZW
IPV4 = IPSetDescriptorType.IPV4
IPV6 = IPSetDescriptorType.IPV6
URI = MatchFieldType.URI
QUERY_STRING = MatchFieldType.QUERY_STRING
HEADER = MatchFieldType.HEADER
METHOD = MatchFieldType.METHOD
BODY = MatchFieldType.BODY
SINGLE_QUERY_ARG = MatchFieldType.SINGLE_QUERY_ARG
ALL_QUERY_ARGS = MatchFieldType.ALL_QUERY_ARGS
ENTITY_NOT_SUPPORTED = MigrationErrorType.ENTITY_NOT_SUPPORTED
ENTITY_NOT_FOUND = MigrationErrorType.ENTITY_NOT_FOUND
S3_BUCKET_NO_PERMISSION = MigrationErrorType.S3_BUCKET_NO_PERMISSION
S3_BUCKET_NOT_ACCESSIBLE = MigrationErrorType.S3_BUCKET_NOT_ACCESSIBLE
S3_BUCKET_NOT_FOUND = MigrationErrorType.S3_BUCKET_NOT_FOUND
S3_BUCKET_INVALID_REGION = MigrationErrorType.S3_BUCKET_INVALID_REGION
S3_INTERNAL_ERROR = MigrationErrorType.S3_INTERNAL_ERROR
CHANGE_ACTION = ParameterExceptionField.CHANGE_ACTION
WAF_ACTION = ParameterExceptionField.WAF_ACTION
WAF_OVERRIDE_ACTION = ParameterExceptionField.WAF_OVERRIDE_ACTION
PREDICATE_TYPE = ParameterExceptionField.PREDICATE_TYPE
IPSET_TYPE = ParameterExceptionField.IPSET_TYPE
BYTE_MATCH_FIELD_TYPE = ParameterExceptionField.BYTE_MATCH_FIELD_TYPE
SQL_INJECTION_MATCH_FIELD_TYPE = ParameterExceptionField.SQL_INJECTION_MATCH_FIELD_TYPE
BYTE_MATCH_TEXT_TRANSFORMATION = ParameterExceptionField.BYTE_MATCH_TEXT_TRANSFORMATION
BYTE_MATCH_POSITIONAL_CONSTRAINT = ParameterExceptionField.BYTE_MATCH_POSITIONAL_CONSTRAINT
SIZE_CONSTRAINT_COMPARISON_OPERATOR = ParameterExceptionField.SIZE_CONSTRAINT_COMPARISON_OPERATOR
GEO_MATCH_LOCATION_TYPE = ParameterExceptionField.GEO_MATCH_LOCATION_TYPE
GEO_MATCH_LOCATION_VALUE = ParameterExceptionField.GEO_MATCH_LOCATION_VALUE
RATE_KEY = ParameterExceptionField.RATE_KEY
RULE_TYPE = ParameterExceptionField.RULE_TYPE
NEXT_MARKER = ParameterExceptionField.NEXT_MARKER
RESOURCE_ARN = ParameterExceptionField.RESOURCE_ARN
TAGS = ParameterExceptionField.TAGS
TAG_KEYS = ParameterExceptionField.TAG_KEYS
INVALID_OPTION = ParameterExceptionReason.INVALID_OPTION
ILLEGAL_COMBINATION = ParameterExceptionReason.ILLEGAL_COMBINATION
ILLEGAL_ARGUMENT = ParameterExceptionReason.ILLEGAL_ARGUMENT
INVALID_TAG_KEY = ParameterExceptionReason.INVALID_TAG_KEY
EXACTLY = PositionalConstraint.EXACTLY
STARTS_WITH = PositionalConstraint.STARTS_WITH
ENDS_WITH = PositionalConstraint.ENDS_WITH
CONTAINS = PositionalConstraint.CONTAINS
CONTAINS_WORD = PositionalConstraint.CONTAINS_WORD
IPMATCH = PredicateType.IPMATCH
BYTEMATCH = PredicateType.BYTEMATCH
SQLINJECTIONMATCH = PredicateType.SQLINJECTIONMATCH
GEOMATCH = PredicateType.GEOMATCH
SIZECONSTRAINT = PredicateType.SIZECONSTRAINT
XSSMATCH = PredicateType.XSSMATCH
REGEXMATCH = PredicateType.REGEXMATCH
IP = RateKey.IP
NONE = TextTransformation.NONE
COMPRESS_WHITE_SPACE = TextTransformation.COMPRESS_WHITE_SPACE
HTML_ENTITY_DECODE = TextTransformation.HTML_ENTITY_DECODE
LOWERCASE = TextTransformation.LOWERCASE
CMD_LINE = TextTransformation.CMD_LINE
URL_DECODE = TextTransformation.URL_DECODE
BLOCK = WafActionType.BLOCK
ALLOW = WafActionType.ALLOW
COUNT = WafActionType.COUNT
NONE = WafOverrideActionType.NONE
COUNT = WafOverrideActionType.COUNT
REGULAR = WafRuleType.REGULAR
RATE_BASED = WafRuleType.RATE_BASED
GROUP = WafRuleType.GROUP


@dataclass
class ByteMatchTuple:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-waf"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    field_to_match: Optional[FieldToMatch] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    positional_constraint: Optional[Union[str, PositionalConstraint, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_string: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    target_string_base64: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    text_transformation: Optional[Union[str, TextTransformation, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.field_to_match is not None:
            if hasattr(self.field_to_match, 'to_dict'):
                props['FieldToMatch'] = self.field_to_match.to_dict()
            elif isinstance(self.field_to_match, list):
                props['FieldToMatch'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.field_to_match
                ]
            else:
                props['FieldToMatch'] = self.field_to_match

        if self.positional_constraint is not None:
            if hasattr(self.positional_constraint, 'to_dict'):
                props['PositionalConstraint'] = self.positional_constraint.to_dict()
            elif isinstance(self.positional_constraint, list):
                props['PositionalConstraint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.positional_constraint
                ]
            else:
                props['PositionalConstraint'] = self.positional_constraint

        if self.target_string is not None:
            if hasattr(self.target_string, 'to_dict'):
                props['TargetString'] = self.target_string.to_dict()
            elif isinstance(self.target_string, list):
                props['TargetString'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_string
                ]
            else:
                props['TargetString'] = self.target_string

        if self.target_string_base64 is not None:
            if hasattr(self.target_string_base64, 'to_dict'):
                props['TargetStringBase64'] = self.target_string_base64.to_dict()
            elif isinstance(self.target_string_base64, list):
                props['TargetStringBase64'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_string_base64
                ]
            else:
                props['TargetStringBase64'] = self.target_string_base64

        if self.text_transformation is not None:
            if hasattr(self.text_transformation, 'to_dict'):
                props['TextTransformation'] = self.text_transformation.to_dict()
            elif isinstance(self.text_transformation, list):
                props['TextTransformation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.text_transformation
                ]
            else:
                props['TextTransformation'] = self.text_transformation

        return props


@dataclass
class FieldToMatch:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-waf"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, MatchFieldType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.data is not None:
            if hasattr(self.data, 'to_dict'):
                props['Data'] = self.data.to_dict()
            elif isinstance(self.data, list):
                props['Data'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data
                ]
            else:
                props['Data'] = self.data

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        return props


@dataclass
class ByteMatchSet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-waf-b"""

    resource_type: ClassVar[str] = "AWS::WAF::ByteMatchSet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    byte_match_tuples: Optional[list[ByteMatchTuple]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.byte_match_tuples is not None:
            # Serialize byte_match_tuples (handle intrinsic functions)
            if hasattr(self.byte_match_tuples, 'to_dict'):
                props["ByteMatchTuples"] = self.byte_match_tuples.to_dict()
            elif isinstance(self.byte_match_tuples, list):
                # Serialize list items (may contain intrinsic functions)
                props['ByteMatchTuples'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.byte_match_tuples
                ]
            else:
                props["ByteMatchTuples"] = self.byte_match_tuples

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props



@dataclass
class IPSetDescriptor:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-waf"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, IPSetDescriptorType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class IPSet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-waf-i"""

    resource_type: ClassVar[str] = "AWS::WAF::IPSet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ip_set_descriptors: Optional[list[IPSetDescriptor]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ip_set_descriptors is not None:
            # Serialize ip_set_descriptors (handle intrinsic functions)
            if hasattr(self.ip_set_descriptors, 'to_dict'):
                props["IPSetDescriptors"] = self.ip_set_descriptors.to_dict()
            elif isinstance(self.ip_set_descriptors, list):
                # Serialize list items (may contain intrinsic functions)
                props['IPSetDescriptors'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_set_descriptors
                ]
            else:
                props["IPSetDescriptors"] = self.ip_set_descriptors

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props



@dataclass
class Predicate:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-waf"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    negated: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, PredicateType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.data_id is not None:
            if hasattr(self.data_id, 'to_dict'):
                props['DataId'] = self.data_id.to_dict()
            elif isinstance(self.data_id, list):
                props['DataId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_id
                ]
            else:
                props['DataId'] = self.data_id

        if self.negated is not None:
            if hasattr(self.negated, 'to_dict'):
                props['Negated'] = self.negated.to_dict()
            elif isinstance(self.negated, list):
                props['Negated'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.negated
                ]
            else:
                props['Negated'] = self.negated

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        return props


@dataclass
class Rule(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-waf-r"""

    resource_type: ClassVar[str] = "AWS::WAF::Rule"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metric_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    predicates: Optional[list[Predicate]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.metric_name is not None:
            # Serialize metric_name (handle intrinsic functions)
            if hasattr(self.metric_name, 'to_dict'):
                props["MetricName"] = self.metric_name.to_dict()
            elif isinstance(self.metric_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['MetricName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_name
                ]
            else:
                props["MetricName"] = self.metric_name

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.predicates is not None:
            # Serialize predicates (handle intrinsic functions)
            if hasattr(self.predicates, 'to_dict'):
                props["Predicates"] = self.predicates.to_dict()
            elif isinstance(self.predicates, list):
                # Serialize list items (may contain intrinsic functions)
                props['Predicates'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.predicates
                ]
            else:
                props["Predicates"] = self.predicates

        return props



@dataclass
class FieldToMatch:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-waf"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, MatchFieldType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.data is not None:
            if hasattr(self.data, 'to_dict'):
                props['Data'] = self.data.to_dict()
            elif isinstance(self.data, list):
                props['Data'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data
                ]
            else:
                props['Data'] = self.data

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        return props


@dataclass
class SizeConstraint:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-waf"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    comparison_operator: Optional[Union[str, ComparisonOperator, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    field_to_match: Optional[FieldToMatch] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    size: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    text_transformation: Optional[Union[str, TextTransformation, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.comparison_operator is not None:
            if hasattr(self.comparison_operator, 'to_dict'):
                props['ComparisonOperator'] = self.comparison_operator.to_dict()
            elif isinstance(self.comparison_operator, list):
                props['ComparisonOperator'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.comparison_operator
                ]
            else:
                props['ComparisonOperator'] = self.comparison_operator

        if self.field_to_match is not None:
            if hasattr(self.field_to_match, 'to_dict'):
                props['FieldToMatch'] = self.field_to_match.to_dict()
            elif isinstance(self.field_to_match, list):
                props['FieldToMatch'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.field_to_match
                ]
            else:
                props['FieldToMatch'] = self.field_to_match

        if self.size is not None:
            if hasattr(self.size, 'to_dict'):
                props['Size'] = self.size.to_dict()
            elif isinstance(self.size, list):
                props['Size'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.size
                ]
            else:
                props['Size'] = self.size

        if self.text_transformation is not None:
            if hasattr(self.text_transformation, 'to_dict'):
                props['TextTransformation'] = self.text_transformation.to_dict()
            elif isinstance(self.text_transformation, list):
                props['TextTransformation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.text_transformation
                ]
            else:
                props['TextTransformation'] = self.text_transformation

        return props


@dataclass
class SizeConstraintSet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-waf-s"""

    resource_type: ClassVar[str] = "AWS::WAF::SizeConstraintSet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    size_constraints: Optional[list[SizeConstraint]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.size_constraints is not None:
            # Serialize size_constraints (handle intrinsic functions)
            if hasattr(self.size_constraints, 'to_dict'):
                props["SizeConstraints"] = self.size_constraints.to_dict()
            elif isinstance(self.size_constraints, list):
                # Serialize list items (may contain intrinsic functions)
                props['SizeConstraints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.size_constraints
                ]
            else:
                props["SizeConstraints"] = self.size_constraints

        return props



@dataclass
class FieldToMatch:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-waf"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, MatchFieldType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.data is not None:
            if hasattr(self.data, 'to_dict'):
                props['Data'] = self.data.to_dict()
            elif isinstance(self.data, list):
                props['Data'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data
                ]
            else:
                props['Data'] = self.data

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        return props


@dataclass
class SqlInjectionMatchTuple:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-waf"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    field_to_match: Optional[FieldToMatch] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    text_transformation: Optional[Union[str, TextTransformation, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.field_to_match is not None:
            if hasattr(self.field_to_match, 'to_dict'):
                props['FieldToMatch'] = self.field_to_match.to_dict()
            elif isinstance(self.field_to_match, list):
                props['FieldToMatch'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.field_to_match
                ]
            else:
                props['FieldToMatch'] = self.field_to_match

        if self.text_transformation is not None:
            if hasattr(self.text_transformation, 'to_dict'):
                props['TextTransformation'] = self.text_transformation.to_dict()
            elif isinstance(self.text_transformation, list):
                props['TextTransformation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.text_transformation
                ]
            else:
                props['TextTransformation'] = self.text_transformation

        return props


@dataclass
class SqlInjectionMatchSet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-waf-s"""

    resource_type: ClassVar[str] = "AWS::WAF::SqlInjectionMatchSet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sql_injection_match_tuples: Optional[list[SqlInjectionMatchTuple]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.sql_injection_match_tuples is not None:
            # Serialize sql_injection_match_tuples (handle intrinsic functions)
            if hasattr(self.sql_injection_match_tuples, 'to_dict'):
                props["SqlInjectionMatchTuples"] = self.sql_injection_match_tuples.to_dict()
            elif isinstance(self.sql_injection_match_tuples, list):
                # Serialize list items (may contain intrinsic functions)
                props['SqlInjectionMatchTuples'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sql_injection_match_tuples
                ]
            else:
                props["SqlInjectionMatchTuples"] = self.sql_injection_match_tuples

        return props



@dataclass
class ActivatedRule:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-waf"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    action: Optional[WafAction] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    priority: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.action is not None:
            if hasattr(self.action, 'to_dict'):
                props['Action'] = self.action.to_dict()
            elif isinstance(self.action, list):
                props['Action'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.action
                ]
            else:
                props['Action'] = self.action

        if self.priority is not None:
            if hasattr(self.priority, 'to_dict'):
                props['Priority'] = self.priority.to_dict()
            elif isinstance(self.priority, list):
                props['Priority'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.priority
                ]
            else:
                props['Priority'] = self.priority

        if self.rule_id is not None:
            if hasattr(self.rule_id, 'to_dict'):
                props['RuleId'] = self.rule_id.to_dict()
            elif isinstance(self.rule_id, list):
                props['RuleId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_id
                ]
            else:
                props['RuleId'] = self.rule_id

        return props


@dataclass
class WafAction:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-waf"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, WafActionType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        return props


@dataclass
class WebACL(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-waf-w"""

    resource_type: ClassVar[str] = "AWS::WAF::WebACL"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_action: Optional[WafAction] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metric_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rules: Optional[list[ActivatedRule]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_action is not None:
            # Serialize default_action (handle intrinsic functions)
            if hasattr(self.default_action, 'to_dict'):
                props["DefaultAction"] = self.default_action.to_dict()
            elif isinstance(self.default_action, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultAction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_action
                ]
            else:
                props["DefaultAction"] = self.default_action

        if self.metric_name is not None:
            # Serialize metric_name (handle intrinsic functions)
            if hasattr(self.metric_name, 'to_dict'):
                props["MetricName"] = self.metric_name.to_dict()
            elif isinstance(self.metric_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['MetricName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_name
                ]
            else:
                props["MetricName"] = self.metric_name

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.rules is not None:
            # Serialize rules (handle intrinsic functions)
            if hasattr(self.rules, 'to_dict'):
                props["Rules"] = self.rules.to_dict()
            elif isinstance(self.rules, list):
                # Serialize list items (may contain intrinsic functions)
                props['Rules'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rules
                ]
            else:
                props["Rules"] = self.rules

        return props



@dataclass
class FieldToMatch:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-waf"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, MatchFieldType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.data is not None:
            if hasattr(self.data, 'to_dict'):
                props['Data'] = self.data.to_dict()
            elif isinstance(self.data, list):
                props['Data'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data
                ]
            else:
                props['Data'] = self.data

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        return props


@dataclass
class XssMatchTuple:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-waf"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    field_to_match: Optional[FieldToMatch] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    text_transformation: Optional[Union[str, TextTransformation, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.field_to_match is not None:
            if hasattr(self.field_to_match, 'to_dict'):
                props['FieldToMatch'] = self.field_to_match.to_dict()
            elif isinstance(self.field_to_match, list):
                props['FieldToMatch'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.field_to_match
                ]
            else:
                props['FieldToMatch'] = self.field_to_match

        if self.text_transformation is not None:
            if hasattr(self.text_transformation, 'to_dict'):
                props['TextTransformation'] = self.text_transformation.to_dict()
            elif isinstance(self.text_transformation, list):
                props['TextTransformation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.text_transformation
                ]
            else:
                props['TextTransformation'] = self.text_transformation

        return props


@dataclass
class XssMatchSet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-waf-x"""

    resource_type: ClassVar[str] = "AWS::WAF::XssMatchSet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    xss_match_tuples: Optional[list[XssMatchTuple]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.xss_match_tuples is not None:
            # Serialize xss_match_tuples (handle intrinsic functions)
            if hasattr(self.xss_match_tuples, 'to_dict'):
                props["XssMatchTuples"] = self.xss_match_tuples.to_dict()
            elif isinstance(self.xss_match_tuples, list):
                # Serialize list items (may contain intrinsic functions)
                props['XssMatchTuples'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.xss_match_tuples
                ]
            else:
                props["XssMatchTuples"] = self.xss_match_tuples

        return props


