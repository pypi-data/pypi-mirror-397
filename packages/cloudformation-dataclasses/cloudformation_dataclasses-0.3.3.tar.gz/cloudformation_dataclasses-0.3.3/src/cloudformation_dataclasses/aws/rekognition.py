"""
AWS CloudFormation Rekognition Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:38

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service Rekognition
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class Attribute:
    """Attribute enum values."""

    DEFAULT = "DEFAULT"
    ALL = "ALL"
    AGE_RANGE = "AGE_RANGE"
    BEARD = "BEARD"
    EMOTIONS = "EMOTIONS"
    EYE_DIRECTION = "EYE_DIRECTION"
    EYEGLASSES = "EYEGLASSES"
    EYES_OPEN = "EYES_OPEN"
    GENDER = "GENDER"
    MOUTH_OPEN = "MOUTH_OPEN"
    MUSTACHE = "MUSTACHE"
    FACE_OCCLUDED = "FACE_OCCLUDED"
    SMILE = "SMILE"
    SUNGLASSES = "SUNGLASSES"


class BodyPart:
    """BodyPart enum values."""

    FACE = "FACE"
    HEAD = "HEAD"
    LEFT_HAND = "LEFT_HAND"
    RIGHT_HAND = "RIGHT_HAND"


class CelebrityRecognitionSortBy:
    """CelebrityRecognitionSortBy enum values."""

    ID = "ID"
    TIMESTAMP = "TIMESTAMP"


class ChallengeType:
    """ChallengeType enum values."""

    FACEMOVEMENTANDLIGHTCHALLENGE = "FaceMovementAndLightChallenge"
    FACEMOVEMENTCHALLENGE = "FaceMovementChallenge"


class ContentClassifier:
    """ContentClassifier enum values."""

    FREEOFPERSONALLYIDENTIFIABLEINFORMATION = "FreeOfPersonallyIdentifiableInformation"
    FREEOFADULTCONTENT = "FreeOfAdultContent"


class ContentModerationAggregateBy:
    """ContentModerationAggregateBy enum values."""

    TIMESTAMPS = "TIMESTAMPS"
    SEGMENTS = "SEGMENTS"


class ContentModerationSortBy:
    """ContentModerationSortBy enum values."""

    NAME = "NAME"
    TIMESTAMP = "TIMESTAMP"


class CustomizationFeature:
    """CustomizationFeature enum values."""

    CONTENT_MODERATION = "CONTENT_MODERATION"
    CUSTOM_LABELS = "CUSTOM_LABELS"


class DatasetStatus:
    """DatasetStatus enum values."""

    CREATE_IN_PROGRESS = "CREATE_IN_PROGRESS"
    CREATE_COMPLETE = "CREATE_COMPLETE"
    CREATE_FAILED = "CREATE_FAILED"
    UPDATE_IN_PROGRESS = "UPDATE_IN_PROGRESS"
    UPDATE_COMPLETE = "UPDATE_COMPLETE"
    UPDATE_FAILED = "UPDATE_FAILED"
    DELETE_IN_PROGRESS = "DELETE_IN_PROGRESS"


class DatasetStatusMessageCode:
    """DatasetStatusMessageCode enum values."""

    SUCCESS = "SUCCESS"
    SERVICE_ERROR = "SERVICE_ERROR"
    CLIENT_ERROR = "CLIENT_ERROR"


class DatasetType:
    """DatasetType enum values."""

    TRAIN = "TRAIN"
    TEST = "TEST"


class DetectLabelsFeatureName:
    """DetectLabelsFeatureName enum values."""

    GENERAL_LABELS = "GENERAL_LABELS"
    IMAGE_PROPERTIES = "IMAGE_PROPERTIES"


class EmotionName:
    """EmotionName enum values."""

    HAPPY = "HAPPY"
    SAD = "SAD"
    ANGRY = "ANGRY"
    CONFUSED = "CONFUSED"
    DISGUSTED = "DISGUSTED"
    SURPRISED = "SURPRISED"
    CALM = "CALM"
    UNKNOWN = "UNKNOWN"
    FEAR = "FEAR"


class FaceAttributes:
    """FaceAttributes enum values."""

    DEFAULT = "DEFAULT"
    ALL = "ALL"


class FaceSearchSortBy:
    """FaceSearchSortBy enum values."""

    INDEX = "INDEX"
    TIMESTAMP = "TIMESTAMP"


class GenderType:
    """GenderType enum values."""

    MALE = "Male"
    FEMALE = "Female"


class KnownGenderType:
    """KnownGenderType enum values."""

    MALE = "Male"
    FEMALE = "Female"
    NONBINARY = "Nonbinary"
    UNLISTED = "Unlisted"


class LabelDetectionAggregateBy:
    """LabelDetectionAggregateBy enum values."""

    TIMESTAMPS = "TIMESTAMPS"
    SEGMENTS = "SEGMENTS"


class LabelDetectionFeatureName:
    """LabelDetectionFeatureName enum values."""

    GENERAL_LABELS = "GENERAL_LABELS"


class LabelDetectionSortBy:
    """LabelDetectionSortBy enum values."""

    NAME = "NAME"
    TIMESTAMP = "TIMESTAMP"


class LandmarkType:
    """LandmarkType enum values."""

    EYELEFT = "eyeLeft"
    EYERIGHT = "eyeRight"
    NOSE = "nose"
    MOUTHLEFT = "mouthLeft"
    MOUTHRIGHT = "mouthRight"
    LEFTEYEBROWLEFT = "leftEyeBrowLeft"
    LEFTEYEBROWRIGHT = "leftEyeBrowRight"
    LEFTEYEBROWUP = "leftEyeBrowUp"
    RIGHTEYEBROWLEFT = "rightEyeBrowLeft"
    RIGHTEYEBROWRIGHT = "rightEyeBrowRight"
    RIGHTEYEBROWUP = "rightEyeBrowUp"
    LEFTEYELEFT = "leftEyeLeft"
    LEFTEYERIGHT = "leftEyeRight"
    LEFTEYEUP = "leftEyeUp"
    LEFTEYEDOWN = "leftEyeDown"
    RIGHTEYELEFT = "rightEyeLeft"
    RIGHTEYERIGHT = "rightEyeRight"
    RIGHTEYEUP = "rightEyeUp"
    RIGHTEYEDOWN = "rightEyeDown"
    NOSELEFT = "noseLeft"
    NOSERIGHT = "noseRight"
    MOUTHUP = "mouthUp"
    MOUTHDOWN = "mouthDown"
    LEFTPUPIL = "leftPupil"
    RIGHTPUPIL = "rightPupil"
    UPPERJAWLINELEFT = "upperJawlineLeft"
    MIDJAWLINELEFT = "midJawlineLeft"
    CHINBOTTOM = "chinBottom"
    MIDJAWLINERIGHT = "midJawlineRight"
    UPPERJAWLINERIGHT = "upperJawlineRight"


class LivenessSessionStatus:
    """LivenessSessionStatus enum values."""

    CREATED = "CREATED"
    IN_PROGRESS = "IN_PROGRESS"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    EXPIRED = "EXPIRED"


class MediaAnalysisJobFailureCode:
    """MediaAnalysisJobFailureCode enum values."""

    INTERNAL_ERROR = "INTERNAL_ERROR"
    INVALID_S3_OBJECT = "INVALID_S3_OBJECT"
    INVALID_MANIFEST = "INVALID_MANIFEST"
    INVALID_OUTPUT_CONFIG = "INVALID_OUTPUT_CONFIG"
    INVALID_KMS_KEY = "INVALID_KMS_KEY"
    ACCESS_DENIED = "ACCESS_DENIED"
    RESOURCE_NOT_FOUND = "RESOURCE_NOT_FOUND"
    RESOURCE_NOT_READY = "RESOURCE_NOT_READY"
    THROTTLED = "THROTTLED"


class MediaAnalysisJobStatus:
    """MediaAnalysisJobStatus enum values."""

    CREATED = "CREATED"
    QUEUED = "QUEUED"
    IN_PROGRESS = "IN_PROGRESS"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"


class OrientationCorrection:
    """OrientationCorrection enum values."""

    ROTATE_0 = "ROTATE_0"
    ROTATE_90 = "ROTATE_90"
    ROTATE_180 = "ROTATE_180"
    ROTATE_270 = "ROTATE_270"


class PersonTrackingSortBy:
    """PersonTrackingSortBy enum values."""

    INDEX = "INDEX"
    TIMESTAMP = "TIMESTAMP"


class ProjectAutoUpdate:
    """ProjectAutoUpdate enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class ProjectStatus:
    """ProjectStatus enum values."""

    CREATING = "CREATING"
    CREATED = "CREATED"
    DELETING = "DELETING"


class ProjectVersionStatus:
    """ProjectVersionStatus enum values."""

    TRAINING_IN_PROGRESS = "TRAINING_IN_PROGRESS"
    TRAINING_COMPLETED = "TRAINING_COMPLETED"
    TRAINING_FAILED = "TRAINING_FAILED"
    STARTING = "STARTING"
    RUNNING = "RUNNING"
    FAILED = "FAILED"
    STOPPING = "STOPPING"
    STOPPED = "STOPPED"
    DELETING = "DELETING"
    COPYING_IN_PROGRESS = "COPYING_IN_PROGRESS"
    COPYING_COMPLETED = "COPYING_COMPLETED"
    COPYING_FAILED = "COPYING_FAILED"
    DEPRECATED = "DEPRECATED"
    EXPIRED = "EXPIRED"


class ProtectiveEquipmentType:
    """ProtectiveEquipmentType enum values."""

    FACE_COVER = "FACE_COVER"
    HAND_COVER = "HAND_COVER"
    HEAD_COVER = "HEAD_COVER"


class QualityFilter:
    """QualityFilter enum values."""

    NONE = "NONE"
    AUTO = "AUTO"
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"


class Reason:
    """Reason enum values."""

    EXCEEDS_MAX_FACES = "EXCEEDS_MAX_FACES"
    EXTREME_POSE = "EXTREME_POSE"
    LOW_BRIGHTNESS = "LOW_BRIGHTNESS"
    LOW_SHARPNESS = "LOW_SHARPNESS"
    LOW_CONFIDENCE = "LOW_CONFIDENCE"
    SMALL_BOUNDING_BOX = "SMALL_BOUNDING_BOX"
    LOW_FACE_QUALITY = "LOW_FACE_QUALITY"


class SegmentType:
    """SegmentType enum values."""

    TECHNICAL_CUE = "TECHNICAL_CUE"
    SHOT = "SHOT"


class StreamProcessorParameterToDelete:
    """StreamProcessorParameterToDelete enum values."""

    CONNECTEDHOMEMINCONFIDENCE = "ConnectedHomeMinConfidence"
    REGIONSOFINTEREST = "RegionsOfInterest"


class StreamProcessorStatus:
    """StreamProcessorStatus enum values."""

    STOPPED = "STOPPED"
    STARTING = "STARTING"
    RUNNING = "RUNNING"
    FAILED = "FAILED"
    STOPPING = "STOPPING"
    UPDATING = "UPDATING"


class TechnicalCueType:
    """TechnicalCueType enum values."""

    COLORBARS = "ColorBars"
    ENDCREDITS = "EndCredits"
    BLACKFRAMES = "BlackFrames"
    OPENINGCREDITS = "OpeningCredits"
    STUDIOLOGO = "StudioLogo"
    SLATE = "Slate"
    CONTENT = "Content"


class TextTypes:
    """TextTypes enum values."""

    LINE = "LINE"
    WORD = "WORD"


class UnsearchedFaceReason:
    """UnsearchedFaceReason enum values."""

    FACE_NOT_LARGEST = "FACE_NOT_LARGEST"
    EXCEEDS_MAX_FACES = "EXCEEDS_MAX_FACES"
    EXTREME_POSE = "EXTREME_POSE"
    LOW_BRIGHTNESS = "LOW_BRIGHTNESS"
    LOW_SHARPNESS = "LOW_SHARPNESS"
    LOW_CONFIDENCE = "LOW_CONFIDENCE"
    SMALL_BOUNDING_BOX = "SMALL_BOUNDING_BOX"
    LOW_FACE_QUALITY = "LOW_FACE_QUALITY"


class UnsuccessfulFaceAssociationReason:
    """UnsuccessfulFaceAssociationReason enum values."""

    FACE_NOT_FOUND = "FACE_NOT_FOUND"
    ASSOCIATED_TO_A_DIFFERENT_USER = "ASSOCIATED_TO_A_DIFFERENT_USER"
    LOW_MATCH_CONFIDENCE = "LOW_MATCH_CONFIDENCE"


class UnsuccessfulFaceDeletionReason:
    """UnsuccessfulFaceDeletionReason enum values."""

    ASSOCIATED_TO_AN_EXISTING_USER = "ASSOCIATED_TO_AN_EXISTING_USER"
    FACE_NOT_FOUND = "FACE_NOT_FOUND"


class UnsuccessfulFaceDisassociationReason:
    """UnsuccessfulFaceDisassociationReason enum values."""

    FACE_NOT_FOUND = "FACE_NOT_FOUND"
    ASSOCIATED_TO_A_DIFFERENT_USER = "ASSOCIATED_TO_A_DIFFERENT_USER"


class UserStatus:
    """UserStatus enum values."""

    ACTIVE = "ACTIVE"
    UPDATING = "UPDATING"
    CREATING = "CREATING"
    CREATED = "CREATED"


class VideoColorRange:
    """VideoColorRange enum values."""

    FULL = "FULL"
    LIMITED = "LIMITED"


class VideoJobStatus:
    """VideoJobStatus enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"


# Convenient aliases for enum values
DEFAULT = Attribute.DEFAULT
ALL = Attribute.ALL
AGE_RANGE = Attribute.AGE_RANGE
BEARD = Attribute.BEARD
EMOTIONS = Attribute.EMOTIONS
EYE_DIRECTION = Attribute.EYE_DIRECTION
EYEGLASSES = Attribute.EYEGLASSES
EYES_OPEN = Attribute.EYES_OPEN
GENDER = Attribute.GENDER
MOUTH_OPEN = Attribute.MOUTH_OPEN
MUSTACHE = Attribute.MUSTACHE
FACE_OCCLUDED = Attribute.FACE_OCCLUDED
SMILE = Attribute.SMILE
SUNGLASSES = Attribute.SUNGLASSES
FACE = BodyPart.FACE
HEAD = BodyPart.HEAD
LEFT_HAND = BodyPart.LEFT_HAND
RIGHT_HAND = BodyPart.RIGHT_HAND
ID = CelebrityRecognitionSortBy.ID
TIMESTAMP = CelebrityRecognitionSortBy.TIMESTAMP
FACEMOVEMENTANDLIGHTCHALLENGE = ChallengeType.FACEMOVEMENTANDLIGHTCHALLENGE
FACEMOVEMENTCHALLENGE = ChallengeType.FACEMOVEMENTCHALLENGE
FREEOFPERSONALLYIDENTIFIABLEINFORMATION = ContentClassifier.FREEOFPERSONALLYIDENTIFIABLEINFORMATION
FREEOFADULTCONTENT = ContentClassifier.FREEOFADULTCONTENT
TIMESTAMPS = ContentModerationAggregateBy.TIMESTAMPS
SEGMENTS = ContentModerationAggregateBy.SEGMENTS
NAME = ContentModerationSortBy.NAME
TIMESTAMP = ContentModerationSortBy.TIMESTAMP
CONTENT_MODERATION = CustomizationFeature.CONTENT_MODERATION
CUSTOM_LABELS = CustomizationFeature.CUSTOM_LABELS
CREATE_IN_PROGRESS = DatasetStatus.CREATE_IN_PROGRESS
CREATE_COMPLETE = DatasetStatus.CREATE_COMPLETE
CREATE_FAILED = DatasetStatus.CREATE_FAILED
UPDATE_IN_PROGRESS = DatasetStatus.UPDATE_IN_PROGRESS
UPDATE_COMPLETE = DatasetStatus.UPDATE_COMPLETE
UPDATE_FAILED = DatasetStatus.UPDATE_FAILED
DELETE_IN_PROGRESS = DatasetStatus.DELETE_IN_PROGRESS
SUCCESS = DatasetStatusMessageCode.SUCCESS
SERVICE_ERROR = DatasetStatusMessageCode.SERVICE_ERROR
CLIENT_ERROR = DatasetStatusMessageCode.CLIENT_ERROR
TRAIN = DatasetType.TRAIN
TEST = DatasetType.TEST
GENERAL_LABELS = DetectLabelsFeatureName.GENERAL_LABELS
IMAGE_PROPERTIES = DetectLabelsFeatureName.IMAGE_PROPERTIES
HAPPY = EmotionName.HAPPY
SAD = EmotionName.SAD
ANGRY = EmotionName.ANGRY
CONFUSED = EmotionName.CONFUSED
DISGUSTED = EmotionName.DISGUSTED
SURPRISED = EmotionName.SURPRISED
CALM = EmotionName.CALM
UNKNOWN = EmotionName.UNKNOWN
FEAR = EmotionName.FEAR
DEFAULT = FaceAttributes.DEFAULT
ALL = FaceAttributes.ALL
INDEX = FaceSearchSortBy.INDEX
TIMESTAMP = FaceSearchSortBy.TIMESTAMP
MALE = GenderType.MALE
FEMALE = GenderType.FEMALE
MALE = KnownGenderType.MALE
FEMALE = KnownGenderType.FEMALE
NONBINARY = KnownGenderType.NONBINARY
UNLISTED = KnownGenderType.UNLISTED
TIMESTAMPS = LabelDetectionAggregateBy.TIMESTAMPS
SEGMENTS = LabelDetectionAggregateBy.SEGMENTS
GENERAL_LABELS = LabelDetectionFeatureName.GENERAL_LABELS
NAME = LabelDetectionSortBy.NAME
TIMESTAMP = LabelDetectionSortBy.TIMESTAMP
EYELEFT = LandmarkType.EYELEFT
EYERIGHT = LandmarkType.EYERIGHT
NOSE = LandmarkType.NOSE
MOUTHLEFT = LandmarkType.MOUTHLEFT
MOUTHRIGHT = LandmarkType.MOUTHRIGHT
LEFTEYEBROWLEFT = LandmarkType.LEFTEYEBROWLEFT
LEFTEYEBROWRIGHT = LandmarkType.LEFTEYEBROWRIGHT
LEFTEYEBROWUP = LandmarkType.LEFTEYEBROWUP
RIGHTEYEBROWLEFT = LandmarkType.RIGHTEYEBROWLEFT
RIGHTEYEBROWRIGHT = LandmarkType.RIGHTEYEBROWRIGHT
RIGHTEYEBROWUP = LandmarkType.RIGHTEYEBROWUP
LEFTEYELEFT = LandmarkType.LEFTEYELEFT
LEFTEYERIGHT = LandmarkType.LEFTEYERIGHT
LEFTEYEUP = LandmarkType.LEFTEYEUP
LEFTEYEDOWN = LandmarkType.LEFTEYEDOWN
RIGHTEYELEFT = LandmarkType.RIGHTEYELEFT
RIGHTEYERIGHT = LandmarkType.RIGHTEYERIGHT
RIGHTEYEUP = LandmarkType.RIGHTEYEUP
RIGHTEYEDOWN = LandmarkType.RIGHTEYEDOWN
NOSELEFT = LandmarkType.NOSELEFT
NOSERIGHT = LandmarkType.NOSERIGHT
MOUTHUP = LandmarkType.MOUTHUP
MOUTHDOWN = LandmarkType.MOUTHDOWN
LEFTPUPIL = LandmarkType.LEFTPUPIL
RIGHTPUPIL = LandmarkType.RIGHTPUPIL
UPPERJAWLINELEFT = LandmarkType.UPPERJAWLINELEFT
MIDJAWLINELEFT = LandmarkType.MIDJAWLINELEFT
CHINBOTTOM = LandmarkType.CHINBOTTOM
MIDJAWLINERIGHT = LandmarkType.MIDJAWLINERIGHT
UPPERJAWLINERIGHT = LandmarkType.UPPERJAWLINERIGHT
CREATED = LivenessSessionStatus.CREATED
IN_PROGRESS = LivenessSessionStatus.IN_PROGRESS
SUCCEEDED = LivenessSessionStatus.SUCCEEDED
FAILED = LivenessSessionStatus.FAILED
EXPIRED = LivenessSessionStatus.EXPIRED
INTERNAL_ERROR = MediaAnalysisJobFailureCode.INTERNAL_ERROR
INVALID_S3_OBJECT = MediaAnalysisJobFailureCode.INVALID_S3_OBJECT
INVALID_MANIFEST = MediaAnalysisJobFailureCode.INVALID_MANIFEST
INVALID_OUTPUT_CONFIG = MediaAnalysisJobFailureCode.INVALID_OUTPUT_CONFIG
INVALID_KMS_KEY = MediaAnalysisJobFailureCode.INVALID_KMS_KEY
ACCESS_DENIED = MediaAnalysisJobFailureCode.ACCESS_DENIED
RESOURCE_NOT_FOUND = MediaAnalysisJobFailureCode.RESOURCE_NOT_FOUND
RESOURCE_NOT_READY = MediaAnalysisJobFailureCode.RESOURCE_NOT_READY
THROTTLED = MediaAnalysisJobFailureCode.THROTTLED
CREATED = MediaAnalysisJobStatus.CREATED
QUEUED = MediaAnalysisJobStatus.QUEUED
IN_PROGRESS = MediaAnalysisJobStatus.IN_PROGRESS
SUCCEEDED = MediaAnalysisJobStatus.SUCCEEDED
FAILED = MediaAnalysisJobStatus.FAILED
ROTATE_0 = OrientationCorrection.ROTATE_0
ROTATE_90 = OrientationCorrection.ROTATE_90
ROTATE_180 = OrientationCorrection.ROTATE_180
ROTATE_270 = OrientationCorrection.ROTATE_270
INDEX = PersonTrackingSortBy.INDEX
TIMESTAMP = PersonTrackingSortBy.TIMESTAMP
ENABLED = ProjectAutoUpdate.ENABLED
DISABLED = ProjectAutoUpdate.DISABLED
CREATING = ProjectStatus.CREATING
CREATED = ProjectStatus.CREATED
DELETING = ProjectStatus.DELETING
TRAINING_IN_PROGRESS = ProjectVersionStatus.TRAINING_IN_PROGRESS
TRAINING_COMPLETED = ProjectVersionStatus.TRAINING_COMPLETED
TRAINING_FAILED = ProjectVersionStatus.TRAINING_FAILED
STARTING = ProjectVersionStatus.STARTING
RUNNING = ProjectVersionStatus.RUNNING
FAILED = ProjectVersionStatus.FAILED
STOPPING = ProjectVersionStatus.STOPPING
STOPPED = ProjectVersionStatus.STOPPED
DELETING = ProjectVersionStatus.DELETING
COPYING_IN_PROGRESS = ProjectVersionStatus.COPYING_IN_PROGRESS
COPYING_COMPLETED = ProjectVersionStatus.COPYING_COMPLETED
COPYING_FAILED = ProjectVersionStatus.COPYING_FAILED
DEPRECATED = ProjectVersionStatus.DEPRECATED
EXPIRED = ProjectVersionStatus.EXPIRED
FACE_COVER = ProtectiveEquipmentType.FACE_COVER
HAND_COVER = ProtectiveEquipmentType.HAND_COVER
HEAD_COVER = ProtectiveEquipmentType.HEAD_COVER
NONE = QualityFilter.NONE
AUTO = QualityFilter.AUTO
LOW = QualityFilter.LOW
MEDIUM = QualityFilter.MEDIUM
HIGH = QualityFilter.HIGH
EXCEEDS_MAX_FACES = Reason.EXCEEDS_MAX_FACES
EXTREME_POSE = Reason.EXTREME_POSE
LOW_BRIGHTNESS = Reason.LOW_BRIGHTNESS
LOW_SHARPNESS = Reason.LOW_SHARPNESS
LOW_CONFIDENCE = Reason.LOW_CONFIDENCE
SMALL_BOUNDING_BOX = Reason.SMALL_BOUNDING_BOX
LOW_FACE_QUALITY = Reason.LOW_FACE_QUALITY
TECHNICAL_CUE = SegmentType.TECHNICAL_CUE
SHOT = SegmentType.SHOT
CONNECTEDHOMEMINCONFIDENCE = StreamProcessorParameterToDelete.CONNECTEDHOMEMINCONFIDENCE
REGIONSOFINTEREST = StreamProcessorParameterToDelete.REGIONSOFINTEREST
STOPPED = StreamProcessorStatus.STOPPED
STARTING = StreamProcessorStatus.STARTING
RUNNING = StreamProcessorStatus.RUNNING
FAILED = StreamProcessorStatus.FAILED
STOPPING = StreamProcessorStatus.STOPPING
UPDATING = StreamProcessorStatus.UPDATING
COLORBARS = TechnicalCueType.COLORBARS
ENDCREDITS = TechnicalCueType.ENDCREDITS
BLACKFRAMES = TechnicalCueType.BLACKFRAMES
OPENINGCREDITS = TechnicalCueType.OPENINGCREDITS
STUDIOLOGO = TechnicalCueType.STUDIOLOGO
SLATE = TechnicalCueType.SLATE
CONTENT = TechnicalCueType.CONTENT
LINE = TextTypes.LINE
WORD = TextTypes.WORD
FACE_NOT_LARGEST = UnsearchedFaceReason.FACE_NOT_LARGEST
EXCEEDS_MAX_FACES = UnsearchedFaceReason.EXCEEDS_MAX_FACES
EXTREME_POSE = UnsearchedFaceReason.EXTREME_POSE
LOW_BRIGHTNESS = UnsearchedFaceReason.LOW_BRIGHTNESS
LOW_SHARPNESS = UnsearchedFaceReason.LOW_SHARPNESS
LOW_CONFIDENCE = UnsearchedFaceReason.LOW_CONFIDENCE
SMALL_BOUNDING_BOX = UnsearchedFaceReason.SMALL_BOUNDING_BOX
LOW_FACE_QUALITY = UnsearchedFaceReason.LOW_FACE_QUALITY
FACE_NOT_FOUND = UnsuccessfulFaceAssociationReason.FACE_NOT_FOUND
ASSOCIATED_TO_A_DIFFERENT_USER = UnsuccessfulFaceAssociationReason.ASSOCIATED_TO_A_DIFFERENT_USER
LOW_MATCH_CONFIDENCE = UnsuccessfulFaceAssociationReason.LOW_MATCH_CONFIDENCE
ASSOCIATED_TO_AN_EXISTING_USER = UnsuccessfulFaceDeletionReason.ASSOCIATED_TO_AN_EXISTING_USER
FACE_NOT_FOUND = UnsuccessfulFaceDeletionReason.FACE_NOT_FOUND
FACE_NOT_FOUND = UnsuccessfulFaceDisassociationReason.FACE_NOT_FOUND
ASSOCIATED_TO_A_DIFFERENT_USER = UnsuccessfulFaceDisassociationReason.ASSOCIATED_TO_A_DIFFERENT_USER
ACTIVE = UserStatus.ACTIVE
UPDATING = UserStatus.UPDATING
CREATING = UserStatus.CREATING
CREATED = UserStatus.CREATED
FULL = VideoColorRange.FULL
LIMITED = VideoColorRange.LIMITED
IN_PROGRESS = VideoJobStatus.IN_PROGRESS
SUCCEEDED = VideoJobStatus.SUCCEEDED
FAILED = VideoJobStatus.FAILED


@dataclass
class Collection(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rekog"""

    resource_type: ClassVar[str] = "AWS::Rekognition::Collection"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    collection_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.collection_id is not None:
            # Serialize collection_id (handle intrinsic functions)
            if hasattr(self.collection_id, 'to_dict'):
                props["CollectionId"] = self.collection_id.to_dict()
            elif isinstance(self.collection_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['CollectionId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.collection_id
                ]
            else:
                props["CollectionId"] = self.collection_id

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class Project(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rekog"""

    resource_type: ClassVar[str] = "AWS::Rekognition::Project"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    project_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.project_name is not None:
            # Serialize project_name (handle intrinsic functions)
            if hasattr(self.project_name, 'to_dict'):
                props["ProjectName"] = self.project_name.to_dict()
            elif isinstance(self.project_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProjectName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.project_name
                ]
            else:
                props["ProjectName"] = self.project_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class BoundingBox:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rek"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    left: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    top: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    height: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    width: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.left is not None:
            if hasattr(self.left, 'to_dict'):
                props['Left'] = self.left.to_dict()
            elif isinstance(self.left, list):
                props['Left'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.left
                ]
            else:
                props['Left'] = self.left

        if self.top is not None:
            if hasattr(self.top, 'to_dict'):
                props['Top'] = self.top.to_dict()
            elif isinstance(self.top, list):
                props['Top'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.top
                ]
            else:
                props['Top'] = self.top

        if self.height is not None:
            if hasattr(self.height, 'to_dict'):
                props['Height'] = self.height.to_dict()
            elif isinstance(self.height, list):
                props['Height'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.height
                ]
            else:
                props['Height'] = self.height

        if self.width is not None:
            if hasattr(self.width, 'to_dict'):
                props['Width'] = self.width.to_dict()
            elif isinstance(self.width, list):
                props['Width'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.width
                ]
            else:
                props['Width'] = self.width

        return props


@dataclass
class ConnectedHomeSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rek"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_confidence: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    labels: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.min_confidence is not None:
            if hasattr(self.min_confidence, 'to_dict'):
                props['MinConfidence'] = self.min_confidence.to_dict()
            elif isinstance(self.min_confidence, list):
                props['MinConfidence'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_confidence
                ]
            else:
                props['MinConfidence'] = self.min_confidence

        if self.labels is not None:
            if hasattr(self.labels, 'to_dict'):
                props['Labels'] = self.labels.to_dict()
            elif isinstance(self.labels, list):
                props['Labels'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.labels
                ]
            else:
                props['Labels'] = self.labels

        return props


@dataclass
class DataSharingPreference:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rek"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    opt_in: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.opt_in is not None:
            if hasattr(self.opt_in, 'to_dict'):
                props['OptIn'] = self.opt_in.to_dict()
            elif isinstance(self.opt_in, list):
                props['OptIn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.opt_in
                ]
            else:
                props['OptIn'] = self.opt_in

        return props


@dataclass
class FaceSearchSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rek"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    collection_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    face_match_threshold: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.collection_id is not None:
            if hasattr(self.collection_id, 'to_dict'):
                props['CollectionId'] = self.collection_id.to_dict()
            elif isinstance(self.collection_id, list):
                props['CollectionId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.collection_id
                ]
            else:
                props['CollectionId'] = self.collection_id

        if self.face_match_threshold is not None:
            if hasattr(self.face_match_threshold, 'to_dict'):
                props['FaceMatchThreshold'] = self.face_match_threshold.to_dict()
            elif isinstance(self.face_match_threshold, list):
                props['FaceMatchThreshold'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.face_match_threshold
                ]
            else:
                props['FaceMatchThreshold'] = self.face_match_threshold

        return props


@dataclass
class KinesisDataStream:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rek"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.arn is not None:
            if hasattr(self.arn, 'to_dict'):
                props['Arn'] = self.arn.to_dict()
            elif isinstance(self.arn, list):
                props['Arn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.arn
                ]
            else:
                props['Arn'] = self.arn

        return props


@dataclass
class KinesisVideoStream:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rek"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.arn is not None:
            if hasattr(self.arn, 'to_dict'):
                props['Arn'] = self.arn.to_dict()
            elif isinstance(self.arn, list):
                props['Arn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.arn
                ]
            else:
                props['Arn'] = self.arn

        return props


@dataclass
class NotificationChannel:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rek"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.arn is not None:
            if hasattr(self.arn, 'to_dict'):
                props['Arn'] = self.arn.to_dict()
            elif isinstance(self.arn, list):
                props['Arn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.arn
                ]
            else:
                props['Arn'] = self.arn

        return props


@dataclass
class S3Destination:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rek"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    object_key_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.bucket_name is not None:
            if hasattr(self.bucket_name, 'to_dict'):
                props['BucketName'] = self.bucket_name.to_dict()
            elif isinstance(self.bucket_name, list):
                props['BucketName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket_name
                ]
            else:
                props['BucketName'] = self.bucket_name

        if self.object_key_prefix is not None:
            if hasattr(self.object_key_prefix, 'to_dict'):
                props['ObjectKeyPrefix'] = self.object_key_prefix.to_dict()
            elif isinstance(self.object_key_prefix, list):
                props['ObjectKeyPrefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.object_key_prefix
                ]
            else:
                props['ObjectKeyPrefix'] = self.object_key_prefix

        return props


@dataclass
class StreamProcessor(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-rekog"""

    resource_type: ClassVar[str] = "AWS::Rekognition::StreamProcessor"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    s3_destination: Optional[S3Destination] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_sharing_preference: Optional[DataSharingPreference] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    face_search_settings: Optional[FaceSearchSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    polygon_regions_of_interest: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    connected_home_settings: Optional[ConnectedHomeSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    notification_channel: Optional[NotificationChannel] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kinesis_video_stream: Optional[KinesisVideoStream] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    bounding_box_regions_of_interest: Optional[list[BoundingBox]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kinesis_data_stream: Optional[KinesisDataStream] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_destination is not None:
            # Serialize s3_destination (handle intrinsic functions)
            if hasattr(self.s3_destination, 'to_dict'):
                props["S3Destination"] = self.s3_destination.to_dict()
            elif isinstance(self.s3_destination, list):
                # Serialize list items (may contain intrinsic functions)
                props['S3Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_destination
                ]
            else:
                props["S3Destination"] = self.s3_destination

        if self.data_sharing_preference is not None:
            # Serialize data_sharing_preference (handle intrinsic functions)
            if hasattr(self.data_sharing_preference, 'to_dict'):
                props["DataSharingPreference"] = self.data_sharing_preference.to_dict()
            elif isinstance(self.data_sharing_preference, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataSharingPreference'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_sharing_preference
                ]
            else:
                props["DataSharingPreference"] = self.data_sharing_preference

        if self.kms_key_id is not None:
            # Serialize kms_key_id (handle intrinsic functions)
            if hasattr(self.kms_key_id, 'to_dict'):
                props["KmsKeyId"] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props["KmsKeyId"] = self.kms_key_id

        if self.face_search_settings is not None:
            # Serialize face_search_settings (handle intrinsic functions)
            if hasattr(self.face_search_settings, 'to_dict'):
                props["FaceSearchSettings"] = self.face_search_settings.to_dict()
            elif isinstance(self.face_search_settings, list):
                # Serialize list items (may contain intrinsic functions)
                props['FaceSearchSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.face_search_settings
                ]
            else:
                props["FaceSearchSettings"] = self.face_search_settings

        if self.polygon_regions_of_interest is not None:
            # Serialize polygon_regions_of_interest (handle intrinsic functions)
            if hasattr(self.polygon_regions_of_interest, 'to_dict'):
                props["PolygonRegionsOfInterest"] = self.polygon_regions_of_interest.to_dict()
            elif isinstance(self.polygon_regions_of_interest, list):
                # Serialize list items (may contain intrinsic functions)
                props['PolygonRegionsOfInterest'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.polygon_regions_of_interest
                ]
            else:
                props["PolygonRegionsOfInterest"] = self.polygon_regions_of_interest

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.connected_home_settings is not None:
            # Serialize connected_home_settings (handle intrinsic functions)
            if hasattr(self.connected_home_settings, 'to_dict'):
                props["ConnectedHomeSettings"] = self.connected_home_settings.to_dict()
            elif isinstance(self.connected_home_settings, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConnectedHomeSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.connected_home_settings
                ]
            else:
                props["ConnectedHomeSettings"] = self.connected_home_settings

        if self.notification_channel is not None:
            # Serialize notification_channel (handle intrinsic functions)
            if hasattr(self.notification_channel, 'to_dict'):
                props["NotificationChannel"] = self.notification_channel.to_dict()
            elif isinstance(self.notification_channel, list):
                # Serialize list items (may contain intrinsic functions)
                props['NotificationChannel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_channel
                ]
            else:
                props["NotificationChannel"] = self.notification_channel

        if self.kinesis_video_stream is not None:
            # Serialize kinesis_video_stream (handle intrinsic functions)
            if hasattr(self.kinesis_video_stream, 'to_dict'):
                props["KinesisVideoStream"] = self.kinesis_video_stream.to_dict()
            elif isinstance(self.kinesis_video_stream, list):
                # Serialize list items (may contain intrinsic functions)
                props['KinesisVideoStream'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kinesis_video_stream
                ]
            else:
                props["KinesisVideoStream"] = self.kinesis_video_stream

        if self.bounding_box_regions_of_interest is not None:
            # Serialize bounding_box_regions_of_interest (handle intrinsic functions)
            if hasattr(self.bounding_box_regions_of_interest, 'to_dict'):
                props["BoundingBoxRegionsOfInterest"] = self.bounding_box_regions_of_interest.to_dict()
            elif isinstance(self.bounding_box_regions_of_interest, list):
                # Serialize list items (may contain intrinsic functions)
                props['BoundingBoxRegionsOfInterest'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bounding_box_regions_of_interest
                ]
            else:
                props["BoundingBoxRegionsOfInterest"] = self.bounding_box_regions_of_interest

        if self.kinesis_data_stream is not None:
            # Serialize kinesis_data_stream (handle intrinsic functions)
            if hasattr(self.kinesis_data_stream, 'to_dict'):
                props["KinesisDataStream"] = self.kinesis_data_stream.to_dict()
            elif isinstance(self.kinesis_data_stream, list):
                # Serialize list items (may contain intrinsic functions)
                props['KinesisDataStream'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kinesis_data_stream
                ]
            else:
                props["KinesisDataStream"] = self.kinesis_data_stream

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_status_message(self) -> GetAtt:
        """Get the StatusMessage attribute."""
        return self.get_att("StatusMessage")



