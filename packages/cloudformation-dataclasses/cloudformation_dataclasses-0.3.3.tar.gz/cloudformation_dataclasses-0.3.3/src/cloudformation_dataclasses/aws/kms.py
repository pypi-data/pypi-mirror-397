"""
AWS CloudFormation KMS Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:37

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service KMS
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AlgorithmSpec:
    """AlgorithmSpec enum values."""

    RSAES_PKCS1_V1_5 = "RSAES_PKCS1_V1_5"
    RSAES_OAEP_SHA_1 = "RSAES_OAEP_SHA_1"
    RSAES_OAEP_SHA_256 = "RSAES_OAEP_SHA_256"
    RSA_AES_KEY_WRAP_SHA_1 = "RSA_AES_KEY_WRAP_SHA_1"
    RSA_AES_KEY_WRAP_SHA_256 = "RSA_AES_KEY_WRAP_SHA_256"
    SM2PKE = "SM2PKE"


class ConnectionErrorCodeType:
    """ConnectionErrorCodeType enum values."""

    INVALID_CREDENTIALS = "INVALID_CREDENTIALS"
    CLUSTER_NOT_FOUND = "CLUSTER_NOT_FOUND"
    NETWORK_ERRORS = "NETWORK_ERRORS"
    INTERNAL_ERROR = "INTERNAL_ERROR"
    INSUFFICIENT_CLOUDHSM_HSMS = "INSUFFICIENT_CLOUDHSM_HSMS"
    USER_LOCKED_OUT = "USER_LOCKED_OUT"
    USER_NOT_FOUND = "USER_NOT_FOUND"
    USER_LOGGED_IN = "USER_LOGGED_IN"
    SUBNET_NOT_FOUND = "SUBNET_NOT_FOUND"
    INSUFFICIENT_FREE_ADDRESSES_IN_SUBNET = "INSUFFICIENT_FREE_ADDRESSES_IN_SUBNET"
    XKS_PROXY_ACCESS_DENIED = "XKS_PROXY_ACCESS_DENIED"
    XKS_PROXY_NOT_REACHABLE = "XKS_PROXY_NOT_REACHABLE"
    XKS_VPC_ENDPOINT_SERVICE_NOT_FOUND = "XKS_VPC_ENDPOINT_SERVICE_NOT_FOUND"
    XKS_PROXY_INVALID_RESPONSE = "XKS_PROXY_INVALID_RESPONSE"
    XKS_PROXY_INVALID_CONFIGURATION = "XKS_PROXY_INVALID_CONFIGURATION"
    XKS_VPC_ENDPOINT_SERVICE_INVALID_CONFIGURATION = "XKS_VPC_ENDPOINT_SERVICE_INVALID_CONFIGURATION"
    XKS_PROXY_TIMED_OUT = "XKS_PROXY_TIMED_OUT"
    XKS_PROXY_INVALID_TLS_CONFIGURATION = "XKS_PROXY_INVALID_TLS_CONFIGURATION"


class ConnectionStateType:
    """ConnectionStateType enum values."""

    CONNECTED = "CONNECTED"
    CONNECTING = "CONNECTING"
    FAILED = "FAILED"
    DISCONNECTED = "DISCONNECTED"
    DISCONNECTING = "DISCONNECTING"


class CustomKeyStoreType:
    """CustomKeyStoreType enum values."""

    AWS_CLOUDHSM = "AWS_CLOUDHSM"
    EXTERNAL_KEY_STORE = "EXTERNAL_KEY_STORE"


class CustomerMasterKeySpec:
    """CustomerMasterKeySpec enum values."""

    RSA_2048 = "RSA_2048"
    RSA_3072 = "RSA_3072"
    RSA_4096 = "RSA_4096"
    ECC_NIST_P256 = "ECC_NIST_P256"
    ECC_NIST_P384 = "ECC_NIST_P384"
    ECC_NIST_P521 = "ECC_NIST_P521"
    ECC_SECG_P256K1 = "ECC_SECG_P256K1"
    SYMMETRIC_DEFAULT = "SYMMETRIC_DEFAULT"
    HMAC_224 = "HMAC_224"
    HMAC_256 = "HMAC_256"
    HMAC_384 = "HMAC_384"
    HMAC_512 = "HMAC_512"
    SM2 = "SM2"


class DataKeyPairSpec:
    """DataKeyPairSpec enum values."""

    RSA_2048 = "RSA_2048"
    RSA_3072 = "RSA_3072"
    RSA_4096 = "RSA_4096"
    ECC_NIST_P256 = "ECC_NIST_P256"
    ECC_NIST_P384 = "ECC_NIST_P384"
    ECC_NIST_P521 = "ECC_NIST_P521"
    ECC_SECG_P256K1 = "ECC_SECG_P256K1"
    SM2 = "SM2"
    ECC_NIST_EDWARDS25519 = "ECC_NIST_EDWARDS25519"


class DataKeySpec:
    """DataKeySpec enum values."""

    AES_256 = "AES_256"
    AES_128 = "AES_128"


class EncryptionAlgorithmSpec:
    """EncryptionAlgorithmSpec enum values."""

    SYMMETRIC_DEFAULT = "SYMMETRIC_DEFAULT"
    RSAES_OAEP_SHA_1 = "RSAES_OAEP_SHA_1"
    RSAES_OAEP_SHA_256 = "RSAES_OAEP_SHA_256"
    SM2PKE = "SM2PKE"


class ExpirationModelType:
    """ExpirationModelType enum values."""

    KEY_MATERIAL_EXPIRES = "KEY_MATERIAL_EXPIRES"
    KEY_MATERIAL_DOES_NOT_EXPIRE = "KEY_MATERIAL_DOES_NOT_EXPIRE"


class GrantOperation:
    """GrantOperation enum values."""

    DECRYPT = "Decrypt"
    ENCRYPT = "Encrypt"
    GENERATEDATAKEY = "GenerateDataKey"
    GENERATEDATAKEYWITHOUTPLAINTEXT = "GenerateDataKeyWithoutPlaintext"
    REENCRYPTFROM = "ReEncryptFrom"
    REENCRYPTTO = "ReEncryptTo"
    SIGN = "Sign"
    VERIFY = "Verify"
    GETPUBLICKEY = "GetPublicKey"
    CREATEGRANT = "CreateGrant"
    RETIREGRANT = "RetireGrant"
    DESCRIBEKEY = "DescribeKey"
    GENERATEDATAKEYPAIR = "GenerateDataKeyPair"
    GENERATEDATAKEYPAIRWITHOUTPLAINTEXT = "GenerateDataKeyPairWithoutPlaintext"
    GENERATEMAC = "GenerateMac"
    VERIFYMAC = "VerifyMac"
    DERIVESHAREDSECRET = "DeriveSharedSecret"


class ImportState:
    """ImportState enum values."""

    IMPORTED = "IMPORTED"
    PENDING_IMPORT = "PENDING_IMPORT"


class ImportType:
    """ImportType enum values."""

    NEW_KEY_MATERIAL = "NEW_KEY_MATERIAL"
    EXISTING_KEY_MATERIAL = "EXISTING_KEY_MATERIAL"


class IncludeKeyMaterial:
    """IncludeKeyMaterial enum values."""

    ALL_KEY_MATERIAL = "ALL_KEY_MATERIAL"
    ROTATIONS_ONLY = "ROTATIONS_ONLY"


class KeyAgreementAlgorithmSpec:
    """KeyAgreementAlgorithmSpec enum values."""

    ECDH = "ECDH"


class KeyEncryptionMechanism:
    """KeyEncryptionMechanism enum values."""

    RSAES_OAEP_SHA_256 = "RSAES_OAEP_SHA_256"


class KeyManagerType:
    """KeyManagerType enum values."""

    AWS = "AWS"
    CUSTOMER = "CUSTOMER"


class KeyMaterialState:
    """KeyMaterialState enum values."""

    NON_CURRENT = "NON_CURRENT"
    CURRENT = "CURRENT"
    PENDING_ROTATION = "PENDING_ROTATION"
    PENDING_MULTI_REGION_IMPORT_AND_ROTATION = "PENDING_MULTI_REGION_IMPORT_AND_ROTATION"


class KeySpec:
    """KeySpec enum values."""

    RSA_2048 = "RSA_2048"
    RSA_3072 = "RSA_3072"
    RSA_4096 = "RSA_4096"
    ECC_NIST_P256 = "ECC_NIST_P256"
    ECC_NIST_P384 = "ECC_NIST_P384"
    ECC_NIST_P521 = "ECC_NIST_P521"
    ECC_SECG_P256K1 = "ECC_SECG_P256K1"
    SYMMETRIC_DEFAULT = "SYMMETRIC_DEFAULT"
    HMAC_224 = "HMAC_224"
    HMAC_256 = "HMAC_256"
    HMAC_384 = "HMAC_384"
    HMAC_512 = "HMAC_512"
    SM2 = "SM2"
    ML_DSA_44 = "ML_DSA_44"
    ML_DSA_65 = "ML_DSA_65"
    ML_DSA_87 = "ML_DSA_87"
    ECC_NIST_EDWARDS25519 = "ECC_NIST_EDWARDS25519"


class KeyState:
    """KeyState enum values."""

    CREATING = "Creating"
    ENABLED = "Enabled"
    DISABLED = "Disabled"
    PENDINGDELETION = "PendingDeletion"
    PENDINGIMPORT = "PendingImport"
    PENDINGREPLICADELETION = "PendingReplicaDeletion"
    UNAVAILABLE = "Unavailable"
    UPDATING = "Updating"


class KeyUsageType:
    """KeyUsageType enum values."""

    SIGN_VERIFY = "SIGN_VERIFY"
    ENCRYPT_DECRYPT = "ENCRYPT_DECRYPT"
    GENERATE_VERIFY_MAC = "GENERATE_VERIFY_MAC"
    KEY_AGREEMENT = "KEY_AGREEMENT"


class MacAlgorithmSpec:
    """MacAlgorithmSpec enum values."""

    HMAC_SHA_224 = "HMAC_SHA_224"
    HMAC_SHA_256 = "HMAC_SHA_256"
    HMAC_SHA_384 = "HMAC_SHA_384"
    HMAC_SHA_512 = "HMAC_SHA_512"


class MessageType:
    """MessageType enum values."""

    RAW = "RAW"
    DIGEST = "DIGEST"
    EXTERNAL_MU = "EXTERNAL_MU"


class MultiRegionKeyType:
    """MultiRegionKeyType enum values."""

    PRIMARY = "PRIMARY"
    REPLICA = "REPLICA"


class OriginType:
    """OriginType enum values."""

    AWS_KMS = "AWS_KMS"
    EXTERNAL = "EXTERNAL"
    AWS_CLOUDHSM = "AWS_CLOUDHSM"
    EXTERNAL_KEY_STORE = "EXTERNAL_KEY_STORE"


class RotationType:
    """RotationType enum values."""

    AUTOMATIC = "AUTOMATIC"
    ON_DEMAND = "ON_DEMAND"


class SigningAlgorithmSpec:
    """SigningAlgorithmSpec enum values."""

    RSASSA_PSS_SHA_256 = "RSASSA_PSS_SHA_256"
    RSASSA_PSS_SHA_384 = "RSASSA_PSS_SHA_384"
    RSASSA_PSS_SHA_512 = "RSASSA_PSS_SHA_512"
    RSASSA_PKCS1_V1_5_SHA_256 = "RSASSA_PKCS1_V1_5_SHA_256"
    RSASSA_PKCS1_V1_5_SHA_384 = "RSASSA_PKCS1_V1_5_SHA_384"
    RSASSA_PKCS1_V1_5_SHA_512 = "RSASSA_PKCS1_V1_5_SHA_512"
    ECDSA_SHA_256 = "ECDSA_SHA_256"
    ECDSA_SHA_384 = "ECDSA_SHA_384"
    ECDSA_SHA_512 = "ECDSA_SHA_512"
    SM2DSA = "SM2DSA"
    ML_DSA_SHAKE_256 = "ML_DSA_SHAKE_256"
    ED25519_SHA_512 = "ED25519_SHA_512"
    ED25519_PH_SHA_512 = "ED25519_PH_SHA_512"


class WrappingKeySpec:
    """WrappingKeySpec enum values."""

    RSA_2048 = "RSA_2048"
    RSA_3072 = "RSA_3072"
    RSA_4096 = "RSA_4096"
    SM2 = "SM2"


class XksProxyConnectivityType:
    """XksProxyConnectivityType enum values."""

    PUBLIC_ENDPOINT = "PUBLIC_ENDPOINT"
    VPC_ENDPOINT_SERVICE = "VPC_ENDPOINT_SERVICE"


# Convenient aliases for enum values
RSAES_PKCS1_V1_5 = AlgorithmSpec.RSAES_PKCS1_V1_5
RSAES_OAEP_SHA_1 = AlgorithmSpec.RSAES_OAEP_SHA_1
RSAES_OAEP_SHA_256 = AlgorithmSpec.RSAES_OAEP_SHA_256
RSA_AES_KEY_WRAP_SHA_1 = AlgorithmSpec.RSA_AES_KEY_WRAP_SHA_1
RSA_AES_KEY_WRAP_SHA_256 = AlgorithmSpec.RSA_AES_KEY_WRAP_SHA_256
SM2PKE = AlgorithmSpec.SM2PKE
INVALID_CREDENTIALS = ConnectionErrorCodeType.INVALID_CREDENTIALS
CLUSTER_NOT_FOUND = ConnectionErrorCodeType.CLUSTER_NOT_FOUND
NETWORK_ERRORS = ConnectionErrorCodeType.NETWORK_ERRORS
INTERNAL_ERROR = ConnectionErrorCodeType.INTERNAL_ERROR
INSUFFICIENT_CLOUDHSM_HSMS = ConnectionErrorCodeType.INSUFFICIENT_CLOUDHSM_HSMS
USER_LOCKED_OUT = ConnectionErrorCodeType.USER_LOCKED_OUT
USER_NOT_FOUND = ConnectionErrorCodeType.USER_NOT_FOUND
USER_LOGGED_IN = ConnectionErrorCodeType.USER_LOGGED_IN
SUBNET_NOT_FOUND = ConnectionErrorCodeType.SUBNET_NOT_FOUND
INSUFFICIENT_FREE_ADDRESSES_IN_SUBNET = ConnectionErrorCodeType.INSUFFICIENT_FREE_ADDRESSES_IN_SUBNET
XKS_PROXY_ACCESS_DENIED = ConnectionErrorCodeType.XKS_PROXY_ACCESS_DENIED
XKS_PROXY_NOT_REACHABLE = ConnectionErrorCodeType.XKS_PROXY_NOT_REACHABLE
XKS_VPC_ENDPOINT_SERVICE_NOT_FOUND = ConnectionErrorCodeType.XKS_VPC_ENDPOINT_SERVICE_NOT_FOUND
XKS_PROXY_INVALID_RESPONSE = ConnectionErrorCodeType.XKS_PROXY_INVALID_RESPONSE
XKS_PROXY_INVALID_CONFIGURATION = ConnectionErrorCodeType.XKS_PROXY_INVALID_CONFIGURATION
XKS_VPC_ENDPOINT_SERVICE_INVALID_CONFIGURATION = ConnectionErrorCodeType.XKS_VPC_ENDPOINT_SERVICE_INVALID_CONFIGURATION
XKS_PROXY_TIMED_OUT = ConnectionErrorCodeType.XKS_PROXY_TIMED_OUT
XKS_PROXY_INVALID_TLS_CONFIGURATION = ConnectionErrorCodeType.XKS_PROXY_INVALID_TLS_CONFIGURATION
CONNECTED = ConnectionStateType.CONNECTED
CONNECTING = ConnectionStateType.CONNECTING
FAILED = ConnectionStateType.FAILED
DISCONNECTED = ConnectionStateType.DISCONNECTED
DISCONNECTING = ConnectionStateType.DISCONNECTING
AWS_CLOUDHSM = CustomKeyStoreType.AWS_CLOUDHSM
EXTERNAL_KEY_STORE = CustomKeyStoreType.EXTERNAL_KEY_STORE
RSA_2048 = CustomerMasterKeySpec.RSA_2048
RSA_3072 = CustomerMasterKeySpec.RSA_3072
RSA_4096 = CustomerMasterKeySpec.RSA_4096
ECC_NIST_P256 = CustomerMasterKeySpec.ECC_NIST_P256
ECC_NIST_P384 = CustomerMasterKeySpec.ECC_NIST_P384
ECC_NIST_P521 = CustomerMasterKeySpec.ECC_NIST_P521
ECC_SECG_P256K1 = CustomerMasterKeySpec.ECC_SECG_P256K1
SYMMETRIC_DEFAULT = CustomerMasterKeySpec.SYMMETRIC_DEFAULT
HMAC_224 = CustomerMasterKeySpec.HMAC_224
HMAC_256 = CustomerMasterKeySpec.HMAC_256
HMAC_384 = CustomerMasterKeySpec.HMAC_384
HMAC_512 = CustomerMasterKeySpec.HMAC_512
SM2 = CustomerMasterKeySpec.SM2
RSA_2048 = DataKeyPairSpec.RSA_2048
RSA_3072 = DataKeyPairSpec.RSA_3072
RSA_4096 = DataKeyPairSpec.RSA_4096
ECC_NIST_P256 = DataKeyPairSpec.ECC_NIST_P256
ECC_NIST_P384 = DataKeyPairSpec.ECC_NIST_P384
ECC_NIST_P521 = DataKeyPairSpec.ECC_NIST_P521
ECC_SECG_P256K1 = DataKeyPairSpec.ECC_SECG_P256K1
SM2 = DataKeyPairSpec.SM2
ECC_NIST_EDWARDS25519 = DataKeyPairSpec.ECC_NIST_EDWARDS25519
AES_256 = DataKeySpec.AES_256
AES_128 = DataKeySpec.AES_128
SYMMETRIC_DEFAULT = EncryptionAlgorithmSpec.SYMMETRIC_DEFAULT
RSAES_OAEP_SHA_1 = EncryptionAlgorithmSpec.RSAES_OAEP_SHA_1
RSAES_OAEP_SHA_256 = EncryptionAlgorithmSpec.RSAES_OAEP_SHA_256
SM2PKE = EncryptionAlgorithmSpec.SM2PKE
KEY_MATERIAL_EXPIRES = ExpirationModelType.KEY_MATERIAL_EXPIRES
KEY_MATERIAL_DOES_NOT_EXPIRE = ExpirationModelType.KEY_MATERIAL_DOES_NOT_EXPIRE
DECRYPT = GrantOperation.DECRYPT
ENCRYPT = GrantOperation.ENCRYPT
GENERATEDATAKEY = GrantOperation.GENERATEDATAKEY
GENERATEDATAKEYWITHOUTPLAINTEXT = GrantOperation.GENERATEDATAKEYWITHOUTPLAINTEXT
REENCRYPTFROM = GrantOperation.REENCRYPTFROM
REENCRYPTTO = GrantOperation.REENCRYPTTO
SIGN = GrantOperation.SIGN
VERIFY = GrantOperation.VERIFY
GETPUBLICKEY = GrantOperation.GETPUBLICKEY
CREATEGRANT = GrantOperation.CREATEGRANT
RETIREGRANT = GrantOperation.RETIREGRANT
DESCRIBEKEY = GrantOperation.DESCRIBEKEY
GENERATEDATAKEYPAIR = GrantOperation.GENERATEDATAKEYPAIR
GENERATEDATAKEYPAIRWITHOUTPLAINTEXT = GrantOperation.GENERATEDATAKEYPAIRWITHOUTPLAINTEXT
GENERATEMAC = GrantOperation.GENERATEMAC
VERIFYMAC = GrantOperation.VERIFYMAC
DERIVESHAREDSECRET = GrantOperation.DERIVESHAREDSECRET
IMPORTED = ImportState.IMPORTED
PENDING_IMPORT = ImportState.PENDING_IMPORT
NEW_KEY_MATERIAL = ImportType.NEW_KEY_MATERIAL
EXISTING_KEY_MATERIAL = ImportType.EXISTING_KEY_MATERIAL
ALL_KEY_MATERIAL = IncludeKeyMaterial.ALL_KEY_MATERIAL
ROTATIONS_ONLY = IncludeKeyMaterial.ROTATIONS_ONLY
ECDH = KeyAgreementAlgorithmSpec.ECDH
RSAES_OAEP_SHA_256 = KeyEncryptionMechanism.RSAES_OAEP_SHA_256
AWS = KeyManagerType.AWS
CUSTOMER = KeyManagerType.CUSTOMER
NON_CURRENT = KeyMaterialState.NON_CURRENT
CURRENT = KeyMaterialState.CURRENT
PENDING_ROTATION = KeyMaterialState.PENDING_ROTATION
PENDING_MULTI_REGION_IMPORT_AND_ROTATION = KeyMaterialState.PENDING_MULTI_REGION_IMPORT_AND_ROTATION
RSA_2048 = KeySpec.RSA_2048
RSA_3072 = KeySpec.RSA_3072
RSA_4096 = KeySpec.RSA_4096
ECC_NIST_P256 = KeySpec.ECC_NIST_P256
ECC_NIST_P384 = KeySpec.ECC_NIST_P384
ECC_NIST_P521 = KeySpec.ECC_NIST_P521
ECC_SECG_P256K1 = KeySpec.ECC_SECG_P256K1
SYMMETRIC_DEFAULT = KeySpec.SYMMETRIC_DEFAULT
HMAC_224 = KeySpec.HMAC_224
HMAC_256 = KeySpec.HMAC_256
HMAC_384 = KeySpec.HMAC_384
HMAC_512 = KeySpec.HMAC_512
SM2 = KeySpec.SM2
ML_DSA_44 = KeySpec.ML_DSA_44
ML_DSA_65 = KeySpec.ML_DSA_65
ML_DSA_87 = KeySpec.ML_DSA_87
ECC_NIST_EDWARDS25519 = KeySpec.ECC_NIST_EDWARDS25519
CREATING = KeyState.CREATING
ENABLED = KeyState.ENABLED
DISABLED = KeyState.DISABLED
PENDINGDELETION = KeyState.PENDINGDELETION
PENDINGIMPORT = KeyState.PENDINGIMPORT
PENDINGREPLICADELETION = KeyState.PENDINGREPLICADELETION
UNAVAILABLE = KeyState.UNAVAILABLE
UPDATING = KeyState.UPDATING
SIGN_VERIFY = KeyUsageType.SIGN_VERIFY
ENCRYPT_DECRYPT = KeyUsageType.ENCRYPT_DECRYPT
GENERATE_VERIFY_MAC = KeyUsageType.GENERATE_VERIFY_MAC
KEY_AGREEMENT = KeyUsageType.KEY_AGREEMENT
HMAC_SHA_224 = MacAlgorithmSpec.HMAC_SHA_224
HMAC_SHA_256 = MacAlgorithmSpec.HMAC_SHA_256
HMAC_SHA_384 = MacAlgorithmSpec.HMAC_SHA_384
HMAC_SHA_512 = MacAlgorithmSpec.HMAC_SHA_512
RAW = MessageType.RAW
DIGEST = MessageType.DIGEST
EXTERNAL_MU = MessageType.EXTERNAL_MU
PRIMARY = MultiRegionKeyType.PRIMARY
REPLICA = MultiRegionKeyType.REPLICA
AWS_KMS = OriginType.AWS_KMS
EXTERNAL = OriginType.EXTERNAL
AWS_CLOUDHSM = OriginType.AWS_CLOUDHSM
EXTERNAL_KEY_STORE = OriginType.EXTERNAL_KEY_STORE
AUTOMATIC = RotationType.AUTOMATIC
ON_DEMAND = RotationType.ON_DEMAND
RSASSA_PSS_SHA_256 = SigningAlgorithmSpec.RSASSA_PSS_SHA_256
RSASSA_PSS_SHA_384 = SigningAlgorithmSpec.RSASSA_PSS_SHA_384
RSASSA_PSS_SHA_512 = SigningAlgorithmSpec.RSASSA_PSS_SHA_512
RSASSA_PKCS1_V1_5_SHA_256 = SigningAlgorithmSpec.RSASSA_PKCS1_V1_5_SHA_256
RSASSA_PKCS1_V1_5_SHA_384 = SigningAlgorithmSpec.RSASSA_PKCS1_V1_5_SHA_384
RSASSA_PKCS1_V1_5_SHA_512 = SigningAlgorithmSpec.RSASSA_PKCS1_V1_5_SHA_512
ECDSA_SHA_256 = SigningAlgorithmSpec.ECDSA_SHA_256
ECDSA_SHA_384 = SigningAlgorithmSpec.ECDSA_SHA_384
ECDSA_SHA_512 = SigningAlgorithmSpec.ECDSA_SHA_512
SM2DSA = SigningAlgorithmSpec.SM2DSA
ML_DSA_SHAKE_256 = SigningAlgorithmSpec.ML_DSA_SHAKE_256
ED25519_SHA_512 = SigningAlgorithmSpec.ED25519_SHA_512
ED25519_PH_SHA_512 = SigningAlgorithmSpec.ED25519_PH_SHA_512
RSA_2048 = WrappingKeySpec.RSA_2048
RSA_3072 = WrappingKeySpec.RSA_3072
RSA_4096 = WrappingKeySpec.RSA_4096
SM2 = WrappingKeySpec.SM2
PUBLIC_ENDPOINT = XksProxyConnectivityType.PUBLIC_ENDPOINT
VPC_ENDPOINT_SERVICE = XksProxyConnectivityType.VPC_ENDPOINT_SERVICE


@dataclass
class Alias(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-a"""

    resource_type: ClassVar[str] = "AWS::KMS::Alias"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    alias_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.target_key_id is not None:
            # Serialize target_key_id (handle intrinsic functions)
            if hasattr(self.target_key_id, 'to_dict'):
                props["TargetKeyId"] = self.target_key_id.to_dict()
            elif isinstance(self.target_key_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_key_id
                ]
            else:
                props["TargetKeyId"] = self.target_key_id

        if self.alias_name is not None:
            # Serialize alias_name (handle intrinsic functions)
            if hasattr(self.alias_name, 'to_dict'):
                props["AliasName"] = self.alias_name.to_dict()
            elif isinstance(self.alias_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['AliasName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.alias_name
                ]
            else:
                props["AliasName"] = self.alias_name

        return props



@dataclass
class Key(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-k"""

    resource_type: ClassVar[str] = "AWS::KMS::Key"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    origin: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    multi_region: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    pending_window_in_days: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    bypass_policy_lockout_safety_check: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    key_policy: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    key_spec: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    key_usage: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rotation_period_in_days: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_key_rotation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.origin is not None:
            # Serialize origin (handle intrinsic functions)
            if hasattr(self.origin, 'to_dict'):
                props["Origin"] = self.origin.to_dict()
            elif isinstance(self.origin, list):
                # Serialize list items (may contain intrinsic functions)
                props['Origin'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.origin
                ]
            else:
                props["Origin"] = self.origin

        if self.multi_region is not None:
            # Serialize multi_region (handle intrinsic functions)
            if hasattr(self.multi_region, 'to_dict'):
                props["MultiRegion"] = self.multi_region.to_dict()
            elif isinstance(self.multi_region, list):
                # Serialize list items (may contain intrinsic functions)
                props['MultiRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.multi_region
                ]
            else:
                props["MultiRegion"] = self.multi_region

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.pending_window_in_days is not None:
            # Serialize pending_window_in_days (handle intrinsic functions)
            if hasattr(self.pending_window_in_days, 'to_dict'):
                props["PendingWindowInDays"] = self.pending_window_in_days.to_dict()
            elif isinstance(self.pending_window_in_days, list):
                # Serialize list items (may contain intrinsic functions)
                props['PendingWindowInDays'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pending_window_in_days
                ]
            else:
                props["PendingWindowInDays"] = self.pending_window_in_days

        if self.bypass_policy_lockout_safety_check is not None:
            # Serialize bypass_policy_lockout_safety_check (handle intrinsic functions)
            if hasattr(self.bypass_policy_lockout_safety_check, 'to_dict'):
                props["BypassPolicyLockoutSafetyCheck"] = self.bypass_policy_lockout_safety_check.to_dict()
            elif isinstance(self.bypass_policy_lockout_safety_check, list):
                # Serialize list items (may contain intrinsic functions)
                props['BypassPolicyLockoutSafetyCheck'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bypass_policy_lockout_safety_check
                ]
            else:
                props["BypassPolicyLockoutSafetyCheck"] = self.bypass_policy_lockout_safety_check

        if self.key_policy is not None:
            # Serialize key_policy (handle intrinsic functions)
            if hasattr(self.key_policy, 'to_dict'):
                props["KeyPolicy"] = self.key_policy.to_dict()
            elif isinstance(self.key_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['KeyPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_policy
                ]
            else:
                props["KeyPolicy"] = self.key_policy

        if self.key_spec is not None:
            # Serialize key_spec (handle intrinsic functions)
            if hasattr(self.key_spec, 'to_dict'):
                props["KeySpec"] = self.key_spec.to_dict()
            elif isinstance(self.key_spec, list):
                # Serialize list items (may contain intrinsic functions)
                props['KeySpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_spec
                ]
            else:
                props["KeySpec"] = self.key_spec

        if self.enabled is not None:
            # Serialize enabled (handle intrinsic functions)
            if hasattr(self.enabled, 'to_dict'):
                props["Enabled"] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props["Enabled"] = self.enabled

        if self.key_usage is not None:
            # Serialize key_usage (handle intrinsic functions)
            if hasattr(self.key_usage, 'to_dict'):
                props["KeyUsage"] = self.key_usage.to_dict()
            elif isinstance(self.key_usage, list):
                # Serialize list items (may contain intrinsic functions)
                props['KeyUsage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_usage
                ]
            else:
                props["KeyUsage"] = self.key_usage

        if self.rotation_period_in_days is not None:
            # Serialize rotation_period_in_days (handle intrinsic functions)
            if hasattr(self.rotation_period_in_days, 'to_dict'):
                props["RotationPeriodInDays"] = self.rotation_period_in_days.to_dict()
            elif isinstance(self.rotation_period_in_days, list):
                # Serialize list items (may contain intrinsic functions)
                props['RotationPeriodInDays'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rotation_period_in_days
                ]
            else:
                props["RotationPeriodInDays"] = self.rotation_period_in_days

        if self.enable_key_rotation is not None:
            # Serialize enable_key_rotation (handle intrinsic functions)
            if hasattr(self.enable_key_rotation, 'to_dict'):
                props["EnableKeyRotation"] = self.enable_key_rotation.to_dict()
            elif isinstance(self.enable_key_rotation, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableKeyRotation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_key_rotation
                ]
            else:
                props["EnableKeyRotation"] = self.enable_key_rotation

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_key_id(self) -> GetAtt:
        """Get the KeyId attribute."""
        return self.get_att("KeyId")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class ReplicaKey(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-kms-r"""

    resource_type: ClassVar[str] = "AWS::KMS::ReplicaKey"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    pending_window_in_days: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    key_policy: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    primary_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.pending_window_in_days is not None:
            # Serialize pending_window_in_days (handle intrinsic functions)
            if hasattr(self.pending_window_in_days, 'to_dict'):
                props["PendingWindowInDays"] = self.pending_window_in_days.to_dict()
            elif isinstance(self.pending_window_in_days, list):
                # Serialize list items (may contain intrinsic functions)
                props['PendingWindowInDays'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pending_window_in_days
                ]
            else:
                props["PendingWindowInDays"] = self.pending_window_in_days

        if self.key_policy is not None:
            # Serialize key_policy (handle intrinsic functions)
            if hasattr(self.key_policy, 'to_dict'):
                props["KeyPolicy"] = self.key_policy.to_dict()
            elif isinstance(self.key_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['KeyPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key_policy
                ]
            else:
                props["KeyPolicy"] = self.key_policy

        if self.primary_key_arn is not None:
            # Serialize primary_key_arn (handle intrinsic functions)
            if hasattr(self.primary_key_arn, 'to_dict'):
                props["PrimaryKeyArn"] = self.primary_key_arn.to_dict()
            elif isinstance(self.primary_key_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrimaryKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.primary_key_arn
                ]
            else:
                props["PrimaryKeyArn"] = self.primary_key_arn

        if self.enabled is not None:
            # Serialize enabled (handle intrinsic functions)
            if hasattr(self.enabled, 'to_dict'):
                props["Enabled"] = self.enabled.to_dict()
            elif isinstance(self.enabled, list):
                # Serialize list items (may contain intrinsic functions)
                props['Enabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enabled
                ]
            else:
                props["Enabled"] = self.enabled

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_key_id(self) -> GetAtt:
        """Get the KeyId attribute."""
        return self.get_att("KeyId")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")



