"""
AWS CloudFormation SSM Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:39

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service SSM
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AccessRequestStatus:
    """AccessRequestStatus enum values."""

    APPROVED = "Approved"
    REJECTED = "Rejected"
    REVOKED = "Revoked"
    EXPIRED = "Expired"
    PENDING = "Pending"


class AccessType:
    """AccessType enum values."""

    STANDARD = "Standard"
    JUSTINTIME = "JustInTime"


class AssociationComplianceSeverity:
    """AssociationComplianceSeverity enum values."""

    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    UNSPECIFIED = "UNSPECIFIED"


class AssociationExecutionFilterKey:
    """AssociationExecutionFilterKey enum values."""

    EXECUTIONID = "ExecutionId"
    STATUS = "Status"
    CREATEDTIME = "CreatedTime"


class AssociationExecutionTargetsFilterKey:
    """AssociationExecutionTargetsFilterKey enum values."""

    STATUS = "Status"
    RESOURCEID = "ResourceId"
    RESOURCETYPE = "ResourceType"


class AssociationFilterKey:
    """AssociationFilterKey enum values."""

    INSTANCEID = "InstanceId"
    NAME = "Name"
    ASSOCIATIONID = "AssociationId"
    ASSOCIATIONSTATUSNAME = "AssociationStatusName"
    LASTEXECUTEDBEFORE = "LastExecutedBefore"
    LASTEXECUTEDAFTER = "LastExecutedAfter"
    ASSOCIATIONNAME = "AssociationName"
    RESOURCEGROUPNAME = "ResourceGroupName"


class AssociationFilterOperatorType:
    """AssociationFilterOperatorType enum values."""

    EQUAL = "EQUAL"
    LESS_THAN = "LESS_THAN"
    GREATER_THAN = "GREATER_THAN"


class AssociationStatusName:
    """AssociationStatusName enum values."""

    PENDING = "Pending"
    SUCCESS = "Success"
    FAILED = "Failed"


class AssociationSyncCompliance:
    """AssociationSyncCompliance enum values."""

    AUTO = "AUTO"
    MANUAL = "MANUAL"


class AttachmentHashType:
    """AttachmentHashType enum values."""

    SHA256 = "Sha256"


class AttachmentsSourceKey:
    """AttachmentsSourceKey enum values."""

    SOURCEURL = "SourceUrl"
    S3FILEURL = "S3FileUrl"
    ATTACHMENTREFERENCE = "AttachmentReference"


class AutomationExecutionFilterKey:
    """AutomationExecutionFilterKey enum values."""

    DOCUMENTNAMEPREFIX = "DocumentNamePrefix"
    EXECUTIONSTATUS = "ExecutionStatus"
    EXECUTIONID = "ExecutionId"
    PARENTEXECUTIONID = "ParentExecutionId"
    CURRENTACTION = "CurrentAction"
    STARTTIMEBEFORE = "StartTimeBefore"
    STARTTIMEAFTER = "StartTimeAfter"
    AUTOMATIONTYPE = "AutomationType"
    TAGKEY = "TagKey"
    TARGETRESOURCEGROUP = "TargetResourceGroup"
    AUTOMATIONSUBTYPE = "AutomationSubtype"
    OPSITEMID = "OpsItemId"


class AutomationExecutionStatus:
    """AutomationExecutionStatus enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    WAITING = "Waiting"
    SUCCESS = "Success"
    TIMEDOUT = "TimedOut"
    CANCELLING = "Cancelling"
    CANCELLED = "Cancelled"
    FAILED = "Failed"
    PENDINGAPPROVAL = "PendingApproval"
    APPROVED = "Approved"
    REJECTED = "Rejected"
    SCHEDULED = "Scheduled"
    RUNBOOKINPROGRESS = "RunbookInProgress"
    PENDINGCHANGECALENDAROVERRIDE = "PendingChangeCalendarOverride"
    CHANGECALENDAROVERRIDEAPPROVED = "ChangeCalendarOverrideApproved"
    CHANGECALENDAROVERRIDEREJECTED = "ChangeCalendarOverrideRejected"
    COMPLETEDWITHSUCCESS = "CompletedWithSuccess"
    COMPLETEDWITHFAILURE = "CompletedWithFailure"
    EXITED = "Exited"


class AutomationSubtype:
    """AutomationSubtype enum values."""

    CHANGEREQUEST = "ChangeRequest"
    ACCESSREQUEST = "AccessRequest"


class AutomationType:
    """AutomationType enum values."""

    CROSSACCOUNT = "CrossAccount"
    LOCAL = "Local"


class CalendarState:
    """CalendarState enum values."""

    OPEN = "OPEN"
    CLOSED = "CLOSED"


class CommandFilterKey:
    """CommandFilterKey enum values."""

    INVOKEDAFTER = "InvokedAfter"
    INVOKEDBEFORE = "InvokedBefore"
    STATUS = "Status"
    EXECUTIONSTAGE = "ExecutionStage"
    DOCUMENTNAME = "DocumentName"


class CommandInvocationStatus:
    """CommandInvocationStatus enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    DELAYED = "Delayed"
    SUCCESS = "Success"
    CANCELLED = "Cancelled"
    TIMEDOUT = "TimedOut"
    FAILED = "Failed"
    CANCELLING = "Cancelling"


class CommandPluginStatus:
    """CommandPluginStatus enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    SUCCESS = "Success"
    TIMEDOUT = "TimedOut"
    CANCELLED = "Cancelled"
    FAILED = "Failed"


class CommandStatus:
    """CommandStatus enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    SUCCESS = "Success"
    CANCELLED = "Cancelled"
    FAILED = "Failed"
    TIMEDOUT = "TimedOut"
    CANCELLING = "Cancelling"


class ComplianceQueryOperatorType:
    """ComplianceQueryOperatorType enum values."""

    EQUAL = "EQUAL"
    NOT_EQUAL = "NOT_EQUAL"
    BEGIN_WITH = "BEGIN_WITH"
    LESS_THAN = "LESS_THAN"
    GREATER_THAN = "GREATER_THAN"


class ComplianceSeverity:
    """ComplianceSeverity enum values."""

    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFORMATIONAL = "INFORMATIONAL"
    UNSPECIFIED = "UNSPECIFIED"


class ComplianceStatus:
    """ComplianceStatus enum values."""

    COMPLIANT = "COMPLIANT"
    NON_COMPLIANT = "NON_COMPLIANT"


class ComplianceUploadType:
    """ComplianceUploadType enum values."""

    COMPLETE = "COMPLETE"
    PARTIAL = "PARTIAL"


class ConnectionStatus:
    """ConnectionStatus enum values."""

    CONNECTED = "connected"
    NOTCONNECTED = "notconnected"


class DescribeActivationsFilterKeys:
    """DescribeActivationsFilterKeys enum values."""

    ACTIVATIONIDS = "ActivationIds"
    DEFAULTINSTANCENAME = "DefaultInstanceName"
    IAMROLE = "IamRole"


class DocumentFilterKey:
    """DocumentFilterKey enum values."""

    NAME = "Name"
    OWNER = "Owner"
    PLATFORMTYPES = "PlatformTypes"
    DOCUMENTTYPE = "DocumentType"


class DocumentFormat:
    """DocumentFormat enum values."""

    YAML = "YAML"
    JSON = "JSON"
    TEXT = "TEXT"


class DocumentHashType:
    """DocumentHashType enum values."""

    SHA256 = "Sha256"
    SHA1 = "Sha1"


class DocumentMetadataEnum:
    """DocumentMetadataEnum enum values."""

    DOCUMENTREVIEWS = "DocumentReviews"


class DocumentParameterType:
    """DocumentParameterType enum values."""

    STRING = "String"
    STRINGLIST = "StringList"


class DocumentPermissionType:
    """DocumentPermissionType enum values."""

    SHARE = "Share"


class DocumentReviewAction:
    """DocumentReviewAction enum values."""

    SENDFORREVIEW = "SendForReview"
    UPDATEREVIEW = "UpdateReview"
    APPROVE = "Approve"
    REJECT = "Reject"


class DocumentReviewCommentType:
    """DocumentReviewCommentType enum values."""

    COMMENT = "Comment"


class DocumentStatus:
    """DocumentStatus enum values."""

    CREATING = "Creating"
    ACTIVE = "Active"
    UPDATING = "Updating"
    DELETING = "Deleting"
    FAILED = "Failed"


class DocumentType:
    """DocumentType enum values."""

    COMMAND = "Command"
    POLICY = "Policy"
    AUTOMATION = "Automation"
    SESSION = "Session"
    PACKAGE = "Package"
    APPLICATIONCONFIGURATION = "ApplicationConfiguration"
    APPLICATIONCONFIGURATIONSCHEMA = "ApplicationConfigurationSchema"
    DEPLOYMENTSTRATEGY = "DeploymentStrategy"
    CHANGECALENDAR = "ChangeCalendar"
    AUTOMATION_CHANGETEMPLATE = "Automation.ChangeTemplate"
    PROBLEMANALYSIS = "ProblemAnalysis"
    PROBLEMANALYSISTEMPLATE = "ProblemAnalysisTemplate"
    CLOUDFORMATION = "CloudFormation"
    CONFORMANCEPACKTEMPLATE = "ConformancePackTemplate"
    QUICKSETUP = "QuickSetup"
    MANUALAPPROVALPOLICY = "ManualApprovalPolicy"
    AUTOAPPROVALPOLICY = "AutoApprovalPolicy"


class ExecutionMode:
    """ExecutionMode enum values."""

    AUTO = "Auto"
    INTERACTIVE = "Interactive"


class ExecutionPreviewStatus:
    """ExecutionPreviewStatus enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    SUCCESS = "Success"
    FAILED = "Failed"


class ExternalAlarmState:
    """ExternalAlarmState enum values."""

    UNKNOWN = "UNKNOWN"
    ALARM = "ALARM"


class Fault:
    """Fault enum values."""

    CLIENT = "Client"
    SERVER = "Server"
    UNKNOWN = "Unknown"


class ImpactType:
    """ImpactType enum values."""

    MUTATING = "Mutating"
    NONMUTATING = "NonMutating"
    UNDETERMINED = "Undetermined"


class InstanceInformationFilterKey:
    """InstanceInformationFilterKey enum values."""

    INSTANCEIDS = "InstanceIds"
    AGENTVERSION = "AgentVersion"
    PINGSTATUS = "PingStatus"
    PLATFORMTYPES = "PlatformTypes"
    ACTIVATIONIDS = "ActivationIds"
    IAMROLE = "IamRole"
    RESOURCETYPE = "ResourceType"
    ASSOCIATIONSTATUS = "AssociationStatus"


class InstancePatchStateOperatorType:
    """InstancePatchStateOperatorType enum values."""

    EQUAL = "Equal"
    NOTEQUAL = "NotEqual"
    LESSTHAN = "LessThan"
    GREATERTHAN = "GreaterThan"


class InstancePropertyFilterKey:
    """InstancePropertyFilterKey enum values."""

    INSTANCEIDS = "InstanceIds"
    AGENTVERSION = "AgentVersion"
    PINGSTATUS = "PingStatus"
    PLATFORMTYPES = "PlatformTypes"
    DOCUMENTNAME = "DocumentName"
    ACTIVATIONIDS = "ActivationIds"
    IAMROLE = "IamRole"
    RESOURCETYPE = "ResourceType"
    ASSOCIATIONSTATUS = "AssociationStatus"


class InstancePropertyFilterOperator:
    """InstancePropertyFilterOperator enum values."""

    EQUAL = "Equal"
    NOTEQUAL = "NotEqual"
    BEGINWITH = "BeginWith"
    LESSTHAN = "LessThan"
    GREATERTHAN = "GreaterThan"


class InventoryAttributeDataType:
    """InventoryAttributeDataType enum values."""

    STRING = "string"
    NUMBER = "number"


class InventoryDeletionStatus:
    """InventoryDeletionStatus enum values."""

    INPROGRESS = "InProgress"
    COMPLETE = "Complete"


class InventoryQueryOperatorType:
    """InventoryQueryOperatorType enum values."""

    EQUAL = "Equal"
    NOTEQUAL = "NotEqual"
    BEGINWITH = "BeginWith"
    LESSTHAN = "LessThan"
    GREATERTHAN = "GreaterThan"
    EXISTS = "Exists"


class InventorySchemaDeleteOption:
    """InventorySchemaDeleteOption enum values."""

    DISABLESCHEMA = "DisableSchema"
    DELETESCHEMA = "DeleteSchema"


class LastResourceDataSyncStatus:
    """LastResourceDataSyncStatus enum values."""

    SUCCESSFUL = "Successful"
    FAILED = "Failed"
    INPROGRESS = "InProgress"


class MaintenanceWindowExecutionStatus:
    """MaintenanceWindowExecutionStatus enum values."""

    PENDING = "PENDING"
    IN_PROGRESS = "IN_PROGRESS"
    SUCCESS = "SUCCESS"
    FAILED = "FAILED"
    TIMED_OUT = "TIMED_OUT"
    CANCELLING = "CANCELLING"
    CANCELLED = "CANCELLED"
    SKIPPED_OVERLAPPING = "SKIPPED_OVERLAPPING"


class MaintenanceWindowResourceType:
    """MaintenanceWindowResourceType enum values."""

    INSTANCE = "INSTANCE"
    RESOURCE_GROUP = "RESOURCE_GROUP"


class MaintenanceWindowTaskCutoffBehavior:
    """MaintenanceWindowTaskCutoffBehavior enum values."""

    CONTINUE_TASK = "CONTINUE_TASK"
    CANCEL_TASK = "CANCEL_TASK"


class MaintenanceWindowTaskType:
    """MaintenanceWindowTaskType enum values."""

    RUN_COMMAND = "RUN_COMMAND"
    AUTOMATION = "AUTOMATION"
    STEP_FUNCTIONS = "STEP_FUNCTIONS"
    LAMBDA = "LAMBDA"


class ManagedStatus:
    """ManagedStatus enum values."""

    ALL = "All"
    MANAGED = "Managed"
    UNMANAGED = "Unmanaged"


class NodeAggregatorType:
    """NodeAggregatorType enum values."""

    COUNT = "Count"


class NodeAttributeName:
    """NodeAttributeName enum values."""

    AGENTVERSION = "AgentVersion"
    PLATFORMNAME = "PlatformName"
    PLATFORMTYPE = "PlatformType"
    PLATFORMVERSION = "PlatformVersion"
    REGION = "Region"
    RESOURCETYPE = "ResourceType"


class NodeFilterKey:
    """NodeFilterKey enum values."""

    AGENTTYPE = "AgentType"
    AGENTVERSION = "AgentVersion"
    COMPUTERNAME = "ComputerName"
    INSTANCEID = "InstanceId"
    INSTANCESTATUS = "InstanceStatus"
    IPADDRESS = "IpAddress"
    MANAGEDSTATUS = "ManagedStatus"
    PLATFORMNAME = "PlatformName"
    PLATFORMTYPE = "PlatformType"
    PLATFORMVERSION = "PlatformVersion"
    RESOURCETYPE = "ResourceType"
    ORGANIZATIONALUNITID = "OrganizationalUnitId"
    ORGANIZATIONALUNITPATH = "OrganizationalUnitPath"
    REGION = "Region"
    ACCOUNTID = "AccountId"


class NodeFilterOperatorType:
    """NodeFilterOperatorType enum values."""

    EQUAL = "Equal"
    NOTEQUAL = "NotEqual"
    BEGINWITH = "BeginWith"


class NodeTypeName:
    """NodeTypeName enum values."""

    INSTANCE = "Instance"


class NotificationEvent:
    """NotificationEvent enum values."""

    ALL = "All"
    INPROGRESS = "InProgress"
    SUCCESS = "Success"
    TIMEDOUT = "TimedOut"
    CANCELLED = "Cancelled"
    FAILED = "Failed"


class NotificationType:
    """NotificationType enum values."""

    COMMAND = "Command"
    INVOCATION = "Invocation"


class OperatingSystem:
    """OperatingSystem enum values."""

    WINDOWS = "WINDOWS"
    AMAZON_LINUX = "AMAZON_LINUX"
    AMAZON_LINUX_2 = "AMAZON_LINUX_2"
    AMAZON_LINUX_2022 = "AMAZON_LINUX_2022"
    UBUNTU = "UBUNTU"
    REDHAT_ENTERPRISE_LINUX = "REDHAT_ENTERPRISE_LINUX"
    SUSE = "SUSE"
    CENTOS = "CENTOS"
    ORACLE_LINUX = "ORACLE_LINUX"
    DEBIAN = "DEBIAN"
    MACOS = "MACOS"
    RASPBIAN = "RASPBIAN"
    ROCKY_LINUX = "ROCKY_LINUX"
    ALMA_LINUX = "ALMA_LINUX"
    AMAZON_LINUX_2023 = "AMAZON_LINUX_2023"


class OpsFilterOperatorType:
    """OpsFilterOperatorType enum values."""

    EQUAL = "Equal"
    NOTEQUAL = "NotEqual"
    BEGINWITH = "BeginWith"
    LESSTHAN = "LessThan"
    GREATERTHAN = "GreaterThan"
    EXISTS = "Exists"


class OpsItemDataType:
    """OpsItemDataType enum values."""

    SEARCHABLESTRING = "SearchableString"
    STRING = "String"


class OpsItemEventFilterKey:
    """OpsItemEventFilterKey enum values."""

    OPSITEMID = "OpsItemId"


class OpsItemEventFilterOperator:
    """OpsItemEventFilterOperator enum values."""

    EQUAL = "Equal"


class OpsItemFilterKey:
    """OpsItemFilterKey enum values."""

    STATUS = "Status"
    CREATEDBY = "CreatedBy"
    SOURCE = "Source"
    PRIORITY = "Priority"
    TITLE = "Title"
    OPSITEMID = "OpsItemId"
    CREATEDTIME = "CreatedTime"
    LASTMODIFIEDTIME = "LastModifiedTime"
    ACTUALSTARTTIME = "ActualStartTime"
    ACTUALENDTIME = "ActualEndTime"
    PLANNEDSTARTTIME = "PlannedStartTime"
    PLANNEDENDTIME = "PlannedEndTime"
    OPERATIONALDATA = "OperationalData"
    OPERATIONALDATAKEY = "OperationalDataKey"
    OPERATIONALDATAVALUE = "OperationalDataValue"
    RESOURCEID = "ResourceId"
    AUTOMATIONID = "AutomationId"
    CATEGORY = "Category"
    SEVERITY = "Severity"
    OPSITEMTYPE = "OpsItemType"
    ACCESSREQUESTBYREQUESTERARN = "AccessRequestByRequesterArn"
    ACCESSREQUESTBYREQUESTERID = "AccessRequestByRequesterId"
    ACCESSREQUESTBYAPPROVERARN = "AccessRequestByApproverArn"
    ACCESSREQUESTBYAPPROVERID = "AccessRequestByApproverId"
    ACCESSREQUESTBYSOURCEACCOUNTID = "AccessRequestBySourceAccountId"
    ACCESSREQUESTBYSOURCEOPSITEMID = "AccessRequestBySourceOpsItemId"
    ACCESSREQUESTBYSOURCEREGION = "AccessRequestBySourceRegion"
    ACCESSREQUESTBYISREPLICA = "AccessRequestByIsReplica"
    ACCESSREQUESTBYTARGETRESOURCEID = "AccessRequestByTargetResourceId"
    CHANGEREQUESTBYREQUESTERARN = "ChangeRequestByRequesterArn"
    CHANGEREQUESTBYREQUESTERNAME = "ChangeRequestByRequesterName"
    CHANGEREQUESTBYAPPROVERARN = "ChangeRequestByApproverArn"
    CHANGEREQUESTBYAPPROVERNAME = "ChangeRequestByApproverName"
    CHANGEREQUESTBYTEMPLATE = "ChangeRequestByTemplate"
    CHANGEREQUESTBYTARGETSRESOURCEGROUP = "ChangeRequestByTargetsResourceGroup"
    INSIGHTBYTYPE = "InsightByType"
    ACCOUNTID = "AccountId"


class OpsItemFilterOperator:
    """OpsItemFilterOperator enum values."""

    EQUAL = "Equal"
    CONTAINS = "Contains"
    GREATERTHAN = "GreaterThan"
    LESSTHAN = "LessThan"


class OpsItemRelatedItemsFilterKey:
    """OpsItemRelatedItemsFilterKey enum values."""

    RESOURCETYPE = "ResourceType"
    ASSOCIATIONID = "AssociationId"
    RESOURCEURI = "ResourceUri"


class OpsItemRelatedItemsFilterOperator:
    """OpsItemRelatedItemsFilterOperator enum values."""

    EQUAL = "Equal"


class OpsItemStatus:
    """OpsItemStatus enum values."""

    OPEN = "Open"
    INPROGRESS = "InProgress"
    RESOLVED = "Resolved"
    PENDING = "Pending"
    TIMEDOUT = "TimedOut"
    CANCELLING = "Cancelling"
    CANCELLED = "Cancelled"
    FAILED = "Failed"
    COMPLETEDWITHSUCCESS = "CompletedWithSuccess"
    COMPLETEDWITHFAILURE = "CompletedWithFailure"
    SCHEDULED = "Scheduled"
    RUNBOOKINPROGRESS = "RunbookInProgress"
    PENDINGCHANGECALENDAROVERRIDE = "PendingChangeCalendarOverride"
    CHANGECALENDAROVERRIDEAPPROVED = "ChangeCalendarOverrideApproved"
    CHANGECALENDAROVERRIDEREJECTED = "ChangeCalendarOverrideRejected"
    PENDINGAPPROVAL = "PendingApproval"
    APPROVED = "Approved"
    REVOKED = "Revoked"
    REJECTED = "Rejected"
    CLOSED = "Closed"


class ParameterTier:
    """ParameterTier enum values."""

    STANDARD = "Standard"
    ADVANCED = "Advanced"
    INTELLIGENT_TIERING = "Intelligent-Tiering"


class ParameterType:
    """ParameterType enum values."""

    STRING = "String"
    STRINGLIST = "StringList"
    SECURESTRING = "SecureString"


class ParametersFilterKey:
    """ParametersFilterKey enum values."""

    NAME = "Name"
    TYPE = "Type"
    KEYID = "KeyId"


class PatchAction:
    """PatchAction enum values."""

    ALLOW_AS_DEPENDENCY = "ALLOW_AS_DEPENDENCY"
    BLOCK = "BLOCK"


class PatchComplianceDataState:
    """PatchComplianceDataState enum values."""

    INSTALLED = "INSTALLED"
    INSTALLED_OTHER = "INSTALLED_OTHER"
    INSTALLED_PENDING_REBOOT = "INSTALLED_PENDING_REBOOT"
    INSTALLED_REJECTED = "INSTALLED_REJECTED"
    MISSING = "MISSING"
    NOT_APPLICABLE = "NOT_APPLICABLE"
    FAILED = "FAILED"
    AVAILABLE_SECURITY_UPDATE = "AVAILABLE_SECURITY_UPDATE"


class PatchComplianceLevel:
    """PatchComplianceLevel enum values."""

    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFORMATIONAL = "INFORMATIONAL"
    UNSPECIFIED = "UNSPECIFIED"


class PatchComplianceStatus:
    """PatchComplianceStatus enum values."""

    COMPLIANT = "COMPLIANT"
    NON_COMPLIANT = "NON_COMPLIANT"


class PatchDeploymentStatus:
    """PatchDeploymentStatus enum values."""

    APPROVED = "APPROVED"
    PENDING_APPROVAL = "PENDING_APPROVAL"
    EXPLICIT_APPROVED = "EXPLICIT_APPROVED"
    EXPLICIT_REJECTED = "EXPLICIT_REJECTED"


class PatchFilterKey:
    """PatchFilterKey enum values."""

    ARCH = "ARCH"
    ADVISORY_ID = "ADVISORY_ID"
    BUGZILLA_ID = "BUGZILLA_ID"
    PATCH_SET = "PATCH_SET"
    PRODUCT = "PRODUCT"
    PRODUCT_FAMILY = "PRODUCT_FAMILY"
    CLASSIFICATION = "CLASSIFICATION"
    CVE_ID = "CVE_ID"
    EPOCH = "EPOCH"
    MSRC_SEVERITY = "MSRC_SEVERITY"
    NAME = "NAME"
    PATCH_ID = "PATCH_ID"
    SECTION = "SECTION"
    PRIORITY = "PRIORITY"
    REPOSITORY = "REPOSITORY"
    RELEASE = "RELEASE"
    SEVERITY = "SEVERITY"
    SECURITY = "SECURITY"
    VERSION = "VERSION"


class PatchOperationType:
    """PatchOperationType enum values."""

    SCAN = "Scan"
    INSTALL = "Install"


class PatchProperty:
    """PatchProperty enum values."""

    PRODUCT = "PRODUCT"
    PRODUCT_FAMILY = "PRODUCT_FAMILY"
    CLASSIFICATION = "CLASSIFICATION"
    MSRC_SEVERITY = "MSRC_SEVERITY"
    PRIORITY = "PRIORITY"
    SEVERITY = "SEVERITY"


class PatchSet:
    """PatchSet enum values."""

    OS = "OS"
    APPLICATION = "APPLICATION"


class PingStatus:
    """PingStatus enum values."""

    ONLINE = "Online"
    CONNECTIONLOST = "ConnectionLost"
    INACTIVE = "Inactive"


class PlatformType:
    """PlatformType enum values."""

    WINDOWS = "Windows"
    LINUX = "Linux"
    MACOS = "MacOS"


class RebootOption:
    """RebootOption enum values."""

    REBOOTIFNEEDED = "RebootIfNeeded"
    NOREBOOT = "NoReboot"


class ResourceDataSyncS3Format:
    """ResourceDataSyncS3Format enum values."""

    JSONSERDE = "JsonSerDe"


class ResourceType:
    """ResourceType enum values."""

    MANAGEDINSTANCE = "ManagedInstance"
    EC2INSTANCE = "EC2Instance"


class ResourceTypeForTagging:
    """ResourceTypeForTagging enum values."""

    DOCUMENT = "Document"
    MANAGEDINSTANCE = "ManagedInstance"
    MAINTENANCEWINDOW = "MaintenanceWindow"
    PARAMETER = "Parameter"
    PATCHBASELINE = "PatchBaseline"
    OPSITEM = "OpsItem"
    OPSMETADATA = "OpsMetadata"
    AUTOMATION = "Automation"
    ASSOCIATION = "Association"


class ReviewStatus:
    """ReviewStatus enum values."""

    APPROVED = "APPROVED"
    NOT_REVIEWED = "NOT_REVIEWED"
    PENDING = "PENDING"
    REJECTED = "REJECTED"


class SessionFilterKey:
    """SessionFilterKey enum values."""

    INVOKEDAFTER = "InvokedAfter"
    INVOKEDBEFORE = "InvokedBefore"
    TARGET = "Target"
    OWNER = "Owner"
    STATUS = "Status"
    SESSIONID = "SessionId"
    ACCESSTYPE = "AccessType"


class SessionState:
    """SessionState enum values."""

    ACTIVE = "Active"
    HISTORY = "History"


class SessionStatus:
    """SessionStatus enum values."""

    CONNECTED = "Connected"
    CONNECTING = "Connecting"
    DISCONNECTED = "Disconnected"
    TERMINATED = "Terminated"
    TERMINATING = "Terminating"
    FAILED = "Failed"


class SignalType:
    """SignalType enum values."""

    APPROVE = "Approve"
    REJECT = "Reject"
    STARTSTEP = "StartStep"
    STOPSTEP = "StopStep"
    RESUME = "Resume"
    REVOKE = "Revoke"


class SourceType:
    """SourceType enum values."""

    AWS_EC2_INSTANCE = "AWS::EC2::Instance"
    AWS_IOT_THING = "AWS::IoT::Thing"
    AWS_SSM_MANAGEDINSTANCE = "AWS::SSM::ManagedInstance"


class StepExecutionFilterKey:
    """StepExecutionFilterKey enum values."""

    STARTTIMEBEFORE = "StartTimeBefore"
    STARTTIMEAFTER = "StartTimeAfter"
    STEPEXECUTIONSTATUS = "StepExecutionStatus"
    STEPEXECUTIONID = "StepExecutionId"
    STEPNAME = "StepName"
    ACTION = "Action"
    PARENTSTEPEXECUTIONID = "ParentStepExecutionId"
    PARENTSTEPITERATION = "ParentStepIteration"
    PARENTSTEPITERATORVALUE = "ParentStepIteratorValue"


class StopType:
    """StopType enum values."""

    COMPLETE = "Complete"
    CANCEL = "Cancel"


# Convenient aliases for enum values
APPROVED = AccessRequestStatus.APPROVED
REJECTED = AccessRequestStatus.REJECTED
REVOKED = AccessRequestStatus.REVOKED
EXPIRED = AccessRequestStatus.EXPIRED
PENDING = AccessRequestStatus.PENDING
STANDARD = AccessType.STANDARD
JUSTINTIME = AccessType.JUSTINTIME
CRITICAL = AssociationComplianceSeverity.CRITICAL
HIGH = AssociationComplianceSeverity.HIGH
MEDIUM = AssociationComplianceSeverity.MEDIUM
LOW = AssociationComplianceSeverity.LOW
UNSPECIFIED = AssociationComplianceSeverity.UNSPECIFIED
EXECUTIONID = AssociationExecutionFilterKey.EXECUTIONID
STATUS = AssociationExecutionFilterKey.STATUS
CREATEDTIME = AssociationExecutionFilterKey.CREATEDTIME
STATUS = AssociationExecutionTargetsFilterKey.STATUS
RESOURCEID = AssociationExecutionTargetsFilterKey.RESOURCEID
RESOURCETYPE = AssociationExecutionTargetsFilterKey.RESOURCETYPE
INSTANCEID = AssociationFilterKey.INSTANCEID
NAME = AssociationFilterKey.NAME
ASSOCIATIONID = AssociationFilterKey.ASSOCIATIONID
ASSOCIATIONSTATUSNAME = AssociationFilterKey.ASSOCIATIONSTATUSNAME
LASTEXECUTEDBEFORE = AssociationFilterKey.LASTEXECUTEDBEFORE
LASTEXECUTEDAFTER = AssociationFilterKey.LASTEXECUTEDAFTER
ASSOCIATIONNAME = AssociationFilterKey.ASSOCIATIONNAME
RESOURCEGROUPNAME = AssociationFilterKey.RESOURCEGROUPNAME
EQUAL = AssociationFilterOperatorType.EQUAL
LESS_THAN = AssociationFilterOperatorType.LESS_THAN
GREATER_THAN = AssociationFilterOperatorType.GREATER_THAN
PENDING = AssociationStatusName.PENDING
SUCCESS = AssociationStatusName.SUCCESS
FAILED = AssociationStatusName.FAILED
AUTO = AssociationSyncCompliance.AUTO
MANUAL = AssociationSyncCompliance.MANUAL
SHA256 = AttachmentHashType.SHA256
SOURCEURL = AttachmentsSourceKey.SOURCEURL
S3FILEURL = AttachmentsSourceKey.S3FILEURL
ATTACHMENTREFERENCE = AttachmentsSourceKey.ATTACHMENTREFERENCE
DOCUMENTNAMEPREFIX = AutomationExecutionFilterKey.DOCUMENTNAMEPREFIX
EXECUTIONSTATUS = AutomationExecutionFilterKey.EXECUTIONSTATUS
EXECUTIONID = AutomationExecutionFilterKey.EXECUTIONID
PARENTEXECUTIONID = AutomationExecutionFilterKey.PARENTEXECUTIONID
CURRENTACTION = AutomationExecutionFilterKey.CURRENTACTION
STARTTIMEBEFORE = AutomationExecutionFilterKey.STARTTIMEBEFORE
STARTTIMEAFTER = AutomationExecutionFilterKey.STARTTIMEAFTER
AUTOMATIONTYPE = AutomationExecutionFilterKey.AUTOMATIONTYPE
TAGKEY = AutomationExecutionFilterKey.TAGKEY
TARGETRESOURCEGROUP = AutomationExecutionFilterKey.TARGETRESOURCEGROUP
AUTOMATIONSUBTYPE = AutomationExecutionFilterKey.AUTOMATIONSUBTYPE
OPSITEMID = AutomationExecutionFilterKey.OPSITEMID
PENDING = AutomationExecutionStatus.PENDING
INPROGRESS = AutomationExecutionStatus.INPROGRESS
WAITING = AutomationExecutionStatus.WAITING
SUCCESS = AutomationExecutionStatus.SUCCESS
TIMEDOUT = AutomationExecutionStatus.TIMEDOUT
CANCELLING = AutomationExecutionStatus.CANCELLING
CANCELLED = AutomationExecutionStatus.CANCELLED
FAILED = AutomationExecutionStatus.FAILED
PENDINGAPPROVAL = AutomationExecutionStatus.PENDINGAPPROVAL
APPROVED = AutomationExecutionStatus.APPROVED
REJECTED = AutomationExecutionStatus.REJECTED
SCHEDULED = AutomationExecutionStatus.SCHEDULED
RUNBOOKINPROGRESS = AutomationExecutionStatus.RUNBOOKINPROGRESS
PENDINGCHANGECALENDAROVERRIDE = AutomationExecutionStatus.PENDINGCHANGECALENDAROVERRIDE
CHANGECALENDAROVERRIDEAPPROVED = AutomationExecutionStatus.CHANGECALENDAROVERRIDEAPPROVED
CHANGECALENDAROVERRIDEREJECTED = AutomationExecutionStatus.CHANGECALENDAROVERRIDEREJECTED
COMPLETEDWITHSUCCESS = AutomationExecutionStatus.COMPLETEDWITHSUCCESS
COMPLETEDWITHFAILURE = AutomationExecutionStatus.COMPLETEDWITHFAILURE
EXITED = AutomationExecutionStatus.EXITED
CHANGEREQUEST = AutomationSubtype.CHANGEREQUEST
ACCESSREQUEST = AutomationSubtype.ACCESSREQUEST
CROSSACCOUNT = AutomationType.CROSSACCOUNT
LOCAL = AutomationType.LOCAL
OPEN = CalendarState.OPEN
CLOSED = CalendarState.CLOSED
INVOKEDAFTER = CommandFilterKey.INVOKEDAFTER
INVOKEDBEFORE = CommandFilterKey.INVOKEDBEFORE
STATUS = CommandFilterKey.STATUS
EXECUTIONSTAGE = CommandFilterKey.EXECUTIONSTAGE
DOCUMENTNAME = CommandFilterKey.DOCUMENTNAME
PENDING = CommandInvocationStatus.PENDING
INPROGRESS = CommandInvocationStatus.INPROGRESS
DELAYED = CommandInvocationStatus.DELAYED
SUCCESS = CommandInvocationStatus.SUCCESS
CANCELLED = CommandInvocationStatus.CANCELLED
TIMEDOUT = CommandInvocationStatus.TIMEDOUT
FAILED = CommandInvocationStatus.FAILED
CANCELLING = CommandInvocationStatus.CANCELLING
PENDING = CommandPluginStatus.PENDING
INPROGRESS = CommandPluginStatus.INPROGRESS
SUCCESS = CommandPluginStatus.SUCCESS
TIMEDOUT = CommandPluginStatus.TIMEDOUT
CANCELLED = CommandPluginStatus.CANCELLED
FAILED = CommandPluginStatus.FAILED
PENDING = CommandStatus.PENDING
INPROGRESS = CommandStatus.INPROGRESS
SUCCESS = CommandStatus.SUCCESS
CANCELLED = CommandStatus.CANCELLED
FAILED = CommandStatus.FAILED
TIMEDOUT = CommandStatus.TIMEDOUT
CANCELLING = CommandStatus.CANCELLING
EQUAL = ComplianceQueryOperatorType.EQUAL
NOT_EQUAL = ComplianceQueryOperatorType.NOT_EQUAL
BEGIN_WITH = ComplianceQueryOperatorType.BEGIN_WITH
LESS_THAN = ComplianceQueryOperatorType.LESS_THAN
GREATER_THAN = ComplianceQueryOperatorType.GREATER_THAN
CRITICAL = ComplianceSeverity.CRITICAL
HIGH = ComplianceSeverity.HIGH
MEDIUM = ComplianceSeverity.MEDIUM
LOW = ComplianceSeverity.LOW
INFORMATIONAL = ComplianceSeverity.INFORMATIONAL
UNSPECIFIED = ComplianceSeverity.UNSPECIFIED
COMPLIANT = ComplianceStatus.COMPLIANT
NON_COMPLIANT = ComplianceStatus.NON_COMPLIANT
COMPLETE = ComplianceUploadType.COMPLETE
PARTIAL = ComplianceUploadType.PARTIAL
CONNECTED = ConnectionStatus.CONNECTED
NOTCONNECTED = ConnectionStatus.NOTCONNECTED
ACTIVATIONIDS = DescribeActivationsFilterKeys.ACTIVATIONIDS
DEFAULTINSTANCENAME = DescribeActivationsFilterKeys.DEFAULTINSTANCENAME
IAMROLE = DescribeActivationsFilterKeys.IAMROLE
NAME = DocumentFilterKey.NAME
OWNER = DocumentFilterKey.OWNER
PLATFORMTYPES = DocumentFilterKey.PLATFORMTYPES
DOCUMENTTYPE = DocumentFilterKey.DOCUMENTTYPE
YAML = DocumentFormat.YAML
JSON = DocumentFormat.JSON
TEXT = DocumentFormat.TEXT
SHA256 = DocumentHashType.SHA256
SHA1 = DocumentHashType.SHA1
DOCUMENTREVIEWS = DocumentMetadataEnum.DOCUMENTREVIEWS
STRING = DocumentParameterType.STRING
STRINGLIST = DocumentParameterType.STRINGLIST
SHARE = DocumentPermissionType.SHARE
SENDFORREVIEW = DocumentReviewAction.SENDFORREVIEW
UPDATEREVIEW = DocumentReviewAction.UPDATEREVIEW
APPROVE = DocumentReviewAction.APPROVE
REJECT = DocumentReviewAction.REJECT
COMMENT = DocumentReviewCommentType.COMMENT
CREATING = DocumentStatus.CREATING
ACTIVE = DocumentStatus.ACTIVE
UPDATING = DocumentStatus.UPDATING
DELETING = DocumentStatus.DELETING
FAILED = DocumentStatus.FAILED
COMMAND = DocumentType.COMMAND
POLICY = DocumentType.POLICY
AUTOMATION = DocumentType.AUTOMATION
SESSION = DocumentType.SESSION
PACKAGE = DocumentType.PACKAGE
APPLICATIONCONFIGURATION = DocumentType.APPLICATIONCONFIGURATION
APPLICATIONCONFIGURATIONSCHEMA = DocumentType.APPLICATIONCONFIGURATIONSCHEMA
DEPLOYMENTSTRATEGY = DocumentType.DEPLOYMENTSTRATEGY
CHANGECALENDAR = DocumentType.CHANGECALENDAR
AUTOMATION_CHANGETEMPLATE = DocumentType.AUTOMATION_CHANGETEMPLATE
PROBLEMANALYSIS = DocumentType.PROBLEMANALYSIS
PROBLEMANALYSISTEMPLATE = DocumentType.PROBLEMANALYSISTEMPLATE
CLOUDFORMATION = DocumentType.CLOUDFORMATION
CONFORMANCEPACKTEMPLATE = DocumentType.CONFORMANCEPACKTEMPLATE
QUICKSETUP = DocumentType.QUICKSETUP
MANUALAPPROVALPOLICY = DocumentType.MANUALAPPROVALPOLICY
AUTOAPPROVALPOLICY = DocumentType.AUTOAPPROVALPOLICY
AUTO = ExecutionMode.AUTO
INTERACTIVE = ExecutionMode.INTERACTIVE
PENDING = ExecutionPreviewStatus.PENDING
INPROGRESS = ExecutionPreviewStatus.INPROGRESS
SUCCESS = ExecutionPreviewStatus.SUCCESS
FAILED = ExecutionPreviewStatus.FAILED
UNKNOWN = ExternalAlarmState.UNKNOWN
ALARM = ExternalAlarmState.ALARM
CLIENT = Fault.CLIENT
SERVER = Fault.SERVER
UNKNOWN = Fault.UNKNOWN
MUTATING = ImpactType.MUTATING
NONMUTATING = ImpactType.NONMUTATING
UNDETERMINED = ImpactType.UNDETERMINED
INSTANCEIDS = InstanceInformationFilterKey.INSTANCEIDS
AGENTVERSION = InstanceInformationFilterKey.AGENTVERSION
PINGSTATUS = InstanceInformationFilterKey.PINGSTATUS
PLATFORMTYPES = InstanceInformationFilterKey.PLATFORMTYPES
ACTIVATIONIDS = InstanceInformationFilterKey.ACTIVATIONIDS
IAMROLE = InstanceInformationFilterKey.IAMROLE
RESOURCETYPE = InstanceInformationFilterKey.RESOURCETYPE
ASSOCIATIONSTATUS = InstanceInformationFilterKey.ASSOCIATIONSTATUS
EQUAL = InstancePatchStateOperatorType.EQUAL
NOTEQUAL = InstancePatchStateOperatorType.NOTEQUAL
LESSTHAN = InstancePatchStateOperatorType.LESSTHAN
GREATERTHAN = InstancePatchStateOperatorType.GREATERTHAN
INSTANCEIDS = InstancePropertyFilterKey.INSTANCEIDS
AGENTVERSION = InstancePropertyFilterKey.AGENTVERSION
PINGSTATUS = InstancePropertyFilterKey.PINGSTATUS
PLATFORMTYPES = InstancePropertyFilterKey.PLATFORMTYPES
DOCUMENTNAME = InstancePropertyFilterKey.DOCUMENTNAME
ACTIVATIONIDS = InstancePropertyFilterKey.ACTIVATIONIDS
IAMROLE = InstancePropertyFilterKey.IAMROLE
RESOURCETYPE = InstancePropertyFilterKey.RESOURCETYPE
ASSOCIATIONSTATUS = InstancePropertyFilterKey.ASSOCIATIONSTATUS
EQUAL = InstancePropertyFilterOperator.EQUAL
NOTEQUAL = InstancePropertyFilterOperator.NOTEQUAL
BEGINWITH = InstancePropertyFilterOperator.BEGINWITH
LESSTHAN = InstancePropertyFilterOperator.LESSTHAN
GREATERTHAN = InstancePropertyFilterOperator.GREATERTHAN
STRING = InventoryAttributeDataType.STRING
NUMBER = InventoryAttributeDataType.NUMBER
INPROGRESS = InventoryDeletionStatus.INPROGRESS
COMPLETE = InventoryDeletionStatus.COMPLETE
EQUAL = InventoryQueryOperatorType.EQUAL
NOTEQUAL = InventoryQueryOperatorType.NOTEQUAL
BEGINWITH = InventoryQueryOperatorType.BEGINWITH
LESSTHAN = InventoryQueryOperatorType.LESSTHAN
GREATERTHAN = InventoryQueryOperatorType.GREATERTHAN
EXISTS = InventoryQueryOperatorType.EXISTS
DISABLESCHEMA = InventorySchemaDeleteOption.DISABLESCHEMA
DELETESCHEMA = InventorySchemaDeleteOption.DELETESCHEMA
SUCCESSFUL = LastResourceDataSyncStatus.SUCCESSFUL
FAILED = LastResourceDataSyncStatus.FAILED
INPROGRESS = LastResourceDataSyncStatus.INPROGRESS
PENDING = MaintenanceWindowExecutionStatus.PENDING
IN_PROGRESS = MaintenanceWindowExecutionStatus.IN_PROGRESS
SUCCESS = MaintenanceWindowExecutionStatus.SUCCESS
FAILED = MaintenanceWindowExecutionStatus.FAILED
TIMED_OUT = MaintenanceWindowExecutionStatus.TIMED_OUT
CANCELLING = MaintenanceWindowExecutionStatus.CANCELLING
CANCELLED = MaintenanceWindowExecutionStatus.CANCELLED
SKIPPED_OVERLAPPING = MaintenanceWindowExecutionStatus.SKIPPED_OVERLAPPING
INSTANCE = MaintenanceWindowResourceType.INSTANCE
RESOURCE_GROUP = MaintenanceWindowResourceType.RESOURCE_GROUP
CONTINUE_TASK = MaintenanceWindowTaskCutoffBehavior.CONTINUE_TASK
CANCEL_TASK = MaintenanceWindowTaskCutoffBehavior.CANCEL_TASK
RUN_COMMAND = MaintenanceWindowTaskType.RUN_COMMAND
AUTOMATION = MaintenanceWindowTaskType.AUTOMATION
STEP_FUNCTIONS = MaintenanceWindowTaskType.STEP_FUNCTIONS
LAMBDA = MaintenanceWindowTaskType.LAMBDA
ALL = ManagedStatus.ALL
MANAGED = ManagedStatus.MANAGED
UNMANAGED = ManagedStatus.UNMANAGED
COUNT = NodeAggregatorType.COUNT
AGENTVERSION = NodeAttributeName.AGENTVERSION
PLATFORMNAME = NodeAttributeName.PLATFORMNAME
PLATFORMTYPE = NodeAttributeName.PLATFORMTYPE
PLATFORMVERSION = NodeAttributeName.PLATFORMVERSION
REGION = NodeAttributeName.REGION
RESOURCETYPE = NodeAttributeName.RESOURCETYPE
AGENTTYPE = NodeFilterKey.AGENTTYPE
AGENTVERSION = NodeFilterKey.AGENTVERSION
COMPUTERNAME = NodeFilterKey.COMPUTERNAME
INSTANCEID = NodeFilterKey.INSTANCEID
INSTANCESTATUS = NodeFilterKey.INSTANCESTATUS
IPADDRESS = NodeFilterKey.IPADDRESS
MANAGEDSTATUS = NodeFilterKey.MANAGEDSTATUS
PLATFORMNAME = NodeFilterKey.PLATFORMNAME
PLATFORMTYPE = NodeFilterKey.PLATFORMTYPE
PLATFORMVERSION = NodeFilterKey.PLATFORMVERSION
RESOURCETYPE = NodeFilterKey.RESOURCETYPE
ORGANIZATIONALUNITID = NodeFilterKey.ORGANIZATIONALUNITID
ORGANIZATIONALUNITPATH = NodeFilterKey.ORGANIZATIONALUNITPATH
REGION = NodeFilterKey.REGION
ACCOUNTID = NodeFilterKey.ACCOUNTID
EQUAL = NodeFilterOperatorType.EQUAL
NOTEQUAL = NodeFilterOperatorType.NOTEQUAL
BEGINWITH = NodeFilterOperatorType.BEGINWITH
INSTANCE = NodeTypeName.INSTANCE
ALL = NotificationEvent.ALL
INPROGRESS = NotificationEvent.INPROGRESS
SUCCESS = NotificationEvent.SUCCESS
TIMEDOUT = NotificationEvent.TIMEDOUT
CANCELLED = NotificationEvent.CANCELLED
FAILED = NotificationEvent.FAILED
COMMAND = NotificationType.COMMAND
INVOCATION = NotificationType.INVOCATION
WINDOWS = OperatingSystem.WINDOWS
AMAZON_LINUX = OperatingSystem.AMAZON_LINUX
AMAZON_LINUX_2 = OperatingSystem.AMAZON_LINUX_2
AMAZON_LINUX_2022 = OperatingSystem.AMAZON_LINUX_2022
UBUNTU = OperatingSystem.UBUNTU
REDHAT_ENTERPRISE_LINUX = OperatingSystem.REDHAT_ENTERPRISE_LINUX
SUSE = OperatingSystem.SUSE
CENTOS = OperatingSystem.CENTOS
ORACLE_LINUX = OperatingSystem.ORACLE_LINUX
DEBIAN = OperatingSystem.DEBIAN
MACOS = OperatingSystem.MACOS
RASPBIAN = OperatingSystem.RASPBIAN
ROCKY_LINUX = OperatingSystem.ROCKY_LINUX
ALMA_LINUX = OperatingSystem.ALMA_LINUX
AMAZON_LINUX_2023 = OperatingSystem.AMAZON_LINUX_2023
EQUAL = OpsFilterOperatorType.EQUAL
NOTEQUAL = OpsFilterOperatorType.NOTEQUAL
BEGINWITH = OpsFilterOperatorType.BEGINWITH
LESSTHAN = OpsFilterOperatorType.LESSTHAN
GREATERTHAN = OpsFilterOperatorType.GREATERTHAN
EXISTS = OpsFilterOperatorType.EXISTS
SEARCHABLESTRING = OpsItemDataType.SEARCHABLESTRING
STRING = OpsItemDataType.STRING
OPSITEMID = OpsItemEventFilterKey.OPSITEMID
EQUAL = OpsItemEventFilterOperator.EQUAL
STATUS = OpsItemFilterKey.STATUS
CREATEDBY = OpsItemFilterKey.CREATEDBY
SOURCE = OpsItemFilterKey.SOURCE
PRIORITY = OpsItemFilterKey.PRIORITY
TITLE = OpsItemFilterKey.TITLE
OPSITEMID = OpsItemFilterKey.OPSITEMID
CREATEDTIME = OpsItemFilterKey.CREATEDTIME
LASTMODIFIEDTIME = OpsItemFilterKey.LASTMODIFIEDTIME
ACTUALSTARTTIME = OpsItemFilterKey.ACTUALSTARTTIME
ACTUALENDTIME = OpsItemFilterKey.ACTUALENDTIME
PLANNEDSTARTTIME = OpsItemFilterKey.PLANNEDSTARTTIME
PLANNEDENDTIME = OpsItemFilterKey.PLANNEDENDTIME
OPERATIONALDATA = OpsItemFilterKey.OPERATIONALDATA
OPERATIONALDATAKEY = OpsItemFilterKey.OPERATIONALDATAKEY
OPERATIONALDATAVALUE = OpsItemFilterKey.OPERATIONALDATAVALUE
RESOURCEID = OpsItemFilterKey.RESOURCEID
AUTOMATIONID = OpsItemFilterKey.AUTOMATIONID
CATEGORY = OpsItemFilterKey.CATEGORY
SEVERITY = OpsItemFilterKey.SEVERITY
OPSITEMTYPE = OpsItemFilterKey.OPSITEMTYPE
ACCESSREQUESTBYREQUESTERARN = OpsItemFilterKey.ACCESSREQUESTBYREQUESTERARN
ACCESSREQUESTBYREQUESTERID = OpsItemFilterKey.ACCESSREQUESTBYREQUESTERID
ACCESSREQUESTBYAPPROVERARN = OpsItemFilterKey.ACCESSREQUESTBYAPPROVERARN
ACCESSREQUESTBYAPPROVERID = OpsItemFilterKey.ACCESSREQUESTBYAPPROVERID
ACCESSREQUESTBYSOURCEACCOUNTID = OpsItemFilterKey.ACCESSREQUESTBYSOURCEACCOUNTID
ACCESSREQUESTBYSOURCEOPSITEMID = OpsItemFilterKey.ACCESSREQUESTBYSOURCEOPSITEMID
ACCESSREQUESTBYSOURCEREGION = OpsItemFilterKey.ACCESSREQUESTBYSOURCEREGION
ACCESSREQUESTBYISREPLICA = OpsItemFilterKey.ACCESSREQUESTBYISREPLICA
ACCESSREQUESTBYTARGETRESOURCEID = OpsItemFilterKey.ACCESSREQUESTBYTARGETRESOURCEID
CHANGEREQUESTBYREQUESTERARN = OpsItemFilterKey.CHANGEREQUESTBYREQUESTERARN
CHANGEREQUESTBYREQUESTERNAME = OpsItemFilterKey.CHANGEREQUESTBYREQUESTERNAME
CHANGEREQUESTBYAPPROVERARN = OpsItemFilterKey.CHANGEREQUESTBYAPPROVERARN
CHANGEREQUESTBYAPPROVERNAME = OpsItemFilterKey.CHANGEREQUESTBYAPPROVERNAME
CHANGEREQUESTBYTEMPLATE = OpsItemFilterKey.CHANGEREQUESTBYTEMPLATE
CHANGEREQUESTBYTARGETSRESOURCEGROUP = OpsItemFilterKey.CHANGEREQUESTBYTARGETSRESOURCEGROUP
INSIGHTBYTYPE = OpsItemFilterKey.INSIGHTBYTYPE
ACCOUNTID = OpsItemFilterKey.ACCOUNTID
EQUAL = OpsItemFilterOperator.EQUAL
CONTAINS = OpsItemFilterOperator.CONTAINS
GREATERTHAN = OpsItemFilterOperator.GREATERTHAN
LESSTHAN = OpsItemFilterOperator.LESSTHAN
RESOURCETYPE = OpsItemRelatedItemsFilterKey.RESOURCETYPE
ASSOCIATIONID = OpsItemRelatedItemsFilterKey.ASSOCIATIONID
RESOURCEURI = OpsItemRelatedItemsFilterKey.RESOURCEURI
EQUAL = OpsItemRelatedItemsFilterOperator.EQUAL
OPEN = OpsItemStatus.OPEN
INPROGRESS = OpsItemStatus.INPROGRESS
RESOLVED = OpsItemStatus.RESOLVED
PENDING = OpsItemStatus.PENDING
TIMEDOUT = OpsItemStatus.TIMEDOUT
CANCELLING = OpsItemStatus.CANCELLING
CANCELLED = OpsItemStatus.CANCELLED
FAILED = OpsItemStatus.FAILED
COMPLETEDWITHSUCCESS = OpsItemStatus.COMPLETEDWITHSUCCESS
COMPLETEDWITHFAILURE = OpsItemStatus.COMPLETEDWITHFAILURE
SCHEDULED = OpsItemStatus.SCHEDULED
RUNBOOKINPROGRESS = OpsItemStatus.RUNBOOKINPROGRESS
PENDINGCHANGECALENDAROVERRIDE = OpsItemStatus.PENDINGCHANGECALENDAROVERRIDE
CHANGECALENDAROVERRIDEAPPROVED = OpsItemStatus.CHANGECALENDAROVERRIDEAPPROVED
CHANGECALENDAROVERRIDEREJECTED = OpsItemStatus.CHANGECALENDAROVERRIDEREJECTED
PENDINGAPPROVAL = OpsItemStatus.PENDINGAPPROVAL
APPROVED = OpsItemStatus.APPROVED
REVOKED = OpsItemStatus.REVOKED
REJECTED = OpsItemStatus.REJECTED
CLOSED = OpsItemStatus.CLOSED
STANDARD = ParameterTier.STANDARD
ADVANCED = ParameterTier.ADVANCED
INTELLIGENT_TIERING = ParameterTier.INTELLIGENT_TIERING
STRING = ParameterType.STRING
STRINGLIST = ParameterType.STRINGLIST
SECURESTRING = ParameterType.SECURESTRING
NAME = ParametersFilterKey.NAME
TYPE = ParametersFilterKey.TYPE
KEYID = ParametersFilterKey.KEYID
ALLOW_AS_DEPENDENCY = PatchAction.ALLOW_AS_DEPENDENCY
BLOCK = PatchAction.BLOCK
INSTALLED = PatchComplianceDataState.INSTALLED
INSTALLED_OTHER = PatchComplianceDataState.INSTALLED_OTHER
INSTALLED_PENDING_REBOOT = PatchComplianceDataState.INSTALLED_PENDING_REBOOT
INSTALLED_REJECTED = PatchComplianceDataState.INSTALLED_REJECTED
MISSING = PatchComplianceDataState.MISSING
NOT_APPLICABLE = PatchComplianceDataState.NOT_APPLICABLE
FAILED = PatchComplianceDataState.FAILED
AVAILABLE_SECURITY_UPDATE = PatchComplianceDataState.AVAILABLE_SECURITY_UPDATE
CRITICAL = PatchComplianceLevel.CRITICAL
HIGH = PatchComplianceLevel.HIGH
MEDIUM = PatchComplianceLevel.MEDIUM
LOW = PatchComplianceLevel.LOW
INFORMATIONAL = PatchComplianceLevel.INFORMATIONAL
UNSPECIFIED = PatchComplianceLevel.UNSPECIFIED
COMPLIANT = PatchComplianceStatus.COMPLIANT
NON_COMPLIANT = PatchComplianceStatus.NON_COMPLIANT
APPROVED = PatchDeploymentStatus.APPROVED
PENDING_APPROVAL = PatchDeploymentStatus.PENDING_APPROVAL
EXPLICIT_APPROVED = PatchDeploymentStatus.EXPLICIT_APPROVED
EXPLICIT_REJECTED = PatchDeploymentStatus.EXPLICIT_REJECTED
ARCH = PatchFilterKey.ARCH
ADVISORY_ID = PatchFilterKey.ADVISORY_ID
BUGZILLA_ID = PatchFilterKey.BUGZILLA_ID
PATCH_SET = PatchFilterKey.PATCH_SET
PRODUCT = PatchFilterKey.PRODUCT
PRODUCT_FAMILY = PatchFilterKey.PRODUCT_FAMILY
CLASSIFICATION = PatchFilterKey.CLASSIFICATION
CVE_ID = PatchFilterKey.CVE_ID
EPOCH = PatchFilterKey.EPOCH
MSRC_SEVERITY = PatchFilterKey.MSRC_SEVERITY
NAME = PatchFilterKey.NAME
PATCH_ID = PatchFilterKey.PATCH_ID
SECTION = PatchFilterKey.SECTION
PRIORITY = PatchFilterKey.PRIORITY
REPOSITORY = PatchFilterKey.REPOSITORY
RELEASE = PatchFilterKey.RELEASE
SEVERITY = PatchFilterKey.SEVERITY
SECURITY = PatchFilterKey.SECURITY
VERSION = PatchFilterKey.VERSION
SCAN = PatchOperationType.SCAN
INSTALL = PatchOperationType.INSTALL
PRODUCT = PatchProperty.PRODUCT
PRODUCT_FAMILY = PatchProperty.PRODUCT_FAMILY
CLASSIFICATION = PatchProperty.CLASSIFICATION
MSRC_SEVERITY = PatchProperty.MSRC_SEVERITY
PRIORITY = PatchProperty.PRIORITY
SEVERITY = PatchProperty.SEVERITY
OS = PatchSet.OS
APPLICATION = PatchSet.APPLICATION
ONLINE = PingStatus.ONLINE
CONNECTIONLOST = PingStatus.CONNECTIONLOST
INACTIVE = PingStatus.INACTIVE
WINDOWS = PlatformType.WINDOWS
LINUX = PlatformType.LINUX
MACOS = PlatformType.MACOS
REBOOTIFNEEDED = RebootOption.REBOOTIFNEEDED
NOREBOOT = RebootOption.NOREBOOT
JSONSERDE = ResourceDataSyncS3Format.JSONSERDE
MANAGEDINSTANCE = ResourceType.MANAGEDINSTANCE
EC2INSTANCE = ResourceType.EC2INSTANCE
DOCUMENT = ResourceTypeForTagging.DOCUMENT
MANAGEDINSTANCE = ResourceTypeForTagging.MANAGEDINSTANCE
MAINTENANCEWINDOW = ResourceTypeForTagging.MAINTENANCEWINDOW
PARAMETER = ResourceTypeForTagging.PARAMETER
PATCHBASELINE = ResourceTypeForTagging.PATCHBASELINE
OPSITEM = ResourceTypeForTagging.OPSITEM
OPSMETADATA = ResourceTypeForTagging.OPSMETADATA
AUTOMATION = ResourceTypeForTagging.AUTOMATION
ASSOCIATION = ResourceTypeForTagging.ASSOCIATION
APPROVED = ReviewStatus.APPROVED
NOT_REVIEWED = ReviewStatus.NOT_REVIEWED
PENDING = ReviewStatus.PENDING
REJECTED = ReviewStatus.REJECTED
INVOKEDAFTER = SessionFilterKey.INVOKEDAFTER
INVOKEDBEFORE = SessionFilterKey.INVOKEDBEFORE
TARGET = SessionFilterKey.TARGET
OWNER = SessionFilterKey.OWNER
STATUS = SessionFilterKey.STATUS
SESSIONID = SessionFilterKey.SESSIONID
ACCESSTYPE = SessionFilterKey.ACCESSTYPE
ACTIVE = SessionState.ACTIVE
HISTORY = SessionState.HISTORY
CONNECTED = SessionStatus.CONNECTED
CONNECTING = SessionStatus.CONNECTING
DISCONNECTED = SessionStatus.DISCONNECTED
TERMINATED = SessionStatus.TERMINATED
TERMINATING = SessionStatus.TERMINATING
FAILED = SessionStatus.FAILED
APPROVE = SignalType.APPROVE
REJECT = SignalType.REJECT
STARTSTEP = SignalType.STARTSTEP
STOPSTEP = SignalType.STOPSTEP
RESUME = SignalType.RESUME
REVOKE = SignalType.REVOKE
AWS_EC2_INSTANCE = SourceType.AWS_EC2_INSTANCE
AWS_IOT_THING = SourceType.AWS_IOT_THING
AWS_SSM_MANAGEDINSTANCE = SourceType.AWS_SSM_MANAGEDINSTANCE
STARTTIMEBEFORE = StepExecutionFilterKey.STARTTIMEBEFORE
STARTTIMEAFTER = StepExecutionFilterKey.STARTTIMEAFTER
STEPEXECUTIONSTATUS = StepExecutionFilterKey.STEPEXECUTIONSTATUS
STEPEXECUTIONID = StepExecutionFilterKey.STEPEXECUTIONID
STEPNAME = StepExecutionFilterKey.STEPNAME
ACTION = StepExecutionFilterKey.ACTION
PARENTSTEPEXECUTIONID = StepExecutionFilterKey.PARENTSTEPEXECUTIONID
PARENTSTEPITERATION = StepExecutionFilterKey.PARENTSTEPITERATION
PARENTSTEPITERATORVALUE = StepExecutionFilterKey.PARENTSTEPITERATORVALUE
COMPLETE = StopType.COMPLETE
CANCEL = StopType.CANCEL


@dataclass
class InstanceAssociationOutputLocation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_location: Optional[S3OutputLocation] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_location is not None:
            if hasattr(self.s3_location, 'to_dict'):
                props['S3Location'] = self.s3_location.to_dict()
            elif isinstance(self.s3_location, list):
                props['S3Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_location
                ]
            else:
                props['S3Location'] = self.s3_location

        return props


@dataclass
class S3OutputLocation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_s3_key_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_s3_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_s3_bucket_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.output_s3_key_prefix is not None:
            if hasattr(self.output_s3_key_prefix, 'to_dict'):
                props['OutputS3KeyPrefix'] = self.output_s3_key_prefix.to_dict()
            elif isinstance(self.output_s3_key_prefix, list):
                props['OutputS3KeyPrefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_s3_key_prefix
                ]
            else:
                props['OutputS3KeyPrefix'] = self.output_s3_key_prefix

        if self.output_s3_region is not None:
            if hasattr(self.output_s3_region, 'to_dict'):
                props['OutputS3Region'] = self.output_s3_region.to_dict()
            elif isinstance(self.output_s3_region, list):
                props['OutputS3Region'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_s3_region
                ]
            else:
                props['OutputS3Region'] = self.output_s3_region

        if self.output_s3_bucket_name is not None:
            if hasattr(self.output_s3_bucket_name, 'to_dict'):
                props['OutputS3BucketName'] = self.output_s3_bucket_name.to_dict()
            elif isinstance(self.output_s3_bucket_name, list):
                props['OutputS3BucketName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_s3_bucket_name
                ]
            else:
                props['OutputS3BucketName'] = self.output_s3_bucket_name

        return props


@dataclass
class Target:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    values: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.values is not None:
            if hasattr(self.values, 'to_dict'):
                props['Values'] = self.values.to_dict()
            elif isinstance(self.values, list):
                props['Values'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.values
                ]
            else:
                props['Values'] = self.values

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class Association(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-a"""

    resource_type: ClassVar[str] = "AWS::SSM::Association"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    association_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    calendar_names: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    schedule_expression: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_errors: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    parameters: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    wait_for_success_timeout_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_concurrency: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    compliance_severity: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    targets: Optional[list[Target]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sync_compliance: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    output_location: Optional[InstanceAssociationOutputLocation] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    schedule_offset: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    apply_only_at_cron_interval: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    document_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    automation_target_parameter_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.association_name is not None:
            # Serialize association_name (handle intrinsic functions)
            if hasattr(self.association_name, 'to_dict'):
                props["AssociationName"] = self.association_name.to_dict()
            elif isinstance(self.association_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['AssociationName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.association_name
                ]
            else:
                props["AssociationName"] = self.association_name

        if self.calendar_names is not None:
            # Serialize calendar_names (handle intrinsic functions)
            if hasattr(self.calendar_names, 'to_dict'):
                props["CalendarNames"] = self.calendar_names.to_dict()
            elif isinstance(self.calendar_names, list):
                # Serialize list items (may contain intrinsic functions)
                props['CalendarNames'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.calendar_names
                ]
            else:
                props["CalendarNames"] = self.calendar_names

        if self.schedule_expression is not None:
            # Serialize schedule_expression (handle intrinsic functions)
            if hasattr(self.schedule_expression, 'to_dict'):
                props["ScheduleExpression"] = self.schedule_expression.to_dict()
            elif isinstance(self.schedule_expression, list):
                # Serialize list items (may contain intrinsic functions)
                props['ScheduleExpression'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schedule_expression
                ]
            else:
                props["ScheduleExpression"] = self.schedule_expression

        if self.max_errors is not None:
            # Serialize max_errors (handle intrinsic functions)
            if hasattr(self.max_errors, 'to_dict'):
                props["MaxErrors"] = self.max_errors.to_dict()
            elif isinstance(self.max_errors, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxErrors'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_errors
                ]
            else:
                props["MaxErrors"] = self.max_errors

        if self.parameters is not None:
            # Serialize parameters (handle intrinsic functions)
            if hasattr(self.parameters, 'to_dict'):
                props["Parameters"] = self.parameters.to_dict()
            elif isinstance(self.parameters, list):
                # Serialize list items (may contain intrinsic functions)
                props['Parameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameters
                ]
            else:
                props["Parameters"] = self.parameters

        if self.instance_id is not None:
            # Serialize instance_id (handle intrinsic functions)
            if hasattr(self.instance_id, 'to_dict'):
                props["InstanceId"] = self.instance_id.to_dict()
            elif isinstance(self.instance_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_id
                ]
            else:
                props["InstanceId"] = self.instance_id

        if self.wait_for_success_timeout_seconds is not None:
            # Serialize wait_for_success_timeout_seconds (handle intrinsic functions)
            if hasattr(self.wait_for_success_timeout_seconds, 'to_dict'):
                props["WaitForSuccessTimeoutSeconds"] = self.wait_for_success_timeout_seconds.to_dict()
            elif isinstance(self.wait_for_success_timeout_seconds, list):
                # Serialize list items (may contain intrinsic functions)
                props['WaitForSuccessTimeoutSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.wait_for_success_timeout_seconds
                ]
            else:
                props["WaitForSuccessTimeoutSeconds"] = self.wait_for_success_timeout_seconds

        if self.max_concurrency is not None:
            # Serialize max_concurrency (handle intrinsic functions)
            if hasattr(self.max_concurrency, 'to_dict'):
                props["MaxConcurrency"] = self.max_concurrency.to_dict()
            elif isinstance(self.max_concurrency, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxConcurrency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_concurrency
                ]
            else:
                props["MaxConcurrency"] = self.max_concurrency

        if self.compliance_severity is not None:
            # Serialize compliance_severity (handle intrinsic functions)
            if hasattr(self.compliance_severity, 'to_dict'):
                props["ComplianceSeverity"] = self.compliance_severity.to_dict()
            elif isinstance(self.compliance_severity, list):
                # Serialize list items (may contain intrinsic functions)
                props['ComplianceSeverity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compliance_severity
                ]
            else:
                props["ComplianceSeverity"] = self.compliance_severity

        if self.targets is not None:
            # Serialize targets (handle intrinsic functions)
            if hasattr(self.targets, 'to_dict'):
                props["Targets"] = self.targets.to_dict()
            elif isinstance(self.targets, list):
                # Serialize list items (may contain intrinsic functions)
                props['Targets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.targets
                ]
            else:
                props["Targets"] = self.targets

        if self.sync_compliance is not None:
            # Serialize sync_compliance (handle intrinsic functions)
            if hasattr(self.sync_compliance, 'to_dict'):
                props["SyncCompliance"] = self.sync_compliance.to_dict()
            elif isinstance(self.sync_compliance, list):
                # Serialize list items (may contain intrinsic functions)
                props['SyncCompliance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sync_compliance
                ]
            else:
                props["SyncCompliance"] = self.sync_compliance

        if self.output_location is not None:
            # Serialize output_location (handle intrinsic functions)
            if hasattr(self.output_location, 'to_dict'):
                props["OutputLocation"] = self.output_location.to_dict()
            elif isinstance(self.output_location, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutputLocation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_location
                ]
            else:
                props["OutputLocation"] = self.output_location

        if self.schedule_offset is not None:
            # Serialize schedule_offset (handle intrinsic functions)
            if hasattr(self.schedule_offset, 'to_dict'):
                props["ScheduleOffset"] = self.schedule_offset.to_dict()
            elif isinstance(self.schedule_offset, list):
                # Serialize list items (may contain intrinsic functions)
                props['ScheduleOffset'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schedule_offset
                ]
            else:
                props["ScheduleOffset"] = self.schedule_offset

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.apply_only_at_cron_interval is not None:
            # Serialize apply_only_at_cron_interval (handle intrinsic functions)
            if hasattr(self.apply_only_at_cron_interval, 'to_dict'):
                props["ApplyOnlyAtCronInterval"] = self.apply_only_at_cron_interval.to_dict()
            elif isinstance(self.apply_only_at_cron_interval, list):
                # Serialize list items (may contain intrinsic functions)
                props['ApplyOnlyAtCronInterval'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.apply_only_at_cron_interval
                ]
            else:
                props["ApplyOnlyAtCronInterval"] = self.apply_only_at_cron_interval

        if self.document_version is not None:
            # Serialize document_version (handle intrinsic functions)
            if hasattr(self.document_version, 'to_dict'):
                props["DocumentVersion"] = self.document_version.to_dict()
            elif isinstance(self.document_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['DocumentVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_version
                ]
            else:
                props["DocumentVersion"] = self.document_version

        if self.automation_target_parameter_name is not None:
            # Serialize automation_target_parameter_name (handle intrinsic functions)
            if hasattr(self.automation_target_parameter_name, 'to_dict'):
                props["AutomationTargetParameterName"] = self.automation_target_parameter_name.to_dict()
            elif isinstance(self.automation_target_parameter_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutomationTargetParameterName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.automation_target_parameter_name
                ]
            else:
                props["AutomationTargetParameterName"] = self.automation_target_parameter_name

        return props

    @property
    def attr_association_id(self) -> GetAtt:
        """Get the AssociationId attribute."""
        return self.get_att("AssociationId")




@dataclass
class AttachmentsSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    values: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, AttachmentsSourceKey, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.values is not None:
            if hasattr(self.values, 'to_dict'):
                props['Values'] = self.values.to_dict()
            elif isinstance(self.values, list):
                props['Values'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.values
                ]
            else:
                props['Values'] = self.values

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class DocumentRequires:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.version is not None:
            if hasattr(self.version, 'to_dict'):
                props['Version'] = self.version.to_dict()
            elif isinstance(self.version, list):
                props['Version'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version
                ]
            else:
                props['Version'] = self.version

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class Document(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-d"""

    resource_type: ClassVar[str] = "AWS::SSM::Document"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    document_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    requires: Optional[list[DocumentRequires]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    content: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    target_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    document_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    version_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    update_method: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    attachments: Optional[list[AttachmentsSource]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.document_format is not None:
            # Serialize document_format (handle intrinsic functions)
            if hasattr(self.document_format, 'to_dict'):
                props["DocumentFormat"] = self.document_format.to_dict()
            elif isinstance(self.document_format, list):
                # Serialize list items (may contain intrinsic functions)
                props['DocumentFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_format
                ]
            else:
                props["DocumentFormat"] = self.document_format

        if self.requires is not None:
            # Serialize requires (handle intrinsic functions)
            if hasattr(self.requires, 'to_dict'):
                props["Requires"] = self.requires.to_dict()
            elif isinstance(self.requires, list):
                # Serialize list items (may contain intrinsic functions)
                props['Requires'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.requires
                ]
            else:
                props["Requires"] = self.requires

        if self.content is not None:
            # Serialize content (handle intrinsic functions)
            if hasattr(self.content, 'to_dict'):
                props["Content"] = self.content.to_dict()
            elif isinstance(self.content, list):
                # Serialize list items (may contain intrinsic functions)
                props['Content'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.content
                ]
            else:
                props["Content"] = self.content

        if self.target_type is not None:
            # Serialize target_type (handle intrinsic functions)
            if hasattr(self.target_type, 'to_dict'):
                props["TargetType"] = self.target_type.to_dict()
            elif isinstance(self.target_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['TargetType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.target_type
                ]
            else:
                props["TargetType"] = self.target_type

        if self.document_type is not None:
            # Serialize document_type (handle intrinsic functions)
            if hasattr(self.document_type, 'to_dict'):
                props["DocumentType"] = self.document_type.to_dict()
            elif isinstance(self.document_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['DocumentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_type
                ]
            else:
                props["DocumentType"] = self.document_type

        if self.version_name is not None:
            # Serialize version_name (handle intrinsic functions)
            if hasattr(self.version_name, 'to_dict'):
                props["VersionName"] = self.version_name.to_dict()
            elif isinstance(self.version_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['VersionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version_name
                ]
            else:
                props["VersionName"] = self.version_name

        if self.update_method is not None:
            # Serialize update_method (handle intrinsic functions)
            if hasattr(self.update_method, 'to_dict'):
                props["UpdateMethod"] = self.update_method.to_dict()
            elif isinstance(self.update_method, list):
                # Serialize list items (may contain intrinsic functions)
                props['UpdateMethod'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.update_method
                ]
            else:
                props["UpdateMethod"] = self.update_method

        if self.attachments is not None:
            # Serialize attachments (handle intrinsic functions)
            if hasattr(self.attachments, 'to_dict'):
                props["Attachments"] = self.attachments.to_dict()
            elif isinstance(self.attachments, list):
                # Serialize list items (may contain intrinsic functions)
                props['Attachments'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attachments
                ]
            else:
                props["Attachments"] = self.attachments

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props



@dataclass
class MaintenanceWindow(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-m"""

    resource_type: ClassVar[str] = "AWS::SSM::MaintenanceWindow"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    start_date: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allow_unassociated_targets: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cutoff: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    schedule: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    duration: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    schedule_offset: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    end_date: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    schedule_timezone: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.start_date is not None:
            # Serialize start_date (handle intrinsic functions)
            if hasattr(self.start_date, 'to_dict'):
                props["StartDate"] = self.start_date.to_dict()
            elif isinstance(self.start_date, list):
                # Serialize list items (may contain intrinsic functions)
                props['StartDate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.start_date
                ]
            else:
                props["StartDate"] = self.start_date

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.allow_unassociated_targets is not None:
            # Serialize allow_unassociated_targets (handle intrinsic functions)
            if hasattr(self.allow_unassociated_targets, 'to_dict'):
                props["AllowUnassociatedTargets"] = self.allow_unassociated_targets.to_dict()
            elif isinstance(self.allow_unassociated_targets, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllowUnassociatedTargets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allow_unassociated_targets
                ]
            else:
                props["AllowUnassociatedTargets"] = self.allow_unassociated_targets

        if self.cutoff is not None:
            # Serialize cutoff (handle intrinsic functions)
            if hasattr(self.cutoff, 'to_dict'):
                props["Cutoff"] = self.cutoff.to_dict()
            elif isinstance(self.cutoff, list):
                # Serialize list items (may contain intrinsic functions)
                props['Cutoff'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cutoff
                ]
            else:
                props["Cutoff"] = self.cutoff

        if self.schedule is not None:
            # Serialize schedule (handle intrinsic functions)
            if hasattr(self.schedule, 'to_dict'):
                props["Schedule"] = self.schedule.to_dict()
            elif isinstance(self.schedule, list):
                # Serialize list items (may contain intrinsic functions)
                props['Schedule'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schedule
                ]
            else:
                props["Schedule"] = self.schedule

        if self.duration is not None:
            # Serialize duration (handle intrinsic functions)
            if hasattr(self.duration, 'to_dict'):
                props["Duration"] = self.duration.to_dict()
            elif isinstance(self.duration, list):
                # Serialize list items (may contain intrinsic functions)
                props['Duration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.duration
                ]
            else:
                props["Duration"] = self.duration

        if self.schedule_offset is not None:
            # Serialize schedule_offset (handle intrinsic functions)
            if hasattr(self.schedule_offset, 'to_dict'):
                props["ScheduleOffset"] = self.schedule_offset.to_dict()
            elif isinstance(self.schedule_offset, list):
                # Serialize list items (may contain intrinsic functions)
                props['ScheduleOffset'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schedule_offset
                ]
            else:
                props["ScheduleOffset"] = self.schedule_offset

        if self.end_date is not None:
            # Serialize end_date (handle intrinsic functions)
            if hasattr(self.end_date, 'to_dict'):
                props["EndDate"] = self.end_date.to_dict()
            elif isinstance(self.end_date, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndDate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.end_date
                ]
            else:
                props["EndDate"] = self.end_date

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.schedule_timezone is not None:
            # Serialize schedule_timezone (handle intrinsic functions)
            if hasattr(self.schedule_timezone, 'to_dict'):
                props["ScheduleTimezone"] = self.schedule_timezone.to_dict()
            elif isinstance(self.schedule_timezone, list):
                # Serialize list items (may contain intrinsic functions)
                props['ScheduleTimezone'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schedule_timezone
                ]
            else:
                props["ScheduleTimezone"] = self.schedule_timezone

        return props



@dataclass
class Targets:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    values: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.values is not None:
            if hasattr(self.values, 'to_dict'):
                props['Values'] = self.values.to_dict()
            elif isinstance(self.values, list):
                props['Values'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.values
                ]
            else:
                props['Values'] = self.values

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class MaintenanceWindowTarget(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-m"""

    resource_type: ClassVar[str] = "AWS::SSM::MaintenanceWindowTarget"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    owner_information: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    window_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_type: Optional[Union[str, MaintenanceWindowResourceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    targets: Optional[list[Targets]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.owner_information is not None:
            # Serialize owner_information (handle intrinsic functions)
            if hasattr(self.owner_information, 'to_dict'):
                props["OwnerInformation"] = self.owner_information.to_dict()
            elif isinstance(self.owner_information, list):
                # Serialize list items (may contain intrinsic functions)
                props['OwnerInformation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.owner_information
                ]
            else:
                props["OwnerInformation"] = self.owner_information

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.window_id is not None:
            # Serialize window_id (handle intrinsic functions)
            if hasattr(self.window_id, 'to_dict'):
                props["WindowId"] = self.window_id.to_dict()
            elif isinstance(self.window_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['WindowId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.window_id
                ]
            else:
                props["WindowId"] = self.window_id

        if self.resource_type is not None:
            # Serialize resource_type (handle intrinsic functions)
            if hasattr(self.resource_type, 'to_dict'):
                props["ResourceType"] = self.resource_type.to_dict()
            elif isinstance(self.resource_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_type
                ]
            else:
                props["ResourceType"] = self.resource_type

        if self.targets is not None:
            # Serialize targets (handle intrinsic functions)
            if hasattr(self.targets, 'to_dict'):
                props["Targets"] = self.targets.to_dict()
            elif isinstance(self.targets, list):
                # Serialize list items (may contain intrinsic functions)
                props['Targets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.targets
                ]
            else:
                props["Targets"] = self.targets

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props



@dataclass
class CloudWatchOutputConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_output_enabled: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_log_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cloud_watch_output_enabled is not None:
            if hasattr(self.cloud_watch_output_enabled, 'to_dict'):
                props['CloudWatchOutputEnabled'] = self.cloud_watch_output_enabled.to_dict()
            elif isinstance(self.cloud_watch_output_enabled, list):
                props['CloudWatchOutputEnabled'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cloud_watch_output_enabled
                ]
            else:
                props['CloudWatchOutputEnabled'] = self.cloud_watch_output_enabled

        if self.cloud_watch_log_group_name is not None:
            if hasattr(self.cloud_watch_log_group_name, 'to_dict'):
                props['CloudWatchLogGroupName'] = self.cloud_watch_log_group_name.to_dict()
            elif isinstance(self.cloud_watch_log_group_name, list):
                props['CloudWatchLogGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cloud_watch_log_group_name
                ]
            else:
                props['CloudWatchLogGroupName'] = self.cloud_watch_log_group_name

        return props


@dataclass
class LoggingInfo:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_bucket is not None:
            if hasattr(self.s3_bucket, 'to_dict'):
                props['S3Bucket'] = self.s3_bucket.to_dict()
            elif isinstance(self.s3_bucket, list):
                props['S3Bucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_bucket
                ]
            else:
                props['S3Bucket'] = self.s3_bucket

        if self.region is not None:
            if hasattr(self.region, 'to_dict'):
                props['Region'] = self.region.to_dict()
            elif isinstance(self.region, list):
                props['Region'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.region
                ]
            else:
                props['Region'] = self.region

        if self.s3_prefix is not None:
            if hasattr(self.s3_prefix, 'to_dict'):
                props['S3Prefix'] = self.s3_prefix.to_dict()
            elif isinstance(self.s3_prefix, list):
                props['S3Prefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_prefix
                ]
            else:
                props['S3Prefix'] = self.s3_prefix

        return props


@dataclass
class MaintenanceWindowAutomationParameters:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parameters: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    document_version: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.parameters is not None:
            if hasattr(self.parameters, 'to_dict'):
                props['Parameters'] = self.parameters.to_dict()
            elif isinstance(self.parameters, list):
                props['Parameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameters
                ]
            else:
                props['Parameters'] = self.parameters

        if self.document_version is not None:
            if hasattr(self.document_version, 'to_dict'):
                props['DocumentVersion'] = self.document_version.to_dict()
            elif isinstance(self.document_version, list):
                props['DocumentVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_version
                ]
            else:
                props['DocumentVersion'] = self.document_version

        return props


@dataclass
class MaintenanceWindowLambdaParameters:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    client_context: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    qualifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    payload: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.client_context is not None:
            if hasattr(self.client_context, 'to_dict'):
                props['ClientContext'] = self.client_context.to_dict()
            elif isinstance(self.client_context, list):
                props['ClientContext'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_context
                ]
            else:
                props['ClientContext'] = self.client_context

        if self.qualifier is not None:
            if hasattr(self.qualifier, 'to_dict'):
                props['Qualifier'] = self.qualifier.to_dict()
            elif isinstance(self.qualifier, list):
                props['Qualifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.qualifier
                ]
            else:
                props['Qualifier'] = self.qualifier

        if self.payload is not None:
            if hasattr(self.payload, 'to_dict'):
                props['Payload'] = self.payload.to_dict()
            elif isinstance(self.payload, list):
                props['Payload'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.payload
                ]
            else:
                props['Payload'] = self.payload

        return props


@dataclass
class MaintenanceWindowRunCommandParameters:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    timeout_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    comment: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_s3_key_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parameters: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cloud_watch_output_config: Optional[CloudWatchOutputConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    document_hash_type: Optional[Union[str, DocumentHashType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    service_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notification_config: Optional[NotificationConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    document_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_s3_bucket_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    document_hash: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.timeout_seconds is not None:
            if hasattr(self.timeout_seconds, 'to_dict'):
                props['TimeoutSeconds'] = self.timeout_seconds.to_dict()
            elif isinstance(self.timeout_seconds, list):
                props['TimeoutSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.timeout_seconds
                ]
            else:
                props['TimeoutSeconds'] = self.timeout_seconds

        if self.comment is not None:
            if hasattr(self.comment, 'to_dict'):
                props['Comment'] = self.comment.to_dict()
            elif isinstance(self.comment, list):
                props['Comment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.comment
                ]
            else:
                props['Comment'] = self.comment

        if self.output_s3_key_prefix is not None:
            if hasattr(self.output_s3_key_prefix, 'to_dict'):
                props['OutputS3KeyPrefix'] = self.output_s3_key_prefix.to_dict()
            elif isinstance(self.output_s3_key_prefix, list):
                props['OutputS3KeyPrefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_s3_key_prefix
                ]
            else:
                props['OutputS3KeyPrefix'] = self.output_s3_key_prefix

        if self.parameters is not None:
            if hasattr(self.parameters, 'to_dict'):
                props['Parameters'] = self.parameters.to_dict()
            elif isinstance(self.parameters, list):
                props['Parameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameters
                ]
            else:
                props['Parameters'] = self.parameters

        if self.cloud_watch_output_config is not None:
            if hasattr(self.cloud_watch_output_config, 'to_dict'):
                props['CloudWatchOutputConfig'] = self.cloud_watch_output_config.to_dict()
            elif isinstance(self.cloud_watch_output_config, list):
                props['CloudWatchOutputConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cloud_watch_output_config
                ]
            else:
                props['CloudWatchOutputConfig'] = self.cloud_watch_output_config

        if self.document_hash_type is not None:
            if hasattr(self.document_hash_type, 'to_dict'):
                props['DocumentHashType'] = self.document_hash_type.to_dict()
            elif isinstance(self.document_hash_type, list):
                props['DocumentHashType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_hash_type
                ]
            else:
                props['DocumentHashType'] = self.document_hash_type

        if self.service_role_arn is not None:
            if hasattr(self.service_role_arn, 'to_dict'):
                props['ServiceRoleArn'] = self.service_role_arn.to_dict()
            elif isinstance(self.service_role_arn, list):
                props['ServiceRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_role_arn
                ]
            else:
                props['ServiceRoleArn'] = self.service_role_arn

        if self.notification_config is not None:
            if hasattr(self.notification_config, 'to_dict'):
                props['NotificationConfig'] = self.notification_config.to_dict()
            elif isinstance(self.notification_config, list):
                props['NotificationConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_config
                ]
            else:
                props['NotificationConfig'] = self.notification_config

        if self.document_version is not None:
            if hasattr(self.document_version, 'to_dict'):
                props['DocumentVersion'] = self.document_version.to_dict()
            elif isinstance(self.document_version, list):
                props['DocumentVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_version
                ]
            else:
                props['DocumentVersion'] = self.document_version

        if self.output_s3_bucket_name is not None:
            if hasattr(self.output_s3_bucket_name, 'to_dict'):
                props['OutputS3BucketName'] = self.output_s3_bucket_name.to_dict()
            elif isinstance(self.output_s3_bucket_name, list):
                props['OutputS3BucketName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_s3_bucket_name
                ]
            else:
                props['OutputS3BucketName'] = self.output_s3_bucket_name

        if self.document_hash is not None:
            if hasattr(self.document_hash, 'to_dict'):
                props['DocumentHash'] = self.document_hash.to_dict()
            elif isinstance(self.document_hash, list):
                props['DocumentHash'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.document_hash
                ]
            else:
                props['DocumentHash'] = self.document_hash

        return props


@dataclass
class MaintenanceWindowStepFunctionsParameters:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    input: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.input is not None:
            if hasattr(self.input, 'to_dict'):
                props['Input'] = self.input.to_dict()
            elif isinstance(self.input, list):
                props['Input'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.input
                ]
            else:
                props['Input'] = self.input

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class NotificationConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notification_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notification_type: Optional[Union[str, NotificationType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notification_events: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.notification_arn is not None:
            if hasattr(self.notification_arn, 'to_dict'):
                props['NotificationArn'] = self.notification_arn.to_dict()
            elif isinstance(self.notification_arn, list):
                props['NotificationArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_arn
                ]
            else:
                props['NotificationArn'] = self.notification_arn

        if self.notification_type is not None:
            if hasattr(self.notification_type, 'to_dict'):
                props['NotificationType'] = self.notification_type.to_dict()
            elif isinstance(self.notification_type, list):
                props['NotificationType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_type
                ]
            else:
                props['NotificationType'] = self.notification_type

        if self.notification_events is not None:
            if hasattr(self.notification_events, 'to_dict'):
                props['NotificationEvents'] = self.notification_events.to_dict()
            elif isinstance(self.notification_events, list):
                props['NotificationEvents'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_events
                ]
            else:
                props['NotificationEvents'] = self.notification_events

        return props


@dataclass
class Target:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    values: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.values is not None:
            if hasattr(self.values, 'to_dict'):
                props['Values'] = self.values.to_dict()
            elif isinstance(self.values, list):
                props['Values'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.values
                ]
            else:
                props['Values'] = self.values

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class TaskInvocationParameters:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maintenance_window_run_command_parameters: Optional[MaintenanceWindowRunCommandParameters] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maintenance_window_automation_parameters: Optional[MaintenanceWindowAutomationParameters] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maintenance_window_step_functions_parameters: Optional[MaintenanceWindowStepFunctionsParameters] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maintenance_window_lambda_parameters: Optional[MaintenanceWindowLambdaParameters] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.maintenance_window_run_command_parameters is not None:
            if hasattr(self.maintenance_window_run_command_parameters, 'to_dict'):
                props['MaintenanceWindowRunCommandParameters'] = self.maintenance_window_run_command_parameters.to_dict()
            elif isinstance(self.maintenance_window_run_command_parameters, list):
                props['MaintenanceWindowRunCommandParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maintenance_window_run_command_parameters
                ]
            else:
                props['MaintenanceWindowRunCommandParameters'] = self.maintenance_window_run_command_parameters

        if self.maintenance_window_automation_parameters is not None:
            if hasattr(self.maintenance_window_automation_parameters, 'to_dict'):
                props['MaintenanceWindowAutomationParameters'] = self.maintenance_window_automation_parameters.to_dict()
            elif isinstance(self.maintenance_window_automation_parameters, list):
                props['MaintenanceWindowAutomationParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maintenance_window_automation_parameters
                ]
            else:
                props['MaintenanceWindowAutomationParameters'] = self.maintenance_window_automation_parameters

        if self.maintenance_window_step_functions_parameters is not None:
            if hasattr(self.maintenance_window_step_functions_parameters, 'to_dict'):
                props['MaintenanceWindowStepFunctionsParameters'] = self.maintenance_window_step_functions_parameters.to_dict()
            elif isinstance(self.maintenance_window_step_functions_parameters, list):
                props['MaintenanceWindowStepFunctionsParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maintenance_window_step_functions_parameters
                ]
            else:
                props['MaintenanceWindowStepFunctionsParameters'] = self.maintenance_window_step_functions_parameters

        if self.maintenance_window_lambda_parameters is not None:
            if hasattr(self.maintenance_window_lambda_parameters, 'to_dict'):
                props['MaintenanceWindowLambdaParameters'] = self.maintenance_window_lambda_parameters.to_dict()
            elif isinstance(self.maintenance_window_lambda_parameters, list):
                props['MaintenanceWindowLambdaParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maintenance_window_lambda_parameters
                ]
            else:
                props['MaintenanceWindowLambdaParameters'] = self.maintenance_window_lambda_parameters

        return props


@dataclass
class MaintenanceWindowTask(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-m"""

    resource_type: ClassVar[str] = "AWS::SSM::MaintenanceWindowTask"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_errors: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    priority: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    max_concurrency: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    targets: Optional[list[Target]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    task_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    task_invocation_parameters: Optional[TaskInvocationParameters] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    window_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    task_parameters: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    task_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cutoff_behavior: Optional[Union[str, MaintenanceWindowTaskCutoffBehavior, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    logging_info: Optional[LoggingInfo] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_errors is not None:
            # Serialize max_errors (handle intrinsic functions)
            if hasattr(self.max_errors, 'to_dict'):
                props["MaxErrors"] = self.max_errors.to_dict()
            elif isinstance(self.max_errors, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxErrors'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_errors
                ]
            else:
                props["MaxErrors"] = self.max_errors

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.service_role_arn is not None:
            # Serialize service_role_arn (handle intrinsic functions)
            if hasattr(self.service_role_arn, 'to_dict'):
                props["ServiceRoleArn"] = self.service_role_arn.to_dict()
            elif isinstance(self.service_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_role_arn
                ]
            else:
                props["ServiceRoleArn"] = self.service_role_arn

        if self.priority is not None:
            # Serialize priority (handle intrinsic functions)
            if hasattr(self.priority, 'to_dict'):
                props["Priority"] = self.priority.to_dict()
            elif isinstance(self.priority, list):
                # Serialize list items (may contain intrinsic functions)
                props['Priority'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.priority
                ]
            else:
                props["Priority"] = self.priority

        if self.max_concurrency is not None:
            # Serialize max_concurrency (handle intrinsic functions)
            if hasattr(self.max_concurrency, 'to_dict'):
                props["MaxConcurrency"] = self.max_concurrency.to_dict()
            elif isinstance(self.max_concurrency, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaxConcurrency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_concurrency
                ]
            else:
                props["MaxConcurrency"] = self.max_concurrency

        if self.targets is not None:
            # Serialize targets (handle intrinsic functions)
            if hasattr(self.targets, 'to_dict'):
                props["Targets"] = self.targets.to_dict()
            elif isinstance(self.targets, list):
                # Serialize list items (may contain intrinsic functions)
                props['Targets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.targets
                ]
            else:
                props["Targets"] = self.targets

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.task_arn is not None:
            # Serialize task_arn (handle intrinsic functions)
            if hasattr(self.task_arn, 'to_dict'):
                props["TaskArn"] = self.task_arn.to_dict()
            elif isinstance(self.task_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['TaskArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.task_arn
                ]
            else:
                props["TaskArn"] = self.task_arn

        if self.task_invocation_parameters is not None:
            # Serialize task_invocation_parameters (handle intrinsic functions)
            if hasattr(self.task_invocation_parameters, 'to_dict'):
                props["TaskInvocationParameters"] = self.task_invocation_parameters.to_dict()
            elif isinstance(self.task_invocation_parameters, list):
                # Serialize list items (may contain intrinsic functions)
                props['TaskInvocationParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.task_invocation_parameters
                ]
            else:
                props["TaskInvocationParameters"] = self.task_invocation_parameters

        if self.window_id is not None:
            # Serialize window_id (handle intrinsic functions)
            if hasattr(self.window_id, 'to_dict'):
                props["WindowId"] = self.window_id.to_dict()
            elif isinstance(self.window_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['WindowId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.window_id
                ]
            else:
                props["WindowId"] = self.window_id

        if self.task_parameters is not None:
            # Serialize task_parameters (handle intrinsic functions)
            if hasattr(self.task_parameters, 'to_dict'):
                props["TaskParameters"] = self.task_parameters.to_dict()
            elif isinstance(self.task_parameters, list):
                # Serialize list items (may contain intrinsic functions)
                props['TaskParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.task_parameters
                ]
            else:
                props["TaskParameters"] = self.task_parameters

        if self.task_type is not None:
            # Serialize task_type (handle intrinsic functions)
            if hasattr(self.task_type, 'to_dict'):
                props["TaskType"] = self.task_type.to_dict()
            elif isinstance(self.task_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['TaskType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.task_type
                ]
            else:
                props["TaskType"] = self.task_type

        if self.cutoff_behavior is not None:
            # Serialize cutoff_behavior (handle intrinsic functions)
            if hasattr(self.cutoff_behavior, 'to_dict'):
                props["CutoffBehavior"] = self.cutoff_behavior.to_dict()
            elif isinstance(self.cutoff_behavior, list):
                # Serialize list items (may contain intrinsic functions)
                props['CutoffBehavior'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cutoff_behavior
                ]
            else:
                props["CutoffBehavior"] = self.cutoff_behavior

        if self.logging_info is not None:
            # Serialize logging_info (handle intrinsic functions)
            if hasattr(self.logging_info, 'to_dict'):
                props["LoggingInfo"] = self.logging_info.to_dict()
            elif isinstance(self.logging_info, list):
                # Serialize list items (may contain intrinsic functions)
                props['LoggingInfo'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.logging_info
                ]
            else:
                props["LoggingInfo"] = self.logging_info

        return props



@dataclass
class Parameter(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-p"""

    resource_type: ClassVar[str] = "AWS::SSM::Parameter"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, ParameterType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policies: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allowed_pattern: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.policies is not None:
            # Serialize policies (handle intrinsic functions)
            if hasattr(self.policies, 'to_dict'):
                props["Policies"] = self.policies.to_dict()
            elif isinstance(self.policies, list):
                # Serialize list items (may contain intrinsic functions)
                props['Policies'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policies
                ]
            else:
                props["Policies"] = self.policies

        if self.allowed_pattern is not None:
            # Serialize allowed_pattern (handle intrinsic functions)
            if hasattr(self.allowed_pattern, 'to_dict'):
                props["AllowedPattern"] = self.allowed_pattern.to_dict()
            elif isinstance(self.allowed_pattern, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllowedPattern'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_pattern
                ]
            else:
                props["AllowedPattern"] = self.allowed_pattern

        if self.tier is not None:
            # Serialize tier (handle intrinsic functions)
            if hasattr(self.tier, 'to_dict'):
                props["Tier"] = self.tier.to_dict()
            elif isinstance(self.tier, list):
                # Serialize list items (may contain intrinsic functions)
                props['Tier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tier
                ]
            else:
                props["Tier"] = self.tier

        if self.value is not None:
            # Serialize value (handle intrinsic functions)
            if hasattr(self.value, 'to_dict'):
                props["Value"] = self.value.to_dict()
            elif isinstance(self.value, list):
                # Serialize list items (may contain intrinsic functions)
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props["Value"] = self.value

        if self.data_type is not None:
            # Serialize data_type (handle intrinsic functions)
            if hasattr(self.data_type, 'to_dict'):
                props["DataType"] = self.data_type.to_dict()
            elif isinstance(self.data_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_type
                ]
            else:
                props["DataType"] = self.data_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_type(self) -> GetAtt:
        """Get the Type attribute."""
        return self.get_att("Type")

    @property
    def attr_value(self) -> GetAtt:
        """Get the Value attribute."""
        return self.get_att("Value")




@dataclass
class PatchFilter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    values: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, PatchFilterKey, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.values is not None:
            if hasattr(self.values, 'to_dict'):
                props['Values'] = self.values.to_dict()
            elif isinstance(self.values, list):
                props['Values'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.values
                ]
            else:
                props['Values'] = self.values

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class PatchFilterGroup:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    patch_filters: Optional[list[PatchFilter]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.patch_filters is not None:
            if hasattr(self.patch_filters, 'to_dict'):
                props['PatchFilters'] = self.patch_filters.to_dict()
            elif isinstance(self.patch_filters, list):
                props['PatchFilters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.patch_filters
                ]
            else:
                props['PatchFilters'] = self.patch_filters

        return props


@dataclass
class PatchSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    products: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    configuration: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.products is not None:
            if hasattr(self.products, 'to_dict'):
                props['Products'] = self.products.to_dict()
            elif isinstance(self.products, list):
                props['Products'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.products
                ]
            else:
                props['Products'] = self.products

        if self.configuration is not None:
            if hasattr(self.configuration, 'to_dict'):
                props['Configuration'] = self.configuration.to_dict()
            elif isinstance(self.configuration, list):
                props['Configuration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.configuration
                ]
            else:
                props['Configuration'] = self.configuration

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class Rule:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    approve_until_date: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_non_security: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    patch_filter_group: Optional[PatchFilterGroup] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    approve_after_days: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    compliance_level: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.approve_until_date is not None:
            if hasattr(self.approve_until_date, 'to_dict'):
                props['ApproveUntilDate'] = self.approve_until_date.to_dict()
            elif isinstance(self.approve_until_date, list):
                props['ApproveUntilDate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.approve_until_date
                ]
            else:
                props['ApproveUntilDate'] = self.approve_until_date

        if self.enable_non_security is not None:
            if hasattr(self.enable_non_security, 'to_dict'):
                props['EnableNonSecurity'] = self.enable_non_security.to_dict()
            elif isinstance(self.enable_non_security, list):
                props['EnableNonSecurity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_non_security
                ]
            else:
                props['EnableNonSecurity'] = self.enable_non_security

        if self.patch_filter_group is not None:
            if hasattr(self.patch_filter_group, 'to_dict'):
                props['PatchFilterGroup'] = self.patch_filter_group.to_dict()
            elif isinstance(self.patch_filter_group, list):
                props['PatchFilterGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.patch_filter_group
                ]
            else:
                props['PatchFilterGroup'] = self.patch_filter_group

        if self.approve_after_days is not None:
            if hasattr(self.approve_after_days, 'to_dict'):
                props['ApproveAfterDays'] = self.approve_after_days.to_dict()
            elif isinstance(self.approve_after_days, list):
                props['ApproveAfterDays'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.approve_after_days
                ]
            else:
                props['ApproveAfterDays'] = self.approve_after_days

        if self.compliance_level is not None:
            if hasattr(self.compliance_level, 'to_dict'):
                props['ComplianceLevel'] = self.compliance_level.to_dict()
            elif isinstance(self.compliance_level, list):
                props['ComplianceLevel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compliance_level
                ]
            else:
                props['ComplianceLevel'] = self.compliance_level

        return props


@dataclass
class RuleGroup:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    patch_rules: Optional[list[Rule]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.patch_rules is not None:
            if hasattr(self.patch_rules, 'to_dict'):
                props['PatchRules'] = self.patch_rules.to_dict()
            elif isinstance(self.patch_rules, list):
                props['PatchRules'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.patch_rules
                ]
            else:
                props['PatchRules'] = self.patch_rules

        return props


@dataclass
class PatchBaseline(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-p"""

    resource_type: ClassVar[str] = "AWS::SSM::PatchBaseline"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    operating_system: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    approval_rules: Optional[RuleGroup] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sources: Optional[list[PatchSource]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rejected_patches: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    approved_patches: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    rejected_patches_action: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    patch_groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    approved_patches_compliance_level: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    available_security_updates_compliance_status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    approved_patches_enable_non_security: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_baseline: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    global_filters: Optional[PatchFilterGroup] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.operating_system is not None:
            # Serialize operating_system (handle intrinsic functions)
            if hasattr(self.operating_system, 'to_dict'):
                props["OperatingSystem"] = self.operating_system.to_dict()
            elif isinstance(self.operating_system, list):
                # Serialize list items (may contain intrinsic functions)
                props['OperatingSystem'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.operating_system
                ]
            else:
                props["OperatingSystem"] = self.operating_system

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.approval_rules is not None:
            # Serialize approval_rules (handle intrinsic functions)
            if hasattr(self.approval_rules, 'to_dict'):
                props["ApprovalRules"] = self.approval_rules.to_dict()
            elif isinstance(self.approval_rules, list):
                # Serialize list items (may contain intrinsic functions)
                props['ApprovalRules'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.approval_rules
                ]
            else:
                props["ApprovalRules"] = self.approval_rules

        if self.sources is not None:
            # Serialize sources (handle intrinsic functions)
            if hasattr(self.sources, 'to_dict'):
                props["Sources"] = self.sources.to_dict()
            elif isinstance(self.sources, list):
                # Serialize list items (may contain intrinsic functions)
                props['Sources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sources
                ]
            else:
                props["Sources"] = self.sources

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.rejected_patches is not None:
            # Serialize rejected_patches (handle intrinsic functions)
            if hasattr(self.rejected_patches, 'to_dict'):
                props["RejectedPatches"] = self.rejected_patches.to_dict()
            elif isinstance(self.rejected_patches, list):
                # Serialize list items (may contain intrinsic functions)
                props['RejectedPatches'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rejected_patches
                ]
            else:
                props["RejectedPatches"] = self.rejected_patches

        if self.approved_patches is not None:
            # Serialize approved_patches (handle intrinsic functions)
            if hasattr(self.approved_patches, 'to_dict'):
                props["ApprovedPatches"] = self.approved_patches.to_dict()
            elif isinstance(self.approved_patches, list):
                # Serialize list items (may contain intrinsic functions)
                props['ApprovedPatches'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.approved_patches
                ]
            else:
                props["ApprovedPatches"] = self.approved_patches

        if self.rejected_patches_action is not None:
            # Serialize rejected_patches_action (handle intrinsic functions)
            if hasattr(self.rejected_patches_action, 'to_dict'):
                props["RejectedPatchesAction"] = self.rejected_patches_action.to_dict()
            elif isinstance(self.rejected_patches_action, list):
                # Serialize list items (may contain intrinsic functions)
                props['RejectedPatchesAction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rejected_patches_action
                ]
            else:
                props["RejectedPatchesAction"] = self.rejected_patches_action

        if self.patch_groups is not None:
            # Serialize patch_groups (handle intrinsic functions)
            if hasattr(self.patch_groups, 'to_dict'):
                props["PatchGroups"] = self.patch_groups.to_dict()
            elif isinstance(self.patch_groups, list):
                # Serialize list items (may contain intrinsic functions)
                props['PatchGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.patch_groups
                ]
            else:
                props["PatchGroups"] = self.patch_groups

        if self.approved_patches_compliance_level is not None:
            # Serialize approved_patches_compliance_level (handle intrinsic functions)
            if hasattr(self.approved_patches_compliance_level, 'to_dict'):
                props["ApprovedPatchesComplianceLevel"] = self.approved_patches_compliance_level.to_dict()
            elif isinstance(self.approved_patches_compliance_level, list):
                # Serialize list items (may contain intrinsic functions)
                props['ApprovedPatchesComplianceLevel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.approved_patches_compliance_level
                ]
            else:
                props["ApprovedPatchesComplianceLevel"] = self.approved_patches_compliance_level

        if self.available_security_updates_compliance_status is not None:
            # Serialize available_security_updates_compliance_status (handle intrinsic functions)
            if hasattr(self.available_security_updates_compliance_status, 'to_dict'):
                props["AvailableSecurityUpdatesComplianceStatus"] = self.available_security_updates_compliance_status.to_dict()
            elif isinstance(self.available_security_updates_compliance_status, list):
                # Serialize list items (may contain intrinsic functions)
                props['AvailableSecurityUpdatesComplianceStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.available_security_updates_compliance_status
                ]
            else:
                props["AvailableSecurityUpdatesComplianceStatus"] = self.available_security_updates_compliance_status

        if self.approved_patches_enable_non_security is not None:
            # Serialize approved_patches_enable_non_security (handle intrinsic functions)
            if hasattr(self.approved_patches_enable_non_security, 'to_dict'):
                props["ApprovedPatchesEnableNonSecurity"] = self.approved_patches_enable_non_security.to_dict()
            elif isinstance(self.approved_patches_enable_non_security, list):
                # Serialize list items (may contain intrinsic functions)
                props['ApprovedPatchesEnableNonSecurity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.approved_patches_enable_non_security
                ]
            else:
                props["ApprovedPatchesEnableNonSecurity"] = self.approved_patches_enable_non_security

        if self.default_baseline is not None:
            # Serialize default_baseline (handle intrinsic functions)
            if hasattr(self.default_baseline, 'to_dict'):
                props["DefaultBaseline"] = self.default_baseline.to_dict()
            elif isinstance(self.default_baseline, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultBaseline'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_baseline
                ]
            else:
                props["DefaultBaseline"] = self.default_baseline

        if self.global_filters is not None:
            # Serialize global_filters (handle intrinsic functions)
            if hasattr(self.global_filters, 'to_dict'):
                props["GlobalFilters"] = self.global_filters.to_dict()
            elif isinstance(self.global_filters, list):
                # Serialize list items (may contain intrinsic functions)
                props['GlobalFilters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.global_filters
                ]
            else:
                props["GlobalFilters"] = self.global_filters

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_id(self) -> GetAtt:
        """Get the Id attribute."""
        return self.get_att("Id")




@dataclass
class AwsOrganizationsSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    organization_source_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    organizational_units: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.organization_source_type is not None:
            if hasattr(self.organization_source_type, 'to_dict'):
                props['OrganizationSourceType'] = self.organization_source_type.to_dict()
            elif isinstance(self.organization_source_type, list):
                props['OrganizationSourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organization_source_type
                ]
            else:
                props['OrganizationSourceType'] = self.organization_source_type

        if self.organizational_units is not None:
            if hasattr(self.organizational_units, 'to_dict'):
                props['OrganizationalUnits'] = self.organizational_units.to_dict()
            elif isinstance(self.organizational_units, list):
                props['OrganizationalUnits'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.organizational_units
                ]
            else:
                props['OrganizationalUnits'] = self.organizational_units

        return props


@dataclass
class S3Destination:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sync_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_arn is not None:
            if hasattr(self.kms_key_arn, 'to_dict'):
                props['KMSKeyArn'] = self.kms_key_arn.to_dict()
            elif isinstance(self.kms_key_arn, list):
                props['KMSKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_arn
                ]
            else:
                props['KMSKeyArn'] = self.kms_key_arn

        if self.bucket_name is not None:
            if hasattr(self.bucket_name, 'to_dict'):
                props['BucketName'] = self.bucket_name.to_dict()
            elif isinstance(self.bucket_name, list):
                props['BucketName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket_name
                ]
            else:
                props['BucketName'] = self.bucket_name

        if self.bucket_region is not None:
            if hasattr(self.bucket_region, 'to_dict'):
                props['BucketRegion'] = self.bucket_region.to_dict()
            elif isinstance(self.bucket_region, list):
                props['BucketRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket_region
                ]
            else:
                props['BucketRegion'] = self.bucket_region

        if self.sync_format is not None:
            if hasattr(self.sync_format, 'to_dict'):
                props['SyncFormat'] = self.sync_format.to_dict()
            elif isinstance(self.sync_format, list):
                props['SyncFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sync_format
                ]
            else:
                props['SyncFormat'] = self.sync_format

        if self.bucket_prefix is not None:
            if hasattr(self.bucket_prefix, 'to_dict'):
                props['BucketPrefix'] = self.bucket_prefix.to_dict()
            elif isinstance(self.bucket_prefix, list):
                props['BucketPrefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket_prefix
                ]
            else:
                props['BucketPrefix'] = self.bucket_prefix

        return props


@dataclass
class SyncSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ssm"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    aws_organizations_source: Optional[AwsOrganizationsSource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    include_future_regions: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_regions: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.source_type is not None:
            if hasattr(self.source_type, 'to_dict'):
                props['SourceType'] = self.source_type.to_dict()
            elif isinstance(self.source_type, list):
                props['SourceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_type
                ]
            else:
                props['SourceType'] = self.source_type

        if self.aws_organizations_source is not None:
            if hasattr(self.aws_organizations_source, 'to_dict'):
                props['AwsOrganizationsSource'] = self.aws_organizations_source.to_dict()
            elif isinstance(self.aws_organizations_source, list):
                props['AwsOrganizationsSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.aws_organizations_source
                ]
            else:
                props['AwsOrganizationsSource'] = self.aws_organizations_source

        if self.include_future_regions is not None:
            if hasattr(self.include_future_regions, 'to_dict'):
                props['IncludeFutureRegions'] = self.include_future_regions.to_dict()
            elif isinstance(self.include_future_regions, list):
                props['IncludeFutureRegions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.include_future_regions
                ]
            else:
                props['IncludeFutureRegions'] = self.include_future_regions

        if self.source_regions is not None:
            if hasattr(self.source_regions, 'to_dict'):
                props['SourceRegions'] = self.source_regions.to_dict()
            elif isinstance(self.source_regions, list):
                props['SourceRegions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_regions
                ]
            else:
                props['SourceRegions'] = self.source_regions

        return props


@dataclass
class ResourceDataSync(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-r"""

    resource_type: ClassVar[str] = "AWS::SSM::ResourceDataSync"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    s3_destination: Optional[S3Destination] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sync_source: Optional[SyncSource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    bucket_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    bucket_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sync_format: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sync_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sync_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    bucket_prefix: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_destination is not None:
            # Serialize s3_destination (handle intrinsic functions)
            if hasattr(self.s3_destination, 'to_dict'):
                props["S3Destination"] = self.s3_destination.to_dict()
            elif isinstance(self.s3_destination, list):
                # Serialize list items (may contain intrinsic functions)
                props['S3Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_destination
                ]
            else:
                props["S3Destination"] = self.s3_destination

        if self.kms_key_arn is not None:
            # Serialize kms_key_arn (handle intrinsic functions)
            if hasattr(self.kms_key_arn, 'to_dict'):
                props["KMSKeyArn"] = self.kms_key_arn.to_dict()
            elif isinstance(self.kms_key_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['KMSKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_arn
                ]
            else:
                props["KMSKeyArn"] = self.kms_key_arn

        if self.sync_source is not None:
            # Serialize sync_source (handle intrinsic functions)
            if hasattr(self.sync_source, 'to_dict'):
                props["SyncSource"] = self.sync_source.to_dict()
            elif isinstance(self.sync_source, list):
                # Serialize list items (may contain intrinsic functions)
                props['SyncSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sync_source
                ]
            else:
                props["SyncSource"] = self.sync_source

        if self.bucket_name is not None:
            # Serialize bucket_name (handle intrinsic functions)
            if hasattr(self.bucket_name, 'to_dict'):
                props["BucketName"] = self.bucket_name.to_dict()
            elif isinstance(self.bucket_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['BucketName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket_name
                ]
            else:
                props["BucketName"] = self.bucket_name

        if self.bucket_region is not None:
            # Serialize bucket_region (handle intrinsic functions)
            if hasattr(self.bucket_region, 'to_dict'):
                props["BucketRegion"] = self.bucket_region.to_dict()
            elif isinstance(self.bucket_region, list):
                # Serialize list items (may contain intrinsic functions)
                props['BucketRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket_region
                ]
            else:
                props["BucketRegion"] = self.bucket_region

        if self.sync_format is not None:
            # Serialize sync_format (handle intrinsic functions)
            if hasattr(self.sync_format, 'to_dict'):
                props["SyncFormat"] = self.sync_format.to_dict()
            elif isinstance(self.sync_format, list):
                # Serialize list items (may contain intrinsic functions)
                props['SyncFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sync_format
                ]
            else:
                props["SyncFormat"] = self.sync_format

        if self.sync_name is not None:
            # Serialize sync_name (handle intrinsic functions)
            if hasattr(self.sync_name, 'to_dict'):
                props["SyncName"] = self.sync_name.to_dict()
            elif isinstance(self.sync_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['SyncName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sync_name
                ]
            else:
                props["SyncName"] = self.sync_name

        if self.sync_type is not None:
            # Serialize sync_type (handle intrinsic functions)
            if hasattr(self.sync_type, 'to_dict'):
                props["SyncType"] = self.sync_type.to_dict()
            elif isinstance(self.sync_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['SyncType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sync_type
                ]
            else:
                props["SyncType"] = self.sync_type

        if self.bucket_prefix is not None:
            # Serialize bucket_prefix (handle intrinsic functions)
            if hasattr(self.bucket_prefix, 'to_dict'):
                props["BucketPrefix"] = self.bucket_prefix.to_dict()
            elif isinstance(self.bucket_prefix, list):
                # Serialize list items (may contain intrinsic functions)
                props['BucketPrefix'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket_prefix
                ]
            else:
                props["BucketPrefix"] = self.bucket_prefix

        return props



@dataclass
class ResourcePolicy(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ssm-r"""

    resource_type: ClassVar[str] = "AWS::SSM::ResourcePolicy"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    policy: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.policy is not None:
            # Serialize policy (handle intrinsic functions)
            if hasattr(self.policy, 'to_dict'):
                props["Policy"] = self.policy.to_dict()
            elif isinstance(self.policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['Policy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.policy
                ]
            else:
                props["Policy"] = self.policy

        if self.resource_arn is not None:
            # Serialize resource_arn (handle intrinsic functions)
            if hasattr(self.resource_arn, 'to_dict'):
                props["ResourceArn"] = self.resource_arn.to_dict()
            elif isinstance(self.resource_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_arn
                ]
            else:
                props["ResourceArn"] = self.resource_arn

        return props

    @property
    def attr_policy_hash(self) -> GetAtt:
        """Get the PolicyHash attribute."""
        return self.get_att("PolicyHash")

    @property
    def attr_policy_id(self) -> GetAtt:
        """Get the PolicyId attribute."""
        return self.get_att("PolicyId")



