"""
AWS CloudFormation LicenseManager Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:37

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service LicenseManager
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class ActivationOverrideBehavior:
    """ActivationOverrideBehavior enum values."""

    DISTRIBUTED_GRANTS_ONLY = "DISTRIBUTED_GRANTS_ONLY"
    ALL_GRANTS_PERMITTED_BY_ISSUER = "ALL_GRANTS_PERMITTED_BY_ISSUER"


class AllowedOperation:
    """AllowedOperation enum values."""

    CREATEGRANT = "CreateGrant"
    CHECKOUTLICENSE = "CheckoutLicense"
    CHECKOUTBORROWLICENSE = "CheckoutBorrowLicense"
    CHECKINLICENSE = "CheckInLicense"
    EXTENDCONSUMPTIONLICENSE = "ExtendConsumptionLicense"
    LISTPURCHASEDLICENSES = "ListPurchasedLicenses"
    CREATETOKEN = "CreateToken"


class CheckoutType:
    """CheckoutType enum values."""

    PROVISIONAL = "PROVISIONAL"
    PERPETUAL = "PERPETUAL"


class DigitalSignatureMethod:
    """DigitalSignatureMethod enum values."""

    JWT_PS384 = "JWT_PS384"


class EntitlementDataUnit:
    """EntitlementDataUnit enum values."""

    COUNT = "Count"
    NONE = "None"
    SECONDS = "Seconds"
    MICROSECONDS = "Microseconds"
    MILLISECONDS = "Milliseconds"
    BYTES = "Bytes"
    KILOBYTES = "Kilobytes"
    MEGABYTES = "Megabytes"
    GIGABYTES = "Gigabytes"
    TERABYTES = "Terabytes"
    BITS = "Bits"
    KILOBITS = "Kilobits"
    MEGABITS = "Megabits"
    GIGABITS = "Gigabits"
    TERABITS = "Terabits"
    PERCENT = "Percent"
    BYTES_SECOND = "Bytes/Second"
    KILOBYTES_SECOND = "Kilobytes/Second"
    MEGABYTES_SECOND = "Megabytes/Second"
    GIGABYTES_SECOND = "Gigabytes/Second"
    TERABYTES_SECOND = "Terabytes/Second"
    BITS_SECOND = "Bits/Second"
    KILOBITS_SECOND = "Kilobits/Second"
    MEGABITS_SECOND = "Megabits/Second"
    GIGABITS_SECOND = "Gigabits/Second"
    TERABITS_SECOND = "Terabits/Second"
    COUNT_SECOND = "Count/Second"


class EntitlementUnit:
    """EntitlementUnit enum values."""

    COUNT = "Count"
    NONE = "None"
    SECONDS = "Seconds"
    MICROSECONDS = "Microseconds"
    MILLISECONDS = "Milliseconds"
    BYTES = "Bytes"
    KILOBYTES = "Kilobytes"
    MEGABYTES = "Megabytes"
    GIGABYTES = "Gigabytes"
    TERABYTES = "Terabytes"
    BITS = "Bits"
    KILOBITS = "Kilobits"
    MEGABITS = "Megabits"
    GIGABITS = "Gigabits"
    TERABITS = "Terabits"
    PERCENT = "Percent"
    BYTES_SECOND = "Bytes/Second"
    KILOBYTES_SECOND = "Kilobytes/Second"
    MEGABYTES_SECOND = "Megabytes/Second"
    GIGABYTES_SECOND = "Gigabytes/Second"
    TERABYTES_SECOND = "Terabytes/Second"
    BITS_SECOND = "Bits/Second"
    KILOBITS_SECOND = "Kilobits/Second"
    MEGABITS_SECOND = "Megabits/Second"
    GIGABITS_SECOND = "Gigabits/Second"
    TERABITS_SECOND = "Terabits/Second"
    COUNT_SECOND = "Count/Second"


class GrantStatus:
    """GrantStatus enum values."""

    PENDING_WORKFLOW = "PENDING_WORKFLOW"
    PENDING_ACCEPT = "PENDING_ACCEPT"
    REJECTED = "REJECTED"
    ACTIVE = "ACTIVE"
    FAILED_WORKFLOW = "FAILED_WORKFLOW"
    DELETED = "DELETED"
    PENDING_DELETE = "PENDING_DELETE"
    DISABLED = "DISABLED"
    WORKFLOW_COMPLETED = "WORKFLOW_COMPLETED"


class InventoryFilterCondition:
    """InventoryFilterCondition enum values."""

    EQUALS = "EQUALS"
    NOT_EQUALS = "NOT_EQUALS"
    BEGINS_WITH = "BEGINS_WITH"
    CONTAINS = "CONTAINS"


class LicenseAssetGroupStatus:
    """LicenseAssetGroupStatus enum values."""

    ACTIVE = "ACTIVE"
    DISABLED = "DISABLED"
    DELETED = "DELETED"


class LicenseConfigurationStatus:
    """LicenseConfigurationStatus enum values."""

    AVAILABLE = "AVAILABLE"
    DISABLED = "DISABLED"


class LicenseConversionTaskStatus:
    """LicenseConversionTaskStatus enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"


class LicenseCountingType:
    """LicenseCountingType enum values."""

    VCPU = "vCPU"
    INSTANCE = "Instance"
    CORE = "Core"
    SOCKET = "Socket"


class LicenseDeletionStatus:
    """LicenseDeletionStatus enum values."""

    PENDING_DELETE = "PENDING_DELETE"
    DELETED = "DELETED"


class LicenseStatus:
    """LicenseStatus enum values."""

    AVAILABLE = "AVAILABLE"
    PENDING_AVAILABLE = "PENDING_AVAILABLE"
    DEACTIVATED = "DEACTIVATED"
    SUSPENDED = "SUSPENDED"
    EXPIRED = "EXPIRED"
    PENDING_DELETE = "PENDING_DELETE"
    DELETED = "DELETED"


class ProductCodeType:
    """ProductCodeType enum values."""

    MARKETPLACE = "marketplace"


class ReceivedStatus:
    """ReceivedStatus enum values."""

    PENDING_WORKFLOW = "PENDING_WORKFLOW"
    PENDING_ACCEPT = "PENDING_ACCEPT"
    REJECTED = "REJECTED"
    ACTIVE = "ACTIVE"
    FAILED_WORKFLOW = "FAILED_WORKFLOW"
    DELETED = "DELETED"
    DISABLED = "DISABLED"
    WORKFLOW_COMPLETED = "WORKFLOW_COMPLETED"


class RenewType:
    """RenewType enum values."""

    NONE = "None"
    WEEKLY = "Weekly"
    MONTHLY = "Monthly"


class ReportFrequencyType:
    """ReportFrequencyType enum values."""

    DAY = "DAY"
    WEEK = "WEEK"
    MONTH = "MONTH"
    ONE_TIME = "ONE_TIME"


class ReportType:
    """ReportType enum values."""

    LICENSECONFIGURATIONSUMMARYREPORT = "LicenseConfigurationSummaryReport"
    LICENSECONFIGURATIONUSAGEREPORT = "LicenseConfigurationUsageReport"
    LICENSEASSETGROUPUSAGEREPORT = "LicenseAssetGroupUsageReport"


class ResourceType:
    """ResourceType enum values."""

    EC2_INSTANCE = "EC2_INSTANCE"
    EC2_HOST = "EC2_HOST"
    EC2_AMI = "EC2_AMI"
    RDS = "RDS"
    SYSTEMS_MANAGER_MANAGED_INSTANCE = "SYSTEMS_MANAGER_MANAGED_INSTANCE"


class TokenType:
    """TokenType enum values."""

    REFRESH_TOKEN = "REFRESH_TOKEN"


# Convenient aliases for enum values
DISTRIBUTED_GRANTS_ONLY = ActivationOverrideBehavior.DISTRIBUTED_GRANTS_ONLY
ALL_GRANTS_PERMITTED_BY_ISSUER = ActivationOverrideBehavior.ALL_GRANTS_PERMITTED_BY_ISSUER
CREATEGRANT = AllowedOperation.CREATEGRANT
CHECKOUTLICENSE = AllowedOperation.CHECKOUTLICENSE
CHECKOUTBORROWLICENSE = AllowedOperation.CHECKOUTBORROWLICENSE
CHECKINLICENSE = AllowedOperation.CHECKINLICENSE
EXTENDCONSUMPTIONLICENSE = AllowedOperation.EXTENDCONSUMPTIONLICENSE
LISTPURCHASEDLICENSES = AllowedOperation.LISTPURCHASEDLICENSES
CREATETOKEN = AllowedOperation.CREATETOKEN
PROVISIONAL = CheckoutType.PROVISIONAL
PERPETUAL = CheckoutType.PERPETUAL
JWT_PS384 = DigitalSignatureMethod.JWT_PS384
COUNT = EntitlementDataUnit.COUNT
NONE = EntitlementDataUnit.NONE
SECONDS = EntitlementDataUnit.SECONDS
MICROSECONDS = EntitlementDataUnit.MICROSECONDS
MILLISECONDS = EntitlementDataUnit.MILLISECONDS
BYTES = EntitlementDataUnit.BYTES
KILOBYTES = EntitlementDataUnit.KILOBYTES
MEGABYTES = EntitlementDataUnit.MEGABYTES
GIGABYTES = EntitlementDataUnit.GIGABYTES
TERABYTES = EntitlementDataUnit.TERABYTES
BITS = EntitlementDataUnit.BITS
KILOBITS = EntitlementDataUnit.KILOBITS
MEGABITS = EntitlementDataUnit.MEGABITS
GIGABITS = EntitlementDataUnit.GIGABITS
TERABITS = EntitlementDataUnit.TERABITS
PERCENT = EntitlementDataUnit.PERCENT
BYTES_SECOND = EntitlementDataUnit.BYTES_SECOND
KILOBYTES_SECOND = EntitlementDataUnit.KILOBYTES_SECOND
MEGABYTES_SECOND = EntitlementDataUnit.MEGABYTES_SECOND
GIGABYTES_SECOND = EntitlementDataUnit.GIGABYTES_SECOND
TERABYTES_SECOND = EntitlementDataUnit.TERABYTES_SECOND
BITS_SECOND = EntitlementDataUnit.BITS_SECOND
KILOBITS_SECOND = EntitlementDataUnit.KILOBITS_SECOND
MEGABITS_SECOND = EntitlementDataUnit.MEGABITS_SECOND
GIGABITS_SECOND = EntitlementDataUnit.GIGABITS_SECOND
TERABITS_SECOND = EntitlementDataUnit.TERABITS_SECOND
COUNT_SECOND = EntitlementDataUnit.COUNT_SECOND
COUNT = EntitlementUnit.COUNT
NONE = EntitlementUnit.NONE
SECONDS = EntitlementUnit.SECONDS
MICROSECONDS = EntitlementUnit.MICROSECONDS
MILLISECONDS = EntitlementUnit.MILLISECONDS
BYTES = EntitlementUnit.BYTES
KILOBYTES = EntitlementUnit.KILOBYTES
MEGABYTES = EntitlementUnit.MEGABYTES
GIGABYTES = EntitlementUnit.GIGABYTES
TERABYTES = EntitlementUnit.TERABYTES
BITS = EntitlementUnit.BITS
KILOBITS = EntitlementUnit.KILOBITS
MEGABITS = EntitlementUnit.MEGABITS
GIGABITS = EntitlementUnit.GIGABITS
TERABITS = EntitlementUnit.TERABITS
PERCENT = EntitlementUnit.PERCENT
BYTES_SECOND = EntitlementUnit.BYTES_SECOND
KILOBYTES_SECOND = EntitlementUnit.KILOBYTES_SECOND
MEGABYTES_SECOND = EntitlementUnit.MEGABYTES_SECOND
GIGABYTES_SECOND = EntitlementUnit.GIGABYTES_SECOND
TERABYTES_SECOND = EntitlementUnit.TERABYTES_SECOND
BITS_SECOND = EntitlementUnit.BITS_SECOND
KILOBITS_SECOND = EntitlementUnit.KILOBITS_SECOND
MEGABITS_SECOND = EntitlementUnit.MEGABITS_SECOND
GIGABITS_SECOND = EntitlementUnit.GIGABITS_SECOND
TERABITS_SECOND = EntitlementUnit.TERABITS_SECOND
COUNT_SECOND = EntitlementUnit.COUNT_SECOND
PENDING_WORKFLOW = GrantStatus.PENDING_WORKFLOW
PENDING_ACCEPT = GrantStatus.PENDING_ACCEPT
REJECTED = GrantStatus.REJECTED
ACTIVE = GrantStatus.ACTIVE
FAILED_WORKFLOW = GrantStatus.FAILED_WORKFLOW
DELETED = GrantStatus.DELETED
PENDING_DELETE = GrantStatus.PENDING_DELETE
DISABLED = GrantStatus.DISABLED
WORKFLOW_COMPLETED = GrantStatus.WORKFLOW_COMPLETED
EQUALS = InventoryFilterCondition.EQUALS
NOT_EQUALS = InventoryFilterCondition.NOT_EQUALS
BEGINS_WITH = InventoryFilterCondition.BEGINS_WITH
CONTAINS = InventoryFilterCondition.CONTAINS
ACTIVE = LicenseAssetGroupStatus.ACTIVE
DISABLED = LicenseAssetGroupStatus.DISABLED
DELETED = LicenseAssetGroupStatus.DELETED
AVAILABLE = LicenseConfigurationStatus.AVAILABLE
DISABLED = LicenseConfigurationStatus.DISABLED
IN_PROGRESS = LicenseConversionTaskStatus.IN_PROGRESS
SUCCEEDED = LicenseConversionTaskStatus.SUCCEEDED
FAILED = LicenseConversionTaskStatus.FAILED
VCPU = LicenseCountingType.VCPU
INSTANCE = LicenseCountingType.INSTANCE
CORE = LicenseCountingType.CORE
SOCKET = LicenseCountingType.SOCKET
PENDING_DELETE = LicenseDeletionStatus.PENDING_DELETE
DELETED = LicenseDeletionStatus.DELETED
AVAILABLE = LicenseStatus.AVAILABLE
PENDING_AVAILABLE = LicenseStatus.PENDING_AVAILABLE
DEACTIVATED = LicenseStatus.DEACTIVATED
SUSPENDED = LicenseStatus.SUSPENDED
EXPIRED = LicenseStatus.EXPIRED
PENDING_DELETE = LicenseStatus.PENDING_DELETE
DELETED = LicenseStatus.DELETED
MARKETPLACE = ProductCodeType.MARKETPLACE
PENDING_WORKFLOW = ReceivedStatus.PENDING_WORKFLOW
PENDING_ACCEPT = ReceivedStatus.PENDING_ACCEPT
REJECTED = ReceivedStatus.REJECTED
ACTIVE = ReceivedStatus.ACTIVE
FAILED_WORKFLOW = ReceivedStatus.FAILED_WORKFLOW
DELETED = ReceivedStatus.DELETED
DISABLED = ReceivedStatus.DISABLED
WORKFLOW_COMPLETED = ReceivedStatus.WORKFLOW_COMPLETED
NONE = RenewType.NONE
WEEKLY = RenewType.WEEKLY
MONTHLY = RenewType.MONTHLY
DAY = ReportFrequencyType.DAY
WEEK = ReportFrequencyType.WEEK
MONTH = ReportFrequencyType.MONTH
ONE_TIME = ReportFrequencyType.ONE_TIME
LICENSECONFIGURATIONSUMMARYREPORT = ReportType.LICENSECONFIGURATIONSUMMARYREPORT
LICENSECONFIGURATIONUSAGEREPORT = ReportType.LICENSECONFIGURATIONUSAGEREPORT
LICENSEASSETGROUPUSAGEREPORT = ReportType.LICENSEASSETGROUPUSAGEREPORT
EC2_INSTANCE = ResourceType.EC2_INSTANCE
EC2_HOST = ResourceType.EC2_HOST
EC2_AMI = ResourceType.EC2_AMI
RDS = ResourceType.RDS
SYSTEMS_MANAGER_MANAGED_INSTANCE = ResourceType.SYSTEMS_MANAGER_MANAGED_INSTANCE
REFRESH_TOKEN = TokenType.REFRESH_TOKEN


@dataclass
class Grant(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-licen"""

    resource_type: ClassVar[str] = "AWS::LicenseManager::Grant"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    principals: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    home_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    allowed_operations: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    license_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    grant_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.status is not None:
            # Serialize status (handle intrinsic functions)
            if hasattr(self.status, 'to_dict'):
                props["Status"] = self.status.to_dict()
            elif isinstance(self.status, list):
                # Serialize list items (may contain intrinsic functions)
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props["Status"] = self.status

        if self.principals is not None:
            # Serialize principals (handle intrinsic functions)
            if hasattr(self.principals, 'to_dict'):
                props["Principals"] = self.principals.to_dict()
            elif isinstance(self.principals, list):
                # Serialize list items (may contain intrinsic functions)
                props['Principals'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.principals
                ]
            else:
                props["Principals"] = self.principals

        if self.home_region is not None:
            # Serialize home_region (handle intrinsic functions)
            if hasattr(self.home_region, 'to_dict'):
                props["HomeRegion"] = self.home_region.to_dict()
            elif isinstance(self.home_region, list):
                # Serialize list items (may contain intrinsic functions)
                props['HomeRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.home_region
                ]
            else:
                props["HomeRegion"] = self.home_region

        if self.allowed_operations is not None:
            # Serialize allowed_operations (handle intrinsic functions)
            if hasattr(self.allowed_operations, 'to_dict'):
                props["AllowedOperations"] = self.allowed_operations.to_dict()
            elif isinstance(self.allowed_operations, list):
                # Serialize list items (may contain intrinsic functions)
                props['AllowedOperations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allowed_operations
                ]
            else:
                props["AllowedOperations"] = self.allowed_operations

        if self.license_arn is not None:
            # Serialize license_arn (handle intrinsic functions)
            if hasattr(self.license_arn, 'to_dict'):
                props["LicenseArn"] = self.license_arn.to_dict()
            elif isinstance(self.license_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['LicenseArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.license_arn
                ]
            else:
                props["LicenseArn"] = self.license_arn

        if self.grant_name is not None:
            # Serialize grant_name (handle intrinsic functions)
            if hasattr(self.grant_name, 'to_dict'):
                props["GrantName"] = self.grant_name.to_dict()
            elif isinstance(self.grant_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['GrantName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.grant_name
                ]
            else:
                props["GrantName"] = self.grant_name

        return props

    @property
    def attr_grant_arn(self) -> GetAtt:
        """Get the GrantArn attribute."""
        return self.get_att("GrantArn")

    @property
    def attr_version(self) -> GetAtt:
        """Get the Version attribute."""
        return self.get_att("Version")




@dataclass
class BorrowConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lic"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allow_early_check_in: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_time_to_live_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.allow_early_check_in is not None:
            if hasattr(self.allow_early_check_in, 'to_dict'):
                props['AllowEarlyCheckIn'] = self.allow_early_check_in.to_dict()
            elif isinstance(self.allow_early_check_in, list):
                props['AllowEarlyCheckIn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allow_early_check_in
                ]
            else:
                props['AllowEarlyCheckIn'] = self.allow_early_check_in

        if self.max_time_to_live_in_minutes is not None:
            if hasattr(self.max_time_to_live_in_minutes, 'to_dict'):
                props['MaxTimeToLiveInMinutes'] = self.max_time_to_live_in_minutes.to_dict()
            elif isinstance(self.max_time_to_live_in_minutes, list):
                props['MaxTimeToLiveInMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_time_to_live_in_minutes
                ]
            else:
                props['MaxTimeToLiveInMinutes'] = self.max_time_to_live_in_minutes

        return props


@dataclass
class ConsumptionConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lic"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    borrow_configuration: Optional[BorrowConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    renew_type: Optional[Union[str, RenewType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provisional_configuration: Optional[ProvisionalConfiguration] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.borrow_configuration is not None:
            if hasattr(self.borrow_configuration, 'to_dict'):
                props['BorrowConfiguration'] = self.borrow_configuration.to_dict()
            elif isinstance(self.borrow_configuration, list):
                props['BorrowConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.borrow_configuration
                ]
            else:
                props['BorrowConfiguration'] = self.borrow_configuration

        if self.renew_type is not None:
            if hasattr(self.renew_type, 'to_dict'):
                props['RenewType'] = self.renew_type.to_dict()
            elif isinstance(self.renew_type, list):
                props['RenewType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.renew_type
                ]
            else:
                props['RenewType'] = self.renew_type

        if self.provisional_configuration is not None:
            if hasattr(self.provisional_configuration, 'to_dict'):
                props['ProvisionalConfiguration'] = self.provisional_configuration.to_dict()
            elif isinstance(self.provisional_configuration, list):
                props['ProvisionalConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.provisional_configuration
                ]
            else:
                props['ProvisionalConfiguration'] = self.provisional_configuration

        return props


@dataclass
class Entitlement:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lic"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    allow_check_in: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    overage: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, EntitlementUnit, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.allow_check_in is not None:
            if hasattr(self.allow_check_in, 'to_dict'):
                props['AllowCheckIn'] = self.allow_check_in.to_dict()
            elif isinstance(self.allow_check_in, list):
                props['AllowCheckIn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.allow_check_in
                ]
            else:
                props['AllowCheckIn'] = self.allow_check_in

        if self.overage is not None:
            if hasattr(self.overage, 'to_dict'):
                props['Overage'] = self.overage.to_dict()
            elif isinstance(self.overage, list):
                props['Overage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.overage
                ]
            else:
                props['Overage'] = self.overage

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.max_count is not None:
            if hasattr(self.max_count, 'to_dict'):
                props['MaxCount'] = self.max_count.to_dict()
            elif isinstance(self.max_count, list):
                props['MaxCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_count
                ]
            else:
                props['MaxCount'] = self.max_count

        if self.unit is not None:
            if hasattr(self.unit, 'to_dict'):
                props['Unit'] = self.unit.to_dict()
            elif isinstance(self.unit, list):
                props['Unit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unit
                ]
            else:
                props['Unit'] = self.unit

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class IssuerData:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lic"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sign_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.sign_key is not None:
            if hasattr(self.sign_key, 'to_dict'):
                props['SignKey'] = self.sign_key.to_dict()
            elif isinstance(self.sign_key, list):
                props['SignKey'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sign_key
                ]
            else:
                props['SignKey'] = self.sign_key

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class Metadata:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lic"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class ProvisionalConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lic"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_time_to_live_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_time_to_live_in_minutes is not None:
            if hasattr(self.max_time_to_live_in_minutes, 'to_dict'):
                props['MaxTimeToLiveInMinutes'] = self.max_time_to_live_in_minutes.to_dict()
            elif isinstance(self.max_time_to_live_in_minutes, list):
                props['MaxTimeToLiveInMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_time_to_live_in_minutes
                ]
            else:
                props['MaxTimeToLiveInMinutes'] = self.max_time_to_live_in_minutes

        return props


@dataclass
class ValidityDateFormat:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lic"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    begin: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    end: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.begin is not None:
            if hasattr(self.begin, 'to_dict'):
                props['Begin'] = self.begin.to_dict()
            elif isinstance(self.begin, list):
                props['Begin'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.begin
                ]
            else:
                props['Begin'] = self.begin

        if self.end is not None:
            if hasattr(self.end, 'to_dict'):
                props['End'] = self.end.to_dict()
            elif isinstance(self.end, list):
                props['End'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.end
                ]
            else:
                props['End'] = self.end

        return props


@dataclass
class License(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-licen"""

    resource_type: ClassVar[str] = "AWS::LicenseManager::License"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    product_sku: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    status: Optional[Union[str, LicenseStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    consumption_configuration: Optional[ConsumptionConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    validity: Optional[ValidityDateFormat] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    product_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    issuer: Optional[IssuerData] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    home_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    entitlements: Optional[list[Entitlement]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    license_metadata: Optional[list[Metadata]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    license_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    beneficiary: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.product_sku is not None:
            # Serialize product_sku (handle intrinsic functions)
            if hasattr(self.product_sku, 'to_dict'):
                props["ProductSKU"] = self.product_sku.to_dict()
            elif isinstance(self.product_sku, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProductSKU'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.product_sku
                ]
            else:
                props["ProductSKU"] = self.product_sku

        if self.status is not None:
            # Serialize status (handle intrinsic functions)
            if hasattr(self.status, 'to_dict'):
                props["Status"] = self.status.to_dict()
            elif isinstance(self.status, list):
                # Serialize list items (may contain intrinsic functions)
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props["Status"] = self.status

        if self.consumption_configuration is not None:
            # Serialize consumption_configuration (handle intrinsic functions)
            if hasattr(self.consumption_configuration, 'to_dict'):
                props["ConsumptionConfiguration"] = self.consumption_configuration.to_dict()
            elif isinstance(self.consumption_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['ConsumptionConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.consumption_configuration
                ]
            else:
                props["ConsumptionConfiguration"] = self.consumption_configuration

        if self.validity is not None:
            # Serialize validity (handle intrinsic functions)
            if hasattr(self.validity, 'to_dict'):
                props["Validity"] = self.validity.to_dict()
            elif isinstance(self.validity, list):
                # Serialize list items (may contain intrinsic functions)
                props['Validity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.validity
                ]
            else:
                props["Validity"] = self.validity

        if self.product_name is not None:
            # Serialize product_name (handle intrinsic functions)
            if hasattr(self.product_name, 'to_dict'):
                props["ProductName"] = self.product_name.to_dict()
            elif isinstance(self.product_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProductName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.product_name
                ]
            else:
                props["ProductName"] = self.product_name

        if self.issuer is not None:
            # Serialize issuer (handle intrinsic functions)
            if hasattr(self.issuer, 'to_dict'):
                props["Issuer"] = self.issuer.to_dict()
            elif isinstance(self.issuer, list):
                # Serialize list items (may contain intrinsic functions)
                props['Issuer'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.issuer
                ]
            else:
                props["Issuer"] = self.issuer

        if self.home_region is not None:
            # Serialize home_region (handle intrinsic functions)
            if hasattr(self.home_region, 'to_dict'):
                props["HomeRegion"] = self.home_region.to_dict()
            elif isinstance(self.home_region, list):
                # Serialize list items (may contain intrinsic functions)
                props['HomeRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.home_region
                ]
            else:
                props["HomeRegion"] = self.home_region

        if self.entitlements is not None:
            # Serialize entitlements (handle intrinsic functions)
            if hasattr(self.entitlements, 'to_dict'):
                props["Entitlements"] = self.entitlements.to_dict()
            elif isinstance(self.entitlements, list):
                # Serialize list items (may contain intrinsic functions)
                props['Entitlements'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.entitlements
                ]
            else:
                props["Entitlements"] = self.entitlements

        if self.license_metadata is not None:
            # Serialize license_metadata (handle intrinsic functions)
            if hasattr(self.license_metadata, 'to_dict'):
                props["LicenseMetadata"] = self.license_metadata.to_dict()
            elif isinstance(self.license_metadata, list):
                # Serialize list items (may contain intrinsic functions)
                props['LicenseMetadata'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.license_metadata
                ]
            else:
                props["LicenseMetadata"] = self.license_metadata

        if self.license_name is not None:
            # Serialize license_name (handle intrinsic functions)
            if hasattr(self.license_name, 'to_dict'):
                props["LicenseName"] = self.license_name.to_dict()
            elif isinstance(self.license_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LicenseName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.license_name
                ]
            else:
                props["LicenseName"] = self.license_name

        if self.beneficiary is not None:
            # Serialize beneficiary (handle intrinsic functions)
            if hasattr(self.beneficiary, 'to_dict'):
                props["Beneficiary"] = self.beneficiary.to_dict()
            elif isinstance(self.beneficiary, list):
                # Serialize list items (may contain intrinsic functions)
                props['Beneficiary'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.beneficiary
                ]
            else:
                props["Beneficiary"] = self.beneficiary

        return props

    @property
    def attr_version(self) -> GetAtt:
        """Get the Version attribute."""
        return self.get_att("Version")

    @property
    def attr_license_arn(self) -> GetAtt:
        """Get the LicenseArn attribute."""
        return self.get_att("LicenseArn")



