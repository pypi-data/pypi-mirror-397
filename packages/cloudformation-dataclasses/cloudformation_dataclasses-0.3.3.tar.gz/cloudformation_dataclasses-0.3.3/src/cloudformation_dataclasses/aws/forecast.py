"""
AWS CloudFormation Forecast Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:36

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service Forecast
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AttributeType:
    """AttributeType enum values."""

    STRING = "string"
    INTEGER = "integer"
    FLOAT = "float"
    TIMESTAMP = "timestamp"
    GEOLOCATION = "geolocation"


class AutoMLOverrideStrategy:
    """AutoMLOverrideStrategy enum values."""

    LATENCYOPTIMIZED = "LatencyOptimized"
    ACCURACYOPTIMIZED = "AccuracyOptimized"


class Condition:
    """Condition enum values."""

    EQUALS = "EQUALS"
    NOT_EQUALS = "NOT_EQUALS"
    LESS_THAN = "LESS_THAN"
    GREATER_THAN = "GREATER_THAN"


class DatasetType:
    """DatasetType enum values."""

    TARGET_TIME_SERIES = "TARGET_TIME_SERIES"
    RELATED_TIME_SERIES = "RELATED_TIME_SERIES"
    ITEM_METADATA = "ITEM_METADATA"


class DayOfWeek:
    """DayOfWeek enum values."""

    MONDAY = "MONDAY"
    TUESDAY = "TUESDAY"
    WEDNESDAY = "WEDNESDAY"
    THURSDAY = "THURSDAY"
    FRIDAY = "FRIDAY"
    SATURDAY = "SATURDAY"
    SUNDAY = "SUNDAY"


class Domain:
    """Domain enum values."""

    RETAIL = "RETAIL"
    CUSTOM = "CUSTOM"
    INVENTORY_PLANNING = "INVENTORY_PLANNING"
    EC2_CAPACITY = "EC2_CAPACITY"
    WORK_FORCE = "WORK_FORCE"
    WEB_TRAFFIC = "WEB_TRAFFIC"
    METRICS = "METRICS"


class EvaluationType:
    """EvaluationType enum values."""

    SUMMARY = "SUMMARY"
    COMPUTED = "COMPUTED"


class FeaturizationMethodName:
    """FeaturizationMethodName enum values."""

    FILLING = "filling"


class FilterConditionString:
    """FilterConditionString enum values."""

    IS = "IS"
    IS_NOT = "IS_NOT"


class ImportMode:
    """ImportMode enum values."""

    FULL = "FULL"
    INCREMENTAL = "INCREMENTAL"


class Month:
    """Month enum values."""

    JANUARY = "JANUARY"
    FEBRUARY = "FEBRUARY"
    MARCH = "MARCH"
    APRIL = "APRIL"
    MAY = "MAY"
    JUNE = "JUNE"
    JULY = "JULY"
    AUGUST = "AUGUST"
    SEPTEMBER = "SEPTEMBER"
    OCTOBER = "OCTOBER"
    NOVEMBER = "NOVEMBER"
    DECEMBER = "DECEMBER"


class Operation:
    """Operation enum values."""

    ADD = "ADD"
    SUBTRACT = "SUBTRACT"
    MULTIPLY = "MULTIPLY"
    DIVIDE = "DIVIDE"


class OptimizationMetric:
    """OptimizationMetric enum values."""

    WAPE = "WAPE"
    RMSE = "RMSE"
    AVERAGEWEIGHTEDQUANTILELOSS = "AverageWeightedQuantileLoss"
    MASE = "MASE"
    MAPE = "MAPE"


class ScalingType:
    """ScalingType enum values."""

    AUTO = "Auto"
    LINEAR = "Linear"
    LOGARITHMIC = "Logarithmic"
    REVERSELOGARITHMIC = "ReverseLogarithmic"


class State:
    """State enum values."""

    ACTIVE = "Active"
    DELETED = "Deleted"


class TimePointGranularity:
    """TimePointGranularity enum values."""

    ALL = "ALL"
    SPECIFIC = "SPECIFIC"


class TimeSeriesGranularity:
    """TimeSeriesGranularity enum values."""

    ALL = "ALL"
    SPECIFIC = "SPECIFIC"


# Convenient aliases for enum values
STRING = AttributeType.STRING
INTEGER = AttributeType.INTEGER
FLOAT = AttributeType.FLOAT
TIMESTAMP = AttributeType.TIMESTAMP
GEOLOCATION = AttributeType.GEOLOCATION
LATENCYOPTIMIZED = AutoMLOverrideStrategy.LATENCYOPTIMIZED
ACCURACYOPTIMIZED = AutoMLOverrideStrategy.ACCURACYOPTIMIZED
EQUALS = Condition.EQUALS
NOT_EQUALS = Condition.NOT_EQUALS
LESS_THAN = Condition.LESS_THAN
GREATER_THAN = Condition.GREATER_THAN
TARGET_TIME_SERIES = DatasetType.TARGET_TIME_SERIES
RELATED_TIME_SERIES = DatasetType.RELATED_TIME_SERIES
ITEM_METADATA = DatasetType.ITEM_METADATA
MONDAY = DayOfWeek.MONDAY
TUESDAY = DayOfWeek.TUESDAY
WEDNESDAY = DayOfWeek.WEDNESDAY
THURSDAY = DayOfWeek.THURSDAY
FRIDAY = DayOfWeek.FRIDAY
SATURDAY = DayOfWeek.SATURDAY
SUNDAY = DayOfWeek.SUNDAY
RETAIL = Domain.RETAIL
CUSTOM = Domain.CUSTOM
INVENTORY_PLANNING = Domain.INVENTORY_PLANNING
EC2_CAPACITY = Domain.EC2_CAPACITY
WORK_FORCE = Domain.WORK_FORCE
WEB_TRAFFIC = Domain.WEB_TRAFFIC
METRICS = Domain.METRICS
SUMMARY = EvaluationType.SUMMARY
COMPUTED = EvaluationType.COMPUTED
FILLING = FeaturizationMethodName.FILLING
IS = FilterConditionString.IS
IS_NOT = FilterConditionString.IS_NOT
FULL = ImportMode.FULL
INCREMENTAL = ImportMode.INCREMENTAL
JANUARY = Month.JANUARY
FEBRUARY = Month.FEBRUARY
MARCH = Month.MARCH
APRIL = Month.APRIL
MAY = Month.MAY
JUNE = Month.JUNE
JULY = Month.JULY
AUGUST = Month.AUGUST
SEPTEMBER = Month.SEPTEMBER
OCTOBER = Month.OCTOBER
NOVEMBER = Month.NOVEMBER
DECEMBER = Month.DECEMBER
ADD = Operation.ADD
SUBTRACT = Operation.SUBTRACT
MULTIPLY = Operation.MULTIPLY
DIVIDE = Operation.DIVIDE
WAPE = OptimizationMetric.WAPE
RMSE = OptimizationMetric.RMSE
AVERAGEWEIGHTEDQUANTILELOSS = OptimizationMetric.AVERAGEWEIGHTEDQUANTILELOSS
MASE = OptimizationMetric.MASE
MAPE = OptimizationMetric.MAPE
AUTO = ScalingType.AUTO
LINEAR = ScalingType.LINEAR
LOGARITHMIC = ScalingType.LOGARITHMIC
REVERSELOGARITHMIC = ScalingType.REVERSELOGARITHMIC
ACTIVE = State.ACTIVE
DELETED = State.DELETED
ALL = TimePointGranularity.ALL
SPECIFIC = TimePointGranularity.SPECIFIC
ALL = TimeSeriesGranularity.ALL
SPECIFIC = TimeSeriesGranularity.SPECIFIC


@dataclass
class AttributesItems:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-for"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attribute_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attribute_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.attribute_type is not None:
            if hasattr(self.attribute_type, 'to_dict'):
                props['AttributeType'] = self.attribute_type.to_dict()
            elif isinstance(self.attribute_type, list):
                props['AttributeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attribute_type
                ]
            else:
                props['AttributeType'] = self.attribute_type

        if self.attribute_name is not None:
            if hasattr(self.attribute_name, 'to_dict'):
                props['AttributeName'] = self.attribute_name.to_dict()
            elif isinstance(self.attribute_name, list):
                props['AttributeName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attribute_name
                ]
            else:
                props['AttributeName'] = self.attribute_name

        return props


@dataclass
class EncryptionConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-for"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_arn is not None:
            if hasattr(self.kms_key_arn, 'to_dict'):
                props['KmsKeyArn'] = self.kms_key_arn.to_dict()
            elif isinstance(self.kms_key_arn, list):
                props['KmsKeyArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_arn
                ]
            else:
                props['KmsKeyArn'] = self.kms_key_arn

        if self.role_arn is not None:
            if hasattr(self.role_arn, 'to_dict'):
                props['RoleArn'] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props['RoleArn'] = self.role_arn

        return props


@dataclass
class Schema:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-for"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    attributes: Optional[list[AttributesItems]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.attributes is not None:
            if hasattr(self.attributes, 'to_dict'):
                props['Attributes'] = self.attributes.to_dict()
            elif isinstance(self.attributes, list):
                props['Attributes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.attributes
                ]
            else:
                props['Attributes'] = self.attributes

        return props


@dataclass
class TagsItems:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-for"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class Dataset(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-forec"""

    resource_type: ClassVar[str] = "AWS::Forecast::Dataset"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_frequency: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    dataset_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    schema: Optional[Schema] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    dataset_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    encryption_config: Optional[EncryptionConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[TagsItems]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.data_frequency is not None:
            # Serialize data_frequency (handle intrinsic functions)
            if hasattr(self.data_frequency, 'to_dict'):
                props["DataFrequency"] = self.data_frequency.to_dict()
            elif isinstance(self.data_frequency, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataFrequency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_frequency
                ]
            else:
                props["DataFrequency"] = self.data_frequency

        if self.dataset_name is not None:
            # Serialize dataset_name (handle intrinsic functions)
            if hasattr(self.dataset_name, 'to_dict'):
                props["DatasetName"] = self.dataset_name.to_dict()
            elif isinstance(self.dataset_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DatasetName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dataset_name
                ]
            else:
                props["DatasetName"] = self.dataset_name

        if self.schema is not None:
            # Serialize schema (handle intrinsic functions)
            if hasattr(self.schema, 'to_dict'):
                props["Schema"] = self.schema.to_dict()
            elif isinstance(self.schema, list):
                # Serialize list items (may contain intrinsic functions)
                props['Schema'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schema
                ]
            else:
                props["Schema"] = self.schema

        if self.dataset_type is not None:
            # Serialize dataset_type (handle intrinsic functions)
            if hasattr(self.dataset_type, 'to_dict'):
                props["DatasetType"] = self.dataset_type.to_dict()
            elif isinstance(self.dataset_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['DatasetType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dataset_type
                ]
            else:
                props["DatasetType"] = self.dataset_type

        if self.domain is not None:
            # Serialize domain (handle intrinsic functions)
            if hasattr(self.domain, 'to_dict'):
                props["Domain"] = self.domain.to_dict()
            elif isinstance(self.domain, list):
                # Serialize list items (may contain intrinsic functions)
                props['Domain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain
                ]
            else:
                props["Domain"] = self.domain

        if self.encryption_config is not None:
            # Serialize encryption_config (handle intrinsic functions)
            if hasattr(self.encryption_config, 'to_dict'):
                props["EncryptionConfig"] = self.encryption_config.to_dict()
            elif isinstance(self.encryption_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['EncryptionConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.encryption_config
                ]
            else:
                props["EncryptionConfig"] = self.encryption_config

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class DatasetGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-forec"""

    resource_type: ClassVar[str] = "AWS::Forecast::DatasetGroup"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    dataset_arns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    dataset_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.dataset_arns is not None:
            # Serialize dataset_arns (handle intrinsic functions)
            if hasattr(self.dataset_arns, 'to_dict'):
                props["DatasetArns"] = self.dataset_arns.to_dict()
            elif isinstance(self.dataset_arns, list):
                # Serialize list items (may contain intrinsic functions)
                props['DatasetArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dataset_arns
                ]
            else:
                props["DatasetArns"] = self.dataset_arns

        if self.dataset_group_name is not None:
            # Serialize dataset_group_name (handle intrinsic functions)
            if hasattr(self.dataset_group_name, 'to_dict'):
                props["DatasetGroupName"] = self.dataset_group_name.to_dict()
            elif isinstance(self.dataset_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DatasetGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dataset_group_name
                ]
            else:
                props["DatasetGroupName"] = self.dataset_group_name

        if self.domain is not None:
            # Serialize domain (handle intrinsic functions)
            if hasattr(self.domain, 'to_dict'):
                props["Domain"] = self.domain.to_dict()
            elif isinstance(self.domain, list):
                # Serialize list items (may contain intrinsic functions)
                props['Domain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain
                ]
            else:
                props["Domain"] = self.domain

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_dataset_group_arn(self) -> GetAtt:
        """Get the DatasetGroupArn attribute."""
        return self.get_att("DatasetGroupArn")



