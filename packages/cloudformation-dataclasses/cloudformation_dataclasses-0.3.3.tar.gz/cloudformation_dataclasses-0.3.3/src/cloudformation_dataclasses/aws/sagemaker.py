"""
AWS CloudFormation SageMaker Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:39

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service SageMaker
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AccountDefaultStatus:
    """AccountDefaultStatus enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class ActionStatus:
    """ActionStatus enum values."""

    UNKNOWN = "Unknown"
    INPROGRESS = "InProgress"
    COMPLETED = "Completed"
    FAILED = "Failed"
    STOPPING = "Stopping"
    STOPPED = "Stopped"


class ActivationState:
    """ActivationState enum values."""

    ENABLED = "Enabled"
    DISABLED = "Disabled"


class ActiveClusterOperationName:
    """ActiveClusterOperationName enum values."""

    SCALING = "Scaling"


class AdditionalS3DataSourceDataType:
    """AdditionalS3DataSourceDataType enum values."""

    S3OBJECT = "S3Object"
    S3PREFIX = "S3Prefix"


class AggregationTransformationValue:
    """AggregationTransformationValue enum values."""

    SUM = "sum"
    AVG = "avg"
    FIRST = "first"
    MIN = "min"
    MAX = "max"


class AlgorithmSortBy:
    """AlgorithmSortBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"


class AlgorithmStatus:
    """AlgorithmStatus enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    COMPLETED = "Completed"
    FAILED = "Failed"
    DELETING = "Deleting"


class AppImageConfigSortKey:
    """AppImageConfigSortKey enum values."""

    CREATIONTIME = "CreationTime"
    LASTMODIFIEDTIME = "LastModifiedTime"
    NAME = "Name"


class AppInstanceType:
    """AppInstanceType enum values."""

    SYSTEM = "system"
    ML_T3_MICRO = "ml.t3.micro"
    ML_T3_SMALL = "ml.t3.small"
    ML_T3_MEDIUM = "ml.t3.medium"
    ML_T3_LARGE = "ml.t3.large"
    ML_T3_XLARGE = "ml.t3.xlarge"
    ML_T3_2XLARGE = "ml.t3.2xlarge"
    ML_M5_LARGE = "ml.m5.large"
    ML_M5_XLARGE = "ml.m5.xlarge"
    ML_M5_2XLARGE = "ml.m5.2xlarge"
    ML_M5_4XLARGE = "ml.m5.4xlarge"
    ML_M5_8XLARGE = "ml.m5.8xlarge"
    ML_M5_12XLARGE = "ml.m5.12xlarge"
    ML_M5_16XLARGE = "ml.m5.16xlarge"
    ML_M5_24XLARGE = "ml.m5.24xlarge"
    ML_M5D_LARGE = "ml.m5d.large"
    ML_M5D_XLARGE = "ml.m5d.xlarge"
    ML_M5D_2XLARGE = "ml.m5d.2xlarge"
    ML_M5D_4XLARGE = "ml.m5d.4xlarge"
    ML_M5D_8XLARGE = "ml.m5d.8xlarge"
    ML_M5D_12XLARGE = "ml.m5d.12xlarge"
    ML_M5D_16XLARGE = "ml.m5d.16xlarge"
    ML_M5D_24XLARGE = "ml.m5d.24xlarge"
    ML_C5_LARGE = "ml.c5.large"
    ML_C5_XLARGE = "ml.c5.xlarge"
    ML_C5_2XLARGE = "ml.c5.2xlarge"
    ML_C5_4XLARGE = "ml.c5.4xlarge"
    ML_C5_9XLARGE = "ml.c5.9xlarge"
    ML_C5_12XLARGE = "ml.c5.12xlarge"
    ML_C5_18XLARGE = "ml.c5.18xlarge"
    ML_C5_24XLARGE = "ml.c5.24xlarge"
    ML_P3_2XLARGE = "ml.p3.2xlarge"
    ML_P3_8XLARGE = "ml.p3.8xlarge"
    ML_P3_16XLARGE = "ml.p3.16xlarge"
    ML_P3DN_24XLARGE = "ml.p3dn.24xlarge"
    ML_G4DN_XLARGE = "ml.g4dn.xlarge"
    ML_G4DN_2XLARGE = "ml.g4dn.2xlarge"
    ML_G4DN_4XLARGE = "ml.g4dn.4xlarge"
    ML_G4DN_8XLARGE = "ml.g4dn.8xlarge"
    ML_G4DN_12XLARGE = "ml.g4dn.12xlarge"
    ML_G4DN_16XLARGE = "ml.g4dn.16xlarge"
    ML_R5_LARGE = "ml.r5.large"
    ML_R5_XLARGE = "ml.r5.xlarge"
    ML_R5_2XLARGE = "ml.r5.2xlarge"
    ML_R5_4XLARGE = "ml.r5.4xlarge"
    ML_R5_8XLARGE = "ml.r5.8xlarge"
    ML_R5_12XLARGE = "ml.r5.12xlarge"
    ML_R5_16XLARGE = "ml.r5.16xlarge"
    ML_R5_24XLARGE = "ml.r5.24xlarge"
    ML_G5_XLARGE = "ml.g5.xlarge"
    ML_G5_2XLARGE = "ml.g5.2xlarge"
    ML_G5_4XLARGE = "ml.g5.4xlarge"
    ML_G5_8XLARGE = "ml.g5.8xlarge"
    ML_G5_16XLARGE = "ml.g5.16xlarge"
    ML_G5_12XLARGE = "ml.g5.12xlarge"
    ML_G5_24XLARGE = "ml.g5.24xlarge"
    ML_G5_48XLARGE = "ml.g5.48xlarge"
    ML_G6_XLARGE = "ml.g6.xlarge"
    ML_G6_2XLARGE = "ml.g6.2xlarge"
    ML_G6_4XLARGE = "ml.g6.4xlarge"
    ML_G6_8XLARGE = "ml.g6.8xlarge"
    ML_G6_12XLARGE = "ml.g6.12xlarge"
    ML_G6_16XLARGE = "ml.g6.16xlarge"
    ML_G6_24XLARGE = "ml.g6.24xlarge"
    ML_G6_48XLARGE = "ml.g6.48xlarge"
    ML_G6E_XLARGE = "ml.g6e.xlarge"
    ML_G6E_2XLARGE = "ml.g6e.2xlarge"
    ML_G6E_4XLARGE = "ml.g6e.4xlarge"
    ML_G6E_8XLARGE = "ml.g6e.8xlarge"
    ML_G6E_12XLARGE = "ml.g6e.12xlarge"
    ML_G6E_16XLARGE = "ml.g6e.16xlarge"
    ML_G6E_24XLARGE = "ml.g6e.24xlarge"
    ML_G6E_48XLARGE = "ml.g6e.48xlarge"
    ML_GEOSPATIAL_INTERACTIVE = "ml.geospatial.interactive"
    ML_P4D_24XLARGE = "ml.p4d.24xlarge"
    ML_P4DE_24XLARGE = "ml.p4de.24xlarge"
    ML_TRN1_2XLARGE = "ml.trn1.2xlarge"
    ML_TRN1_32XLARGE = "ml.trn1.32xlarge"
    ML_TRN1N_32XLARGE = "ml.trn1n.32xlarge"
    ML_P5_48XLARGE = "ml.p5.48xlarge"
    ML_P5EN_48XLARGE = "ml.p5en.48xlarge"
    ML_P6_B200_48XLARGE = "ml.p6-b200.48xlarge"
    ML_M6I_LARGE = "ml.m6i.large"
    ML_M6I_XLARGE = "ml.m6i.xlarge"
    ML_M6I_2XLARGE = "ml.m6i.2xlarge"
    ML_M6I_4XLARGE = "ml.m6i.4xlarge"
    ML_M6I_8XLARGE = "ml.m6i.8xlarge"
    ML_M6I_12XLARGE = "ml.m6i.12xlarge"
    ML_M6I_16XLARGE = "ml.m6i.16xlarge"
    ML_M6I_24XLARGE = "ml.m6i.24xlarge"
    ML_M6I_32XLARGE = "ml.m6i.32xlarge"
    ML_M7I_LARGE = "ml.m7i.large"
    ML_M7I_XLARGE = "ml.m7i.xlarge"
    ML_M7I_2XLARGE = "ml.m7i.2xlarge"
    ML_M7I_4XLARGE = "ml.m7i.4xlarge"
    ML_M7I_8XLARGE = "ml.m7i.8xlarge"
    ML_M7I_12XLARGE = "ml.m7i.12xlarge"
    ML_M7I_16XLARGE = "ml.m7i.16xlarge"
    ML_M7I_24XLARGE = "ml.m7i.24xlarge"
    ML_M7I_48XLARGE = "ml.m7i.48xlarge"
    ML_C6I_LARGE = "ml.c6i.large"
    ML_C6I_XLARGE = "ml.c6i.xlarge"
    ML_C6I_2XLARGE = "ml.c6i.2xlarge"
    ML_C6I_4XLARGE = "ml.c6i.4xlarge"
    ML_C6I_8XLARGE = "ml.c6i.8xlarge"
    ML_C6I_12XLARGE = "ml.c6i.12xlarge"
    ML_C6I_16XLARGE = "ml.c6i.16xlarge"
    ML_C6I_24XLARGE = "ml.c6i.24xlarge"
    ML_C6I_32XLARGE = "ml.c6i.32xlarge"
    ML_C7I_LARGE = "ml.c7i.large"
    ML_C7I_XLARGE = "ml.c7i.xlarge"
    ML_C7I_2XLARGE = "ml.c7i.2xlarge"
    ML_C7I_4XLARGE = "ml.c7i.4xlarge"
    ML_C7I_8XLARGE = "ml.c7i.8xlarge"
    ML_C7I_12XLARGE = "ml.c7i.12xlarge"
    ML_C7I_16XLARGE = "ml.c7i.16xlarge"
    ML_C7I_24XLARGE = "ml.c7i.24xlarge"
    ML_C7I_48XLARGE = "ml.c7i.48xlarge"
    ML_R6I_LARGE = "ml.r6i.large"
    ML_R6I_XLARGE = "ml.r6i.xlarge"
    ML_R6I_2XLARGE = "ml.r6i.2xlarge"
    ML_R6I_4XLARGE = "ml.r6i.4xlarge"
    ML_R6I_8XLARGE = "ml.r6i.8xlarge"
    ML_R6I_12XLARGE = "ml.r6i.12xlarge"
    ML_R6I_16XLARGE = "ml.r6i.16xlarge"
    ML_R6I_24XLARGE = "ml.r6i.24xlarge"
    ML_R6I_32XLARGE = "ml.r6i.32xlarge"
    ML_R7I_LARGE = "ml.r7i.large"
    ML_R7I_XLARGE = "ml.r7i.xlarge"
    ML_R7I_2XLARGE = "ml.r7i.2xlarge"
    ML_R7I_4XLARGE = "ml.r7i.4xlarge"
    ML_R7I_8XLARGE = "ml.r7i.8xlarge"
    ML_R7I_12XLARGE = "ml.r7i.12xlarge"
    ML_R7I_16XLARGE = "ml.r7i.16xlarge"
    ML_R7I_24XLARGE = "ml.r7i.24xlarge"
    ML_R7I_48XLARGE = "ml.r7i.48xlarge"
    ML_M6ID_LARGE = "ml.m6id.large"
    ML_M6ID_XLARGE = "ml.m6id.xlarge"
    ML_M6ID_2XLARGE = "ml.m6id.2xlarge"
    ML_M6ID_4XLARGE = "ml.m6id.4xlarge"
    ML_M6ID_8XLARGE = "ml.m6id.8xlarge"
    ML_M6ID_12XLARGE = "ml.m6id.12xlarge"
    ML_M6ID_16XLARGE = "ml.m6id.16xlarge"
    ML_M6ID_24XLARGE = "ml.m6id.24xlarge"
    ML_M6ID_32XLARGE = "ml.m6id.32xlarge"
    ML_C6ID_LARGE = "ml.c6id.large"
    ML_C6ID_XLARGE = "ml.c6id.xlarge"
    ML_C6ID_2XLARGE = "ml.c6id.2xlarge"
    ML_C6ID_4XLARGE = "ml.c6id.4xlarge"
    ML_C6ID_8XLARGE = "ml.c6id.8xlarge"
    ML_C6ID_12XLARGE = "ml.c6id.12xlarge"
    ML_C6ID_16XLARGE = "ml.c6id.16xlarge"
    ML_C6ID_24XLARGE = "ml.c6id.24xlarge"
    ML_C6ID_32XLARGE = "ml.c6id.32xlarge"
    ML_R6ID_LARGE = "ml.r6id.large"
    ML_R6ID_XLARGE = "ml.r6id.xlarge"
    ML_R6ID_2XLARGE = "ml.r6id.2xlarge"
    ML_R6ID_4XLARGE = "ml.r6id.4xlarge"
    ML_R6ID_8XLARGE = "ml.r6id.8xlarge"
    ML_R6ID_12XLARGE = "ml.r6id.12xlarge"
    ML_R6ID_16XLARGE = "ml.r6id.16xlarge"
    ML_R6ID_24XLARGE = "ml.r6id.24xlarge"
    ML_R6ID_32XLARGE = "ml.r6id.32xlarge"


class AppNetworkAccessType:
    """AppNetworkAccessType enum values."""

    PUBLICINTERNETONLY = "PublicInternetOnly"
    VPCONLY = "VpcOnly"


class AppSecurityGroupManagement:
    """AppSecurityGroupManagement enum values."""

    SERVICE = "Service"
    CUSTOMER = "Customer"


class AppSortKey:
    """AppSortKey enum values."""

    CREATIONTIME = "CreationTime"


class AppStatus:
    """AppStatus enum values."""

    DELETED = "Deleted"
    DELETING = "Deleting"
    FAILED = "Failed"
    INSERVICE = "InService"
    PENDING = "Pending"


class AppType:
    """AppType enum values."""

    JUPYTERSERVER = "JupyterServer"
    KERNELGATEWAY = "KernelGateway"
    DETAILEDPROFILER = "DetailedProfiler"
    TENSORBOARD = "TensorBoard"
    CODEEDITOR = "CodeEditor"
    JUPYTERLAB = "JupyterLab"
    RSTUDIOSERVERPRO = "RStudioServerPro"
    RSESSIONGATEWAY = "RSessionGateway"
    CANVAS = "Canvas"


class ArtifactSourceIdType:
    """ArtifactSourceIdType enum values."""

    MD5HASH = "MD5Hash"
    S3ETAG = "S3ETag"
    S3VERSION = "S3Version"
    CUSTOM = "Custom"


class AssemblyType:
    """AssemblyType enum values."""

    NONE = "None"
    LINE = "Line"


class AssociationEdgeType:
    """AssociationEdgeType enum values."""

    CONTRIBUTEDTO = "ContributedTo"
    ASSOCIATEDWITH = "AssociatedWith"
    DERIVEDFROM = "DerivedFrom"
    PRODUCED = "Produced"
    SAMEAS = "SameAs"


class AsyncNotificationTopicTypes:
    """AsyncNotificationTopicTypes enum values."""

    SUCCESS_NOTIFICATION_TOPIC = "SUCCESS_NOTIFICATION_TOPIC"
    ERROR_NOTIFICATION_TOPIC = "ERROR_NOTIFICATION_TOPIC"


class AthenaResultCompressionType:
    """AthenaResultCompressionType enum values."""

    GZIP = "GZIP"
    SNAPPY = "SNAPPY"
    ZLIB = "ZLIB"


class AthenaResultFormat:
    """AthenaResultFormat enum values."""

    PARQUET = "PARQUET"
    ORC = "ORC"
    AVRO = "AVRO"
    JSON = "JSON"
    TEXTFILE = "TEXTFILE"


class AuthMode:
    """AuthMode enum values."""

    SSO = "SSO"
    IAM = "IAM"


class AutoMLAlgorithm:
    """AutoMLAlgorithm enum values."""

    XGBOOST = "xgboost"
    LINEAR_LEARNER = "linear-learner"
    MLP = "mlp"
    LIGHTGBM = "lightgbm"
    CATBOOST = "catboost"
    RANDOMFOREST = "randomforest"
    EXTRA_TREES = "extra-trees"
    NN_TORCH = "nn-torch"
    FASTAI = "fastai"
    CNN_QR = "cnn-qr"
    DEEPAR = "deepar"
    PROPHET = "prophet"
    NPTS = "npts"
    ARIMA = "arima"
    ETS = "ets"


class AutoMLChannelType:
    """AutoMLChannelType enum values."""

    TRAINING = "training"
    VALIDATION = "validation"


class AutoMLJobObjectiveType:
    """AutoMLJobObjectiveType enum values."""

    MAXIMIZE = "Maximize"
    MINIMIZE = "Minimize"


class AutoMLJobSecondaryStatus:
    """AutoMLJobSecondaryStatus enum values."""

    STARTING = "Starting"
    MAXCANDIDATESREACHED = "MaxCandidatesReached"
    FAILED = "Failed"
    STOPPED = "Stopped"
    MAXAUTOMLJOBRUNTIMEREACHED = "MaxAutoMLJobRuntimeReached"
    STOPPING = "Stopping"
    CANDIDATEDEFINITIONSGENERATED = "CandidateDefinitionsGenerated"
    COMPLETED = "Completed"
    EXPLAINABILITYERROR = "ExplainabilityError"
    DEPLOYINGMODEL = "DeployingModel"
    MODELDEPLOYMENTERROR = "ModelDeploymentError"
    GENERATINGMODELINSIGHTSREPORT = "GeneratingModelInsightsReport"
    MODELINSIGHTSERROR = "ModelInsightsError"
    ANALYZINGDATA = "AnalyzingData"
    FEATUREENGINEERING = "FeatureEngineering"
    MODELTUNING = "ModelTuning"
    GENERATINGEXPLAINABILITYREPORT = "GeneratingExplainabilityReport"
    TRAININGMODELS = "TrainingModels"
    PRETRAINING = "PreTraining"


class AutoMLJobStatus:
    """AutoMLJobStatus enum values."""

    COMPLETED = "Completed"
    INPROGRESS = "InProgress"
    FAILED = "Failed"
    STOPPED = "Stopped"
    STOPPING = "Stopping"


class AutoMLMetricEnum:
    """AutoMLMetricEnum enum values."""

    ACCURACY = "Accuracy"
    MSE = "MSE"
    F1 = "F1"
    F1MACRO = "F1macro"
    AUC = "AUC"
    RMSE = "RMSE"
    BALANCEDACCURACY = "BalancedAccuracy"
    R2 = "R2"
    RECALL = "Recall"
    RECALLMACRO = "RecallMacro"
    PRECISION = "Precision"
    PRECISIONMACRO = "PrecisionMacro"
    MAE = "MAE"
    MAPE = "MAPE"
    MASE = "MASE"
    WAPE = "WAPE"
    AVERAGEWEIGHTEDQUANTILELOSS = "AverageWeightedQuantileLoss"


class AutoMLMetricExtendedEnum:
    """AutoMLMetricExtendedEnum enum values."""

    ACCURACY = "Accuracy"
    MSE = "MSE"
    F1 = "F1"
    F1MACRO = "F1macro"
    AUC = "AUC"
    RMSE = "RMSE"
    MAE = "MAE"
    R2 = "R2"
    BALANCEDACCURACY = "BalancedAccuracy"
    PRECISION = "Precision"
    PRECISIONMACRO = "PrecisionMacro"
    RECALL = "Recall"
    RECALLMACRO = "RecallMacro"
    LOGLOSS = "LogLoss"
    INFERENCELATENCY = "InferenceLatency"
    MAPE = "MAPE"
    MASE = "MASE"
    WAPE = "WAPE"
    AVERAGEWEIGHTEDQUANTILELOSS = "AverageWeightedQuantileLoss"
    ROUGE1 = "Rouge1"
    ROUGE2 = "Rouge2"
    ROUGEL = "RougeL"
    ROUGELSUM = "RougeLSum"
    PERPLEXITY = "Perplexity"
    VALIDATIONLOSS = "ValidationLoss"
    TRAININGLOSS = "TrainingLoss"


class AutoMLMode:
    """AutoMLMode enum values."""

    AUTO = "AUTO"
    ENSEMBLING = "ENSEMBLING"
    HYPERPARAMETER_TUNING = "HYPERPARAMETER_TUNING"


class AutoMLProblemTypeConfigName:
    """AutoMLProblemTypeConfigName enum values."""

    IMAGECLASSIFICATION = "ImageClassification"
    TEXTCLASSIFICATION = "TextClassification"
    TIMESERIESFORECASTING = "TimeSeriesForecasting"
    TABULAR = "Tabular"
    TEXTGENERATION = "TextGeneration"


class AutoMLProcessingUnit:
    """AutoMLProcessingUnit enum values."""

    CPU = "CPU"
    GPU = "GPU"


class AutoMLS3DataType:
    """AutoMLS3DataType enum values."""

    MANIFESTFILE = "ManifestFile"
    S3PREFIX = "S3Prefix"
    AUGMENTEDMANIFESTFILE = "AugmentedManifestFile"


class AutoMLSortBy:
    """AutoMLSortBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    STATUS = "Status"


class AutoMLSortOrder:
    """AutoMLSortOrder enum values."""

    ASCENDING = "Ascending"
    DESCENDING = "Descending"


class AutoMountHomeEFS:
    """AutoMountHomeEFS enum values."""

    ENABLED = "Enabled"
    DISABLED = "Disabled"
    DEFAULTASDOMAIN = "DefaultAsDomain"


class AutotuneMode:
    """AutotuneMode enum values."""

    ENABLED = "Enabled"


class AwsManagedHumanLoopRequestSource:
    """AwsManagedHumanLoopRequestSource enum values."""

    AWS_REKOGNITION_DETECTMODERATIONLABELS_IMAGE_V3 = "AWS/Rekognition/DetectModerationLabels/Image/V3"
    AWS_TEXTRACT_ANALYZEDOCUMENT_FORMS_V1 = "AWS/Textract/AnalyzeDocument/Forms/V1"


class BatchAddClusterNodesErrorCode:
    """BatchAddClusterNodesErrorCode enum values."""

    INSTANCEGROUPNOTFOUND = "InstanceGroupNotFound"
    INVALIDINSTANCEGROUPSTATUS = "InvalidInstanceGroupStatus"


class BatchDeleteClusterNodesErrorCode:
    """BatchDeleteClusterNodesErrorCode enum values."""

    NODEIDNOTFOUND = "NodeIdNotFound"
    INVALIDNODESTATUS = "InvalidNodeStatus"
    NODEIDINUSE = "NodeIdInUse"


class BatchRebootClusterNodesErrorCode:
    """BatchRebootClusterNodesErrorCode enum values."""

    INSTANCEIDNOTFOUND = "InstanceIdNotFound"
    INVALIDINSTANCESTATUS = "InvalidInstanceStatus"
    INSTANCEIDINUSE = "InstanceIdInUse"
    INTERNALSERVERERROR = "InternalServerError"


class BatchReplaceClusterNodesErrorCode:
    """BatchReplaceClusterNodesErrorCode enum values."""

    INSTANCEIDNOTFOUND = "InstanceIdNotFound"
    INVALIDINSTANCESTATUS = "InvalidInstanceStatus"
    INSTANCEIDINUSE = "InstanceIdInUse"
    INTERNALSERVERERROR = "InternalServerError"


class BatchStrategy:
    """BatchStrategy enum values."""

    MULTIRECORD = "MultiRecord"
    SINGLERECORD = "SingleRecord"


class BooleanOperator:
    """BooleanOperator enum values."""

    AND = "And"
    OR = "Or"


class CandidateSortBy:
    """CandidateSortBy enum values."""

    CREATIONTIME = "CreationTime"
    STATUS = "Status"
    FINALOBJECTIVEMETRICVALUE = "FinalObjectiveMetricValue"


class CandidateStatus:
    """CandidateStatus enum values."""

    COMPLETED = "Completed"
    INPROGRESS = "InProgress"
    FAILED = "Failed"
    STOPPED = "Stopped"
    STOPPING = "Stopping"


class CandidateStepType:
    """CandidateStepType enum values."""

    AWS_SAGEMAKER_TRAININGJOB = "AWS::SageMaker::TrainingJob"
    AWS_SAGEMAKER_TRANSFORMJOB = "AWS::SageMaker::TransformJob"
    AWS_SAGEMAKER_PROCESSINGJOB = "AWS::SageMaker::ProcessingJob"


class CapacityReservationPreference:
    """CapacityReservationPreference enum values."""

    CAPACITY_RESERVATIONS_ONLY = "capacity-reservations-only"


class CapacityReservationType:
    """CapacityReservationType enum values."""

    ODCR = "ODCR"
    CRG = "CRG"


class CapacitySizeType:
    """CapacitySizeType enum values."""

    INSTANCE_COUNT = "INSTANCE_COUNT"
    CAPACITY_PERCENT = "CAPACITY_PERCENT"


class CaptureMode:
    """CaptureMode enum values."""

    INPUT = "Input"
    OUTPUT = "Output"
    INPUTANDOUTPUT = "InputAndOutput"


class CaptureStatus:
    """CaptureStatus enum values."""

    STARTED = "Started"
    STOPPED = "Stopped"


class ClarifyFeatureType:
    """ClarifyFeatureType enum values."""

    NUMERICAL = "numerical"
    CATEGORICAL = "categorical"
    TEXT = "text"


class ClarifyTextGranularity:
    """ClarifyTextGranularity enum values."""

    TOKEN = "token"
    SENTENCE = "sentence"
    PARAGRAPH = "paragraph"


class ClarifyTextLanguage:
    """ClarifyTextLanguage enum values."""

    AF = "af"
    SQ = "sq"
    AR = "ar"
    HY = "hy"
    EU = "eu"
    BN = "bn"
    BG = "bg"
    CA = "ca"
    ZH = "zh"
    HR = "hr"
    CS = "cs"
    DA = "da"
    NL = "nl"
    EN = "en"
    ET = "et"
    FI = "fi"
    FR = "fr"
    DE = "de"
    EL = "el"
    GU = "gu"
    HE = "he"
    HI = "hi"
    HU = "hu"
    IS = "is"
    ID = "id"
    GA = "ga"
    IT = "it"
    KN = "kn"
    KY = "ky"
    LV = "lv"
    LT = "lt"
    LB = "lb"
    MK = "mk"
    ML = "ml"
    MR = "mr"
    NE = "ne"
    NB = "nb"
    FA = "fa"
    PL = "pl"
    PT = "pt"
    RO = "ro"
    RU = "ru"
    SA = "sa"
    SR = "sr"
    TN = "tn"
    SI = "si"
    SK = "sk"
    SL = "sl"
    ES = "es"
    SV = "sv"
    TL = "tl"
    TA = "ta"
    TT = "tt"
    TE = "te"
    TR = "tr"
    UK = "uk"
    UR = "ur"
    YO = "yo"
    LIJ = "lij"
    XX = "xx"


class ClusterAutoScalerType:
    """ClusterAutoScalerType enum values."""

    KARPENTER = "Karpenter"


class ClusterAutoScalingMode:
    """ClusterAutoScalingMode enum values."""

    ENABLE = "Enable"
    DISABLE = "Disable"


class ClusterAutoScalingStatus:
    """ClusterAutoScalingStatus enum values."""

    INSERVICE = "InService"
    FAILED = "Failed"
    CREATING = "Creating"
    DELETING = "Deleting"


class ClusterCapacityType:
    """ClusterCapacityType enum values."""

    SPOT = "Spot"
    ONDEMAND = "OnDemand"


class ClusterConfigMode:
    """ClusterConfigMode enum values."""

    ENABLE = "Enable"
    DISABLE = "Disable"


class ClusterEventResourceType:
    """ClusterEventResourceType enum values."""

    CLUSTER = "Cluster"
    INSTANCEGROUP = "InstanceGroup"
    INSTANCE = "Instance"


class ClusterInstanceStatus:
    """ClusterInstanceStatus enum values."""

    RUNNING = "Running"
    FAILURE = "Failure"
    PENDING = "Pending"
    SHUTTINGDOWN = "ShuttingDown"
    SYSTEMUPDATING = "SystemUpdating"
    DEEPHEALTHCHECKINPROGRESS = "DeepHealthCheckInProgress"
    NOTFOUND = "NotFound"


class ClusterInstanceType:
    """ClusterInstanceType enum values."""

    ML_P4D_24XLARGE = "ml.p4d.24xlarge"
    ML_P4DE_24XLARGE = "ml.p4de.24xlarge"
    ML_P5_48XLARGE = "ml.p5.48xlarge"
    ML_P5_4XLARGE = "ml.p5.4xlarge"
    ML_P6E_GB200_36XLARGE = "ml.p6e-gb200.36xlarge"
    ML_TRN1_32XLARGE = "ml.trn1.32xlarge"
    ML_TRN1N_32XLARGE = "ml.trn1n.32xlarge"
    ML_G5_XLARGE = "ml.g5.xlarge"
    ML_G5_2XLARGE = "ml.g5.2xlarge"
    ML_G5_4XLARGE = "ml.g5.4xlarge"
    ML_G5_8XLARGE = "ml.g5.8xlarge"
    ML_G5_12XLARGE = "ml.g5.12xlarge"
    ML_G5_16XLARGE = "ml.g5.16xlarge"
    ML_G5_24XLARGE = "ml.g5.24xlarge"
    ML_G5_48XLARGE = "ml.g5.48xlarge"
    ML_C5_LARGE = "ml.c5.large"
    ML_C5_XLARGE = "ml.c5.xlarge"
    ML_C5_2XLARGE = "ml.c5.2xlarge"
    ML_C5_4XLARGE = "ml.c5.4xlarge"
    ML_C5_9XLARGE = "ml.c5.9xlarge"
    ML_C5_12XLARGE = "ml.c5.12xlarge"
    ML_C5_18XLARGE = "ml.c5.18xlarge"
    ML_C5_24XLARGE = "ml.c5.24xlarge"
    ML_C5N_LARGE = "ml.c5n.large"
    ML_C5N_2XLARGE = "ml.c5n.2xlarge"
    ML_C5N_4XLARGE = "ml.c5n.4xlarge"
    ML_C5N_9XLARGE = "ml.c5n.9xlarge"
    ML_C5N_18XLARGE = "ml.c5n.18xlarge"
    ML_M5_LARGE = "ml.m5.large"
    ML_M5_XLARGE = "ml.m5.xlarge"
    ML_M5_2XLARGE = "ml.m5.2xlarge"
    ML_M5_4XLARGE = "ml.m5.4xlarge"
    ML_M5_8XLARGE = "ml.m5.8xlarge"
    ML_M5_12XLARGE = "ml.m5.12xlarge"
    ML_M5_16XLARGE = "ml.m5.16xlarge"
    ML_M5_24XLARGE = "ml.m5.24xlarge"
    ML_T3_MEDIUM = "ml.t3.medium"
    ML_T3_LARGE = "ml.t3.large"
    ML_T3_XLARGE = "ml.t3.xlarge"
    ML_T3_2XLARGE = "ml.t3.2xlarge"
    ML_G6_XLARGE = "ml.g6.xlarge"
    ML_G6_2XLARGE = "ml.g6.2xlarge"
    ML_G6_4XLARGE = "ml.g6.4xlarge"
    ML_G6_8XLARGE = "ml.g6.8xlarge"
    ML_G6_16XLARGE = "ml.g6.16xlarge"
    ML_G6_12XLARGE = "ml.g6.12xlarge"
    ML_G6_24XLARGE = "ml.g6.24xlarge"
    ML_G6_48XLARGE = "ml.g6.48xlarge"
    ML_GR6_4XLARGE = "ml.gr6.4xlarge"
    ML_GR6_8XLARGE = "ml.gr6.8xlarge"
    ML_G6E_XLARGE = "ml.g6e.xlarge"
    ML_G6E_2XLARGE = "ml.g6e.2xlarge"
    ML_G6E_4XLARGE = "ml.g6e.4xlarge"
    ML_G6E_8XLARGE = "ml.g6e.8xlarge"
    ML_G6E_16XLARGE = "ml.g6e.16xlarge"
    ML_G6E_12XLARGE = "ml.g6e.12xlarge"
    ML_G6E_24XLARGE = "ml.g6e.24xlarge"
    ML_G6E_48XLARGE = "ml.g6e.48xlarge"
    ML_P5E_48XLARGE = "ml.p5e.48xlarge"
    ML_P5EN_48XLARGE = "ml.p5en.48xlarge"
    ML_P6_B200_48XLARGE = "ml.p6-b200.48xlarge"
    ML_TRN2_3XLARGE = "ml.trn2.3xlarge"
    ML_TRN2_48XLARGE = "ml.trn2.48xlarge"
    ML_C6I_LARGE = "ml.c6i.large"
    ML_C6I_XLARGE = "ml.c6i.xlarge"
    ML_C6I_2XLARGE = "ml.c6i.2xlarge"
    ML_C6I_4XLARGE = "ml.c6i.4xlarge"
    ML_C6I_8XLARGE = "ml.c6i.8xlarge"
    ML_C6I_12XLARGE = "ml.c6i.12xlarge"
    ML_C6I_16XLARGE = "ml.c6i.16xlarge"
    ML_C6I_24XLARGE = "ml.c6i.24xlarge"
    ML_C6I_32XLARGE = "ml.c6i.32xlarge"
    ML_M6I_LARGE = "ml.m6i.large"
    ML_M6I_XLARGE = "ml.m6i.xlarge"
    ML_M6I_2XLARGE = "ml.m6i.2xlarge"
    ML_M6I_4XLARGE = "ml.m6i.4xlarge"
    ML_M6I_8XLARGE = "ml.m6i.8xlarge"
    ML_M6I_12XLARGE = "ml.m6i.12xlarge"
    ML_M6I_16XLARGE = "ml.m6i.16xlarge"
    ML_M6I_24XLARGE = "ml.m6i.24xlarge"
    ML_M6I_32XLARGE = "ml.m6i.32xlarge"
    ML_R6I_LARGE = "ml.r6i.large"
    ML_R6I_XLARGE = "ml.r6i.xlarge"
    ML_R6I_2XLARGE = "ml.r6i.2xlarge"
    ML_R6I_4XLARGE = "ml.r6i.4xlarge"
    ML_R6I_8XLARGE = "ml.r6i.8xlarge"
    ML_R6I_12XLARGE = "ml.r6i.12xlarge"
    ML_R6I_16XLARGE = "ml.r6i.16xlarge"
    ML_R6I_24XLARGE = "ml.r6i.24xlarge"
    ML_R6I_32XLARGE = "ml.r6i.32xlarge"
    ML_I3EN_LARGE = "ml.i3en.large"
    ML_I3EN_XLARGE = "ml.i3en.xlarge"
    ML_I3EN_2XLARGE = "ml.i3en.2xlarge"
    ML_I3EN_3XLARGE = "ml.i3en.3xlarge"
    ML_I3EN_6XLARGE = "ml.i3en.6xlarge"
    ML_I3EN_12XLARGE = "ml.i3en.12xlarge"
    ML_I3EN_24XLARGE = "ml.i3en.24xlarge"
    ML_M7I_LARGE = "ml.m7i.large"
    ML_M7I_XLARGE = "ml.m7i.xlarge"
    ML_M7I_2XLARGE = "ml.m7i.2xlarge"
    ML_M7I_4XLARGE = "ml.m7i.4xlarge"
    ML_M7I_8XLARGE = "ml.m7i.8xlarge"
    ML_M7I_12XLARGE = "ml.m7i.12xlarge"
    ML_M7I_16XLARGE = "ml.m7i.16xlarge"
    ML_M7I_24XLARGE = "ml.m7i.24xlarge"
    ML_M7I_48XLARGE = "ml.m7i.48xlarge"
    ML_R7I_LARGE = "ml.r7i.large"
    ML_R7I_XLARGE = "ml.r7i.xlarge"
    ML_R7I_2XLARGE = "ml.r7i.2xlarge"
    ML_R7I_4XLARGE = "ml.r7i.4xlarge"
    ML_R7I_8XLARGE = "ml.r7i.8xlarge"
    ML_R7I_12XLARGE = "ml.r7i.12xlarge"
    ML_R7I_16XLARGE = "ml.r7i.16xlarge"
    ML_R7I_24XLARGE = "ml.r7i.24xlarge"
    ML_R7I_48XLARGE = "ml.r7i.48xlarge"
    ML_P6_B300_48XLARGE = "ml.p6-b300.48xlarge"


class ClusterKubernetesTaintEffect:
    """ClusterKubernetesTaintEffect enum values."""

    NOSCHEDULE = "NoSchedule"
    PREFERNOSCHEDULE = "PreferNoSchedule"
    NOEXECUTE = "NoExecute"


class ClusterNodeProvisioningMode:
    """ClusterNodeProvisioningMode enum values."""

    CONTINUOUS = "Continuous"


class ClusterNodeRecovery:
    """ClusterNodeRecovery enum values."""

    AUTOMATIC = "Automatic"
    NONE = "None"


class ClusterSortBy:
    """ClusterSortBy enum values."""

    CREATION_TIME = "CREATION_TIME"
    NAME = "NAME"


class ClusterStatus:
    """ClusterStatus enum values."""

    CREATING = "Creating"
    DELETING = "Deleting"
    FAILED = "Failed"
    INSERVICE = "InService"
    ROLLINGBACK = "RollingBack"
    SYSTEMUPDATING = "SystemUpdating"
    UPDATING = "Updating"


class CodeRepositorySortBy:
    """CodeRepositorySortBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    LASTMODIFIEDTIME = "LastModifiedTime"


class CodeRepositorySortOrder:
    """CodeRepositorySortOrder enum values."""

    ASCENDING = "Ascending"
    DESCENDING = "Descending"


class CollectionType:
    """CollectionType enum values."""

    LIST = "List"
    SET = "Set"
    VECTOR = "Vector"


class CompilationJobStatus:
    """CompilationJobStatus enum values."""

    INPROGRESS = "INPROGRESS"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    STARTING = "STARTING"
    STOPPING = "STOPPING"
    STOPPED = "STOPPED"


class CompleteOnConvergence:
    """CompleteOnConvergence enum values."""

    DISABLED = "Disabled"
    ENABLED = "Enabled"


class CompressionType:
    """CompressionType enum values."""

    NONE = "None"
    GZIP = "Gzip"


class ConditionOutcome:
    """ConditionOutcome enum values."""

    TRUE = "True"
    FALSE = "False"


class ContainerMode:
    """ContainerMode enum values."""

    SINGLEMODEL = "SingleModel"
    MULTIMODEL = "MultiModel"


class ContentClassifier:
    """ContentClassifier enum values."""

    FREEOFPERSONALLYIDENTIFIABLEINFORMATION = "FreeOfPersonallyIdentifiableInformation"
    FREEOFADULTCONTENT = "FreeOfAdultContent"


class CrossAccountFilterOption:
    """CrossAccountFilterOption enum values."""

    SAMEACCOUNT = "SameAccount"
    CROSSACCOUNT = "CrossAccount"


class CustomizationTechnique:
    """CustomizationTechnique enum values."""

    SFT = "SFT"
    DPO = "DPO"
    RLVR = "RLVR"
    RLAIF = "RLAIF"


class DataDistributionType:
    """DataDistributionType enum values."""

    FULLYREPLICATED = "FullyReplicated"
    SHARDEDBYS3KEY = "ShardedByS3Key"


class DataSourceName:
    """DataSourceName enum values."""

    SALESFORCEGENIE = "SalesforceGenie"
    SNOWFLAKE = "Snowflake"


class DeepHealthCheckType:
    """DeepHealthCheckType enum values."""

    INSTANCESTRESS = "InstanceStress"
    INSTANCECONNECTIVITY = "InstanceConnectivity"


class DetailedAlgorithmStatus:
    """DetailedAlgorithmStatus enum values."""

    NOTSTARTED = "NotStarted"
    INPROGRESS = "InProgress"
    COMPLETED = "Completed"
    FAILED = "Failed"


class DetailedModelPackageStatus:
    """DetailedModelPackageStatus enum values."""

    NOTSTARTED = "NotStarted"
    INPROGRESS = "InProgress"
    COMPLETED = "Completed"
    FAILED = "Failed"


class DeviceDeploymentStatus:
    """DeviceDeploymentStatus enum values."""

    READYTODEPLOY = "READYTODEPLOY"
    INPROGRESS = "INPROGRESS"
    DEPLOYED = "DEPLOYED"
    FAILED = "FAILED"
    STOPPING = "STOPPING"
    STOPPED = "STOPPED"


class DeviceSubsetType:
    """DeviceSubsetType enum values."""

    PERCENTAGE = "PERCENTAGE"
    SELECTION = "SELECTION"
    NAMECONTAINS = "NAMECONTAINS"


class DirectInternetAccess:
    """DirectInternetAccess enum values."""

    ENABLED = "Enabled"
    DISABLED = "Disabled"


class Direction:
    """Direction enum values."""

    BOTH = "Both"
    ASCENDANTS = "Ascendants"
    DESCENDANTS = "Descendants"


class DomainStatus:
    """DomainStatus enum values."""

    DELETING = "Deleting"
    FAILED = "Failed"
    INSERVICE = "InService"
    PENDING = "Pending"
    UPDATING = "Updating"
    UPDATE_FAILED = "Update_Failed"
    DELETE_FAILED = "Delete_Failed"


class EdgePackagingJobStatus:
    """EdgePackagingJobStatus enum values."""

    STARTING = "STARTING"
    INPROGRESS = "INPROGRESS"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    STOPPING = "STOPPING"
    STOPPED = "STOPPED"


class EdgePresetDeploymentStatus:
    """EdgePresetDeploymentStatus enum values."""

    COMPLETED = "COMPLETED"
    FAILED = "FAILED"


class EdgePresetDeploymentType:
    """EdgePresetDeploymentType enum values."""

    GREENGRASSV2COMPONENT = "GreengrassV2Component"


class EnabledOrDisabled:
    """EnabledOrDisabled enum values."""

    ENABLED = "Enabled"
    DISABLED = "Disabled"


class EndpointConfigSortKey:
    """EndpointConfigSortKey enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"


class EndpointSortKey:
    """EndpointSortKey enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    STATUS = "Status"


class EndpointStatus:
    """EndpointStatus enum values."""

    OUTOFSERVICE = "OutOfService"
    CREATING = "Creating"
    UPDATING = "Updating"
    SYSTEMUPDATING = "SystemUpdating"
    ROLLINGBACK = "RollingBack"
    INSERVICE = "InService"
    DELETING = "Deleting"
    FAILED = "Failed"
    UPDATEROLLBACKFAILED = "UpdateRollbackFailed"


class EvaluationType:
    """EvaluationType enum values."""

    LLMAJEVALUATION = "LLMAJEvaluation"
    CUSTOMSCOREREVALUATION = "CustomScorerEvaluation"
    BENCHMARKEVALUATION = "BenchmarkEvaluation"


class EventSortBy:
    """EventSortBy enum values."""

    EVENTTIME = "EventTime"


class ExecutionRoleIdentityConfig:
    """ExecutionRoleIdentityConfig enum values."""

    USER_PROFILE_NAME = "USER_PROFILE_NAME"
    DISABLED = "DISABLED"


class ExecutionStatus:
    """ExecutionStatus enum values."""

    PENDING = "Pending"
    COMPLETED = "Completed"
    COMPLETEDWITHVIOLATIONS = "CompletedWithViolations"
    INPROGRESS = "InProgress"
    FAILED = "Failed"
    STOPPING = "Stopping"
    STOPPED = "Stopped"


class FailureHandlingPolicy:
    """FailureHandlingPolicy enum values."""

    ROLLBACK_ON_FAILURE = "ROLLBACK_ON_FAILURE"
    DO_NOTHING = "DO_NOTHING"


class FairShare:
    """FairShare enum values."""

    ENABLED = "Enabled"
    DISABLED = "Disabled"


class FeatureGroupSortBy:
    """FeatureGroupSortBy enum values."""

    NAME = "Name"
    FEATUREGROUPSTATUS = "FeatureGroupStatus"
    OFFLINESTORESTATUS = "OfflineStoreStatus"
    CREATIONTIME = "CreationTime"


class FeatureGroupSortOrder:
    """FeatureGroupSortOrder enum values."""

    ASCENDING = "Ascending"
    DESCENDING = "Descending"


class FeatureGroupStatus:
    """FeatureGroupStatus enum values."""

    CREATING = "Creating"
    CREATED = "Created"
    CREATEFAILED = "CreateFailed"
    DELETING = "Deleting"
    DELETEFAILED = "DeleteFailed"


class FeatureStatus:
    """FeatureStatus enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class FeatureType:
    """FeatureType enum values."""

    INTEGRAL = "Integral"
    FRACTIONAL = "Fractional"
    STRING = "String"


class FileSystemAccessMode:
    """FileSystemAccessMode enum values."""

    RW = "rw"
    RO = "ro"


class FileSystemType:
    """FileSystemType enum values."""

    EFS = "EFS"
    FSXLUSTRE = "FSxLustre"


class FillingType:
    """FillingType enum values."""

    FRONTFILL = "frontfill"
    MIDDLEFILL = "middlefill"
    BACKFILL = "backfill"
    FUTUREFILL = "futurefill"
    FRONTFILL_VALUE = "frontfill_value"
    MIDDLEFILL_VALUE = "middlefill_value"
    BACKFILL_VALUE = "backfill_value"
    FUTUREFILL_VALUE = "futurefill_value"


class FlatInvocations:
    """FlatInvocations enum values."""

    CONTINUE = "Continue"
    STOP = "Stop"


class FlowDefinitionStatus:
    """FlowDefinitionStatus enum values."""

    INITIALIZING = "Initializing"
    ACTIVE = "Active"
    FAILED = "Failed"
    DELETING = "Deleting"


class Framework:
    """Framework enum values."""

    TENSORFLOW = "TENSORFLOW"
    KERAS = "KERAS"
    MXNET = "MXNET"
    ONNX = "ONNX"
    PYTORCH = "PYTORCH"
    XGBOOST = "XGBOOST"
    TFLITE = "TFLITE"
    DARKNET = "DARKNET"
    SKLEARN = "SKLEARN"


class HubContentSortBy:
    """HubContentSortBy enum values."""

    HUBCONTENTNAME = "HubContentName"
    CREATIONTIME = "CreationTime"
    HUBCONTENTSTATUS = "HubContentStatus"


class HubContentStatus:
    """HubContentStatus enum values."""

    AVAILABLE = "Available"
    IMPORTING = "Importing"
    DELETING = "Deleting"
    IMPORTFAILED = "ImportFailed"
    DELETEFAILED = "DeleteFailed"
    PENDINGIMPORT = "PendingImport"
    PENDINGDELETE = "PendingDelete"


class HubContentSupportStatus:
    """HubContentSupportStatus enum values."""

    SUPPORTED = "Supported"
    DEPRECATED = "Deprecated"
    RESTRICTED = "Restricted"


class HubContentType:
    """HubContentType enum values."""

    MODEL = "Model"
    NOTEBOOK = "Notebook"
    MODELREFERENCE = "ModelReference"
    DATASET = "DataSet"
    JSONDOC = "JsonDoc"


class HubSortBy:
    """HubSortBy enum values."""

    HUBNAME = "HubName"
    CREATIONTIME = "CreationTime"
    HUBSTATUS = "HubStatus"
    ACCOUNTIDOWNER = "AccountIdOwner"


class HubStatus:
    """HubStatus enum values."""

    INSERVICE = "InService"
    CREATING = "Creating"
    UPDATING = "Updating"
    DELETING = "Deleting"
    CREATEFAILED = "CreateFailed"
    UPDATEFAILED = "UpdateFailed"
    DELETEFAILED = "DeleteFailed"


class HumanTaskUiStatus:
    """HumanTaskUiStatus enum values."""

    ACTIVE = "Active"
    DELETING = "Deleting"


class HyperParameterScalingType:
    """HyperParameterScalingType enum values."""

    AUTO = "Auto"
    LINEAR = "Linear"
    LOGARITHMIC = "Logarithmic"
    REVERSELOGARITHMIC = "ReverseLogarithmic"


class HyperParameterTuningAllocationStrategy:
    """HyperParameterTuningAllocationStrategy enum values."""

    PRIORITIZED = "Prioritized"


class HyperParameterTuningJobObjectiveType:
    """HyperParameterTuningJobObjectiveType enum values."""

    MAXIMIZE = "Maximize"
    MINIMIZE = "Minimize"


class HyperParameterTuningJobSortByOptions:
    """HyperParameterTuningJobSortByOptions enum values."""

    NAME = "Name"
    STATUS = "Status"
    CREATIONTIME = "CreationTime"


class HyperParameterTuningJobStatus:
    """HyperParameterTuningJobStatus enum values."""

    COMPLETED = "Completed"
    INPROGRESS = "InProgress"
    FAILED = "Failed"
    STOPPED = "Stopped"
    STOPPING = "Stopping"
    DELETING = "Deleting"
    DELETEFAILED = "DeleteFailed"


class HyperParameterTuningJobStrategyType:
    """HyperParameterTuningJobStrategyType enum values."""

    BAYESIAN = "Bayesian"
    RANDOM = "Random"
    HYPERBAND = "Hyperband"
    GRID = "Grid"


class HyperParameterTuningJobWarmStartType:
    """HyperParameterTuningJobWarmStartType enum values."""

    IDENTICALDATAANDALGORITHM = "IdenticalDataAndAlgorithm"
    TRANSFERLEARNING = "TransferLearning"


class IPAddressType:
    """IPAddressType enum values."""

    IPV4 = "ipv4"
    DUALSTACK = "dualstack"


class ImageSortBy:
    """ImageSortBy enum values."""

    CREATION_TIME = "CREATION_TIME"
    LAST_MODIFIED_TIME = "LAST_MODIFIED_TIME"
    IMAGE_NAME = "IMAGE_NAME"


class ImageSortOrder:
    """ImageSortOrder enum values."""

    ASCENDING = "ASCENDING"
    DESCENDING = "DESCENDING"


class ImageStatus:
    """ImageStatus enum values."""

    CREATING = "CREATING"
    CREATED = "CREATED"
    CREATE_FAILED = "CREATE_FAILED"
    UPDATING = "UPDATING"
    UPDATE_FAILED = "UPDATE_FAILED"
    DELETING = "DELETING"
    DELETE_FAILED = "DELETE_FAILED"


class ImageVersionSortBy:
    """ImageVersionSortBy enum values."""

    CREATION_TIME = "CREATION_TIME"
    LAST_MODIFIED_TIME = "LAST_MODIFIED_TIME"
    VERSION = "VERSION"


class ImageVersionSortOrder:
    """ImageVersionSortOrder enum values."""

    ASCENDING = "ASCENDING"
    DESCENDING = "DESCENDING"


class ImageVersionStatus:
    """ImageVersionStatus enum values."""

    CREATING = "CREATING"
    CREATED = "CREATED"
    CREATE_FAILED = "CREATE_FAILED"
    DELETING = "DELETING"
    DELETE_FAILED = "DELETE_FAILED"


class InferenceComponentCapacitySizeType:
    """InferenceComponentCapacitySizeType enum values."""

    COPY_COUNT = "COPY_COUNT"
    CAPACITY_PERCENT = "CAPACITY_PERCENT"


class InferenceComponentSortKey:
    """InferenceComponentSortKey enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    STATUS = "Status"


class InferenceComponentStatus:
    """InferenceComponentStatus enum values."""

    INSERVICE = "InService"
    CREATING = "Creating"
    UPDATING = "Updating"
    FAILED = "Failed"
    DELETING = "Deleting"


class InferenceExecutionMode:
    """InferenceExecutionMode enum values."""

    SERIAL = "Serial"
    DIRECT = "Direct"


class InferenceExperimentStatus:
    """InferenceExperimentStatus enum values."""

    CREATING = "Creating"
    CREATED = "Created"
    UPDATING = "Updating"
    RUNNING = "Running"
    STARTING = "Starting"
    STOPPING = "Stopping"
    COMPLETED = "Completed"
    CANCELLED = "Cancelled"


class InferenceExperimentStopDesiredState:
    """InferenceExperimentStopDesiredState enum values."""

    COMPLETED = "Completed"
    CANCELLED = "Cancelled"


class InferenceExperimentType:
    """InferenceExperimentType enum values."""

    SHADOWMODE = "ShadowMode"


class InputMode:
    """InputMode enum values."""

    PIPE = "Pipe"
    FILE = "File"


class InstanceGroupStatus:
    """InstanceGroupStatus enum values."""

    INSERVICE = "InService"
    CREATING = "Creating"
    UPDATING = "Updating"
    FAILED = "Failed"
    DEGRADED = "Degraded"
    SYSTEMUPDATING = "SystemUpdating"
    DELETING = "Deleting"


class InstanceType:
    """InstanceType enum values."""

    ML_T2_MEDIUM = "ml.t2.medium"
    ML_T2_LARGE = "ml.t2.large"
    ML_T2_XLARGE = "ml.t2.xlarge"
    ML_T2_2XLARGE = "ml.t2.2xlarge"
    ML_T3_MEDIUM = "ml.t3.medium"
    ML_T3_LARGE = "ml.t3.large"
    ML_T3_XLARGE = "ml.t3.xlarge"
    ML_T3_2XLARGE = "ml.t3.2xlarge"
    ML_M4_XLARGE = "ml.m4.xlarge"
    ML_M4_2XLARGE = "ml.m4.2xlarge"
    ML_M4_4XLARGE = "ml.m4.4xlarge"
    ML_M4_10XLARGE = "ml.m4.10xlarge"
    ML_M4_16XLARGE = "ml.m4.16xlarge"
    ML_M5_XLARGE = "ml.m5.xlarge"
    ML_M5_2XLARGE = "ml.m5.2xlarge"
    ML_M5_4XLARGE = "ml.m5.4xlarge"
    ML_M5_12XLARGE = "ml.m5.12xlarge"
    ML_M5_24XLARGE = "ml.m5.24xlarge"
    ML_M5D_LARGE = "ml.m5d.large"
    ML_M5D_XLARGE = "ml.m5d.xlarge"
    ML_M5D_2XLARGE = "ml.m5d.2xlarge"
    ML_M5D_4XLARGE = "ml.m5d.4xlarge"
    ML_M5D_8XLARGE = "ml.m5d.8xlarge"
    ML_M5D_12XLARGE = "ml.m5d.12xlarge"
    ML_M5D_16XLARGE = "ml.m5d.16xlarge"
    ML_M5D_24XLARGE = "ml.m5d.24xlarge"
    ML_C4_XLARGE = "ml.c4.xlarge"
    ML_C4_2XLARGE = "ml.c4.2xlarge"
    ML_C4_4XLARGE = "ml.c4.4xlarge"
    ML_C4_8XLARGE = "ml.c4.8xlarge"
    ML_C5_XLARGE = "ml.c5.xlarge"
    ML_C5_2XLARGE = "ml.c5.2xlarge"
    ML_C5_4XLARGE = "ml.c5.4xlarge"
    ML_C5_9XLARGE = "ml.c5.9xlarge"
    ML_C5_18XLARGE = "ml.c5.18xlarge"
    ML_C5D_XLARGE = "ml.c5d.xlarge"
    ML_C5D_2XLARGE = "ml.c5d.2xlarge"
    ML_C5D_4XLARGE = "ml.c5d.4xlarge"
    ML_C5D_9XLARGE = "ml.c5d.9xlarge"
    ML_C5D_18XLARGE = "ml.c5d.18xlarge"
    ML_P2_XLARGE = "ml.p2.xlarge"
    ML_P2_8XLARGE = "ml.p2.8xlarge"
    ML_P2_16XLARGE = "ml.p2.16xlarge"
    ML_P3_2XLARGE = "ml.p3.2xlarge"
    ML_P3_8XLARGE = "ml.p3.8xlarge"
    ML_P3_16XLARGE = "ml.p3.16xlarge"
    ML_P3DN_24XLARGE = "ml.p3dn.24xlarge"
    ML_G4DN_XLARGE = "ml.g4dn.xlarge"
    ML_G4DN_2XLARGE = "ml.g4dn.2xlarge"
    ML_G4DN_4XLARGE = "ml.g4dn.4xlarge"
    ML_G4DN_8XLARGE = "ml.g4dn.8xlarge"
    ML_G4DN_12XLARGE = "ml.g4dn.12xlarge"
    ML_G4DN_16XLARGE = "ml.g4dn.16xlarge"
    ML_R5_LARGE = "ml.r5.large"
    ML_R5_XLARGE = "ml.r5.xlarge"
    ML_R5_2XLARGE = "ml.r5.2xlarge"
    ML_R5_4XLARGE = "ml.r5.4xlarge"
    ML_R5_8XLARGE = "ml.r5.8xlarge"
    ML_R5_12XLARGE = "ml.r5.12xlarge"
    ML_R5_16XLARGE = "ml.r5.16xlarge"
    ML_R5_24XLARGE = "ml.r5.24xlarge"
    ML_G5_XLARGE = "ml.g5.xlarge"
    ML_G5_2XLARGE = "ml.g5.2xlarge"
    ML_G5_4XLARGE = "ml.g5.4xlarge"
    ML_G5_8XLARGE = "ml.g5.8xlarge"
    ML_G5_16XLARGE = "ml.g5.16xlarge"
    ML_G5_12XLARGE = "ml.g5.12xlarge"
    ML_G5_24XLARGE = "ml.g5.24xlarge"
    ML_G5_48XLARGE = "ml.g5.48xlarge"
    ML_INF1_XLARGE = "ml.inf1.xlarge"
    ML_INF1_2XLARGE = "ml.inf1.2xlarge"
    ML_INF1_6XLARGE = "ml.inf1.6xlarge"
    ML_INF1_24XLARGE = "ml.inf1.24xlarge"
    ML_TRN1_2XLARGE = "ml.trn1.2xlarge"
    ML_TRN1_32XLARGE = "ml.trn1.32xlarge"
    ML_TRN1N_32XLARGE = "ml.trn1n.32xlarge"
    ML_INF2_XLARGE = "ml.inf2.xlarge"
    ML_INF2_8XLARGE = "ml.inf2.8xlarge"
    ML_INF2_24XLARGE = "ml.inf2.24xlarge"
    ML_INF2_48XLARGE = "ml.inf2.48xlarge"
    ML_P4D_24XLARGE = "ml.p4d.24xlarge"
    ML_P4DE_24XLARGE = "ml.p4de.24xlarge"
    ML_P5_48XLARGE = "ml.p5.48xlarge"
    ML_P6_B200_48XLARGE = "ml.p6-b200.48xlarge"
    ML_M6I_LARGE = "ml.m6i.large"
    ML_M6I_XLARGE = "ml.m6i.xlarge"
    ML_M6I_2XLARGE = "ml.m6i.2xlarge"
    ML_M6I_4XLARGE = "ml.m6i.4xlarge"
    ML_M6I_8XLARGE = "ml.m6i.8xlarge"
    ML_M6I_12XLARGE = "ml.m6i.12xlarge"
    ML_M6I_16XLARGE = "ml.m6i.16xlarge"
    ML_M6I_24XLARGE = "ml.m6i.24xlarge"
    ML_M6I_32XLARGE = "ml.m6i.32xlarge"
    ML_M7I_LARGE = "ml.m7i.large"
    ML_M7I_XLARGE = "ml.m7i.xlarge"
    ML_M7I_2XLARGE = "ml.m7i.2xlarge"
    ML_M7I_4XLARGE = "ml.m7i.4xlarge"
    ML_M7I_8XLARGE = "ml.m7i.8xlarge"
    ML_M7I_12XLARGE = "ml.m7i.12xlarge"
    ML_M7I_16XLARGE = "ml.m7i.16xlarge"
    ML_M7I_24XLARGE = "ml.m7i.24xlarge"
    ML_M7I_48XLARGE = "ml.m7i.48xlarge"
    ML_C6I_LARGE = "ml.c6i.large"
    ML_C6I_XLARGE = "ml.c6i.xlarge"
    ML_C6I_2XLARGE = "ml.c6i.2xlarge"
    ML_C6I_4XLARGE = "ml.c6i.4xlarge"
    ML_C6I_8XLARGE = "ml.c6i.8xlarge"
    ML_C6I_12XLARGE = "ml.c6i.12xlarge"
    ML_C6I_16XLARGE = "ml.c6i.16xlarge"
    ML_C6I_24XLARGE = "ml.c6i.24xlarge"
    ML_C6I_32XLARGE = "ml.c6i.32xlarge"
    ML_C7I_LARGE = "ml.c7i.large"
    ML_C7I_XLARGE = "ml.c7i.xlarge"
    ML_C7I_2XLARGE = "ml.c7i.2xlarge"
    ML_C7I_4XLARGE = "ml.c7i.4xlarge"
    ML_C7I_8XLARGE = "ml.c7i.8xlarge"
    ML_C7I_12XLARGE = "ml.c7i.12xlarge"
    ML_C7I_16XLARGE = "ml.c7i.16xlarge"
    ML_C7I_24XLARGE = "ml.c7i.24xlarge"
    ML_C7I_48XLARGE = "ml.c7i.48xlarge"
    ML_R6I_LARGE = "ml.r6i.large"
    ML_R6I_XLARGE = "ml.r6i.xlarge"
    ML_R6I_2XLARGE = "ml.r6i.2xlarge"
    ML_R6I_4XLARGE = "ml.r6i.4xlarge"
    ML_R6I_8XLARGE = "ml.r6i.8xlarge"
    ML_R6I_12XLARGE = "ml.r6i.12xlarge"
    ML_R6I_16XLARGE = "ml.r6i.16xlarge"
    ML_R6I_24XLARGE = "ml.r6i.24xlarge"
    ML_R6I_32XLARGE = "ml.r6i.32xlarge"
    ML_R7I_LARGE = "ml.r7i.large"
    ML_R7I_XLARGE = "ml.r7i.xlarge"
    ML_R7I_2XLARGE = "ml.r7i.2xlarge"
    ML_R7I_4XLARGE = "ml.r7i.4xlarge"
    ML_R7I_8XLARGE = "ml.r7i.8xlarge"
    ML_R7I_12XLARGE = "ml.r7i.12xlarge"
    ML_R7I_16XLARGE = "ml.r7i.16xlarge"
    ML_R7I_24XLARGE = "ml.r7i.24xlarge"
    ML_R7I_48XLARGE = "ml.r7i.48xlarge"
    ML_M6ID_LARGE = "ml.m6id.large"
    ML_M6ID_XLARGE = "ml.m6id.xlarge"
    ML_M6ID_2XLARGE = "ml.m6id.2xlarge"
    ML_M6ID_4XLARGE = "ml.m6id.4xlarge"
    ML_M6ID_8XLARGE = "ml.m6id.8xlarge"
    ML_M6ID_12XLARGE = "ml.m6id.12xlarge"
    ML_M6ID_16XLARGE = "ml.m6id.16xlarge"
    ML_M6ID_24XLARGE = "ml.m6id.24xlarge"
    ML_M6ID_32XLARGE = "ml.m6id.32xlarge"
    ML_C6ID_LARGE = "ml.c6id.large"
    ML_C6ID_XLARGE = "ml.c6id.xlarge"
    ML_C6ID_2XLARGE = "ml.c6id.2xlarge"
    ML_C6ID_4XLARGE = "ml.c6id.4xlarge"
    ML_C6ID_8XLARGE = "ml.c6id.8xlarge"
    ML_C6ID_12XLARGE = "ml.c6id.12xlarge"
    ML_C6ID_16XLARGE = "ml.c6id.16xlarge"
    ML_C6ID_24XLARGE = "ml.c6id.24xlarge"
    ML_C6ID_32XLARGE = "ml.c6id.32xlarge"
    ML_R6ID_LARGE = "ml.r6id.large"
    ML_R6ID_XLARGE = "ml.r6id.xlarge"
    ML_R6ID_2XLARGE = "ml.r6id.2xlarge"
    ML_R6ID_4XLARGE = "ml.r6id.4xlarge"
    ML_R6ID_8XLARGE = "ml.r6id.8xlarge"
    ML_R6ID_12XLARGE = "ml.r6id.12xlarge"
    ML_R6ID_16XLARGE = "ml.r6id.16xlarge"
    ML_R6ID_24XLARGE = "ml.r6id.24xlarge"
    ML_R6ID_32XLARGE = "ml.r6id.32xlarge"
    ML_G6_XLARGE = "ml.g6.xlarge"
    ML_G6_2XLARGE = "ml.g6.2xlarge"
    ML_G6_4XLARGE = "ml.g6.4xlarge"
    ML_G6_8XLARGE = "ml.g6.8xlarge"
    ML_G6_12XLARGE = "ml.g6.12xlarge"
    ML_G6_16XLARGE = "ml.g6.16xlarge"
    ML_G6_24XLARGE = "ml.g6.24xlarge"
    ML_G6_48XLARGE = "ml.g6.48xlarge"


class IsTrackingServerActive:
    """IsTrackingServerActive enum values."""

    ACTIVE = "Active"
    INACTIVE = "Inactive"


class JobType:
    """JobType enum values."""

    TRAINING = "TRAINING"
    INFERENCE = "INFERENCE"
    NOTEBOOK_KERNEL = "NOTEBOOK_KERNEL"


class JoinSource:
    """JoinSource enum values."""

    INPUT = "Input"
    NONE = "None"


class LabelingJobStatus:
    """LabelingJobStatus enum values."""

    INITIALIZING = "Initializing"
    INPROGRESS = "InProgress"
    COMPLETED = "Completed"
    FAILED = "Failed"
    STOPPING = "Stopping"
    STOPPED = "Stopped"


class LastUpdateStatusValue:
    """LastUpdateStatusValue enum values."""

    SUCCESSFUL = "Successful"
    FAILED = "Failed"
    INPROGRESS = "InProgress"


class LifecycleManagement:
    """LifecycleManagement enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class LineageType:
    """LineageType enum values."""

    TRIALCOMPONENT = "TrialComponent"
    ARTIFACT = "Artifact"
    CONTEXT = "Context"
    ACTION = "Action"


class ListCompilationJobsSortBy:
    """ListCompilationJobsSortBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    STATUS = "Status"


class ListDeviceFleetsSortBy:
    """ListDeviceFleetsSortBy enum values."""

    NAME = "NAME"
    CREATION_TIME = "CREATION_TIME"
    LAST_MODIFIED_TIME = "LAST_MODIFIED_TIME"


class ListEdgeDeploymentPlansSortBy:
    """ListEdgeDeploymentPlansSortBy enum values."""

    NAME = "NAME"
    DEVICE_FLEET_NAME = "DEVICE_FLEET_NAME"
    CREATION_TIME = "CREATION_TIME"
    LAST_MODIFIED_TIME = "LAST_MODIFIED_TIME"


class ListEdgePackagingJobsSortBy:
    """ListEdgePackagingJobsSortBy enum values."""

    NAME = "NAME"
    MODEL_NAME = "MODEL_NAME"
    CREATION_TIME = "CREATION_TIME"
    LAST_MODIFIED_TIME = "LAST_MODIFIED_TIME"
    STATUS = "STATUS"


class ListInferenceRecommendationsJobsSortBy:
    """ListInferenceRecommendationsJobsSortBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    STATUS = "Status"


class ListLabelingJobsForWorkteamSortByOptions:
    """ListLabelingJobsForWorkteamSortByOptions enum values."""

    CREATIONTIME = "CreationTime"


class ListOptimizationJobsSortBy:
    """ListOptimizationJobsSortBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    STATUS = "Status"


class ListWorkforcesSortByOptions:
    """ListWorkforcesSortByOptions enum values."""

    NAME = "Name"
    CREATEDATE = "CreateDate"


class ListWorkteamsSortByOptions:
    """ListWorkteamsSortByOptions enum values."""

    NAME = "Name"
    CREATEDATE = "CreateDate"


class MIGProfileType:
    """MIGProfileType enum values."""

    MIG_1G_5GB = "mig-1g.5gb"
    MIG_1G_10GB = "mig-1g.10gb"
    MIG_1G_18GB = "mig-1g.18gb"
    MIG_1G_20GB = "mig-1g.20gb"
    MIG_1G_23GB = "mig-1g.23gb"
    MIG_1G_35GB = "mig-1g.35gb"
    MIG_1G_45GB = "mig-1g.45gb"
    MIG_1G_47GB = "mig-1g.47gb"
    MIG_2G_10GB = "mig-2g.10gb"
    MIG_2G_20GB = "mig-2g.20gb"
    MIG_2G_35GB = "mig-2g.35gb"
    MIG_2G_45GB = "mig-2g.45gb"
    MIG_2G_47GB = "mig-2g.47gb"
    MIG_3G_20GB = "mig-3g.20gb"
    MIG_3G_40GB = "mig-3g.40gb"
    MIG_3G_71GB = "mig-3g.71gb"
    MIG_3G_90GB = "mig-3g.90gb"
    MIG_3G_93GB = "mig-3g.93gb"
    MIG_4G_20GB = "mig-4g.20gb"
    MIG_4G_40GB = "mig-4g.40gb"
    MIG_4G_71GB = "mig-4g.71gb"
    MIG_4G_90GB = "mig-4g.90gb"
    MIG_4G_93GB = "mig-4g.93gb"
    MIG_7G_40GB = "mig-7g.40gb"
    MIG_7G_80GB = "mig-7g.80gb"
    MIG_7G_141GB = "mig-7g.141gb"
    MIG_7G_180GB = "mig-7g.180gb"
    MIG_7G_186GB = "mig-7g.186gb"


class MaintenanceStatus:
    """MaintenanceStatus enum values."""

    MAINTENANCEINPROGRESS = "MaintenanceInProgress"
    MAINTENANCECOMPLETE = "MaintenanceComplete"
    MAINTENANCEFAILED = "MaintenanceFailed"


class ManagedInstanceScalingStatus:
    """ManagedInstanceScalingStatus enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class MetricSetSource:
    """MetricSetSource enum values."""

    TRAIN = "Train"
    VALIDATION = "Validation"
    TEST = "Test"


class MlTools:
    """MlTools enum values."""

    DATAWRANGLER = "DataWrangler"
    FEATURESTORE = "FeatureStore"
    EMRCLUSTERS = "EmrClusters"
    AUTOML = "AutoMl"
    EXPERIMENTS = "Experiments"
    TRAINING = "Training"
    MODELEVALUATION = "ModelEvaluation"
    PIPELINES = "Pipelines"
    MODELS = "Models"
    JUMPSTART = "JumpStart"
    INFERENCERECOMMENDER = "InferenceRecommender"
    ENDPOINTS = "Endpoints"
    PROJECTS = "Projects"
    INFERENCEOPTIMIZATION = "InferenceOptimization"
    PERFORMANCEEVALUATION = "PerformanceEvaluation"
    LAKERAGUARD = "LakeraGuard"
    COMET = "Comet"
    DEEPCHECKSLLMEVALUATION = "DeepchecksLLMEvaluation"
    FIDDLER = "Fiddler"
    HYPERPODCLUSTERS = "HyperPodClusters"
    RUNNINGINSTANCES = "RunningInstances"
    DATASETS = "Datasets"
    EVALUATORS = "Evaluators"


class MlflowAppStatus:
    """MlflowAppStatus enum values."""

    CREATING = "Creating"
    CREATED = "Created"
    CREATEFAILED = "CreateFailed"
    UPDATING = "Updating"
    UPDATED = "Updated"
    UPDATEFAILED = "UpdateFailed"
    DELETING = "Deleting"
    DELETEFAILED = "DeleteFailed"
    DELETED = "Deleted"


class ModelApprovalStatus:
    """ModelApprovalStatus enum values."""

    APPROVED = "Approved"
    REJECTED = "Rejected"
    PENDINGMANUALAPPROVAL = "PendingManualApproval"


class ModelCacheSetting:
    """ModelCacheSetting enum values."""

    ENABLED = "Enabled"
    DISABLED = "Disabled"


class ModelCardExportJobSortBy:
    """ModelCardExportJobSortBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    STATUS = "Status"


class ModelCardExportJobSortOrder:
    """ModelCardExportJobSortOrder enum values."""

    ASCENDING = "Ascending"
    DESCENDING = "Descending"


class ModelCardExportJobStatus:
    """ModelCardExportJobStatus enum values."""

    INPROGRESS = "InProgress"
    COMPLETED = "Completed"
    FAILED = "Failed"


class ModelCardProcessingStatus:
    """ModelCardProcessingStatus enum values."""

    DELETEINPROGRESS = "DeleteInProgress"
    DELETEPENDING = "DeletePending"
    CONTENTDELETED = "ContentDeleted"
    EXPORTJOBSDELETED = "ExportJobsDeleted"
    DELETECOMPLETED = "DeleteCompleted"
    DELETEFAILED = "DeleteFailed"


class ModelCardSortBy:
    """ModelCardSortBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"


class ModelCardSortOrder:
    """ModelCardSortOrder enum values."""

    ASCENDING = "Ascending"
    DESCENDING = "Descending"


class ModelCardStatus:
    """ModelCardStatus enum values."""

    DRAFT = "Draft"
    PENDINGREVIEW = "PendingReview"
    APPROVED = "Approved"
    ARCHIVED = "Archived"


class ModelCardVersionSortBy:
    """ModelCardVersionSortBy enum values."""

    VERSION = "Version"


class ModelCompressionType:
    """ModelCompressionType enum values."""

    NONE = "None"
    GZIP = "Gzip"


class ModelInfrastructureType:
    """ModelInfrastructureType enum values."""

    REALTIMEINFERENCE = "RealTimeInference"


class ModelMetadataFilterType:
    """ModelMetadataFilterType enum values."""

    DOMAIN = "Domain"
    FRAMEWORK = "Framework"
    TASK = "Task"
    FRAMEWORKVERSION = "FrameworkVersion"


class ModelPackageGroupSortBy:
    """ModelPackageGroupSortBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"


class ModelPackageGroupStatus:
    """ModelPackageGroupStatus enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    COMPLETED = "Completed"
    FAILED = "Failed"
    DELETING = "Deleting"
    DELETEFAILED = "DeleteFailed"


class ModelPackageRegistrationType:
    """ModelPackageRegistrationType enum values."""

    LOGGED = "Logged"
    REGISTERED = "Registered"


class ModelPackageSortBy:
    """ModelPackageSortBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"


class ModelPackageStatus:
    """ModelPackageStatus enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    COMPLETED = "Completed"
    FAILED = "Failed"
    DELETING = "Deleting"


class ModelPackageType:
    """ModelPackageType enum values."""

    VERSIONED = "Versioned"
    UNVERSIONED = "Unversioned"
    BOTH = "Both"


class ModelRegistrationMode:
    """ModelRegistrationMode enum values."""

    AUTOMODELREGISTRATIONENABLED = "AutoModelRegistrationEnabled"
    AUTOMODELREGISTRATIONDISABLED = "AutoModelRegistrationDisabled"


class ModelSortKey:
    """ModelSortKey enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"


class ModelSpeculativeDecodingS3DataType:
    """ModelSpeculativeDecodingS3DataType enum values."""

    S3PREFIX = "S3Prefix"
    MANIFESTFILE = "ManifestFile"


class ModelSpeculativeDecodingTechnique:
    """ModelSpeculativeDecodingTechnique enum values."""

    EAGLE = "EAGLE"


class ModelVariantAction:
    """ModelVariantAction enum values."""

    RETAIN = "Retain"
    REMOVE = "Remove"
    PROMOTE = "Promote"


class ModelVariantStatus:
    """ModelVariantStatus enum values."""

    CREATING = "Creating"
    UPDATING = "Updating"
    INSERVICE = "InService"
    DELETING = "Deleting"
    DELETED = "Deleted"


class MonitoringAlertHistorySortKey:
    """MonitoringAlertHistorySortKey enum values."""

    CREATIONTIME = "CreationTime"
    STATUS = "Status"


class MonitoringAlertStatus:
    """MonitoringAlertStatus enum values."""

    INALERT = "InAlert"
    OK = "OK"


class MonitoringExecutionSortKey:
    """MonitoringExecutionSortKey enum values."""

    CREATIONTIME = "CreationTime"
    SCHEDULEDTIME = "ScheduledTime"
    STATUS = "Status"


class MonitoringJobDefinitionSortKey:
    """MonitoringJobDefinitionSortKey enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"


class MonitoringProblemType:
    """MonitoringProblemType enum values."""

    BINARYCLASSIFICATION = "BinaryClassification"
    MULTICLASSCLASSIFICATION = "MulticlassClassification"
    REGRESSION = "Regression"


class MonitoringScheduleSortKey:
    """MonitoringScheduleSortKey enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    STATUS = "Status"


class MonitoringType:
    """MonitoringType enum values."""

    DATAQUALITY = "DataQuality"
    MODELQUALITY = "ModelQuality"
    MODELBIAS = "ModelBias"
    MODELEXPLAINABILITY = "ModelExplainability"


class NodeUnavailabilityType:
    """NodeUnavailabilityType enum values."""

    INSTANCE_COUNT = "INSTANCE_COUNT"
    CAPACITY_PERCENTAGE = "CAPACITY_PERCENTAGE"


class NotebookInstanceAcceleratorType:
    """NotebookInstanceAcceleratorType enum values."""

    ML_EIA1_MEDIUM = "ml.eia1.medium"
    ML_EIA1_LARGE = "ml.eia1.large"
    ML_EIA1_XLARGE = "ml.eia1.xlarge"
    ML_EIA2_MEDIUM = "ml.eia2.medium"
    ML_EIA2_LARGE = "ml.eia2.large"
    ML_EIA2_XLARGE = "ml.eia2.xlarge"


class NotebookInstanceLifecycleConfigSortKey:
    """NotebookInstanceLifecycleConfigSortKey enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    LASTMODIFIEDTIME = "LastModifiedTime"


class NotebookInstanceLifecycleConfigSortOrder:
    """NotebookInstanceLifecycleConfigSortOrder enum values."""

    ASCENDING = "Ascending"
    DESCENDING = "Descending"


class NotebookInstanceSortKey:
    """NotebookInstanceSortKey enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    STATUS = "Status"


class NotebookInstanceSortOrder:
    """NotebookInstanceSortOrder enum values."""

    ASCENDING = "Ascending"
    DESCENDING = "Descending"


class NotebookInstanceStatus:
    """NotebookInstanceStatus enum values."""

    PENDING = "Pending"
    INSERVICE = "InService"
    STOPPING = "Stopping"
    STOPPED = "Stopped"
    FAILED = "Failed"
    DELETING = "Deleting"
    UPDATING = "Updating"


class NotebookOutputOption:
    """NotebookOutputOption enum values."""

    ALLOWED = "Allowed"
    DISABLED = "Disabled"


class ObjectiveStatus:
    """ObjectiveStatus enum values."""

    SUCCEEDED = "Succeeded"
    PENDING = "Pending"
    FAILED = "Failed"


class OfflineStoreStatusValue:
    """OfflineStoreStatusValue enum values."""

    ACTIVE = "Active"
    BLOCKED = "Blocked"
    DISABLED = "Disabled"


class Operator:
    """Operator enum values."""

    EQUALS = "Equals"
    NOTEQUALS = "NotEquals"
    GREATERTHAN = "GreaterThan"
    GREATERTHANOREQUALTO = "GreaterThanOrEqualTo"
    LESSTHAN = "LessThan"
    LESSTHANOREQUALTO = "LessThanOrEqualTo"
    CONTAINS = "Contains"
    EXISTS = "Exists"
    NOTEXISTS = "NotExists"
    IN = "In"


class OptimizationJobDeploymentInstanceType:
    """OptimizationJobDeploymentInstanceType enum values."""

    ML_P4D_24XLARGE = "ml.p4d.24xlarge"
    ML_P4DE_24XLARGE = "ml.p4de.24xlarge"
    ML_P5_48XLARGE = "ml.p5.48xlarge"
    ML_P5E_48XLARGE = "ml.p5e.48xlarge"
    ML_P5EN_48XLARGE = "ml.p5en.48xlarge"
    ML_G5_XLARGE = "ml.g5.xlarge"
    ML_G5_2XLARGE = "ml.g5.2xlarge"
    ML_G5_4XLARGE = "ml.g5.4xlarge"
    ML_G5_8XLARGE = "ml.g5.8xlarge"
    ML_G5_12XLARGE = "ml.g5.12xlarge"
    ML_G5_16XLARGE = "ml.g5.16xlarge"
    ML_G5_24XLARGE = "ml.g5.24xlarge"
    ML_G5_48XLARGE = "ml.g5.48xlarge"
    ML_G6_XLARGE = "ml.g6.xlarge"
    ML_G6_2XLARGE = "ml.g6.2xlarge"
    ML_G6_4XLARGE = "ml.g6.4xlarge"
    ML_G6_8XLARGE = "ml.g6.8xlarge"
    ML_G6_12XLARGE = "ml.g6.12xlarge"
    ML_G6_16XLARGE = "ml.g6.16xlarge"
    ML_G6_24XLARGE = "ml.g6.24xlarge"
    ML_G6_48XLARGE = "ml.g6.48xlarge"
    ML_G6E_XLARGE = "ml.g6e.xlarge"
    ML_G6E_2XLARGE = "ml.g6e.2xlarge"
    ML_G6E_4XLARGE = "ml.g6e.4xlarge"
    ML_G6E_8XLARGE = "ml.g6e.8xlarge"
    ML_G6E_12XLARGE = "ml.g6e.12xlarge"
    ML_G6E_16XLARGE = "ml.g6e.16xlarge"
    ML_G6E_24XLARGE = "ml.g6e.24xlarge"
    ML_G6E_48XLARGE = "ml.g6e.48xlarge"
    ML_INF2_XLARGE = "ml.inf2.xlarge"
    ML_INF2_8XLARGE = "ml.inf2.8xlarge"
    ML_INF2_24XLARGE = "ml.inf2.24xlarge"
    ML_INF2_48XLARGE = "ml.inf2.48xlarge"
    ML_TRN1_2XLARGE = "ml.trn1.2xlarge"
    ML_TRN1_32XLARGE = "ml.trn1.32xlarge"
    ML_TRN1N_32XLARGE = "ml.trn1n.32xlarge"


class OptimizationJobStatus:
    """OptimizationJobStatus enum values."""

    INPROGRESS = "INPROGRESS"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    STARTING = "STARTING"
    STOPPING = "STOPPING"
    STOPPED = "STOPPED"


class OrderKey:
    """OrderKey enum values."""

    ASCENDING = "Ascending"
    DESCENDING = "Descending"


class OutputCompressionType:
    """OutputCompressionType enum values."""

    GZIP = "GZIP"
    NONE = "NONE"


class ParameterType:
    """ParameterType enum values."""

    INTEGER = "Integer"
    CONTINUOUS = "Continuous"
    CATEGORICAL = "Categorical"
    FREETEXT = "FreeText"


class PartnerAppAuthType:
    """PartnerAppAuthType enum values."""

    IAM = "IAM"


class PartnerAppStatus:
    """PartnerAppStatus enum values."""

    CREATING = "Creating"
    UPDATING = "Updating"
    DELETING = "Deleting"
    AVAILABLE = "Available"
    FAILED = "Failed"
    UPDATEFAILED = "UpdateFailed"
    DELETED = "Deleted"


class PartnerAppType:
    """PartnerAppType enum values."""

    LAKERA_GUARD = "lakera-guard"
    COMET = "comet"
    DEEPCHECKS_LLM_EVALUATION = "deepchecks-llm-evaluation"
    FIDDLER = "fiddler"


class Peft:
    """Peft enum values."""

    LORA = "LORA"


class PipelineExecutionStatus:
    """PipelineExecutionStatus enum values."""

    EXECUTING = "Executing"
    STOPPING = "Stopping"
    STOPPED = "Stopped"
    FAILED = "Failed"
    SUCCEEDED = "Succeeded"


class PipelineStatus:
    """PipelineStatus enum values."""

    ACTIVE = "Active"
    DELETING = "Deleting"


class PreemptTeamTasks:
    """PreemptTeamTasks enum values."""

    NEVER = "Never"
    LOWERPRIORITY = "LowerPriority"


class ProblemType:
    """ProblemType enum values."""

    BINARYCLASSIFICATION = "BinaryClassification"
    MULTICLASSCLASSIFICATION = "MulticlassClassification"
    REGRESSION = "Regression"


class ProcessingInstanceType:
    """ProcessingInstanceType enum values."""

    ML_T3_MEDIUM = "ml.t3.medium"
    ML_T3_LARGE = "ml.t3.large"
    ML_T3_XLARGE = "ml.t3.xlarge"
    ML_T3_2XLARGE = "ml.t3.2xlarge"
    ML_M4_XLARGE = "ml.m4.xlarge"
    ML_M4_2XLARGE = "ml.m4.2xlarge"
    ML_M4_4XLARGE = "ml.m4.4xlarge"
    ML_M4_10XLARGE = "ml.m4.10xlarge"
    ML_M4_16XLARGE = "ml.m4.16xlarge"
    ML_C4_XLARGE = "ml.c4.xlarge"
    ML_C4_2XLARGE = "ml.c4.2xlarge"
    ML_C4_4XLARGE = "ml.c4.4xlarge"
    ML_C4_8XLARGE = "ml.c4.8xlarge"
    ML_P2_XLARGE = "ml.p2.xlarge"
    ML_P2_8XLARGE = "ml.p2.8xlarge"
    ML_P2_16XLARGE = "ml.p2.16xlarge"
    ML_P3_2XLARGE = "ml.p3.2xlarge"
    ML_P3_8XLARGE = "ml.p3.8xlarge"
    ML_P3_16XLARGE = "ml.p3.16xlarge"
    ML_C5_XLARGE = "ml.c5.xlarge"
    ML_C5_2XLARGE = "ml.c5.2xlarge"
    ML_C5_4XLARGE = "ml.c5.4xlarge"
    ML_C5_9XLARGE = "ml.c5.9xlarge"
    ML_C5_18XLARGE = "ml.c5.18xlarge"
    ML_M5_LARGE = "ml.m5.large"
    ML_M5_XLARGE = "ml.m5.xlarge"
    ML_M5_2XLARGE = "ml.m5.2xlarge"
    ML_M5_4XLARGE = "ml.m5.4xlarge"
    ML_M5_12XLARGE = "ml.m5.12xlarge"
    ML_M5_24XLARGE = "ml.m5.24xlarge"
    ML_R5_LARGE = "ml.r5.large"
    ML_R5_XLARGE = "ml.r5.xlarge"
    ML_R5_2XLARGE = "ml.r5.2xlarge"
    ML_R5_4XLARGE = "ml.r5.4xlarge"
    ML_R5_8XLARGE = "ml.r5.8xlarge"
    ML_R5_12XLARGE = "ml.r5.12xlarge"
    ML_R5_16XLARGE = "ml.r5.16xlarge"
    ML_R5_24XLARGE = "ml.r5.24xlarge"
    ML_G4DN_XLARGE = "ml.g4dn.xlarge"
    ML_G4DN_2XLARGE = "ml.g4dn.2xlarge"
    ML_G4DN_4XLARGE = "ml.g4dn.4xlarge"
    ML_G4DN_8XLARGE = "ml.g4dn.8xlarge"
    ML_G4DN_12XLARGE = "ml.g4dn.12xlarge"
    ML_G4DN_16XLARGE = "ml.g4dn.16xlarge"
    ML_G5_XLARGE = "ml.g5.xlarge"
    ML_G5_2XLARGE = "ml.g5.2xlarge"
    ML_G5_4XLARGE = "ml.g5.4xlarge"
    ML_G5_8XLARGE = "ml.g5.8xlarge"
    ML_G5_16XLARGE = "ml.g5.16xlarge"
    ML_G5_12XLARGE = "ml.g5.12xlarge"
    ML_G5_24XLARGE = "ml.g5.24xlarge"
    ML_G5_48XLARGE = "ml.g5.48xlarge"
    ML_R5D_LARGE = "ml.r5d.large"
    ML_R5D_XLARGE = "ml.r5d.xlarge"
    ML_R5D_2XLARGE = "ml.r5d.2xlarge"
    ML_R5D_4XLARGE = "ml.r5d.4xlarge"
    ML_R5D_8XLARGE = "ml.r5d.8xlarge"
    ML_R5D_12XLARGE = "ml.r5d.12xlarge"
    ML_R5D_16XLARGE = "ml.r5d.16xlarge"
    ML_R5D_24XLARGE = "ml.r5d.24xlarge"
    ML_G6_XLARGE = "ml.g6.xlarge"
    ML_G6_2XLARGE = "ml.g6.2xlarge"
    ML_G6_4XLARGE = "ml.g6.4xlarge"
    ML_G6_8XLARGE = "ml.g6.8xlarge"
    ML_G6_12XLARGE = "ml.g6.12xlarge"
    ML_G6_16XLARGE = "ml.g6.16xlarge"
    ML_G6_24XLARGE = "ml.g6.24xlarge"
    ML_G6_48XLARGE = "ml.g6.48xlarge"
    ML_G6E_XLARGE = "ml.g6e.xlarge"
    ML_G6E_2XLARGE = "ml.g6e.2xlarge"
    ML_G6E_4XLARGE = "ml.g6e.4xlarge"
    ML_G6E_8XLARGE = "ml.g6e.8xlarge"
    ML_G6E_12XLARGE = "ml.g6e.12xlarge"
    ML_G6E_16XLARGE = "ml.g6e.16xlarge"
    ML_G6E_24XLARGE = "ml.g6e.24xlarge"
    ML_G6E_48XLARGE = "ml.g6e.48xlarge"
    ML_M6I_LARGE = "ml.m6i.large"
    ML_M6I_XLARGE = "ml.m6i.xlarge"
    ML_M6I_2XLARGE = "ml.m6i.2xlarge"
    ML_M6I_4XLARGE = "ml.m6i.4xlarge"
    ML_M6I_8XLARGE = "ml.m6i.8xlarge"
    ML_M6I_12XLARGE = "ml.m6i.12xlarge"
    ML_M6I_16XLARGE = "ml.m6i.16xlarge"
    ML_M6I_24XLARGE = "ml.m6i.24xlarge"
    ML_M6I_32XLARGE = "ml.m6i.32xlarge"
    ML_C6I_XLARGE = "ml.c6i.xlarge"
    ML_C6I_2XLARGE = "ml.c6i.2xlarge"
    ML_C6I_4XLARGE = "ml.c6i.4xlarge"
    ML_C6I_8XLARGE = "ml.c6i.8xlarge"
    ML_C6I_12XLARGE = "ml.c6i.12xlarge"
    ML_C6I_16XLARGE = "ml.c6i.16xlarge"
    ML_C6I_24XLARGE = "ml.c6i.24xlarge"
    ML_C6I_32XLARGE = "ml.c6i.32xlarge"
    ML_M7I_LARGE = "ml.m7i.large"
    ML_M7I_XLARGE = "ml.m7i.xlarge"
    ML_M7I_2XLARGE = "ml.m7i.2xlarge"
    ML_M7I_4XLARGE = "ml.m7i.4xlarge"
    ML_M7I_8XLARGE = "ml.m7i.8xlarge"
    ML_M7I_12XLARGE = "ml.m7i.12xlarge"
    ML_M7I_16XLARGE = "ml.m7i.16xlarge"
    ML_M7I_24XLARGE = "ml.m7i.24xlarge"
    ML_M7I_48XLARGE = "ml.m7i.48xlarge"
    ML_C7I_LARGE = "ml.c7i.large"
    ML_C7I_XLARGE = "ml.c7i.xlarge"
    ML_C7I_2XLARGE = "ml.c7i.2xlarge"
    ML_C7I_4XLARGE = "ml.c7i.4xlarge"
    ML_C7I_8XLARGE = "ml.c7i.8xlarge"
    ML_C7I_12XLARGE = "ml.c7i.12xlarge"
    ML_C7I_16XLARGE = "ml.c7i.16xlarge"
    ML_C7I_24XLARGE = "ml.c7i.24xlarge"
    ML_C7I_48XLARGE = "ml.c7i.48xlarge"
    ML_R7I_LARGE = "ml.r7i.large"
    ML_R7I_XLARGE = "ml.r7i.xlarge"
    ML_R7I_2XLARGE = "ml.r7i.2xlarge"
    ML_R7I_4XLARGE = "ml.r7i.4xlarge"
    ML_R7I_8XLARGE = "ml.r7i.8xlarge"
    ML_R7I_12XLARGE = "ml.r7i.12xlarge"
    ML_R7I_16XLARGE = "ml.r7i.16xlarge"
    ML_R7I_24XLARGE = "ml.r7i.24xlarge"
    ML_R7I_48XLARGE = "ml.r7i.48xlarge"
    ML_P5_4XLARGE = "ml.p5.4xlarge"


class ProcessingJobStatus:
    """ProcessingJobStatus enum values."""

    INPROGRESS = "InProgress"
    COMPLETED = "Completed"
    FAILED = "Failed"
    STOPPING = "Stopping"
    STOPPED = "Stopped"


class ProcessingS3CompressionType:
    """ProcessingS3CompressionType enum values."""

    NONE = "None"
    GZIP = "Gzip"


class ProcessingS3DataDistributionType:
    """ProcessingS3DataDistributionType enum values."""

    FULLYREPLICATED = "FullyReplicated"
    SHARDEDBYS3KEY = "ShardedByS3Key"


class ProcessingS3DataType:
    """ProcessingS3DataType enum values."""

    MANIFESTFILE = "ManifestFile"
    S3PREFIX = "S3Prefix"


class ProcessingS3InputMode:
    """ProcessingS3InputMode enum values."""

    PIPE = "Pipe"
    FILE = "File"


class ProcessingS3UploadMode:
    """ProcessingS3UploadMode enum values."""

    CONTINUOUS = "Continuous"
    ENDOFJOB = "EndOfJob"


class Processor:
    """Processor enum values."""

    CPU = "CPU"
    GPU = "GPU"


class ProductionVariantAcceleratorType:
    """ProductionVariantAcceleratorType enum values."""

    ML_EIA1_MEDIUM = "ml.eia1.medium"
    ML_EIA1_LARGE = "ml.eia1.large"
    ML_EIA1_XLARGE = "ml.eia1.xlarge"
    ML_EIA2_MEDIUM = "ml.eia2.medium"
    ML_EIA2_LARGE = "ml.eia2.large"
    ML_EIA2_XLARGE = "ml.eia2.xlarge"


class ProductionVariantInferenceAmiVersion:
    """ProductionVariantInferenceAmiVersion enum values."""

    AL2_AMI_SAGEMAKER_INFERENCE_GPU_2 = "al2-ami-sagemaker-inference-gpu-2"
    AL2_AMI_SAGEMAKER_INFERENCE_GPU_2_1 = "al2-ami-sagemaker-inference-gpu-2-1"
    AL2_AMI_SAGEMAKER_INFERENCE_GPU_3_1 = "al2-ami-sagemaker-inference-gpu-3-1"
    AL2_AMI_SAGEMAKER_INFERENCE_NEURON_2 = "al2-ami-sagemaker-inference-neuron-2"


class ProductionVariantInstanceType:
    """ProductionVariantInstanceType enum values."""

    ML_T2_MEDIUM = "ml.t2.medium"
    ML_T2_LARGE = "ml.t2.large"
    ML_T2_XLARGE = "ml.t2.xlarge"
    ML_T2_2XLARGE = "ml.t2.2xlarge"
    ML_M4_XLARGE = "ml.m4.xlarge"
    ML_M4_2XLARGE = "ml.m4.2xlarge"
    ML_M4_4XLARGE = "ml.m4.4xlarge"
    ML_M4_10XLARGE = "ml.m4.10xlarge"
    ML_M4_16XLARGE = "ml.m4.16xlarge"
    ML_M5_LARGE = "ml.m5.large"
    ML_M5_XLARGE = "ml.m5.xlarge"
    ML_M5_2XLARGE = "ml.m5.2xlarge"
    ML_M5_4XLARGE = "ml.m5.4xlarge"
    ML_M5_12XLARGE = "ml.m5.12xlarge"
    ML_M5_24XLARGE = "ml.m5.24xlarge"
    ML_M5D_LARGE = "ml.m5d.large"
    ML_M5D_XLARGE = "ml.m5d.xlarge"
    ML_M5D_2XLARGE = "ml.m5d.2xlarge"
    ML_M5D_4XLARGE = "ml.m5d.4xlarge"
    ML_M5D_12XLARGE = "ml.m5d.12xlarge"
    ML_M5D_24XLARGE = "ml.m5d.24xlarge"
    ML_C4_LARGE = "ml.c4.large"
    ML_C4_XLARGE = "ml.c4.xlarge"
    ML_C4_2XLARGE = "ml.c4.2xlarge"
    ML_C4_4XLARGE = "ml.c4.4xlarge"
    ML_C4_8XLARGE = "ml.c4.8xlarge"
    ML_P2_XLARGE = "ml.p2.xlarge"
    ML_P2_8XLARGE = "ml.p2.8xlarge"
    ML_P2_16XLARGE = "ml.p2.16xlarge"
    ML_P3_2XLARGE = "ml.p3.2xlarge"
    ML_P3_8XLARGE = "ml.p3.8xlarge"
    ML_P3_16XLARGE = "ml.p3.16xlarge"
    ML_C5_LARGE = "ml.c5.large"
    ML_C5_XLARGE = "ml.c5.xlarge"
    ML_C5_2XLARGE = "ml.c5.2xlarge"
    ML_C5_4XLARGE = "ml.c5.4xlarge"
    ML_C5_9XLARGE = "ml.c5.9xlarge"
    ML_C5_18XLARGE = "ml.c5.18xlarge"
    ML_C5D_LARGE = "ml.c5d.large"
    ML_C5D_XLARGE = "ml.c5d.xlarge"
    ML_C5D_2XLARGE = "ml.c5d.2xlarge"
    ML_C5D_4XLARGE = "ml.c5d.4xlarge"
    ML_C5D_9XLARGE = "ml.c5d.9xlarge"
    ML_C5D_18XLARGE = "ml.c5d.18xlarge"
    ML_G4DN_XLARGE = "ml.g4dn.xlarge"
    ML_G4DN_2XLARGE = "ml.g4dn.2xlarge"
    ML_G4DN_4XLARGE = "ml.g4dn.4xlarge"
    ML_G4DN_8XLARGE = "ml.g4dn.8xlarge"
    ML_G4DN_12XLARGE = "ml.g4dn.12xlarge"
    ML_G4DN_16XLARGE = "ml.g4dn.16xlarge"
    ML_R5_LARGE = "ml.r5.large"
    ML_R5_XLARGE = "ml.r5.xlarge"
    ML_R5_2XLARGE = "ml.r5.2xlarge"
    ML_R5_4XLARGE = "ml.r5.4xlarge"
    ML_R5_12XLARGE = "ml.r5.12xlarge"
    ML_R5_24XLARGE = "ml.r5.24xlarge"
    ML_R5D_LARGE = "ml.r5d.large"
    ML_R5D_XLARGE = "ml.r5d.xlarge"
    ML_R5D_2XLARGE = "ml.r5d.2xlarge"
    ML_R5D_4XLARGE = "ml.r5d.4xlarge"
    ML_R5D_12XLARGE = "ml.r5d.12xlarge"
    ML_R5D_24XLARGE = "ml.r5d.24xlarge"
    ML_INF1_XLARGE = "ml.inf1.xlarge"
    ML_INF1_2XLARGE = "ml.inf1.2xlarge"
    ML_INF1_6XLARGE = "ml.inf1.6xlarge"
    ML_INF1_24XLARGE = "ml.inf1.24xlarge"
    ML_DL1_24XLARGE = "ml.dl1.24xlarge"
    ML_C6I_LARGE = "ml.c6i.large"
    ML_C6I_XLARGE = "ml.c6i.xlarge"
    ML_C6I_2XLARGE = "ml.c6i.2xlarge"
    ML_C6I_4XLARGE = "ml.c6i.4xlarge"
    ML_C6I_8XLARGE = "ml.c6i.8xlarge"
    ML_C6I_12XLARGE = "ml.c6i.12xlarge"
    ML_C6I_16XLARGE = "ml.c6i.16xlarge"
    ML_C6I_24XLARGE = "ml.c6i.24xlarge"
    ML_C6I_32XLARGE = "ml.c6i.32xlarge"
    ML_M6I_LARGE = "ml.m6i.large"
    ML_M6I_XLARGE = "ml.m6i.xlarge"
    ML_M6I_2XLARGE = "ml.m6i.2xlarge"
    ML_M6I_4XLARGE = "ml.m6i.4xlarge"
    ML_M6I_8XLARGE = "ml.m6i.8xlarge"
    ML_M6I_12XLARGE = "ml.m6i.12xlarge"
    ML_M6I_16XLARGE = "ml.m6i.16xlarge"
    ML_M6I_24XLARGE = "ml.m6i.24xlarge"
    ML_M6I_32XLARGE = "ml.m6i.32xlarge"
    ML_R6I_LARGE = "ml.r6i.large"
    ML_R6I_XLARGE = "ml.r6i.xlarge"
    ML_R6I_2XLARGE = "ml.r6i.2xlarge"
    ML_R6I_4XLARGE = "ml.r6i.4xlarge"
    ML_R6I_8XLARGE = "ml.r6i.8xlarge"
    ML_R6I_12XLARGE = "ml.r6i.12xlarge"
    ML_R6I_16XLARGE = "ml.r6i.16xlarge"
    ML_R6I_24XLARGE = "ml.r6i.24xlarge"
    ML_R6I_32XLARGE = "ml.r6i.32xlarge"
    ML_G5_XLARGE = "ml.g5.xlarge"
    ML_G5_2XLARGE = "ml.g5.2xlarge"
    ML_G5_4XLARGE = "ml.g5.4xlarge"
    ML_G5_8XLARGE = "ml.g5.8xlarge"
    ML_G5_12XLARGE = "ml.g5.12xlarge"
    ML_G5_16XLARGE = "ml.g5.16xlarge"
    ML_G5_24XLARGE = "ml.g5.24xlarge"
    ML_G5_48XLARGE = "ml.g5.48xlarge"
    ML_G6_XLARGE = "ml.g6.xlarge"
    ML_G6_2XLARGE = "ml.g6.2xlarge"
    ML_G6_4XLARGE = "ml.g6.4xlarge"
    ML_G6_8XLARGE = "ml.g6.8xlarge"
    ML_G6_12XLARGE = "ml.g6.12xlarge"
    ML_G6_16XLARGE = "ml.g6.16xlarge"
    ML_G6_24XLARGE = "ml.g6.24xlarge"
    ML_G6_48XLARGE = "ml.g6.48xlarge"
    ML_R8G_MEDIUM = "ml.r8g.medium"
    ML_R8G_LARGE = "ml.r8g.large"
    ML_R8G_XLARGE = "ml.r8g.xlarge"
    ML_R8G_2XLARGE = "ml.r8g.2xlarge"
    ML_R8G_4XLARGE = "ml.r8g.4xlarge"
    ML_R8G_8XLARGE = "ml.r8g.8xlarge"
    ML_R8G_12XLARGE = "ml.r8g.12xlarge"
    ML_R8G_16XLARGE = "ml.r8g.16xlarge"
    ML_R8G_24XLARGE = "ml.r8g.24xlarge"
    ML_R8G_48XLARGE = "ml.r8g.48xlarge"
    ML_G6E_XLARGE = "ml.g6e.xlarge"
    ML_G6E_2XLARGE = "ml.g6e.2xlarge"
    ML_G6E_4XLARGE = "ml.g6e.4xlarge"
    ML_G6E_8XLARGE = "ml.g6e.8xlarge"
    ML_G6E_12XLARGE = "ml.g6e.12xlarge"
    ML_G6E_16XLARGE = "ml.g6e.16xlarge"
    ML_G6E_24XLARGE = "ml.g6e.24xlarge"
    ML_G6E_48XLARGE = "ml.g6e.48xlarge"
    ML_P4D_24XLARGE = "ml.p4d.24xlarge"
    ML_C7G_LARGE = "ml.c7g.large"
    ML_C7G_XLARGE = "ml.c7g.xlarge"
    ML_C7G_2XLARGE = "ml.c7g.2xlarge"
    ML_C7G_4XLARGE = "ml.c7g.4xlarge"
    ML_C7G_8XLARGE = "ml.c7g.8xlarge"
    ML_C7G_12XLARGE = "ml.c7g.12xlarge"
    ML_C7G_16XLARGE = "ml.c7g.16xlarge"
    ML_M6G_LARGE = "ml.m6g.large"
    ML_M6G_XLARGE = "ml.m6g.xlarge"
    ML_M6G_2XLARGE = "ml.m6g.2xlarge"
    ML_M6G_4XLARGE = "ml.m6g.4xlarge"
    ML_M6G_8XLARGE = "ml.m6g.8xlarge"
    ML_M6G_12XLARGE = "ml.m6g.12xlarge"
    ML_M6G_16XLARGE = "ml.m6g.16xlarge"
    ML_M6GD_LARGE = "ml.m6gd.large"
    ML_M6GD_XLARGE = "ml.m6gd.xlarge"
    ML_M6GD_2XLARGE = "ml.m6gd.2xlarge"
    ML_M6GD_4XLARGE = "ml.m6gd.4xlarge"
    ML_M6GD_8XLARGE = "ml.m6gd.8xlarge"
    ML_M6GD_12XLARGE = "ml.m6gd.12xlarge"
    ML_M6GD_16XLARGE = "ml.m6gd.16xlarge"
    ML_C6G_LARGE = "ml.c6g.large"
    ML_C6G_XLARGE = "ml.c6g.xlarge"
    ML_C6G_2XLARGE = "ml.c6g.2xlarge"
    ML_C6G_4XLARGE = "ml.c6g.4xlarge"
    ML_C6G_8XLARGE = "ml.c6g.8xlarge"
    ML_C6G_12XLARGE = "ml.c6g.12xlarge"
    ML_C6G_16XLARGE = "ml.c6g.16xlarge"
    ML_C6GD_LARGE = "ml.c6gd.large"
    ML_C6GD_XLARGE = "ml.c6gd.xlarge"
    ML_C6GD_2XLARGE = "ml.c6gd.2xlarge"
    ML_C6GD_4XLARGE = "ml.c6gd.4xlarge"
    ML_C6GD_8XLARGE = "ml.c6gd.8xlarge"
    ML_C6GD_12XLARGE = "ml.c6gd.12xlarge"
    ML_C6GD_16XLARGE = "ml.c6gd.16xlarge"
    ML_C6GN_LARGE = "ml.c6gn.large"
    ML_C6GN_XLARGE = "ml.c6gn.xlarge"
    ML_C6GN_2XLARGE = "ml.c6gn.2xlarge"
    ML_C6GN_4XLARGE = "ml.c6gn.4xlarge"
    ML_C6GN_8XLARGE = "ml.c6gn.8xlarge"
    ML_C6GN_12XLARGE = "ml.c6gn.12xlarge"
    ML_C6GN_16XLARGE = "ml.c6gn.16xlarge"
    ML_R6G_LARGE = "ml.r6g.large"
    ML_R6G_XLARGE = "ml.r6g.xlarge"
    ML_R6G_2XLARGE = "ml.r6g.2xlarge"
    ML_R6G_4XLARGE = "ml.r6g.4xlarge"
    ML_R6G_8XLARGE = "ml.r6g.8xlarge"
    ML_R6G_12XLARGE = "ml.r6g.12xlarge"
    ML_R6G_16XLARGE = "ml.r6g.16xlarge"
    ML_R6GD_LARGE = "ml.r6gd.large"
    ML_R6GD_XLARGE = "ml.r6gd.xlarge"
    ML_R6GD_2XLARGE = "ml.r6gd.2xlarge"
    ML_R6GD_4XLARGE = "ml.r6gd.4xlarge"
    ML_R6GD_8XLARGE = "ml.r6gd.8xlarge"
    ML_R6GD_12XLARGE = "ml.r6gd.12xlarge"
    ML_R6GD_16XLARGE = "ml.r6gd.16xlarge"
    ML_P4DE_24XLARGE = "ml.p4de.24xlarge"
    ML_TRN1_2XLARGE = "ml.trn1.2xlarge"
    ML_TRN1_32XLARGE = "ml.trn1.32xlarge"
    ML_TRN1N_32XLARGE = "ml.trn1n.32xlarge"
    ML_TRN2_48XLARGE = "ml.trn2.48xlarge"
    ML_INF2_XLARGE = "ml.inf2.xlarge"
    ML_INF2_8XLARGE = "ml.inf2.8xlarge"
    ML_INF2_24XLARGE = "ml.inf2.24xlarge"
    ML_INF2_48XLARGE = "ml.inf2.48xlarge"
    ML_P5_48XLARGE = "ml.p5.48xlarge"
    ML_P5E_48XLARGE = "ml.p5e.48xlarge"
    ML_P5EN_48XLARGE = "ml.p5en.48xlarge"
    ML_M7I_LARGE = "ml.m7i.large"
    ML_M7I_XLARGE = "ml.m7i.xlarge"
    ML_M7I_2XLARGE = "ml.m7i.2xlarge"
    ML_M7I_4XLARGE = "ml.m7i.4xlarge"
    ML_M7I_8XLARGE = "ml.m7i.8xlarge"
    ML_M7I_12XLARGE = "ml.m7i.12xlarge"
    ML_M7I_16XLARGE = "ml.m7i.16xlarge"
    ML_M7I_24XLARGE = "ml.m7i.24xlarge"
    ML_M7I_48XLARGE = "ml.m7i.48xlarge"
    ML_C7I_LARGE = "ml.c7i.large"
    ML_C7I_XLARGE = "ml.c7i.xlarge"
    ML_C7I_2XLARGE = "ml.c7i.2xlarge"
    ML_C7I_4XLARGE = "ml.c7i.4xlarge"
    ML_C7I_8XLARGE = "ml.c7i.8xlarge"
    ML_C7I_12XLARGE = "ml.c7i.12xlarge"
    ML_C7I_16XLARGE = "ml.c7i.16xlarge"
    ML_C7I_24XLARGE = "ml.c7i.24xlarge"
    ML_C7I_48XLARGE = "ml.c7i.48xlarge"
    ML_R7I_LARGE = "ml.r7i.large"
    ML_R7I_XLARGE = "ml.r7i.xlarge"
    ML_R7I_2XLARGE = "ml.r7i.2xlarge"
    ML_R7I_4XLARGE = "ml.r7i.4xlarge"
    ML_R7I_8XLARGE = "ml.r7i.8xlarge"
    ML_R7I_12XLARGE = "ml.r7i.12xlarge"
    ML_R7I_16XLARGE = "ml.r7i.16xlarge"
    ML_R7I_24XLARGE = "ml.r7i.24xlarge"
    ML_R7I_48XLARGE = "ml.r7i.48xlarge"
    ML_C8G_MEDIUM = "ml.c8g.medium"
    ML_C8G_LARGE = "ml.c8g.large"
    ML_C8G_XLARGE = "ml.c8g.xlarge"
    ML_C8G_2XLARGE = "ml.c8g.2xlarge"
    ML_C8G_4XLARGE = "ml.c8g.4xlarge"
    ML_C8G_8XLARGE = "ml.c8g.8xlarge"
    ML_C8G_12XLARGE = "ml.c8g.12xlarge"
    ML_C8G_16XLARGE = "ml.c8g.16xlarge"
    ML_C8G_24XLARGE = "ml.c8g.24xlarge"
    ML_C8G_48XLARGE = "ml.c8g.48xlarge"
    ML_R7GD_MEDIUM = "ml.r7gd.medium"
    ML_R7GD_LARGE = "ml.r7gd.large"
    ML_R7GD_XLARGE = "ml.r7gd.xlarge"
    ML_R7GD_2XLARGE = "ml.r7gd.2xlarge"
    ML_R7GD_4XLARGE = "ml.r7gd.4xlarge"
    ML_R7GD_8XLARGE = "ml.r7gd.8xlarge"
    ML_R7GD_12XLARGE = "ml.r7gd.12xlarge"
    ML_R7GD_16XLARGE = "ml.r7gd.16xlarge"
    ML_M8G_MEDIUM = "ml.m8g.medium"
    ML_M8G_LARGE = "ml.m8g.large"
    ML_M8G_XLARGE = "ml.m8g.xlarge"
    ML_M8G_2XLARGE = "ml.m8g.2xlarge"
    ML_M8G_4XLARGE = "ml.m8g.4xlarge"
    ML_M8G_8XLARGE = "ml.m8g.8xlarge"
    ML_M8G_12XLARGE = "ml.m8g.12xlarge"
    ML_M8G_16XLARGE = "ml.m8g.16xlarge"
    ML_M8G_24XLARGE = "ml.m8g.24xlarge"
    ML_M8G_48XLARGE = "ml.m8g.48xlarge"
    ML_C6IN_LARGE = "ml.c6in.large"
    ML_C6IN_XLARGE = "ml.c6in.xlarge"
    ML_C6IN_2XLARGE = "ml.c6in.2xlarge"
    ML_C6IN_4XLARGE = "ml.c6in.4xlarge"
    ML_C6IN_8XLARGE = "ml.c6in.8xlarge"
    ML_C6IN_12XLARGE = "ml.c6in.12xlarge"
    ML_C6IN_16XLARGE = "ml.c6in.16xlarge"
    ML_C6IN_24XLARGE = "ml.c6in.24xlarge"
    ML_C6IN_32XLARGE = "ml.c6in.32xlarge"
    ML_P6_B200_48XLARGE = "ml.p6-b200.48xlarge"
    ML_P6E_GB200_36XLARGE = "ml.p6e-gb200.36xlarge"
    ML_P5_4XLARGE = "ml.p5.4xlarge"


class ProfilingStatus:
    """ProfilingStatus enum values."""

    ENABLED = "Enabled"
    DISABLED = "Disabled"


class ProjectSortBy:
    """ProjectSortBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"


class ProjectSortOrder:
    """ProjectSortOrder enum values."""

    ASCENDING = "Ascending"
    DESCENDING = "Descending"


class ProjectStatus:
    """ProjectStatus enum values."""

    PENDING = "Pending"
    CREATEINPROGRESS = "CreateInProgress"
    CREATECOMPLETED = "CreateCompleted"
    CREATEFAILED = "CreateFailed"
    DELETEINPROGRESS = "DeleteInProgress"
    DELETEFAILED = "DeleteFailed"
    DELETECOMPLETED = "DeleteCompleted"
    UPDATEINPROGRESS = "UpdateInProgress"
    UPDATECOMPLETED = "UpdateCompleted"
    UPDATEFAILED = "UpdateFailed"


class RStudioServerProAccessStatus:
    """RStudioServerProAccessStatus enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class RStudioServerProUserGroup:
    """RStudioServerProUserGroup enum values."""

    R_STUDIO_ADMIN = "R_STUDIO_ADMIN"
    R_STUDIO_USER = "R_STUDIO_USER"


class RecommendationJobStatus:
    """RecommendationJobStatus enum values."""

    PENDING = "PENDING"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    STOPPING = "STOPPING"
    STOPPED = "STOPPED"
    DELETING = "DELETING"
    DELETED = "DELETED"


class RecommendationJobSupportedEndpointType:
    """RecommendationJobSupportedEndpointType enum values."""

    REALTIME = "RealTime"
    SERVERLESS = "Serverless"


class RecommendationJobType:
    """RecommendationJobType enum values."""

    DEFAULT = "Default"
    ADVANCED = "Advanced"


class RecommendationStatus:
    """RecommendationStatus enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    NOT_APPLICABLE = "NOT_APPLICABLE"


class RecommendationStepType:
    """RecommendationStepType enum values."""

    BENCHMARK = "BENCHMARK"


class RecordWrapper:
    """RecordWrapper enum values."""

    NONE = "None"
    RECORDIO = "RecordIO"


class RedshiftResultCompressionType:
    """RedshiftResultCompressionType enum values."""

    NONE = "None"
    GZIP = "GZIP"
    BZIP2 = "BZIP2"
    ZSTD = "ZSTD"
    SNAPPY = "SNAPPY"


class RedshiftResultFormat:
    """RedshiftResultFormat enum values."""

    PARQUET = "PARQUET"
    CSV = "CSV"


class Relation:
    """Relation enum values."""

    EQUALTO = "EqualTo"
    GREATERTHANOREQUALTO = "GreaterThanOrEqualTo"


class RepositoryAccessMode:
    """RepositoryAccessMode enum values."""

    PLATFORM = "Platform"
    VPC = "Vpc"


class ReservedCapacityInstanceType:
    """ReservedCapacityInstanceType enum values."""

    ML_P4D_24XLARGE = "ml.p4d.24xlarge"
    ML_P5_48XLARGE = "ml.p5.48xlarge"
    ML_P5E_48XLARGE = "ml.p5e.48xlarge"
    ML_P5EN_48XLARGE = "ml.p5en.48xlarge"
    ML_TRN1_32XLARGE = "ml.trn1.32xlarge"
    ML_TRN2_48XLARGE = "ml.trn2.48xlarge"
    ML_P6_B200_48XLARGE = "ml.p6-b200.48xlarge"
    ML_P4DE_24XLARGE = "ml.p4de.24xlarge"
    ML_P6E_GB200_36XLARGE = "ml.p6e-gb200.36xlarge"
    ML_P5_4XLARGE = "ml.p5.4xlarge"
    ML_P6_B300_48XLARGE = "ml.p6-b300.48xlarge"


class ReservedCapacityStatus:
    """ReservedCapacityStatus enum values."""

    PENDING = "Pending"
    ACTIVE = "Active"
    SCHEDULED = "Scheduled"
    EXPIRED = "Expired"
    FAILED = "Failed"


class ReservedCapacityType:
    """ReservedCapacityType enum values."""

    ULTRASERVER = "UltraServer"
    INSTANCE = "Instance"


class ResourceCatalogSortBy:
    """ResourceCatalogSortBy enum values."""

    CREATIONTIME = "CreationTime"


class ResourceCatalogSortOrder:
    """ResourceCatalogSortOrder enum values."""

    ASCENDING = "Ascending"
    DESCENDING = "Descending"


class ResourceSharingStrategy:
    """ResourceSharingStrategy enum values."""

    LEND = "Lend"
    DONTLEND = "DontLend"
    LENDANDBORROW = "LendAndBorrow"


class ResourceType:
    """ResourceType enum values."""

    TRAININGJOB = "TrainingJob"
    EXPERIMENT = "Experiment"
    EXPERIMENTTRIAL = "ExperimentTrial"
    EXPERIMENTTRIALCOMPONENT = "ExperimentTrialComponent"
    ENDPOINT = "Endpoint"
    MODEL = "Model"
    MODELPACKAGE = "ModelPackage"
    MODELPACKAGEGROUP = "ModelPackageGroup"
    PIPELINE = "Pipeline"
    PIPELINEEXECUTION = "PipelineExecution"
    FEATUREGROUP = "FeatureGroup"
    FEATUREMETADATA = "FeatureMetadata"
    IMAGE = "Image"
    IMAGEVERSION = "ImageVersion"
    PROJECT = "Project"
    HYPERPARAMETERTUNINGJOB = "HyperParameterTuningJob"
    MODELCARD = "ModelCard"
    PIPELINEVERSION = "PipelineVersion"


class RetentionType:
    """RetentionType enum values."""

    RETAIN = "Retain"
    DELETE = "Delete"


class RootAccess:
    """RootAccess enum values."""

    ENABLED = "Enabled"
    DISABLED = "Disabled"


class RoutingStrategy:
    """RoutingStrategy enum values."""

    LEAST_OUTSTANDING_REQUESTS = "LEAST_OUTSTANDING_REQUESTS"
    RANDOM = "RANDOM"


class RuleEvaluationStatus:
    """RuleEvaluationStatus enum values."""

    INPROGRESS = "InProgress"
    NOISSUESFOUND = "NoIssuesFound"
    ISSUESFOUND = "IssuesFound"
    ERROR = "Error"
    STOPPING = "Stopping"
    STOPPED = "Stopped"


class S3DataDistribution:
    """S3DataDistribution enum values."""

    FULLYREPLICATED = "FullyReplicated"
    SHARDEDBYS3KEY = "ShardedByS3Key"


class S3DataType:
    """S3DataType enum values."""

    MANIFESTFILE = "ManifestFile"
    S3PREFIX = "S3Prefix"
    AUGMENTEDMANIFESTFILE = "AugmentedManifestFile"
    CONVERSE = "Converse"


class S3ModelDataType:
    """S3ModelDataType enum values."""

    S3PREFIX = "S3Prefix"
    S3OBJECT = "S3Object"


class SageMakerImageName:
    """SageMakerImageName enum values."""

    SAGEMAKER_DISTRIBUTION = "sagemaker_distribution"


class SageMakerResourceName:
    """SageMakerResourceName enum values."""

    TRAINING_JOB = "training-job"
    HYPERPOD_CLUSTER = "hyperpod-cluster"
    ENDPOINT = "endpoint"


class SagemakerServicecatalogStatus:
    """SagemakerServicecatalogStatus enum values."""

    ENABLED = "Enabled"
    DISABLED = "Disabled"


class ScheduleStatus:
    """ScheduleStatus enum values."""

    PENDING = "Pending"
    FAILED = "Failed"
    SCHEDULED = "Scheduled"
    STOPPED = "Stopped"


class SchedulerResourceStatus:
    """SchedulerResourceStatus enum values."""

    CREATING = "Creating"
    CREATEFAILED = "CreateFailed"
    CREATEROLLBACKFAILED = "CreateRollbackFailed"
    CREATED = "Created"
    UPDATING = "Updating"
    UPDATEFAILED = "UpdateFailed"
    UPDATEROLLBACKFAILED = "UpdateRollbackFailed"
    UPDATED = "Updated"
    DELETING = "Deleting"
    DELETEFAILED = "DeleteFailed"
    DELETEROLLBACKFAILED = "DeleteRollbackFailed"
    DELETED = "Deleted"


class SearchSortOrder:
    """SearchSortOrder enum values."""

    ASCENDING = "Ascending"
    DESCENDING = "Descending"


class SecondaryStatus:
    """SecondaryStatus enum values."""

    STARTING = "Starting"
    LAUNCHINGMLINSTANCES = "LaunchingMLInstances"
    PREPARINGTRAININGSTACK = "PreparingTrainingStack"
    DOWNLOADING = "Downloading"
    DOWNLOADINGTRAININGIMAGE = "DownloadingTrainingImage"
    TRAINING = "Training"
    UPLOADING = "Uploading"
    STOPPING = "Stopping"
    STOPPED = "Stopped"
    MAXRUNTIMEEXCEEDED = "MaxRuntimeExceeded"
    COMPLETED = "Completed"
    FAILED = "Failed"
    INTERRUPTED = "Interrupted"
    MAXWAITTIMEEXCEEDED = "MaxWaitTimeExceeded"
    UPDATING = "Updating"
    RESTARTING = "Restarting"
    PENDING = "Pending"


class ServerlessJobType:
    """ServerlessJobType enum values."""

    FINETUNING = "FineTuning"
    EVALUATION = "Evaluation"


class SharingType:
    """SharingType enum values."""

    PRIVATE = "Private"
    SHARED = "Shared"


class SkipModelValidation:
    """SkipModelValidation enum values."""

    ALL = "All"
    NONE = "None"


class SoftwareUpdateStatus:
    """SoftwareUpdateStatus enum values."""

    PENDING = "Pending"
    INPROGRESS = "InProgress"
    SUCCEEDED = "Succeeded"
    FAILED = "Failed"
    ROLLBACKINPROGRESS = "RollbackInProgress"
    ROLLBACKCOMPLETE = "RollbackComplete"


class SortActionsBy:
    """SortActionsBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"


class SortArtifactsBy:
    """SortArtifactsBy enum values."""

    CREATIONTIME = "CreationTime"


class SortAssociationsBy:
    """SortAssociationsBy enum values."""

    SOURCEARN = "SourceArn"
    DESTINATIONARN = "DestinationArn"
    SOURCETYPE = "SourceType"
    DESTINATIONTYPE = "DestinationType"
    CREATIONTIME = "CreationTime"


class SortBy:
    """SortBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    STATUS = "Status"


class SortClusterSchedulerConfigBy:
    """SortClusterSchedulerConfigBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    STATUS = "Status"


class SortContextsBy:
    """SortContextsBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"


class SortExperimentsBy:
    """SortExperimentsBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"


class SortInferenceExperimentsBy:
    """SortInferenceExperimentsBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    STATUS = "Status"


class SortLineageGroupsBy:
    """SortLineageGroupsBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"


class SortMlflowAppBy:
    """SortMlflowAppBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    STATUS = "Status"


class SortOrder:
    """SortOrder enum values."""

    ASCENDING = "Ascending"
    DESCENDING = "Descending"


class SortPipelineExecutionsBy:
    """SortPipelineExecutionsBy enum values."""

    CREATIONTIME = "CreationTime"
    PIPELINEEXECUTIONARN = "PipelineExecutionArn"


class SortPipelinesBy:
    """SortPipelinesBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"


class SortQuotaBy:
    """SortQuotaBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    STATUS = "Status"
    CLUSTERARN = "ClusterArn"


class SortTrackingServerBy:
    """SortTrackingServerBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    STATUS = "Status"


class SortTrialComponentsBy:
    """SortTrialComponentsBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"


class SortTrialsBy:
    """SortTrialsBy enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"


class SpaceSortKey:
    """SpaceSortKey enum values."""

    CREATIONTIME = "CreationTime"
    LASTMODIFIEDTIME = "LastModifiedTime"


class SpaceStatus:
    """SpaceStatus enum values."""

    DELETING = "Deleting"
    FAILED = "Failed"
    INSERVICE = "InService"
    PENDING = "Pending"
    UPDATING = "Updating"
    UPDATE_FAILED = "Update_Failed"
    DELETE_FAILED = "Delete_Failed"


class SplitType:
    """SplitType enum values."""

    NONE = "None"
    LINE = "Line"
    RECORDIO = "RecordIO"
    TFRECORD = "TFRecord"


class StageStatus:
    """StageStatus enum values."""

    CREATING = "CREATING"
    READYTODEPLOY = "READYTODEPLOY"
    STARTING = "STARTING"
    INPROGRESS = "INPROGRESS"
    DEPLOYED = "DEPLOYED"
    FAILED = "FAILED"
    STOPPING = "STOPPING"
    STOPPED = "STOPPED"


class Statistic:
    """Statistic enum values."""

    AVERAGE = "Average"
    MINIMUM = "Minimum"
    MAXIMUM = "Maximum"
    SAMPLECOUNT = "SampleCount"
    SUM = "Sum"


class StepStatus:
    """StepStatus enum values."""

    STARTING = "Starting"
    EXECUTING = "Executing"
    STOPPING = "Stopping"
    STOPPED = "Stopped"
    FAILED = "Failed"
    SUCCEEDED = "Succeeded"


class StorageType:
    """StorageType enum values."""

    STANDARD = "Standard"
    INMEMORY = "InMemory"


class StudioLifecycleConfigAppType:
    """StudioLifecycleConfigAppType enum values."""

    JUPYTERSERVER = "JupyterServer"
    KERNELGATEWAY = "KernelGateway"
    CODEEDITOR = "CodeEditor"
    JUPYTERLAB = "JupyterLab"


class StudioLifecycleConfigSortKey:
    """StudioLifecycleConfigSortKey enum values."""

    CREATIONTIME = "CreationTime"
    LASTMODIFIEDTIME = "LastModifiedTime"
    NAME = "Name"


class StudioWebPortal:
    """StudioWebPortal enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class TableFormat:
    """TableFormat enum values."""

    DEFAULT = "Default"
    GLUE = "Glue"
    ICEBERG = "Iceberg"


class TagPropagation:
    """TagPropagation enum values."""

    ENABLED = "ENABLED"
    DISABLED = "DISABLED"


class TargetDevice:
    """TargetDevice enum values."""

    LAMBDA = "lambda"
    ML_M4 = "ml_m4"
    ML_M5 = "ml_m5"
    ML_M6G = "ml_m6g"
    ML_C4 = "ml_c4"
    ML_C5 = "ml_c5"
    ML_C6G = "ml_c6g"
    ML_P2 = "ml_p2"
    ML_P3 = "ml_p3"
    ML_G4DN = "ml_g4dn"
    ML_INF1 = "ml_inf1"
    ML_INF2 = "ml_inf2"
    ML_TRN1 = "ml_trn1"
    ML_EIA2 = "ml_eia2"
    JETSON_TX1 = "jetson_tx1"
    JETSON_TX2 = "jetson_tx2"
    JETSON_NANO = "jetson_nano"
    JETSON_XAVIER = "jetson_xavier"
    RASP3B = "rasp3b"
    RASP4B = "rasp4b"
    IMX8QM = "imx8qm"
    DEEPLENS = "deeplens"
    RK3399 = "rk3399"
    RK3288 = "rk3288"
    AISAGE = "aisage"
    SBE_C = "sbe_c"
    QCS605 = "qcs605"
    QCS603 = "qcs603"
    SITARA_AM57X = "sitara_am57x"
    AMBA_CV2 = "amba_cv2"
    AMBA_CV22 = "amba_cv22"
    AMBA_CV25 = "amba_cv25"
    X86_WIN32 = "x86_win32"
    X86_WIN64 = "x86_win64"
    COREML = "coreml"
    JACINTO_TDA4VM = "jacinto_tda4vm"
    IMX8MPLUS = "imx8mplus"


class TargetPlatformAccelerator:
    """TargetPlatformAccelerator enum values."""

    INTEL_GRAPHICS = "INTEL_GRAPHICS"
    MALI = "MALI"
    NVIDIA = "NVIDIA"
    NNA = "NNA"


class TargetPlatformArch:
    """TargetPlatformArch enum values."""

    X86_64 = "X86_64"
    X86 = "X86"
    ARM64 = "ARM64"
    ARM_EABI = "ARM_EABI"
    ARM_EABIHF = "ARM_EABIHF"


class TargetPlatformOs:
    """TargetPlatformOs enum values."""

    ANDROID = "ANDROID"
    LINUX = "LINUX"


class ThroughputMode:
    """ThroughputMode enum values."""

    ONDEMAND = "OnDemand"
    PROVISIONED = "Provisioned"


class TrackingServerMaintenanceStatus:
    """TrackingServerMaintenanceStatus enum values."""

    MAINTENANCEINPROGRESS = "MaintenanceInProgress"
    MAINTENANCECOMPLETE = "MaintenanceComplete"
    MAINTENANCEFAILED = "MaintenanceFailed"


class TrackingServerSize:
    """TrackingServerSize enum values."""

    SMALL = "Small"
    MEDIUM = "Medium"
    LARGE = "Large"


class TrackingServerStatus:
    """TrackingServerStatus enum values."""

    CREATING = "Creating"
    CREATED = "Created"
    CREATEFAILED = "CreateFailed"
    UPDATING = "Updating"
    UPDATED = "Updated"
    UPDATEFAILED = "UpdateFailed"
    DELETING = "Deleting"
    DELETEFAILED = "DeleteFailed"
    STOPPING = "Stopping"
    STOPPED = "Stopped"
    STOPFAILED = "StopFailed"
    STARTING = "Starting"
    STARTED = "Started"
    STARTFAILED = "StartFailed"
    MAINTENANCEINPROGRESS = "MaintenanceInProgress"
    MAINTENANCECOMPLETE = "MaintenanceComplete"
    MAINTENANCEFAILED = "MaintenanceFailed"


class TrafficRoutingConfigType:
    """TrafficRoutingConfigType enum values."""

    ALL_AT_ONCE = "ALL_AT_ONCE"
    CANARY = "CANARY"
    LINEAR = "LINEAR"


class TrafficType:
    """TrafficType enum values."""

    PHASES = "PHASES"
    STAIRS = "STAIRS"


class TrainingInputMode:
    """TrainingInputMode enum values."""

    PIPE = "Pipe"
    FILE = "File"
    FASTFILE = "FastFile"


class TrainingInstanceType:
    """TrainingInstanceType enum values."""

    ML_M4_XLARGE = "ml.m4.xlarge"
    ML_M4_2XLARGE = "ml.m4.2xlarge"
    ML_M4_4XLARGE = "ml.m4.4xlarge"
    ML_M4_10XLARGE = "ml.m4.10xlarge"
    ML_M4_16XLARGE = "ml.m4.16xlarge"
    ML_G4DN_XLARGE = "ml.g4dn.xlarge"
    ML_G4DN_2XLARGE = "ml.g4dn.2xlarge"
    ML_G4DN_4XLARGE = "ml.g4dn.4xlarge"
    ML_G4DN_8XLARGE = "ml.g4dn.8xlarge"
    ML_G4DN_12XLARGE = "ml.g4dn.12xlarge"
    ML_G4DN_16XLARGE = "ml.g4dn.16xlarge"
    ML_M5_LARGE = "ml.m5.large"
    ML_M5_XLARGE = "ml.m5.xlarge"
    ML_M5_2XLARGE = "ml.m5.2xlarge"
    ML_M5_4XLARGE = "ml.m5.4xlarge"
    ML_M5_12XLARGE = "ml.m5.12xlarge"
    ML_M5_24XLARGE = "ml.m5.24xlarge"
    ML_C4_XLARGE = "ml.c4.xlarge"
    ML_C4_2XLARGE = "ml.c4.2xlarge"
    ML_C4_4XLARGE = "ml.c4.4xlarge"
    ML_C4_8XLARGE = "ml.c4.8xlarge"
    ML_P2_XLARGE = "ml.p2.xlarge"
    ML_P2_8XLARGE = "ml.p2.8xlarge"
    ML_P2_16XLARGE = "ml.p2.16xlarge"
    ML_P3_2XLARGE = "ml.p3.2xlarge"
    ML_P3_8XLARGE = "ml.p3.8xlarge"
    ML_P3_16XLARGE = "ml.p3.16xlarge"
    ML_P3DN_24XLARGE = "ml.p3dn.24xlarge"
    ML_P4D_24XLARGE = "ml.p4d.24xlarge"
    ML_P4DE_24XLARGE = "ml.p4de.24xlarge"
    ML_P5_48XLARGE = "ml.p5.48xlarge"
    ML_P5E_48XLARGE = "ml.p5e.48xlarge"
    ML_P5EN_48XLARGE = "ml.p5en.48xlarge"
    ML_C5_XLARGE = "ml.c5.xlarge"
    ML_C5_2XLARGE = "ml.c5.2xlarge"
    ML_C5_4XLARGE = "ml.c5.4xlarge"
    ML_C5_9XLARGE = "ml.c5.9xlarge"
    ML_C5_18XLARGE = "ml.c5.18xlarge"
    ML_C5N_XLARGE = "ml.c5n.xlarge"
    ML_C5N_2XLARGE = "ml.c5n.2xlarge"
    ML_C5N_4XLARGE = "ml.c5n.4xlarge"
    ML_C5N_9XLARGE = "ml.c5n.9xlarge"
    ML_C5N_18XLARGE = "ml.c5n.18xlarge"
    ML_G5_XLARGE = "ml.g5.xlarge"
    ML_G5_2XLARGE = "ml.g5.2xlarge"
    ML_G5_4XLARGE = "ml.g5.4xlarge"
    ML_G5_8XLARGE = "ml.g5.8xlarge"
    ML_G5_16XLARGE = "ml.g5.16xlarge"
    ML_G5_12XLARGE = "ml.g5.12xlarge"
    ML_G5_24XLARGE = "ml.g5.24xlarge"
    ML_G5_48XLARGE = "ml.g5.48xlarge"
    ML_G6_XLARGE = "ml.g6.xlarge"
    ML_G6_2XLARGE = "ml.g6.2xlarge"
    ML_G6_4XLARGE = "ml.g6.4xlarge"
    ML_G6_8XLARGE = "ml.g6.8xlarge"
    ML_G6_16XLARGE = "ml.g6.16xlarge"
    ML_G6_12XLARGE = "ml.g6.12xlarge"
    ML_G6_24XLARGE = "ml.g6.24xlarge"
    ML_G6_48XLARGE = "ml.g6.48xlarge"
    ML_G6E_XLARGE = "ml.g6e.xlarge"
    ML_G6E_2XLARGE = "ml.g6e.2xlarge"
    ML_G6E_4XLARGE = "ml.g6e.4xlarge"
    ML_G6E_8XLARGE = "ml.g6e.8xlarge"
    ML_G6E_16XLARGE = "ml.g6e.16xlarge"
    ML_G6E_12XLARGE = "ml.g6e.12xlarge"
    ML_G6E_24XLARGE = "ml.g6e.24xlarge"
    ML_G6E_48XLARGE = "ml.g6e.48xlarge"
    ML_TRN1_2XLARGE = "ml.trn1.2xlarge"
    ML_TRN1_32XLARGE = "ml.trn1.32xlarge"
    ML_TRN1N_32XLARGE = "ml.trn1n.32xlarge"
    ML_TRN2_48XLARGE = "ml.trn2.48xlarge"
    ML_M6I_LARGE = "ml.m6i.large"
    ML_M6I_XLARGE = "ml.m6i.xlarge"
    ML_M6I_2XLARGE = "ml.m6i.2xlarge"
    ML_M6I_4XLARGE = "ml.m6i.4xlarge"
    ML_M6I_8XLARGE = "ml.m6i.8xlarge"
    ML_M6I_12XLARGE = "ml.m6i.12xlarge"
    ML_M6I_16XLARGE = "ml.m6i.16xlarge"
    ML_M6I_24XLARGE = "ml.m6i.24xlarge"
    ML_M6I_32XLARGE = "ml.m6i.32xlarge"
    ML_C6I_XLARGE = "ml.c6i.xlarge"
    ML_C6I_2XLARGE = "ml.c6i.2xlarge"
    ML_C6I_8XLARGE = "ml.c6i.8xlarge"
    ML_C6I_4XLARGE = "ml.c6i.4xlarge"
    ML_C6I_12XLARGE = "ml.c6i.12xlarge"
    ML_C6I_16XLARGE = "ml.c6i.16xlarge"
    ML_C6I_24XLARGE = "ml.c6i.24xlarge"
    ML_C6I_32XLARGE = "ml.c6i.32xlarge"
    ML_R5D_LARGE = "ml.r5d.large"
    ML_R5D_XLARGE = "ml.r5d.xlarge"
    ML_R5D_2XLARGE = "ml.r5d.2xlarge"
    ML_R5D_4XLARGE = "ml.r5d.4xlarge"
    ML_R5D_8XLARGE = "ml.r5d.8xlarge"
    ML_R5D_12XLARGE = "ml.r5d.12xlarge"
    ML_R5D_16XLARGE = "ml.r5d.16xlarge"
    ML_R5D_24XLARGE = "ml.r5d.24xlarge"
    ML_T3_MEDIUM = "ml.t3.medium"
    ML_T3_LARGE = "ml.t3.large"
    ML_T3_XLARGE = "ml.t3.xlarge"
    ML_T3_2XLARGE = "ml.t3.2xlarge"
    ML_R5_LARGE = "ml.r5.large"
    ML_R5_XLARGE = "ml.r5.xlarge"
    ML_R5_2XLARGE = "ml.r5.2xlarge"
    ML_R5_4XLARGE = "ml.r5.4xlarge"
    ML_R5_8XLARGE = "ml.r5.8xlarge"
    ML_R5_12XLARGE = "ml.r5.12xlarge"
    ML_R5_16XLARGE = "ml.r5.16xlarge"
    ML_R5_24XLARGE = "ml.r5.24xlarge"
    ML_P6_B200_48XLARGE = "ml.p6-b200.48xlarge"
    ML_M7I_LARGE = "ml.m7i.large"
    ML_M7I_XLARGE = "ml.m7i.xlarge"
    ML_M7I_2XLARGE = "ml.m7i.2xlarge"
    ML_M7I_4XLARGE = "ml.m7i.4xlarge"
    ML_M7I_8XLARGE = "ml.m7i.8xlarge"
    ML_M7I_12XLARGE = "ml.m7i.12xlarge"
    ML_M7I_16XLARGE = "ml.m7i.16xlarge"
    ML_M7I_24XLARGE = "ml.m7i.24xlarge"
    ML_M7I_48XLARGE = "ml.m7i.48xlarge"
    ML_C7I_LARGE = "ml.c7i.large"
    ML_C7I_XLARGE = "ml.c7i.xlarge"
    ML_C7I_2XLARGE = "ml.c7i.2xlarge"
    ML_C7I_4XLARGE = "ml.c7i.4xlarge"
    ML_C7I_8XLARGE = "ml.c7i.8xlarge"
    ML_C7I_12XLARGE = "ml.c7i.12xlarge"
    ML_C7I_16XLARGE = "ml.c7i.16xlarge"
    ML_C7I_24XLARGE = "ml.c7i.24xlarge"
    ML_C7I_48XLARGE = "ml.c7i.48xlarge"
    ML_R7I_LARGE = "ml.r7i.large"
    ML_R7I_XLARGE = "ml.r7i.xlarge"
    ML_R7I_2XLARGE = "ml.r7i.2xlarge"
    ML_R7I_4XLARGE = "ml.r7i.4xlarge"
    ML_R7I_8XLARGE = "ml.r7i.8xlarge"
    ML_R7I_12XLARGE = "ml.r7i.12xlarge"
    ML_R7I_16XLARGE = "ml.r7i.16xlarge"
    ML_R7I_24XLARGE = "ml.r7i.24xlarge"
    ML_R7I_48XLARGE = "ml.r7i.48xlarge"
    ML_P6E_GB200_36XLARGE = "ml.p6e-gb200.36xlarge"
    ML_P5_4XLARGE = "ml.p5.4xlarge"
    ML_P6_B300_48XLARGE = "ml.p6-b300.48xlarge"


class TrainingJobEarlyStoppingType:
    """TrainingJobEarlyStoppingType enum values."""

    OFF = "Off"
    AUTO = "Auto"


class TrainingJobSortByOptions:
    """TrainingJobSortByOptions enum values."""

    NAME = "Name"
    CREATIONTIME = "CreationTime"
    STATUS = "Status"
    FINALOBJECTIVEMETRICVALUE = "FinalObjectiveMetricValue"


class TrainingJobStatus:
    """TrainingJobStatus enum values."""

    INPROGRESS = "InProgress"
    COMPLETED = "Completed"
    FAILED = "Failed"
    STOPPING = "Stopping"
    STOPPED = "Stopped"
    DELETING = "Deleting"


class TrainingPlanFilterName:
    """TrainingPlanFilterName enum values."""

    STATUS = "Status"


class TrainingPlanSortBy:
    """TrainingPlanSortBy enum values."""

    TRAININGPLANNAME = "TrainingPlanName"
    STARTTIME = "StartTime"
    STATUS = "Status"


class TrainingPlanSortOrder:
    """TrainingPlanSortOrder enum values."""

    ASCENDING = "Ascending"
    DESCENDING = "Descending"


class TrainingPlanStatus:
    """TrainingPlanStatus enum values."""

    PENDING = "Pending"
    ACTIVE = "Active"
    SCHEDULED = "Scheduled"
    EXPIRED = "Expired"
    FAILED = "Failed"


class TrainingRepositoryAccessMode:
    """TrainingRepositoryAccessMode enum values."""

    PLATFORM = "Platform"
    VPC = "Vpc"


class TransformInstanceType:
    """TransformInstanceType enum values."""

    ML_M4_XLARGE = "ml.m4.xlarge"
    ML_M4_2XLARGE = "ml.m4.2xlarge"
    ML_M4_4XLARGE = "ml.m4.4xlarge"
    ML_M4_10XLARGE = "ml.m4.10xlarge"
    ML_M4_16XLARGE = "ml.m4.16xlarge"
    ML_C4_XLARGE = "ml.c4.xlarge"
    ML_C4_2XLARGE = "ml.c4.2xlarge"
    ML_C4_4XLARGE = "ml.c4.4xlarge"
    ML_C4_8XLARGE = "ml.c4.8xlarge"
    ML_P2_XLARGE = "ml.p2.xlarge"
    ML_P2_8XLARGE = "ml.p2.8xlarge"
    ML_P2_16XLARGE = "ml.p2.16xlarge"
    ML_P3_2XLARGE = "ml.p3.2xlarge"
    ML_P3_8XLARGE = "ml.p3.8xlarge"
    ML_P3_16XLARGE = "ml.p3.16xlarge"
    ML_C5_XLARGE = "ml.c5.xlarge"
    ML_C5_2XLARGE = "ml.c5.2xlarge"
    ML_C5_4XLARGE = "ml.c5.4xlarge"
    ML_C5_9XLARGE = "ml.c5.9xlarge"
    ML_C5_18XLARGE = "ml.c5.18xlarge"
    ML_M5_LARGE = "ml.m5.large"
    ML_M5_XLARGE = "ml.m5.xlarge"
    ML_M5_2XLARGE = "ml.m5.2xlarge"
    ML_M5_4XLARGE = "ml.m5.4xlarge"
    ML_M5_12XLARGE = "ml.m5.12xlarge"
    ML_M5_24XLARGE = "ml.m5.24xlarge"
    ML_M6I_LARGE = "ml.m6i.large"
    ML_M6I_XLARGE = "ml.m6i.xlarge"
    ML_M6I_2XLARGE = "ml.m6i.2xlarge"
    ML_M6I_4XLARGE = "ml.m6i.4xlarge"
    ML_M6I_8XLARGE = "ml.m6i.8xlarge"
    ML_M6I_12XLARGE = "ml.m6i.12xlarge"
    ML_M6I_16XLARGE = "ml.m6i.16xlarge"
    ML_M6I_24XLARGE = "ml.m6i.24xlarge"
    ML_M6I_32XLARGE = "ml.m6i.32xlarge"
    ML_C6I_LARGE = "ml.c6i.large"
    ML_C6I_XLARGE = "ml.c6i.xlarge"
    ML_C6I_2XLARGE = "ml.c6i.2xlarge"
    ML_C6I_4XLARGE = "ml.c6i.4xlarge"
    ML_C6I_8XLARGE = "ml.c6i.8xlarge"
    ML_C6I_12XLARGE = "ml.c6i.12xlarge"
    ML_C6I_16XLARGE = "ml.c6i.16xlarge"
    ML_C6I_24XLARGE = "ml.c6i.24xlarge"
    ML_C6I_32XLARGE = "ml.c6i.32xlarge"
    ML_R6I_LARGE = "ml.r6i.large"
    ML_R6I_XLARGE = "ml.r6i.xlarge"
    ML_R6I_2XLARGE = "ml.r6i.2xlarge"
    ML_R6I_4XLARGE = "ml.r6i.4xlarge"
    ML_R6I_8XLARGE = "ml.r6i.8xlarge"
    ML_R6I_12XLARGE = "ml.r6i.12xlarge"
    ML_R6I_16XLARGE = "ml.r6i.16xlarge"
    ML_R6I_24XLARGE = "ml.r6i.24xlarge"
    ML_R6I_32XLARGE = "ml.r6i.32xlarge"
    ML_M7I_LARGE = "ml.m7i.large"
    ML_M7I_XLARGE = "ml.m7i.xlarge"
    ML_M7I_2XLARGE = "ml.m7i.2xlarge"
    ML_M7I_4XLARGE = "ml.m7i.4xlarge"
    ML_M7I_8XLARGE = "ml.m7i.8xlarge"
    ML_M7I_12XLARGE = "ml.m7i.12xlarge"
    ML_M7I_16XLARGE = "ml.m7i.16xlarge"
    ML_M7I_24XLARGE = "ml.m7i.24xlarge"
    ML_M7I_48XLARGE = "ml.m7i.48xlarge"
    ML_C7I_LARGE = "ml.c7i.large"
    ML_C7I_XLARGE = "ml.c7i.xlarge"
    ML_C7I_2XLARGE = "ml.c7i.2xlarge"
    ML_C7I_4XLARGE = "ml.c7i.4xlarge"
    ML_C7I_8XLARGE = "ml.c7i.8xlarge"
    ML_C7I_12XLARGE = "ml.c7i.12xlarge"
    ML_C7I_16XLARGE = "ml.c7i.16xlarge"
    ML_C7I_24XLARGE = "ml.c7i.24xlarge"
    ML_C7I_48XLARGE = "ml.c7i.48xlarge"
    ML_R7I_LARGE = "ml.r7i.large"
    ML_R7I_XLARGE = "ml.r7i.xlarge"
    ML_R7I_2XLARGE = "ml.r7i.2xlarge"
    ML_R7I_4XLARGE = "ml.r7i.4xlarge"
    ML_R7I_8XLARGE = "ml.r7i.8xlarge"
    ML_R7I_12XLARGE = "ml.r7i.12xlarge"
    ML_R7I_16XLARGE = "ml.r7i.16xlarge"
    ML_R7I_24XLARGE = "ml.r7i.24xlarge"
    ML_R7I_48XLARGE = "ml.r7i.48xlarge"
    ML_G4DN_XLARGE = "ml.g4dn.xlarge"
    ML_G4DN_2XLARGE = "ml.g4dn.2xlarge"
    ML_G4DN_4XLARGE = "ml.g4dn.4xlarge"
    ML_G4DN_8XLARGE = "ml.g4dn.8xlarge"
    ML_G4DN_12XLARGE = "ml.g4dn.12xlarge"
    ML_G4DN_16XLARGE = "ml.g4dn.16xlarge"
    ML_G5_XLARGE = "ml.g5.xlarge"
    ML_G5_2XLARGE = "ml.g5.2xlarge"
    ML_G5_4XLARGE = "ml.g5.4xlarge"
    ML_G5_8XLARGE = "ml.g5.8xlarge"
    ML_G5_12XLARGE = "ml.g5.12xlarge"
    ML_G5_16XLARGE = "ml.g5.16xlarge"
    ML_G5_24XLARGE = "ml.g5.24xlarge"
    ML_G5_48XLARGE = "ml.g5.48xlarge"
    ML_TRN1_2XLARGE = "ml.trn1.2xlarge"
    ML_TRN1_32XLARGE = "ml.trn1.32xlarge"
    ML_INF2_XLARGE = "ml.inf2.xlarge"
    ML_INF2_8XLARGE = "ml.inf2.8xlarge"
    ML_INF2_24XLARGE = "ml.inf2.24xlarge"
    ML_INF2_48XLARGE = "ml.inf2.48xlarge"
    ML_G6_XLARGE = "ml.g6.xlarge"
    ML_G6_2XLARGE = "ml.g6.2xlarge"
    ML_G6_4XLARGE = "ml.g6.4xlarge"
    ML_G6_8XLARGE = "ml.g6.8xlarge"
    ML_G6_12XLARGE = "ml.g6.12xlarge"
    ML_G6_16XLARGE = "ml.g6.16xlarge"
    ML_G6_24XLARGE = "ml.g6.24xlarge"
    ML_G6_48XLARGE = "ml.g6.48xlarge"


class TransformJobStatus:
    """TransformJobStatus enum values."""

    INPROGRESS = "InProgress"
    COMPLETED = "Completed"
    FAILED = "Failed"
    STOPPING = "Stopping"
    STOPPED = "Stopped"


class TrialComponentPrimaryStatus:
    """TrialComponentPrimaryStatus enum values."""

    INPROGRESS = "InProgress"
    COMPLETED = "Completed"
    FAILED = "Failed"
    STOPPING = "Stopping"
    STOPPED = "Stopped"


class TtlDurationUnit:
    """TtlDurationUnit enum values."""

    SECONDS = "Seconds"
    MINUTES = "Minutes"
    HOURS = "Hours"
    DAYS = "Days"
    WEEKS = "Weeks"


class UltraServerHealthStatus:
    """UltraServerHealthStatus enum values."""

    OK = "OK"
    IMPAIRED = "Impaired"
    INSUFFICIENT_DATA = "Insufficient-Data"


class UserProfileSortKey:
    """UserProfileSortKey enum values."""

    CREATIONTIME = "CreationTime"
    LASTMODIFIEDTIME = "LastModifiedTime"


class UserProfileStatus:
    """UserProfileStatus enum values."""

    DELETING = "Deleting"
    FAILED = "Failed"
    INSERVICE = "InService"
    PENDING = "Pending"
    UPDATING = "Updating"
    UPDATE_FAILED = "Update_Failed"
    DELETE_FAILED = "Delete_Failed"


class VariantPropertyType:
    """VariantPropertyType enum values."""

    DESIREDINSTANCECOUNT = "DesiredInstanceCount"
    DESIREDWEIGHT = "DesiredWeight"
    DATACAPTURECONFIG = "DataCaptureConfig"


class VariantStatus:
    """VariantStatus enum values."""

    CREATING = "Creating"
    UPDATING = "Updating"
    DELETING = "Deleting"
    ACTIVATINGTRAFFIC = "ActivatingTraffic"
    BAKING = "Baking"


class VendorGuidance:
    """VendorGuidance enum values."""

    NOT_PROVIDED = "NOT_PROVIDED"
    STABLE = "STABLE"
    TO_BE_ARCHIVED = "TO_BE_ARCHIVED"
    ARCHIVED = "ARCHIVED"


class VolumeAttachmentStatus:
    """VolumeAttachmentStatus enum values."""

    ATTACHING = "attaching"
    ATTACHED = "attached"
    DETACHING = "detaching"
    DETACHED = "detached"
    BUSY = "busy"


class WarmPoolResourceStatus:
    """WarmPoolResourceStatus enum values."""

    AVAILABLE = "Available"
    TERMINATED = "Terminated"
    REUSED = "Reused"
    INUSE = "InUse"


class WorkforceIpAddressType:
    """WorkforceIpAddressType enum values."""

    IPV4 = "ipv4"
    DUALSTACK = "dualstack"


class WorkforceStatus:
    """WorkforceStatus enum values."""

    INITIALIZING = "Initializing"
    UPDATING = "Updating"
    DELETING = "Deleting"
    FAILED = "Failed"
    ACTIVE = "Active"


# Convenient aliases for enum values
ENABLED = AccountDefaultStatus.ENABLED
DISABLED = AccountDefaultStatus.DISABLED
UNKNOWN = ActionStatus.UNKNOWN
INPROGRESS = ActionStatus.INPROGRESS
COMPLETED = ActionStatus.COMPLETED
FAILED = ActionStatus.FAILED
STOPPING = ActionStatus.STOPPING
STOPPED = ActionStatus.STOPPED
ENABLED = ActivationState.ENABLED
DISABLED = ActivationState.DISABLED
SCALING = ActiveClusterOperationName.SCALING
S3OBJECT = AdditionalS3DataSourceDataType.S3OBJECT
S3PREFIX = AdditionalS3DataSourceDataType.S3PREFIX
SUM = AggregationTransformationValue.SUM
AVG = AggregationTransformationValue.AVG
FIRST = AggregationTransformationValue.FIRST
MIN = AggregationTransformationValue.MIN
MAX = AggregationTransformationValue.MAX
NAME = AlgorithmSortBy.NAME
CREATIONTIME = AlgorithmSortBy.CREATIONTIME
PENDING = AlgorithmStatus.PENDING
INPROGRESS = AlgorithmStatus.INPROGRESS
COMPLETED = AlgorithmStatus.COMPLETED
FAILED = AlgorithmStatus.FAILED
DELETING = AlgorithmStatus.DELETING
CREATIONTIME = AppImageConfigSortKey.CREATIONTIME
LASTMODIFIEDTIME = AppImageConfigSortKey.LASTMODIFIEDTIME
NAME = AppImageConfigSortKey.NAME
SYSTEM = AppInstanceType.SYSTEM
ML_T3_MICRO = AppInstanceType.ML_T3_MICRO
ML_T3_SMALL = AppInstanceType.ML_T3_SMALL
ML_T3_MEDIUM = AppInstanceType.ML_T3_MEDIUM
ML_T3_LARGE = AppInstanceType.ML_T3_LARGE
ML_T3_XLARGE = AppInstanceType.ML_T3_XLARGE
ML_T3_2XLARGE = AppInstanceType.ML_T3_2XLARGE
ML_M5_LARGE = AppInstanceType.ML_M5_LARGE
ML_M5_XLARGE = AppInstanceType.ML_M5_XLARGE
ML_M5_2XLARGE = AppInstanceType.ML_M5_2XLARGE
ML_M5_4XLARGE = AppInstanceType.ML_M5_4XLARGE
ML_M5_8XLARGE = AppInstanceType.ML_M5_8XLARGE
ML_M5_12XLARGE = AppInstanceType.ML_M5_12XLARGE
ML_M5_16XLARGE = AppInstanceType.ML_M5_16XLARGE
ML_M5_24XLARGE = AppInstanceType.ML_M5_24XLARGE
ML_M5D_LARGE = AppInstanceType.ML_M5D_LARGE
ML_M5D_XLARGE = AppInstanceType.ML_M5D_XLARGE
ML_M5D_2XLARGE = AppInstanceType.ML_M5D_2XLARGE
ML_M5D_4XLARGE = AppInstanceType.ML_M5D_4XLARGE
ML_M5D_8XLARGE = AppInstanceType.ML_M5D_8XLARGE
ML_M5D_12XLARGE = AppInstanceType.ML_M5D_12XLARGE
ML_M5D_16XLARGE = AppInstanceType.ML_M5D_16XLARGE
ML_M5D_24XLARGE = AppInstanceType.ML_M5D_24XLARGE
ML_C5_LARGE = AppInstanceType.ML_C5_LARGE
ML_C5_XLARGE = AppInstanceType.ML_C5_XLARGE
ML_C5_2XLARGE = AppInstanceType.ML_C5_2XLARGE
ML_C5_4XLARGE = AppInstanceType.ML_C5_4XLARGE
ML_C5_9XLARGE = AppInstanceType.ML_C5_9XLARGE
ML_C5_12XLARGE = AppInstanceType.ML_C5_12XLARGE
ML_C5_18XLARGE = AppInstanceType.ML_C5_18XLARGE
ML_C5_24XLARGE = AppInstanceType.ML_C5_24XLARGE
ML_P3_2XLARGE = AppInstanceType.ML_P3_2XLARGE
ML_P3_8XLARGE = AppInstanceType.ML_P3_8XLARGE
ML_P3_16XLARGE = AppInstanceType.ML_P3_16XLARGE
ML_P3DN_24XLARGE = AppInstanceType.ML_P3DN_24XLARGE
ML_G4DN_XLARGE = AppInstanceType.ML_G4DN_XLARGE
ML_G4DN_2XLARGE = AppInstanceType.ML_G4DN_2XLARGE
ML_G4DN_4XLARGE = AppInstanceType.ML_G4DN_4XLARGE
ML_G4DN_8XLARGE = AppInstanceType.ML_G4DN_8XLARGE
ML_G4DN_12XLARGE = AppInstanceType.ML_G4DN_12XLARGE
ML_G4DN_16XLARGE = AppInstanceType.ML_G4DN_16XLARGE
ML_R5_LARGE = AppInstanceType.ML_R5_LARGE
ML_R5_XLARGE = AppInstanceType.ML_R5_XLARGE
ML_R5_2XLARGE = AppInstanceType.ML_R5_2XLARGE
ML_R5_4XLARGE = AppInstanceType.ML_R5_4XLARGE
ML_R5_8XLARGE = AppInstanceType.ML_R5_8XLARGE
ML_R5_12XLARGE = AppInstanceType.ML_R5_12XLARGE
ML_R5_16XLARGE = AppInstanceType.ML_R5_16XLARGE
ML_R5_24XLARGE = AppInstanceType.ML_R5_24XLARGE
ML_G5_XLARGE = AppInstanceType.ML_G5_XLARGE
ML_G5_2XLARGE = AppInstanceType.ML_G5_2XLARGE
ML_G5_4XLARGE = AppInstanceType.ML_G5_4XLARGE
ML_G5_8XLARGE = AppInstanceType.ML_G5_8XLARGE
ML_G5_16XLARGE = AppInstanceType.ML_G5_16XLARGE
ML_G5_12XLARGE = AppInstanceType.ML_G5_12XLARGE
ML_G5_24XLARGE = AppInstanceType.ML_G5_24XLARGE
ML_G5_48XLARGE = AppInstanceType.ML_G5_48XLARGE
ML_G6_XLARGE = AppInstanceType.ML_G6_XLARGE
ML_G6_2XLARGE = AppInstanceType.ML_G6_2XLARGE
ML_G6_4XLARGE = AppInstanceType.ML_G6_4XLARGE
ML_G6_8XLARGE = AppInstanceType.ML_G6_8XLARGE
ML_G6_12XLARGE = AppInstanceType.ML_G6_12XLARGE
ML_G6_16XLARGE = AppInstanceType.ML_G6_16XLARGE
ML_G6_24XLARGE = AppInstanceType.ML_G6_24XLARGE
ML_G6_48XLARGE = AppInstanceType.ML_G6_48XLARGE
ML_G6E_XLARGE = AppInstanceType.ML_G6E_XLARGE
ML_G6E_2XLARGE = AppInstanceType.ML_G6E_2XLARGE
ML_G6E_4XLARGE = AppInstanceType.ML_G6E_4XLARGE
ML_G6E_8XLARGE = AppInstanceType.ML_G6E_8XLARGE
ML_G6E_12XLARGE = AppInstanceType.ML_G6E_12XLARGE
ML_G6E_16XLARGE = AppInstanceType.ML_G6E_16XLARGE
ML_G6E_24XLARGE = AppInstanceType.ML_G6E_24XLARGE
ML_G6E_48XLARGE = AppInstanceType.ML_G6E_48XLARGE
ML_GEOSPATIAL_INTERACTIVE = AppInstanceType.ML_GEOSPATIAL_INTERACTIVE
ML_P4D_24XLARGE = AppInstanceType.ML_P4D_24XLARGE
ML_P4DE_24XLARGE = AppInstanceType.ML_P4DE_24XLARGE
ML_TRN1_2XLARGE = AppInstanceType.ML_TRN1_2XLARGE
ML_TRN1_32XLARGE = AppInstanceType.ML_TRN1_32XLARGE
ML_TRN1N_32XLARGE = AppInstanceType.ML_TRN1N_32XLARGE
ML_P5_48XLARGE = AppInstanceType.ML_P5_48XLARGE
ML_P5EN_48XLARGE = AppInstanceType.ML_P5EN_48XLARGE
ML_P6_B200_48XLARGE = AppInstanceType.ML_P6_B200_48XLARGE
ML_M6I_LARGE = AppInstanceType.ML_M6I_LARGE
ML_M6I_XLARGE = AppInstanceType.ML_M6I_XLARGE
ML_M6I_2XLARGE = AppInstanceType.ML_M6I_2XLARGE
ML_M6I_4XLARGE = AppInstanceType.ML_M6I_4XLARGE
ML_M6I_8XLARGE = AppInstanceType.ML_M6I_8XLARGE
ML_M6I_12XLARGE = AppInstanceType.ML_M6I_12XLARGE
ML_M6I_16XLARGE = AppInstanceType.ML_M6I_16XLARGE
ML_M6I_24XLARGE = AppInstanceType.ML_M6I_24XLARGE
ML_M6I_32XLARGE = AppInstanceType.ML_M6I_32XLARGE
ML_M7I_LARGE = AppInstanceType.ML_M7I_LARGE
ML_M7I_XLARGE = AppInstanceType.ML_M7I_XLARGE
ML_M7I_2XLARGE = AppInstanceType.ML_M7I_2XLARGE
ML_M7I_4XLARGE = AppInstanceType.ML_M7I_4XLARGE
ML_M7I_8XLARGE = AppInstanceType.ML_M7I_8XLARGE
ML_M7I_12XLARGE = AppInstanceType.ML_M7I_12XLARGE
ML_M7I_16XLARGE = AppInstanceType.ML_M7I_16XLARGE
ML_M7I_24XLARGE = AppInstanceType.ML_M7I_24XLARGE
ML_M7I_48XLARGE = AppInstanceType.ML_M7I_48XLARGE
ML_C6I_LARGE = AppInstanceType.ML_C6I_LARGE
ML_C6I_XLARGE = AppInstanceType.ML_C6I_XLARGE
ML_C6I_2XLARGE = AppInstanceType.ML_C6I_2XLARGE
ML_C6I_4XLARGE = AppInstanceType.ML_C6I_4XLARGE
ML_C6I_8XLARGE = AppInstanceType.ML_C6I_8XLARGE
ML_C6I_12XLARGE = AppInstanceType.ML_C6I_12XLARGE
ML_C6I_16XLARGE = AppInstanceType.ML_C6I_16XLARGE
ML_C6I_24XLARGE = AppInstanceType.ML_C6I_24XLARGE
ML_C6I_32XLARGE = AppInstanceType.ML_C6I_32XLARGE
ML_C7I_LARGE = AppInstanceType.ML_C7I_LARGE
ML_C7I_XLARGE = AppInstanceType.ML_C7I_XLARGE
ML_C7I_2XLARGE = AppInstanceType.ML_C7I_2XLARGE
ML_C7I_4XLARGE = AppInstanceType.ML_C7I_4XLARGE
ML_C7I_8XLARGE = AppInstanceType.ML_C7I_8XLARGE
ML_C7I_12XLARGE = AppInstanceType.ML_C7I_12XLARGE
ML_C7I_16XLARGE = AppInstanceType.ML_C7I_16XLARGE
ML_C7I_24XLARGE = AppInstanceType.ML_C7I_24XLARGE
ML_C7I_48XLARGE = AppInstanceType.ML_C7I_48XLARGE
ML_R6I_LARGE = AppInstanceType.ML_R6I_LARGE
ML_R6I_XLARGE = AppInstanceType.ML_R6I_XLARGE
ML_R6I_2XLARGE = AppInstanceType.ML_R6I_2XLARGE
ML_R6I_4XLARGE = AppInstanceType.ML_R6I_4XLARGE
ML_R6I_8XLARGE = AppInstanceType.ML_R6I_8XLARGE
ML_R6I_12XLARGE = AppInstanceType.ML_R6I_12XLARGE
ML_R6I_16XLARGE = AppInstanceType.ML_R6I_16XLARGE
ML_R6I_24XLARGE = AppInstanceType.ML_R6I_24XLARGE
ML_R6I_32XLARGE = AppInstanceType.ML_R6I_32XLARGE
ML_R7I_LARGE = AppInstanceType.ML_R7I_LARGE
ML_R7I_XLARGE = AppInstanceType.ML_R7I_XLARGE
ML_R7I_2XLARGE = AppInstanceType.ML_R7I_2XLARGE
ML_R7I_4XLARGE = AppInstanceType.ML_R7I_4XLARGE
ML_R7I_8XLARGE = AppInstanceType.ML_R7I_8XLARGE
ML_R7I_12XLARGE = AppInstanceType.ML_R7I_12XLARGE
ML_R7I_16XLARGE = AppInstanceType.ML_R7I_16XLARGE
ML_R7I_24XLARGE = AppInstanceType.ML_R7I_24XLARGE
ML_R7I_48XLARGE = AppInstanceType.ML_R7I_48XLARGE
ML_M6ID_LARGE = AppInstanceType.ML_M6ID_LARGE
ML_M6ID_XLARGE = AppInstanceType.ML_M6ID_XLARGE
ML_M6ID_2XLARGE = AppInstanceType.ML_M6ID_2XLARGE
ML_M6ID_4XLARGE = AppInstanceType.ML_M6ID_4XLARGE
ML_M6ID_8XLARGE = AppInstanceType.ML_M6ID_8XLARGE
ML_M6ID_12XLARGE = AppInstanceType.ML_M6ID_12XLARGE
ML_M6ID_16XLARGE = AppInstanceType.ML_M6ID_16XLARGE
ML_M6ID_24XLARGE = AppInstanceType.ML_M6ID_24XLARGE
ML_M6ID_32XLARGE = AppInstanceType.ML_M6ID_32XLARGE
ML_C6ID_LARGE = AppInstanceType.ML_C6ID_LARGE
ML_C6ID_XLARGE = AppInstanceType.ML_C6ID_XLARGE
ML_C6ID_2XLARGE = AppInstanceType.ML_C6ID_2XLARGE
ML_C6ID_4XLARGE = AppInstanceType.ML_C6ID_4XLARGE
ML_C6ID_8XLARGE = AppInstanceType.ML_C6ID_8XLARGE
ML_C6ID_12XLARGE = AppInstanceType.ML_C6ID_12XLARGE
ML_C6ID_16XLARGE = AppInstanceType.ML_C6ID_16XLARGE
ML_C6ID_24XLARGE = AppInstanceType.ML_C6ID_24XLARGE
ML_C6ID_32XLARGE = AppInstanceType.ML_C6ID_32XLARGE
ML_R6ID_LARGE = AppInstanceType.ML_R6ID_LARGE
ML_R6ID_XLARGE = AppInstanceType.ML_R6ID_XLARGE
ML_R6ID_2XLARGE = AppInstanceType.ML_R6ID_2XLARGE
ML_R6ID_4XLARGE = AppInstanceType.ML_R6ID_4XLARGE
ML_R6ID_8XLARGE = AppInstanceType.ML_R6ID_8XLARGE
ML_R6ID_12XLARGE = AppInstanceType.ML_R6ID_12XLARGE
ML_R6ID_16XLARGE = AppInstanceType.ML_R6ID_16XLARGE
ML_R6ID_24XLARGE = AppInstanceType.ML_R6ID_24XLARGE
ML_R6ID_32XLARGE = AppInstanceType.ML_R6ID_32XLARGE
PUBLICINTERNETONLY = AppNetworkAccessType.PUBLICINTERNETONLY
VPCONLY = AppNetworkAccessType.VPCONLY
SERVICE = AppSecurityGroupManagement.SERVICE
CUSTOMER = AppSecurityGroupManagement.CUSTOMER
CREATIONTIME = AppSortKey.CREATIONTIME
DELETED = AppStatus.DELETED
DELETING = AppStatus.DELETING
FAILED = AppStatus.FAILED
INSERVICE = AppStatus.INSERVICE
PENDING = AppStatus.PENDING
JUPYTERSERVER = AppType.JUPYTERSERVER
KERNELGATEWAY = AppType.KERNELGATEWAY
DETAILEDPROFILER = AppType.DETAILEDPROFILER
TENSORBOARD = AppType.TENSORBOARD
CODEEDITOR = AppType.CODEEDITOR
JUPYTERLAB = AppType.JUPYTERLAB
RSTUDIOSERVERPRO = AppType.RSTUDIOSERVERPRO
RSESSIONGATEWAY = AppType.RSESSIONGATEWAY
CANVAS = AppType.CANVAS
MD5HASH = ArtifactSourceIdType.MD5HASH
S3ETAG = ArtifactSourceIdType.S3ETAG
S3VERSION = ArtifactSourceIdType.S3VERSION
CUSTOM = ArtifactSourceIdType.CUSTOM
NONE = AssemblyType.NONE
LINE = AssemblyType.LINE
CONTRIBUTEDTO = AssociationEdgeType.CONTRIBUTEDTO
ASSOCIATEDWITH = AssociationEdgeType.ASSOCIATEDWITH
DERIVEDFROM = AssociationEdgeType.DERIVEDFROM
PRODUCED = AssociationEdgeType.PRODUCED
SAMEAS = AssociationEdgeType.SAMEAS
SUCCESS_NOTIFICATION_TOPIC = AsyncNotificationTopicTypes.SUCCESS_NOTIFICATION_TOPIC
ERROR_NOTIFICATION_TOPIC = AsyncNotificationTopicTypes.ERROR_NOTIFICATION_TOPIC
GZIP = AthenaResultCompressionType.GZIP
SNAPPY = AthenaResultCompressionType.SNAPPY
ZLIB = AthenaResultCompressionType.ZLIB
PARQUET = AthenaResultFormat.PARQUET
ORC = AthenaResultFormat.ORC
AVRO = AthenaResultFormat.AVRO
JSON = AthenaResultFormat.JSON
TEXTFILE = AthenaResultFormat.TEXTFILE
SSO = AuthMode.SSO
IAM = AuthMode.IAM
XGBOOST = AutoMLAlgorithm.XGBOOST
LINEAR_LEARNER = AutoMLAlgorithm.LINEAR_LEARNER
MLP = AutoMLAlgorithm.MLP
LIGHTGBM = AutoMLAlgorithm.LIGHTGBM
CATBOOST = AutoMLAlgorithm.CATBOOST
RANDOMFOREST = AutoMLAlgorithm.RANDOMFOREST
EXTRA_TREES = AutoMLAlgorithm.EXTRA_TREES
NN_TORCH = AutoMLAlgorithm.NN_TORCH
FASTAI = AutoMLAlgorithm.FASTAI
CNN_QR = AutoMLAlgorithm.CNN_QR
DEEPAR = AutoMLAlgorithm.DEEPAR
PROPHET = AutoMLAlgorithm.PROPHET
NPTS = AutoMLAlgorithm.NPTS
ARIMA = AutoMLAlgorithm.ARIMA
ETS = AutoMLAlgorithm.ETS
TRAINING = AutoMLChannelType.TRAINING
VALIDATION = AutoMLChannelType.VALIDATION
MAXIMIZE = AutoMLJobObjectiveType.MAXIMIZE
MINIMIZE = AutoMLJobObjectiveType.MINIMIZE
STARTING = AutoMLJobSecondaryStatus.STARTING
MAXCANDIDATESREACHED = AutoMLJobSecondaryStatus.MAXCANDIDATESREACHED
FAILED = AutoMLJobSecondaryStatus.FAILED
STOPPED = AutoMLJobSecondaryStatus.STOPPED
MAXAUTOMLJOBRUNTIMEREACHED = AutoMLJobSecondaryStatus.MAXAUTOMLJOBRUNTIMEREACHED
STOPPING = AutoMLJobSecondaryStatus.STOPPING
CANDIDATEDEFINITIONSGENERATED = AutoMLJobSecondaryStatus.CANDIDATEDEFINITIONSGENERATED
COMPLETED = AutoMLJobSecondaryStatus.COMPLETED
EXPLAINABILITYERROR = AutoMLJobSecondaryStatus.EXPLAINABILITYERROR
DEPLOYINGMODEL = AutoMLJobSecondaryStatus.DEPLOYINGMODEL
MODELDEPLOYMENTERROR = AutoMLJobSecondaryStatus.MODELDEPLOYMENTERROR
GENERATINGMODELINSIGHTSREPORT = AutoMLJobSecondaryStatus.GENERATINGMODELINSIGHTSREPORT
MODELINSIGHTSERROR = AutoMLJobSecondaryStatus.MODELINSIGHTSERROR
ANALYZINGDATA = AutoMLJobSecondaryStatus.ANALYZINGDATA
FEATUREENGINEERING = AutoMLJobSecondaryStatus.FEATUREENGINEERING
MODELTUNING = AutoMLJobSecondaryStatus.MODELTUNING
GENERATINGEXPLAINABILITYREPORT = AutoMLJobSecondaryStatus.GENERATINGEXPLAINABILITYREPORT
TRAININGMODELS = AutoMLJobSecondaryStatus.TRAININGMODELS
PRETRAINING = AutoMLJobSecondaryStatus.PRETRAINING
COMPLETED = AutoMLJobStatus.COMPLETED
INPROGRESS = AutoMLJobStatus.INPROGRESS
FAILED = AutoMLJobStatus.FAILED
STOPPED = AutoMLJobStatus.STOPPED
STOPPING = AutoMLJobStatus.STOPPING
ACCURACY = AutoMLMetricEnum.ACCURACY
MSE = AutoMLMetricEnum.MSE
F1 = AutoMLMetricEnum.F1
F1MACRO = AutoMLMetricEnum.F1MACRO
AUC = AutoMLMetricEnum.AUC
RMSE = AutoMLMetricEnum.RMSE
BALANCEDACCURACY = AutoMLMetricEnum.BALANCEDACCURACY
R2 = AutoMLMetricEnum.R2
RECALL = AutoMLMetricEnum.RECALL
RECALLMACRO = AutoMLMetricEnum.RECALLMACRO
PRECISION = AutoMLMetricEnum.PRECISION
PRECISIONMACRO = AutoMLMetricEnum.PRECISIONMACRO
MAE = AutoMLMetricEnum.MAE
MAPE = AutoMLMetricEnum.MAPE
MASE = AutoMLMetricEnum.MASE
WAPE = AutoMLMetricEnum.WAPE
AVERAGEWEIGHTEDQUANTILELOSS = AutoMLMetricEnum.AVERAGEWEIGHTEDQUANTILELOSS
ACCURACY = AutoMLMetricExtendedEnum.ACCURACY
MSE = AutoMLMetricExtendedEnum.MSE
F1 = AutoMLMetricExtendedEnum.F1
F1MACRO = AutoMLMetricExtendedEnum.F1MACRO
AUC = AutoMLMetricExtendedEnum.AUC
RMSE = AutoMLMetricExtendedEnum.RMSE
MAE = AutoMLMetricExtendedEnum.MAE
R2 = AutoMLMetricExtendedEnum.R2
BALANCEDACCURACY = AutoMLMetricExtendedEnum.BALANCEDACCURACY
PRECISION = AutoMLMetricExtendedEnum.PRECISION
PRECISIONMACRO = AutoMLMetricExtendedEnum.PRECISIONMACRO
RECALL = AutoMLMetricExtendedEnum.RECALL
RECALLMACRO = AutoMLMetricExtendedEnum.RECALLMACRO
LOGLOSS = AutoMLMetricExtendedEnum.LOGLOSS
INFERENCELATENCY = AutoMLMetricExtendedEnum.INFERENCELATENCY
MAPE = AutoMLMetricExtendedEnum.MAPE
MASE = AutoMLMetricExtendedEnum.MASE
WAPE = AutoMLMetricExtendedEnum.WAPE
AVERAGEWEIGHTEDQUANTILELOSS = AutoMLMetricExtendedEnum.AVERAGEWEIGHTEDQUANTILELOSS
ROUGE1 = AutoMLMetricExtendedEnum.ROUGE1
ROUGE2 = AutoMLMetricExtendedEnum.ROUGE2
ROUGEL = AutoMLMetricExtendedEnum.ROUGEL
ROUGELSUM = AutoMLMetricExtendedEnum.ROUGELSUM
PERPLEXITY = AutoMLMetricExtendedEnum.PERPLEXITY
VALIDATIONLOSS = AutoMLMetricExtendedEnum.VALIDATIONLOSS
TRAININGLOSS = AutoMLMetricExtendedEnum.TRAININGLOSS
AUTO = AutoMLMode.AUTO
ENSEMBLING = AutoMLMode.ENSEMBLING
HYPERPARAMETER_TUNING = AutoMLMode.HYPERPARAMETER_TUNING
IMAGECLASSIFICATION = AutoMLProblemTypeConfigName.IMAGECLASSIFICATION
TEXTCLASSIFICATION = AutoMLProblemTypeConfigName.TEXTCLASSIFICATION
TIMESERIESFORECASTING = AutoMLProblemTypeConfigName.TIMESERIESFORECASTING
TABULAR = AutoMLProblemTypeConfigName.TABULAR
TEXTGENERATION = AutoMLProblemTypeConfigName.TEXTGENERATION
CPU = AutoMLProcessingUnit.CPU
GPU = AutoMLProcessingUnit.GPU
MANIFESTFILE = AutoMLS3DataType.MANIFESTFILE
S3PREFIX = AutoMLS3DataType.S3PREFIX
AUGMENTEDMANIFESTFILE = AutoMLS3DataType.AUGMENTEDMANIFESTFILE
NAME = AutoMLSortBy.NAME
CREATIONTIME = AutoMLSortBy.CREATIONTIME
STATUS = AutoMLSortBy.STATUS
ASCENDING = AutoMLSortOrder.ASCENDING
DESCENDING = AutoMLSortOrder.DESCENDING
ENABLED = AutoMountHomeEFS.ENABLED
DISABLED = AutoMountHomeEFS.DISABLED
DEFAULTASDOMAIN = AutoMountHomeEFS.DEFAULTASDOMAIN
ENABLED = AutotuneMode.ENABLED
AWS_REKOGNITION_DETECTMODERATIONLABELS_IMAGE_V3 = AwsManagedHumanLoopRequestSource.AWS_REKOGNITION_DETECTMODERATIONLABELS_IMAGE_V3
AWS_TEXTRACT_ANALYZEDOCUMENT_FORMS_V1 = AwsManagedHumanLoopRequestSource.AWS_TEXTRACT_ANALYZEDOCUMENT_FORMS_V1
INSTANCEGROUPNOTFOUND = BatchAddClusterNodesErrorCode.INSTANCEGROUPNOTFOUND
INVALIDINSTANCEGROUPSTATUS = BatchAddClusterNodesErrorCode.INVALIDINSTANCEGROUPSTATUS
NODEIDNOTFOUND = BatchDeleteClusterNodesErrorCode.NODEIDNOTFOUND
INVALIDNODESTATUS = BatchDeleteClusterNodesErrorCode.INVALIDNODESTATUS
NODEIDINUSE = BatchDeleteClusterNodesErrorCode.NODEIDINUSE
INSTANCEIDNOTFOUND = BatchRebootClusterNodesErrorCode.INSTANCEIDNOTFOUND
INVALIDINSTANCESTATUS = BatchRebootClusterNodesErrorCode.INVALIDINSTANCESTATUS
INSTANCEIDINUSE = BatchRebootClusterNodesErrorCode.INSTANCEIDINUSE
INTERNALSERVERERROR = BatchRebootClusterNodesErrorCode.INTERNALSERVERERROR
INSTANCEIDNOTFOUND = BatchReplaceClusterNodesErrorCode.INSTANCEIDNOTFOUND
INVALIDINSTANCESTATUS = BatchReplaceClusterNodesErrorCode.INVALIDINSTANCESTATUS
INSTANCEIDINUSE = BatchReplaceClusterNodesErrorCode.INSTANCEIDINUSE
INTERNALSERVERERROR = BatchReplaceClusterNodesErrorCode.INTERNALSERVERERROR
MULTIRECORD = BatchStrategy.MULTIRECORD
SINGLERECORD = BatchStrategy.SINGLERECORD
AND = BooleanOperator.AND
OR = BooleanOperator.OR
CREATIONTIME = CandidateSortBy.CREATIONTIME
STATUS = CandidateSortBy.STATUS
FINALOBJECTIVEMETRICVALUE = CandidateSortBy.FINALOBJECTIVEMETRICVALUE
COMPLETED = CandidateStatus.COMPLETED
INPROGRESS = CandidateStatus.INPROGRESS
FAILED = CandidateStatus.FAILED
STOPPED = CandidateStatus.STOPPED
STOPPING = CandidateStatus.STOPPING
AWS_SAGEMAKER_TRAININGJOB = CandidateStepType.AWS_SAGEMAKER_TRAININGJOB
AWS_SAGEMAKER_TRANSFORMJOB = CandidateStepType.AWS_SAGEMAKER_TRANSFORMJOB
AWS_SAGEMAKER_PROCESSINGJOB = CandidateStepType.AWS_SAGEMAKER_PROCESSINGJOB
CAPACITY_RESERVATIONS_ONLY = CapacityReservationPreference.CAPACITY_RESERVATIONS_ONLY
ODCR = CapacityReservationType.ODCR
CRG = CapacityReservationType.CRG
INSTANCE_COUNT = CapacitySizeType.INSTANCE_COUNT
CAPACITY_PERCENT = CapacitySizeType.CAPACITY_PERCENT
INPUT = CaptureMode.INPUT
OUTPUT = CaptureMode.OUTPUT
INPUTANDOUTPUT = CaptureMode.INPUTANDOUTPUT
STARTED = CaptureStatus.STARTED
STOPPED = CaptureStatus.STOPPED
NUMERICAL = ClarifyFeatureType.NUMERICAL
CATEGORICAL = ClarifyFeatureType.CATEGORICAL
TEXT = ClarifyFeatureType.TEXT
TOKEN = ClarifyTextGranularity.TOKEN
SENTENCE = ClarifyTextGranularity.SENTENCE
PARAGRAPH = ClarifyTextGranularity.PARAGRAPH
AF = ClarifyTextLanguage.AF
SQ = ClarifyTextLanguage.SQ
AR = ClarifyTextLanguage.AR
HY = ClarifyTextLanguage.HY
EU = ClarifyTextLanguage.EU
BN = ClarifyTextLanguage.BN
BG = ClarifyTextLanguage.BG
CA = ClarifyTextLanguage.CA
ZH = ClarifyTextLanguage.ZH
HR = ClarifyTextLanguage.HR
CS = ClarifyTextLanguage.CS
DA = ClarifyTextLanguage.DA
NL = ClarifyTextLanguage.NL
EN = ClarifyTextLanguage.EN
ET = ClarifyTextLanguage.ET
FI = ClarifyTextLanguage.FI
FR = ClarifyTextLanguage.FR
DE = ClarifyTextLanguage.DE
EL = ClarifyTextLanguage.EL
GU = ClarifyTextLanguage.GU
HE = ClarifyTextLanguage.HE
HI = ClarifyTextLanguage.HI
HU = ClarifyTextLanguage.HU
IS = ClarifyTextLanguage.IS
ID = ClarifyTextLanguage.ID
GA = ClarifyTextLanguage.GA
IT = ClarifyTextLanguage.IT
KN = ClarifyTextLanguage.KN
KY = ClarifyTextLanguage.KY
LV = ClarifyTextLanguage.LV
LT = ClarifyTextLanguage.LT
LB = ClarifyTextLanguage.LB
MK = ClarifyTextLanguage.MK
ML = ClarifyTextLanguage.ML
MR = ClarifyTextLanguage.MR
NE = ClarifyTextLanguage.NE
NB = ClarifyTextLanguage.NB
FA = ClarifyTextLanguage.FA
PL = ClarifyTextLanguage.PL
PT = ClarifyTextLanguage.PT
RO = ClarifyTextLanguage.RO
RU = ClarifyTextLanguage.RU
SA = ClarifyTextLanguage.SA
SR = ClarifyTextLanguage.SR
TN = ClarifyTextLanguage.TN
SI = ClarifyTextLanguage.SI
SK = ClarifyTextLanguage.SK
SL = ClarifyTextLanguage.SL
ES = ClarifyTextLanguage.ES
SV = ClarifyTextLanguage.SV
TL = ClarifyTextLanguage.TL
TA = ClarifyTextLanguage.TA
TT = ClarifyTextLanguage.TT
TE = ClarifyTextLanguage.TE
TR = ClarifyTextLanguage.TR
UK = ClarifyTextLanguage.UK
UR = ClarifyTextLanguage.UR
YO = ClarifyTextLanguage.YO
LIJ = ClarifyTextLanguage.LIJ
XX = ClarifyTextLanguage.XX
KARPENTER = ClusterAutoScalerType.KARPENTER
ENABLE = ClusterAutoScalingMode.ENABLE
DISABLE = ClusterAutoScalingMode.DISABLE
INSERVICE = ClusterAutoScalingStatus.INSERVICE
FAILED = ClusterAutoScalingStatus.FAILED
CREATING = ClusterAutoScalingStatus.CREATING
DELETING = ClusterAutoScalingStatus.DELETING
SPOT = ClusterCapacityType.SPOT
ONDEMAND = ClusterCapacityType.ONDEMAND
ENABLE = ClusterConfigMode.ENABLE
DISABLE = ClusterConfigMode.DISABLE
CLUSTER = ClusterEventResourceType.CLUSTER
INSTANCEGROUP = ClusterEventResourceType.INSTANCEGROUP
INSTANCE = ClusterEventResourceType.INSTANCE
RUNNING = ClusterInstanceStatus.RUNNING
FAILURE = ClusterInstanceStatus.FAILURE
PENDING = ClusterInstanceStatus.PENDING
SHUTTINGDOWN = ClusterInstanceStatus.SHUTTINGDOWN
SYSTEMUPDATING = ClusterInstanceStatus.SYSTEMUPDATING
DEEPHEALTHCHECKINPROGRESS = ClusterInstanceStatus.DEEPHEALTHCHECKINPROGRESS
NOTFOUND = ClusterInstanceStatus.NOTFOUND
ML_P4D_24XLARGE = ClusterInstanceType.ML_P4D_24XLARGE
ML_P4DE_24XLARGE = ClusterInstanceType.ML_P4DE_24XLARGE
ML_P5_48XLARGE = ClusterInstanceType.ML_P5_48XLARGE
ML_P5_4XLARGE = ClusterInstanceType.ML_P5_4XLARGE
ML_P6E_GB200_36XLARGE = ClusterInstanceType.ML_P6E_GB200_36XLARGE
ML_TRN1_32XLARGE = ClusterInstanceType.ML_TRN1_32XLARGE
ML_TRN1N_32XLARGE = ClusterInstanceType.ML_TRN1N_32XLARGE
ML_G5_XLARGE = ClusterInstanceType.ML_G5_XLARGE
ML_G5_2XLARGE = ClusterInstanceType.ML_G5_2XLARGE
ML_G5_4XLARGE = ClusterInstanceType.ML_G5_4XLARGE
ML_G5_8XLARGE = ClusterInstanceType.ML_G5_8XLARGE
ML_G5_12XLARGE = ClusterInstanceType.ML_G5_12XLARGE
ML_G5_16XLARGE = ClusterInstanceType.ML_G5_16XLARGE
ML_G5_24XLARGE = ClusterInstanceType.ML_G5_24XLARGE
ML_G5_48XLARGE = ClusterInstanceType.ML_G5_48XLARGE
ML_C5_LARGE = ClusterInstanceType.ML_C5_LARGE
ML_C5_XLARGE = ClusterInstanceType.ML_C5_XLARGE
ML_C5_2XLARGE = ClusterInstanceType.ML_C5_2XLARGE
ML_C5_4XLARGE = ClusterInstanceType.ML_C5_4XLARGE
ML_C5_9XLARGE = ClusterInstanceType.ML_C5_9XLARGE
ML_C5_12XLARGE = ClusterInstanceType.ML_C5_12XLARGE
ML_C5_18XLARGE = ClusterInstanceType.ML_C5_18XLARGE
ML_C5_24XLARGE = ClusterInstanceType.ML_C5_24XLARGE
ML_C5N_LARGE = ClusterInstanceType.ML_C5N_LARGE
ML_C5N_2XLARGE = ClusterInstanceType.ML_C5N_2XLARGE
ML_C5N_4XLARGE = ClusterInstanceType.ML_C5N_4XLARGE
ML_C5N_9XLARGE = ClusterInstanceType.ML_C5N_9XLARGE
ML_C5N_18XLARGE = ClusterInstanceType.ML_C5N_18XLARGE
ML_M5_LARGE = ClusterInstanceType.ML_M5_LARGE
ML_M5_XLARGE = ClusterInstanceType.ML_M5_XLARGE
ML_M5_2XLARGE = ClusterInstanceType.ML_M5_2XLARGE
ML_M5_4XLARGE = ClusterInstanceType.ML_M5_4XLARGE
ML_M5_8XLARGE = ClusterInstanceType.ML_M5_8XLARGE
ML_M5_12XLARGE = ClusterInstanceType.ML_M5_12XLARGE
ML_M5_16XLARGE = ClusterInstanceType.ML_M5_16XLARGE
ML_M5_24XLARGE = ClusterInstanceType.ML_M5_24XLARGE
ML_T3_MEDIUM = ClusterInstanceType.ML_T3_MEDIUM
ML_T3_LARGE = ClusterInstanceType.ML_T3_LARGE
ML_T3_XLARGE = ClusterInstanceType.ML_T3_XLARGE
ML_T3_2XLARGE = ClusterInstanceType.ML_T3_2XLARGE
ML_G6_XLARGE = ClusterInstanceType.ML_G6_XLARGE
ML_G6_2XLARGE = ClusterInstanceType.ML_G6_2XLARGE
ML_G6_4XLARGE = ClusterInstanceType.ML_G6_4XLARGE
ML_G6_8XLARGE = ClusterInstanceType.ML_G6_8XLARGE
ML_G6_16XLARGE = ClusterInstanceType.ML_G6_16XLARGE
ML_G6_12XLARGE = ClusterInstanceType.ML_G6_12XLARGE
ML_G6_24XLARGE = ClusterInstanceType.ML_G6_24XLARGE
ML_G6_48XLARGE = ClusterInstanceType.ML_G6_48XLARGE
ML_GR6_4XLARGE = ClusterInstanceType.ML_GR6_4XLARGE
ML_GR6_8XLARGE = ClusterInstanceType.ML_GR6_8XLARGE
ML_G6E_XLARGE = ClusterInstanceType.ML_G6E_XLARGE
ML_G6E_2XLARGE = ClusterInstanceType.ML_G6E_2XLARGE
ML_G6E_4XLARGE = ClusterInstanceType.ML_G6E_4XLARGE
ML_G6E_8XLARGE = ClusterInstanceType.ML_G6E_8XLARGE
ML_G6E_16XLARGE = ClusterInstanceType.ML_G6E_16XLARGE
ML_G6E_12XLARGE = ClusterInstanceType.ML_G6E_12XLARGE
ML_G6E_24XLARGE = ClusterInstanceType.ML_G6E_24XLARGE
ML_G6E_48XLARGE = ClusterInstanceType.ML_G6E_48XLARGE
ML_P5E_48XLARGE = ClusterInstanceType.ML_P5E_48XLARGE
ML_P5EN_48XLARGE = ClusterInstanceType.ML_P5EN_48XLARGE
ML_P6_B200_48XLARGE = ClusterInstanceType.ML_P6_B200_48XLARGE
ML_TRN2_3XLARGE = ClusterInstanceType.ML_TRN2_3XLARGE
ML_TRN2_48XLARGE = ClusterInstanceType.ML_TRN2_48XLARGE
ML_C6I_LARGE = ClusterInstanceType.ML_C6I_LARGE
ML_C6I_XLARGE = ClusterInstanceType.ML_C6I_XLARGE
ML_C6I_2XLARGE = ClusterInstanceType.ML_C6I_2XLARGE
ML_C6I_4XLARGE = ClusterInstanceType.ML_C6I_4XLARGE
ML_C6I_8XLARGE = ClusterInstanceType.ML_C6I_8XLARGE
ML_C6I_12XLARGE = ClusterInstanceType.ML_C6I_12XLARGE
ML_C6I_16XLARGE = ClusterInstanceType.ML_C6I_16XLARGE
ML_C6I_24XLARGE = ClusterInstanceType.ML_C6I_24XLARGE
ML_C6I_32XLARGE = ClusterInstanceType.ML_C6I_32XLARGE
ML_M6I_LARGE = ClusterInstanceType.ML_M6I_LARGE
ML_M6I_XLARGE = ClusterInstanceType.ML_M6I_XLARGE
ML_M6I_2XLARGE = ClusterInstanceType.ML_M6I_2XLARGE
ML_M6I_4XLARGE = ClusterInstanceType.ML_M6I_4XLARGE
ML_M6I_8XLARGE = ClusterInstanceType.ML_M6I_8XLARGE
ML_M6I_12XLARGE = ClusterInstanceType.ML_M6I_12XLARGE
ML_M6I_16XLARGE = ClusterInstanceType.ML_M6I_16XLARGE
ML_M6I_24XLARGE = ClusterInstanceType.ML_M6I_24XLARGE
ML_M6I_32XLARGE = ClusterInstanceType.ML_M6I_32XLARGE
ML_R6I_LARGE = ClusterInstanceType.ML_R6I_LARGE
ML_R6I_XLARGE = ClusterInstanceType.ML_R6I_XLARGE
ML_R6I_2XLARGE = ClusterInstanceType.ML_R6I_2XLARGE
ML_R6I_4XLARGE = ClusterInstanceType.ML_R6I_4XLARGE
ML_R6I_8XLARGE = ClusterInstanceType.ML_R6I_8XLARGE
ML_R6I_12XLARGE = ClusterInstanceType.ML_R6I_12XLARGE
ML_R6I_16XLARGE = ClusterInstanceType.ML_R6I_16XLARGE
ML_R6I_24XLARGE = ClusterInstanceType.ML_R6I_24XLARGE
ML_R6I_32XLARGE = ClusterInstanceType.ML_R6I_32XLARGE
ML_I3EN_LARGE = ClusterInstanceType.ML_I3EN_LARGE
ML_I3EN_XLARGE = ClusterInstanceType.ML_I3EN_XLARGE
ML_I3EN_2XLARGE = ClusterInstanceType.ML_I3EN_2XLARGE
ML_I3EN_3XLARGE = ClusterInstanceType.ML_I3EN_3XLARGE
ML_I3EN_6XLARGE = ClusterInstanceType.ML_I3EN_6XLARGE
ML_I3EN_12XLARGE = ClusterInstanceType.ML_I3EN_12XLARGE
ML_I3EN_24XLARGE = ClusterInstanceType.ML_I3EN_24XLARGE
ML_M7I_LARGE = ClusterInstanceType.ML_M7I_LARGE
ML_M7I_XLARGE = ClusterInstanceType.ML_M7I_XLARGE
ML_M7I_2XLARGE = ClusterInstanceType.ML_M7I_2XLARGE
ML_M7I_4XLARGE = ClusterInstanceType.ML_M7I_4XLARGE
ML_M7I_8XLARGE = ClusterInstanceType.ML_M7I_8XLARGE
ML_M7I_12XLARGE = ClusterInstanceType.ML_M7I_12XLARGE
ML_M7I_16XLARGE = ClusterInstanceType.ML_M7I_16XLARGE
ML_M7I_24XLARGE = ClusterInstanceType.ML_M7I_24XLARGE
ML_M7I_48XLARGE = ClusterInstanceType.ML_M7I_48XLARGE
ML_R7I_LARGE = ClusterInstanceType.ML_R7I_LARGE
ML_R7I_XLARGE = ClusterInstanceType.ML_R7I_XLARGE
ML_R7I_2XLARGE = ClusterInstanceType.ML_R7I_2XLARGE
ML_R7I_4XLARGE = ClusterInstanceType.ML_R7I_4XLARGE
ML_R7I_8XLARGE = ClusterInstanceType.ML_R7I_8XLARGE
ML_R7I_12XLARGE = ClusterInstanceType.ML_R7I_12XLARGE
ML_R7I_16XLARGE = ClusterInstanceType.ML_R7I_16XLARGE
ML_R7I_24XLARGE = ClusterInstanceType.ML_R7I_24XLARGE
ML_R7I_48XLARGE = ClusterInstanceType.ML_R7I_48XLARGE
ML_P6_B300_48XLARGE = ClusterInstanceType.ML_P6_B300_48XLARGE
NOSCHEDULE = ClusterKubernetesTaintEffect.NOSCHEDULE
PREFERNOSCHEDULE = ClusterKubernetesTaintEffect.PREFERNOSCHEDULE
NOEXECUTE = ClusterKubernetesTaintEffect.NOEXECUTE
CONTINUOUS = ClusterNodeProvisioningMode.CONTINUOUS
AUTOMATIC = ClusterNodeRecovery.AUTOMATIC
NONE = ClusterNodeRecovery.NONE
CREATION_TIME = ClusterSortBy.CREATION_TIME
NAME = ClusterSortBy.NAME
CREATING = ClusterStatus.CREATING
DELETING = ClusterStatus.DELETING
FAILED = ClusterStatus.FAILED
INSERVICE = ClusterStatus.INSERVICE
ROLLINGBACK = ClusterStatus.ROLLINGBACK
SYSTEMUPDATING = ClusterStatus.SYSTEMUPDATING
UPDATING = ClusterStatus.UPDATING
NAME = CodeRepositorySortBy.NAME
CREATIONTIME = CodeRepositorySortBy.CREATIONTIME
LASTMODIFIEDTIME = CodeRepositorySortBy.LASTMODIFIEDTIME
ASCENDING = CodeRepositorySortOrder.ASCENDING
DESCENDING = CodeRepositorySortOrder.DESCENDING
LIST = CollectionType.LIST
SET = CollectionType.SET
VECTOR = CollectionType.VECTOR
INPROGRESS = CompilationJobStatus.INPROGRESS
COMPLETED = CompilationJobStatus.COMPLETED
FAILED = CompilationJobStatus.FAILED
STARTING = CompilationJobStatus.STARTING
STOPPING = CompilationJobStatus.STOPPING
STOPPED = CompilationJobStatus.STOPPED
DISABLED = CompleteOnConvergence.DISABLED
ENABLED = CompleteOnConvergence.ENABLED
NONE = CompressionType.NONE
GZIP = CompressionType.GZIP
TRUE = ConditionOutcome.TRUE
FALSE = ConditionOutcome.FALSE
SINGLEMODEL = ContainerMode.SINGLEMODEL
MULTIMODEL = ContainerMode.MULTIMODEL
FREEOFPERSONALLYIDENTIFIABLEINFORMATION = ContentClassifier.FREEOFPERSONALLYIDENTIFIABLEINFORMATION
FREEOFADULTCONTENT = ContentClassifier.FREEOFADULTCONTENT
SAMEACCOUNT = CrossAccountFilterOption.SAMEACCOUNT
CROSSACCOUNT = CrossAccountFilterOption.CROSSACCOUNT
SFT = CustomizationTechnique.SFT
DPO = CustomizationTechnique.DPO
RLVR = CustomizationTechnique.RLVR
RLAIF = CustomizationTechnique.RLAIF
FULLYREPLICATED = DataDistributionType.FULLYREPLICATED
SHARDEDBYS3KEY = DataDistributionType.SHARDEDBYS3KEY
SALESFORCEGENIE = DataSourceName.SALESFORCEGENIE
SNOWFLAKE = DataSourceName.SNOWFLAKE
INSTANCESTRESS = DeepHealthCheckType.INSTANCESTRESS
INSTANCECONNECTIVITY = DeepHealthCheckType.INSTANCECONNECTIVITY
NOTSTARTED = DetailedAlgorithmStatus.NOTSTARTED
INPROGRESS = DetailedAlgorithmStatus.INPROGRESS
COMPLETED = DetailedAlgorithmStatus.COMPLETED
FAILED = DetailedAlgorithmStatus.FAILED
NOTSTARTED = DetailedModelPackageStatus.NOTSTARTED
INPROGRESS = DetailedModelPackageStatus.INPROGRESS
COMPLETED = DetailedModelPackageStatus.COMPLETED
FAILED = DetailedModelPackageStatus.FAILED
READYTODEPLOY = DeviceDeploymentStatus.READYTODEPLOY
INPROGRESS = DeviceDeploymentStatus.INPROGRESS
DEPLOYED = DeviceDeploymentStatus.DEPLOYED
FAILED = DeviceDeploymentStatus.FAILED
STOPPING = DeviceDeploymentStatus.STOPPING
STOPPED = DeviceDeploymentStatus.STOPPED
PERCENTAGE = DeviceSubsetType.PERCENTAGE
SELECTION = DeviceSubsetType.SELECTION
NAMECONTAINS = DeviceSubsetType.NAMECONTAINS
ENABLED = DirectInternetAccess.ENABLED
DISABLED = DirectInternetAccess.DISABLED
BOTH = Direction.BOTH
ASCENDANTS = Direction.ASCENDANTS
DESCENDANTS = Direction.DESCENDANTS
DELETING = DomainStatus.DELETING
FAILED = DomainStatus.FAILED
INSERVICE = DomainStatus.INSERVICE
PENDING = DomainStatus.PENDING
UPDATING = DomainStatus.UPDATING
UPDATE_FAILED = DomainStatus.UPDATE_FAILED
DELETE_FAILED = DomainStatus.DELETE_FAILED
STARTING = EdgePackagingJobStatus.STARTING
INPROGRESS = EdgePackagingJobStatus.INPROGRESS
COMPLETED = EdgePackagingJobStatus.COMPLETED
FAILED = EdgePackagingJobStatus.FAILED
STOPPING = EdgePackagingJobStatus.STOPPING
STOPPED = EdgePackagingJobStatus.STOPPED
COMPLETED = EdgePresetDeploymentStatus.COMPLETED
FAILED = EdgePresetDeploymentStatus.FAILED
GREENGRASSV2COMPONENT = EdgePresetDeploymentType.GREENGRASSV2COMPONENT
ENABLED = EnabledOrDisabled.ENABLED
DISABLED = EnabledOrDisabled.DISABLED
NAME = EndpointConfigSortKey.NAME
CREATIONTIME = EndpointConfigSortKey.CREATIONTIME
NAME = EndpointSortKey.NAME
CREATIONTIME = EndpointSortKey.CREATIONTIME
STATUS = EndpointSortKey.STATUS
OUTOFSERVICE = EndpointStatus.OUTOFSERVICE
CREATING = EndpointStatus.CREATING
UPDATING = EndpointStatus.UPDATING
SYSTEMUPDATING = EndpointStatus.SYSTEMUPDATING
ROLLINGBACK = EndpointStatus.ROLLINGBACK
INSERVICE = EndpointStatus.INSERVICE
DELETING = EndpointStatus.DELETING
FAILED = EndpointStatus.FAILED
UPDATEROLLBACKFAILED = EndpointStatus.UPDATEROLLBACKFAILED
LLMAJEVALUATION = EvaluationType.LLMAJEVALUATION
CUSTOMSCOREREVALUATION = EvaluationType.CUSTOMSCOREREVALUATION
BENCHMARKEVALUATION = EvaluationType.BENCHMARKEVALUATION
EVENTTIME = EventSortBy.EVENTTIME
USER_PROFILE_NAME = ExecutionRoleIdentityConfig.USER_PROFILE_NAME
DISABLED = ExecutionRoleIdentityConfig.DISABLED
PENDING = ExecutionStatus.PENDING
COMPLETED = ExecutionStatus.COMPLETED
COMPLETEDWITHVIOLATIONS = ExecutionStatus.COMPLETEDWITHVIOLATIONS
INPROGRESS = ExecutionStatus.INPROGRESS
FAILED = ExecutionStatus.FAILED
STOPPING = ExecutionStatus.STOPPING
STOPPED = ExecutionStatus.STOPPED
ROLLBACK_ON_FAILURE = FailureHandlingPolicy.ROLLBACK_ON_FAILURE
DO_NOTHING = FailureHandlingPolicy.DO_NOTHING
ENABLED = FairShare.ENABLED
DISABLED = FairShare.DISABLED
NAME = FeatureGroupSortBy.NAME
FEATUREGROUPSTATUS = FeatureGroupSortBy.FEATUREGROUPSTATUS
OFFLINESTORESTATUS = FeatureGroupSortBy.OFFLINESTORESTATUS
CREATIONTIME = FeatureGroupSortBy.CREATIONTIME
ASCENDING = FeatureGroupSortOrder.ASCENDING
DESCENDING = FeatureGroupSortOrder.DESCENDING
CREATING = FeatureGroupStatus.CREATING
CREATED = FeatureGroupStatus.CREATED
CREATEFAILED = FeatureGroupStatus.CREATEFAILED
DELETING = FeatureGroupStatus.DELETING
DELETEFAILED = FeatureGroupStatus.DELETEFAILED
ENABLED = FeatureStatus.ENABLED
DISABLED = FeatureStatus.DISABLED
INTEGRAL = FeatureType.INTEGRAL
FRACTIONAL = FeatureType.FRACTIONAL
STRING = FeatureType.STRING
RW = FileSystemAccessMode.RW
RO = FileSystemAccessMode.RO
EFS = FileSystemType.EFS
FSXLUSTRE = FileSystemType.FSXLUSTRE
FRONTFILL = FillingType.FRONTFILL
MIDDLEFILL = FillingType.MIDDLEFILL
BACKFILL = FillingType.BACKFILL
FUTUREFILL = FillingType.FUTUREFILL
FRONTFILL_VALUE = FillingType.FRONTFILL_VALUE
MIDDLEFILL_VALUE = FillingType.MIDDLEFILL_VALUE
BACKFILL_VALUE = FillingType.BACKFILL_VALUE
FUTUREFILL_VALUE = FillingType.FUTUREFILL_VALUE
CONTINUE = FlatInvocations.CONTINUE
STOP = FlatInvocations.STOP
INITIALIZING = FlowDefinitionStatus.INITIALIZING
ACTIVE = FlowDefinitionStatus.ACTIVE
FAILED = FlowDefinitionStatus.FAILED
DELETING = FlowDefinitionStatus.DELETING
TENSORFLOW = Framework.TENSORFLOW
KERAS = Framework.KERAS
MXNET = Framework.MXNET
ONNX = Framework.ONNX
PYTORCH = Framework.PYTORCH
XGBOOST = Framework.XGBOOST
TFLITE = Framework.TFLITE
DARKNET = Framework.DARKNET
SKLEARN = Framework.SKLEARN
HUBCONTENTNAME = HubContentSortBy.HUBCONTENTNAME
CREATIONTIME = HubContentSortBy.CREATIONTIME
HUBCONTENTSTATUS = HubContentSortBy.HUBCONTENTSTATUS
AVAILABLE = HubContentStatus.AVAILABLE
IMPORTING = HubContentStatus.IMPORTING
DELETING = HubContentStatus.DELETING
IMPORTFAILED = HubContentStatus.IMPORTFAILED
DELETEFAILED = HubContentStatus.DELETEFAILED
PENDINGIMPORT = HubContentStatus.PENDINGIMPORT
PENDINGDELETE = HubContentStatus.PENDINGDELETE
SUPPORTED = HubContentSupportStatus.SUPPORTED
DEPRECATED = HubContentSupportStatus.DEPRECATED
RESTRICTED = HubContentSupportStatus.RESTRICTED
MODEL = HubContentType.MODEL
NOTEBOOK = HubContentType.NOTEBOOK
MODELREFERENCE = HubContentType.MODELREFERENCE
DATASET = HubContentType.DATASET
JSONDOC = HubContentType.JSONDOC
HUBNAME = HubSortBy.HUBNAME
CREATIONTIME = HubSortBy.CREATIONTIME
HUBSTATUS = HubSortBy.HUBSTATUS
ACCOUNTIDOWNER = HubSortBy.ACCOUNTIDOWNER
INSERVICE = HubStatus.INSERVICE
CREATING = HubStatus.CREATING
UPDATING = HubStatus.UPDATING
DELETING = HubStatus.DELETING
CREATEFAILED = HubStatus.CREATEFAILED
UPDATEFAILED = HubStatus.UPDATEFAILED
DELETEFAILED = HubStatus.DELETEFAILED
ACTIVE = HumanTaskUiStatus.ACTIVE
DELETING = HumanTaskUiStatus.DELETING
AUTO = HyperParameterScalingType.AUTO
LINEAR = HyperParameterScalingType.LINEAR
LOGARITHMIC = HyperParameterScalingType.LOGARITHMIC
REVERSELOGARITHMIC = HyperParameterScalingType.REVERSELOGARITHMIC
PRIORITIZED = HyperParameterTuningAllocationStrategy.PRIORITIZED
MAXIMIZE = HyperParameterTuningJobObjectiveType.MAXIMIZE
MINIMIZE = HyperParameterTuningJobObjectiveType.MINIMIZE
NAME = HyperParameterTuningJobSortByOptions.NAME
STATUS = HyperParameterTuningJobSortByOptions.STATUS
CREATIONTIME = HyperParameterTuningJobSortByOptions.CREATIONTIME
COMPLETED = HyperParameterTuningJobStatus.COMPLETED
INPROGRESS = HyperParameterTuningJobStatus.INPROGRESS
FAILED = HyperParameterTuningJobStatus.FAILED
STOPPED = HyperParameterTuningJobStatus.STOPPED
STOPPING = HyperParameterTuningJobStatus.STOPPING
DELETING = HyperParameterTuningJobStatus.DELETING
DELETEFAILED = HyperParameterTuningJobStatus.DELETEFAILED
BAYESIAN = HyperParameterTuningJobStrategyType.BAYESIAN
RANDOM = HyperParameterTuningJobStrategyType.RANDOM
HYPERBAND = HyperParameterTuningJobStrategyType.HYPERBAND
GRID = HyperParameterTuningJobStrategyType.GRID
IDENTICALDATAANDALGORITHM = HyperParameterTuningJobWarmStartType.IDENTICALDATAANDALGORITHM
TRANSFERLEARNING = HyperParameterTuningJobWarmStartType.TRANSFERLEARNING
IPV4 = IPAddressType.IPV4
DUALSTACK = IPAddressType.DUALSTACK
CREATION_TIME = ImageSortBy.CREATION_TIME
LAST_MODIFIED_TIME = ImageSortBy.LAST_MODIFIED_TIME
IMAGE_NAME = ImageSortBy.IMAGE_NAME
ASCENDING = ImageSortOrder.ASCENDING
DESCENDING = ImageSortOrder.DESCENDING
CREATING = ImageStatus.CREATING
CREATED = ImageStatus.CREATED
CREATE_FAILED = ImageStatus.CREATE_FAILED
UPDATING = ImageStatus.UPDATING
UPDATE_FAILED = ImageStatus.UPDATE_FAILED
DELETING = ImageStatus.DELETING
DELETE_FAILED = ImageStatus.DELETE_FAILED
CREATION_TIME = ImageVersionSortBy.CREATION_TIME
LAST_MODIFIED_TIME = ImageVersionSortBy.LAST_MODIFIED_TIME
VERSION = ImageVersionSortBy.VERSION
ASCENDING = ImageVersionSortOrder.ASCENDING
DESCENDING = ImageVersionSortOrder.DESCENDING
CREATING = ImageVersionStatus.CREATING
CREATED = ImageVersionStatus.CREATED
CREATE_FAILED = ImageVersionStatus.CREATE_FAILED
DELETING = ImageVersionStatus.DELETING
DELETE_FAILED = ImageVersionStatus.DELETE_FAILED
COPY_COUNT = InferenceComponentCapacitySizeType.COPY_COUNT
CAPACITY_PERCENT = InferenceComponentCapacitySizeType.CAPACITY_PERCENT
NAME = InferenceComponentSortKey.NAME
CREATIONTIME = InferenceComponentSortKey.CREATIONTIME
STATUS = InferenceComponentSortKey.STATUS
INSERVICE = InferenceComponentStatus.INSERVICE
CREATING = InferenceComponentStatus.CREATING
UPDATING = InferenceComponentStatus.UPDATING
FAILED = InferenceComponentStatus.FAILED
DELETING = InferenceComponentStatus.DELETING
SERIAL = InferenceExecutionMode.SERIAL
DIRECT = InferenceExecutionMode.DIRECT
CREATING = InferenceExperimentStatus.CREATING
CREATED = InferenceExperimentStatus.CREATED
UPDATING = InferenceExperimentStatus.UPDATING
RUNNING = InferenceExperimentStatus.RUNNING
STARTING = InferenceExperimentStatus.STARTING
STOPPING = InferenceExperimentStatus.STOPPING
COMPLETED = InferenceExperimentStatus.COMPLETED
CANCELLED = InferenceExperimentStatus.CANCELLED
COMPLETED = InferenceExperimentStopDesiredState.COMPLETED
CANCELLED = InferenceExperimentStopDesiredState.CANCELLED
SHADOWMODE = InferenceExperimentType.SHADOWMODE
PIPE = InputMode.PIPE
FILE = InputMode.FILE
INSERVICE = InstanceGroupStatus.INSERVICE
CREATING = InstanceGroupStatus.CREATING
UPDATING = InstanceGroupStatus.UPDATING
FAILED = InstanceGroupStatus.FAILED
DEGRADED = InstanceGroupStatus.DEGRADED
SYSTEMUPDATING = InstanceGroupStatus.SYSTEMUPDATING
DELETING = InstanceGroupStatus.DELETING
ML_T2_MEDIUM = InstanceType.ML_T2_MEDIUM
ML_T2_LARGE = InstanceType.ML_T2_LARGE
ML_T2_XLARGE = InstanceType.ML_T2_XLARGE
ML_T2_2XLARGE = InstanceType.ML_T2_2XLARGE
ML_T3_MEDIUM = InstanceType.ML_T3_MEDIUM
ML_T3_LARGE = InstanceType.ML_T3_LARGE
ML_T3_XLARGE = InstanceType.ML_T3_XLARGE
ML_T3_2XLARGE = InstanceType.ML_T3_2XLARGE
ML_M4_XLARGE = InstanceType.ML_M4_XLARGE
ML_M4_2XLARGE = InstanceType.ML_M4_2XLARGE
ML_M4_4XLARGE = InstanceType.ML_M4_4XLARGE
ML_M4_10XLARGE = InstanceType.ML_M4_10XLARGE
ML_M4_16XLARGE = InstanceType.ML_M4_16XLARGE
ML_M5_XLARGE = InstanceType.ML_M5_XLARGE
ML_M5_2XLARGE = InstanceType.ML_M5_2XLARGE
ML_M5_4XLARGE = InstanceType.ML_M5_4XLARGE
ML_M5_12XLARGE = InstanceType.ML_M5_12XLARGE
ML_M5_24XLARGE = InstanceType.ML_M5_24XLARGE
ML_M5D_LARGE = InstanceType.ML_M5D_LARGE
ML_M5D_XLARGE = InstanceType.ML_M5D_XLARGE
ML_M5D_2XLARGE = InstanceType.ML_M5D_2XLARGE
ML_M5D_4XLARGE = InstanceType.ML_M5D_4XLARGE
ML_M5D_8XLARGE = InstanceType.ML_M5D_8XLARGE
ML_M5D_12XLARGE = InstanceType.ML_M5D_12XLARGE
ML_M5D_16XLARGE = InstanceType.ML_M5D_16XLARGE
ML_M5D_24XLARGE = InstanceType.ML_M5D_24XLARGE
ML_C4_XLARGE = InstanceType.ML_C4_XLARGE
ML_C4_2XLARGE = InstanceType.ML_C4_2XLARGE
ML_C4_4XLARGE = InstanceType.ML_C4_4XLARGE
ML_C4_8XLARGE = InstanceType.ML_C4_8XLARGE
ML_C5_XLARGE = InstanceType.ML_C5_XLARGE
ML_C5_2XLARGE = InstanceType.ML_C5_2XLARGE
ML_C5_4XLARGE = InstanceType.ML_C5_4XLARGE
ML_C5_9XLARGE = InstanceType.ML_C5_9XLARGE
ML_C5_18XLARGE = InstanceType.ML_C5_18XLARGE
ML_C5D_XLARGE = InstanceType.ML_C5D_XLARGE
ML_C5D_2XLARGE = InstanceType.ML_C5D_2XLARGE
ML_C5D_4XLARGE = InstanceType.ML_C5D_4XLARGE
ML_C5D_9XLARGE = InstanceType.ML_C5D_9XLARGE
ML_C5D_18XLARGE = InstanceType.ML_C5D_18XLARGE
ML_P2_XLARGE = InstanceType.ML_P2_XLARGE
ML_P2_8XLARGE = InstanceType.ML_P2_8XLARGE
ML_P2_16XLARGE = InstanceType.ML_P2_16XLARGE
ML_P3_2XLARGE = InstanceType.ML_P3_2XLARGE
ML_P3_8XLARGE = InstanceType.ML_P3_8XLARGE
ML_P3_16XLARGE = InstanceType.ML_P3_16XLARGE
ML_P3DN_24XLARGE = InstanceType.ML_P3DN_24XLARGE
ML_G4DN_XLARGE = InstanceType.ML_G4DN_XLARGE
ML_G4DN_2XLARGE = InstanceType.ML_G4DN_2XLARGE
ML_G4DN_4XLARGE = InstanceType.ML_G4DN_4XLARGE
ML_G4DN_8XLARGE = InstanceType.ML_G4DN_8XLARGE
ML_G4DN_12XLARGE = InstanceType.ML_G4DN_12XLARGE
ML_G4DN_16XLARGE = InstanceType.ML_G4DN_16XLARGE
ML_R5_LARGE = InstanceType.ML_R5_LARGE
ML_R5_XLARGE = InstanceType.ML_R5_XLARGE
ML_R5_2XLARGE = InstanceType.ML_R5_2XLARGE
ML_R5_4XLARGE = InstanceType.ML_R5_4XLARGE
ML_R5_8XLARGE = InstanceType.ML_R5_8XLARGE
ML_R5_12XLARGE = InstanceType.ML_R5_12XLARGE
ML_R5_16XLARGE = InstanceType.ML_R5_16XLARGE
ML_R5_24XLARGE = InstanceType.ML_R5_24XLARGE
ML_G5_XLARGE = InstanceType.ML_G5_XLARGE
ML_G5_2XLARGE = InstanceType.ML_G5_2XLARGE
ML_G5_4XLARGE = InstanceType.ML_G5_4XLARGE
ML_G5_8XLARGE = InstanceType.ML_G5_8XLARGE
ML_G5_16XLARGE = InstanceType.ML_G5_16XLARGE
ML_G5_12XLARGE = InstanceType.ML_G5_12XLARGE
ML_G5_24XLARGE = InstanceType.ML_G5_24XLARGE
ML_G5_48XLARGE = InstanceType.ML_G5_48XLARGE
ML_INF1_XLARGE = InstanceType.ML_INF1_XLARGE
ML_INF1_2XLARGE = InstanceType.ML_INF1_2XLARGE
ML_INF1_6XLARGE = InstanceType.ML_INF1_6XLARGE
ML_INF1_24XLARGE = InstanceType.ML_INF1_24XLARGE
ML_TRN1_2XLARGE = InstanceType.ML_TRN1_2XLARGE
ML_TRN1_32XLARGE = InstanceType.ML_TRN1_32XLARGE
ML_TRN1N_32XLARGE = InstanceType.ML_TRN1N_32XLARGE
ML_INF2_XLARGE = InstanceType.ML_INF2_XLARGE
ML_INF2_8XLARGE = InstanceType.ML_INF2_8XLARGE
ML_INF2_24XLARGE = InstanceType.ML_INF2_24XLARGE
ML_INF2_48XLARGE = InstanceType.ML_INF2_48XLARGE
ML_P4D_24XLARGE = InstanceType.ML_P4D_24XLARGE
ML_P4DE_24XLARGE = InstanceType.ML_P4DE_24XLARGE
ML_P5_48XLARGE = InstanceType.ML_P5_48XLARGE
ML_P6_B200_48XLARGE = InstanceType.ML_P6_B200_48XLARGE
ML_M6I_LARGE = InstanceType.ML_M6I_LARGE
ML_M6I_XLARGE = InstanceType.ML_M6I_XLARGE
ML_M6I_2XLARGE = InstanceType.ML_M6I_2XLARGE
ML_M6I_4XLARGE = InstanceType.ML_M6I_4XLARGE
ML_M6I_8XLARGE = InstanceType.ML_M6I_8XLARGE
ML_M6I_12XLARGE = InstanceType.ML_M6I_12XLARGE
ML_M6I_16XLARGE = InstanceType.ML_M6I_16XLARGE
ML_M6I_24XLARGE = InstanceType.ML_M6I_24XLARGE
ML_M6I_32XLARGE = InstanceType.ML_M6I_32XLARGE
ML_M7I_LARGE = InstanceType.ML_M7I_LARGE
ML_M7I_XLARGE = InstanceType.ML_M7I_XLARGE
ML_M7I_2XLARGE = InstanceType.ML_M7I_2XLARGE
ML_M7I_4XLARGE = InstanceType.ML_M7I_4XLARGE
ML_M7I_8XLARGE = InstanceType.ML_M7I_8XLARGE
ML_M7I_12XLARGE = InstanceType.ML_M7I_12XLARGE
ML_M7I_16XLARGE = InstanceType.ML_M7I_16XLARGE
ML_M7I_24XLARGE = InstanceType.ML_M7I_24XLARGE
ML_M7I_48XLARGE = InstanceType.ML_M7I_48XLARGE
ML_C6I_LARGE = InstanceType.ML_C6I_LARGE
ML_C6I_XLARGE = InstanceType.ML_C6I_XLARGE
ML_C6I_2XLARGE = InstanceType.ML_C6I_2XLARGE
ML_C6I_4XLARGE = InstanceType.ML_C6I_4XLARGE
ML_C6I_8XLARGE = InstanceType.ML_C6I_8XLARGE
ML_C6I_12XLARGE = InstanceType.ML_C6I_12XLARGE
ML_C6I_16XLARGE = InstanceType.ML_C6I_16XLARGE
ML_C6I_24XLARGE = InstanceType.ML_C6I_24XLARGE
ML_C6I_32XLARGE = InstanceType.ML_C6I_32XLARGE
ML_C7I_LARGE = InstanceType.ML_C7I_LARGE
ML_C7I_XLARGE = InstanceType.ML_C7I_XLARGE
ML_C7I_2XLARGE = InstanceType.ML_C7I_2XLARGE
ML_C7I_4XLARGE = InstanceType.ML_C7I_4XLARGE
ML_C7I_8XLARGE = InstanceType.ML_C7I_8XLARGE
ML_C7I_12XLARGE = InstanceType.ML_C7I_12XLARGE
ML_C7I_16XLARGE = InstanceType.ML_C7I_16XLARGE
ML_C7I_24XLARGE = InstanceType.ML_C7I_24XLARGE
ML_C7I_48XLARGE = InstanceType.ML_C7I_48XLARGE
ML_R6I_LARGE = InstanceType.ML_R6I_LARGE
ML_R6I_XLARGE = InstanceType.ML_R6I_XLARGE
ML_R6I_2XLARGE = InstanceType.ML_R6I_2XLARGE
ML_R6I_4XLARGE = InstanceType.ML_R6I_4XLARGE
ML_R6I_8XLARGE = InstanceType.ML_R6I_8XLARGE
ML_R6I_12XLARGE = InstanceType.ML_R6I_12XLARGE
ML_R6I_16XLARGE = InstanceType.ML_R6I_16XLARGE
ML_R6I_24XLARGE = InstanceType.ML_R6I_24XLARGE
ML_R6I_32XLARGE = InstanceType.ML_R6I_32XLARGE
ML_R7I_LARGE = InstanceType.ML_R7I_LARGE
ML_R7I_XLARGE = InstanceType.ML_R7I_XLARGE
ML_R7I_2XLARGE = InstanceType.ML_R7I_2XLARGE
ML_R7I_4XLARGE = InstanceType.ML_R7I_4XLARGE
ML_R7I_8XLARGE = InstanceType.ML_R7I_8XLARGE
ML_R7I_12XLARGE = InstanceType.ML_R7I_12XLARGE
ML_R7I_16XLARGE = InstanceType.ML_R7I_16XLARGE
ML_R7I_24XLARGE = InstanceType.ML_R7I_24XLARGE
ML_R7I_48XLARGE = InstanceType.ML_R7I_48XLARGE
ML_M6ID_LARGE = InstanceType.ML_M6ID_LARGE
ML_M6ID_XLARGE = InstanceType.ML_M6ID_XLARGE
ML_M6ID_2XLARGE = InstanceType.ML_M6ID_2XLARGE
ML_M6ID_4XLARGE = InstanceType.ML_M6ID_4XLARGE
ML_M6ID_8XLARGE = InstanceType.ML_M6ID_8XLARGE
ML_M6ID_12XLARGE = InstanceType.ML_M6ID_12XLARGE
ML_M6ID_16XLARGE = InstanceType.ML_M6ID_16XLARGE
ML_M6ID_24XLARGE = InstanceType.ML_M6ID_24XLARGE
ML_M6ID_32XLARGE = InstanceType.ML_M6ID_32XLARGE
ML_C6ID_LARGE = InstanceType.ML_C6ID_LARGE
ML_C6ID_XLARGE = InstanceType.ML_C6ID_XLARGE
ML_C6ID_2XLARGE = InstanceType.ML_C6ID_2XLARGE
ML_C6ID_4XLARGE = InstanceType.ML_C6ID_4XLARGE
ML_C6ID_8XLARGE = InstanceType.ML_C6ID_8XLARGE
ML_C6ID_12XLARGE = InstanceType.ML_C6ID_12XLARGE
ML_C6ID_16XLARGE = InstanceType.ML_C6ID_16XLARGE
ML_C6ID_24XLARGE = InstanceType.ML_C6ID_24XLARGE
ML_C6ID_32XLARGE = InstanceType.ML_C6ID_32XLARGE
ML_R6ID_LARGE = InstanceType.ML_R6ID_LARGE
ML_R6ID_XLARGE = InstanceType.ML_R6ID_XLARGE
ML_R6ID_2XLARGE = InstanceType.ML_R6ID_2XLARGE
ML_R6ID_4XLARGE = InstanceType.ML_R6ID_4XLARGE
ML_R6ID_8XLARGE = InstanceType.ML_R6ID_8XLARGE
ML_R6ID_12XLARGE = InstanceType.ML_R6ID_12XLARGE
ML_R6ID_16XLARGE = InstanceType.ML_R6ID_16XLARGE
ML_R6ID_24XLARGE = InstanceType.ML_R6ID_24XLARGE
ML_R6ID_32XLARGE = InstanceType.ML_R6ID_32XLARGE
ML_G6_XLARGE = InstanceType.ML_G6_XLARGE
ML_G6_2XLARGE = InstanceType.ML_G6_2XLARGE
ML_G6_4XLARGE = InstanceType.ML_G6_4XLARGE
ML_G6_8XLARGE = InstanceType.ML_G6_8XLARGE
ML_G6_12XLARGE = InstanceType.ML_G6_12XLARGE
ML_G6_16XLARGE = InstanceType.ML_G6_16XLARGE
ML_G6_24XLARGE = InstanceType.ML_G6_24XLARGE
ML_G6_48XLARGE = InstanceType.ML_G6_48XLARGE
ACTIVE = IsTrackingServerActive.ACTIVE
INACTIVE = IsTrackingServerActive.INACTIVE
TRAINING = JobType.TRAINING
INFERENCE = JobType.INFERENCE
NOTEBOOK_KERNEL = JobType.NOTEBOOK_KERNEL
INPUT = JoinSource.INPUT
NONE = JoinSource.NONE
INITIALIZING = LabelingJobStatus.INITIALIZING
INPROGRESS = LabelingJobStatus.INPROGRESS
COMPLETED = LabelingJobStatus.COMPLETED
FAILED = LabelingJobStatus.FAILED
STOPPING = LabelingJobStatus.STOPPING
STOPPED = LabelingJobStatus.STOPPED
SUCCESSFUL = LastUpdateStatusValue.SUCCESSFUL
FAILED = LastUpdateStatusValue.FAILED
INPROGRESS = LastUpdateStatusValue.INPROGRESS
ENABLED = LifecycleManagement.ENABLED
DISABLED = LifecycleManagement.DISABLED
TRIALCOMPONENT = LineageType.TRIALCOMPONENT
ARTIFACT = LineageType.ARTIFACT
CONTEXT = LineageType.CONTEXT
ACTION = LineageType.ACTION
NAME = ListCompilationJobsSortBy.NAME
CREATIONTIME = ListCompilationJobsSortBy.CREATIONTIME
STATUS = ListCompilationJobsSortBy.STATUS
NAME = ListDeviceFleetsSortBy.NAME
CREATION_TIME = ListDeviceFleetsSortBy.CREATION_TIME
LAST_MODIFIED_TIME = ListDeviceFleetsSortBy.LAST_MODIFIED_TIME
NAME = ListEdgeDeploymentPlansSortBy.NAME
DEVICE_FLEET_NAME = ListEdgeDeploymentPlansSortBy.DEVICE_FLEET_NAME
CREATION_TIME = ListEdgeDeploymentPlansSortBy.CREATION_TIME
LAST_MODIFIED_TIME = ListEdgeDeploymentPlansSortBy.LAST_MODIFIED_TIME
NAME = ListEdgePackagingJobsSortBy.NAME
MODEL_NAME = ListEdgePackagingJobsSortBy.MODEL_NAME
CREATION_TIME = ListEdgePackagingJobsSortBy.CREATION_TIME
LAST_MODIFIED_TIME = ListEdgePackagingJobsSortBy.LAST_MODIFIED_TIME
STATUS = ListEdgePackagingJobsSortBy.STATUS
NAME = ListInferenceRecommendationsJobsSortBy.NAME
CREATIONTIME = ListInferenceRecommendationsJobsSortBy.CREATIONTIME
STATUS = ListInferenceRecommendationsJobsSortBy.STATUS
CREATIONTIME = ListLabelingJobsForWorkteamSortByOptions.CREATIONTIME
NAME = ListOptimizationJobsSortBy.NAME
CREATIONTIME = ListOptimizationJobsSortBy.CREATIONTIME
STATUS = ListOptimizationJobsSortBy.STATUS
NAME = ListWorkforcesSortByOptions.NAME
CREATEDATE = ListWorkforcesSortByOptions.CREATEDATE
NAME = ListWorkteamsSortByOptions.NAME
CREATEDATE = ListWorkteamsSortByOptions.CREATEDATE
MIG_1G_5GB = MIGProfileType.MIG_1G_5GB
MIG_1G_10GB = MIGProfileType.MIG_1G_10GB
MIG_1G_18GB = MIGProfileType.MIG_1G_18GB
MIG_1G_20GB = MIGProfileType.MIG_1G_20GB
MIG_1G_23GB = MIGProfileType.MIG_1G_23GB
MIG_1G_35GB = MIGProfileType.MIG_1G_35GB
MIG_1G_45GB = MIGProfileType.MIG_1G_45GB
MIG_1G_47GB = MIGProfileType.MIG_1G_47GB
MIG_2G_10GB = MIGProfileType.MIG_2G_10GB
MIG_2G_20GB = MIGProfileType.MIG_2G_20GB
MIG_2G_35GB = MIGProfileType.MIG_2G_35GB
MIG_2G_45GB = MIGProfileType.MIG_2G_45GB
MIG_2G_47GB = MIGProfileType.MIG_2G_47GB
MIG_3G_20GB = MIGProfileType.MIG_3G_20GB
MIG_3G_40GB = MIGProfileType.MIG_3G_40GB
MIG_3G_71GB = MIGProfileType.MIG_3G_71GB
MIG_3G_90GB = MIGProfileType.MIG_3G_90GB
MIG_3G_93GB = MIGProfileType.MIG_3G_93GB
MIG_4G_20GB = MIGProfileType.MIG_4G_20GB
MIG_4G_40GB = MIGProfileType.MIG_4G_40GB
MIG_4G_71GB = MIGProfileType.MIG_4G_71GB
MIG_4G_90GB = MIGProfileType.MIG_4G_90GB
MIG_4G_93GB = MIGProfileType.MIG_4G_93GB
MIG_7G_40GB = MIGProfileType.MIG_7G_40GB
MIG_7G_80GB = MIGProfileType.MIG_7G_80GB
MIG_7G_141GB = MIGProfileType.MIG_7G_141GB
MIG_7G_180GB = MIGProfileType.MIG_7G_180GB
MIG_7G_186GB = MIGProfileType.MIG_7G_186GB
MAINTENANCEINPROGRESS = MaintenanceStatus.MAINTENANCEINPROGRESS
MAINTENANCECOMPLETE = MaintenanceStatus.MAINTENANCECOMPLETE
MAINTENANCEFAILED = MaintenanceStatus.MAINTENANCEFAILED
ENABLED = ManagedInstanceScalingStatus.ENABLED
DISABLED = ManagedInstanceScalingStatus.DISABLED
TRAIN = MetricSetSource.TRAIN
VALIDATION = MetricSetSource.VALIDATION
TEST = MetricSetSource.TEST
DATAWRANGLER = MlTools.DATAWRANGLER
FEATURESTORE = MlTools.FEATURESTORE
EMRCLUSTERS = MlTools.EMRCLUSTERS
AUTOML = MlTools.AUTOML
EXPERIMENTS = MlTools.EXPERIMENTS
TRAINING = MlTools.TRAINING
MODELEVALUATION = MlTools.MODELEVALUATION
PIPELINES = MlTools.PIPELINES
MODELS = MlTools.MODELS
JUMPSTART = MlTools.JUMPSTART
INFERENCERECOMMENDER = MlTools.INFERENCERECOMMENDER
ENDPOINTS = MlTools.ENDPOINTS
PROJECTS = MlTools.PROJECTS
INFERENCEOPTIMIZATION = MlTools.INFERENCEOPTIMIZATION
PERFORMANCEEVALUATION = MlTools.PERFORMANCEEVALUATION
LAKERAGUARD = MlTools.LAKERAGUARD
COMET = MlTools.COMET
DEEPCHECKSLLMEVALUATION = MlTools.DEEPCHECKSLLMEVALUATION
FIDDLER = MlTools.FIDDLER
HYPERPODCLUSTERS = MlTools.HYPERPODCLUSTERS
RUNNINGINSTANCES = MlTools.RUNNINGINSTANCES
DATASETS = MlTools.DATASETS
EVALUATORS = MlTools.EVALUATORS
CREATING = MlflowAppStatus.CREATING
CREATED = MlflowAppStatus.CREATED
CREATEFAILED = MlflowAppStatus.CREATEFAILED
UPDATING = MlflowAppStatus.UPDATING
UPDATED = MlflowAppStatus.UPDATED
UPDATEFAILED = MlflowAppStatus.UPDATEFAILED
DELETING = MlflowAppStatus.DELETING
DELETEFAILED = MlflowAppStatus.DELETEFAILED
DELETED = MlflowAppStatus.DELETED
APPROVED = ModelApprovalStatus.APPROVED
REJECTED = ModelApprovalStatus.REJECTED
PENDINGMANUALAPPROVAL = ModelApprovalStatus.PENDINGMANUALAPPROVAL
ENABLED = ModelCacheSetting.ENABLED
DISABLED = ModelCacheSetting.DISABLED
NAME = ModelCardExportJobSortBy.NAME
CREATIONTIME = ModelCardExportJobSortBy.CREATIONTIME
STATUS = ModelCardExportJobSortBy.STATUS
ASCENDING = ModelCardExportJobSortOrder.ASCENDING
DESCENDING = ModelCardExportJobSortOrder.DESCENDING
INPROGRESS = ModelCardExportJobStatus.INPROGRESS
COMPLETED = ModelCardExportJobStatus.COMPLETED
FAILED = ModelCardExportJobStatus.FAILED
DELETEINPROGRESS = ModelCardProcessingStatus.DELETEINPROGRESS
DELETEPENDING = ModelCardProcessingStatus.DELETEPENDING
CONTENTDELETED = ModelCardProcessingStatus.CONTENTDELETED
EXPORTJOBSDELETED = ModelCardProcessingStatus.EXPORTJOBSDELETED
DELETECOMPLETED = ModelCardProcessingStatus.DELETECOMPLETED
DELETEFAILED = ModelCardProcessingStatus.DELETEFAILED
NAME = ModelCardSortBy.NAME
CREATIONTIME = ModelCardSortBy.CREATIONTIME
ASCENDING = ModelCardSortOrder.ASCENDING
DESCENDING = ModelCardSortOrder.DESCENDING
DRAFT = ModelCardStatus.DRAFT
PENDINGREVIEW = ModelCardStatus.PENDINGREVIEW
APPROVED = ModelCardStatus.APPROVED
ARCHIVED = ModelCardStatus.ARCHIVED
VERSION = ModelCardVersionSortBy.VERSION
NONE = ModelCompressionType.NONE
GZIP = ModelCompressionType.GZIP
REALTIMEINFERENCE = ModelInfrastructureType.REALTIMEINFERENCE
DOMAIN = ModelMetadataFilterType.DOMAIN
FRAMEWORK = ModelMetadataFilterType.FRAMEWORK
TASK = ModelMetadataFilterType.TASK
FRAMEWORKVERSION = ModelMetadataFilterType.FRAMEWORKVERSION
NAME = ModelPackageGroupSortBy.NAME
CREATIONTIME = ModelPackageGroupSortBy.CREATIONTIME
PENDING = ModelPackageGroupStatus.PENDING
INPROGRESS = ModelPackageGroupStatus.INPROGRESS
COMPLETED = ModelPackageGroupStatus.COMPLETED
FAILED = ModelPackageGroupStatus.FAILED
DELETING = ModelPackageGroupStatus.DELETING
DELETEFAILED = ModelPackageGroupStatus.DELETEFAILED
LOGGED = ModelPackageRegistrationType.LOGGED
REGISTERED = ModelPackageRegistrationType.REGISTERED
NAME = ModelPackageSortBy.NAME
CREATIONTIME = ModelPackageSortBy.CREATIONTIME
PENDING = ModelPackageStatus.PENDING
INPROGRESS = ModelPackageStatus.INPROGRESS
COMPLETED = ModelPackageStatus.COMPLETED
FAILED = ModelPackageStatus.FAILED
DELETING = ModelPackageStatus.DELETING
VERSIONED = ModelPackageType.VERSIONED
UNVERSIONED = ModelPackageType.UNVERSIONED
BOTH = ModelPackageType.BOTH
AUTOMODELREGISTRATIONENABLED = ModelRegistrationMode.AUTOMODELREGISTRATIONENABLED
AUTOMODELREGISTRATIONDISABLED = ModelRegistrationMode.AUTOMODELREGISTRATIONDISABLED
NAME = ModelSortKey.NAME
CREATIONTIME = ModelSortKey.CREATIONTIME
S3PREFIX = ModelSpeculativeDecodingS3DataType.S3PREFIX
MANIFESTFILE = ModelSpeculativeDecodingS3DataType.MANIFESTFILE
EAGLE = ModelSpeculativeDecodingTechnique.EAGLE
RETAIN = ModelVariantAction.RETAIN
REMOVE = ModelVariantAction.REMOVE
PROMOTE = ModelVariantAction.PROMOTE
CREATING = ModelVariantStatus.CREATING
UPDATING = ModelVariantStatus.UPDATING
INSERVICE = ModelVariantStatus.INSERVICE
DELETING = ModelVariantStatus.DELETING
DELETED = ModelVariantStatus.DELETED
CREATIONTIME = MonitoringAlertHistorySortKey.CREATIONTIME
STATUS = MonitoringAlertHistorySortKey.STATUS
INALERT = MonitoringAlertStatus.INALERT
OK = MonitoringAlertStatus.OK
CREATIONTIME = MonitoringExecutionSortKey.CREATIONTIME
SCHEDULEDTIME = MonitoringExecutionSortKey.SCHEDULEDTIME
STATUS = MonitoringExecutionSortKey.STATUS
NAME = MonitoringJobDefinitionSortKey.NAME
CREATIONTIME = MonitoringJobDefinitionSortKey.CREATIONTIME
BINARYCLASSIFICATION = MonitoringProblemType.BINARYCLASSIFICATION
MULTICLASSCLASSIFICATION = MonitoringProblemType.MULTICLASSCLASSIFICATION
REGRESSION = MonitoringProblemType.REGRESSION
NAME = MonitoringScheduleSortKey.NAME
CREATIONTIME = MonitoringScheduleSortKey.CREATIONTIME
STATUS = MonitoringScheduleSortKey.STATUS
DATAQUALITY = MonitoringType.DATAQUALITY
MODELQUALITY = MonitoringType.MODELQUALITY
MODELBIAS = MonitoringType.MODELBIAS
MODELEXPLAINABILITY = MonitoringType.MODELEXPLAINABILITY
INSTANCE_COUNT = NodeUnavailabilityType.INSTANCE_COUNT
CAPACITY_PERCENTAGE = NodeUnavailabilityType.CAPACITY_PERCENTAGE
ML_EIA1_MEDIUM = NotebookInstanceAcceleratorType.ML_EIA1_MEDIUM
ML_EIA1_LARGE = NotebookInstanceAcceleratorType.ML_EIA1_LARGE
ML_EIA1_XLARGE = NotebookInstanceAcceleratorType.ML_EIA1_XLARGE
ML_EIA2_MEDIUM = NotebookInstanceAcceleratorType.ML_EIA2_MEDIUM
ML_EIA2_LARGE = NotebookInstanceAcceleratorType.ML_EIA2_LARGE
ML_EIA2_XLARGE = NotebookInstanceAcceleratorType.ML_EIA2_XLARGE
NAME = NotebookInstanceLifecycleConfigSortKey.NAME
CREATIONTIME = NotebookInstanceLifecycleConfigSortKey.CREATIONTIME
LASTMODIFIEDTIME = NotebookInstanceLifecycleConfigSortKey.LASTMODIFIEDTIME
ASCENDING = NotebookInstanceLifecycleConfigSortOrder.ASCENDING
DESCENDING = NotebookInstanceLifecycleConfigSortOrder.DESCENDING
NAME = NotebookInstanceSortKey.NAME
CREATIONTIME = NotebookInstanceSortKey.CREATIONTIME
STATUS = NotebookInstanceSortKey.STATUS
ASCENDING = NotebookInstanceSortOrder.ASCENDING
DESCENDING = NotebookInstanceSortOrder.DESCENDING
PENDING = NotebookInstanceStatus.PENDING
INSERVICE = NotebookInstanceStatus.INSERVICE
STOPPING = NotebookInstanceStatus.STOPPING
STOPPED = NotebookInstanceStatus.STOPPED
FAILED = NotebookInstanceStatus.FAILED
DELETING = NotebookInstanceStatus.DELETING
UPDATING = NotebookInstanceStatus.UPDATING
ALLOWED = NotebookOutputOption.ALLOWED
DISABLED = NotebookOutputOption.DISABLED
SUCCEEDED = ObjectiveStatus.SUCCEEDED
PENDING = ObjectiveStatus.PENDING
FAILED = ObjectiveStatus.FAILED
ACTIVE = OfflineStoreStatusValue.ACTIVE
BLOCKED = OfflineStoreStatusValue.BLOCKED
DISABLED = OfflineStoreStatusValue.DISABLED
EQUALS = Operator.EQUALS
NOTEQUALS = Operator.NOTEQUALS
GREATERTHAN = Operator.GREATERTHAN
GREATERTHANOREQUALTO = Operator.GREATERTHANOREQUALTO
LESSTHAN = Operator.LESSTHAN
LESSTHANOREQUALTO = Operator.LESSTHANOREQUALTO
CONTAINS = Operator.CONTAINS
EXISTS = Operator.EXISTS
NOTEXISTS = Operator.NOTEXISTS
IN = Operator.IN
ML_P4D_24XLARGE = OptimizationJobDeploymentInstanceType.ML_P4D_24XLARGE
ML_P4DE_24XLARGE = OptimizationJobDeploymentInstanceType.ML_P4DE_24XLARGE
ML_P5_48XLARGE = OptimizationJobDeploymentInstanceType.ML_P5_48XLARGE
ML_P5E_48XLARGE = OptimizationJobDeploymentInstanceType.ML_P5E_48XLARGE
ML_P5EN_48XLARGE = OptimizationJobDeploymentInstanceType.ML_P5EN_48XLARGE
ML_G5_XLARGE = OptimizationJobDeploymentInstanceType.ML_G5_XLARGE
ML_G5_2XLARGE = OptimizationJobDeploymentInstanceType.ML_G5_2XLARGE
ML_G5_4XLARGE = OptimizationJobDeploymentInstanceType.ML_G5_4XLARGE
ML_G5_8XLARGE = OptimizationJobDeploymentInstanceType.ML_G5_8XLARGE
ML_G5_12XLARGE = OptimizationJobDeploymentInstanceType.ML_G5_12XLARGE
ML_G5_16XLARGE = OptimizationJobDeploymentInstanceType.ML_G5_16XLARGE
ML_G5_24XLARGE = OptimizationJobDeploymentInstanceType.ML_G5_24XLARGE
ML_G5_48XLARGE = OptimizationJobDeploymentInstanceType.ML_G5_48XLARGE
ML_G6_XLARGE = OptimizationJobDeploymentInstanceType.ML_G6_XLARGE
ML_G6_2XLARGE = OptimizationJobDeploymentInstanceType.ML_G6_2XLARGE
ML_G6_4XLARGE = OptimizationJobDeploymentInstanceType.ML_G6_4XLARGE
ML_G6_8XLARGE = OptimizationJobDeploymentInstanceType.ML_G6_8XLARGE
ML_G6_12XLARGE = OptimizationJobDeploymentInstanceType.ML_G6_12XLARGE
ML_G6_16XLARGE = OptimizationJobDeploymentInstanceType.ML_G6_16XLARGE
ML_G6_24XLARGE = OptimizationJobDeploymentInstanceType.ML_G6_24XLARGE
ML_G6_48XLARGE = OptimizationJobDeploymentInstanceType.ML_G6_48XLARGE
ML_G6E_XLARGE = OptimizationJobDeploymentInstanceType.ML_G6E_XLARGE
ML_G6E_2XLARGE = OptimizationJobDeploymentInstanceType.ML_G6E_2XLARGE
ML_G6E_4XLARGE = OptimizationJobDeploymentInstanceType.ML_G6E_4XLARGE
ML_G6E_8XLARGE = OptimizationJobDeploymentInstanceType.ML_G6E_8XLARGE
ML_G6E_12XLARGE = OptimizationJobDeploymentInstanceType.ML_G6E_12XLARGE
ML_G6E_16XLARGE = OptimizationJobDeploymentInstanceType.ML_G6E_16XLARGE
ML_G6E_24XLARGE = OptimizationJobDeploymentInstanceType.ML_G6E_24XLARGE
ML_G6E_48XLARGE = OptimizationJobDeploymentInstanceType.ML_G6E_48XLARGE
ML_INF2_XLARGE = OptimizationJobDeploymentInstanceType.ML_INF2_XLARGE
ML_INF2_8XLARGE = OptimizationJobDeploymentInstanceType.ML_INF2_8XLARGE
ML_INF2_24XLARGE = OptimizationJobDeploymentInstanceType.ML_INF2_24XLARGE
ML_INF2_48XLARGE = OptimizationJobDeploymentInstanceType.ML_INF2_48XLARGE
ML_TRN1_2XLARGE = OptimizationJobDeploymentInstanceType.ML_TRN1_2XLARGE
ML_TRN1_32XLARGE = OptimizationJobDeploymentInstanceType.ML_TRN1_32XLARGE
ML_TRN1N_32XLARGE = OptimizationJobDeploymentInstanceType.ML_TRN1N_32XLARGE
INPROGRESS = OptimizationJobStatus.INPROGRESS
COMPLETED = OptimizationJobStatus.COMPLETED
FAILED = OptimizationJobStatus.FAILED
STARTING = OptimizationJobStatus.STARTING
STOPPING = OptimizationJobStatus.STOPPING
STOPPED = OptimizationJobStatus.STOPPED
ASCENDING = OrderKey.ASCENDING
DESCENDING = OrderKey.DESCENDING
GZIP = OutputCompressionType.GZIP
NONE = OutputCompressionType.NONE
INTEGER = ParameterType.INTEGER
CONTINUOUS = ParameterType.CONTINUOUS
CATEGORICAL = ParameterType.CATEGORICAL
FREETEXT = ParameterType.FREETEXT
IAM = PartnerAppAuthType.IAM
CREATING = PartnerAppStatus.CREATING
UPDATING = PartnerAppStatus.UPDATING
DELETING = PartnerAppStatus.DELETING
AVAILABLE = PartnerAppStatus.AVAILABLE
FAILED = PartnerAppStatus.FAILED
UPDATEFAILED = PartnerAppStatus.UPDATEFAILED
DELETED = PartnerAppStatus.DELETED
LAKERA_GUARD = PartnerAppType.LAKERA_GUARD
COMET = PartnerAppType.COMET
DEEPCHECKS_LLM_EVALUATION = PartnerAppType.DEEPCHECKS_LLM_EVALUATION
FIDDLER = PartnerAppType.FIDDLER
LORA = Peft.LORA
EXECUTING = PipelineExecutionStatus.EXECUTING
STOPPING = PipelineExecutionStatus.STOPPING
STOPPED = PipelineExecutionStatus.STOPPED
FAILED = PipelineExecutionStatus.FAILED
SUCCEEDED = PipelineExecutionStatus.SUCCEEDED
ACTIVE = PipelineStatus.ACTIVE
DELETING = PipelineStatus.DELETING
NEVER = PreemptTeamTasks.NEVER
LOWERPRIORITY = PreemptTeamTasks.LOWERPRIORITY
BINARYCLASSIFICATION = ProblemType.BINARYCLASSIFICATION
MULTICLASSCLASSIFICATION = ProblemType.MULTICLASSCLASSIFICATION
REGRESSION = ProblemType.REGRESSION
ML_T3_MEDIUM = ProcessingInstanceType.ML_T3_MEDIUM
ML_T3_LARGE = ProcessingInstanceType.ML_T3_LARGE
ML_T3_XLARGE = ProcessingInstanceType.ML_T3_XLARGE
ML_T3_2XLARGE = ProcessingInstanceType.ML_T3_2XLARGE
ML_M4_XLARGE = ProcessingInstanceType.ML_M4_XLARGE
ML_M4_2XLARGE = ProcessingInstanceType.ML_M4_2XLARGE
ML_M4_4XLARGE = ProcessingInstanceType.ML_M4_4XLARGE
ML_M4_10XLARGE = ProcessingInstanceType.ML_M4_10XLARGE
ML_M4_16XLARGE = ProcessingInstanceType.ML_M4_16XLARGE
ML_C4_XLARGE = ProcessingInstanceType.ML_C4_XLARGE
ML_C4_2XLARGE = ProcessingInstanceType.ML_C4_2XLARGE
ML_C4_4XLARGE = ProcessingInstanceType.ML_C4_4XLARGE
ML_C4_8XLARGE = ProcessingInstanceType.ML_C4_8XLARGE
ML_P2_XLARGE = ProcessingInstanceType.ML_P2_XLARGE
ML_P2_8XLARGE = ProcessingInstanceType.ML_P2_8XLARGE
ML_P2_16XLARGE = ProcessingInstanceType.ML_P2_16XLARGE
ML_P3_2XLARGE = ProcessingInstanceType.ML_P3_2XLARGE
ML_P3_8XLARGE = ProcessingInstanceType.ML_P3_8XLARGE
ML_P3_16XLARGE = ProcessingInstanceType.ML_P3_16XLARGE
ML_C5_XLARGE = ProcessingInstanceType.ML_C5_XLARGE
ML_C5_2XLARGE = ProcessingInstanceType.ML_C5_2XLARGE
ML_C5_4XLARGE = ProcessingInstanceType.ML_C5_4XLARGE
ML_C5_9XLARGE = ProcessingInstanceType.ML_C5_9XLARGE
ML_C5_18XLARGE = ProcessingInstanceType.ML_C5_18XLARGE
ML_M5_LARGE = ProcessingInstanceType.ML_M5_LARGE
ML_M5_XLARGE = ProcessingInstanceType.ML_M5_XLARGE
ML_M5_2XLARGE = ProcessingInstanceType.ML_M5_2XLARGE
ML_M5_4XLARGE = ProcessingInstanceType.ML_M5_4XLARGE
ML_M5_12XLARGE = ProcessingInstanceType.ML_M5_12XLARGE
ML_M5_24XLARGE = ProcessingInstanceType.ML_M5_24XLARGE
ML_R5_LARGE = ProcessingInstanceType.ML_R5_LARGE
ML_R5_XLARGE = ProcessingInstanceType.ML_R5_XLARGE
ML_R5_2XLARGE = ProcessingInstanceType.ML_R5_2XLARGE
ML_R5_4XLARGE = ProcessingInstanceType.ML_R5_4XLARGE
ML_R5_8XLARGE = ProcessingInstanceType.ML_R5_8XLARGE
ML_R5_12XLARGE = ProcessingInstanceType.ML_R5_12XLARGE
ML_R5_16XLARGE = ProcessingInstanceType.ML_R5_16XLARGE
ML_R5_24XLARGE = ProcessingInstanceType.ML_R5_24XLARGE
ML_G4DN_XLARGE = ProcessingInstanceType.ML_G4DN_XLARGE
ML_G4DN_2XLARGE = ProcessingInstanceType.ML_G4DN_2XLARGE
ML_G4DN_4XLARGE = ProcessingInstanceType.ML_G4DN_4XLARGE
ML_G4DN_8XLARGE = ProcessingInstanceType.ML_G4DN_8XLARGE
ML_G4DN_12XLARGE = ProcessingInstanceType.ML_G4DN_12XLARGE
ML_G4DN_16XLARGE = ProcessingInstanceType.ML_G4DN_16XLARGE
ML_G5_XLARGE = ProcessingInstanceType.ML_G5_XLARGE
ML_G5_2XLARGE = ProcessingInstanceType.ML_G5_2XLARGE
ML_G5_4XLARGE = ProcessingInstanceType.ML_G5_4XLARGE
ML_G5_8XLARGE = ProcessingInstanceType.ML_G5_8XLARGE
ML_G5_16XLARGE = ProcessingInstanceType.ML_G5_16XLARGE
ML_G5_12XLARGE = ProcessingInstanceType.ML_G5_12XLARGE
ML_G5_24XLARGE = ProcessingInstanceType.ML_G5_24XLARGE
ML_G5_48XLARGE = ProcessingInstanceType.ML_G5_48XLARGE
ML_R5D_LARGE = ProcessingInstanceType.ML_R5D_LARGE
ML_R5D_XLARGE = ProcessingInstanceType.ML_R5D_XLARGE
ML_R5D_2XLARGE = ProcessingInstanceType.ML_R5D_2XLARGE
ML_R5D_4XLARGE = ProcessingInstanceType.ML_R5D_4XLARGE
ML_R5D_8XLARGE = ProcessingInstanceType.ML_R5D_8XLARGE
ML_R5D_12XLARGE = ProcessingInstanceType.ML_R5D_12XLARGE
ML_R5D_16XLARGE = ProcessingInstanceType.ML_R5D_16XLARGE
ML_R5D_24XLARGE = ProcessingInstanceType.ML_R5D_24XLARGE
ML_G6_XLARGE = ProcessingInstanceType.ML_G6_XLARGE
ML_G6_2XLARGE = ProcessingInstanceType.ML_G6_2XLARGE
ML_G6_4XLARGE = ProcessingInstanceType.ML_G6_4XLARGE
ML_G6_8XLARGE = ProcessingInstanceType.ML_G6_8XLARGE
ML_G6_12XLARGE = ProcessingInstanceType.ML_G6_12XLARGE
ML_G6_16XLARGE = ProcessingInstanceType.ML_G6_16XLARGE
ML_G6_24XLARGE = ProcessingInstanceType.ML_G6_24XLARGE
ML_G6_48XLARGE = ProcessingInstanceType.ML_G6_48XLARGE
ML_G6E_XLARGE = ProcessingInstanceType.ML_G6E_XLARGE
ML_G6E_2XLARGE = ProcessingInstanceType.ML_G6E_2XLARGE
ML_G6E_4XLARGE = ProcessingInstanceType.ML_G6E_4XLARGE
ML_G6E_8XLARGE = ProcessingInstanceType.ML_G6E_8XLARGE
ML_G6E_12XLARGE = ProcessingInstanceType.ML_G6E_12XLARGE
ML_G6E_16XLARGE = ProcessingInstanceType.ML_G6E_16XLARGE
ML_G6E_24XLARGE = ProcessingInstanceType.ML_G6E_24XLARGE
ML_G6E_48XLARGE = ProcessingInstanceType.ML_G6E_48XLARGE
ML_M6I_LARGE = ProcessingInstanceType.ML_M6I_LARGE
ML_M6I_XLARGE = ProcessingInstanceType.ML_M6I_XLARGE
ML_M6I_2XLARGE = ProcessingInstanceType.ML_M6I_2XLARGE
ML_M6I_4XLARGE = ProcessingInstanceType.ML_M6I_4XLARGE
ML_M6I_8XLARGE = ProcessingInstanceType.ML_M6I_8XLARGE
ML_M6I_12XLARGE = ProcessingInstanceType.ML_M6I_12XLARGE
ML_M6I_16XLARGE = ProcessingInstanceType.ML_M6I_16XLARGE
ML_M6I_24XLARGE = ProcessingInstanceType.ML_M6I_24XLARGE
ML_M6I_32XLARGE = ProcessingInstanceType.ML_M6I_32XLARGE
ML_C6I_XLARGE = ProcessingInstanceType.ML_C6I_XLARGE
ML_C6I_2XLARGE = ProcessingInstanceType.ML_C6I_2XLARGE
ML_C6I_4XLARGE = ProcessingInstanceType.ML_C6I_4XLARGE
ML_C6I_8XLARGE = ProcessingInstanceType.ML_C6I_8XLARGE
ML_C6I_12XLARGE = ProcessingInstanceType.ML_C6I_12XLARGE
ML_C6I_16XLARGE = ProcessingInstanceType.ML_C6I_16XLARGE
ML_C6I_24XLARGE = ProcessingInstanceType.ML_C6I_24XLARGE
ML_C6I_32XLARGE = ProcessingInstanceType.ML_C6I_32XLARGE
ML_M7I_LARGE = ProcessingInstanceType.ML_M7I_LARGE
ML_M7I_XLARGE = ProcessingInstanceType.ML_M7I_XLARGE
ML_M7I_2XLARGE = ProcessingInstanceType.ML_M7I_2XLARGE
ML_M7I_4XLARGE = ProcessingInstanceType.ML_M7I_4XLARGE
ML_M7I_8XLARGE = ProcessingInstanceType.ML_M7I_8XLARGE
ML_M7I_12XLARGE = ProcessingInstanceType.ML_M7I_12XLARGE
ML_M7I_16XLARGE = ProcessingInstanceType.ML_M7I_16XLARGE
ML_M7I_24XLARGE = ProcessingInstanceType.ML_M7I_24XLARGE
ML_M7I_48XLARGE = ProcessingInstanceType.ML_M7I_48XLARGE
ML_C7I_LARGE = ProcessingInstanceType.ML_C7I_LARGE
ML_C7I_XLARGE = ProcessingInstanceType.ML_C7I_XLARGE
ML_C7I_2XLARGE = ProcessingInstanceType.ML_C7I_2XLARGE
ML_C7I_4XLARGE = ProcessingInstanceType.ML_C7I_4XLARGE
ML_C7I_8XLARGE = ProcessingInstanceType.ML_C7I_8XLARGE
ML_C7I_12XLARGE = ProcessingInstanceType.ML_C7I_12XLARGE
ML_C7I_16XLARGE = ProcessingInstanceType.ML_C7I_16XLARGE
ML_C7I_24XLARGE = ProcessingInstanceType.ML_C7I_24XLARGE
ML_C7I_48XLARGE = ProcessingInstanceType.ML_C7I_48XLARGE
ML_R7I_LARGE = ProcessingInstanceType.ML_R7I_LARGE
ML_R7I_XLARGE = ProcessingInstanceType.ML_R7I_XLARGE
ML_R7I_2XLARGE = ProcessingInstanceType.ML_R7I_2XLARGE
ML_R7I_4XLARGE = ProcessingInstanceType.ML_R7I_4XLARGE
ML_R7I_8XLARGE = ProcessingInstanceType.ML_R7I_8XLARGE
ML_R7I_12XLARGE = ProcessingInstanceType.ML_R7I_12XLARGE
ML_R7I_16XLARGE = ProcessingInstanceType.ML_R7I_16XLARGE
ML_R7I_24XLARGE = ProcessingInstanceType.ML_R7I_24XLARGE
ML_R7I_48XLARGE = ProcessingInstanceType.ML_R7I_48XLARGE
ML_P5_4XLARGE = ProcessingInstanceType.ML_P5_4XLARGE
INPROGRESS = ProcessingJobStatus.INPROGRESS
COMPLETED = ProcessingJobStatus.COMPLETED
FAILED = ProcessingJobStatus.FAILED
STOPPING = ProcessingJobStatus.STOPPING
STOPPED = ProcessingJobStatus.STOPPED
NONE = ProcessingS3CompressionType.NONE
GZIP = ProcessingS3CompressionType.GZIP
FULLYREPLICATED = ProcessingS3DataDistributionType.FULLYREPLICATED
SHARDEDBYS3KEY = ProcessingS3DataDistributionType.SHARDEDBYS3KEY
MANIFESTFILE = ProcessingS3DataType.MANIFESTFILE
S3PREFIX = ProcessingS3DataType.S3PREFIX
PIPE = ProcessingS3InputMode.PIPE
FILE = ProcessingS3InputMode.FILE
CONTINUOUS = ProcessingS3UploadMode.CONTINUOUS
ENDOFJOB = ProcessingS3UploadMode.ENDOFJOB
CPU = Processor.CPU
GPU = Processor.GPU
ML_EIA1_MEDIUM = ProductionVariantAcceleratorType.ML_EIA1_MEDIUM
ML_EIA1_LARGE = ProductionVariantAcceleratorType.ML_EIA1_LARGE
ML_EIA1_XLARGE = ProductionVariantAcceleratorType.ML_EIA1_XLARGE
ML_EIA2_MEDIUM = ProductionVariantAcceleratorType.ML_EIA2_MEDIUM
ML_EIA2_LARGE = ProductionVariantAcceleratorType.ML_EIA2_LARGE
ML_EIA2_XLARGE = ProductionVariantAcceleratorType.ML_EIA2_XLARGE
AL2_AMI_SAGEMAKER_INFERENCE_GPU_2 = ProductionVariantInferenceAmiVersion.AL2_AMI_SAGEMAKER_INFERENCE_GPU_2
AL2_AMI_SAGEMAKER_INFERENCE_GPU_2_1 = ProductionVariantInferenceAmiVersion.AL2_AMI_SAGEMAKER_INFERENCE_GPU_2_1
AL2_AMI_SAGEMAKER_INFERENCE_GPU_3_1 = ProductionVariantInferenceAmiVersion.AL2_AMI_SAGEMAKER_INFERENCE_GPU_3_1
AL2_AMI_SAGEMAKER_INFERENCE_NEURON_2 = ProductionVariantInferenceAmiVersion.AL2_AMI_SAGEMAKER_INFERENCE_NEURON_2
ML_T2_MEDIUM = ProductionVariantInstanceType.ML_T2_MEDIUM
ML_T2_LARGE = ProductionVariantInstanceType.ML_T2_LARGE
ML_T2_XLARGE = ProductionVariantInstanceType.ML_T2_XLARGE
ML_T2_2XLARGE = ProductionVariantInstanceType.ML_T2_2XLARGE
ML_M4_XLARGE = ProductionVariantInstanceType.ML_M4_XLARGE
ML_M4_2XLARGE = ProductionVariantInstanceType.ML_M4_2XLARGE
ML_M4_4XLARGE = ProductionVariantInstanceType.ML_M4_4XLARGE
ML_M4_10XLARGE = ProductionVariantInstanceType.ML_M4_10XLARGE
ML_M4_16XLARGE = ProductionVariantInstanceType.ML_M4_16XLARGE
ML_M5_LARGE = ProductionVariantInstanceType.ML_M5_LARGE
ML_M5_XLARGE = ProductionVariantInstanceType.ML_M5_XLARGE
ML_M5_2XLARGE = ProductionVariantInstanceType.ML_M5_2XLARGE
ML_M5_4XLARGE = ProductionVariantInstanceType.ML_M5_4XLARGE
ML_M5_12XLARGE = ProductionVariantInstanceType.ML_M5_12XLARGE
ML_M5_24XLARGE = ProductionVariantInstanceType.ML_M5_24XLARGE
ML_M5D_LARGE = ProductionVariantInstanceType.ML_M5D_LARGE
ML_M5D_XLARGE = ProductionVariantInstanceType.ML_M5D_XLARGE
ML_M5D_2XLARGE = ProductionVariantInstanceType.ML_M5D_2XLARGE
ML_M5D_4XLARGE = ProductionVariantInstanceType.ML_M5D_4XLARGE
ML_M5D_12XLARGE = ProductionVariantInstanceType.ML_M5D_12XLARGE
ML_M5D_24XLARGE = ProductionVariantInstanceType.ML_M5D_24XLARGE
ML_C4_LARGE = ProductionVariantInstanceType.ML_C4_LARGE
ML_C4_XLARGE = ProductionVariantInstanceType.ML_C4_XLARGE
ML_C4_2XLARGE = ProductionVariantInstanceType.ML_C4_2XLARGE
ML_C4_4XLARGE = ProductionVariantInstanceType.ML_C4_4XLARGE
ML_C4_8XLARGE = ProductionVariantInstanceType.ML_C4_8XLARGE
ML_P2_XLARGE = ProductionVariantInstanceType.ML_P2_XLARGE
ML_P2_8XLARGE = ProductionVariantInstanceType.ML_P2_8XLARGE
ML_P2_16XLARGE = ProductionVariantInstanceType.ML_P2_16XLARGE
ML_P3_2XLARGE = ProductionVariantInstanceType.ML_P3_2XLARGE
ML_P3_8XLARGE = ProductionVariantInstanceType.ML_P3_8XLARGE
ML_P3_16XLARGE = ProductionVariantInstanceType.ML_P3_16XLARGE
ML_C5_LARGE = ProductionVariantInstanceType.ML_C5_LARGE
ML_C5_XLARGE = ProductionVariantInstanceType.ML_C5_XLARGE
ML_C5_2XLARGE = ProductionVariantInstanceType.ML_C5_2XLARGE
ML_C5_4XLARGE = ProductionVariantInstanceType.ML_C5_4XLARGE
ML_C5_9XLARGE = ProductionVariantInstanceType.ML_C5_9XLARGE
ML_C5_18XLARGE = ProductionVariantInstanceType.ML_C5_18XLARGE
ML_C5D_LARGE = ProductionVariantInstanceType.ML_C5D_LARGE
ML_C5D_XLARGE = ProductionVariantInstanceType.ML_C5D_XLARGE
ML_C5D_2XLARGE = ProductionVariantInstanceType.ML_C5D_2XLARGE
ML_C5D_4XLARGE = ProductionVariantInstanceType.ML_C5D_4XLARGE
ML_C5D_9XLARGE = ProductionVariantInstanceType.ML_C5D_9XLARGE
ML_C5D_18XLARGE = ProductionVariantInstanceType.ML_C5D_18XLARGE
ML_G4DN_XLARGE = ProductionVariantInstanceType.ML_G4DN_XLARGE
ML_G4DN_2XLARGE = ProductionVariantInstanceType.ML_G4DN_2XLARGE
ML_G4DN_4XLARGE = ProductionVariantInstanceType.ML_G4DN_4XLARGE
ML_G4DN_8XLARGE = ProductionVariantInstanceType.ML_G4DN_8XLARGE
ML_G4DN_12XLARGE = ProductionVariantInstanceType.ML_G4DN_12XLARGE
ML_G4DN_16XLARGE = ProductionVariantInstanceType.ML_G4DN_16XLARGE
ML_R5_LARGE = ProductionVariantInstanceType.ML_R5_LARGE
ML_R5_XLARGE = ProductionVariantInstanceType.ML_R5_XLARGE
ML_R5_2XLARGE = ProductionVariantInstanceType.ML_R5_2XLARGE
ML_R5_4XLARGE = ProductionVariantInstanceType.ML_R5_4XLARGE
ML_R5_12XLARGE = ProductionVariantInstanceType.ML_R5_12XLARGE
ML_R5_24XLARGE = ProductionVariantInstanceType.ML_R5_24XLARGE
ML_R5D_LARGE = ProductionVariantInstanceType.ML_R5D_LARGE
ML_R5D_XLARGE = ProductionVariantInstanceType.ML_R5D_XLARGE
ML_R5D_2XLARGE = ProductionVariantInstanceType.ML_R5D_2XLARGE
ML_R5D_4XLARGE = ProductionVariantInstanceType.ML_R5D_4XLARGE
ML_R5D_12XLARGE = ProductionVariantInstanceType.ML_R5D_12XLARGE
ML_R5D_24XLARGE = ProductionVariantInstanceType.ML_R5D_24XLARGE
ML_INF1_XLARGE = ProductionVariantInstanceType.ML_INF1_XLARGE
ML_INF1_2XLARGE = ProductionVariantInstanceType.ML_INF1_2XLARGE
ML_INF1_6XLARGE = ProductionVariantInstanceType.ML_INF1_6XLARGE
ML_INF1_24XLARGE = ProductionVariantInstanceType.ML_INF1_24XLARGE
ML_DL1_24XLARGE = ProductionVariantInstanceType.ML_DL1_24XLARGE
ML_C6I_LARGE = ProductionVariantInstanceType.ML_C6I_LARGE
ML_C6I_XLARGE = ProductionVariantInstanceType.ML_C6I_XLARGE
ML_C6I_2XLARGE = ProductionVariantInstanceType.ML_C6I_2XLARGE
ML_C6I_4XLARGE = ProductionVariantInstanceType.ML_C6I_4XLARGE
ML_C6I_8XLARGE = ProductionVariantInstanceType.ML_C6I_8XLARGE
ML_C6I_12XLARGE = ProductionVariantInstanceType.ML_C6I_12XLARGE
ML_C6I_16XLARGE = ProductionVariantInstanceType.ML_C6I_16XLARGE
ML_C6I_24XLARGE = ProductionVariantInstanceType.ML_C6I_24XLARGE
ML_C6I_32XLARGE = ProductionVariantInstanceType.ML_C6I_32XLARGE
ML_M6I_LARGE = ProductionVariantInstanceType.ML_M6I_LARGE
ML_M6I_XLARGE = ProductionVariantInstanceType.ML_M6I_XLARGE
ML_M6I_2XLARGE = ProductionVariantInstanceType.ML_M6I_2XLARGE
ML_M6I_4XLARGE = ProductionVariantInstanceType.ML_M6I_4XLARGE
ML_M6I_8XLARGE = ProductionVariantInstanceType.ML_M6I_8XLARGE
ML_M6I_12XLARGE = ProductionVariantInstanceType.ML_M6I_12XLARGE
ML_M6I_16XLARGE = ProductionVariantInstanceType.ML_M6I_16XLARGE
ML_M6I_24XLARGE = ProductionVariantInstanceType.ML_M6I_24XLARGE
ML_M6I_32XLARGE = ProductionVariantInstanceType.ML_M6I_32XLARGE
ML_R6I_LARGE = ProductionVariantInstanceType.ML_R6I_LARGE
ML_R6I_XLARGE = ProductionVariantInstanceType.ML_R6I_XLARGE
ML_R6I_2XLARGE = ProductionVariantInstanceType.ML_R6I_2XLARGE
ML_R6I_4XLARGE = ProductionVariantInstanceType.ML_R6I_4XLARGE
ML_R6I_8XLARGE = ProductionVariantInstanceType.ML_R6I_8XLARGE
ML_R6I_12XLARGE = ProductionVariantInstanceType.ML_R6I_12XLARGE
ML_R6I_16XLARGE = ProductionVariantInstanceType.ML_R6I_16XLARGE
ML_R6I_24XLARGE = ProductionVariantInstanceType.ML_R6I_24XLARGE
ML_R6I_32XLARGE = ProductionVariantInstanceType.ML_R6I_32XLARGE
ML_G5_XLARGE = ProductionVariantInstanceType.ML_G5_XLARGE
ML_G5_2XLARGE = ProductionVariantInstanceType.ML_G5_2XLARGE
ML_G5_4XLARGE = ProductionVariantInstanceType.ML_G5_4XLARGE
ML_G5_8XLARGE = ProductionVariantInstanceType.ML_G5_8XLARGE
ML_G5_12XLARGE = ProductionVariantInstanceType.ML_G5_12XLARGE
ML_G5_16XLARGE = ProductionVariantInstanceType.ML_G5_16XLARGE
ML_G5_24XLARGE = ProductionVariantInstanceType.ML_G5_24XLARGE
ML_G5_48XLARGE = ProductionVariantInstanceType.ML_G5_48XLARGE
ML_G6_XLARGE = ProductionVariantInstanceType.ML_G6_XLARGE
ML_G6_2XLARGE = ProductionVariantInstanceType.ML_G6_2XLARGE
ML_G6_4XLARGE = ProductionVariantInstanceType.ML_G6_4XLARGE
ML_G6_8XLARGE = ProductionVariantInstanceType.ML_G6_8XLARGE
ML_G6_12XLARGE = ProductionVariantInstanceType.ML_G6_12XLARGE
ML_G6_16XLARGE = ProductionVariantInstanceType.ML_G6_16XLARGE
ML_G6_24XLARGE = ProductionVariantInstanceType.ML_G6_24XLARGE
ML_G6_48XLARGE = ProductionVariantInstanceType.ML_G6_48XLARGE
ML_R8G_MEDIUM = ProductionVariantInstanceType.ML_R8G_MEDIUM
ML_R8G_LARGE = ProductionVariantInstanceType.ML_R8G_LARGE
ML_R8G_XLARGE = ProductionVariantInstanceType.ML_R8G_XLARGE
ML_R8G_2XLARGE = ProductionVariantInstanceType.ML_R8G_2XLARGE
ML_R8G_4XLARGE = ProductionVariantInstanceType.ML_R8G_4XLARGE
ML_R8G_8XLARGE = ProductionVariantInstanceType.ML_R8G_8XLARGE
ML_R8G_12XLARGE = ProductionVariantInstanceType.ML_R8G_12XLARGE
ML_R8G_16XLARGE = ProductionVariantInstanceType.ML_R8G_16XLARGE
ML_R8G_24XLARGE = ProductionVariantInstanceType.ML_R8G_24XLARGE
ML_R8G_48XLARGE = ProductionVariantInstanceType.ML_R8G_48XLARGE
ML_G6E_XLARGE = ProductionVariantInstanceType.ML_G6E_XLARGE
ML_G6E_2XLARGE = ProductionVariantInstanceType.ML_G6E_2XLARGE
ML_G6E_4XLARGE = ProductionVariantInstanceType.ML_G6E_4XLARGE
ML_G6E_8XLARGE = ProductionVariantInstanceType.ML_G6E_8XLARGE
ML_G6E_12XLARGE = ProductionVariantInstanceType.ML_G6E_12XLARGE
ML_G6E_16XLARGE = ProductionVariantInstanceType.ML_G6E_16XLARGE
ML_G6E_24XLARGE = ProductionVariantInstanceType.ML_G6E_24XLARGE
ML_G6E_48XLARGE = ProductionVariantInstanceType.ML_G6E_48XLARGE
ML_P4D_24XLARGE = ProductionVariantInstanceType.ML_P4D_24XLARGE
ML_C7G_LARGE = ProductionVariantInstanceType.ML_C7G_LARGE
ML_C7G_XLARGE = ProductionVariantInstanceType.ML_C7G_XLARGE
ML_C7G_2XLARGE = ProductionVariantInstanceType.ML_C7G_2XLARGE
ML_C7G_4XLARGE = ProductionVariantInstanceType.ML_C7G_4XLARGE
ML_C7G_8XLARGE = ProductionVariantInstanceType.ML_C7G_8XLARGE
ML_C7G_12XLARGE = ProductionVariantInstanceType.ML_C7G_12XLARGE
ML_C7G_16XLARGE = ProductionVariantInstanceType.ML_C7G_16XLARGE
ML_M6G_LARGE = ProductionVariantInstanceType.ML_M6G_LARGE
ML_M6G_XLARGE = ProductionVariantInstanceType.ML_M6G_XLARGE
ML_M6G_2XLARGE = ProductionVariantInstanceType.ML_M6G_2XLARGE
ML_M6G_4XLARGE = ProductionVariantInstanceType.ML_M6G_4XLARGE
ML_M6G_8XLARGE = ProductionVariantInstanceType.ML_M6G_8XLARGE
ML_M6G_12XLARGE = ProductionVariantInstanceType.ML_M6G_12XLARGE
ML_M6G_16XLARGE = ProductionVariantInstanceType.ML_M6G_16XLARGE
ML_M6GD_LARGE = ProductionVariantInstanceType.ML_M6GD_LARGE
ML_M6GD_XLARGE = ProductionVariantInstanceType.ML_M6GD_XLARGE
ML_M6GD_2XLARGE = ProductionVariantInstanceType.ML_M6GD_2XLARGE
ML_M6GD_4XLARGE = ProductionVariantInstanceType.ML_M6GD_4XLARGE
ML_M6GD_8XLARGE = ProductionVariantInstanceType.ML_M6GD_8XLARGE
ML_M6GD_12XLARGE = ProductionVariantInstanceType.ML_M6GD_12XLARGE
ML_M6GD_16XLARGE = ProductionVariantInstanceType.ML_M6GD_16XLARGE
ML_C6G_LARGE = ProductionVariantInstanceType.ML_C6G_LARGE
ML_C6G_XLARGE = ProductionVariantInstanceType.ML_C6G_XLARGE
ML_C6G_2XLARGE = ProductionVariantInstanceType.ML_C6G_2XLARGE
ML_C6G_4XLARGE = ProductionVariantInstanceType.ML_C6G_4XLARGE
ML_C6G_8XLARGE = ProductionVariantInstanceType.ML_C6G_8XLARGE
ML_C6G_12XLARGE = ProductionVariantInstanceType.ML_C6G_12XLARGE
ML_C6G_16XLARGE = ProductionVariantInstanceType.ML_C6G_16XLARGE
ML_C6GD_LARGE = ProductionVariantInstanceType.ML_C6GD_LARGE
ML_C6GD_XLARGE = ProductionVariantInstanceType.ML_C6GD_XLARGE
ML_C6GD_2XLARGE = ProductionVariantInstanceType.ML_C6GD_2XLARGE
ML_C6GD_4XLARGE = ProductionVariantInstanceType.ML_C6GD_4XLARGE
ML_C6GD_8XLARGE = ProductionVariantInstanceType.ML_C6GD_8XLARGE
ML_C6GD_12XLARGE = ProductionVariantInstanceType.ML_C6GD_12XLARGE
ML_C6GD_16XLARGE = ProductionVariantInstanceType.ML_C6GD_16XLARGE
ML_C6GN_LARGE = ProductionVariantInstanceType.ML_C6GN_LARGE
ML_C6GN_XLARGE = ProductionVariantInstanceType.ML_C6GN_XLARGE
ML_C6GN_2XLARGE = ProductionVariantInstanceType.ML_C6GN_2XLARGE
ML_C6GN_4XLARGE = ProductionVariantInstanceType.ML_C6GN_4XLARGE
ML_C6GN_8XLARGE = ProductionVariantInstanceType.ML_C6GN_8XLARGE
ML_C6GN_12XLARGE = ProductionVariantInstanceType.ML_C6GN_12XLARGE
ML_C6GN_16XLARGE = ProductionVariantInstanceType.ML_C6GN_16XLARGE
ML_R6G_LARGE = ProductionVariantInstanceType.ML_R6G_LARGE
ML_R6G_XLARGE = ProductionVariantInstanceType.ML_R6G_XLARGE
ML_R6G_2XLARGE = ProductionVariantInstanceType.ML_R6G_2XLARGE
ML_R6G_4XLARGE = ProductionVariantInstanceType.ML_R6G_4XLARGE
ML_R6G_8XLARGE = ProductionVariantInstanceType.ML_R6G_8XLARGE
ML_R6G_12XLARGE = ProductionVariantInstanceType.ML_R6G_12XLARGE
ML_R6G_16XLARGE = ProductionVariantInstanceType.ML_R6G_16XLARGE
ML_R6GD_LARGE = ProductionVariantInstanceType.ML_R6GD_LARGE
ML_R6GD_XLARGE = ProductionVariantInstanceType.ML_R6GD_XLARGE
ML_R6GD_2XLARGE = ProductionVariantInstanceType.ML_R6GD_2XLARGE
ML_R6GD_4XLARGE = ProductionVariantInstanceType.ML_R6GD_4XLARGE
ML_R6GD_8XLARGE = ProductionVariantInstanceType.ML_R6GD_8XLARGE
ML_R6GD_12XLARGE = ProductionVariantInstanceType.ML_R6GD_12XLARGE
ML_R6GD_16XLARGE = ProductionVariantInstanceType.ML_R6GD_16XLARGE
ML_P4DE_24XLARGE = ProductionVariantInstanceType.ML_P4DE_24XLARGE
ML_TRN1_2XLARGE = ProductionVariantInstanceType.ML_TRN1_2XLARGE
ML_TRN1_32XLARGE = ProductionVariantInstanceType.ML_TRN1_32XLARGE
ML_TRN1N_32XLARGE = ProductionVariantInstanceType.ML_TRN1N_32XLARGE
ML_TRN2_48XLARGE = ProductionVariantInstanceType.ML_TRN2_48XLARGE
ML_INF2_XLARGE = ProductionVariantInstanceType.ML_INF2_XLARGE
ML_INF2_8XLARGE = ProductionVariantInstanceType.ML_INF2_8XLARGE
ML_INF2_24XLARGE = ProductionVariantInstanceType.ML_INF2_24XLARGE
ML_INF2_48XLARGE = ProductionVariantInstanceType.ML_INF2_48XLARGE
ML_P5_48XLARGE = ProductionVariantInstanceType.ML_P5_48XLARGE
ML_P5E_48XLARGE = ProductionVariantInstanceType.ML_P5E_48XLARGE
ML_P5EN_48XLARGE = ProductionVariantInstanceType.ML_P5EN_48XLARGE
ML_M7I_LARGE = ProductionVariantInstanceType.ML_M7I_LARGE
ML_M7I_XLARGE = ProductionVariantInstanceType.ML_M7I_XLARGE
ML_M7I_2XLARGE = ProductionVariantInstanceType.ML_M7I_2XLARGE
ML_M7I_4XLARGE = ProductionVariantInstanceType.ML_M7I_4XLARGE
ML_M7I_8XLARGE = ProductionVariantInstanceType.ML_M7I_8XLARGE
ML_M7I_12XLARGE = ProductionVariantInstanceType.ML_M7I_12XLARGE
ML_M7I_16XLARGE = ProductionVariantInstanceType.ML_M7I_16XLARGE
ML_M7I_24XLARGE = ProductionVariantInstanceType.ML_M7I_24XLARGE
ML_M7I_48XLARGE = ProductionVariantInstanceType.ML_M7I_48XLARGE
ML_C7I_LARGE = ProductionVariantInstanceType.ML_C7I_LARGE
ML_C7I_XLARGE = ProductionVariantInstanceType.ML_C7I_XLARGE
ML_C7I_2XLARGE = ProductionVariantInstanceType.ML_C7I_2XLARGE
ML_C7I_4XLARGE = ProductionVariantInstanceType.ML_C7I_4XLARGE
ML_C7I_8XLARGE = ProductionVariantInstanceType.ML_C7I_8XLARGE
ML_C7I_12XLARGE = ProductionVariantInstanceType.ML_C7I_12XLARGE
ML_C7I_16XLARGE = ProductionVariantInstanceType.ML_C7I_16XLARGE
ML_C7I_24XLARGE = ProductionVariantInstanceType.ML_C7I_24XLARGE
ML_C7I_48XLARGE = ProductionVariantInstanceType.ML_C7I_48XLARGE
ML_R7I_LARGE = ProductionVariantInstanceType.ML_R7I_LARGE
ML_R7I_XLARGE = ProductionVariantInstanceType.ML_R7I_XLARGE
ML_R7I_2XLARGE = ProductionVariantInstanceType.ML_R7I_2XLARGE
ML_R7I_4XLARGE = ProductionVariantInstanceType.ML_R7I_4XLARGE
ML_R7I_8XLARGE = ProductionVariantInstanceType.ML_R7I_8XLARGE
ML_R7I_12XLARGE = ProductionVariantInstanceType.ML_R7I_12XLARGE
ML_R7I_16XLARGE = ProductionVariantInstanceType.ML_R7I_16XLARGE
ML_R7I_24XLARGE = ProductionVariantInstanceType.ML_R7I_24XLARGE
ML_R7I_48XLARGE = ProductionVariantInstanceType.ML_R7I_48XLARGE
ML_C8G_MEDIUM = ProductionVariantInstanceType.ML_C8G_MEDIUM
ML_C8G_LARGE = ProductionVariantInstanceType.ML_C8G_LARGE
ML_C8G_XLARGE = ProductionVariantInstanceType.ML_C8G_XLARGE
ML_C8G_2XLARGE = ProductionVariantInstanceType.ML_C8G_2XLARGE
ML_C8G_4XLARGE = ProductionVariantInstanceType.ML_C8G_4XLARGE
ML_C8G_8XLARGE = ProductionVariantInstanceType.ML_C8G_8XLARGE
ML_C8G_12XLARGE = ProductionVariantInstanceType.ML_C8G_12XLARGE
ML_C8G_16XLARGE = ProductionVariantInstanceType.ML_C8G_16XLARGE
ML_C8G_24XLARGE = ProductionVariantInstanceType.ML_C8G_24XLARGE
ML_C8G_48XLARGE = ProductionVariantInstanceType.ML_C8G_48XLARGE
ML_R7GD_MEDIUM = ProductionVariantInstanceType.ML_R7GD_MEDIUM
ML_R7GD_LARGE = ProductionVariantInstanceType.ML_R7GD_LARGE
ML_R7GD_XLARGE = ProductionVariantInstanceType.ML_R7GD_XLARGE
ML_R7GD_2XLARGE = ProductionVariantInstanceType.ML_R7GD_2XLARGE
ML_R7GD_4XLARGE = ProductionVariantInstanceType.ML_R7GD_4XLARGE
ML_R7GD_8XLARGE = ProductionVariantInstanceType.ML_R7GD_8XLARGE
ML_R7GD_12XLARGE = ProductionVariantInstanceType.ML_R7GD_12XLARGE
ML_R7GD_16XLARGE = ProductionVariantInstanceType.ML_R7GD_16XLARGE
ML_M8G_MEDIUM = ProductionVariantInstanceType.ML_M8G_MEDIUM
ML_M8G_LARGE = ProductionVariantInstanceType.ML_M8G_LARGE
ML_M8G_XLARGE = ProductionVariantInstanceType.ML_M8G_XLARGE
ML_M8G_2XLARGE = ProductionVariantInstanceType.ML_M8G_2XLARGE
ML_M8G_4XLARGE = ProductionVariantInstanceType.ML_M8G_4XLARGE
ML_M8G_8XLARGE = ProductionVariantInstanceType.ML_M8G_8XLARGE
ML_M8G_12XLARGE = ProductionVariantInstanceType.ML_M8G_12XLARGE
ML_M8G_16XLARGE = ProductionVariantInstanceType.ML_M8G_16XLARGE
ML_M8G_24XLARGE = ProductionVariantInstanceType.ML_M8G_24XLARGE
ML_M8G_48XLARGE = ProductionVariantInstanceType.ML_M8G_48XLARGE
ML_C6IN_LARGE = ProductionVariantInstanceType.ML_C6IN_LARGE
ML_C6IN_XLARGE = ProductionVariantInstanceType.ML_C6IN_XLARGE
ML_C6IN_2XLARGE = ProductionVariantInstanceType.ML_C6IN_2XLARGE
ML_C6IN_4XLARGE = ProductionVariantInstanceType.ML_C6IN_4XLARGE
ML_C6IN_8XLARGE = ProductionVariantInstanceType.ML_C6IN_8XLARGE
ML_C6IN_12XLARGE = ProductionVariantInstanceType.ML_C6IN_12XLARGE
ML_C6IN_16XLARGE = ProductionVariantInstanceType.ML_C6IN_16XLARGE
ML_C6IN_24XLARGE = ProductionVariantInstanceType.ML_C6IN_24XLARGE
ML_C6IN_32XLARGE = ProductionVariantInstanceType.ML_C6IN_32XLARGE
ML_P6_B200_48XLARGE = ProductionVariantInstanceType.ML_P6_B200_48XLARGE
ML_P6E_GB200_36XLARGE = ProductionVariantInstanceType.ML_P6E_GB200_36XLARGE
ML_P5_4XLARGE = ProductionVariantInstanceType.ML_P5_4XLARGE
ENABLED = ProfilingStatus.ENABLED
DISABLED = ProfilingStatus.DISABLED
NAME = ProjectSortBy.NAME
CREATIONTIME = ProjectSortBy.CREATIONTIME
ASCENDING = ProjectSortOrder.ASCENDING
DESCENDING = ProjectSortOrder.DESCENDING
PENDING = ProjectStatus.PENDING
CREATEINPROGRESS = ProjectStatus.CREATEINPROGRESS
CREATECOMPLETED = ProjectStatus.CREATECOMPLETED
CREATEFAILED = ProjectStatus.CREATEFAILED
DELETEINPROGRESS = ProjectStatus.DELETEINPROGRESS
DELETEFAILED = ProjectStatus.DELETEFAILED
DELETECOMPLETED = ProjectStatus.DELETECOMPLETED
UPDATEINPROGRESS = ProjectStatus.UPDATEINPROGRESS
UPDATECOMPLETED = ProjectStatus.UPDATECOMPLETED
UPDATEFAILED = ProjectStatus.UPDATEFAILED
ENABLED = RStudioServerProAccessStatus.ENABLED
DISABLED = RStudioServerProAccessStatus.DISABLED
R_STUDIO_ADMIN = RStudioServerProUserGroup.R_STUDIO_ADMIN
R_STUDIO_USER = RStudioServerProUserGroup.R_STUDIO_USER
PENDING = RecommendationJobStatus.PENDING
IN_PROGRESS = RecommendationJobStatus.IN_PROGRESS
COMPLETED = RecommendationJobStatus.COMPLETED
FAILED = RecommendationJobStatus.FAILED
STOPPING = RecommendationJobStatus.STOPPING
STOPPED = RecommendationJobStatus.STOPPED
DELETING = RecommendationJobStatus.DELETING
DELETED = RecommendationJobStatus.DELETED
REALTIME = RecommendationJobSupportedEndpointType.REALTIME
SERVERLESS = RecommendationJobSupportedEndpointType.SERVERLESS
DEFAULT = RecommendationJobType.DEFAULT
ADVANCED = RecommendationJobType.ADVANCED
IN_PROGRESS = RecommendationStatus.IN_PROGRESS
COMPLETED = RecommendationStatus.COMPLETED
FAILED = RecommendationStatus.FAILED
NOT_APPLICABLE = RecommendationStatus.NOT_APPLICABLE
BENCHMARK = RecommendationStepType.BENCHMARK
NONE = RecordWrapper.NONE
RECORDIO = RecordWrapper.RECORDIO
NONE = RedshiftResultCompressionType.NONE
GZIP = RedshiftResultCompressionType.GZIP
BZIP2 = RedshiftResultCompressionType.BZIP2
ZSTD = RedshiftResultCompressionType.ZSTD
SNAPPY = RedshiftResultCompressionType.SNAPPY
PARQUET = RedshiftResultFormat.PARQUET
CSV = RedshiftResultFormat.CSV
EQUALTO = Relation.EQUALTO
GREATERTHANOREQUALTO = Relation.GREATERTHANOREQUALTO
PLATFORM = RepositoryAccessMode.PLATFORM
VPC = RepositoryAccessMode.VPC
ML_P4D_24XLARGE = ReservedCapacityInstanceType.ML_P4D_24XLARGE
ML_P5_48XLARGE = ReservedCapacityInstanceType.ML_P5_48XLARGE
ML_P5E_48XLARGE = ReservedCapacityInstanceType.ML_P5E_48XLARGE
ML_P5EN_48XLARGE = ReservedCapacityInstanceType.ML_P5EN_48XLARGE
ML_TRN1_32XLARGE = ReservedCapacityInstanceType.ML_TRN1_32XLARGE
ML_TRN2_48XLARGE = ReservedCapacityInstanceType.ML_TRN2_48XLARGE
ML_P6_B200_48XLARGE = ReservedCapacityInstanceType.ML_P6_B200_48XLARGE
ML_P4DE_24XLARGE = ReservedCapacityInstanceType.ML_P4DE_24XLARGE
ML_P6E_GB200_36XLARGE = ReservedCapacityInstanceType.ML_P6E_GB200_36XLARGE
ML_P5_4XLARGE = ReservedCapacityInstanceType.ML_P5_4XLARGE
ML_P6_B300_48XLARGE = ReservedCapacityInstanceType.ML_P6_B300_48XLARGE
PENDING = ReservedCapacityStatus.PENDING
ACTIVE = ReservedCapacityStatus.ACTIVE
SCHEDULED = ReservedCapacityStatus.SCHEDULED
EXPIRED = ReservedCapacityStatus.EXPIRED
FAILED = ReservedCapacityStatus.FAILED
ULTRASERVER = ReservedCapacityType.ULTRASERVER
INSTANCE = ReservedCapacityType.INSTANCE
CREATIONTIME = ResourceCatalogSortBy.CREATIONTIME
ASCENDING = ResourceCatalogSortOrder.ASCENDING
DESCENDING = ResourceCatalogSortOrder.DESCENDING
LEND = ResourceSharingStrategy.LEND
DONTLEND = ResourceSharingStrategy.DONTLEND
LENDANDBORROW = ResourceSharingStrategy.LENDANDBORROW
TRAININGJOB = ResourceType.TRAININGJOB
EXPERIMENT = ResourceType.EXPERIMENT
EXPERIMENTTRIAL = ResourceType.EXPERIMENTTRIAL
EXPERIMENTTRIALCOMPONENT = ResourceType.EXPERIMENTTRIALCOMPONENT
ENDPOINT = ResourceType.ENDPOINT
MODEL = ResourceType.MODEL
MODELPACKAGE = ResourceType.MODELPACKAGE
MODELPACKAGEGROUP = ResourceType.MODELPACKAGEGROUP
PIPELINE = ResourceType.PIPELINE
PIPELINEEXECUTION = ResourceType.PIPELINEEXECUTION
FEATUREGROUP = ResourceType.FEATUREGROUP
FEATUREMETADATA = ResourceType.FEATUREMETADATA
IMAGE = ResourceType.IMAGE
IMAGEVERSION = ResourceType.IMAGEVERSION
PROJECT = ResourceType.PROJECT
HYPERPARAMETERTUNINGJOB = ResourceType.HYPERPARAMETERTUNINGJOB
MODELCARD = ResourceType.MODELCARD
PIPELINEVERSION = ResourceType.PIPELINEVERSION
RETAIN = RetentionType.RETAIN
DELETE = RetentionType.DELETE
ENABLED = RootAccess.ENABLED
DISABLED = RootAccess.DISABLED
LEAST_OUTSTANDING_REQUESTS = RoutingStrategy.LEAST_OUTSTANDING_REQUESTS
RANDOM = RoutingStrategy.RANDOM
INPROGRESS = RuleEvaluationStatus.INPROGRESS
NOISSUESFOUND = RuleEvaluationStatus.NOISSUESFOUND
ISSUESFOUND = RuleEvaluationStatus.ISSUESFOUND
ERROR = RuleEvaluationStatus.ERROR
STOPPING = RuleEvaluationStatus.STOPPING
STOPPED = RuleEvaluationStatus.STOPPED
FULLYREPLICATED = S3DataDistribution.FULLYREPLICATED
SHARDEDBYS3KEY = S3DataDistribution.SHARDEDBYS3KEY
MANIFESTFILE = S3DataType.MANIFESTFILE
S3PREFIX = S3DataType.S3PREFIX
AUGMENTEDMANIFESTFILE = S3DataType.AUGMENTEDMANIFESTFILE
CONVERSE = S3DataType.CONVERSE
S3PREFIX = S3ModelDataType.S3PREFIX
S3OBJECT = S3ModelDataType.S3OBJECT
SAGEMAKER_DISTRIBUTION = SageMakerImageName.SAGEMAKER_DISTRIBUTION
TRAINING_JOB = SageMakerResourceName.TRAINING_JOB
HYPERPOD_CLUSTER = SageMakerResourceName.HYPERPOD_CLUSTER
ENDPOINT = SageMakerResourceName.ENDPOINT
ENABLED = SagemakerServicecatalogStatus.ENABLED
DISABLED = SagemakerServicecatalogStatus.DISABLED
PENDING = ScheduleStatus.PENDING
FAILED = ScheduleStatus.FAILED
SCHEDULED = ScheduleStatus.SCHEDULED
STOPPED = ScheduleStatus.STOPPED
CREATING = SchedulerResourceStatus.CREATING
CREATEFAILED = SchedulerResourceStatus.CREATEFAILED
CREATEROLLBACKFAILED = SchedulerResourceStatus.CREATEROLLBACKFAILED
CREATED = SchedulerResourceStatus.CREATED
UPDATING = SchedulerResourceStatus.UPDATING
UPDATEFAILED = SchedulerResourceStatus.UPDATEFAILED
UPDATEROLLBACKFAILED = SchedulerResourceStatus.UPDATEROLLBACKFAILED
UPDATED = SchedulerResourceStatus.UPDATED
DELETING = SchedulerResourceStatus.DELETING
DELETEFAILED = SchedulerResourceStatus.DELETEFAILED
DELETEROLLBACKFAILED = SchedulerResourceStatus.DELETEROLLBACKFAILED
DELETED = SchedulerResourceStatus.DELETED
ASCENDING = SearchSortOrder.ASCENDING
DESCENDING = SearchSortOrder.DESCENDING
STARTING = SecondaryStatus.STARTING
LAUNCHINGMLINSTANCES = SecondaryStatus.LAUNCHINGMLINSTANCES
PREPARINGTRAININGSTACK = SecondaryStatus.PREPARINGTRAININGSTACK
DOWNLOADING = SecondaryStatus.DOWNLOADING
DOWNLOADINGTRAININGIMAGE = SecondaryStatus.DOWNLOADINGTRAININGIMAGE
TRAINING = SecondaryStatus.TRAINING
UPLOADING = SecondaryStatus.UPLOADING
STOPPING = SecondaryStatus.STOPPING
STOPPED = SecondaryStatus.STOPPED
MAXRUNTIMEEXCEEDED = SecondaryStatus.MAXRUNTIMEEXCEEDED
COMPLETED = SecondaryStatus.COMPLETED
FAILED = SecondaryStatus.FAILED
INTERRUPTED = SecondaryStatus.INTERRUPTED
MAXWAITTIMEEXCEEDED = SecondaryStatus.MAXWAITTIMEEXCEEDED
UPDATING = SecondaryStatus.UPDATING
RESTARTING = SecondaryStatus.RESTARTING
PENDING = SecondaryStatus.PENDING
FINETUNING = ServerlessJobType.FINETUNING
EVALUATION = ServerlessJobType.EVALUATION
PRIVATE = SharingType.PRIVATE
SHARED = SharingType.SHARED
ALL = SkipModelValidation.ALL
NONE = SkipModelValidation.NONE
PENDING = SoftwareUpdateStatus.PENDING
INPROGRESS = SoftwareUpdateStatus.INPROGRESS
SUCCEEDED = SoftwareUpdateStatus.SUCCEEDED
FAILED = SoftwareUpdateStatus.FAILED
ROLLBACKINPROGRESS = SoftwareUpdateStatus.ROLLBACKINPROGRESS
ROLLBACKCOMPLETE = SoftwareUpdateStatus.ROLLBACKCOMPLETE
NAME = SortActionsBy.NAME
CREATIONTIME = SortActionsBy.CREATIONTIME
CREATIONTIME = SortArtifactsBy.CREATIONTIME
SOURCEARN = SortAssociationsBy.SOURCEARN
DESTINATIONARN = SortAssociationsBy.DESTINATIONARN
SOURCETYPE = SortAssociationsBy.SOURCETYPE
DESTINATIONTYPE = SortAssociationsBy.DESTINATIONTYPE
CREATIONTIME = SortAssociationsBy.CREATIONTIME
NAME = SortBy.NAME
CREATIONTIME = SortBy.CREATIONTIME
STATUS = SortBy.STATUS
NAME = SortClusterSchedulerConfigBy.NAME
CREATIONTIME = SortClusterSchedulerConfigBy.CREATIONTIME
STATUS = SortClusterSchedulerConfigBy.STATUS
NAME = SortContextsBy.NAME
CREATIONTIME = SortContextsBy.CREATIONTIME
NAME = SortExperimentsBy.NAME
CREATIONTIME = SortExperimentsBy.CREATIONTIME
NAME = SortInferenceExperimentsBy.NAME
CREATIONTIME = SortInferenceExperimentsBy.CREATIONTIME
STATUS = SortInferenceExperimentsBy.STATUS
NAME = SortLineageGroupsBy.NAME
CREATIONTIME = SortLineageGroupsBy.CREATIONTIME
NAME = SortMlflowAppBy.NAME
CREATIONTIME = SortMlflowAppBy.CREATIONTIME
STATUS = SortMlflowAppBy.STATUS
ASCENDING = SortOrder.ASCENDING
DESCENDING = SortOrder.DESCENDING
CREATIONTIME = SortPipelineExecutionsBy.CREATIONTIME
PIPELINEEXECUTIONARN = SortPipelineExecutionsBy.PIPELINEEXECUTIONARN
NAME = SortPipelinesBy.NAME
CREATIONTIME = SortPipelinesBy.CREATIONTIME
NAME = SortQuotaBy.NAME
CREATIONTIME = SortQuotaBy.CREATIONTIME
STATUS = SortQuotaBy.STATUS
CLUSTERARN = SortQuotaBy.CLUSTERARN
NAME = SortTrackingServerBy.NAME
CREATIONTIME = SortTrackingServerBy.CREATIONTIME
STATUS = SortTrackingServerBy.STATUS
NAME = SortTrialComponentsBy.NAME
CREATIONTIME = SortTrialComponentsBy.CREATIONTIME
NAME = SortTrialsBy.NAME
CREATIONTIME = SortTrialsBy.CREATIONTIME
CREATIONTIME = SpaceSortKey.CREATIONTIME
LASTMODIFIEDTIME = SpaceSortKey.LASTMODIFIEDTIME
DELETING = SpaceStatus.DELETING
FAILED = SpaceStatus.FAILED
INSERVICE = SpaceStatus.INSERVICE
PENDING = SpaceStatus.PENDING
UPDATING = SpaceStatus.UPDATING
UPDATE_FAILED = SpaceStatus.UPDATE_FAILED
DELETE_FAILED = SpaceStatus.DELETE_FAILED
NONE = SplitType.NONE
LINE = SplitType.LINE
RECORDIO = SplitType.RECORDIO
TFRECORD = SplitType.TFRECORD
CREATING = StageStatus.CREATING
READYTODEPLOY = StageStatus.READYTODEPLOY
STARTING = StageStatus.STARTING
INPROGRESS = StageStatus.INPROGRESS
DEPLOYED = StageStatus.DEPLOYED
FAILED = StageStatus.FAILED
STOPPING = StageStatus.STOPPING
STOPPED = StageStatus.STOPPED
AVERAGE = Statistic.AVERAGE
MINIMUM = Statistic.MINIMUM
MAXIMUM = Statistic.MAXIMUM
SAMPLECOUNT = Statistic.SAMPLECOUNT
SUM = Statistic.SUM
STARTING = StepStatus.STARTING
EXECUTING = StepStatus.EXECUTING
STOPPING = StepStatus.STOPPING
STOPPED = StepStatus.STOPPED
FAILED = StepStatus.FAILED
SUCCEEDED = StepStatus.SUCCEEDED
STANDARD = StorageType.STANDARD
INMEMORY = StorageType.INMEMORY
JUPYTERSERVER = StudioLifecycleConfigAppType.JUPYTERSERVER
KERNELGATEWAY = StudioLifecycleConfigAppType.KERNELGATEWAY
CODEEDITOR = StudioLifecycleConfigAppType.CODEEDITOR
JUPYTERLAB = StudioLifecycleConfigAppType.JUPYTERLAB
CREATIONTIME = StudioLifecycleConfigSortKey.CREATIONTIME
LASTMODIFIEDTIME = StudioLifecycleConfigSortKey.LASTMODIFIEDTIME
NAME = StudioLifecycleConfigSortKey.NAME
ENABLED = StudioWebPortal.ENABLED
DISABLED = StudioWebPortal.DISABLED
DEFAULT = TableFormat.DEFAULT
GLUE = TableFormat.GLUE
ICEBERG = TableFormat.ICEBERG
ENABLED = TagPropagation.ENABLED
DISABLED = TagPropagation.DISABLED
LAMBDA = TargetDevice.LAMBDA
ML_M4 = TargetDevice.ML_M4
ML_M5 = TargetDevice.ML_M5
ML_M6G = TargetDevice.ML_M6G
ML_C4 = TargetDevice.ML_C4
ML_C5 = TargetDevice.ML_C5
ML_C6G = TargetDevice.ML_C6G
ML_P2 = TargetDevice.ML_P2
ML_P3 = TargetDevice.ML_P3
ML_G4DN = TargetDevice.ML_G4DN
ML_INF1 = TargetDevice.ML_INF1
ML_INF2 = TargetDevice.ML_INF2
ML_TRN1 = TargetDevice.ML_TRN1
ML_EIA2 = TargetDevice.ML_EIA2
JETSON_TX1 = TargetDevice.JETSON_TX1
JETSON_TX2 = TargetDevice.JETSON_TX2
JETSON_NANO = TargetDevice.JETSON_NANO
JETSON_XAVIER = TargetDevice.JETSON_XAVIER
RASP3B = TargetDevice.RASP3B
RASP4B = TargetDevice.RASP4B
IMX8QM = TargetDevice.IMX8QM
DEEPLENS = TargetDevice.DEEPLENS
RK3399 = TargetDevice.RK3399
RK3288 = TargetDevice.RK3288
AISAGE = TargetDevice.AISAGE
SBE_C = TargetDevice.SBE_C
QCS605 = TargetDevice.QCS605
QCS603 = TargetDevice.QCS603
SITARA_AM57X = TargetDevice.SITARA_AM57X
AMBA_CV2 = TargetDevice.AMBA_CV2
AMBA_CV22 = TargetDevice.AMBA_CV22
AMBA_CV25 = TargetDevice.AMBA_CV25
X86_WIN32 = TargetDevice.X86_WIN32
X86_WIN64 = TargetDevice.X86_WIN64
COREML = TargetDevice.COREML
JACINTO_TDA4VM = TargetDevice.JACINTO_TDA4VM
IMX8MPLUS = TargetDevice.IMX8MPLUS
INTEL_GRAPHICS = TargetPlatformAccelerator.INTEL_GRAPHICS
MALI = TargetPlatformAccelerator.MALI
NVIDIA = TargetPlatformAccelerator.NVIDIA
NNA = TargetPlatformAccelerator.NNA
X86_64 = TargetPlatformArch.X86_64
X86 = TargetPlatformArch.X86
ARM64 = TargetPlatformArch.ARM64
ARM_EABI = TargetPlatformArch.ARM_EABI
ARM_EABIHF = TargetPlatformArch.ARM_EABIHF
ANDROID = TargetPlatformOs.ANDROID
LINUX = TargetPlatformOs.LINUX
ONDEMAND = ThroughputMode.ONDEMAND
PROVISIONED = ThroughputMode.PROVISIONED
MAINTENANCEINPROGRESS = TrackingServerMaintenanceStatus.MAINTENANCEINPROGRESS
MAINTENANCECOMPLETE = TrackingServerMaintenanceStatus.MAINTENANCECOMPLETE
MAINTENANCEFAILED = TrackingServerMaintenanceStatus.MAINTENANCEFAILED
SMALL = TrackingServerSize.SMALL
MEDIUM = TrackingServerSize.MEDIUM
LARGE = TrackingServerSize.LARGE
CREATING = TrackingServerStatus.CREATING
CREATED = TrackingServerStatus.CREATED
CREATEFAILED = TrackingServerStatus.CREATEFAILED
UPDATING = TrackingServerStatus.UPDATING
UPDATED = TrackingServerStatus.UPDATED
UPDATEFAILED = TrackingServerStatus.UPDATEFAILED
DELETING = TrackingServerStatus.DELETING
DELETEFAILED = TrackingServerStatus.DELETEFAILED
STOPPING = TrackingServerStatus.STOPPING
STOPPED = TrackingServerStatus.STOPPED
STOPFAILED = TrackingServerStatus.STOPFAILED
STARTING = TrackingServerStatus.STARTING
STARTED = TrackingServerStatus.STARTED
STARTFAILED = TrackingServerStatus.STARTFAILED
MAINTENANCEINPROGRESS = TrackingServerStatus.MAINTENANCEINPROGRESS
MAINTENANCECOMPLETE = TrackingServerStatus.MAINTENANCECOMPLETE
MAINTENANCEFAILED = TrackingServerStatus.MAINTENANCEFAILED
ALL_AT_ONCE = TrafficRoutingConfigType.ALL_AT_ONCE
CANARY = TrafficRoutingConfigType.CANARY
LINEAR = TrafficRoutingConfigType.LINEAR
PHASES = TrafficType.PHASES
STAIRS = TrafficType.STAIRS
PIPE = TrainingInputMode.PIPE
FILE = TrainingInputMode.FILE
FASTFILE = TrainingInputMode.FASTFILE
ML_M4_XLARGE = TrainingInstanceType.ML_M4_XLARGE
ML_M4_2XLARGE = TrainingInstanceType.ML_M4_2XLARGE
ML_M4_4XLARGE = TrainingInstanceType.ML_M4_4XLARGE
ML_M4_10XLARGE = TrainingInstanceType.ML_M4_10XLARGE
ML_M4_16XLARGE = TrainingInstanceType.ML_M4_16XLARGE
ML_G4DN_XLARGE = TrainingInstanceType.ML_G4DN_XLARGE
ML_G4DN_2XLARGE = TrainingInstanceType.ML_G4DN_2XLARGE
ML_G4DN_4XLARGE = TrainingInstanceType.ML_G4DN_4XLARGE
ML_G4DN_8XLARGE = TrainingInstanceType.ML_G4DN_8XLARGE
ML_G4DN_12XLARGE = TrainingInstanceType.ML_G4DN_12XLARGE
ML_G4DN_16XLARGE = TrainingInstanceType.ML_G4DN_16XLARGE
ML_M5_LARGE = TrainingInstanceType.ML_M5_LARGE
ML_M5_XLARGE = TrainingInstanceType.ML_M5_XLARGE
ML_M5_2XLARGE = TrainingInstanceType.ML_M5_2XLARGE
ML_M5_4XLARGE = TrainingInstanceType.ML_M5_4XLARGE
ML_M5_12XLARGE = TrainingInstanceType.ML_M5_12XLARGE
ML_M5_24XLARGE = TrainingInstanceType.ML_M5_24XLARGE
ML_C4_XLARGE = TrainingInstanceType.ML_C4_XLARGE
ML_C4_2XLARGE = TrainingInstanceType.ML_C4_2XLARGE
ML_C4_4XLARGE = TrainingInstanceType.ML_C4_4XLARGE
ML_C4_8XLARGE = TrainingInstanceType.ML_C4_8XLARGE
ML_P2_XLARGE = TrainingInstanceType.ML_P2_XLARGE
ML_P2_8XLARGE = TrainingInstanceType.ML_P2_8XLARGE
ML_P2_16XLARGE = TrainingInstanceType.ML_P2_16XLARGE
ML_P3_2XLARGE = TrainingInstanceType.ML_P3_2XLARGE
ML_P3_8XLARGE = TrainingInstanceType.ML_P3_8XLARGE
ML_P3_16XLARGE = TrainingInstanceType.ML_P3_16XLARGE
ML_P3DN_24XLARGE = TrainingInstanceType.ML_P3DN_24XLARGE
ML_P4D_24XLARGE = TrainingInstanceType.ML_P4D_24XLARGE
ML_P4DE_24XLARGE = TrainingInstanceType.ML_P4DE_24XLARGE
ML_P5_48XLARGE = TrainingInstanceType.ML_P5_48XLARGE
ML_P5E_48XLARGE = TrainingInstanceType.ML_P5E_48XLARGE
ML_P5EN_48XLARGE = TrainingInstanceType.ML_P5EN_48XLARGE
ML_C5_XLARGE = TrainingInstanceType.ML_C5_XLARGE
ML_C5_2XLARGE = TrainingInstanceType.ML_C5_2XLARGE
ML_C5_4XLARGE = TrainingInstanceType.ML_C5_4XLARGE
ML_C5_9XLARGE = TrainingInstanceType.ML_C5_9XLARGE
ML_C5_18XLARGE = TrainingInstanceType.ML_C5_18XLARGE
ML_C5N_XLARGE = TrainingInstanceType.ML_C5N_XLARGE
ML_C5N_2XLARGE = TrainingInstanceType.ML_C5N_2XLARGE
ML_C5N_4XLARGE = TrainingInstanceType.ML_C5N_4XLARGE
ML_C5N_9XLARGE = TrainingInstanceType.ML_C5N_9XLARGE
ML_C5N_18XLARGE = TrainingInstanceType.ML_C5N_18XLARGE
ML_G5_XLARGE = TrainingInstanceType.ML_G5_XLARGE
ML_G5_2XLARGE = TrainingInstanceType.ML_G5_2XLARGE
ML_G5_4XLARGE = TrainingInstanceType.ML_G5_4XLARGE
ML_G5_8XLARGE = TrainingInstanceType.ML_G5_8XLARGE
ML_G5_16XLARGE = TrainingInstanceType.ML_G5_16XLARGE
ML_G5_12XLARGE = TrainingInstanceType.ML_G5_12XLARGE
ML_G5_24XLARGE = TrainingInstanceType.ML_G5_24XLARGE
ML_G5_48XLARGE = TrainingInstanceType.ML_G5_48XLARGE
ML_G6_XLARGE = TrainingInstanceType.ML_G6_XLARGE
ML_G6_2XLARGE = TrainingInstanceType.ML_G6_2XLARGE
ML_G6_4XLARGE = TrainingInstanceType.ML_G6_4XLARGE
ML_G6_8XLARGE = TrainingInstanceType.ML_G6_8XLARGE
ML_G6_16XLARGE = TrainingInstanceType.ML_G6_16XLARGE
ML_G6_12XLARGE = TrainingInstanceType.ML_G6_12XLARGE
ML_G6_24XLARGE = TrainingInstanceType.ML_G6_24XLARGE
ML_G6_48XLARGE = TrainingInstanceType.ML_G6_48XLARGE
ML_G6E_XLARGE = TrainingInstanceType.ML_G6E_XLARGE
ML_G6E_2XLARGE = TrainingInstanceType.ML_G6E_2XLARGE
ML_G6E_4XLARGE = TrainingInstanceType.ML_G6E_4XLARGE
ML_G6E_8XLARGE = TrainingInstanceType.ML_G6E_8XLARGE
ML_G6E_16XLARGE = TrainingInstanceType.ML_G6E_16XLARGE
ML_G6E_12XLARGE = TrainingInstanceType.ML_G6E_12XLARGE
ML_G6E_24XLARGE = TrainingInstanceType.ML_G6E_24XLARGE
ML_G6E_48XLARGE = TrainingInstanceType.ML_G6E_48XLARGE
ML_TRN1_2XLARGE = TrainingInstanceType.ML_TRN1_2XLARGE
ML_TRN1_32XLARGE = TrainingInstanceType.ML_TRN1_32XLARGE
ML_TRN1N_32XLARGE = TrainingInstanceType.ML_TRN1N_32XLARGE
ML_TRN2_48XLARGE = TrainingInstanceType.ML_TRN2_48XLARGE
ML_M6I_LARGE = TrainingInstanceType.ML_M6I_LARGE
ML_M6I_XLARGE = TrainingInstanceType.ML_M6I_XLARGE
ML_M6I_2XLARGE = TrainingInstanceType.ML_M6I_2XLARGE
ML_M6I_4XLARGE = TrainingInstanceType.ML_M6I_4XLARGE
ML_M6I_8XLARGE = TrainingInstanceType.ML_M6I_8XLARGE
ML_M6I_12XLARGE = TrainingInstanceType.ML_M6I_12XLARGE
ML_M6I_16XLARGE = TrainingInstanceType.ML_M6I_16XLARGE
ML_M6I_24XLARGE = TrainingInstanceType.ML_M6I_24XLARGE
ML_M6I_32XLARGE = TrainingInstanceType.ML_M6I_32XLARGE
ML_C6I_XLARGE = TrainingInstanceType.ML_C6I_XLARGE
ML_C6I_2XLARGE = TrainingInstanceType.ML_C6I_2XLARGE
ML_C6I_8XLARGE = TrainingInstanceType.ML_C6I_8XLARGE
ML_C6I_4XLARGE = TrainingInstanceType.ML_C6I_4XLARGE
ML_C6I_12XLARGE = TrainingInstanceType.ML_C6I_12XLARGE
ML_C6I_16XLARGE = TrainingInstanceType.ML_C6I_16XLARGE
ML_C6I_24XLARGE = TrainingInstanceType.ML_C6I_24XLARGE
ML_C6I_32XLARGE = TrainingInstanceType.ML_C6I_32XLARGE
ML_R5D_LARGE = TrainingInstanceType.ML_R5D_LARGE
ML_R5D_XLARGE = TrainingInstanceType.ML_R5D_XLARGE
ML_R5D_2XLARGE = TrainingInstanceType.ML_R5D_2XLARGE
ML_R5D_4XLARGE = TrainingInstanceType.ML_R5D_4XLARGE
ML_R5D_8XLARGE = TrainingInstanceType.ML_R5D_8XLARGE
ML_R5D_12XLARGE = TrainingInstanceType.ML_R5D_12XLARGE
ML_R5D_16XLARGE = TrainingInstanceType.ML_R5D_16XLARGE
ML_R5D_24XLARGE = TrainingInstanceType.ML_R5D_24XLARGE
ML_T3_MEDIUM = TrainingInstanceType.ML_T3_MEDIUM
ML_T3_LARGE = TrainingInstanceType.ML_T3_LARGE
ML_T3_XLARGE = TrainingInstanceType.ML_T3_XLARGE
ML_T3_2XLARGE = TrainingInstanceType.ML_T3_2XLARGE
ML_R5_LARGE = TrainingInstanceType.ML_R5_LARGE
ML_R5_XLARGE = TrainingInstanceType.ML_R5_XLARGE
ML_R5_2XLARGE = TrainingInstanceType.ML_R5_2XLARGE
ML_R5_4XLARGE = TrainingInstanceType.ML_R5_4XLARGE
ML_R5_8XLARGE = TrainingInstanceType.ML_R5_8XLARGE
ML_R5_12XLARGE = TrainingInstanceType.ML_R5_12XLARGE
ML_R5_16XLARGE = TrainingInstanceType.ML_R5_16XLARGE
ML_R5_24XLARGE = TrainingInstanceType.ML_R5_24XLARGE
ML_P6_B200_48XLARGE = TrainingInstanceType.ML_P6_B200_48XLARGE
ML_M7I_LARGE = TrainingInstanceType.ML_M7I_LARGE
ML_M7I_XLARGE = TrainingInstanceType.ML_M7I_XLARGE
ML_M7I_2XLARGE = TrainingInstanceType.ML_M7I_2XLARGE
ML_M7I_4XLARGE = TrainingInstanceType.ML_M7I_4XLARGE
ML_M7I_8XLARGE = TrainingInstanceType.ML_M7I_8XLARGE
ML_M7I_12XLARGE = TrainingInstanceType.ML_M7I_12XLARGE
ML_M7I_16XLARGE = TrainingInstanceType.ML_M7I_16XLARGE
ML_M7I_24XLARGE = TrainingInstanceType.ML_M7I_24XLARGE
ML_M7I_48XLARGE = TrainingInstanceType.ML_M7I_48XLARGE
ML_C7I_LARGE = TrainingInstanceType.ML_C7I_LARGE
ML_C7I_XLARGE = TrainingInstanceType.ML_C7I_XLARGE
ML_C7I_2XLARGE = TrainingInstanceType.ML_C7I_2XLARGE
ML_C7I_4XLARGE = TrainingInstanceType.ML_C7I_4XLARGE
ML_C7I_8XLARGE = TrainingInstanceType.ML_C7I_8XLARGE
ML_C7I_12XLARGE = TrainingInstanceType.ML_C7I_12XLARGE
ML_C7I_16XLARGE = TrainingInstanceType.ML_C7I_16XLARGE
ML_C7I_24XLARGE = TrainingInstanceType.ML_C7I_24XLARGE
ML_C7I_48XLARGE = TrainingInstanceType.ML_C7I_48XLARGE
ML_R7I_LARGE = TrainingInstanceType.ML_R7I_LARGE
ML_R7I_XLARGE = TrainingInstanceType.ML_R7I_XLARGE
ML_R7I_2XLARGE = TrainingInstanceType.ML_R7I_2XLARGE
ML_R7I_4XLARGE = TrainingInstanceType.ML_R7I_4XLARGE
ML_R7I_8XLARGE = TrainingInstanceType.ML_R7I_8XLARGE
ML_R7I_12XLARGE = TrainingInstanceType.ML_R7I_12XLARGE
ML_R7I_16XLARGE = TrainingInstanceType.ML_R7I_16XLARGE
ML_R7I_24XLARGE = TrainingInstanceType.ML_R7I_24XLARGE
ML_R7I_48XLARGE = TrainingInstanceType.ML_R7I_48XLARGE
ML_P6E_GB200_36XLARGE = TrainingInstanceType.ML_P6E_GB200_36XLARGE
ML_P5_4XLARGE = TrainingInstanceType.ML_P5_4XLARGE
ML_P6_B300_48XLARGE = TrainingInstanceType.ML_P6_B300_48XLARGE
OFF = TrainingJobEarlyStoppingType.OFF
AUTO = TrainingJobEarlyStoppingType.AUTO
NAME = TrainingJobSortByOptions.NAME
CREATIONTIME = TrainingJobSortByOptions.CREATIONTIME
STATUS = TrainingJobSortByOptions.STATUS
FINALOBJECTIVEMETRICVALUE = TrainingJobSortByOptions.FINALOBJECTIVEMETRICVALUE
INPROGRESS = TrainingJobStatus.INPROGRESS
COMPLETED = TrainingJobStatus.COMPLETED
FAILED = TrainingJobStatus.FAILED
STOPPING = TrainingJobStatus.STOPPING
STOPPED = TrainingJobStatus.STOPPED
DELETING = TrainingJobStatus.DELETING
STATUS = TrainingPlanFilterName.STATUS
TRAININGPLANNAME = TrainingPlanSortBy.TRAININGPLANNAME
STARTTIME = TrainingPlanSortBy.STARTTIME
STATUS = TrainingPlanSortBy.STATUS
ASCENDING = TrainingPlanSortOrder.ASCENDING
DESCENDING = TrainingPlanSortOrder.DESCENDING
PENDING = TrainingPlanStatus.PENDING
ACTIVE = TrainingPlanStatus.ACTIVE
SCHEDULED = TrainingPlanStatus.SCHEDULED
EXPIRED = TrainingPlanStatus.EXPIRED
FAILED = TrainingPlanStatus.FAILED
PLATFORM = TrainingRepositoryAccessMode.PLATFORM
VPC = TrainingRepositoryAccessMode.VPC
ML_M4_XLARGE = TransformInstanceType.ML_M4_XLARGE
ML_M4_2XLARGE = TransformInstanceType.ML_M4_2XLARGE
ML_M4_4XLARGE = TransformInstanceType.ML_M4_4XLARGE
ML_M4_10XLARGE = TransformInstanceType.ML_M4_10XLARGE
ML_M4_16XLARGE = TransformInstanceType.ML_M4_16XLARGE
ML_C4_XLARGE = TransformInstanceType.ML_C4_XLARGE
ML_C4_2XLARGE = TransformInstanceType.ML_C4_2XLARGE
ML_C4_4XLARGE = TransformInstanceType.ML_C4_4XLARGE
ML_C4_8XLARGE = TransformInstanceType.ML_C4_8XLARGE
ML_P2_XLARGE = TransformInstanceType.ML_P2_XLARGE
ML_P2_8XLARGE = TransformInstanceType.ML_P2_8XLARGE
ML_P2_16XLARGE = TransformInstanceType.ML_P2_16XLARGE
ML_P3_2XLARGE = TransformInstanceType.ML_P3_2XLARGE
ML_P3_8XLARGE = TransformInstanceType.ML_P3_8XLARGE
ML_P3_16XLARGE = TransformInstanceType.ML_P3_16XLARGE
ML_C5_XLARGE = TransformInstanceType.ML_C5_XLARGE
ML_C5_2XLARGE = TransformInstanceType.ML_C5_2XLARGE
ML_C5_4XLARGE = TransformInstanceType.ML_C5_4XLARGE
ML_C5_9XLARGE = TransformInstanceType.ML_C5_9XLARGE
ML_C5_18XLARGE = TransformInstanceType.ML_C5_18XLARGE
ML_M5_LARGE = TransformInstanceType.ML_M5_LARGE
ML_M5_XLARGE = TransformInstanceType.ML_M5_XLARGE
ML_M5_2XLARGE = TransformInstanceType.ML_M5_2XLARGE
ML_M5_4XLARGE = TransformInstanceType.ML_M5_4XLARGE
ML_M5_12XLARGE = TransformInstanceType.ML_M5_12XLARGE
ML_M5_24XLARGE = TransformInstanceType.ML_M5_24XLARGE
ML_M6I_LARGE = TransformInstanceType.ML_M6I_LARGE
ML_M6I_XLARGE = TransformInstanceType.ML_M6I_XLARGE
ML_M6I_2XLARGE = TransformInstanceType.ML_M6I_2XLARGE
ML_M6I_4XLARGE = TransformInstanceType.ML_M6I_4XLARGE
ML_M6I_8XLARGE = TransformInstanceType.ML_M6I_8XLARGE
ML_M6I_12XLARGE = TransformInstanceType.ML_M6I_12XLARGE
ML_M6I_16XLARGE = TransformInstanceType.ML_M6I_16XLARGE
ML_M6I_24XLARGE = TransformInstanceType.ML_M6I_24XLARGE
ML_M6I_32XLARGE = TransformInstanceType.ML_M6I_32XLARGE
ML_C6I_LARGE = TransformInstanceType.ML_C6I_LARGE
ML_C6I_XLARGE = TransformInstanceType.ML_C6I_XLARGE
ML_C6I_2XLARGE = TransformInstanceType.ML_C6I_2XLARGE
ML_C6I_4XLARGE = TransformInstanceType.ML_C6I_4XLARGE
ML_C6I_8XLARGE = TransformInstanceType.ML_C6I_8XLARGE
ML_C6I_12XLARGE = TransformInstanceType.ML_C6I_12XLARGE
ML_C6I_16XLARGE = TransformInstanceType.ML_C6I_16XLARGE
ML_C6I_24XLARGE = TransformInstanceType.ML_C6I_24XLARGE
ML_C6I_32XLARGE = TransformInstanceType.ML_C6I_32XLARGE
ML_R6I_LARGE = TransformInstanceType.ML_R6I_LARGE
ML_R6I_XLARGE = TransformInstanceType.ML_R6I_XLARGE
ML_R6I_2XLARGE = TransformInstanceType.ML_R6I_2XLARGE
ML_R6I_4XLARGE = TransformInstanceType.ML_R6I_4XLARGE
ML_R6I_8XLARGE = TransformInstanceType.ML_R6I_8XLARGE
ML_R6I_12XLARGE = TransformInstanceType.ML_R6I_12XLARGE
ML_R6I_16XLARGE = TransformInstanceType.ML_R6I_16XLARGE
ML_R6I_24XLARGE = TransformInstanceType.ML_R6I_24XLARGE
ML_R6I_32XLARGE = TransformInstanceType.ML_R6I_32XLARGE
ML_M7I_LARGE = TransformInstanceType.ML_M7I_LARGE
ML_M7I_XLARGE = TransformInstanceType.ML_M7I_XLARGE
ML_M7I_2XLARGE = TransformInstanceType.ML_M7I_2XLARGE
ML_M7I_4XLARGE = TransformInstanceType.ML_M7I_4XLARGE
ML_M7I_8XLARGE = TransformInstanceType.ML_M7I_8XLARGE
ML_M7I_12XLARGE = TransformInstanceType.ML_M7I_12XLARGE
ML_M7I_16XLARGE = TransformInstanceType.ML_M7I_16XLARGE
ML_M7I_24XLARGE = TransformInstanceType.ML_M7I_24XLARGE
ML_M7I_48XLARGE = TransformInstanceType.ML_M7I_48XLARGE
ML_C7I_LARGE = TransformInstanceType.ML_C7I_LARGE
ML_C7I_XLARGE = TransformInstanceType.ML_C7I_XLARGE
ML_C7I_2XLARGE = TransformInstanceType.ML_C7I_2XLARGE
ML_C7I_4XLARGE = TransformInstanceType.ML_C7I_4XLARGE
ML_C7I_8XLARGE = TransformInstanceType.ML_C7I_8XLARGE
ML_C7I_12XLARGE = TransformInstanceType.ML_C7I_12XLARGE
ML_C7I_16XLARGE = TransformInstanceType.ML_C7I_16XLARGE
ML_C7I_24XLARGE = TransformInstanceType.ML_C7I_24XLARGE
ML_C7I_48XLARGE = TransformInstanceType.ML_C7I_48XLARGE
ML_R7I_LARGE = TransformInstanceType.ML_R7I_LARGE
ML_R7I_XLARGE = TransformInstanceType.ML_R7I_XLARGE
ML_R7I_2XLARGE = TransformInstanceType.ML_R7I_2XLARGE
ML_R7I_4XLARGE = TransformInstanceType.ML_R7I_4XLARGE
ML_R7I_8XLARGE = TransformInstanceType.ML_R7I_8XLARGE
ML_R7I_12XLARGE = TransformInstanceType.ML_R7I_12XLARGE
ML_R7I_16XLARGE = TransformInstanceType.ML_R7I_16XLARGE
ML_R7I_24XLARGE = TransformInstanceType.ML_R7I_24XLARGE
ML_R7I_48XLARGE = TransformInstanceType.ML_R7I_48XLARGE
ML_G4DN_XLARGE = TransformInstanceType.ML_G4DN_XLARGE
ML_G4DN_2XLARGE = TransformInstanceType.ML_G4DN_2XLARGE
ML_G4DN_4XLARGE = TransformInstanceType.ML_G4DN_4XLARGE
ML_G4DN_8XLARGE = TransformInstanceType.ML_G4DN_8XLARGE
ML_G4DN_12XLARGE = TransformInstanceType.ML_G4DN_12XLARGE
ML_G4DN_16XLARGE = TransformInstanceType.ML_G4DN_16XLARGE
ML_G5_XLARGE = TransformInstanceType.ML_G5_XLARGE
ML_G5_2XLARGE = TransformInstanceType.ML_G5_2XLARGE
ML_G5_4XLARGE = TransformInstanceType.ML_G5_4XLARGE
ML_G5_8XLARGE = TransformInstanceType.ML_G5_8XLARGE
ML_G5_12XLARGE = TransformInstanceType.ML_G5_12XLARGE
ML_G5_16XLARGE = TransformInstanceType.ML_G5_16XLARGE
ML_G5_24XLARGE = TransformInstanceType.ML_G5_24XLARGE
ML_G5_48XLARGE = TransformInstanceType.ML_G5_48XLARGE
ML_TRN1_2XLARGE = TransformInstanceType.ML_TRN1_2XLARGE
ML_TRN1_32XLARGE = TransformInstanceType.ML_TRN1_32XLARGE
ML_INF2_XLARGE = TransformInstanceType.ML_INF2_XLARGE
ML_INF2_8XLARGE = TransformInstanceType.ML_INF2_8XLARGE
ML_INF2_24XLARGE = TransformInstanceType.ML_INF2_24XLARGE
ML_INF2_48XLARGE = TransformInstanceType.ML_INF2_48XLARGE
ML_G6_XLARGE = TransformInstanceType.ML_G6_XLARGE
ML_G6_2XLARGE = TransformInstanceType.ML_G6_2XLARGE
ML_G6_4XLARGE = TransformInstanceType.ML_G6_4XLARGE
ML_G6_8XLARGE = TransformInstanceType.ML_G6_8XLARGE
ML_G6_12XLARGE = TransformInstanceType.ML_G6_12XLARGE
ML_G6_16XLARGE = TransformInstanceType.ML_G6_16XLARGE
ML_G6_24XLARGE = TransformInstanceType.ML_G6_24XLARGE
ML_G6_48XLARGE = TransformInstanceType.ML_G6_48XLARGE
INPROGRESS = TransformJobStatus.INPROGRESS
COMPLETED = TransformJobStatus.COMPLETED
FAILED = TransformJobStatus.FAILED
STOPPING = TransformJobStatus.STOPPING
STOPPED = TransformJobStatus.STOPPED
INPROGRESS = TrialComponentPrimaryStatus.INPROGRESS
COMPLETED = TrialComponentPrimaryStatus.COMPLETED
FAILED = TrialComponentPrimaryStatus.FAILED
STOPPING = TrialComponentPrimaryStatus.STOPPING
STOPPED = TrialComponentPrimaryStatus.STOPPED
SECONDS = TtlDurationUnit.SECONDS
MINUTES = TtlDurationUnit.MINUTES
HOURS = TtlDurationUnit.HOURS
DAYS = TtlDurationUnit.DAYS
WEEKS = TtlDurationUnit.WEEKS
OK = UltraServerHealthStatus.OK
IMPAIRED = UltraServerHealthStatus.IMPAIRED
INSUFFICIENT_DATA = UltraServerHealthStatus.INSUFFICIENT_DATA
CREATIONTIME = UserProfileSortKey.CREATIONTIME
LASTMODIFIEDTIME = UserProfileSortKey.LASTMODIFIEDTIME
DELETING = UserProfileStatus.DELETING
FAILED = UserProfileStatus.FAILED
INSERVICE = UserProfileStatus.INSERVICE
PENDING = UserProfileStatus.PENDING
UPDATING = UserProfileStatus.UPDATING
UPDATE_FAILED = UserProfileStatus.UPDATE_FAILED
DELETE_FAILED = UserProfileStatus.DELETE_FAILED
DESIREDINSTANCECOUNT = VariantPropertyType.DESIREDINSTANCECOUNT
DESIREDWEIGHT = VariantPropertyType.DESIREDWEIGHT
DATACAPTURECONFIG = VariantPropertyType.DATACAPTURECONFIG
CREATING = VariantStatus.CREATING
UPDATING = VariantStatus.UPDATING
DELETING = VariantStatus.DELETING
ACTIVATINGTRAFFIC = VariantStatus.ACTIVATINGTRAFFIC
BAKING = VariantStatus.BAKING
NOT_PROVIDED = VendorGuidance.NOT_PROVIDED
STABLE = VendorGuidance.STABLE
TO_BE_ARCHIVED = VendorGuidance.TO_BE_ARCHIVED
ARCHIVED = VendorGuidance.ARCHIVED
ATTACHING = VolumeAttachmentStatus.ATTACHING
ATTACHED = VolumeAttachmentStatus.ATTACHED
DETACHING = VolumeAttachmentStatus.DETACHING
DETACHED = VolumeAttachmentStatus.DETACHED
BUSY = VolumeAttachmentStatus.BUSY
AVAILABLE = WarmPoolResourceStatus.AVAILABLE
TERMINATED = WarmPoolResourceStatus.TERMINATED
REUSED = WarmPoolResourceStatus.REUSED
INUSE = WarmPoolResourceStatus.INUSE
IPV4 = WorkforceIpAddressType.IPV4
DUALSTACK = WorkforceIpAddressType.DUALSTACK
INITIALIZING = WorkforceStatus.INITIALIZING
UPDATING = WorkforceStatus.UPDATING
DELETING = WorkforceStatus.DELETING
FAILED = WorkforceStatus.FAILED
ACTIVE = WorkforceStatus.ACTIVE


@dataclass
class ResourceSpec:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_config_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sage_maker_image_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, AppInstanceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sage_maker_image_version_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.lifecycle_config_arn is not None:
            if hasattr(self.lifecycle_config_arn, 'to_dict'):
                props['LifecycleConfigArn'] = self.lifecycle_config_arn.to_dict()
            elif isinstance(self.lifecycle_config_arn, list):
                props['LifecycleConfigArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_config_arn
                ]
            else:
                props['LifecycleConfigArn'] = self.lifecycle_config_arn

        if self.sage_maker_image_arn is not None:
            if hasattr(self.sage_maker_image_arn, 'to_dict'):
                props['SageMakerImageArn'] = self.sage_maker_image_arn.to_dict()
            elif isinstance(self.sage_maker_image_arn, list):
                props['SageMakerImageArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sage_maker_image_arn
                ]
            else:
                props['SageMakerImageArn'] = self.sage_maker_image_arn

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        if self.sage_maker_image_version_arn is not None:
            if hasattr(self.sage_maker_image_version_arn, 'to_dict'):
                props['SageMakerImageVersionArn'] = self.sage_maker_image_version_arn.to_dict()
            elif isinstance(self.sage_maker_image_version_arn, list):
                props['SageMakerImageVersionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sage_maker_image_version_arn
                ]
            else:
                props['SageMakerImageVersionArn'] = self.sage_maker_image_version_arn

        return props


@dataclass
class App(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::App"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    recovery_mode: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    resource_spec: Optional[ResourceSpec] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    app_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    user_profile_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    app_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.recovery_mode is not None:
            # Serialize recovery_mode (handle intrinsic functions)
            if hasattr(self.recovery_mode, 'to_dict'):
                props["RecoveryMode"] = self.recovery_mode.to_dict()
            elif isinstance(self.recovery_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['RecoveryMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.recovery_mode
                ]
            else:
                props["RecoveryMode"] = self.recovery_mode

        if self.domain_id is not None:
            # Serialize domain_id (handle intrinsic functions)
            if hasattr(self.domain_id, 'to_dict'):
                props["DomainId"] = self.domain_id.to_dict()
            elif isinstance(self.domain_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_id
                ]
            else:
                props["DomainId"] = self.domain_id

        if self.resource_spec is not None:
            # Serialize resource_spec (handle intrinsic functions)
            if hasattr(self.resource_spec, 'to_dict'):
                props["ResourceSpec"] = self.resource_spec.to_dict()
            elif isinstance(self.resource_spec, list):
                # Serialize list items (may contain intrinsic functions)
                props['ResourceSpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_spec
                ]
            else:
                props["ResourceSpec"] = self.resource_spec

        if self.app_type is not None:
            # Serialize app_type (handle intrinsic functions)
            if hasattr(self.app_type, 'to_dict'):
                props["AppType"] = self.app_type.to_dict()
            elif isinstance(self.app_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['AppType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_type
                ]
            else:
                props["AppType"] = self.app_type

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.user_profile_name is not None:
            # Serialize user_profile_name (handle intrinsic functions)
            if hasattr(self.user_profile_name, 'to_dict'):
                props["UserProfileName"] = self.user_profile_name.to_dict()
            elif isinstance(self.user_profile_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['UserProfileName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_profile_name
                ]
            else:
                props["UserProfileName"] = self.user_profile_name

        if self.app_name is not None:
            # Serialize app_name (handle intrinsic functions)
            if hasattr(self.app_name, 'to_dict'):
                props["AppName"] = self.app_name.to_dict()
            elif isinstance(self.app_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['AppName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_name
                ]
            else:
                props["AppName"] = self.app_name

        return props

    @property
    def attr_app_arn(self) -> GetAtt:
        """Get the AppArn attribute."""
        return self.get_att("AppArn")

    @property
    def attr_built_in_lifecycle_config_arn(self) -> GetAtt:
        """Get the BuiltInLifecycleConfigArn attribute."""
        return self.get_att("BuiltInLifecycleConfigArn")




@dataclass
class CodeEditorAppImageConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_config: Optional[ContainerConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.container_config is not None:
            if hasattr(self.container_config, 'to_dict'):
                props['ContainerConfig'] = self.container_config.to_dict()
            elif isinstance(self.container_config, list):
                props['ContainerConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_config
                ]
            else:
                props['ContainerConfig'] = self.container_config

        return props


@dataclass
class ContainerConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_entrypoint: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_environment_variables: Optional[list[CustomImageContainerEnvironmentVariable]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_arguments: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.container_entrypoint is not None:
            if hasattr(self.container_entrypoint, 'to_dict'):
                props['ContainerEntrypoint'] = self.container_entrypoint.to_dict()
            elif isinstance(self.container_entrypoint, list):
                props['ContainerEntrypoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_entrypoint
                ]
            else:
                props['ContainerEntrypoint'] = self.container_entrypoint

        if self.container_environment_variables is not None:
            if hasattr(self.container_environment_variables, 'to_dict'):
                props['ContainerEnvironmentVariables'] = self.container_environment_variables.to_dict()
            elif isinstance(self.container_environment_variables, list):
                props['ContainerEnvironmentVariables'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_environment_variables
                ]
            else:
                props['ContainerEnvironmentVariables'] = self.container_environment_variables

        if self.container_arguments is not None:
            if hasattr(self.container_arguments, 'to_dict'):
                props['ContainerArguments'] = self.container_arguments.to_dict()
            elif isinstance(self.container_arguments, list):
                props['ContainerArguments'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_arguments
                ]
            else:
                props['ContainerArguments'] = self.container_arguments

        return props


@dataclass
class CustomImageContainerEnvironmentVariable:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class FileSystemConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mount_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_gid: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_uid: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mount_path is not None:
            if hasattr(self.mount_path, 'to_dict'):
                props['MountPath'] = self.mount_path.to_dict()
            elif isinstance(self.mount_path, list):
                props['MountPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mount_path
                ]
            else:
                props['MountPath'] = self.mount_path

        if self.default_gid is not None:
            if hasattr(self.default_gid, 'to_dict'):
                props['DefaultGid'] = self.default_gid.to_dict()
            elif isinstance(self.default_gid, list):
                props['DefaultGid'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_gid
                ]
            else:
                props['DefaultGid'] = self.default_gid

        if self.default_uid is not None:
            if hasattr(self.default_uid, 'to_dict'):
                props['DefaultUid'] = self.default_uid.to_dict()
            elif isinstance(self.default_uid, list):
                props['DefaultUid'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_uid
                ]
            else:
                props['DefaultUid'] = self.default_uid

        return props


@dataclass
class JupyterLabAppImageConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_config: Optional[ContainerConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.container_config is not None:
            if hasattr(self.container_config, 'to_dict'):
                props['ContainerConfig'] = self.container_config.to_dict()
            elif isinstance(self.container_config, list):
                props['ContainerConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_config
                ]
            else:
                props['ContainerConfig'] = self.container_config

        return props


@dataclass
class KernelGatewayImageConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kernel_specs: Optional[list[KernelSpec]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_system_config: Optional[FileSystemConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kernel_specs is not None:
            if hasattr(self.kernel_specs, 'to_dict'):
                props['KernelSpecs'] = self.kernel_specs.to_dict()
            elif isinstance(self.kernel_specs, list):
                props['KernelSpecs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kernel_specs
                ]
            else:
                props['KernelSpecs'] = self.kernel_specs

        if self.file_system_config is not None:
            if hasattr(self.file_system_config, 'to_dict'):
                props['FileSystemConfig'] = self.file_system_config.to_dict()
            elif isinstance(self.file_system_config, list):
                props['FileSystemConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_config
                ]
            else:
                props['FileSystemConfig'] = self.file_system_config

        return props


@dataclass
class KernelSpec:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.display_name is not None:
            if hasattr(self.display_name, 'to_dict'):
                props['DisplayName'] = self.display_name.to_dict()
            elif isinstance(self.display_name, list):
                props['DisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.display_name
                ]
            else:
                props['DisplayName'] = self.display_name

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class AppImageConfig(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::AppImageConfig"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kernel_gateway_image_config: Optional[KernelGatewayImageConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    code_editor_app_image_config: Optional[CodeEditorAppImageConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    app_image_config_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    jupyter_lab_app_image_config: Optional[JupyterLabAppImageConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kernel_gateway_image_config is not None:
            # Serialize kernel_gateway_image_config (handle intrinsic functions)
            if hasattr(self.kernel_gateway_image_config, 'to_dict'):
                props["KernelGatewayImageConfig"] = self.kernel_gateway_image_config.to_dict()
            elif isinstance(self.kernel_gateway_image_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['KernelGatewayImageConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kernel_gateway_image_config
                ]
            else:
                props["KernelGatewayImageConfig"] = self.kernel_gateway_image_config

        if self.code_editor_app_image_config is not None:
            # Serialize code_editor_app_image_config (handle intrinsic functions)
            if hasattr(self.code_editor_app_image_config, 'to_dict'):
                props["CodeEditorAppImageConfig"] = self.code_editor_app_image_config.to_dict()
            elif isinstance(self.code_editor_app_image_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['CodeEditorAppImageConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code_editor_app_image_config
                ]
            else:
                props["CodeEditorAppImageConfig"] = self.code_editor_app_image_config

        if self.app_image_config_name is not None:
            # Serialize app_image_config_name (handle intrinsic functions)
            if hasattr(self.app_image_config_name, 'to_dict'):
                props["AppImageConfigName"] = self.app_image_config_name.to_dict()
            elif isinstance(self.app_image_config_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['AppImageConfigName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_image_config_name
                ]
            else:
                props["AppImageConfigName"] = self.app_image_config_name

        if self.jupyter_lab_app_image_config is not None:
            # Serialize jupyter_lab_app_image_config (handle intrinsic functions)
            if hasattr(self.jupyter_lab_app_image_config, 'to_dict'):
                props["JupyterLabAppImageConfig"] = self.jupyter_lab_app_image_config.to_dict()
            elif isinstance(self.jupyter_lab_app_image_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['JupyterLabAppImageConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.jupyter_lab_app_image_config
                ]
            else:
                props["JupyterLabAppImageConfig"] = self.jupyter_lab_app_image_config

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_app_image_config_arn(self) -> GetAtt:
        """Get the AppImageConfigArn attribute."""
        return self.get_att("AppImageConfigArn")




@dataclass
class AlarmDetails:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    alarm_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.alarm_name is not None:
            if hasattr(self.alarm_name, 'to_dict'):
                props['AlarmName'] = self.alarm_name.to_dict()
            elif isinstance(self.alarm_name, list):
                props['AlarmName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.alarm_name
                ]
            else:
                props['AlarmName'] = self.alarm_name

        return props


@dataclass
class CapacitySizeConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, NodeUnavailabilityType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class ClusterAutoScalingConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mode: Optional[Union[str, ClusterAutoScalingMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auto_scaler_type: Optional[Union[str, ClusterAutoScalerType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mode is not None:
            if hasattr(self.mode, 'to_dict'):
                props['Mode'] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props['Mode'] = self.mode

        if self.auto_scaler_type is not None:
            if hasattr(self.auto_scaler_type, 'to_dict'):
                props['AutoScalerType'] = self.auto_scaler_type.to_dict()
            elif isinstance(self.auto_scaler_type, list):
                props['AutoScalerType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_scaler_type
                ]
            else:
                props['AutoScalerType'] = self.auto_scaler_type

        return props


@dataclass
class ClusterCapacityRequirements:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    spot: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_demand: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.spot is not None:
            if hasattr(self.spot, 'to_dict'):
                props['Spot'] = self.spot.to_dict()
            elif isinstance(self.spot, list):
                props['Spot'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.spot
                ]
            else:
                props['Spot'] = self.spot

        if self.on_demand is not None:
            if hasattr(self.on_demand, 'to_dict'):
                props['OnDemand'] = self.on_demand.to_dict()
            elif isinstance(self.on_demand, list):
                props['OnDemand'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_demand
                ]
            else:
                props['OnDemand'] = self.on_demand

        return props


@dataclass
class ClusterEbsVolumeConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size_in_gb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    root_volume: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.volume_size_in_gb is not None:
            if hasattr(self.volume_size_in_gb, 'to_dict'):
                props['VolumeSizeInGB'] = self.volume_size_in_gb.to_dict()
            elif isinstance(self.volume_size_in_gb, list):
                props['VolumeSizeInGB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size_in_gb
                ]
            else:
                props['VolumeSizeInGB'] = self.volume_size_in_gb

        if self.volume_kms_key_id is not None:
            if hasattr(self.volume_kms_key_id, 'to_dict'):
                props['VolumeKmsKeyId'] = self.volume_kms_key_id.to_dict()
            elif isinstance(self.volume_kms_key_id, list):
                props['VolumeKmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_kms_key_id
                ]
            else:
                props['VolumeKmsKeyId'] = self.volume_kms_key_id

        if self.root_volume is not None:
            if hasattr(self.root_volume, 'to_dict'):
                props['RootVolume'] = self.root_volume.to_dict()
            elif isinstance(self.root_volume, list):
                props['RootVolume'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.root_volume
                ]
            else:
                props['RootVolume'] = self.root_volume

        return props


@dataclass
class ClusterInstanceGroup:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_requirements: Optional[ClusterCapacityRequirements] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_storage_configs: Optional[list[ClusterInstanceStorageConfig]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kubernetes_config: Optional[ClusterKubernetesConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    life_cycle_config: Optional[ClusterLifeCycleConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    training_plan_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    threads_per_core: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    override_vpc_config: Optional[VpcConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_start_deep_health_checks: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    current_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scheduled_update_config: Optional[ScheduledUpdateConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    execution_role: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capacity_requirements is not None:
            if hasattr(self.capacity_requirements, 'to_dict'):
                props['CapacityRequirements'] = self.capacity_requirements.to_dict()
            elif isinstance(self.capacity_requirements, list):
                props['CapacityRequirements'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_requirements
                ]
            else:
                props['CapacityRequirements'] = self.capacity_requirements

        if self.instance_group_name is not None:
            if hasattr(self.instance_group_name, 'to_dict'):
                props['InstanceGroupName'] = self.instance_group_name.to_dict()
            elif isinstance(self.instance_group_name, list):
                props['InstanceGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_group_name
                ]
            else:
                props['InstanceGroupName'] = self.instance_group_name

        if self.instance_storage_configs is not None:
            if hasattr(self.instance_storage_configs, 'to_dict'):
                props['InstanceStorageConfigs'] = self.instance_storage_configs.to_dict()
            elif isinstance(self.instance_storage_configs, list):
                props['InstanceStorageConfigs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_storage_configs
                ]
            else:
                props['InstanceStorageConfigs'] = self.instance_storage_configs

        if self.kubernetes_config is not None:
            if hasattr(self.kubernetes_config, 'to_dict'):
                props['KubernetesConfig'] = self.kubernetes_config.to_dict()
            elif isinstance(self.kubernetes_config, list):
                props['KubernetesConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kubernetes_config
                ]
            else:
                props['KubernetesConfig'] = self.kubernetes_config

        if self.life_cycle_config is not None:
            if hasattr(self.life_cycle_config, 'to_dict'):
                props['LifeCycleConfig'] = self.life_cycle_config.to_dict()
            elif isinstance(self.life_cycle_config, list):
                props['LifeCycleConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.life_cycle_config
                ]
            else:
                props['LifeCycleConfig'] = self.life_cycle_config

        if self.training_plan_arn is not None:
            if hasattr(self.training_plan_arn, 'to_dict'):
                props['TrainingPlanArn'] = self.training_plan_arn.to_dict()
            elif isinstance(self.training_plan_arn, list):
                props['TrainingPlanArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.training_plan_arn
                ]
            else:
                props['TrainingPlanArn'] = self.training_plan_arn

        if self.threads_per_core is not None:
            if hasattr(self.threads_per_core, 'to_dict'):
                props['ThreadsPerCore'] = self.threads_per_core.to_dict()
            elif isinstance(self.threads_per_core, list):
                props['ThreadsPerCore'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.threads_per_core
                ]
            else:
                props['ThreadsPerCore'] = self.threads_per_core

        if self.override_vpc_config is not None:
            if hasattr(self.override_vpc_config, 'to_dict'):
                props['OverrideVpcConfig'] = self.override_vpc_config.to_dict()
            elif isinstance(self.override_vpc_config, list):
                props['OverrideVpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.override_vpc_config
                ]
            else:
                props['OverrideVpcConfig'] = self.override_vpc_config

        if self.instance_count is not None:
            if hasattr(self.instance_count, 'to_dict'):
                props['InstanceCount'] = self.instance_count.to_dict()
            elif isinstance(self.instance_count, list):
                props['InstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_count
                ]
            else:
                props['InstanceCount'] = self.instance_count

        if self.on_start_deep_health_checks is not None:
            if hasattr(self.on_start_deep_health_checks, 'to_dict'):
                props['OnStartDeepHealthChecks'] = self.on_start_deep_health_checks.to_dict()
            elif isinstance(self.on_start_deep_health_checks, list):
                props['OnStartDeepHealthChecks'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_start_deep_health_checks
                ]
            else:
                props['OnStartDeepHealthChecks'] = self.on_start_deep_health_checks

        if self.image_id is not None:
            if hasattr(self.image_id, 'to_dict'):
                props['ImageId'] = self.image_id.to_dict()
            elif isinstance(self.image_id, list):
                props['ImageId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_id
                ]
            else:
                props['ImageId'] = self.image_id

        if self.current_count is not None:
            if hasattr(self.current_count, 'to_dict'):
                props['CurrentCount'] = self.current_count.to_dict()
            elif isinstance(self.current_count, list):
                props['CurrentCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.current_count
                ]
            else:
                props['CurrentCount'] = self.current_count

        if self.scheduled_update_config is not None:
            if hasattr(self.scheduled_update_config, 'to_dict'):
                props['ScheduledUpdateConfig'] = self.scheduled_update_config.to_dict()
            elif isinstance(self.scheduled_update_config, list):
                props['ScheduledUpdateConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scheduled_update_config
                ]
            else:
                props['ScheduledUpdateConfig'] = self.scheduled_update_config

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        if self.execution_role is not None:
            if hasattr(self.execution_role, 'to_dict'):
                props['ExecutionRole'] = self.execution_role.to_dict()
            elif isinstance(self.execution_role, list):
                props['ExecutionRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role
                ]
            else:
                props['ExecutionRole'] = self.execution_role

        return props


@dataclass
class ClusterInstanceStorageConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs_volume_config: Optional[ClusterEbsVolumeConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ebs_volume_config is not None:
            if hasattr(self.ebs_volume_config, 'to_dict'):
                props['EbsVolumeConfig'] = self.ebs_volume_config.to_dict()
            elif isinstance(self.ebs_volume_config, list):
                props['EbsVolumeConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_volume_config
                ]
            else:
                props['EbsVolumeConfig'] = self.ebs_volume_config

        return props


@dataclass
class ClusterKubernetesConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    labels: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    taints: Optional[list[ClusterKubernetesTaint]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.labels is not None:
            if hasattr(self.labels, 'to_dict'):
                props['Labels'] = self.labels.to_dict()
            elif isinstance(self.labels, list):
                props['Labels'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.labels
                ]
            else:
                props['Labels'] = self.labels

        if self.taints is not None:
            if hasattr(self.taints, 'to_dict'):
                props['Taints'] = self.taints.to_dict()
            elif isinstance(self.taints, list):
                props['Taints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.taints
                ]
            else:
                props['Taints'] = self.taints

        return props


@dataclass
class ClusterKubernetesTaint:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    effect: Optional[Union[str, ClusterKubernetesTaintEffect, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.effect is not None:
            if hasattr(self.effect, 'to_dict'):
                props['Effect'] = self.effect.to_dict()
            elif isinstance(self.effect, list):
                props['Effect'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.effect
                ]
            else:
                props['Effect'] = self.effect

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class ClusterLifeCycleConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_create: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.source_s3_uri is not None:
            if hasattr(self.source_s3_uri, 'to_dict'):
                props['SourceS3Uri'] = self.source_s3_uri.to_dict()
            elif isinstance(self.source_s3_uri, list):
                props['SourceS3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_s3_uri
                ]
            else:
                props['SourceS3Uri'] = self.source_s3_uri

        if self.on_create is not None:
            if hasattr(self.on_create, 'to_dict'):
                props['OnCreate'] = self.on_create.to_dict()
            elif isinstance(self.on_create, list):
                props['OnCreate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_create
                ]
            else:
                props['OnCreate'] = self.on_create

        return props


@dataclass
class ClusterOrchestratorEksConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cluster_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cluster_arn is not None:
            if hasattr(self.cluster_arn, 'to_dict'):
                props['ClusterArn'] = self.cluster_arn.to_dict()
            elif isinstance(self.cluster_arn, list):
                props['ClusterArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cluster_arn
                ]
            else:
                props['ClusterArn'] = self.cluster_arn

        return props


@dataclass
class ClusterRestrictedInstanceGroup:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    override_vpc_config: Optional[VpcConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    on_start_deep_health_checks: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    environment_config: Optional[EnvironmentConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_storage_configs: Optional[list[ClusterInstanceStorageConfig]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    current_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    training_plan_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    threads_per_core: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    execution_role: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.override_vpc_config is not None:
            if hasattr(self.override_vpc_config, 'to_dict'):
                props['OverrideVpcConfig'] = self.override_vpc_config.to_dict()
            elif isinstance(self.override_vpc_config, list):
                props['OverrideVpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.override_vpc_config
                ]
            else:
                props['OverrideVpcConfig'] = self.override_vpc_config

        if self.instance_count is not None:
            if hasattr(self.instance_count, 'to_dict'):
                props['InstanceCount'] = self.instance_count.to_dict()
            elif isinstance(self.instance_count, list):
                props['InstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_count
                ]
            else:
                props['InstanceCount'] = self.instance_count

        if self.on_start_deep_health_checks is not None:
            if hasattr(self.on_start_deep_health_checks, 'to_dict'):
                props['OnStartDeepHealthChecks'] = self.on_start_deep_health_checks.to_dict()
            elif isinstance(self.on_start_deep_health_checks, list):
                props['OnStartDeepHealthChecks'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_start_deep_health_checks
                ]
            else:
                props['OnStartDeepHealthChecks'] = self.on_start_deep_health_checks

        if self.environment_config is not None:
            if hasattr(self.environment_config, 'to_dict'):
                props['EnvironmentConfig'] = self.environment_config.to_dict()
            elif isinstance(self.environment_config, list):
                props['EnvironmentConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment_config
                ]
            else:
                props['EnvironmentConfig'] = self.environment_config

        if self.instance_group_name is not None:
            if hasattr(self.instance_group_name, 'to_dict'):
                props['InstanceGroupName'] = self.instance_group_name.to_dict()
            elif isinstance(self.instance_group_name, list):
                props['InstanceGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_group_name
                ]
            else:
                props['InstanceGroupName'] = self.instance_group_name

        if self.instance_storage_configs is not None:
            if hasattr(self.instance_storage_configs, 'to_dict'):
                props['InstanceStorageConfigs'] = self.instance_storage_configs.to_dict()
            elif isinstance(self.instance_storage_configs, list):
                props['InstanceStorageConfigs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_storage_configs
                ]
            else:
                props['InstanceStorageConfigs'] = self.instance_storage_configs

        if self.current_count is not None:
            if hasattr(self.current_count, 'to_dict'):
                props['CurrentCount'] = self.current_count.to_dict()
            elif isinstance(self.current_count, list):
                props['CurrentCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.current_count
                ]
            else:
                props['CurrentCount'] = self.current_count

        if self.training_plan_arn is not None:
            if hasattr(self.training_plan_arn, 'to_dict'):
                props['TrainingPlanArn'] = self.training_plan_arn.to_dict()
            elif isinstance(self.training_plan_arn, list):
                props['TrainingPlanArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.training_plan_arn
                ]
            else:
                props['TrainingPlanArn'] = self.training_plan_arn

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        if self.threads_per_core is not None:
            if hasattr(self.threads_per_core, 'to_dict'):
                props['ThreadsPerCore'] = self.threads_per_core.to_dict()
            elif isinstance(self.threads_per_core, list):
                props['ThreadsPerCore'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.threads_per_core
                ]
            else:
                props['ThreadsPerCore'] = self.threads_per_core

        if self.execution_role is not None:
            if hasattr(self.execution_role, 'to_dict'):
                props['ExecutionRole'] = self.execution_role.to_dict()
            elif isinstance(self.execution_role, list):
                props['ExecutionRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role
                ]
            else:
                props['ExecutionRole'] = self.execution_role

        return props


@dataclass
class DeploymentConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auto_rollback_configuration: Optional[list[AlarmDetails]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rolling_update_policy: Optional[RollingUpdatePolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    wait_interval_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.auto_rollback_configuration is not None:
            if hasattr(self.auto_rollback_configuration, 'to_dict'):
                props['AutoRollbackConfiguration'] = self.auto_rollback_configuration.to_dict()
            elif isinstance(self.auto_rollback_configuration, list):
                props['AutoRollbackConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_rollback_configuration
                ]
            else:
                props['AutoRollbackConfiguration'] = self.auto_rollback_configuration

        if self.rolling_update_policy is not None:
            if hasattr(self.rolling_update_policy, 'to_dict'):
                props['RollingUpdatePolicy'] = self.rolling_update_policy.to_dict()
            elif isinstance(self.rolling_update_policy, list):
                props['RollingUpdatePolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rolling_update_policy
                ]
            else:
                props['RollingUpdatePolicy'] = self.rolling_update_policy

        if self.wait_interval_in_seconds is not None:
            if hasattr(self.wait_interval_in_seconds, 'to_dict'):
                props['WaitIntervalInSeconds'] = self.wait_interval_in_seconds.to_dict()
            elif isinstance(self.wait_interval_in_seconds, list):
                props['WaitIntervalInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.wait_interval_in_seconds
                ]
            else:
                props['WaitIntervalInSeconds'] = self.wait_interval_in_seconds

        return props


@dataclass
class EnvironmentConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    f_sx_lustre_config: Optional[FSxLustreConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.f_sx_lustre_config is not None:
            if hasattr(self.f_sx_lustre_config, 'to_dict'):
                props['FSxLustreConfig'] = self.f_sx_lustre_config.to_dict()
            elif isinstance(self.f_sx_lustre_config, list):
                props['FSxLustreConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.f_sx_lustre_config
                ]
            else:
                props['FSxLustreConfig'] = self.f_sx_lustre_config

        return props


@dataclass
class FSxLustreConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    size_in_gi_b: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    per_unit_storage_throughput: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.size_in_gi_b is not None:
            if hasattr(self.size_in_gi_b, 'to_dict'):
                props['SizeInGiB'] = self.size_in_gi_b.to_dict()
            elif isinstance(self.size_in_gi_b, list):
                props['SizeInGiB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.size_in_gi_b
                ]
            else:
                props['SizeInGiB'] = self.size_in_gi_b

        if self.per_unit_storage_throughput is not None:
            if hasattr(self.per_unit_storage_throughput, 'to_dict'):
                props['PerUnitStorageThroughput'] = self.per_unit_storage_throughput.to_dict()
            elif isinstance(self.per_unit_storage_throughput, list):
                props['PerUnitStorageThroughput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.per_unit_storage_throughput
                ]
            else:
                props['PerUnitStorageThroughput'] = self.per_unit_storage_throughput

        return props


@dataclass
class Orchestrator:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    eks: Optional[ClusterOrchestratorEksConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.eks is not None:
            if hasattr(self.eks, 'to_dict'):
                props['Eks'] = self.eks.to_dict()
            elif isinstance(self.eks, list):
                props['Eks'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.eks
                ]
            else:
                props['Eks'] = self.eks

        return props


@dataclass
class RollingUpdatePolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_batch_size: Optional[CapacitySizeConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rollback_maximum_batch_size: Optional[CapacitySizeConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.maximum_batch_size is not None:
            if hasattr(self.maximum_batch_size, 'to_dict'):
                props['MaximumBatchSize'] = self.maximum_batch_size.to_dict()
            elif isinstance(self.maximum_batch_size, list):
                props['MaximumBatchSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_batch_size
                ]
            else:
                props['MaximumBatchSize'] = self.maximum_batch_size

        if self.rollback_maximum_batch_size is not None:
            if hasattr(self.rollback_maximum_batch_size, 'to_dict'):
                props['RollbackMaximumBatchSize'] = self.rollback_maximum_batch_size.to_dict()
            elif isinstance(self.rollback_maximum_batch_size, list):
                props['RollbackMaximumBatchSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rollback_maximum_batch_size
                ]
            else:
                props['RollbackMaximumBatchSize'] = self.rollback_maximum_batch_size

        return props


@dataclass
class ScheduledUpdateConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    schedule_expression: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    deployment_config: Optional[DeploymentConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.schedule_expression is not None:
            if hasattr(self.schedule_expression, 'to_dict'):
                props['ScheduleExpression'] = self.schedule_expression.to_dict()
            elif isinstance(self.schedule_expression, list):
                props['ScheduleExpression'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schedule_expression
                ]
            else:
                props['ScheduleExpression'] = self.schedule_expression

        if self.deployment_config is not None:
            if hasattr(self.deployment_config, 'to_dict'):
                props['DeploymentConfig'] = self.deployment_config.to_dict()
            elif isinstance(self.deployment_config, list):
                props['DeploymentConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.deployment_config
                ]
            else:
                props['DeploymentConfig'] = self.deployment_config

        return props


@dataclass
class TieredStorageConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_memory_allocation_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mode is not None:
            if hasattr(self.mode, 'to_dict'):
                props['Mode'] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props['Mode'] = self.mode

        if self.instance_memory_allocation_percentage is not None:
            if hasattr(self.instance_memory_allocation_percentage, 'to_dict'):
                props['InstanceMemoryAllocationPercentage'] = self.instance_memory_allocation_percentage.to_dict()
            elif isinstance(self.instance_memory_allocation_percentage, list):
                props['InstanceMemoryAllocationPercentage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_memory_allocation_percentage
                ]
            else:
                props['InstanceMemoryAllocationPercentage'] = self.instance_memory_allocation_percentage

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnets: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        if self.subnets is not None:
            if hasattr(self.subnets, 'to_dict'):
                props['Subnets'] = self.subnets.to_dict()
            elif isinstance(self.subnets, list):
                props['Subnets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnets
                ]
            else:
                props['Subnets'] = self.subnets

        return props


@dataclass
class Cluster(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::Cluster"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_config: Optional[VpcConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    node_recovery: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    node_provisioning_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_groups: Optional[list[ClusterInstanceGroup]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    restricted_instance_groups: Optional[list[ClusterRestrictedInstanceGroup]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cluster_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    orchestrator: Optional[Orchestrator] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auto_scaling: Optional[ClusterAutoScalingConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    cluster_role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tiered_storage_config: Optional[TieredStorageConfig] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_config is not None:
            # Serialize vpc_config (handle intrinsic functions)
            if hasattr(self.vpc_config, 'to_dict'):
                props["VpcConfig"] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props["VpcConfig"] = self.vpc_config

        if self.node_recovery is not None:
            # Serialize node_recovery (handle intrinsic functions)
            if hasattr(self.node_recovery, 'to_dict'):
                props["NodeRecovery"] = self.node_recovery.to_dict()
            elif isinstance(self.node_recovery, list):
                # Serialize list items (may contain intrinsic functions)
                props['NodeRecovery'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.node_recovery
                ]
            else:
                props["NodeRecovery"] = self.node_recovery

        if self.node_provisioning_mode is not None:
            # Serialize node_provisioning_mode (handle intrinsic functions)
            if hasattr(self.node_provisioning_mode, 'to_dict'):
                props["NodeProvisioningMode"] = self.node_provisioning_mode.to_dict()
            elif isinstance(self.node_provisioning_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['NodeProvisioningMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.node_provisioning_mode
                ]
            else:
                props["NodeProvisioningMode"] = self.node_provisioning_mode

        if self.instance_groups is not None:
            # Serialize instance_groups (handle intrinsic functions)
            if hasattr(self.instance_groups, 'to_dict'):
                props["InstanceGroups"] = self.instance_groups.to_dict()
            elif isinstance(self.instance_groups, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_groups
                ]
            else:
                props["InstanceGroups"] = self.instance_groups

        if self.restricted_instance_groups is not None:
            # Serialize restricted_instance_groups (handle intrinsic functions)
            if hasattr(self.restricted_instance_groups, 'to_dict'):
                props["RestrictedInstanceGroups"] = self.restricted_instance_groups.to_dict()
            elif isinstance(self.restricted_instance_groups, list):
                # Serialize list items (may contain intrinsic functions)
                props['RestrictedInstanceGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.restricted_instance_groups
                ]
            else:
                props["RestrictedInstanceGroups"] = self.restricted_instance_groups

        if self.cluster_name is not None:
            # Serialize cluster_name (handle intrinsic functions)
            if hasattr(self.cluster_name, 'to_dict'):
                props["ClusterName"] = self.cluster_name.to_dict()
            elif isinstance(self.cluster_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClusterName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cluster_name
                ]
            else:
                props["ClusterName"] = self.cluster_name

        if self.orchestrator is not None:
            # Serialize orchestrator (handle intrinsic functions)
            if hasattr(self.orchestrator, 'to_dict'):
                props["Orchestrator"] = self.orchestrator.to_dict()
            elif isinstance(self.orchestrator, list):
                # Serialize list items (may contain intrinsic functions)
                props['Orchestrator'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.orchestrator
                ]
            else:
                props["Orchestrator"] = self.orchestrator

        if self.auto_scaling is not None:
            # Serialize auto_scaling (handle intrinsic functions)
            if hasattr(self.auto_scaling, 'to_dict'):
                props["AutoScaling"] = self.auto_scaling.to_dict()
            elif isinstance(self.auto_scaling, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutoScaling'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_scaling
                ]
            else:
                props["AutoScaling"] = self.auto_scaling

        if self.cluster_role is not None:
            # Serialize cluster_role (handle intrinsic functions)
            if hasattr(self.cluster_role, 'to_dict'):
                props["ClusterRole"] = self.cluster_role.to_dict()
            elif isinstance(self.cluster_role, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClusterRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cluster_role
                ]
            else:
                props["ClusterRole"] = self.cluster_role

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.tiered_storage_config is not None:
            # Serialize tiered_storage_config (handle intrinsic functions)
            if hasattr(self.tiered_storage_config, 'to_dict'):
                props["TieredStorageConfig"] = self.tiered_storage_config.to_dict()
            elif isinstance(self.tiered_storage_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['TieredStorageConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tiered_storage_config
                ]
            else:
                props["TieredStorageConfig"] = self.tiered_storage_config

        return props

    @property
    def attr_cluster_arn(self) -> GetAtt:
        """Get the ClusterArn attribute."""
        return self.get_att("ClusterArn")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_failure_message(self) -> GetAtt:
        """Get the FailureMessage attribute."""
        return self.get_att("FailureMessage")

    @property
    def attr_cluster_status(self) -> GetAtt:
        """Get the ClusterStatus attribute."""
        return self.get_att("ClusterStatus")




@dataclass
class GitConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    secret_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    branch: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    repository_url: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.secret_arn is not None:
            if hasattr(self.secret_arn, 'to_dict'):
                props['SecretArn'] = self.secret_arn.to_dict()
            elif isinstance(self.secret_arn, list):
                props['SecretArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.secret_arn
                ]
            else:
                props['SecretArn'] = self.secret_arn

        if self.branch is not None:
            if hasattr(self.branch, 'to_dict'):
                props['Branch'] = self.branch.to_dict()
            elif isinstance(self.branch, list):
                props['Branch'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.branch
                ]
            else:
                props['Branch'] = self.branch

        if self.repository_url is not None:
            if hasattr(self.repository_url, 'to_dict'):
                props['RepositoryUrl'] = self.repository_url.to_dict()
            elif isinstance(self.repository_url, list):
                props['RepositoryUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.repository_url
                ]
            else:
                props['RepositoryUrl'] = self.repository_url

        return props


@dataclass
class CodeRepository(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::CodeRepository"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    code_repository_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    git_config: Optional[GitConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.code_repository_name is not None:
            # Serialize code_repository_name (handle intrinsic functions)
            if hasattr(self.code_repository_name, 'to_dict'):
                props["CodeRepositoryName"] = self.code_repository_name.to_dict()
            elif isinstance(self.code_repository_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['CodeRepositoryName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code_repository_name
                ]
            else:
                props["CodeRepositoryName"] = self.code_repository_name

        if self.git_config is not None:
            # Serialize git_config (handle intrinsic functions)
            if hasattr(self.git_config, 'to_dict'):
                props["GitConfig"] = self.git_config.to_dict()
            elif isinstance(self.git_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['GitConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.git_config
                ]
            else:
                props["GitConfig"] = self.git_config

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_code_repository_name(self) -> GetAtt:
        """Get the CodeRepositoryName attribute."""
        return self.get_att("CodeRepositoryName")




@dataclass
class BatchTransformInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dataset_format: Optional[DatasetFormat] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_distribution_type: Optional[Union[str, ProcessingS3DataDistributionType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_captured_destination_s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_input_mode: Optional[Union[str, ProcessingS3InputMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    exclude_features_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.dataset_format is not None:
            if hasattr(self.dataset_format, 'to_dict'):
                props['DatasetFormat'] = self.dataset_format.to_dict()
            elif isinstance(self.dataset_format, list):
                props['DatasetFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dataset_format
                ]
            else:
                props['DatasetFormat'] = self.dataset_format

        if self.s3_data_distribution_type is not None:
            if hasattr(self.s3_data_distribution_type, 'to_dict'):
                props['S3DataDistributionType'] = self.s3_data_distribution_type.to_dict()
            elif isinstance(self.s3_data_distribution_type, list):
                props['S3DataDistributionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_distribution_type
                ]
            else:
                props['S3DataDistributionType'] = self.s3_data_distribution_type

        if self.data_captured_destination_s3_uri is not None:
            if hasattr(self.data_captured_destination_s3_uri, 'to_dict'):
                props['DataCapturedDestinationS3Uri'] = self.data_captured_destination_s3_uri.to_dict()
            elif isinstance(self.data_captured_destination_s3_uri, list):
                props['DataCapturedDestinationS3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_captured_destination_s3_uri
                ]
            else:
                props['DataCapturedDestinationS3Uri'] = self.data_captured_destination_s3_uri

        if self.s3_input_mode is not None:
            if hasattr(self.s3_input_mode, 'to_dict'):
                props['S3InputMode'] = self.s3_input_mode.to_dict()
            elif isinstance(self.s3_input_mode, list):
                props['S3InputMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_input_mode
                ]
            else:
                props['S3InputMode'] = self.s3_input_mode

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.exclude_features_attribute is not None:
            if hasattr(self.exclude_features_attribute, 'to_dict'):
                props['ExcludeFeaturesAttribute'] = self.exclude_features_attribute.to_dict()
            elif isinstance(self.exclude_features_attribute, list):
                props['ExcludeFeaturesAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.exclude_features_attribute
                ]
            else:
                props['ExcludeFeaturesAttribute'] = self.exclude_features_attribute

        return props


@dataclass
class ClusterConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size_in_gb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_count is not None:
            if hasattr(self.instance_count, 'to_dict'):
                props['InstanceCount'] = self.instance_count.to_dict()
            elif isinstance(self.instance_count, list):
                props['InstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_count
                ]
            else:
                props['InstanceCount'] = self.instance_count

        if self.volume_size_in_gb is not None:
            if hasattr(self.volume_size_in_gb, 'to_dict'):
                props['VolumeSizeInGB'] = self.volume_size_in_gb.to_dict()
            elif isinstance(self.volume_size_in_gb, list):
                props['VolumeSizeInGB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size_in_gb
                ]
            else:
                props['VolumeSizeInGB'] = self.volume_size_in_gb

        if self.volume_kms_key_id is not None:
            if hasattr(self.volume_kms_key_id, 'to_dict'):
                props['VolumeKmsKeyId'] = self.volume_kms_key_id.to_dict()
            elif isinstance(self.volume_kms_key_id, list):
                props['VolumeKmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_kms_key_id
                ]
            else:
                props['VolumeKmsKeyId'] = self.volume_kms_key_id

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        return props


@dataclass
class ConstraintsResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        return props


@dataclass
class Csv:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    header: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.header is not None:
            if hasattr(self.header, 'to_dict'):
                props['Header'] = self.header.to_dict()
            elif isinstance(self.header, list):
                props['Header'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.header
                ]
            else:
                props['Header'] = self.header

        return props


@dataclass
class DataQualityAppSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_entrypoint: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    post_analytics_processor_source_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    record_preprocessor_source_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    environment: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_arguments: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.container_entrypoint is not None:
            if hasattr(self.container_entrypoint, 'to_dict'):
                props['ContainerEntrypoint'] = self.container_entrypoint.to_dict()
            elif isinstance(self.container_entrypoint, list):
                props['ContainerEntrypoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_entrypoint
                ]
            else:
                props['ContainerEntrypoint'] = self.container_entrypoint

        if self.post_analytics_processor_source_uri is not None:
            if hasattr(self.post_analytics_processor_source_uri, 'to_dict'):
                props['PostAnalyticsProcessorSourceUri'] = self.post_analytics_processor_source_uri.to_dict()
            elif isinstance(self.post_analytics_processor_source_uri, list):
                props['PostAnalyticsProcessorSourceUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.post_analytics_processor_source_uri
                ]
            else:
                props['PostAnalyticsProcessorSourceUri'] = self.post_analytics_processor_source_uri

        if self.record_preprocessor_source_uri is not None:
            if hasattr(self.record_preprocessor_source_uri, 'to_dict'):
                props['RecordPreprocessorSourceUri'] = self.record_preprocessor_source_uri.to_dict()
            elif isinstance(self.record_preprocessor_source_uri, list):
                props['RecordPreprocessorSourceUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.record_preprocessor_source_uri
                ]
            else:
                props['RecordPreprocessorSourceUri'] = self.record_preprocessor_source_uri

        if self.environment is not None:
            if hasattr(self.environment, 'to_dict'):
                props['Environment'] = self.environment.to_dict()
            elif isinstance(self.environment, list):
                props['Environment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment
                ]
            else:
                props['Environment'] = self.environment

        if self.image_uri is not None:
            if hasattr(self.image_uri, 'to_dict'):
                props['ImageUri'] = self.image_uri.to_dict()
            elif isinstance(self.image_uri, list):
                props['ImageUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_uri
                ]
            else:
                props['ImageUri'] = self.image_uri

        if self.container_arguments is not None:
            if hasattr(self.container_arguments, 'to_dict'):
                props['ContainerArguments'] = self.container_arguments.to_dict()
            elif isinstance(self.container_arguments, list):
                props['ContainerArguments'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_arguments
                ]
            else:
                props['ContainerArguments'] = self.container_arguments

        return props


@dataclass
class DataQualityBaselineConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    statistics_resource: Optional[StatisticsResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    constraints_resource: Optional[ConstraintsResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baselining_job_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.statistics_resource is not None:
            if hasattr(self.statistics_resource, 'to_dict'):
                props['StatisticsResource'] = self.statistics_resource.to_dict()
            elif isinstance(self.statistics_resource, list):
                props['StatisticsResource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.statistics_resource
                ]
            else:
                props['StatisticsResource'] = self.statistics_resource

        if self.constraints_resource is not None:
            if hasattr(self.constraints_resource, 'to_dict'):
                props['ConstraintsResource'] = self.constraints_resource.to_dict()
            elif isinstance(self.constraints_resource, list):
                props['ConstraintsResource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.constraints_resource
                ]
            else:
                props['ConstraintsResource'] = self.constraints_resource

        if self.baselining_job_name is not None:
            if hasattr(self.baselining_job_name, 'to_dict'):
                props['BaseliningJobName'] = self.baselining_job_name.to_dict()
            elif isinstance(self.baselining_job_name, list):
                props['BaseliningJobName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baselining_job_name
                ]
            else:
                props['BaseliningJobName'] = self.baselining_job_name

        return props


@dataclass
class DataQualityJobInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    batch_transform_input: Optional[BatchTransformInput] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_input: Optional[EndpointInput] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.batch_transform_input is not None:
            if hasattr(self.batch_transform_input, 'to_dict'):
                props['BatchTransformInput'] = self.batch_transform_input.to_dict()
            elif isinstance(self.batch_transform_input, list):
                props['BatchTransformInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.batch_transform_input
                ]
            else:
                props['BatchTransformInput'] = self.batch_transform_input

        if self.endpoint_input is not None:
            if hasattr(self.endpoint_input, 'to_dict'):
                props['EndpointInput'] = self.endpoint_input.to_dict()
            elif isinstance(self.endpoint_input, list):
                props['EndpointInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_input
                ]
            else:
                props['EndpointInput'] = self.endpoint_input

        return props


@dataclass
class DatasetFormat:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parquet: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    csv: Optional[Csv] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    json: Optional[Json] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.parquet is not None:
            if hasattr(self.parquet, 'to_dict'):
                props['Parquet'] = self.parquet.to_dict()
            elif isinstance(self.parquet, list):
                props['Parquet'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parquet
                ]
            else:
                props['Parquet'] = self.parquet

        if self.csv is not None:
            if hasattr(self.csv, 'to_dict'):
                props['Csv'] = self.csv.to_dict()
            elif isinstance(self.csv, list):
                props['Csv'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.csv
                ]
            else:
                props['Csv'] = self.csv

        if self.json is not None:
            if hasattr(self.json, 'to_dict'):
                props['Json'] = self.json.to_dict()
            elif isinstance(self.json, list):
                props['Json'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.json
                ]
            else:
                props['Json'] = self.json

        return props


@dataclass
class EndpointInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_distribution_type: Optional[Union[str, ProcessingS3DataDistributionType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_input_mode: Optional[Union[str, ProcessingS3InputMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    exclude_features_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_data_distribution_type is not None:
            if hasattr(self.s3_data_distribution_type, 'to_dict'):
                props['S3DataDistributionType'] = self.s3_data_distribution_type.to_dict()
            elif isinstance(self.s3_data_distribution_type, list):
                props['S3DataDistributionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_distribution_type
                ]
            else:
                props['S3DataDistributionType'] = self.s3_data_distribution_type

        if self.endpoint_name is not None:
            if hasattr(self.endpoint_name, 'to_dict'):
                props['EndpointName'] = self.endpoint_name.to_dict()
            elif isinstance(self.endpoint_name, list):
                props['EndpointName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_name
                ]
            else:
                props['EndpointName'] = self.endpoint_name

        if self.s3_input_mode is not None:
            if hasattr(self.s3_input_mode, 'to_dict'):
                props['S3InputMode'] = self.s3_input_mode.to_dict()
            elif isinstance(self.s3_input_mode, list):
                props['S3InputMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_input_mode
                ]
            else:
                props['S3InputMode'] = self.s3_input_mode

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.exclude_features_attribute is not None:
            if hasattr(self.exclude_features_attribute, 'to_dict'):
                props['ExcludeFeaturesAttribute'] = self.exclude_features_attribute.to_dict()
            elif isinstance(self.exclude_features_attribute, list):
                props['ExcludeFeaturesAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.exclude_features_attribute
                ]
            else:
                props['ExcludeFeaturesAttribute'] = self.exclude_features_attribute

        return props


@dataclass
class Json:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    line: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.line is not None:
            if hasattr(self.line, 'to_dict'):
                props['Line'] = self.line.to_dict()
            elif isinstance(self.line, list):
                props['Line'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.line
                ]
            else:
                props['Line'] = self.line

        return props


@dataclass
class MonitoringOutput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_output: Optional[S3Output] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_output is not None:
            if hasattr(self.s3_output, 'to_dict'):
                props['S3Output'] = self.s3_output.to_dict()
            elif isinstance(self.s3_output, list):
                props['S3Output'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_output
                ]
            else:
                props['S3Output'] = self.s3_output

        return props


@dataclass
class MonitoringOutputConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring_outputs: Optional[list[MonitoringOutput]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.monitoring_outputs is not None:
            if hasattr(self.monitoring_outputs, 'to_dict'):
                props['MonitoringOutputs'] = self.monitoring_outputs.to_dict()
            elif isinstance(self.monitoring_outputs, list):
                props['MonitoringOutputs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_outputs
                ]
            else:
                props['MonitoringOutputs'] = self.monitoring_outputs

        return props


@dataclass
class MonitoringResources:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cluster_config: Optional[ClusterConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cluster_config is not None:
            if hasattr(self.cluster_config, 'to_dict'):
                props['ClusterConfig'] = self.cluster_config.to_dict()
            elif isinstance(self.cluster_config, list):
                props['ClusterConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cluster_config
                ]
            else:
                props['ClusterConfig'] = self.cluster_config

        return props


@dataclass
class NetworkConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_network_isolation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_inter_container_traffic_encryption: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_config: Optional[VpcConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enable_network_isolation is not None:
            if hasattr(self.enable_network_isolation, 'to_dict'):
                props['EnableNetworkIsolation'] = self.enable_network_isolation.to_dict()
            elif isinstance(self.enable_network_isolation, list):
                props['EnableNetworkIsolation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_network_isolation
                ]
            else:
                props['EnableNetworkIsolation'] = self.enable_network_isolation

        if self.enable_inter_container_traffic_encryption is not None:
            if hasattr(self.enable_inter_container_traffic_encryption, 'to_dict'):
                props['EnableInterContainerTrafficEncryption'] = self.enable_inter_container_traffic_encryption.to_dict()
            elif isinstance(self.enable_inter_container_traffic_encryption, list):
                props['EnableInterContainerTrafficEncryption'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_inter_container_traffic_encryption
                ]
            else:
                props['EnableInterContainerTrafficEncryption'] = self.enable_inter_container_traffic_encryption

        if self.vpc_config is not None:
            if hasattr(self.vpc_config, 'to_dict'):
                props['VpcConfig'] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props['VpcConfig'] = self.vpc_config

        return props


@dataclass
class S3Output:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_upload_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.s3_upload_mode is not None:
            if hasattr(self.s3_upload_mode, 'to_dict'):
                props['S3UploadMode'] = self.s3_upload_mode.to_dict()
            elif isinstance(self.s3_upload_mode, list):
                props['S3UploadMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_upload_mode
                ]
            else:
                props['S3UploadMode'] = self.s3_upload_mode

        return props


@dataclass
class StatisticsResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        return props


@dataclass
class StoppingCondition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_runtime_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_runtime_in_seconds is not None:
            if hasattr(self.max_runtime_in_seconds, 'to_dict'):
                props['MaxRuntimeInSeconds'] = self.max_runtime_in_seconds.to_dict()
            elif isinstance(self.max_runtime_in_seconds, list):
                props['MaxRuntimeInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_runtime_in_seconds
                ]
            else:
                props['MaxRuntimeInSeconds'] = self.max_runtime_in_seconds

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnets: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnets is not None:
            if hasattr(self.subnets, 'to_dict'):
                props['Subnets'] = self.subnets.to_dict()
            elif isinstance(self.subnets, list):
                props['Subnets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnets
                ]
            else:
                props['Subnets'] = self.subnets

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class DataQualityJobDefinition(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::DataQualityJobDefinition"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_quality_job_input: Optional[DataQualityJobInput] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_quality_app_specification: Optional[DataQualityAppSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    endpoint_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    stopping_condition: Optional[StoppingCondition] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    job_definition_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    job_resources: Optional[MonitoringResources] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_config: Optional[NetworkConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_quality_job_output_config: Optional[MonitoringOutputConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_quality_baseline_config: Optional[DataQualityBaselineConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.data_quality_job_input is not None:
            # Serialize data_quality_job_input (handle intrinsic functions)
            if hasattr(self.data_quality_job_input, 'to_dict'):
                props["DataQualityJobInput"] = self.data_quality_job_input.to_dict()
            elif isinstance(self.data_quality_job_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataQualityJobInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_quality_job_input
                ]
            else:
                props["DataQualityJobInput"] = self.data_quality_job_input

        if self.data_quality_app_specification is not None:
            # Serialize data_quality_app_specification (handle intrinsic functions)
            if hasattr(self.data_quality_app_specification, 'to_dict'):
                props["DataQualityAppSpecification"] = self.data_quality_app_specification.to_dict()
            elif isinstance(self.data_quality_app_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataQualityAppSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_quality_app_specification
                ]
            else:
                props["DataQualityAppSpecification"] = self.data_quality_app_specification

        if self.endpoint_name is not None:
            # Serialize endpoint_name (handle intrinsic functions)
            if hasattr(self.endpoint_name, 'to_dict'):
                props["EndpointName"] = self.endpoint_name.to_dict()
            elif isinstance(self.endpoint_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndpointName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_name
                ]
            else:
                props["EndpointName"] = self.endpoint_name

        if self.stopping_condition is not None:
            # Serialize stopping_condition (handle intrinsic functions)
            if hasattr(self.stopping_condition, 'to_dict'):
                props["StoppingCondition"] = self.stopping_condition.to_dict()
            elif isinstance(self.stopping_condition, list):
                # Serialize list items (may contain intrinsic functions)
                props['StoppingCondition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stopping_condition
                ]
            else:
                props["StoppingCondition"] = self.stopping_condition

        if self.job_definition_name is not None:
            # Serialize job_definition_name (handle intrinsic functions)
            if hasattr(self.job_definition_name, 'to_dict'):
                props["JobDefinitionName"] = self.job_definition_name.to_dict()
            elif isinstance(self.job_definition_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['JobDefinitionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.job_definition_name
                ]
            else:
                props["JobDefinitionName"] = self.job_definition_name

        if self.job_resources is not None:
            # Serialize job_resources (handle intrinsic functions)
            if hasattr(self.job_resources, 'to_dict'):
                props["JobResources"] = self.job_resources.to_dict()
            elif isinstance(self.job_resources, list):
                # Serialize list items (may contain intrinsic functions)
                props['JobResources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.job_resources
                ]
            else:
                props["JobResources"] = self.job_resources

        if self.network_config is not None:
            # Serialize network_config (handle intrinsic functions)
            if hasattr(self.network_config, 'to_dict'):
                props["NetworkConfig"] = self.network_config.to_dict()
            elif isinstance(self.network_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_config
                ]
            else:
                props["NetworkConfig"] = self.network_config

        if self.data_quality_job_output_config is not None:
            # Serialize data_quality_job_output_config (handle intrinsic functions)
            if hasattr(self.data_quality_job_output_config, 'to_dict'):
                props["DataQualityJobOutputConfig"] = self.data_quality_job_output_config.to_dict()
            elif isinstance(self.data_quality_job_output_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataQualityJobOutputConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_quality_job_output_config
                ]
            else:
                props["DataQualityJobOutputConfig"] = self.data_quality_job_output_config

        if self.data_quality_baseline_config is not None:
            # Serialize data_quality_baseline_config (handle intrinsic functions)
            if hasattr(self.data_quality_baseline_config, 'to_dict'):
                props["DataQualityBaselineConfig"] = self.data_quality_baseline_config.to_dict()
            elif isinstance(self.data_quality_baseline_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataQualityBaselineConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_quality_baseline_config
                ]
            else:
                props["DataQualityBaselineConfig"] = self.data_quality_baseline_config

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_job_definition_arn(self) -> GetAtt:
        """Get the JobDefinitionArn attribute."""
        return self.get_att("JobDefinitionArn")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")




@dataclass
class Device:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    iot_thing_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    device_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.iot_thing_name is not None:
            if hasattr(self.iot_thing_name, 'to_dict'):
                props['IotThingName'] = self.iot_thing_name.to_dict()
            elif isinstance(self.iot_thing_name, list):
                props['IotThingName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.iot_thing_name
                ]
            else:
                props['IotThingName'] = self.iot_thing_name

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.device_name is not None:
            if hasattr(self.device_name, 'to_dict'):
                props['DeviceName'] = self.device_name.to_dict()
            elif isinstance(self.device_name, list):
                props['DeviceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_name
                ]
            else:
                props['DeviceName'] = self.device_name

        return props


@dataclass
class Device(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::Device"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    device_fleet_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    device: Optional[Device] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.device_fleet_name is not None:
            # Serialize device_fleet_name (handle intrinsic functions)
            if hasattr(self.device_fleet_name, 'to_dict'):
                props["DeviceFleetName"] = self.device_fleet_name.to_dict()
            elif isinstance(self.device_fleet_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeviceFleetName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_fleet_name
                ]
            else:
                props["DeviceFleetName"] = self.device_fleet_name

        if self.device is not None:
            # Serialize device (handle intrinsic functions)
            if hasattr(self.device, 'to_dict'):
                props["Device"] = self.device.to_dict()
            elif isinstance(self.device, list):
                # Serialize list items (may contain intrinsic functions)
                props['Device'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device
                ]
            else:
                props["Device"] = self.device

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props



@dataclass
class EdgeOutputConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_output_location: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.s3_output_location is not None:
            if hasattr(self.s3_output_location, 'to_dict'):
                props['S3OutputLocation'] = self.s3_output_location.to_dict()
            elif isinstance(self.s3_output_location, list):
                props['S3OutputLocation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_output_location
                ]
            else:
                props['S3OutputLocation'] = self.s3_output_location

        return props


@dataclass
class DeviceFleet(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::DeviceFleet"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    device_fleet_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    output_config: Optional[EdgeOutputConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.device_fleet_name is not None:
            # Serialize device_fleet_name (handle intrinsic functions)
            if hasattr(self.device_fleet_name, 'to_dict'):
                props["DeviceFleetName"] = self.device_fleet_name.to_dict()
            elif isinstance(self.device_fleet_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeviceFleetName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.device_fleet_name
                ]
            else:
                props["DeviceFleetName"] = self.device_fleet_name

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.output_config is not None:
            # Serialize output_config (handle intrinsic functions)
            if hasattr(self.output_config, 'to_dict'):
                props["OutputConfig"] = self.output_config.to_dict()
            elif isinstance(self.output_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['OutputConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_config
                ]
            else:
                props["OutputConfig"] = self.output_config

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props



@dataclass
class AppLifecycleManagement:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    idle_settings: Optional[IdleSettings] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.idle_settings is not None:
            if hasattr(self.idle_settings, 'to_dict'):
                props['IdleSettings'] = self.idle_settings.to_dict()
            elif isinstance(self.idle_settings, list):
                props['IdleSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.idle_settings
                ]
            else:
                props['IdleSettings'] = self.idle_settings

        return props


@dataclass
class CodeEditorAppSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_images: Optional[list[CustomImage]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_resource_spec: Optional[ResourceSpec] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_config_arns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    built_in_lifecycle_config_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    app_lifecycle_management: Optional[AppLifecycleManagement] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.custom_images is not None:
            if hasattr(self.custom_images, 'to_dict'):
                props['CustomImages'] = self.custom_images.to_dict()
            elif isinstance(self.custom_images, list):
                props['CustomImages'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_images
                ]
            else:
                props['CustomImages'] = self.custom_images

        if self.default_resource_spec is not None:
            if hasattr(self.default_resource_spec, 'to_dict'):
                props['DefaultResourceSpec'] = self.default_resource_spec.to_dict()
            elif isinstance(self.default_resource_spec, list):
                props['DefaultResourceSpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_resource_spec
                ]
            else:
                props['DefaultResourceSpec'] = self.default_resource_spec

        if self.lifecycle_config_arns is not None:
            if hasattr(self.lifecycle_config_arns, 'to_dict'):
                props['LifecycleConfigArns'] = self.lifecycle_config_arns.to_dict()
            elif isinstance(self.lifecycle_config_arns, list):
                props['LifecycleConfigArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_config_arns
                ]
            else:
                props['LifecycleConfigArns'] = self.lifecycle_config_arns

        if self.built_in_lifecycle_config_arn is not None:
            if hasattr(self.built_in_lifecycle_config_arn, 'to_dict'):
                props['BuiltInLifecycleConfigArn'] = self.built_in_lifecycle_config_arn.to_dict()
            elif isinstance(self.built_in_lifecycle_config_arn, list):
                props['BuiltInLifecycleConfigArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.built_in_lifecycle_config_arn
                ]
            else:
                props['BuiltInLifecycleConfigArn'] = self.built_in_lifecycle_config_arn

        if self.app_lifecycle_management is not None:
            if hasattr(self.app_lifecycle_management, 'to_dict'):
                props['AppLifecycleManagement'] = self.app_lifecycle_management.to_dict()
            elif isinstance(self.app_lifecycle_management, list):
                props['AppLifecycleManagement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_lifecycle_management
                ]
            else:
                props['AppLifecycleManagement'] = self.app_lifecycle_management

        return props


@dataclass
class CodeRepository:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    repository_url: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.repository_url is not None:
            if hasattr(self.repository_url, 'to_dict'):
                props['RepositoryUrl'] = self.repository_url.to_dict()
            elif isinstance(self.repository_url, list):
                props['RepositoryUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.repository_url
                ]
            else:
                props['RepositoryUrl'] = self.repository_url

        return props


@dataclass
class CustomFileSystemConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    efs_file_system_config: Optional[EFSFileSystemConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_file_system_config: Optional[S3FileSystemConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    f_sx_lustre_file_system_config: Optional[FSxLustreFileSystemConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.efs_file_system_config is not None:
            if hasattr(self.efs_file_system_config, 'to_dict'):
                props['EFSFileSystemConfig'] = self.efs_file_system_config.to_dict()
            elif isinstance(self.efs_file_system_config, list):
                props['EFSFileSystemConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.efs_file_system_config
                ]
            else:
                props['EFSFileSystemConfig'] = self.efs_file_system_config

        if self.s3_file_system_config is not None:
            if hasattr(self.s3_file_system_config, 'to_dict'):
                props['S3FileSystemConfig'] = self.s3_file_system_config.to_dict()
            elif isinstance(self.s3_file_system_config, list):
                props['S3FileSystemConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_file_system_config
                ]
            else:
                props['S3FileSystemConfig'] = self.s3_file_system_config

        if self.f_sx_lustre_file_system_config is not None:
            if hasattr(self.f_sx_lustre_file_system_config, 'to_dict'):
                props['FSxLustreFileSystemConfig'] = self.f_sx_lustre_file_system_config.to_dict()
            elif isinstance(self.f_sx_lustre_file_system_config, list):
                props['FSxLustreFileSystemConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.f_sx_lustre_file_system_config
                ]
            else:
                props['FSxLustreFileSystemConfig'] = self.f_sx_lustre_file_system_config

        return props


@dataclass
class CustomImage:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    app_image_config_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_version_number: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.image_name is not None:
            if hasattr(self.image_name, 'to_dict'):
                props['ImageName'] = self.image_name.to_dict()
            elif isinstance(self.image_name, list):
                props['ImageName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_name
                ]
            else:
                props['ImageName'] = self.image_name

        if self.app_image_config_name is not None:
            if hasattr(self.app_image_config_name, 'to_dict'):
                props['AppImageConfigName'] = self.app_image_config_name.to_dict()
            elif isinstance(self.app_image_config_name, list):
                props['AppImageConfigName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_image_config_name
                ]
            else:
                props['AppImageConfigName'] = self.app_image_config_name

        if self.image_version_number is not None:
            if hasattr(self.image_version_number, 'to_dict'):
                props['ImageVersionNumber'] = self.image_version_number.to_dict()
            elif isinstance(self.image_version_number, list):
                props['ImageVersionNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_version_number
                ]
            else:
                props['ImageVersionNumber'] = self.image_version_number

        return props


@dataclass
class CustomPosixUserConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    uid: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    gid: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.uid is not None:
            if hasattr(self.uid, 'to_dict'):
                props['Uid'] = self.uid.to_dict()
            elif isinstance(self.uid, list):
                props['Uid'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.uid
                ]
            else:
                props['Uid'] = self.uid

        if self.gid is not None:
            if hasattr(self.gid, 'to_dict'):
                props['Gid'] = self.gid.to_dict()
            elif isinstance(self.gid, list):
                props['Gid'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gid
                ]
            else:
                props['Gid'] = self.gid

        return props


@dataclass
class DefaultEbsStorageSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_ebs_volume_size_in_gb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_ebs_volume_size_in_gb: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.maximum_ebs_volume_size_in_gb is not None:
            if hasattr(self.maximum_ebs_volume_size_in_gb, 'to_dict'):
                props['MaximumEbsVolumeSizeInGb'] = self.maximum_ebs_volume_size_in_gb.to_dict()
            elif isinstance(self.maximum_ebs_volume_size_in_gb, list):
                props['MaximumEbsVolumeSizeInGb'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_ebs_volume_size_in_gb
                ]
            else:
                props['MaximumEbsVolumeSizeInGb'] = self.maximum_ebs_volume_size_in_gb

        if self.default_ebs_volume_size_in_gb is not None:
            if hasattr(self.default_ebs_volume_size_in_gb, 'to_dict'):
                props['DefaultEbsVolumeSizeInGb'] = self.default_ebs_volume_size_in_gb.to_dict()
            elif isinstance(self.default_ebs_volume_size_in_gb, list):
                props['DefaultEbsVolumeSizeInGb'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_ebs_volume_size_in_gb
                ]
            else:
                props['DefaultEbsVolumeSizeInGb'] = self.default_ebs_volume_size_in_gb

        return props


@dataclass
class DefaultSpaceSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    jupyter_lab_app_settings: Optional[JupyterLabAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kernel_gateway_app_settings: Optional[KernelGatewayAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    jupyter_server_app_settings: Optional[JupyterServerAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_file_system_configs: Optional[list[CustomFileSystemConfig]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    execution_role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    space_storage_settings: Optional[DefaultSpaceStorageSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_posix_user_config: Optional[CustomPosixUserConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.security_groups is not None:
            if hasattr(self.security_groups, 'to_dict'):
                props['SecurityGroups'] = self.security_groups.to_dict()
            elif isinstance(self.security_groups, list):
                props['SecurityGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_groups
                ]
            else:
                props['SecurityGroups'] = self.security_groups

        if self.jupyter_lab_app_settings is not None:
            if hasattr(self.jupyter_lab_app_settings, 'to_dict'):
                props['JupyterLabAppSettings'] = self.jupyter_lab_app_settings.to_dict()
            elif isinstance(self.jupyter_lab_app_settings, list):
                props['JupyterLabAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.jupyter_lab_app_settings
                ]
            else:
                props['JupyterLabAppSettings'] = self.jupyter_lab_app_settings

        if self.kernel_gateway_app_settings is not None:
            if hasattr(self.kernel_gateway_app_settings, 'to_dict'):
                props['KernelGatewayAppSettings'] = self.kernel_gateway_app_settings.to_dict()
            elif isinstance(self.kernel_gateway_app_settings, list):
                props['KernelGatewayAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kernel_gateway_app_settings
                ]
            else:
                props['KernelGatewayAppSettings'] = self.kernel_gateway_app_settings

        if self.jupyter_server_app_settings is not None:
            if hasattr(self.jupyter_server_app_settings, 'to_dict'):
                props['JupyterServerAppSettings'] = self.jupyter_server_app_settings.to_dict()
            elif isinstance(self.jupyter_server_app_settings, list):
                props['JupyterServerAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.jupyter_server_app_settings
                ]
            else:
                props['JupyterServerAppSettings'] = self.jupyter_server_app_settings

        if self.custom_file_system_configs is not None:
            if hasattr(self.custom_file_system_configs, 'to_dict'):
                props['CustomFileSystemConfigs'] = self.custom_file_system_configs.to_dict()
            elif isinstance(self.custom_file_system_configs, list):
                props['CustomFileSystemConfigs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_file_system_configs
                ]
            else:
                props['CustomFileSystemConfigs'] = self.custom_file_system_configs

        if self.execution_role is not None:
            if hasattr(self.execution_role, 'to_dict'):
                props['ExecutionRole'] = self.execution_role.to_dict()
            elif isinstance(self.execution_role, list):
                props['ExecutionRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role
                ]
            else:
                props['ExecutionRole'] = self.execution_role

        if self.space_storage_settings is not None:
            if hasattr(self.space_storage_settings, 'to_dict'):
                props['SpaceStorageSettings'] = self.space_storage_settings.to_dict()
            elif isinstance(self.space_storage_settings, list):
                props['SpaceStorageSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.space_storage_settings
                ]
            else:
                props['SpaceStorageSettings'] = self.space_storage_settings

        if self.custom_posix_user_config is not None:
            if hasattr(self.custom_posix_user_config, 'to_dict'):
                props['CustomPosixUserConfig'] = self.custom_posix_user_config.to_dict()
            elif isinstance(self.custom_posix_user_config, list):
                props['CustomPosixUserConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_posix_user_config
                ]
            else:
                props['CustomPosixUserConfig'] = self.custom_posix_user_config

        return props


@dataclass
class DefaultSpaceStorageSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_ebs_storage_settings: Optional[DefaultEbsStorageSettings] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_ebs_storage_settings is not None:
            if hasattr(self.default_ebs_storage_settings, 'to_dict'):
                props['DefaultEbsStorageSettings'] = self.default_ebs_storage_settings.to_dict()
            elif isinstance(self.default_ebs_storage_settings, list):
                props['DefaultEbsStorageSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_ebs_storage_settings
                ]
            else:
                props['DefaultEbsStorageSettings'] = self.default_ebs_storage_settings

        return props


@dataclass
class DockerSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_only_trusted_accounts: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_docker_access: Optional[Union[str, FeatureStatus, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.vpc_only_trusted_accounts is not None:
            if hasattr(self.vpc_only_trusted_accounts, 'to_dict'):
                props['VpcOnlyTrustedAccounts'] = self.vpc_only_trusted_accounts.to_dict()
            elif isinstance(self.vpc_only_trusted_accounts, list):
                props['VpcOnlyTrustedAccounts'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_only_trusted_accounts
                ]
            else:
                props['VpcOnlyTrustedAccounts'] = self.vpc_only_trusted_accounts

        if self.enable_docker_access is not None:
            if hasattr(self.enable_docker_access, 'to_dict'):
                props['EnableDockerAccess'] = self.enable_docker_access.to_dict()
            elif isinstance(self.enable_docker_access, list):
                props['EnableDockerAccess'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_docker_access
                ]
            else:
                props['EnableDockerAccess'] = self.enable_docker_access

        return props


@dataclass
class DomainSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    docker_settings: Optional[DockerSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ip_address_type: Optional[Union[str, IPAddressType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    execution_role_identity_config: Optional[Union[str, ExecutionRoleIdentityConfig, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unified_studio_settings: Optional[UnifiedStudioSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    r_studio_server_pro_domain_settings: Optional[RStudioServerProDomainSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.docker_settings is not None:
            if hasattr(self.docker_settings, 'to_dict'):
                props['DockerSettings'] = self.docker_settings.to_dict()
            elif isinstance(self.docker_settings, list):
                props['DockerSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.docker_settings
                ]
            else:
                props['DockerSettings'] = self.docker_settings

        if self.ip_address_type is not None:
            if hasattr(self.ip_address_type, 'to_dict'):
                props['IpAddressType'] = self.ip_address_type.to_dict()
            elif isinstance(self.ip_address_type, list):
                props['IpAddressType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ip_address_type
                ]
            else:
                props['IpAddressType'] = self.ip_address_type

        if self.execution_role_identity_config is not None:
            if hasattr(self.execution_role_identity_config, 'to_dict'):
                props['ExecutionRoleIdentityConfig'] = self.execution_role_identity_config.to_dict()
            elif isinstance(self.execution_role_identity_config, list):
                props['ExecutionRoleIdentityConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role_identity_config
                ]
            else:
                props['ExecutionRoleIdentityConfig'] = self.execution_role_identity_config

        if self.unified_studio_settings is not None:
            if hasattr(self.unified_studio_settings, 'to_dict'):
                props['UnifiedStudioSettings'] = self.unified_studio_settings.to_dict()
            elif isinstance(self.unified_studio_settings, list):
                props['UnifiedStudioSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unified_studio_settings
                ]
            else:
                props['UnifiedStudioSettings'] = self.unified_studio_settings

        if self.r_studio_server_pro_domain_settings is not None:
            if hasattr(self.r_studio_server_pro_domain_settings, 'to_dict'):
                props['RStudioServerProDomainSettings'] = self.r_studio_server_pro_domain_settings.to_dict()
            elif isinstance(self.r_studio_server_pro_domain_settings, list):
                props['RStudioServerProDomainSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.r_studio_server_pro_domain_settings
                ]
            else:
                props['RStudioServerProDomainSettings'] = self.r_studio_server_pro_domain_settings

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class EFSFileSystemConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_system_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_system_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.file_system_path is not None:
            if hasattr(self.file_system_path, 'to_dict'):
                props['FileSystemPath'] = self.file_system_path.to_dict()
            elif isinstance(self.file_system_path, list):
                props['FileSystemPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_path
                ]
            else:
                props['FileSystemPath'] = self.file_system_path

        if self.file_system_id is not None:
            if hasattr(self.file_system_id, 'to_dict'):
                props['FileSystemId'] = self.file_system_id.to_dict()
            elif isinstance(self.file_system_id, list):
                props['FileSystemId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_id
                ]
            else:
                props['FileSystemId'] = self.file_system_id

        return props


@dataclass
class FSxLustreFileSystemConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_system_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_system_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.file_system_path is not None:
            if hasattr(self.file_system_path, 'to_dict'):
                props['FileSystemPath'] = self.file_system_path.to_dict()
            elif isinstance(self.file_system_path, list):
                props['FileSystemPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_path
                ]
            else:
                props['FileSystemPath'] = self.file_system_path

        if self.file_system_id is not None:
            if hasattr(self.file_system_id, 'to_dict'):
                props['FileSystemId'] = self.file_system_id.to_dict()
            elif isinstance(self.file_system_id, list):
                props['FileSystemId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_id
                ]
            else:
                props['FileSystemId'] = self.file_system_id

        return props


@dataclass
class HiddenSageMakerImage:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sage_maker_image_name: Optional[Union[str, SageMakerImageName, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version_aliases: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.sage_maker_image_name is not None:
            if hasattr(self.sage_maker_image_name, 'to_dict'):
                props['SageMakerImageName'] = self.sage_maker_image_name.to_dict()
            elif isinstance(self.sage_maker_image_name, list):
                props['SageMakerImageName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sage_maker_image_name
                ]
            else:
                props['SageMakerImageName'] = self.sage_maker_image_name

        if self.version_aliases is not None:
            if hasattr(self.version_aliases, 'to_dict'):
                props['VersionAliases'] = self.version_aliases.to_dict()
            elif isinstance(self.version_aliases, list):
                props['VersionAliases'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version_aliases
                ]
            else:
                props['VersionAliases'] = self.version_aliases

        return props


@dataclass
class IdleSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_idle_timeout_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    idle_timeout_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_idle_timeout_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_management: Optional[Union[str, LifecycleManagement, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_idle_timeout_in_minutes is not None:
            if hasattr(self.max_idle_timeout_in_minutes, 'to_dict'):
                props['MaxIdleTimeoutInMinutes'] = self.max_idle_timeout_in_minutes.to_dict()
            elif isinstance(self.max_idle_timeout_in_minutes, list):
                props['MaxIdleTimeoutInMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_idle_timeout_in_minutes
                ]
            else:
                props['MaxIdleTimeoutInMinutes'] = self.max_idle_timeout_in_minutes

        if self.idle_timeout_in_minutes is not None:
            if hasattr(self.idle_timeout_in_minutes, 'to_dict'):
                props['IdleTimeoutInMinutes'] = self.idle_timeout_in_minutes.to_dict()
            elif isinstance(self.idle_timeout_in_minutes, list):
                props['IdleTimeoutInMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.idle_timeout_in_minutes
                ]
            else:
                props['IdleTimeoutInMinutes'] = self.idle_timeout_in_minutes

        if self.min_idle_timeout_in_minutes is not None:
            if hasattr(self.min_idle_timeout_in_minutes, 'to_dict'):
                props['MinIdleTimeoutInMinutes'] = self.min_idle_timeout_in_minutes.to_dict()
            elif isinstance(self.min_idle_timeout_in_minutes, list):
                props['MinIdleTimeoutInMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_idle_timeout_in_minutes
                ]
            else:
                props['MinIdleTimeoutInMinutes'] = self.min_idle_timeout_in_minutes

        if self.lifecycle_management is not None:
            if hasattr(self.lifecycle_management, 'to_dict'):
                props['LifecycleManagement'] = self.lifecycle_management.to_dict()
            elif isinstance(self.lifecycle_management, list):
                props['LifecycleManagement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_management
                ]
            else:
                props['LifecycleManagement'] = self.lifecycle_management

        return props


@dataclass
class JupyterLabAppSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_images: Optional[list[CustomImage]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_resource_spec: Optional[ResourceSpec] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_config_arns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    built_in_lifecycle_config_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    code_repositories: Optional[list[CodeRepository]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    app_lifecycle_management: Optional[AppLifecycleManagement] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.custom_images is not None:
            if hasattr(self.custom_images, 'to_dict'):
                props['CustomImages'] = self.custom_images.to_dict()
            elif isinstance(self.custom_images, list):
                props['CustomImages'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_images
                ]
            else:
                props['CustomImages'] = self.custom_images

        if self.default_resource_spec is not None:
            if hasattr(self.default_resource_spec, 'to_dict'):
                props['DefaultResourceSpec'] = self.default_resource_spec.to_dict()
            elif isinstance(self.default_resource_spec, list):
                props['DefaultResourceSpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_resource_spec
                ]
            else:
                props['DefaultResourceSpec'] = self.default_resource_spec

        if self.lifecycle_config_arns is not None:
            if hasattr(self.lifecycle_config_arns, 'to_dict'):
                props['LifecycleConfigArns'] = self.lifecycle_config_arns.to_dict()
            elif isinstance(self.lifecycle_config_arns, list):
                props['LifecycleConfigArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_config_arns
                ]
            else:
                props['LifecycleConfigArns'] = self.lifecycle_config_arns

        if self.built_in_lifecycle_config_arn is not None:
            if hasattr(self.built_in_lifecycle_config_arn, 'to_dict'):
                props['BuiltInLifecycleConfigArn'] = self.built_in_lifecycle_config_arn.to_dict()
            elif isinstance(self.built_in_lifecycle_config_arn, list):
                props['BuiltInLifecycleConfigArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.built_in_lifecycle_config_arn
                ]
            else:
                props['BuiltInLifecycleConfigArn'] = self.built_in_lifecycle_config_arn

        if self.code_repositories is not None:
            if hasattr(self.code_repositories, 'to_dict'):
                props['CodeRepositories'] = self.code_repositories.to_dict()
            elif isinstance(self.code_repositories, list):
                props['CodeRepositories'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code_repositories
                ]
            else:
                props['CodeRepositories'] = self.code_repositories

        if self.app_lifecycle_management is not None:
            if hasattr(self.app_lifecycle_management, 'to_dict'):
                props['AppLifecycleManagement'] = self.app_lifecycle_management.to_dict()
            elif isinstance(self.app_lifecycle_management, list):
                props['AppLifecycleManagement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_lifecycle_management
                ]
            else:
                props['AppLifecycleManagement'] = self.app_lifecycle_management

        return props


@dataclass
class JupyterServerAppSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_resource_spec: Optional[ResourceSpec] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_config_arns: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_resource_spec is not None:
            if hasattr(self.default_resource_spec, 'to_dict'):
                props['DefaultResourceSpec'] = self.default_resource_spec.to_dict()
            elif isinstance(self.default_resource_spec, list):
                props['DefaultResourceSpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_resource_spec
                ]
            else:
                props['DefaultResourceSpec'] = self.default_resource_spec

        if self.lifecycle_config_arns is not None:
            if hasattr(self.lifecycle_config_arns, 'to_dict'):
                props['LifecycleConfigArns'] = self.lifecycle_config_arns.to_dict()
            elif isinstance(self.lifecycle_config_arns, list):
                props['LifecycleConfigArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_config_arns
                ]
            else:
                props['LifecycleConfigArns'] = self.lifecycle_config_arns

        return props


@dataclass
class KernelGatewayAppSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_images: Optional[list[CustomImage]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_resource_spec: Optional[ResourceSpec] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_config_arns: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.custom_images is not None:
            if hasattr(self.custom_images, 'to_dict'):
                props['CustomImages'] = self.custom_images.to_dict()
            elif isinstance(self.custom_images, list):
                props['CustomImages'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_images
                ]
            else:
                props['CustomImages'] = self.custom_images

        if self.default_resource_spec is not None:
            if hasattr(self.default_resource_spec, 'to_dict'):
                props['DefaultResourceSpec'] = self.default_resource_spec.to_dict()
            elif isinstance(self.default_resource_spec, list):
                props['DefaultResourceSpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_resource_spec
                ]
            else:
                props['DefaultResourceSpec'] = self.default_resource_spec

        if self.lifecycle_config_arns is not None:
            if hasattr(self.lifecycle_config_arns, 'to_dict'):
                props['LifecycleConfigArns'] = self.lifecycle_config_arns.to_dict()
            elif isinstance(self.lifecycle_config_arns, list):
                props['LifecycleConfigArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_config_arns
                ]
            else:
                props['LifecycleConfigArns'] = self.lifecycle_config_arns

        return props


@dataclass
class RSessionAppSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_images: Optional[list[CustomImage]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_resource_spec: Optional[ResourceSpec] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.custom_images is not None:
            if hasattr(self.custom_images, 'to_dict'):
                props['CustomImages'] = self.custom_images.to_dict()
            elif isinstance(self.custom_images, list):
                props['CustomImages'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_images
                ]
            else:
                props['CustomImages'] = self.custom_images

        if self.default_resource_spec is not None:
            if hasattr(self.default_resource_spec, 'to_dict'):
                props['DefaultResourceSpec'] = self.default_resource_spec.to_dict()
            elif isinstance(self.default_resource_spec, list):
                props['DefaultResourceSpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_resource_spec
                ]
            else:
                props['DefaultResourceSpec'] = self.default_resource_spec

        return props


@dataclass
class RStudioServerProAppSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    access_status: Optional[Union[str, RStudioServerProAccessStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_group: Optional[Union[str, RStudioServerProUserGroup, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.access_status is not None:
            if hasattr(self.access_status, 'to_dict'):
                props['AccessStatus'] = self.access_status.to_dict()
            elif isinstance(self.access_status, list):
                props['AccessStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.access_status
                ]
            else:
                props['AccessStatus'] = self.access_status

        if self.user_group is not None:
            if hasattr(self.user_group, 'to_dict'):
                props['UserGroup'] = self.user_group.to_dict()
            elif isinstance(self.user_group, list):
                props['UserGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_group
                ]
            else:
                props['UserGroup'] = self.user_group

        return props


@dataclass
class RStudioServerProDomainSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    domain_execution_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    r_studio_connect_url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_resource_spec: Optional[ResourceSpec] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    r_studio_package_manager_url: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.domain_execution_role_arn is not None:
            if hasattr(self.domain_execution_role_arn, 'to_dict'):
                props['DomainExecutionRoleArn'] = self.domain_execution_role_arn.to_dict()
            elif isinstance(self.domain_execution_role_arn, list):
                props['DomainExecutionRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_execution_role_arn
                ]
            else:
                props['DomainExecutionRoleArn'] = self.domain_execution_role_arn

        if self.r_studio_connect_url is not None:
            if hasattr(self.r_studio_connect_url, 'to_dict'):
                props['RStudioConnectUrl'] = self.r_studio_connect_url.to_dict()
            elif isinstance(self.r_studio_connect_url, list):
                props['RStudioConnectUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.r_studio_connect_url
                ]
            else:
                props['RStudioConnectUrl'] = self.r_studio_connect_url

        if self.default_resource_spec is not None:
            if hasattr(self.default_resource_spec, 'to_dict'):
                props['DefaultResourceSpec'] = self.default_resource_spec.to_dict()
            elif isinstance(self.default_resource_spec, list):
                props['DefaultResourceSpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_resource_spec
                ]
            else:
                props['DefaultResourceSpec'] = self.default_resource_spec

        if self.r_studio_package_manager_url is not None:
            if hasattr(self.r_studio_package_manager_url, 'to_dict'):
                props['RStudioPackageManagerUrl'] = self.r_studio_package_manager_url.to_dict()
            elif isinstance(self.r_studio_package_manager_url, list):
                props['RStudioPackageManagerUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.r_studio_package_manager_url
                ]
            else:
                props['RStudioPackageManagerUrl'] = self.r_studio_package_manager_url

        return props


@dataclass
class ResourceSpec:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sage_maker_image_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, AppInstanceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_config_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sage_maker_image_version_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.sage_maker_image_arn is not None:
            if hasattr(self.sage_maker_image_arn, 'to_dict'):
                props['SageMakerImageArn'] = self.sage_maker_image_arn.to_dict()
            elif isinstance(self.sage_maker_image_arn, list):
                props['SageMakerImageArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sage_maker_image_arn
                ]
            else:
                props['SageMakerImageArn'] = self.sage_maker_image_arn

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        if self.lifecycle_config_arn is not None:
            if hasattr(self.lifecycle_config_arn, 'to_dict'):
                props['LifecycleConfigArn'] = self.lifecycle_config_arn.to_dict()
            elif isinstance(self.lifecycle_config_arn, list):
                props['LifecycleConfigArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_config_arn
                ]
            else:
                props['LifecycleConfigArn'] = self.lifecycle_config_arn

        if self.sage_maker_image_version_arn is not None:
            if hasattr(self.sage_maker_image_version_arn, 'to_dict'):
                props['SageMakerImageVersionArn'] = self.sage_maker_image_version_arn.to_dict()
            elif isinstance(self.sage_maker_image_version_arn, list):
                props['SageMakerImageVersionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sage_maker_image_version_arn
                ]
            else:
                props['SageMakerImageVersionArn'] = self.sage_maker_image_version_arn

        return props


@dataclass
class S3FileSystemConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mount_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mount_path is not None:
            if hasattr(self.mount_path, 'to_dict'):
                props['MountPath'] = self.mount_path.to_dict()
            elif isinstance(self.mount_path, list):
                props['MountPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mount_path
                ]
            else:
                props['MountPath'] = self.mount_path

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        return props


@dataclass
class SharingSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notebook_output_option: Optional[Union[str, NotebookOutputOption, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_output_path: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.notebook_output_option is not None:
            if hasattr(self.notebook_output_option, 'to_dict'):
                props['NotebookOutputOption'] = self.notebook_output_option.to_dict()
            elif isinstance(self.notebook_output_option, list):
                props['NotebookOutputOption'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notebook_output_option
                ]
            else:
                props['NotebookOutputOption'] = self.notebook_output_option

        if self.s3_kms_key_id is not None:
            if hasattr(self.s3_kms_key_id, 'to_dict'):
                props['S3KmsKeyId'] = self.s3_kms_key_id.to_dict()
            elif isinstance(self.s3_kms_key_id, list):
                props['S3KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_kms_key_id
                ]
            else:
                props['S3KmsKeyId'] = self.s3_kms_key_id

        if self.s3_output_path is not None:
            if hasattr(self.s3_output_path, 'to_dict'):
                props['S3OutputPath'] = self.s3_output_path.to_dict()
            elif isinstance(self.s3_output_path, list):
                props['S3OutputPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_output_path
                ]
            else:
                props['S3OutputPath'] = self.s3_output_path

        return props


@dataclass
class StudioWebPortalSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hidden_sage_maker_image_version_aliases: Optional[list[HiddenSageMakerImage]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hidden_app_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hidden_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hidden_ml_tools: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.hidden_sage_maker_image_version_aliases is not None:
            if hasattr(self.hidden_sage_maker_image_version_aliases, 'to_dict'):
                props['HiddenSageMakerImageVersionAliases'] = self.hidden_sage_maker_image_version_aliases.to_dict()
            elif isinstance(self.hidden_sage_maker_image_version_aliases, list):
                props['HiddenSageMakerImageVersionAliases'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hidden_sage_maker_image_version_aliases
                ]
            else:
                props['HiddenSageMakerImageVersionAliases'] = self.hidden_sage_maker_image_version_aliases

        if self.hidden_app_types is not None:
            if hasattr(self.hidden_app_types, 'to_dict'):
                props['HiddenAppTypes'] = self.hidden_app_types.to_dict()
            elif isinstance(self.hidden_app_types, list):
                props['HiddenAppTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hidden_app_types
                ]
            else:
                props['HiddenAppTypes'] = self.hidden_app_types

        if self.hidden_instance_types is not None:
            if hasattr(self.hidden_instance_types, 'to_dict'):
                props['HiddenInstanceTypes'] = self.hidden_instance_types.to_dict()
            elif isinstance(self.hidden_instance_types, list):
                props['HiddenInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hidden_instance_types
                ]
            else:
                props['HiddenInstanceTypes'] = self.hidden_instance_types

        if self.hidden_ml_tools is not None:
            if hasattr(self.hidden_ml_tools, 'to_dict'):
                props['HiddenMlTools'] = self.hidden_ml_tools.to_dict()
            elif isinstance(self.hidden_ml_tools, list):
                props['HiddenMlTools'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hidden_ml_tools
                ]
            else:
                props['HiddenMlTools'] = self.hidden_ml_tools

        return props


@dataclass
class UnifiedStudioSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    environment_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    domain_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    project_s3_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    domain_account_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    project_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    domain_region: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    studio_web_portal_access: Optional[Union[str, FeatureStatus, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.environment_id is not None:
            if hasattr(self.environment_id, 'to_dict'):
                props['EnvironmentId'] = self.environment_id.to_dict()
            elif isinstance(self.environment_id, list):
                props['EnvironmentId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment_id
                ]
            else:
                props['EnvironmentId'] = self.environment_id

        if self.domain_id is not None:
            if hasattr(self.domain_id, 'to_dict'):
                props['DomainId'] = self.domain_id.to_dict()
            elif isinstance(self.domain_id, list):
                props['DomainId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_id
                ]
            else:
                props['DomainId'] = self.domain_id

        if self.project_s3_path is not None:
            if hasattr(self.project_s3_path, 'to_dict'):
                props['ProjectS3Path'] = self.project_s3_path.to_dict()
            elif isinstance(self.project_s3_path, list):
                props['ProjectS3Path'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.project_s3_path
                ]
            else:
                props['ProjectS3Path'] = self.project_s3_path

        if self.domain_account_id is not None:
            if hasattr(self.domain_account_id, 'to_dict'):
                props['DomainAccountId'] = self.domain_account_id.to_dict()
            elif isinstance(self.domain_account_id, list):
                props['DomainAccountId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_account_id
                ]
            else:
                props['DomainAccountId'] = self.domain_account_id

        if self.project_id is not None:
            if hasattr(self.project_id, 'to_dict'):
                props['ProjectId'] = self.project_id.to_dict()
            elif isinstance(self.project_id, list):
                props['ProjectId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.project_id
                ]
            else:
                props['ProjectId'] = self.project_id

        if self.domain_region is not None:
            if hasattr(self.domain_region, 'to_dict'):
                props['DomainRegion'] = self.domain_region.to_dict()
            elif isinstance(self.domain_region, list):
                props['DomainRegion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_region
                ]
            else:
                props['DomainRegion'] = self.domain_region

        if self.studio_web_portal_access is not None:
            if hasattr(self.studio_web_portal_access, 'to_dict'):
                props['StudioWebPortalAccess'] = self.studio_web_portal_access.to_dict()
            elif isinstance(self.studio_web_portal_access, list):
                props['StudioWebPortalAccess'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.studio_web_portal_access
                ]
            else:
                props['StudioWebPortalAccess'] = self.studio_web_portal_access

        return props


@dataclass
class UserSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    jupyter_lab_app_settings: Optional[JupyterLabAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kernel_gateway_app_settings: Optional[KernelGatewayAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    studio_web_portal_settings: Optional[StudioWebPortalSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_file_system_configs: Optional[list[CustomFileSystemConfig]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_posix_user_config: Optional[CustomPosixUserConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    code_editor_app_settings: Optional[CodeEditorAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    r_studio_server_pro_app_settings: Optional[RStudioServerProAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    studio_web_portal: Optional[Union[str, StudioWebPortal, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    r_session_app_settings: Optional[RSessionAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    jupyter_server_app_settings: Optional[JupyterServerAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auto_mount_home_efs: Optional[Union[str, AutoMountHomeEFS, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_landing_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    execution_role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    space_storage_settings: Optional[DefaultSpaceStorageSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sharing_settings: Optional[SharingSettings] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.security_groups is not None:
            if hasattr(self.security_groups, 'to_dict'):
                props['SecurityGroups'] = self.security_groups.to_dict()
            elif isinstance(self.security_groups, list):
                props['SecurityGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_groups
                ]
            else:
                props['SecurityGroups'] = self.security_groups

        if self.jupyter_lab_app_settings is not None:
            if hasattr(self.jupyter_lab_app_settings, 'to_dict'):
                props['JupyterLabAppSettings'] = self.jupyter_lab_app_settings.to_dict()
            elif isinstance(self.jupyter_lab_app_settings, list):
                props['JupyterLabAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.jupyter_lab_app_settings
                ]
            else:
                props['JupyterLabAppSettings'] = self.jupyter_lab_app_settings

        if self.kernel_gateway_app_settings is not None:
            if hasattr(self.kernel_gateway_app_settings, 'to_dict'):
                props['KernelGatewayAppSettings'] = self.kernel_gateway_app_settings.to_dict()
            elif isinstance(self.kernel_gateway_app_settings, list):
                props['KernelGatewayAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kernel_gateway_app_settings
                ]
            else:
                props['KernelGatewayAppSettings'] = self.kernel_gateway_app_settings

        if self.studio_web_portal_settings is not None:
            if hasattr(self.studio_web_portal_settings, 'to_dict'):
                props['StudioWebPortalSettings'] = self.studio_web_portal_settings.to_dict()
            elif isinstance(self.studio_web_portal_settings, list):
                props['StudioWebPortalSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.studio_web_portal_settings
                ]
            else:
                props['StudioWebPortalSettings'] = self.studio_web_portal_settings

        if self.custom_file_system_configs is not None:
            if hasattr(self.custom_file_system_configs, 'to_dict'):
                props['CustomFileSystemConfigs'] = self.custom_file_system_configs.to_dict()
            elif isinstance(self.custom_file_system_configs, list):
                props['CustomFileSystemConfigs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_file_system_configs
                ]
            else:
                props['CustomFileSystemConfigs'] = self.custom_file_system_configs

        if self.custom_posix_user_config is not None:
            if hasattr(self.custom_posix_user_config, 'to_dict'):
                props['CustomPosixUserConfig'] = self.custom_posix_user_config.to_dict()
            elif isinstance(self.custom_posix_user_config, list):
                props['CustomPosixUserConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_posix_user_config
                ]
            else:
                props['CustomPosixUserConfig'] = self.custom_posix_user_config

        if self.code_editor_app_settings is not None:
            if hasattr(self.code_editor_app_settings, 'to_dict'):
                props['CodeEditorAppSettings'] = self.code_editor_app_settings.to_dict()
            elif isinstance(self.code_editor_app_settings, list):
                props['CodeEditorAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code_editor_app_settings
                ]
            else:
                props['CodeEditorAppSettings'] = self.code_editor_app_settings

        if self.r_studio_server_pro_app_settings is not None:
            if hasattr(self.r_studio_server_pro_app_settings, 'to_dict'):
                props['RStudioServerProAppSettings'] = self.r_studio_server_pro_app_settings.to_dict()
            elif isinstance(self.r_studio_server_pro_app_settings, list):
                props['RStudioServerProAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.r_studio_server_pro_app_settings
                ]
            else:
                props['RStudioServerProAppSettings'] = self.r_studio_server_pro_app_settings

        if self.studio_web_portal is not None:
            if hasattr(self.studio_web_portal, 'to_dict'):
                props['StudioWebPortal'] = self.studio_web_portal.to_dict()
            elif isinstance(self.studio_web_portal, list):
                props['StudioWebPortal'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.studio_web_portal
                ]
            else:
                props['StudioWebPortal'] = self.studio_web_portal

        if self.r_session_app_settings is not None:
            if hasattr(self.r_session_app_settings, 'to_dict'):
                props['RSessionAppSettings'] = self.r_session_app_settings.to_dict()
            elif isinstance(self.r_session_app_settings, list):
                props['RSessionAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.r_session_app_settings
                ]
            else:
                props['RSessionAppSettings'] = self.r_session_app_settings

        if self.jupyter_server_app_settings is not None:
            if hasattr(self.jupyter_server_app_settings, 'to_dict'):
                props['JupyterServerAppSettings'] = self.jupyter_server_app_settings.to_dict()
            elif isinstance(self.jupyter_server_app_settings, list):
                props['JupyterServerAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.jupyter_server_app_settings
                ]
            else:
                props['JupyterServerAppSettings'] = self.jupyter_server_app_settings

        if self.auto_mount_home_efs is not None:
            if hasattr(self.auto_mount_home_efs, 'to_dict'):
                props['AutoMountHomeEFS'] = self.auto_mount_home_efs.to_dict()
            elif isinstance(self.auto_mount_home_efs, list):
                props['AutoMountHomeEFS'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_mount_home_efs
                ]
            else:
                props['AutoMountHomeEFS'] = self.auto_mount_home_efs

        if self.default_landing_uri is not None:
            if hasattr(self.default_landing_uri, 'to_dict'):
                props['DefaultLandingUri'] = self.default_landing_uri.to_dict()
            elif isinstance(self.default_landing_uri, list):
                props['DefaultLandingUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_landing_uri
                ]
            else:
                props['DefaultLandingUri'] = self.default_landing_uri

        if self.execution_role is not None:
            if hasattr(self.execution_role, 'to_dict'):
                props['ExecutionRole'] = self.execution_role.to_dict()
            elif isinstance(self.execution_role, list):
                props['ExecutionRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role
                ]
            else:
                props['ExecutionRole'] = self.execution_role

        if self.space_storage_settings is not None:
            if hasattr(self.space_storage_settings, 'to_dict'):
                props['SpaceStorageSettings'] = self.space_storage_settings.to_dict()
            elif isinstance(self.space_storage_settings, list):
                props['SpaceStorageSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.space_storage_settings
                ]
            else:
                props['SpaceStorageSettings'] = self.space_storage_settings

        if self.sharing_settings is not None:
            if hasattr(self.sharing_settings, 'to_dict'):
                props['SharingSettings'] = self.sharing_settings.to_dict()
            elif isinstance(self.sharing_settings, list):
                props['SharingSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sharing_settings
                ]
            else:
                props['SharingSettings'] = self.sharing_settings

        return props


@dataclass
class Domain(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::Domain"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    app_network_access_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_space_settings: Optional[DefaultSpaceSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    app_security_group_management: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_user_settings: Optional[UserSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auth_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_settings: Optional[DomainSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tag_propagation: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.app_network_access_type is not None:
            # Serialize app_network_access_type (handle intrinsic functions)
            if hasattr(self.app_network_access_type, 'to_dict'):
                props["AppNetworkAccessType"] = self.app_network_access_type.to_dict()
            elif isinstance(self.app_network_access_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['AppNetworkAccessType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_network_access_type
                ]
            else:
                props["AppNetworkAccessType"] = self.app_network_access_type

        if self.default_space_settings is not None:
            # Serialize default_space_settings (handle intrinsic functions)
            if hasattr(self.default_space_settings, 'to_dict'):
                props["DefaultSpaceSettings"] = self.default_space_settings.to_dict()
            elif isinstance(self.default_space_settings, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultSpaceSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_space_settings
                ]
            else:
                props["DefaultSpaceSettings"] = self.default_space_settings

        if self.kms_key_id is not None:
            # Serialize kms_key_id (handle intrinsic functions)
            if hasattr(self.kms_key_id, 'to_dict'):
                props["KmsKeyId"] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props["KmsKeyId"] = self.kms_key_id

        if self.vpc_id is not None:
            # Serialize vpc_id (handle intrinsic functions)
            if hasattr(self.vpc_id, 'to_dict'):
                props["VpcId"] = self.vpc_id.to_dict()
            elif isinstance(self.vpc_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_id
                ]
            else:
                props["VpcId"] = self.vpc_id

        if self.domain_name is not None:
            # Serialize domain_name (handle intrinsic functions)
            if hasattr(self.domain_name, 'to_dict'):
                props["DomainName"] = self.domain_name.to_dict()
            elif isinstance(self.domain_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_name
                ]
            else:
                props["DomainName"] = self.domain_name

        if self.app_security_group_management is not None:
            # Serialize app_security_group_management (handle intrinsic functions)
            if hasattr(self.app_security_group_management, 'to_dict'):
                props["AppSecurityGroupManagement"] = self.app_security_group_management.to_dict()
            elif isinstance(self.app_security_group_management, list):
                # Serialize list items (may contain intrinsic functions)
                props['AppSecurityGroupManagement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_security_group_management
                ]
            else:
                props["AppSecurityGroupManagement"] = self.app_security_group_management

        if self.default_user_settings is not None:
            # Serialize default_user_settings (handle intrinsic functions)
            if hasattr(self.default_user_settings, 'to_dict'):
                props["DefaultUserSettings"] = self.default_user_settings.to_dict()
            elif isinstance(self.default_user_settings, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultUserSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_user_settings
                ]
            else:
                props["DefaultUserSettings"] = self.default_user_settings

        if self.subnet_ids is not None:
            # Serialize subnet_ids (handle intrinsic functions)
            if hasattr(self.subnet_ids, 'to_dict'):
                props["SubnetIds"] = self.subnet_ids.to_dict()
            elif isinstance(self.subnet_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_ids
                ]
            else:
                props["SubnetIds"] = self.subnet_ids

        if self.auth_mode is not None:
            # Serialize auth_mode (handle intrinsic functions)
            if hasattr(self.auth_mode, 'to_dict'):
                props["AuthMode"] = self.auth_mode.to_dict()
            elif isinstance(self.auth_mode, list):
                # Serialize list items (may contain intrinsic functions)
                props['AuthMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auth_mode
                ]
            else:
                props["AuthMode"] = self.auth_mode

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.domain_settings is not None:
            # Serialize domain_settings (handle intrinsic functions)
            if hasattr(self.domain_settings, 'to_dict'):
                props["DomainSettings"] = self.domain_settings.to_dict()
            elif isinstance(self.domain_settings, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_settings
                ]
            else:
                props["DomainSettings"] = self.domain_settings

        if self.tag_propagation is not None:
            # Serialize tag_propagation (handle intrinsic functions)
            if hasattr(self.tag_propagation, 'to_dict'):
                props["TagPropagation"] = self.tag_propagation.to_dict()
            elif isinstance(self.tag_propagation, list):
                # Serialize list items (may contain intrinsic functions)
                props['TagPropagation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tag_propagation
                ]
            else:
                props["TagPropagation"] = self.tag_propagation

        return props

    @property
    def attr_home_efs_file_system_id(self) -> GetAtt:
        """Get the HomeEfsFileSystemId attribute."""
        return self.get_att("HomeEfsFileSystemId")

    @property
    def attr_domain_id(self) -> GetAtt:
        """Get the DomainId attribute."""
        return self.get_att("DomainId")

    @property
    def attr_security_group_id_for_domain_boundary(self) -> GetAtt:
        """Get the SecurityGroupIdForDomainBoundary attribute."""
        return self.get_att("SecurityGroupIdForDomainBoundary")

    @property
    def attr_single_sign_on_managed_application_instance_id(self) -> GetAtt:
        """Get the SingleSignOnManagedApplicationInstanceId attribute."""
        return self.get_att("SingleSignOnManagedApplicationInstanceId")

    @property
    def attr_single_sign_on_application_arn(self) -> GetAtt:
        """Get the SingleSignOnApplicationArn attribute."""
        return self.get_att("SingleSignOnApplicationArn")

    @property
    def attr_domain_arn(self) -> GetAtt:
        """Get the DomainArn attribute."""
        return self.get_att("DomainArn")

    @property
    def attr_url(self) -> GetAtt:
        """Get the Url attribute."""
        return self.get_att("Url")




@dataclass
class Alarm:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    alarm_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.alarm_name is not None:
            if hasattr(self.alarm_name, 'to_dict'):
                props['AlarmName'] = self.alarm_name.to_dict()
            elif isinstance(self.alarm_name, list):
                props['AlarmName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.alarm_name
                ]
            else:
                props['AlarmName'] = self.alarm_name

        return props


@dataclass
class AutoRollbackConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    alarms: Optional[list[Alarm]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.alarms is not None:
            if hasattr(self.alarms, 'to_dict'):
                props['Alarms'] = self.alarms.to_dict()
            elif isinstance(self.alarms, list):
                props['Alarms'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.alarms
                ]
            else:
                props['Alarms'] = self.alarms

        return props


@dataclass
class BlueGreenUpdatePolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_execution_timeout_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    termination_wait_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    traffic_routing_configuration: Optional[TrafficRoutingConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.maximum_execution_timeout_in_seconds is not None:
            if hasattr(self.maximum_execution_timeout_in_seconds, 'to_dict'):
                props['MaximumExecutionTimeoutInSeconds'] = self.maximum_execution_timeout_in_seconds.to_dict()
            elif isinstance(self.maximum_execution_timeout_in_seconds, list):
                props['MaximumExecutionTimeoutInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_execution_timeout_in_seconds
                ]
            else:
                props['MaximumExecutionTimeoutInSeconds'] = self.maximum_execution_timeout_in_seconds

        if self.termination_wait_in_seconds is not None:
            if hasattr(self.termination_wait_in_seconds, 'to_dict'):
                props['TerminationWaitInSeconds'] = self.termination_wait_in_seconds.to_dict()
            elif isinstance(self.termination_wait_in_seconds, list):
                props['TerminationWaitInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.termination_wait_in_seconds
                ]
            else:
                props['TerminationWaitInSeconds'] = self.termination_wait_in_seconds

        if self.traffic_routing_configuration is not None:
            if hasattr(self.traffic_routing_configuration, 'to_dict'):
                props['TrafficRoutingConfiguration'] = self.traffic_routing_configuration.to_dict()
            elif isinstance(self.traffic_routing_configuration, list):
                props['TrafficRoutingConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.traffic_routing_configuration
                ]
            else:
                props['TrafficRoutingConfiguration'] = self.traffic_routing_configuration

        return props


@dataclass
class CapacitySize:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, CapacitySizeType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class DeploymentConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auto_rollback_configuration: Optional[AutoRollbackConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rolling_update_policy: Optional[RollingUpdatePolicy] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    blue_green_update_policy: Optional[BlueGreenUpdatePolicy] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.auto_rollback_configuration is not None:
            if hasattr(self.auto_rollback_configuration, 'to_dict'):
                props['AutoRollbackConfiguration'] = self.auto_rollback_configuration.to_dict()
            elif isinstance(self.auto_rollback_configuration, list):
                props['AutoRollbackConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_rollback_configuration
                ]
            else:
                props['AutoRollbackConfiguration'] = self.auto_rollback_configuration

        if self.rolling_update_policy is not None:
            if hasattr(self.rolling_update_policy, 'to_dict'):
                props['RollingUpdatePolicy'] = self.rolling_update_policy.to_dict()
            elif isinstance(self.rolling_update_policy, list):
                props['RollingUpdatePolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rolling_update_policy
                ]
            else:
                props['RollingUpdatePolicy'] = self.rolling_update_policy

        if self.blue_green_update_policy is not None:
            if hasattr(self.blue_green_update_policy, 'to_dict'):
                props['BlueGreenUpdatePolicy'] = self.blue_green_update_policy.to_dict()
            elif isinstance(self.blue_green_update_policy, list):
                props['BlueGreenUpdatePolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.blue_green_update_policy
                ]
            else:
                props['BlueGreenUpdatePolicy'] = self.blue_green_update_policy

        return props


@dataclass
class RollingUpdatePolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_execution_timeout_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_batch_size: Optional[CapacitySize] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    wait_interval_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rollback_maximum_batch_size: Optional[CapacitySize] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.maximum_execution_timeout_in_seconds is not None:
            if hasattr(self.maximum_execution_timeout_in_seconds, 'to_dict'):
                props['MaximumExecutionTimeoutInSeconds'] = self.maximum_execution_timeout_in_seconds.to_dict()
            elif isinstance(self.maximum_execution_timeout_in_seconds, list):
                props['MaximumExecutionTimeoutInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_execution_timeout_in_seconds
                ]
            else:
                props['MaximumExecutionTimeoutInSeconds'] = self.maximum_execution_timeout_in_seconds

        if self.maximum_batch_size is not None:
            if hasattr(self.maximum_batch_size, 'to_dict'):
                props['MaximumBatchSize'] = self.maximum_batch_size.to_dict()
            elif isinstance(self.maximum_batch_size, list):
                props['MaximumBatchSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_batch_size
                ]
            else:
                props['MaximumBatchSize'] = self.maximum_batch_size

        if self.wait_interval_in_seconds is not None:
            if hasattr(self.wait_interval_in_seconds, 'to_dict'):
                props['WaitIntervalInSeconds'] = self.wait_interval_in_seconds.to_dict()
            elif isinstance(self.wait_interval_in_seconds, list):
                props['WaitIntervalInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.wait_interval_in_seconds
                ]
            else:
                props['WaitIntervalInSeconds'] = self.wait_interval_in_seconds

        if self.rollback_maximum_batch_size is not None:
            if hasattr(self.rollback_maximum_batch_size, 'to_dict'):
                props['RollbackMaximumBatchSize'] = self.rollback_maximum_batch_size.to_dict()
            elif isinstance(self.rollback_maximum_batch_size, list):
                props['RollbackMaximumBatchSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rollback_maximum_batch_size
                ]
            else:
                props['RollbackMaximumBatchSize'] = self.rollback_maximum_batch_size

        return props


@dataclass
class TrafficRoutingConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, TrafficRoutingConfigType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    linear_step_size: Optional[CapacitySize] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    canary_size: Optional[CapacitySize] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    wait_interval_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.linear_step_size is not None:
            if hasattr(self.linear_step_size, 'to_dict'):
                props['LinearStepSize'] = self.linear_step_size.to_dict()
            elif isinstance(self.linear_step_size, list):
                props['LinearStepSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.linear_step_size
                ]
            else:
                props['LinearStepSize'] = self.linear_step_size

        if self.canary_size is not None:
            if hasattr(self.canary_size, 'to_dict'):
                props['CanarySize'] = self.canary_size.to_dict()
            elif isinstance(self.canary_size, list):
                props['CanarySize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.canary_size
                ]
            else:
                props['CanarySize'] = self.canary_size

        if self.wait_interval_in_seconds is not None:
            if hasattr(self.wait_interval_in_seconds, 'to_dict'):
                props['WaitIntervalInSeconds'] = self.wait_interval_in_seconds.to_dict()
            elif isinstance(self.wait_interval_in_seconds, list):
                props['WaitIntervalInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.wait_interval_in_seconds
                ]
            else:
                props['WaitIntervalInSeconds'] = self.wait_interval_in_seconds

        return props


@dataclass
class VariantProperty:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    variant_property_type: Optional[Union[str, VariantPropertyType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.variant_property_type is not None:
            if hasattr(self.variant_property_type, 'to_dict'):
                props['VariantPropertyType'] = self.variant_property_type.to_dict()
            elif isinstance(self.variant_property_type, list):
                props['VariantPropertyType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.variant_property_type
                ]
            else:
                props['VariantPropertyType'] = self.variant_property_type

        return props


@dataclass
class Endpoint(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::Endpoint"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    retain_all_variant_properties: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    endpoint_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    exclude_retained_variant_properties: Optional[list[VariantProperty]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    endpoint_config_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    deployment_config: Optional[DeploymentConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    retain_deployment_config: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.retain_all_variant_properties is not None:
            # Serialize retain_all_variant_properties (handle intrinsic functions)
            if hasattr(self.retain_all_variant_properties, 'to_dict'):
                props["RetainAllVariantProperties"] = self.retain_all_variant_properties.to_dict()
            elif isinstance(self.retain_all_variant_properties, list):
                # Serialize list items (may contain intrinsic functions)
                props['RetainAllVariantProperties'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.retain_all_variant_properties
                ]
            else:
                props["RetainAllVariantProperties"] = self.retain_all_variant_properties

        if self.endpoint_name is not None:
            # Serialize endpoint_name (handle intrinsic functions)
            if hasattr(self.endpoint_name, 'to_dict'):
                props["EndpointName"] = self.endpoint_name.to_dict()
            elif isinstance(self.endpoint_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndpointName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_name
                ]
            else:
                props["EndpointName"] = self.endpoint_name

        if self.exclude_retained_variant_properties is not None:
            # Serialize exclude_retained_variant_properties (handle intrinsic functions)
            if hasattr(self.exclude_retained_variant_properties, 'to_dict'):
                props["ExcludeRetainedVariantProperties"] = self.exclude_retained_variant_properties.to_dict()
            elif isinstance(self.exclude_retained_variant_properties, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExcludeRetainedVariantProperties'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.exclude_retained_variant_properties
                ]
            else:
                props["ExcludeRetainedVariantProperties"] = self.exclude_retained_variant_properties

        if self.endpoint_config_name is not None:
            # Serialize endpoint_config_name (handle intrinsic functions)
            if hasattr(self.endpoint_config_name, 'to_dict'):
                props["EndpointConfigName"] = self.endpoint_config_name.to_dict()
            elif isinstance(self.endpoint_config_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndpointConfigName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_config_name
                ]
            else:
                props["EndpointConfigName"] = self.endpoint_config_name

        if self.deployment_config is not None:
            # Serialize deployment_config (handle intrinsic functions)
            if hasattr(self.deployment_config, 'to_dict'):
                props["DeploymentConfig"] = self.deployment_config.to_dict()
            elif isinstance(self.deployment_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeploymentConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.deployment_config
                ]
            else:
                props["DeploymentConfig"] = self.deployment_config

        if self.retain_deployment_config is not None:
            # Serialize retain_deployment_config (handle intrinsic functions)
            if hasattr(self.retain_deployment_config, 'to_dict'):
                props["RetainDeploymentConfig"] = self.retain_deployment_config.to_dict()
            elif isinstance(self.retain_deployment_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['RetainDeploymentConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.retain_deployment_config
                ]
            else:
                props["RetainDeploymentConfig"] = self.retain_deployment_config

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_endpoint_name(self) -> GetAtt:
        """Get the EndpointName attribute."""
        return self.get_att("EndpointName")




@dataclass
class AsyncInferenceClientConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_concurrent_invocations_per_instance: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_concurrent_invocations_per_instance is not None:
            if hasattr(self.max_concurrent_invocations_per_instance, 'to_dict'):
                props['MaxConcurrentInvocationsPerInstance'] = self.max_concurrent_invocations_per_instance.to_dict()
            elif isinstance(self.max_concurrent_invocations_per_instance, list):
                props['MaxConcurrentInvocationsPerInstance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_concurrent_invocations_per_instance
                ]
            else:
                props['MaxConcurrentInvocationsPerInstance'] = self.max_concurrent_invocations_per_instance

        return props


@dataclass
class AsyncInferenceConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_config: Optional[AsyncInferenceOutputConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    client_config: Optional[AsyncInferenceClientConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.output_config is not None:
            if hasattr(self.output_config, 'to_dict'):
                props['OutputConfig'] = self.output_config.to_dict()
            elif isinstance(self.output_config, list):
                props['OutputConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_config
                ]
            else:
                props['OutputConfig'] = self.output_config

        if self.client_config is not None:
            if hasattr(self.client_config, 'to_dict'):
                props['ClientConfig'] = self.client_config.to_dict()
            elif isinstance(self.client_config, list):
                props['ClientConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_config
                ]
            else:
                props['ClientConfig'] = self.client_config

        return props


@dataclass
class AsyncInferenceNotificationConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    include_inference_response_in: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    success_topic: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    error_topic: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.include_inference_response_in is not None:
            if hasattr(self.include_inference_response_in, 'to_dict'):
                props['IncludeInferenceResponseIn'] = self.include_inference_response_in.to_dict()
            elif isinstance(self.include_inference_response_in, list):
                props['IncludeInferenceResponseIn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.include_inference_response_in
                ]
            else:
                props['IncludeInferenceResponseIn'] = self.include_inference_response_in

        if self.success_topic is not None:
            if hasattr(self.success_topic, 'to_dict'):
                props['SuccessTopic'] = self.success_topic.to_dict()
            elif isinstance(self.success_topic, list):
                props['SuccessTopic'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.success_topic
                ]
            else:
                props['SuccessTopic'] = self.success_topic

        if self.error_topic is not None:
            if hasattr(self.error_topic, 'to_dict'):
                props['ErrorTopic'] = self.error_topic.to_dict()
            elif isinstance(self.error_topic, list):
                props['ErrorTopic'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.error_topic
                ]
            else:
                props['ErrorTopic'] = self.error_topic

        return props


@dataclass
class AsyncInferenceOutputConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notification_config: Optional[AsyncInferenceNotificationConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_output_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_failure_path: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.notification_config is not None:
            if hasattr(self.notification_config, 'to_dict'):
                props['NotificationConfig'] = self.notification_config.to_dict()
            elif isinstance(self.notification_config, list):
                props['NotificationConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_config
                ]
            else:
                props['NotificationConfig'] = self.notification_config

        if self.s3_output_path is not None:
            if hasattr(self.s3_output_path, 'to_dict'):
                props['S3OutputPath'] = self.s3_output_path.to_dict()
            elif isinstance(self.s3_output_path, list):
                props['S3OutputPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_output_path
                ]
            else:
                props['S3OutputPath'] = self.s3_output_path

        if self.s3_failure_path is not None:
            if hasattr(self.s3_failure_path, 'to_dict'):
                props['S3FailurePath'] = self.s3_failure_path.to_dict()
            elif isinstance(self.s3_failure_path, list):
                props['S3FailurePath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_failure_path
                ]
            else:
                props['S3FailurePath'] = self.s3_failure_path

        return props


@dataclass
class CapacityReservationConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ml_reservation_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_preference: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ml_reservation_arn is not None:
            if hasattr(self.ml_reservation_arn, 'to_dict'):
                props['MlReservationArn'] = self.ml_reservation_arn.to_dict()
            elif isinstance(self.ml_reservation_arn, list):
                props['MlReservationArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ml_reservation_arn
                ]
            else:
                props['MlReservationArn'] = self.ml_reservation_arn

        if self.capacity_reservation_preference is not None:
            if hasattr(self.capacity_reservation_preference, 'to_dict'):
                props['CapacityReservationPreference'] = self.capacity_reservation_preference.to_dict()
            elif isinstance(self.capacity_reservation_preference, list):
                props['CapacityReservationPreference'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_preference
                ]
            else:
                props['CapacityReservationPreference'] = self.capacity_reservation_preference

        return props


@dataclass
class CaptureContentTypeHeader:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    json_content_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    csv_content_types: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.json_content_types is not None:
            if hasattr(self.json_content_types, 'to_dict'):
                props['JsonContentTypes'] = self.json_content_types.to_dict()
            elif isinstance(self.json_content_types, list):
                props['JsonContentTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.json_content_types
                ]
            else:
                props['JsonContentTypes'] = self.json_content_types

        if self.csv_content_types is not None:
            if hasattr(self.csv_content_types, 'to_dict'):
                props['CsvContentTypes'] = self.csv_content_types.to_dict()
            elif isinstance(self.csv_content_types, list):
                props['CsvContentTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.csv_content_types
                ]
            else:
                props['CsvContentTypes'] = self.csv_content_types

        return props


@dataclass
class CaptureOption:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capture_mode: Optional[Union[str, CaptureMode, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capture_mode is not None:
            if hasattr(self.capture_mode, 'to_dict'):
                props['CaptureMode'] = self.capture_mode.to_dict()
            elif isinstance(self.capture_mode, list):
                props['CaptureMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capture_mode
                ]
            else:
                props['CaptureMode'] = self.capture_mode

        return props


@dataclass
class ClarifyExplainerConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inference_config: Optional[ClarifyInferenceConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_explanations: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    shap_config: Optional[ClarifyShapConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.inference_config is not None:
            if hasattr(self.inference_config, 'to_dict'):
                props['InferenceConfig'] = self.inference_config.to_dict()
            elif isinstance(self.inference_config, list):
                props['InferenceConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inference_config
                ]
            else:
                props['InferenceConfig'] = self.inference_config

        if self.enable_explanations is not None:
            if hasattr(self.enable_explanations, 'to_dict'):
                props['EnableExplanations'] = self.enable_explanations.to_dict()
            elif isinstance(self.enable_explanations, list):
                props['EnableExplanations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_explanations
                ]
            else:
                props['EnableExplanations'] = self.enable_explanations

        if self.shap_config is not None:
            if hasattr(self.shap_config, 'to_dict'):
                props['ShapConfig'] = self.shap_config.to_dict()
            elif isinstance(self.shap_config, list):
                props['ShapConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.shap_config
                ]
            else:
                props['ShapConfig'] = self.shap_config

        return props


@dataclass
class ClarifyFeatureType:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    pass


@dataclass
class ClarifyHeader:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    pass


@dataclass
class ClarifyInferenceConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    content_template: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    label_headers: Optional[list[ClarifyHeader]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_payload_in_mb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    probability_index: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    label_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    feature_types: Optional[list[ClarifyFeatureType]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    feature_headers: Optional[list[ClarifyHeader]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    label_index: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    probability_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    features_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_record_count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.content_template is not None:
            if hasattr(self.content_template, 'to_dict'):
                props['ContentTemplate'] = self.content_template.to_dict()
            elif isinstance(self.content_template, list):
                props['ContentTemplate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.content_template
                ]
            else:
                props['ContentTemplate'] = self.content_template

        if self.label_headers is not None:
            if hasattr(self.label_headers, 'to_dict'):
                props['LabelHeaders'] = self.label_headers.to_dict()
            elif isinstance(self.label_headers, list):
                props['LabelHeaders'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.label_headers
                ]
            else:
                props['LabelHeaders'] = self.label_headers

        if self.max_payload_in_mb is not None:
            if hasattr(self.max_payload_in_mb, 'to_dict'):
                props['MaxPayloadInMB'] = self.max_payload_in_mb.to_dict()
            elif isinstance(self.max_payload_in_mb, list):
                props['MaxPayloadInMB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_payload_in_mb
                ]
            else:
                props['MaxPayloadInMB'] = self.max_payload_in_mb

        if self.probability_index is not None:
            if hasattr(self.probability_index, 'to_dict'):
                props['ProbabilityIndex'] = self.probability_index.to_dict()
            elif isinstance(self.probability_index, list):
                props['ProbabilityIndex'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.probability_index
                ]
            else:
                props['ProbabilityIndex'] = self.probability_index

        if self.label_attribute is not None:
            if hasattr(self.label_attribute, 'to_dict'):
                props['LabelAttribute'] = self.label_attribute.to_dict()
            elif isinstance(self.label_attribute, list):
                props['LabelAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.label_attribute
                ]
            else:
                props['LabelAttribute'] = self.label_attribute

        if self.feature_types is not None:
            if hasattr(self.feature_types, 'to_dict'):
                props['FeatureTypes'] = self.feature_types.to_dict()
            elif isinstance(self.feature_types, list):
                props['FeatureTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.feature_types
                ]
            else:
                props['FeatureTypes'] = self.feature_types

        if self.feature_headers is not None:
            if hasattr(self.feature_headers, 'to_dict'):
                props['FeatureHeaders'] = self.feature_headers.to_dict()
            elif isinstance(self.feature_headers, list):
                props['FeatureHeaders'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.feature_headers
                ]
            else:
                props['FeatureHeaders'] = self.feature_headers

        if self.label_index is not None:
            if hasattr(self.label_index, 'to_dict'):
                props['LabelIndex'] = self.label_index.to_dict()
            elif isinstance(self.label_index, list):
                props['LabelIndex'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.label_index
                ]
            else:
                props['LabelIndex'] = self.label_index

        if self.probability_attribute is not None:
            if hasattr(self.probability_attribute, 'to_dict'):
                props['ProbabilityAttribute'] = self.probability_attribute.to_dict()
            elif isinstance(self.probability_attribute, list):
                props['ProbabilityAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.probability_attribute
                ]
            else:
                props['ProbabilityAttribute'] = self.probability_attribute

        if self.features_attribute is not None:
            if hasattr(self.features_attribute, 'to_dict'):
                props['FeaturesAttribute'] = self.features_attribute.to_dict()
            elif isinstance(self.features_attribute, list):
                props['FeaturesAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.features_attribute
                ]
            else:
                props['FeaturesAttribute'] = self.features_attribute

        if self.max_record_count is not None:
            if hasattr(self.max_record_count, 'to_dict'):
                props['MaxRecordCount'] = self.max_record_count.to_dict()
            elif isinstance(self.max_record_count, list):
                props['MaxRecordCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_record_count
                ]
            else:
                props['MaxRecordCount'] = self.max_record_count

        return props


@dataclass
class ClarifyShapBaselineConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    shap_baseline: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    shap_baseline_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mime_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.shap_baseline is not None:
            if hasattr(self.shap_baseline, 'to_dict'):
                props['ShapBaseline'] = self.shap_baseline.to_dict()
            elif isinstance(self.shap_baseline, list):
                props['ShapBaseline'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.shap_baseline
                ]
            else:
                props['ShapBaseline'] = self.shap_baseline

        if self.shap_baseline_uri is not None:
            if hasattr(self.shap_baseline_uri, 'to_dict'):
                props['ShapBaselineUri'] = self.shap_baseline_uri.to_dict()
            elif isinstance(self.shap_baseline_uri, list):
                props['ShapBaselineUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.shap_baseline_uri
                ]
            else:
                props['ShapBaselineUri'] = self.shap_baseline_uri

        if self.mime_type is not None:
            if hasattr(self.mime_type, 'to_dict'):
                props['MimeType'] = self.mime_type.to_dict()
            elif isinstance(self.mime_type, list):
                props['MimeType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mime_type
                ]
            else:
                props['MimeType'] = self.mime_type

        return props


@dataclass
class ClarifyShapConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    text_config: Optional[ClarifyTextConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    use_logit: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    seed: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    shap_baseline_config: Optional[ClarifyShapBaselineConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    number_of_samples: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.text_config is not None:
            if hasattr(self.text_config, 'to_dict'):
                props['TextConfig'] = self.text_config.to_dict()
            elif isinstance(self.text_config, list):
                props['TextConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.text_config
                ]
            else:
                props['TextConfig'] = self.text_config

        if self.use_logit is not None:
            if hasattr(self.use_logit, 'to_dict'):
                props['UseLogit'] = self.use_logit.to_dict()
            elif isinstance(self.use_logit, list):
                props['UseLogit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.use_logit
                ]
            else:
                props['UseLogit'] = self.use_logit

        if self.seed is not None:
            if hasattr(self.seed, 'to_dict'):
                props['Seed'] = self.seed.to_dict()
            elif isinstance(self.seed, list):
                props['Seed'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.seed
                ]
            else:
                props['Seed'] = self.seed

        if self.shap_baseline_config is not None:
            if hasattr(self.shap_baseline_config, 'to_dict'):
                props['ShapBaselineConfig'] = self.shap_baseline_config.to_dict()
            elif isinstance(self.shap_baseline_config, list):
                props['ShapBaselineConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.shap_baseline_config
                ]
            else:
                props['ShapBaselineConfig'] = self.shap_baseline_config

        if self.number_of_samples is not None:
            if hasattr(self.number_of_samples, 'to_dict'):
                props['NumberOfSamples'] = self.number_of_samples.to_dict()
            elif isinstance(self.number_of_samples, list):
                props['NumberOfSamples'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.number_of_samples
                ]
            else:
                props['NumberOfSamples'] = self.number_of_samples

        return props


@dataclass
class ClarifyTextConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    language: Optional[Union[str, ClarifyTextLanguage, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    granularity: Optional[Union[str, ClarifyTextGranularity, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.language is not None:
            if hasattr(self.language, 'to_dict'):
                props['Language'] = self.language.to_dict()
            elif isinstance(self.language, list):
                props['Language'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.language
                ]
            else:
                props['Language'] = self.language

        if self.granularity is not None:
            if hasattr(self.granularity, 'to_dict'):
                props['Granularity'] = self.granularity.to_dict()
            elif isinstance(self.granularity, list):
                props['Granularity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.granularity
                ]
            else:
                props['Granularity'] = self.granularity

        return props


@dataclass
class DataCaptureConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capture_options: Optional[list[CaptureOption]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination_s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    initial_sampling_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capture_content_type_header: Optional[CaptureContentTypeHeader] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_capture: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.capture_options is not None:
            if hasattr(self.capture_options, 'to_dict'):
                props['CaptureOptions'] = self.capture_options.to_dict()
            elif isinstance(self.capture_options, list):
                props['CaptureOptions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capture_options
                ]
            else:
                props['CaptureOptions'] = self.capture_options

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.destination_s3_uri is not None:
            if hasattr(self.destination_s3_uri, 'to_dict'):
                props['DestinationS3Uri'] = self.destination_s3_uri.to_dict()
            elif isinstance(self.destination_s3_uri, list):
                props['DestinationS3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination_s3_uri
                ]
            else:
                props['DestinationS3Uri'] = self.destination_s3_uri

        if self.initial_sampling_percentage is not None:
            if hasattr(self.initial_sampling_percentage, 'to_dict'):
                props['InitialSamplingPercentage'] = self.initial_sampling_percentage.to_dict()
            elif isinstance(self.initial_sampling_percentage, list):
                props['InitialSamplingPercentage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.initial_sampling_percentage
                ]
            else:
                props['InitialSamplingPercentage'] = self.initial_sampling_percentage

        if self.capture_content_type_header is not None:
            if hasattr(self.capture_content_type_header, 'to_dict'):
                props['CaptureContentTypeHeader'] = self.capture_content_type_header.to_dict()
            elif isinstance(self.capture_content_type_header, list):
                props['CaptureContentTypeHeader'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capture_content_type_header
                ]
            else:
                props['CaptureContentTypeHeader'] = self.capture_content_type_header

        if self.enable_capture is not None:
            if hasattr(self.enable_capture, 'to_dict'):
                props['EnableCapture'] = self.enable_capture.to_dict()
            elif isinstance(self.enable_capture, list):
                props['EnableCapture'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_capture
                ]
            else:
                props['EnableCapture'] = self.enable_capture

        return props


@dataclass
class ExplainerConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    clarify_explainer_config: Optional[ClarifyExplainerConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.clarify_explainer_config is not None:
            if hasattr(self.clarify_explainer_config, 'to_dict'):
                props['ClarifyExplainerConfig'] = self.clarify_explainer_config.to_dict()
            elif isinstance(self.clarify_explainer_config, list):
                props['ClarifyExplainerConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.clarify_explainer_config
                ]
            else:
                props['ClarifyExplainerConfig'] = self.clarify_explainer_config

        return props


@dataclass
class ManagedInstanceScaling:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.status is not None:
            if hasattr(self.status, 'to_dict'):
                props['Status'] = self.status.to_dict()
            elif isinstance(self.status, list):
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props['Status'] = self.status

        if self.max_instance_count is not None:
            if hasattr(self.max_instance_count, 'to_dict'):
                props['MaxInstanceCount'] = self.max_instance_count.to_dict()
            elif isinstance(self.max_instance_count, list):
                props['MaxInstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_instance_count
                ]
            else:
                props['MaxInstanceCount'] = self.max_instance_count

        if self.min_instance_count is not None:
            if hasattr(self.min_instance_count, 'to_dict'):
                props['MinInstanceCount'] = self.min_instance_count.to_dict()
            elif isinstance(self.min_instance_count, list):
                props['MinInstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_instance_count
                ]
            else:
                props['MinInstanceCount'] = self.min_instance_count

        return props


@dataclass
class ProductionVariant:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    managed_instance_scaling: Optional[ManagedInstanceScaling] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size_in_gb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_ssm_access: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    variant_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    initial_instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    routing_config: Optional[RoutingConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    initial_variant_weight: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_data_download_timeout_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    capacity_reservation_config: Optional[CapacityReservationConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inference_ami_version: Optional[Union[str, ProductionVariantInferenceAmiVersion, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_startup_health_check_timeout_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    serverless_config: Optional[ServerlessConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, ProductionVariantInstanceType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.managed_instance_scaling is not None:
            if hasattr(self.managed_instance_scaling, 'to_dict'):
                props['ManagedInstanceScaling'] = self.managed_instance_scaling.to_dict()
            elif isinstance(self.managed_instance_scaling, list):
                props['ManagedInstanceScaling'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.managed_instance_scaling
                ]
            else:
                props['ManagedInstanceScaling'] = self.managed_instance_scaling

        if self.model_name is not None:
            if hasattr(self.model_name, 'to_dict'):
                props['ModelName'] = self.model_name.to_dict()
            elif isinstance(self.model_name, list):
                props['ModelName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_name
                ]
            else:
                props['ModelName'] = self.model_name

        if self.volume_size_in_gb is not None:
            if hasattr(self.volume_size_in_gb, 'to_dict'):
                props['VolumeSizeInGB'] = self.volume_size_in_gb.to_dict()
            elif isinstance(self.volume_size_in_gb, list):
                props['VolumeSizeInGB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size_in_gb
                ]
            else:
                props['VolumeSizeInGB'] = self.volume_size_in_gb

        if self.enable_ssm_access is not None:
            if hasattr(self.enable_ssm_access, 'to_dict'):
                props['EnableSSMAccess'] = self.enable_ssm_access.to_dict()
            elif isinstance(self.enable_ssm_access, list):
                props['EnableSSMAccess'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_ssm_access
                ]
            else:
                props['EnableSSMAccess'] = self.enable_ssm_access

        if self.variant_name is not None:
            if hasattr(self.variant_name, 'to_dict'):
                props['VariantName'] = self.variant_name.to_dict()
            elif isinstance(self.variant_name, list):
                props['VariantName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.variant_name
                ]
            else:
                props['VariantName'] = self.variant_name

        if self.initial_instance_count is not None:
            if hasattr(self.initial_instance_count, 'to_dict'):
                props['InitialInstanceCount'] = self.initial_instance_count.to_dict()
            elif isinstance(self.initial_instance_count, list):
                props['InitialInstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.initial_instance_count
                ]
            else:
                props['InitialInstanceCount'] = self.initial_instance_count

        if self.routing_config is not None:
            if hasattr(self.routing_config, 'to_dict'):
                props['RoutingConfig'] = self.routing_config.to_dict()
            elif isinstance(self.routing_config, list):
                props['RoutingConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.routing_config
                ]
            else:
                props['RoutingConfig'] = self.routing_config

        if self.initial_variant_weight is not None:
            if hasattr(self.initial_variant_weight, 'to_dict'):
                props['InitialVariantWeight'] = self.initial_variant_weight.to_dict()
            elif isinstance(self.initial_variant_weight, list):
                props['InitialVariantWeight'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.initial_variant_weight
                ]
            else:
                props['InitialVariantWeight'] = self.initial_variant_weight

        if self.model_data_download_timeout_in_seconds is not None:
            if hasattr(self.model_data_download_timeout_in_seconds, 'to_dict'):
                props['ModelDataDownloadTimeoutInSeconds'] = self.model_data_download_timeout_in_seconds.to_dict()
            elif isinstance(self.model_data_download_timeout_in_seconds, list):
                props['ModelDataDownloadTimeoutInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_data_download_timeout_in_seconds
                ]
            else:
                props['ModelDataDownloadTimeoutInSeconds'] = self.model_data_download_timeout_in_seconds

        if self.capacity_reservation_config is not None:
            if hasattr(self.capacity_reservation_config, 'to_dict'):
                props['CapacityReservationConfig'] = self.capacity_reservation_config.to_dict()
            elif isinstance(self.capacity_reservation_config, list):
                props['CapacityReservationConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.capacity_reservation_config
                ]
            else:
                props['CapacityReservationConfig'] = self.capacity_reservation_config

        if self.inference_ami_version is not None:
            if hasattr(self.inference_ami_version, 'to_dict'):
                props['InferenceAmiVersion'] = self.inference_ami_version.to_dict()
            elif isinstance(self.inference_ami_version, list):
                props['InferenceAmiVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inference_ami_version
                ]
            else:
                props['InferenceAmiVersion'] = self.inference_ami_version

        if self.container_startup_health_check_timeout_in_seconds is not None:
            if hasattr(self.container_startup_health_check_timeout_in_seconds, 'to_dict'):
                props['ContainerStartupHealthCheckTimeoutInSeconds'] = self.container_startup_health_check_timeout_in_seconds.to_dict()
            elif isinstance(self.container_startup_health_check_timeout_in_seconds, list):
                props['ContainerStartupHealthCheckTimeoutInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_startup_health_check_timeout_in_seconds
                ]
            else:
                props['ContainerStartupHealthCheckTimeoutInSeconds'] = self.container_startup_health_check_timeout_in_seconds

        if self.serverless_config is not None:
            if hasattr(self.serverless_config, 'to_dict'):
                props['ServerlessConfig'] = self.serverless_config.to_dict()
            elif isinstance(self.serverless_config, list):
                props['ServerlessConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.serverless_config
                ]
            else:
                props['ServerlessConfig'] = self.serverless_config

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        return props


@dataclass
class RoutingConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    routing_strategy: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.routing_strategy is not None:
            if hasattr(self.routing_strategy, 'to_dict'):
                props['RoutingStrategy'] = self.routing_strategy.to_dict()
            elif isinstance(self.routing_strategy, list):
                props['RoutingStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.routing_strategy
                ]
            else:
                props['RoutingStrategy'] = self.routing_strategy

        return props


@dataclass
class ServerlessConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_concurrency: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    memory_size_in_mb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provisioned_concurrency: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_concurrency is not None:
            if hasattr(self.max_concurrency, 'to_dict'):
                props['MaxConcurrency'] = self.max_concurrency.to_dict()
            elif isinstance(self.max_concurrency, list):
                props['MaxConcurrency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_concurrency
                ]
            else:
                props['MaxConcurrency'] = self.max_concurrency

        if self.memory_size_in_mb is not None:
            if hasattr(self.memory_size_in_mb, 'to_dict'):
                props['MemorySizeInMB'] = self.memory_size_in_mb.to_dict()
            elif isinstance(self.memory_size_in_mb, list):
                props['MemorySizeInMB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.memory_size_in_mb
                ]
            else:
                props['MemorySizeInMB'] = self.memory_size_in_mb

        if self.provisioned_concurrency is not None:
            if hasattr(self.provisioned_concurrency, 'to_dict'):
                props['ProvisionedConcurrency'] = self.provisioned_concurrency.to_dict()
            elif isinstance(self.provisioned_concurrency, list):
                props['ProvisionedConcurrency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.provisioned_concurrency
                ]
            else:
                props['ProvisionedConcurrency'] = self.provisioned_concurrency

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnets: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnets is not None:
            if hasattr(self.subnets, 'to_dict'):
                props['Subnets'] = self.subnets.to_dict()
            elif isinstance(self.subnets, list):
                props['Subnets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnets
                ]
            else:
                props['Subnets'] = self.subnets

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class EndpointConfig(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::EndpointConfig"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    shadow_production_variants: Optional[list[ProductionVariant]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_capture_config: Optional[DataCaptureConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    execution_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_network_isolation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    production_variants: Optional[list[ProductionVariant]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    async_inference_config: Optional[AsyncInferenceConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_config: Optional[VpcConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    endpoint_config_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    explainer_config: Optional[ExplainerConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.shadow_production_variants is not None:
            # Serialize shadow_production_variants (handle intrinsic functions)
            if hasattr(self.shadow_production_variants, 'to_dict'):
                props["ShadowProductionVariants"] = self.shadow_production_variants.to_dict()
            elif isinstance(self.shadow_production_variants, list):
                # Serialize list items (may contain intrinsic functions)
                props['ShadowProductionVariants'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.shadow_production_variants
                ]
            else:
                props["ShadowProductionVariants"] = self.shadow_production_variants

        if self.data_capture_config is not None:
            # Serialize data_capture_config (handle intrinsic functions)
            if hasattr(self.data_capture_config, 'to_dict'):
                props["DataCaptureConfig"] = self.data_capture_config.to_dict()
            elif isinstance(self.data_capture_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataCaptureConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_capture_config
                ]
            else:
                props["DataCaptureConfig"] = self.data_capture_config

        if self.execution_role_arn is not None:
            # Serialize execution_role_arn (handle intrinsic functions)
            if hasattr(self.execution_role_arn, 'to_dict'):
                props["ExecutionRoleArn"] = self.execution_role_arn.to_dict()
            elif isinstance(self.execution_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExecutionRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role_arn
                ]
            else:
                props["ExecutionRoleArn"] = self.execution_role_arn

        if self.enable_network_isolation is not None:
            # Serialize enable_network_isolation (handle intrinsic functions)
            if hasattr(self.enable_network_isolation, 'to_dict'):
                props["EnableNetworkIsolation"] = self.enable_network_isolation.to_dict()
            elif isinstance(self.enable_network_isolation, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableNetworkIsolation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_network_isolation
                ]
            else:
                props["EnableNetworkIsolation"] = self.enable_network_isolation

        if self.production_variants is not None:
            # Serialize production_variants (handle intrinsic functions)
            if hasattr(self.production_variants, 'to_dict'):
                props["ProductionVariants"] = self.production_variants.to_dict()
            elif isinstance(self.production_variants, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProductionVariants'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.production_variants
                ]
            else:
                props["ProductionVariants"] = self.production_variants

        if self.kms_key_id is not None:
            # Serialize kms_key_id (handle intrinsic functions)
            if hasattr(self.kms_key_id, 'to_dict'):
                props["KmsKeyId"] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props["KmsKeyId"] = self.kms_key_id

        if self.async_inference_config is not None:
            # Serialize async_inference_config (handle intrinsic functions)
            if hasattr(self.async_inference_config, 'to_dict'):
                props["AsyncInferenceConfig"] = self.async_inference_config.to_dict()
            elif isinstance(self.async_inference_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['AsyncInferenceConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.async_inference_config
                ]
            else:
                props["AsyncInferenceConfig"] = self.async_inference_config

        if self.vpc_config is not None:
            # Serialize vpc_config (handle intrinsic functions)
            if hasattr(self.vpc_config, 'to_dict'):
                props["VpcConfig"] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props["VpcConfig"] = self.vpc_config

        if self.endpoint_config_name is not None:
            # Serialize endpoint_config_name (handle intrinsic functions)
            if hasattr(self.endpoint_config_name, 'to_dict'):
                props["EndpointConfigName"] = self.endpoint_config_name.to_dict()
            elif isinstance(self.endpoint_config_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndpointConfigName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_config_name
                ]
            else:
                props["EndpointConfigName"] = self.endpoint_config_name

        if self.explainer_config is not None:
            # Serialize explainer_config (handle intrinsic functions)
            if hasattr(self.explainer_config, 'to_dict'):
                props["ExplainerConfig"] = self.explainer_config.to_dict()
            elif isinstance(self.explainer_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExplainerConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.explainer_config
                ]
            else:
                props["ExplainerConfig"] = self.explainer_config

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_endpoint_config_name(self) -> GetAtt:
        """Get the EndpointConfigName attribute."""
        return self.get_att("EndpointConfigName")




@dataclass
class DataCatalogConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    table_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.table_name is not None:
            if hasattr(self.table_name, 'to_dict'):
                props['TableName'] = self.table_name.to_dict()
            elif isinstance(self.table_name, list):
                props['TableName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.table_name
                ]
            else:
                props['TableName'] = self.table_name

        if self.database is not None:
            if hasattr(self.database, 'to_dict'):
                props['Database'] = self.database.to_dict()
            elif isinstance(self.database, list):
                props['Database'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.database
                ]
            else:
                props['Database'] = self.database

        if self.catalog is not None:
            if hasattr(self.catalog, 'to_dict'):
                props['Catalog'] = self.catalog.to_dict()
            elif isinstance(self.catalog, list):
                props['Catalog'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.catalog
                ]
            else:
                props['Catalog'] = self.catalog

        return props


@dataclass
class FeatureDefinition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    feature_type: Optional[Union[str, FeatureType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    feature_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.feature_type is not None:
            if hasattr(self.feature_type, 'to_dict'):
                props['FeatureType'] = self.feature_type.to_dict()
            elif isinstance(self.feature_type, list):
                props['FeatureType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.feature_type
                ]
            else:
                props['FeatureType'] = self.feature_type

        if self.feature_name is not None:
            if hasattr(self.feature_name, 'to_dict'):
                props['FeatureName'] = self.feature_name.to_dict()
            elif isinstance(self.feature_name, list):
                props['FeatureName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.feature_name
                ]
            else:
                props['FeatureName'] = self.feature_name

        return props


@dataclass
class OfflineStoreConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_catalog_config: Optional[DataCatalogConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_storage_config: Optional[S3StorageConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    disable_glue_table_creation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    table_format: Optional[Union[str, TableFormat, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.data_catalog_config is not None:
            if hasattr(self.data_catalog_config, 'to_dict'):
                props['DataCatalogConfig'] = self.data_catalog_config.to_dict()
            elif isinstance(self.data_catalog_config, list):
                props['DataCatalogConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_catalog_config
                ]
            else:
                props['DataCatalogConfig'] = self.data_catalog_config

        if self.s3_storage_config is not None:
            if hasattr(self.s3_storage_config, 'to_dict'):
                props['S3StorageConfig'] = self.s3_storage_config.to_dict()
            elif isinstance(self.s3_storage_config, list):
                props['S3StorageConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_storage_config
                ]
            else:
                props['S3StorageConfig'] = self.s3_storage_config

        if self.disable_glue_table_creation is not None:
            if hasattr(self.disable_glue_table_creation, 'to_dict'):
                props['DisableGlueTableCreation'] = self.disable_glue_table_creation.to_dict()
            elif isinstance(self.disable_glue_table_creation, list):
                props['DisableGlueTableCreation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.disable_glue_table_creation
                ]
            else:
                props['DisableGlueTableCreation'] = self.disable_glue_table_creation

        if self.table_format is not None:
            if hasattr(self.table_format, 'to_dict'):
                props['TableFormat'] = self.table_format.to_dict()
            elif isinstance(self.table_format, list):
                props['TableFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.table_format
                ]
            else:
                props['TableFormat'] = self.table_format

        return props


@dataclass
class OnlineStoreConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_online_store: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    storage_type: Optional[Union[str, StorageType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_config: Optional[OnlineStoreSecurityConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ttl_duration: Optional[TtlDuration] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enable_online_store is not None:
            if hasattr(self.enable_online_store, 'to_dict'):
                props['EnableOnlineStore'] = self.enable_online_store.to_dict()
            elif isinstance(self.enable_online_store, list):
                props['EnableOnlineStore'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_online_store
                ]
            else:
                props['EnableOnlineStore'] = self.enable_online_store

        if self.storage_type is not None:
            if hasattr(self.storage_type, 'to_dict'):
                props['StorageType'] = self.storage_type.to_dict()
            elif isinstance(self.storage_type, list):
                props['StorageType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.storage_type
                ]
            else:
                props['StorageType'] = self.storage_type

        if self.security_config is not None:
            if hasattr(self.security_config, 'to_dict'):
                props['SecurityConfig'] = self.security_config.to_dict()
            elif isinstance(self.security_config, list):
                props['SecurityConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_config
                ]
            else:
                props['SecurityConfig'] = self.security_config

        if self.ttl_duration is not None:
            if hasattr(self.ttl_duration, 'to_dict'):
                props['TtlDuration'] = self.ttl_duration.to_dict()
            elif isinstance(self.ttl_duration, list):
                props['TtlDuration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ttl_duration
                ]
            else:
                props['TtlDuration'] = self.ttl_duration

        return props


@dataclass
class OnlineStoreSecurityConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        return props


@dataclass
class S3StorageConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        return props


@dataclass
class ThroughputConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provisioned_read_capacity_units: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provisioned_write_capacity_units: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    throughput_mode: Optional[Union[str, ThroughputMode, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.provisioned_read_capacity_units is not None:
            if hasattr(self.provisioned_read_capacity_units, 'to_dict'):
                props['ProvisionedReadCapacityUnits'] = self.provisioned_read_capacity_units.to_dict()
            elif isinstance(self.provisioned_read_capacity_units, list):
                props['ProvisionedReadCapacityUnits'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.provisioned_read_capacity_units
                ]
            else:
                props['ProvisionedReadCapacityUnits'] = self.provisioned_read_capacity_units

        if self.provisioned_write_capacity_units is not None:
            if hasattr(self.provisioned_write_capacity_units, 'to_dict'):
                props['ProvisionedWriteCapacityUnits'] = self.provisioned_write_capacity_units.to_dict()
            elif isinstance(self.provisioned_write_capacity_units, list):
                props['ProvisionedWriteCapacityUnits'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.provisioned_write_capacity_units
                ]
            else:
                props['ProvisionedWriteCapacityUnits'] = self.provisioned_write_capacity_units

        if self.throughput_mode is not None:
            if hasattr(self.throughput_mode, 'to_dict'):
                props['ThroughputMode'] = self.throughput_mode.to_dict()
            elif isinstance(self.throughput_mode, list):
                props['ThroughputMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.throughput_mode
                ]
            else:
                props['ThroughputMode'] = self.throughput_mode

        return props


@dataclass
class TtlDuration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unit: Optional[Union[str, TtlDurationUnit, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.unit is not None:
            if hasattr(self.unit, 'to_dict'):
                props['Unit'] = self.unit.to_dict()
            elif isinstance(self.unit, list):
                props['Unit'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unit
                ]
            else:
                props['Unit'] = self.unit

        return props


@dataclass
class FeatureGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::FeatureGroup"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    throughput_config: Optional[ThroughputConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    offline_store_config: Optional[OfflineStoreConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    feature_definitions: Optional[list[FeatureDefinition]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    record_identifier_feature_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    event_time_feature_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    feature_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    online_store_config: Optional[OnlineStoreConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.throughput_config is not None:
            # Serialize throughput_config (handle intrinsic functions)
            if hasattr(self.throughput_config, 'to_dict'):
                props["ThroughputConfig"] = self.throughput_config.to_dict()
            elif isinstance(self.throughput_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ThroughputConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.throughput_config
                ]
            else:
                props["ThroughputConfig"] = self.throughput_config

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.offline_store_config is not None:
            # Serialize offline_store_config (handle intrinsic functions)
            if hasattr(self.offline_store_config, 'to_dict'):
                props["OfflineStoreConfig"] = self.offline_store_config.to_dict()
            elif isinstance(self.offline_store_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['OfflineStoreConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.offline_store_config
                ]
            else:
                props["OfflineStoreConfig"] = self.offline_store_config

        if self.feature_definitions is not None:
            # Serialize feature_definitions (handle intrinsic functions)
            if hasattr(self.feature_definitions, 'to_dict'):
                props["FeatureDefinitions"] = self.feature_definitions.to_dict()
            elif isinstance(self.feature_definitions, list):
                # Serialize list items (may contain intrinsic functions)
                props['FeatureDefinitions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.feature_definitions
                ]
            else:
                props["FeatureDefinitions"] = self.feature_definitions

        if self.record_identifier_feature_name is not None:
            # Serialize record_identifier_feature_name (handle intrinsic functions)
            if hasattr(self.record_identifier_feature_name, 'to_dict'):
                props["RecordIdentifierFeatureName"] = self.record_identifier_feature_name.to_dict()
            elif isinstance(self.record_identifier_feature_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['RecordIdentifierFeatureName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.record_identifier_feature_name
                ]
            else:
                props["RecordIdentifierFeatureName"] = self.record_identifier_feature_name

        if self.event_time_feature_name is not None:
            # Serialize event_time_feature_name (handle intrinsic functions)
            if hasattr(self.event_time_feature_name, 'to_dict'):
                props["EventTimeFeatureName"] = self.event_time_feature_name.to_dict()
            elif isinstance(self.event_time_feature_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['EventTimeFeatureName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.event_time_feature_name
                ]
            else:
                props["EventTimeFeatureName"] = self.event_time_feature_name

        if self.feature_group_name is not None:
            # Serialize feature_group_name (handle intrinsic functions)
            if hasattr(self.feature_group_name, 'to_dict'):
                props["FeatureGroupName"] = self.feature_group_name.to_dict()
            elif isinstance(self.feature_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['FeatureGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.feature_group_name
                ]
            else:
                props["FeatureGroupName"] = self.feature_group_name

        if self.online_store_config is not None:
            # Serialize online_store_config (handle intrinsic functions)
            if hasattr(self.online_store_config, 'to_dict'):
                props["OnlineStoreConfig"] = self.online_store_config.to_dict()
            elif isinstance(self.online_store_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['OnlineStoreConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.online_store_config
                ]
            else:
                props["OnlineStoreConfig"] = self.online_store_config

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_feature_group_status(self) -> GetAtt:
        """Get the FeatureGroupStatus attribute."""
        return self.get_att("FeatureGroupStatus")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")




@dataclass
class Image(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::Image"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    image_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    image_display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    image_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    image_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.image_name is not None:
            # Serialize image_name (handle intrinsic functions)
            if hasattr(self.image_name, 'to_dict'):
                props["ImageName"] = self.image_name.to_dict()
            elif isinstance(self.image_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ImageName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_name
                ]
            else:
                props["ImageName"] = self.image_name

        if self.image_display_name is not None:
            # Serialize image_display_name (handle intrinsic functions)
            if hasattr(self.image_display_name, 'to_dict'):
                props["ImageDisplayName"] = self.image_display_name.to_dict()
            elif isinstance(self.image_display_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ImageDisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_display_name
                ]
            else:
                props["ImageDisplayName"] = self.image_display_name

        if self.image_role_arn is not None:
            # Serialize image_role_arn (handle intrinsic functions)
            if hasattr(self.image_role_arn, 'to_dict'):
                props["ImageRoleArn"] = self.image_role_arn.to_dict()
            elif isinstance(self.image_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ImageRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_role_arn
                ]
            else:
                props["ImageRoleArn"] = self.image_role_arn

        if self.image_description is not None:
            # Serialize image_description (handle intrinsic functions)
            if hasattr(self.image_description, 'to_dict'):
                props["ImageDescription"] = self.image_description.to_dict()
            elif isinstance(self.image_description, list):
                # Serialize list items (may contain intrinsic functions)
                props['ImageDescription'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_description
                ]
            else:
                props["ImageDescription"] = self.image_description

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_image_arn(self) -> GetAtt:
        """Get the ImageArn attribute."""
        return self.get_att("ImageArn")




@dataclass
class ImageVersion(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::ImageVersion"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    image_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    horovod: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    processor: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    job_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    alias: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    programming_lang: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vendor_guidance: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ml_framework: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    aliases: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    release_notes: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    base_image: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.image_name is not None:
            # Serialize image_name (handle intrinsic functions)
            if hasattr(self.image_name, 'to_dict'):
                props["ImageName"] = self.image_name.to_dict()
            elif isinstance(self.image_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ImageName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_name
                ]
            else:
                props["ImageName"] = self.image_name

        if self.horovod is not None:
            # Serialize horovod (handle intrinsic functions)
            if hasattr(self.horovod, 'to_dict'):
                props["Horovod"] = self.horovod.to_dict()
            elif isinstance(self.horovod, list):
                # Serialize list items (may contain intrinsic functions)
                props['Horovod'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.horovod
                ]
            else:
                props["Horovod"] = self.horovod

        if self.processor is not None:
            # Serialize processor (handle intrinsic functions)
            if hasattr(self.processor, 'to_dict'):
                props["Processor"] = self.processor.to_dict()
            elif isinstance(self.processor, list):
                # Serialize list items (may contain intrinsic functions)
                props['Processor'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.processor
                ]
            else:
                props["Processor"] = self.processor

        if self.job_type is not None:
            # Serialize job_type (handle intrinsic functions)
            if hasattr(self.job_type, 'to_dict'):
                props["JobType"] = self.job_type.to_dict()
            elif isinstance(self.job_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['JobType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.job_type
                ]
            else:
                props["JobType"] = self.job_type

        if self.alias is not None:
            # Serialize alias (handle intrinsic functions)
            if hasattr(self.alias, 'to_dict'):
                props["Alias"] = self.alias.to_dict()
            elif isinstance(self.alias, list):
                # Serialize list items (may contain intrinsic functions)
                props['Alias'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.alias
                ]
            else:
                props["Alias"] = self.alias

        if self.programming_lang is not None:
            # Serialize programming_lang (handle intrinsic functions)
            if hasattr(self.programming_lang, 'to_dict'):
                props["ProgrammingLang"] = self.programming_lang.to_dict()
            elif isinstance(self.programming_lang, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProgrammingLang'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.programming_lang
                ]
            else:
                props["ProgrammingLang"] = self.programming_lang

        if self.vendor_guidance is not None:
            # Serialize vendor_guidance (handle intrinsic functions)
            if hasattr(self.vendor_guidance, 'to_dict'):
                props["VendorGuidance"] = self.vendor_guidance.to_dict()
            elif isinstance(self.vendor_guidance, list):
                # Serialize list items (may contain intrinsic functions)
                props['VendorGuidance'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vendor_guidance
                ]
            else:
                props["VendorGuidance"] = self.vendor_guidance

        if self.ml_framework is not None:
            # Serialize ml_framework (handle intrinsic functions)
            if hasattr(self.ml_framework, 'to_dict'):
                props["MLFramework"] = self.ml_framework.to_dict()
            elif isinstance(self.ml_framework, list):
                # Serialize list items (may contain intrinsic functions)
                props['MLFramework'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ml_framework
                ]
            else:
                props["MLFramework"] = self.ml_framework

        if self.aliases is not None:
            # Serialize aliases (handle intrinsic functions)
            if hasattr(self.aliases, 'to_dict'):
                props["Aliases"] = self.aliases.to_dict()
            elif isinstance(self.aliases, list):
                # Serialize list items (may contain intrinsic functions)
                props['Aliases'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.aliases
                ]
            else:
                props["Aliases"] = self.aliases

        if self.release_notes is not None:
            # Serialize release_notes (handle intrinsic functions)
            if hasattr(self.release_notes, 'to_dict'):
                props["ReleaseNotes"] = self.release_notes.to_dict()
            elif isinstance(self.release_notes, list):
                # Serialize list items (may contain intrinsic functions)
                props['ReleaseNotes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.release_notes
                ]
            else:
                props["ReleaseNotes"] = self.release_notes

        if self.base_image is not None:
            # Serialize base_image (handle intrinsic functions)
            if hasattr(self.base_image, 'to_dict'):
                props["BaseImage"] = self.base_image.to_dict()
            elif isinstance(self.base_image, list):
                # Serialize list items (may contain intrinsic functions)
                props['BaseImage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.base_image
                ]
            else:
                props["BaseImage"] = self.base_image

        return props

    @property
    def attr_image_version_arn(self) -> GetAtt:
        """Get the ImageVersionArn attribute."""
        return self.get_att("ImageVersionArn")

    @property
    def attr_version(self) -> GetAtt:
        """Get the Version attribute."""
        return self.get_att("Version")

    @property
    def attr_container_image(self) -> GetAtt:
        """Get the ContainerImage attribute."""
        return self.get_att("ContainerImage")

    @property
    def attr_image_arn(self) -> GetAtt:
        """Get the ImageArn attribute."""
        return self.get_att("ImageArn")




@dataclass
class Alarm:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    alarm_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.alarm_name is not None:
            if hasattr(self.alarm_name, 'to_dict'):
                props['AlarmName'] = self.alarm_name.to_dict()
            elif isinstance(self.alarm_name, list):
                props['AlarmName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.alarm_name
                ]
            else:
                props['AlarmName'] = self.alarm_name

        return props


@dataclass
class AutoRollbackConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    alarms: Optional[list[Alarm]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.alarms is not None:
            if hasattr(self.alarms, 'to_dict'):
                props['Alarms'] = self.alarms.to_dict()
            elif isinstance(self.alarms, list):
                props['Alarms'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.alarms
                ]
            else:
                props['Alarms'] = self.alarms

        return props


@dataclass
class DeployedImage:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resolution_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    specified_image: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resolved_image: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resolution_time is not None:
            if hasattr(self.resolution_time, 'to_dict'):
                props['ResolutionTime'] = self.resolution_time.to_dict()
            elif isinstance(self.resolution_time, list):
                props['ResolutionTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resolution_time
                ]
            else:
                props['ResolutionTime'] = self.resolution_time

        if self.specified_image is not None:
            if hasattr(self.specified_image, 'to_dict'):
                props['SpecifiedImage'] = self.specified_image.to_dict()
            elif isinstance(self.specified_image, list):
                props['SpecifiedImage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.specified_image
                ]
            else:
                props['SpecifiedImage'] = self.specified_image

        if self.resolved_image is not None:
            if hasattr(self.resolved_image, 'to_dict'):
                props['ResolvedImage'] = self.resolved_image.to_dict()
            elif isinstance(self.resolved_image, list):
                props['ResolvedImage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resolved_image
                ]
            else:
                props['ResolvedImage'] = self.resolved_image

        return props


@dataclass
class InferenceComponentCapacitySize:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, InferenceComponentCapacitySizeType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        return props


@dataclass
class InferenceComponentComputeResourceRequirements:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    number_of_accelerator_devices_required: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_memory_required_in_mb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_memory_required_in_mb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    number_of_cpu_cores_required: Optional[Union[float, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.number_of_accelerator_devices_required is not None:
            if hasattr(self.number_of_accelerator_devices_required, 'to_dict'):
                props['NumberOfAcceleratorDevicesRequired'] = self.number_of_accelerator_devices_required.to_dict()
            elif isinstance(self.number_of_accelerator_devices_required, list):
                props['NumberOfAcceleratorDevicesRequired'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.number_of_accelerator_devices_required
                ]
            else:
                props['NumberOfAcceleratorDevicesRequired'] = self.number_of_accelerator_devices_required

        if self.max_memory_required_in_mb is not None:
            if hasattr(self.max_memory_required_in_mb, 'to_dict'):
                props['MaxMemoryRequiredInMb'] = self.max_memory_required_in_mb.to_dict()
            elif isinstance(self.max_memory_required_in_mb, list):
                props['MaxMemoryRequiredInMb'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_memory_required_in_mb
                ]
            else:
                props['MaxMemoryRequiredInMb'] = self.max_memory_required_in_mb

        if self.min_memory_required_in_mb is not None:
            if hasattr(self.min_memory_required_in_mb, 'to_dict'):
                props['MinMemoryRequiredInMb'] = self.min_memory_required_in_mb.to_dict()
            elif isinstance(self.min_memory_required_in_mb, list):
                props['MinMemoryRequiredInMb'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_memory_required_in_mb
                ]
            else:
                props['MinMemoryRequiredInMb'] = self.min_memory_required_in_mb

        if self.number_of_cpu_cores_required is not None:
            if hasattr(self.number_of_cpu_cores_required, 'to_dict'):
                props['NumberOfCpuCoresRequired'] = self.number_of_cpu_cores_required.to_dict()
            elif isinstance(self.number_of_cpu_cores_required, list):
                props['NumberOfCpuCoresRequired'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.number_of_cpu_cores_required
                ]
            else:
                props['NumberOfCpuCoresRequired'] = self.number_of_cpu_cores_required

        return props


@dataclass
class InferenceComponentContainerSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    artifact_url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    environment: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    deployed_image: Optional[DeployedImage] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.artifact_url is not None:
            if hasattr(self.artifact_url, 'to_dict'):
                props['ArtifactUrl'] = self.artifact_url.to_dict()
            elif isinstance(self.artifact_url, list):
                props['ArtifactUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.artifact_url
                ]
            else:
                props['ArtifactUrl'] = self.artifact_url

        if self.environment is not None:
            if hasattr(self.environment, 'to_dict'):
                props['Environment'] = self.environment.to_dict()
            elif isinstance(self.environment, list):
                props['Environment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment
                ]
            else:
                props['Environment'] = self.environment

        if self.deployed_image is not None:
            if hasattr(self.deployed_image, 'to_dict'):
                props['DeployedImage'] = self.deployed_image.to_dict()
            elif isinstance(self.deployed_image, list):
                props['DeployedImage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.deployed_image
                ]
            else:
                props['DeployedImage'] = self.deployed_image

        if self.image is not None:
            if hasattr(self.image, 'to_dict'):
                props['Image'] = self.image.to_dict()
            elif isinstance(self.image, list):
                props['Image'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image
                ]
            else:
                props['Image'] = self.image

        return props


@dataclass
class InferenceComponentDeploymentConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auto_rollback_configuration: Optional[AutoRollbackConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rolling_update_policy: Optional[InferenceComponentRollingUpdatePolicy] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.auto_rollback_configuration is not None:
            if hasattr(self.auto_rollback_configuration, 'to_dict'):
                props['AutoRollbackConfiguration'] = self.auto_rollback_configuration.to_dict()
            elif isinstance(self.auto_rollback_configuration, list):
                props['AutoRollbackConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_rollback_configuration
                ]
            else:
                props['AutoRollbackConfiguration'] = self.auto_rollback_configuration

        if self.rolling_update_policy is not None:
            if hasattr(self.rolling_update_policy, 'to_dict'):
                props['RollingUpdatePolicy'] = self.rolling_update_policy.to_dict()
            elif isinstance(self.rolling_update_policy, list):
                props['RollingUpdatePolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rolling_update_policy
                ]
            else:
                props['RollingUpdatePolicy'] = self.rolling_update_policy

        return props


@dataclass
class InferenceComponentRollingUpdatePolicy:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_execution_timeout_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_batch_size: Optional[InferenceComponentCapacitySize] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    wait_interval_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rollback_maximum_batch_size: Optional[InferenceComponentCapacitySize] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.maximum_execution_timeout_in_seconds is not None:
            if hasattr(self.maximum_execution_timeout_in_seconds, 'to_dict'):
                props['MaximumExecutionTimeoutInSeconds'] = self.maximum_execution_timeout_in_seconds.to_dict()
            elif isinstance(self.maximum_execution_timeout_in_seconds, list):
                props['MaximumExecutionTimeoutInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_execution_timeout_in_seconds
                ]
            else:
                props['MaximumExecutionTimeoutInSeconds'] = self.maximum_execution_timeout_in_seconds

        if self.maximum_batch_size is not None:
            if hasattr(self.maximum_batch_size, 'to_dict'):
                props['MaximumBatchSize'] = self.maximum_batch_size.to_dict()
            elif isinstance(self.maximum_batch_size, list):
                props['MaximumBatchSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_batch_size
                ]
            else:
                props['MaximumBatchSize'] = self.maximum_batch_size

        if self.wait_interval_in_seconds is not None:
            if hasattr(self.wait_interval_in_seconds, 'to_dict'):
                props['WaitIntervalInSeconds'] = self.wait_interval_in_seconds.to_dict()
            elif isinstance(self.wait_interval_in_seconds, list):
                props['WaitIntervalInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.wait_interval_in_seconds
                ]
            else:
                props['WaitIntervalInSeconds'] = self.wait_interval_in_seconds

        if self.rollback_maximum_batch_size is not None:
            if hasattr(self.rollback_maximum_batch_size, 'to_dict'):
                props['RollbackMaximumBatchSize'] = self.rollback_maximum_batch_size.to_dict()
            elif isinstance(self.rollback_maximum_batch_size, list):
                props['RollbackMaximumBatchSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rollback_maximum_batch_size
                ]
            else:
                props['RollbackMaximumBatchSize'] = self.rollback_maximum_batch_size

        return props


@dataclass
class InferenceComponentRuntimeConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    current_copy_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    desired_copy_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    copy_count: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.current_copy_count is not None:
            if hasattr(self.current_copy_count, 'to_dict'):
                props['CurrentCopyCount'] = self.current_copy_count.to_dict()
            elif isinstance(self.current_copy_count, list):
                props['CurrentCopyCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.current_copy_count
                ]
            else:
                props['CurrentCopyCount'] = self.current_copy_count

        if self.desired_copy_count is not None:
            if hasattr(self.desired_copy_count, 'to_dict'):
                props['DesiredCopyCount'] = self.desired_copy_count.to_dict()
            elif isinstance(self.desired_copy_count, list):
                props['DesiredCopyCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.desired_copy_count
                ]
            else:
                props['DesiredCopyCount'] = self.desired_copy_count

        if self.copy_count is not None:
            if hasattr(self.copy_count, 'to_dict'):
                props['CopyCount'] = self.copy_count.to_dict()
            elif isinstance(self.copy_count, list):
                props['CopyCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.copy_count
                ]
            else:
                props['CopyCount'] = self.copy_count

        return props


@dataclass
class InferenceComponentSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container: Optional[InferenceComponentContainerSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    compute_resource_requirements: Optional[InferenceComponentComputeResourceRequirements] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    base_inference_component_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    startup_parameters: Optional[InferenceComponentStartupParameters] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.container is not None:
            if hasattr(self.container, 'to_dict'):
                props['Container'] = self.container.to_dict()
            elif isinstance(self.container, list):
                props['Container'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container
                ]
            else:
                props['Container'] = self.container

        if self.model_name is not None:
            if hasattr(self.model_name, 'to_dict'):
                props['ModelName'] = self.model_name.to_dict()
            elif isinstance(self.model_name, list):
                props['ModelName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_name
                ]
            else:
                props['ModelName'] = self.model_name

        if self.compute_resource_requirements is not None:
            if hasattr(self.compute_resource_requirements, 'to_dict'):
                props['ComputeResourceRequirements'] = self.compute_resource_requirements.to_dict()
            elif isinstance(self.compute_resource_requirements, list):
                props['ComputeResourceRequirements'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compute_resource_requirements
                ]
            else:
                props['ComputeResourceRequirements'] = self.compute_resource_requirements

        if self.base_inference_component_name is not None:
            if hasattr(self.base_inference_component_name, 'to_dict'):
                props['BaseInferenceComponentName'] = self.base_inference_component_name.to_dict()
            elif isinstance(self.base_inference_component_name, list):
                props['BaseInferenceComponentName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.base_inference_component_name
                ]
            else:
                props['BaseInferenceComponentName'] = self.base_inference_component_name

        if self.startup_parameters is not None:
            if hasattr(self.startup_parameters, 'to_dict'):
                props['StartupParameters'] = self.startup_parameters.to_dict()
            elif isinstance(self.startup_parameters, list):
                props['StartupParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.startup_parameters
                ]
            else:
                props['StartupParameters'] = self.startup_parameters

        return props


@dataclass
class InferenceComponentStartupParameters:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_data_download_timeout_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_startup_health_check_timeout_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_data_download_timeout_in_seconds is not None:
            if hasattr(self.model_data_download_timeout_in_seconds, 'to_dict'):
                props['ModelDataDownloadTimeoutInSeconds'] = self.model_data_download_timeout_in_seconds.to_dict()
            elif isinstance(self.model_data_download_timeout_in_seconds, list):
                props['ModelDataDownloadTimeoutInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_data_download_timeout_in_seconds
                ]
            else:
                props['ModelDataDownloadTimeoutInSeconds'] = self.model_data_download_timeout_in_seconds

        if self.container_startup_health_check_timeout_in_seconds is not None:
            if hasattr(self.container_startup_health_check_timeout_in_seconds, 'to_dict'):
                props['ContainerStartupHealthCheckTimeoutInSeconds'] = self.container_startup_health_check_timeout_in_seconds.to_dict()
            elif isinstance(self.container_startup_health_check_timeout_in_seconds, list):
                props['ContainerStartupHealthCheckTimeoutInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_startup_health_check_timeout_in_seconds
                ]
            else:
                props['ContainerStartupHealthCheckTimeoutInSeconds'] = self.container_startup_health_check_timeout_in_seconds

        return props


@dataclass
class InferenceComponent(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::InferenceComponent"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    endpoint_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    variant_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    inference_component_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    specification: Optional[InferenceComponentSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    runtime_config: Optional[InferenceComponentRuntimeConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    deployment_config: Optional[InferenceComponentDeploymentConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    endpoint_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.endpoint_name is not None:
            # Serialize endpoint_name (handle intrinsic functions)
            if hasattr(self.endpoint_name, 'to_dict'):
                props["EndpointName"] = self.endpoint_name.to_dict()
            elif isinstance(self.endpoint_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndpointName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_name
                ]
            else:
                props["EndpointName"] = self.endpoint_name

        if self.variant_name is not None:
            # Serialize variant_name (handle intrinsic functions)
            if hasattr(self.variant_name, 'to_dict'):
                props["VariantName"] = self.variant_name.to_dict()
            elif isinstance(self.variant_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['VariantName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.variant_name
                ]
            else:
                props["VariantName"] = self.variant_name

        if self.inference_component_name is not None:
            # Serialize inference_component_name (handle intrinsic functions)
            if hasattr(self.inference_component_name, 'to_dict'):
                props["InferenceComponentName"] = self.inference_component_name.to_dict()
            elif isinstance(self.inference_component_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['InferenceComponentName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inference_component_name
                ]
            else:
                props["InferenceComponentName"] = self.inference_component_name

        if self.specification is not None:
            # Serialize specification (handle intrinsic functions)
            if hasattr(self.specification, 'to_dict'):
                props["Specification"] = self.specification.to_dict()
            elif isinstance(self.specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['Specification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.specification
                ]
            else:
                props["Specification"] = self.specification

        if self.runtime_config is not None:
            # Serialize runtime_config (handle intrinsic functions)
            if hasattr(self.runtime_config, 'to_dict'):
                props["RuntimeConfig"] = self.runtime_config.to_dict()
            elif isinstance(self.runtime_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['RuntimeConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.runtime_config
                ]
            else:
                props["RuntimeConfig"] = self.runtime_config

        if self.deployment_config is not None:
            # Serialize deployment_config (handle intrinsic functions)
            if hasattr(self.deployment_config, 'to_dict'):
                props["DeploymentConfig"] = self.deployment_config.to_dict()
            elif isinstance(self.deployment_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['DeploymentConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.deployment_config
                ]
            else:
                props["DeploymentConfig"] = self.deployment_config

        if self.endpoint_arn is not None:
            # Serialize endpoint_arn (handle intrinsic functions)
            if hasattr(self.endpoint_arn, 'to_dict'):
                props["EndpointArn"] = self.endpoint_arn.to_dict()
            elif isinstance(self.endpoint_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndpointArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_arn
                ]
            else:
                props["EndpointArn"] = self.endpoint_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_specification__container__deployed_image__resolution_time(self) -> GetAtt:
        """Get the Specification.Container.DeployedImage.ResolutionTime attribute."""
        return self.get_att("Specification.Container.DeployedImage.ResolutionTime")

    @property
    def attr_inference_component_status(self) -> GetAtt:
        """Get the InferenceComponentStatus attribute."""
        return self.get_att("InferenceComponentStatus")

    @property
    def attr_failure_reason(self) -> GetAtt:
        """Get the FailureReason attribute."""
        return self.get_att("FailureReason")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_last_modified_time(self) -> GetAtt:
        """Get the LastModifiedTime attribute."""
        return self.get_att("LastModifiedTime")

    @property
    def attr_inference_component_arn(self) -> GetAtt:
        """Get the InferenceComponentArn attribute."""
        return self.get_att("InferenceComponentArn")

    @property
    def attr_specification__container__deployed_image__resolved_image(self) -> GetAtt:
        """Get the Specification.Container.DeployedImage.ResolvedImage attribute."""
        return self.get_att("Specification.Container.DeployedImage.ResolvedImage")

    @property
    def attr_runtime_config__current_copy_count(self) -> GetAtt:
        """Get the RuntimeConfig.CurrentCopyCount attribute."""
        return self.get_att("RuntimeConfig.CurrentCopyCount")

    @property
    def attr_runtime_config__desired_copy_count(self) -> GetAtt:
        """Get the RuntimeConfig.DesiredCopyCount attribute."""
        return self.get_att("RuntimeConfig.DesiredCopyCount")

    @property
    def attr_specification__container__deployed_image(self) -> GetAtt:
        """Get the Specification.Container.DeployedImage attribute."""
        return self.get_att("Specification.Container.DeployedImage")

    @property
    def attr_specification__container__deployed_image__specified_image(self) -> GetAtt:
        """Get the Specification.Container.DeployedImage.SpecifiedImage attribute."""
        return self.get_att("Specification.Container.DeployedImage.SpecifiedImage")




@dataclass
class CaptureContentTypeHeader:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    json_content_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    csv_content_types: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.json_content_types is not None:
            if hasattr(self.json_content_types, 'to_dict'):
                props['JsonContentTypes'] = self.json_content_types.to_dict()
            elif isinstance(self.json_content_types, list):
                props['JsonContentTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.json_content_types
                ]
            else:
                props['JsonContentTypes'] = self.json_content_types

        if self.csv_content_types is not None:
            if hasattr(self.csv_content_types, 'to_dict'):
                props['CsvContentTypes'] = self.csv_content_types.to_dict()
            elif isinstance(self.csv_content_types, list):
                props['CsvContentTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.csv_content_types
                ]
            else:
                props['CsvContentTypes'] = self.csv_content_types

        return props


@dataclass
class DataStorageConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    destination: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    content_type: Optional[CaptureContentTypeHeader] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.destination is not None:
            if hasattr(self.destination, 'to_dict'):
                props['Destination'] = self.destination.to_dict()
            elif isinstance(self.destination, list):
                props['Destination'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.destination
                ]
            else:
                props['Destination'] = self.destination

        if self.content_type is not None:
            if hasattr(self.content_type, 'to_dict'):
                props['ContentType'] = self.content_type.to_dict()
            elif isinstance(self.content_type, list):
                props['ContentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.content_type
                ]
            else:
                props['ContentType'] = self.content_type

        if self.kms_key is not None:
            if hasattr(self.kms_key, 'to_dict'):
                props['KmsKey'] = self.kms_key.to_dict()
            elif isinstance(self.kms_key, list):
                props['KmsKey'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key
                ]
            else:
                props['KmsKey'] = self.kms_key

        return props


@dataclass
class EndpointMetadata:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_status: Optional[Union[str, EndpointStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_config_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.endpoint_status is not None:
            if hasattr(self.endpoint_status, 'to_dict'):
                props['EndpointStatus'] = self.endpoint_status.to_dict()
            elif isinstance(self.endpoint_status, list):
                props['EndpointStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_status
                ]
            else:
                props['EndpointStatus'] = self.endpoint_status

        if self.endpoint_name is not None:
            if hasattr(self.endpoint_name, 'to_dict'):
                props['EndpointName'] = self.endpoint_name.to_dict()
            elif isinstance(self.endpoint_name, list):
                props['EndpointName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_name
                ]
            else:
                props['EndpointName'] = self.endpoint_name

        if self.endpoint_config_name is not None:
            if hasattr(self.endpoint_config_name, 'to_dict'):
                props['EndpointConfigName'] = self.endpoint_config_name.to_dict()
            elif isinstance(self.endpoint_config_name, list):
                props['EndpointConfigName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_config_name
                ]
            else:
                props['EndpointConfigName'] = self.endpoint_config_name

        return props


@dataclass
class InferenceExperimentSchedule:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    end_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    start_time: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.end_time is not None:
            if hasattr(self.end_time, 'to_dict'):
                props['EndTime'] = self.end_time.to_dict()
            elif isinstance(self.end_time, list):
                props['EndTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.end_time
                ]
            else:
                props['EndTime'] = self.end_time

        if self.start_time is not None:
            if hasattr(self.start_time, 'to_dict'):
                props['StartTime'] = self.start_time.to_dict()
            elif isinstance(self.start_time, list):
                props['StartTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.start_time
                ]
            else:
                props['StartTime'] = self.start_time

        return props


@dataclass
class ModelInfrastructureConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    infrastructure_type: Optional[Union[str, ModelInfrastructureType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    real_time_inference_config: Optional[RealTimeInferenceConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.infrastructure_type is not None:
            if hasattr(self.infrastructure_type, 'to_dict'):
                props['InfrastructureType'] = self.infrastructure_type.to_dict()
            elif isinstance(self.infrastructure_type, list):
                props['InfrastructureType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.infrastructure_type
                ]
            else:
                props['InfrastructureType'] = self.infrastructure_type

        if self.real_time_inference_config is not None:
            if hasattr(self.real_time_inference_config, 'to_dict'):
                props['RealTimeInferenceConfig'] = self.real_time_inference_config.to_dict()
            elif isinstance(self.real_time_inference_config, list):
                props['RealTimeInferenceConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.real_time_inference_config
                ]
            else:
                props['RealTimeInferenceConfig'] = self.real_time_inference_config

        return props


@dataclass
class ModelVariantConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    variant_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    infrastructure_config: Optional[ModelInfrastructureConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_name is not None:
            if hasattr(self.model_name, 'to_dict'):
                props['ModelName'] = self.model_name.to_dict()
            elif isinstance(self.model_name, list):
                props['ModelName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_name
                ]
            else:
                props['ModelName'] = self.model_name

        if self.variant_name is not None:
            if hasattr(self.variant_name, 'to_dict'):
                props['VariantName'] = self.variant_name.to_dict()
            elif isinstance(self.variant_name, list):
                props['VariantName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.variant_name
                ]
            else:
                props['VariantName'] = self.variant_name

        if self.infrastructure_config is not None:
            if hasattr(self.infrastructure_config, 'to_dict'):
                props['InfrastructureConfig'] = self.infrastructure_config.to_dict()
            elif isinstance(self.infrastructure_config, list):
                props['InfrastructureConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.infrastructure_config
                ]
            else:
                props['InfrastructureConfig'] = self.infrastructure_config

        return props


@dataclass
class RealTimeInferenceConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, InstanceType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_count is not None:
            if hasattr(self.instance_count, 'to_dict'):
                props['InstanceCount'] = self.instance_count.to_dict()
            elif isinstance(self.instance_count, list):
                props['InstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_count
                ]
            else:
                props['InstanceCount'] = self.instance_count

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        return props


@dataclass
class ShadowModeConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_model_variant_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    shadow_model_variants: Optional[list[ShadowModelVariantConfig]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.source_model_variant_name is not None:
            if hasattr(self.source_model_variant_name, 'to_dict'):
                props['SourceModelVariantName'] = self.source_model_variant_name.to_dict()
            elif isinstance(self.source_model_variant_name, list):
                props['SourceModelVariantName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_model_variant_name
                ]
            else:
                props['SourceModelVariantName'] = self.source_model_variant_name

        if self.shadow_model_variants is not None:
            if hasattr(self.shadow_model_variants, 'to_dict'):
                props['ShadowModelVariants'] = self.shadow_model_variants.to_dict()
            elif isinstance(self.shadow_model_variants, list):
                props['ShadowModelVariants'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.shadow_model_variants
                ]
            else:
                props['ShadowModelVariants'] = self.shadow_model_variants

        return props


@dataclass
class ShadowModelVariantConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    shadow_model_variant_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sampling_percentage: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.shadow_model_variant_name is not None:
            if hasattr(self.shadow_model_variant_name, 'to_dict'):
                props['ShadowModelVariantName'] = self.shadow_model_variant_name.to_dict()
            elif isinstance(self.shadow_model_variant_name, list):
                props['ShadowModelVariantName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.shadow_model_variant_name
                ]
            else:
                props['ShadowModelVariantName'] = self.shadow_model_variant_name

        if self.sampling_percentage is not None:
            if hasattr(self.sampling_percentage, 'to_dict'):
                props['SamplingPercentage'] = self.sampling_percentage.to_dict()
            elif isinstance(self.sampling_percentage, list):
                props['SamplingPercentage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sampling_percentage
                ]
            else:
                props['SamplingPercentage'] = self.sampling_percentage

        return props


@dataclass
class InferenceExperiment(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::InferenceExperiment"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    data_storage_config: Optional[DataStorageConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    status_reason: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_variants: Optional[list[ModelVariantConfig]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    shadow_mode_config: Optional[ShadowModeConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    endpoint_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    desired_state: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    schedule: Optional[InferenceExperimentSchedule] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.data_storage_config is not None:
            # Serialize data_storage_config (handle intrinsic functions)
            if hasattr(self.data_storage_config, 'to_dict'):
                props["DataStorageConfig"] = self.data_storage_config.to_dict()
            elif isinstance(self.data_storage_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['DataStorageConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_storage_config
                ]
            else:
                props["DataStorageConfig"] = self.data_storage_config

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.status_reason is not None:
            # Serialize status_reason (handle intrinsic functions)
            if hasattr(self.status_reason, 'to_dict'):
                props["StatusReason"] = self.status_reason.to_dict()
            elif isinstance(self.status_reason, list):
                # Serialize list items (may contain intrinsic functions)
                props['StatusReason'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status_reason
                ]
            else:
                props["StatusReason"] = self.status_reason

        if self.model_variants is not None:
            # Serialize model_variants (handle intrinsic functions)
            if hasattr(self.model_variants, 'to_dict'):
                props["ModelVariants"] = self.model_variants.to_dict()
            elif isinstance(self.model_variants, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelVariants'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_variants
                ]
            else:
                props["ModelVariants"] = self.model_variants

        if self.shadow_mode_config is not None:
            # Serialize shadow_mode_config (handle intrinsic functions)
            if hasattr(self.shadow_mode_config, 'to_dict'):
                props["ShadowModeConfig"] = self.shadow_mode_config.to_dict()
            elif isinstance(self.shadow_mode_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ShadowModeConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.shadow_mode_config
                ]
            else:
                props["ShadowModeConfig"] = self.shadow_mode_config

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.endpoint_name is not None:
            # Serialize endpoint_name (handle intrinsic functions)
            if hasattr(self.endpoint_name, 'to_dict'):
                props["EndpointName"] = self.endpoint_name.to_dict()
            elif isinstance(self.endpoint_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndpointName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_name
                ]
            else:
                props["EndpointName"] = self.endpoint_name

        if self.desired_state is not None:
            # Serialize desired_state (handle intrinsic functions)
            if hasattr(self.desired_state, 'to_dict'):
                props["DesiredState"] = self.desired_state.to_dict()
            elif isinstance(self.desired_state, list):
                # Serialize list items (may contain intrinsic functions)
                props['DesiredState'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.desired_state
                ]
            else:
                props["DesiredState"] = self.desired_state

        if self.schedule is not None:
            # Serialize schedule (handle intrinsic functions)
            if hasattr(self.schedule, 'to_dict'):
                props["Schedule"] = self.schedule.to_dict()
            elif isinstance(self.schedule, list):
                # Serialize list items (may contain intrinsic functions)
                props['Schedule'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schedule
                ]
            else:
                props["Schedule"] = self.schedule

        if self.kms_key is not None:
            # Serialize kms_key (handle intrinsic functions)
            if hasattr(self.kms_key, 'to_dict'):
                props["KmsKey"] = self.kms_key.to_dict()
            elif isinstance(self.kms_key, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKey'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key
                ]
            else:
                props["KmsKey"] = self.kms_key

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_status(self) -> GetAtt:
        """Get the Status attribute."""
        return self.get_att("Status")

    @property
    def attr_endpoint_metadata__endpoint_config_name(self) -> GetAtt:
        """Get the EndpointMetadata.EndpointConfigName attribute."""
        return self.get_att("EndpointMetadata.EndpointConfigName")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_last_modified_time(self) -> GetAtt:
        """Get the LastModifiedTime attribute."""
        return self.get_att("LastModifiedTime")

    @property
    def attr_endpoint_metadata__endpoint_name(self) -> GetAtt:
        """Get the EndpointMetadata.EndpointName attribute."""
        return self.get_att("EndpointMetadata.EndpointName")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")

    @property
    def attr_endpoint_metadata__endpoint_status(self) -> GetAtt:
        """Get the EndpointMetadata.EndpointStatus attribute."""
        return self.get_att("EndpointMetadata.EndpointStatus")

    @property
    def attr_endpoint_metadata(self) -> GetAtt:
        """Get the EndpointMetadata attribute."""
        return self.get_att("EndpointMetadata")




@dataclass
class MlflowTrackingServer(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::MlflowTrackingServer"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tracking_server_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    mlflow_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    weekly_maintenance_window_start: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tracking_server_size: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    artifact_store_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    automatic_model_registration: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.tracking_server_name is not None:
            # Serialize tracking_server_name (handle intrinsic functions)
            if hasattr(self.tracking_server_name, 'to_dict'):
                props["TrackingServerName"] = self.tracking_server_name.to_dict()
            elif isinstance(self.tracking_server_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['TrackingServerName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tracking_server_name
                ]
            else:
                props["TrackingServerName"] = self.tracking_server_name

        if self.mlflow_version is not None:
            # Serialize mlflow_version (handle intrinsic functions)
            if hasattr(self.mlflow_version, 'to_dict'):
                props["MlflowVersion"] = self.mlflow_version.to_dict()
            elif isinstance(self.mlflow_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['MlflowVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mlflow_version
                ]
            else:
                props["MlflowVersion"] = self.mlflow_version

        if self.weekly_maintenance_window_start is not None:
            # Serialize weekly_maintenance_window_start (handle intrinsic functions)
            if hasattr(self.weekly_maintenance_window_start, 'to_dict'):
                props["WeeklyMaintenanceWindowStart"] = self.weekly_maintenance_window_start.to_dict()
            elif isinstance(self.weekly_maintenance_window_start, list):
                # Serialize list items (may contain intrinsic functions)
                props['WeeklyMaintenanceWindowStart'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.weekly_maintenance_window_start
                ]
            else:
                props["WeeklyMaintenanceWindowStart"] = self.weekly_maintenance_window_start

        if self.tracking_server_size is not None:
            # Serialize tracking_server_size (handle intrinsic functions)
            if hasattr(self.tracking_server_size, 'to_dict'):
                props["TrackingServerSize"] = self.tracking_server_size.to_dict()
            elif isinstance(self.tracking_server_size, list):
                # Serialize list items (may contain intrinsic functions)
                props['TrackingServerSize'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tracking_server_size
                ]
            else:
                props["TrackingServerSize"] = self.tracking_server_size

        if self.artifact_store_uri is not None:
            # Serialize artifact_store_uri (handle intrinsic functions)
            if hasattr(self.artifact_store_uri, 'to_dict'):
                props["ArtifactStoreUri"] = self.artifact_store_uri.to_dict()
            elif isinstance(self.artifact_store_uri, list):
                # Serialize list items (may contain intrinsic functions)
                props['ArtifactStoreUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.artifact_store_uri
                ]
            else:
                props["ArtifactStoreUri"] = self.artifact_store_uri

        if self.automatic_model_registration is not None:
            # Serialize automatic_model_registration (handle intrinsic functions)
            if hasattr(self.automatic_model_registration, 'to_dict'):
                props["AutomaticModelRegistration"] = self.automatic_model_registration.to_dict()
            elif isinstance(self.automatic_model_registration, list):
                # Serialize list items (may contain intrinsic functions)
                props['AutomaticModelRegistration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.automatic_model_registration
                ]
            else:
                props["AutomaticModelRegistration"] = self.automatic_model_registration

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_tracking_server_arn(self) -> GetAtt:
        """Get the TrackingServerArn attribute."""
        return self.get_att("TrackingServerArn")




@dataclass
class AdditionalModelDataSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    channel_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_source: Optional[S3DataSource] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.channel_name is not None:
            if hasattr(self.channel_name, 'to_dict'):
                props['ChannelName'] = self.channel_name.to_dict()
            elif isinstance(self.channel_name, list):
                props['ChannelName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.channel_name
                ]
            else:
                props['ChannelName'] = self.channel_name

        if self.s3_data_source is not None:
            if hasattr(self.s3_data_source, 'to_dict'):
                props['S3DataSource'] = self.s3_data_source.to_dict()
            elif isinstance(self.s3_data_source, list):
                props['S3DataSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_source
                ]
            else:
                props['S3DataSource'] = self.s3_data_source

        return props


@dataclass
class ContainerDefinition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_config: Optional[ImageConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inference_specification_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_hostname: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_package_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mode: Optional[Union[str, ContainerMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    environment: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_data_url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_data_source: Optional[ModelDataSource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    multi_model_config: Optional[MultiModelConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.image_config is not None:
            if hasattr(self.image_config, 'to_dict'):
                props['ImageConfig'] = self.image_config.to_dict()
            elif isinstance(self.image_config, list):
                props['ImageConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_config
                ]
            else:
                props['ImageConfig'] = self.image_config

        if self.inference_specification_name is not None:
            if hasattr(self.inference_specification_name, 'to_dict'):
                props['InferenceSpecificationName'] = self.inference_specification_name.to_dict()
            elif isinstance(self.inference_specification_name, list):
                props['InferenceSpecificationName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inference_specification_name
                ]
            else:
                props['InferenceSpecificationName'] = self.inference_specification_name

        if self.container_hostname is not None:
            if hasattr(self.container_hostname, 'to_dict'):
                props['ContainerHostname'] = self.container_hostname.to_dict()
            elif isinstance(self.container_hostname, list):
                props['ContainerHostname'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_hostname
                ]
            else:
                props['ContainerHostname'] = self.container_hostname

        if self.model_package_name is not None:
            if hasattr(self.model_package_name, 'to_dict'):
                props['ModelPackageName'] = self.model_package_name.to_dict()
            elif isinstance(self.model_package_name, list):
                props['ModelPackageName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_package_name
                ]
            else:
                props['ModelPackageName'] = self.model_package_name

        if self.mode is not None:
            if hasattr(self.mode, 'to_dict'):
                props['Mode'] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props['Mode'] = self.mode

        if self.environment is not None:
            if hasattr(self.environment, 'to_dict'):
                props['Environment'] = self.environment.to_dict()
            elif isinstance(self.environment, list):
                props['Environment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment
                ]
            else:
                props['Environment'] = self.environment

        if self.model_data_url is not None:
            if hasattr(self.model_data_url, 'to_dict'):
                props['ModelDataUrl'] = self.model_data_url.to_dict()
            elif isinstance(self.model_data_url, list):
                props['ModelDataUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_data_url
                ]
            else:
                props['ModelDataUrl'] = self.model_data_url

        if self.image is not None:
            if hasattr(self.image, 'to_dict'):
                props['Image'] = self.image.to_dict()
            elif isinstance(self.image, list):
                props['Image'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image
                ]
            else:
                props['Image'] = self.image

        if self.model_data_source is not None:
            if hasattr(self.model_data_source, 'to_dict'):
                props['ModelDataSource'] = self.model_data_source.to_dict()
            elif isinstance(self.model_data_source, list):
                props['ModelDataSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_data_source
                ]
            else:
                props['ModelDataSource'] = self.model_data_source

        if self.multi_model_config is not None:
            if hasattr(self.multi_model_config, 'to_dict'):
                props['MultiModelConfig'] = self.multi_model_config.to_dict()
            elif isinstance(self.multi_model_config, list):
                props['MultiModelConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.multi_model_config
                ]
            else:
                props['MultiModelConfig'] = self.multi_model_config

        return props


@dataclass
class HubAccessConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hub_content_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.hub_content_arn is not None:
            if hasattr(self.hub_content_arn, 'to_dict'):
                props['HubContentArn'] = self.hub_content_arn.to_dict()
            elif isinstance(self.hub_content_arn, list):
                props['HubContentArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hub_content_arn
                ]
            else:
                props['HubContentArn'] = self.hub_content_arn

        return props


@dataclass
class ImageConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    repository_auth_config: Optional[RepositoryAuthConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    repository_access_mode: Optional[Union[str, RepositoryAccessMode, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.repository_auth_config is not None:
            if hasattr(self.repository_auth_config, 'to_dict'):
                props['RepositoryAuthConfig'] = self.repository_auth_config.to_dict()
            elif isinstance(self.repository_auth_config, list):
                props['RepositoryAuthConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.repository_auth_config
                ]
            else:
                props['RepositoryAuthConfig'] = self.repository_auth_config

        if self.repository_access_mode is not None:
            if hasattr(self.repository_access_mode, 'to_dict'):
                props['RepositoryAccessMode'] = self.repository_access_mode.to_dict()
            elif isinstance(self.repository_access_mode, list):
                props['RepositoryAccessMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.repository_access_mode
                ]
            else:
                props['RepositoryAccessMode'] = self.repository_access_mode

        return props


@dataclass
class InferenceExecutionConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mode: Optional[Union[str, InferenceExecutionMode, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mode is not None:
            if hasattr(self.mode, 'to_dict'):
                props['Mode'] = self.mode.to_dict()
            elif isinstance(self.mode, list):
                props['Mode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mode
                ]
            else:
                props['Mode'] = self.mode

        return props


@dataclass
class ModelAccessConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accept_eula: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.accept_eula is not None:
            if hasattr(self.accept_eula, 'to_dict'):
                props['AcceptEula'] = self.accept_eula.to_dict()
            elif isinstance(self.accept_eula, list):
                props['AcceptEula'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accept_eula
                ]
            else:
                props['AcceptEula'] = self.accept_eula

        return props


@dataclass
class ModelDataSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_source: Optional[S3DataSource] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_data_source is not None:
            if hasattr(self.s3_data_source, 'to_dict'):
                props['S3DataSource'] = self.s3_data_source.to_dict()
            elif isinstance(self.s3_data_source, list):
                props['S3DataSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_source
                ]
            else:
                props['S3DataSource'] = self.s3_data_source

        return props


@dataclass
class MultiModelConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_cache_setting: Optional[Union[str, ModelCacheSetting, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_cache_setting is not None:
            if hasattr(self.model_cache_setting, 'to_dict'):
                props['ModelCacheSetting'] = self.model_cache_setting.to_dict()
            elif isinstance(self.model_cache_setting, list):
                props['ModelCacheSetting'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_cache_setting
                ]
            else:
                props['ModelCacheSetting'] = self.model_cache_setting

        return props


@dataclass
class RepositoryAuthConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    repository_credentials_provider_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.repository_credentials_provider_arn is not None:
            if hasattr(self.repository_credentials_provider_arn, 'to_dict'):
                props['RepositoryCredentialsProviderArn'] = self.repository_credentials_provider_arn.to_dict()
            elif isinstance(self.repository_credentials_provider_arn, list):
                props['RepositoryCredentialsProviderArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.repository_credentials_provider_arn
                ]
            else:
                props['RepositoryCredentialsProviderArn'] = self.repository_credentials_provider_arn

        return props


@dataclass
class S3DataSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_access_config: Optional[ModelAccessConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_type: Optional[Union[str, S3DataType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    compression_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hub_access_config: Optional[HubAccessConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_access_config is not None:
            if hasattr(self.model_access_config, 'to_dict'):
                props['ModelAccessConfig'] = self.model_access_config.to_dict()
            elif isinstance(self.model_access_config, list):
                props['ModelAccessConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_access_config
                ]
            else:
                props['ModelAccessConfig'] = self.model_access_config

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        if self.s3_data_type is not None:
            if hasattr(self.s3_data_type, 'to_dict'):
                props['S3DataType'] = self.s3_data_type.to_dict()
            elif isinstance(self.s3_data_type, list):
                props['S3DataType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_type
                ]
            else:
                props['S3DataType'] = self.s3_data_type

        if self.compression_type is not None:
            if hasattr(self.compression_type, 'to_dict'):
                props['CompressionType'] = self.compression_type.to_dict()
            elif isinstance(self.compression_type, list):
                props['CompressionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compression_type
                ]
            else:
                props['CompressionType'] = self.compression_type

        if self.hub_access_config is not None:
            if hasattr(self.hub_access_config, 'to_dict'):
                props['HubAccessConfig'] = self.hub_access_config.to_dict()
            elif isinstance(self.hub_access_config, list):
                props['HubAccessConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hub_access_config
                ]
            else:
                props['HubAccessConfig'] = self.hub_access_config

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnets: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnets is not None:
            if hasattr(self.subnets, 'to_dict'):
                props['Subnets'] = self.subnets.to_dict()
            elif isinstance(self.subnets, list):
                props['Subnets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnets
                ]
            else:
                props['Subnets'] = self.subnets

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class Model(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::Model"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    execution_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_network_isolation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    primary_container: Optional[ContainerDefinition] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    vpc_config: Optional[VpcConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    containers: Optional[list[ContainerDefinition]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    inference_execution_config: Optional[InferenceExecutionConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.execution_role_arn is not None:
            # Serialize execution_role_arn (handle intrinsic functions)
            if hasattr(self.execution_role_arn, 'to_dict'):
                props["ExecutionRoleArn"] = self.execution_role_arn.to_dict()
            elif isinstance(self.execution_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExecutionRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role_arn
                ]
            else:
                props["ExecutionRoleArn"] = self.execution_role_arn

        if self.enable_network_isolation is not None:
            # Serialize enable_network_isolation (handle intrinsic functions)
            if hasattr(self.enable_network_isolation, 'to_dict'):
                props["EnableNetworkIsolation"] = self.enable_network_isolation.to_dict()
            elif isinstance(self.enable_network_isolation, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableNetworkIsolation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_network_isolation
                ]
            else:
                props["EnableNetworkIsolation"] = self.enable_network_isolation

        if self.primary_container is not None:
            # Serialize primary_container (handle intrinsic functions)
            if hasattr(self.primary_container, 'to_dict'):
                props["PrimaryContainer"] = self.primary_container.to_dict()
            elif isinstance(self.primary_container, list):
                # Serialize list items (may contain intrinsic functions)
                props['PrimaryContainer'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.primary_container
                ]
            else:
                props["PrimaryContainer"] = self.primary_container

        if self.model_name is not None:
            # Serialize model_name (handle intrinsic functions)
            if hasattr(self.model_name, 'to_dict'):
                props["ModelName"] = self.model_name.to_dict()
            elif isinstance(self.model_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_name
                ]
            else:
                props["ModelName"] = self.model_name

        if self.vpc_config is not None:
            # Serialize vpc_config (handle intrinsic functions)
            if hasattr(self.vpc_config, 'to_dict'):
                props["VpcConfig"] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props["VpcConfig"] = self.vpc_config

        if self.containers is not None:
            # Serialize containers (handle intrinsic functions)
            if hasattr(self.containers, 'to_dict'):
                props["Containers"] = self.containers.to_dict()
            elif isinstance(self.containers, list):
                # Serialize list items (may contain intrinsic functions)
                props['Containers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.containers
                ]
            else:
                props["Containers"] = self.containers

        if self.inference_execution_config is not None:
            # Serialize inference_execution_config (handle intrinsic functions)
            if hasattr(self.inference_execution_config, 'to_dict'):
                props["InferenceExecutionConfig"] = self.inference_execution_config.to_dict()
            elif isinstance(self.inference_execution_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['InferenceExecutionConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inference_execution_config
                ]
            else:
                props["InferenceExecutionConfig"] = self.inference_execution_config

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_model_name(self) -> GetAtt:
        """Get the ModelName attribute."""
        return self.get_att("ModelName")




@dataclass
class BatchTransformInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dataset_format: Optional[DatasetFormat] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_distribution_type: Optional[Union[str, ProcessingS3DataDistributionType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    start_time_offset: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    end_time_offset: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    probability_threshold_attribute: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inference_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_captured_destination_s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_input_mode: Optional[Union[str, ProcessingS3InputMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    probability_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    features_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.dataset_format is not None:
            if hasattr(self.dataset_format, 'to_dict'):
                props['DatasetFormat'] = self.dataset_format.to_dict()
            elif isinstance(self.dataset_format, list):
                props['DatasetFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dataset_format
                ]
            else:
                props['DatasetFormat'] = self.dataset_format

        if self.s3_data_distribution_type is not None:
            if hasattr(self.s3_data_distribution_type, 'to_dict'):
                props['S3DataDistributionType'] = self.s3_data_distribution_type.to_dict()
            elif isinstance(self.s3_data_distribution_type, list):
                props['S3DataDistributionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_distribution_type
                ]
            else:
                props['S3DataDistributionType'] = self.s3_data_distribution_type

        if self.start_time_offset is not None:
            if hasattr(self.start_time_offset, 'to_dict'):
                props['StartTimeOffset'] = self.start_time_offset.to_dict()
            elif isinstance(self.start_time_offset, list):
                props['StartTimeOffset'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.start_time_offset
                ]
            else:
                props['StartTimeOffset'] = self.start_time_offset

        if self.end_time_offset is not None:
            if hasattr(self.end_time_offset, 'to_dict'):
                props['EndTimeOffset'] = self.end_time_offset.to_dict()
            elif isinstance(self.end_time_offset, list):
                props['EndTimeOffset'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.end_time_offset
                ]
            else:
                props['EndTimeOffset'] = self.end_time_offset

        if self.probability_threshold_attribute is not None:
            if hasattr(self.probability_threshold_attribute, 'to_dict'):
                props['ProbabilityThresholdAttribute'] = self.probability_threshold_attribute.to_dict()
            elif isinstance(self.probability_threshold_attribute, list):
                props['ProbabilityThresholdAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.probability_threshold_attribute
                ]
            else:
                props['ProbabilityThresholdAttribute'] = self.probability_threshold_attribute

        if self.inference_attribute is not None:
            if hasattr(self.inference_attribute, 'to_dict'):
                props['InferenceAttribute'] = self.inference_attribute.to_dict()
            elif isinstance(self.inference_attribute, list):
                props['InferenceAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inference_attribute
                ]
            else:
                props['InferenceAttribute'] = self.inference_attribute

        if self.data_captured_destination_s3_uri is not None:
            if hasattr(self.data_captured_destination_s3_uri, 'to_dict'):
                props['DataCapturedDestinationS3Uri'] = self.data_captured_destination_s3_uri.to_dict()
            elif isinstance(self.data_captured_destination_s3_uri, list):
                props['DataCapturedDestinationS3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_captured_destination_s3_uri
                ]
            else:
                props['DataCapturedDestinationS3Uri'] = self.data_captured_destination_s3_uri

        if self.s3_input_mode is not None:
            if hasattr(self.s3_input_mode, 'to_dict'):
                props['S3InputMode'] = self.s3_input_mode.to_dict()
            elif isinstance(self.s3_input_mode, list):
                props['S3InputMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_input_mode
                ]
            else:
                props['S3InputMode'] = self.s3_input_mode

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.probability_attribute is not None:
            if hasattr(self.probability_attribute, 'to_dict'):
                props['ProbabilityAttribute'] = self.probability_attribute.to_dict()
            elif isinstance(self.probability_attribute, list):
                props['ProbabilityAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.probability_attribute
                ]
            else:
                props['ProbabilityAttribute'] = self.probability_attribute

        if self.features_attribute is not None:
            if hasattr(self.features_attribute, 'to_dict'):
                props['FeaturesAttribute'] = self.features_attribute.to_dict()
            elif isinstance(self.features_attribute, list):
                props['FeaturesAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.features_attribute
                ]
            else:
                props['FeaturesAttribute'] = self.features_attribute

        return props


@dataclass
class ClusterConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size_in_gb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_count is not None:
            if hasattr(self.instance_count, 'to_dict'):
                props['InstanceCount'] = self.instance_count.to_dict()
            elif isinstance(self.instance_count, list):
                props['InstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_count
                ]
            else:
                props['InstanceCount'] = self.instance_count

        if self.volume_size_in_gb is not None:
            if hasattr(self.volume_size_in_gb, 'to_dict'):
                props['VolumeSizeInGB'] = self.volume_size_in_gb.to_dict()
            elif isinstance(self.volume_size_in_gb, list):
                props['VolumeSizeInGB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size_in_gb
                ]
            else:
                props['VolumeSizeInGB'] = self.volume_size_in_gb

        if self.volume_kms_key_id is not None:
            if hasattr(self.volume_kms_key_id, 'to_dict'):
                props['VolumeKmsKeyId'] = self.volume_kms_key_id.to_dict()
            elif isinstance(self.volume_kms_key_id, list):
                props['VolumeKmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_kms_key_id
                ]
            else:
                props['VolumeKmsKeyId'] = self.volume_kms_key_id

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        return props


@dataclass
class ConstraintsResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        return props


@dataclass
class Csv:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    header: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.header is not None:
            if hasattr(self.header, 'to_dict'):
                props['Header'] = self.header.to_dict()
            elif isinstance(self.header, list):
                props['Header'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.header
                ]
            else:
                props['Header'] = self.header

        return props


@dataclass
class DatasetFormat:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parquet: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    csv: Optional[Csv] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    json: Optional[Json] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.parquet is not None:
            if hasattr(self.parquet, 'to_dict'):
                props['Parquet'] = self.parquet.to_dict()
            elif isinstance(self.parquet, list):
                props['Parquet'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parquet
                ]
            else:
                props['Parquet'] = self.parquet

        if self.csv is not None:
            if hasattr(self.csv, 'to_dict'):
                props['Csv'] = self.csv.to_dict()
            elif isinstance(self.csv, list):
                props['Csv'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.csv
                ]
            else:
                props['Csv'] = self.csv

        if self.json is not None:
            if hasattr(self.json, 'to_dict'):
                props['Json'] = self.json.to_dict()
            elif isinstance(self.json, list):
                props['Json'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.json
                ]
            else:
                props['Json'] = self.json

        return props


@dataclass
class EndpointInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_distribution_type: Optional[Union[str, ProcessingS3DataDistributionType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    start_time_offset: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    end_time_offset: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    probability_threshold_attribute: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inference_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_input_mode: Optional[Union[str, ProcessingS3InputMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    probability_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    features_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_data_distribution_type is not None:
            if hasattr(self.s3_data_distribution_type, 'to_dict'):
                props['S3DataDistributionType'] = self.s3_data_distribution_type.to_dict()
            elif isinstance(self.s3_data_distribution_type, list):
                props['S3DataDistributionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_distribution_type
                ]
            else:
                props['S3DataDistributionType'] = self.s3_data_distribution_type

        if self.start_time_offset is not None:
            if hasattr(self.start_time_offset, 'to_dict'):
                props['StartTimeOffset'] = self.start_time_offset.to_dict()
            elif isinstance(self.start_time_offset, list):
                props['StartTimeOffset'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.start_time_offset
                ]
            else:
                props['StartTimeOffset'] = self.start_time_offset

        if self.end_time_offset is not None:
            if hasattr(self.end_time_offset, 'to_dict'):
                props['EndTimeOffset'] = self.end_time_offset.to_dict()
            elif isinstance(self.end_time_offset, list):
                props['EndTimeOffset'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.end_time_offset
                ]
            else:
                props['EndTimeOffset'] = self.end_time_offset

        if self.probability_threshold_attribute is not None:
            if hasattr(self.probability_threshold_attribute, 'to_dict'):
                props['ProbabilityThresholdAttribute'] = self.probability_threshold_attribute.to_dict()
            elif isinstance(self.probability_threshold_attribute, list):
                props['ProbabilityThresholdAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.probability_threshold_attribute
                ]
            else:
                props['ProbabilityThresholdAttribute'] = self.probability_threshold_attribute

        if self.endpoint_name is not None:
            if hasattr(self.endpoint_name, 'to_dict'):
                props['EndpointName'] = self.endpoint_name.to_dict()
            elif isinstance(self.endpoint_name, list):
                props['EndpointName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_name
                ]
            else:
                props['EndpointName'] = self.endpoint_name

        if self.inference_attribute is not None:
            if hasattr(self.inference_attribute, 'to_dict'):
                props['InferenceAttribute'] = self.inference_attribute.to_dict()
            elif isinstance(self.inference_attribute, list):
                props['InferenceAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inference_attribute
                ]
            else:
                props['InferenceAttribute'] = self.inference_attribute

        if self.s3_input_mode is not None:
            if hasattr(self.s3_input_mode, 'to_dict'):
                props['S3InputMode'] = self.s3_input_mode.to_dict()
            elif isinstance(self.s3_input_mode, list):
                props['S3InputMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_input_mode
                ]
            else:
                props['S3InputMode'] = self.s3_input_mode

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.probability_attribute is not None:
            if hasattr(self.probability_attribute, 'to_dict'):
                props['ProbabilityAttribute'] = self.probability_attribute.to_dict()
            elif isinstance(self.probability_attribute, list):
                props['ProbabilityAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.probability_attribute
                ]
            else:
                props['ProbabilityAttribute'] = self.probability_attribute

        if self.features_attribute is not None:
            if hasattr(self.features_attribute, 'to_dict'):
                props['FeaturesAttribute'] = self.features_attribute.to_dict()
            elif isinstance(self.features_attribute, list):
                props['FeaturesAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.features_attribute
                ]
            else:
                props['FeaturesAttribute'] = self.features_attribute

        return props


@dataclass
class Json:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    line: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.line is not None:
            if hasattr(self.line, 'to_dict'):
                props['Line'] = self.line.to_dict()
            elif isinstance(self.line, list):
                props['Line'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.line
                ]
            else:
                props['Line'] = self.line

        return props


@dataclass
class ModelBiasAppSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    config_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    environment: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.config_uri is not None:
            if hasattr(self.config_uri, 'to_dict'):
                props['ConfigUri'] = self.config_uri.to_dict()
            elif isinstance(self.config_uri, list):
                props['ConfigUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.config_uri
                ]
            else:
                props['ConfigUri'] = self.config_uri

        if self.environment is not None:
            if hasattr(self.environment, 'to_dict'):
                props['Environment'] = self.environment.to_dict()
            elif isinstance(self.environment, list):
                props['Environment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment
                ]
            else:
                props['Environment'] = self.environment

        if self.image_uri is not None:
            if hasattr(self.image_uri, 'to_dict'):
                props['ImageUri'] = self.image_uri.to_dict()
            elif isinstance(self.image_uri, list):
                props['ImageUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_uri
                ]
            else:
                props['ImageUri'] = self.image_uri

        return props


@dataclass
class ModelBiasBaselineConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    constraints_resource: Optional[ConstraintsResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baselining_job_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.constraints_resource is not None:
            if hasattr(self.constraints_resource, 'to_dict'):
                props['ConstraintsResource'] = self.constraints_resource.to_dict()
            elif isinstance(self.constraints_resource, list):
                props['ConstraintsResource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.constraints_resource
                ]
            else:
                props['ConstraintsResource'] = self.constraints_resource

        if self.baselining_job_name is not None:
            if hasattr(self.baselining_job_name, 'to_dict'):
                props['BaseliningJobName'] = self.baselining_job_name.to_dict()
            elif isinstance(self.baselining_job_name, list):
                props['BaseliningJobName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baselining_job_name
                ]
            else:
                props['BaseliningJobName'] = self.baselining_job_name

        return props


@dataclass
class ModelBiasJobInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ground_truth_s3_input: Optional[MonitoringGroundTruthS3Input] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    batch_transform_input: Optional[BatchTransformInput] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_input: Optional[EndpointInput] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ground_truth_s3_input is not None:
            if hasattr(self.ground_truth_s3_input, 'to_dict'):
                props['GroundTruthS3Input'] = self.ground_truth_s3_input.to_dict()
            elif isinstance(self.ground_truth_s3_input, list):
                props['GroundTruthS3Input'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ground_truth_s3_input
                ]
            else:
                props['GroundTruthS3Input'] = self.ground_truth_s3_input

        if self.batch_transform_input is not None:
            if hasattr(self.batch_transform_input, 'to_dict'):
                props['BatchTransformInput'] = self.batch_transform_input.to_dict()
            elif isinstance(self.batch_transform_input, list):
                props['BatchTransformInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.batch_transform_input
                ]
            else:
                props['BatchTransformInput'] = self.batch_transform_input

        if self.endpoint_input is not None:
            if hasattr(self.endpoint_input, 'to_dict'):
                props['EndpointInput'] = self.endpoint_input.to_dict()
            elif isinstance(self.endpoint_input, list):
                props['EndpointInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_input
                ]
            else:
                props['EndpointInput'] = self.endpoint_input

        return props


@dataclass
class MonitoringGroundTruthS3Input:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        return props


@dataclass
class MonitoringOutput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_output: Optional[S3Output] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_output is not None:
            if hasattr(self.s3_output, 'to_dict'):
                props['S3Output'] = self.s3_output.to_dict()
            elif isinstance(self.s3_output, list):
                props['S3Output'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_output
                ]
            else:
                props['S3Output'] = self.s3_output

        return props


@dataclass
class MonitoringOutputConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring_outputs: Optional[list[MonitoringOutput]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.monitoring_outputs is not None:
            if hasattr(self.monitoring_outputs, 'to_dict'):
                props['MonitoringOutputs'] = self.monitoring_outputs.to_dict()
            elif isinstance(self.monitoring_outputs, list):
                props['MonitoringOutputs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_outputs
                ]
            else:
                props['MonitoringOutputs'] = self.monitoring_outputs

        return props


@dataclass
class MonitoringResources:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cluster_config: Optional[ClusterConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cluster_config is not None:
            if hasattr(self.cluster_config, 'to_dict'):
                props['ClusterConfig'] = self.cluster_config.to_dict()
            elif isinstance(self.cluster_config, list):
                props['ClusterConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cluster_config
                ]
            else:
                props['ClusterConfig'] = self.cluster_config

        return props


@dataclass
class NetworkConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_network_isolation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_inter_container_traffic_encryption: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_config: Optional[VpcConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enable_network_isolation is not None:
            if hasattr(self.enable_network_isolation, 'to_dict'):
                props['EnableNetworkIsolation'] = self.enable_network_isolation.to_dict()
            elif isinstance(self.enable_network_isolation, list):
                props['EnableNetworkIsolation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_network_isolation
                ]
            else:
                props['EnableNetworkIsolation'] = self.enable_network_isolation

        if self.enable_inter_container_traffic_encryption is not None:
            if hasattr(self.enable_inter_container_traffic_encryption, 'to_dict'):
                props['EnableInterContainerTrafficEncryption'] = self.enable_inter_container_traffic_encryption.to_dict()
            elif isinstance(self.enable_inter_container_traffic_encryption, list):
                props['EnableInterContainerTrafficEncryption'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_inter_container_traffic_encryption
                ]
            else:
                props['EnableInterContainerTrafficEncryption'] = self.enable_inter_container_traffic_encryption

        if self.vpc_config is not None:
            if hasattr(self.vpc_config, 'to_dict'):
                props['VpcConfig'] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props['VpcConfig'] = self.vpc_config

        return props


@dataclass
class S3Output:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_upload_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.s3_upload_mode is not None:
            if hasattr(self.s3_upload_mode, 'to_dict'):
                props['S3UploadMode'] = self.s3_upload_mode.to_dict()
            elif isinstance(self.s3_upload_mode, list):
                props['S3UploadMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_upload_mode
                ]
            else:
                props['S3UploadMode'] = self.s3_upload_mode

        return props


@dataclass
class StoppingCondition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_runtime_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_runtime_in_seconds is not None:
            if hasattr(self.max_runtime_in_seconds, 'to_dict'):
                props['MaxRuntimeInSeconds'] = self.max_runtime_in_seconds.to_dict()
            elif isinstance(self.max_runtime_in_seconds, list):
                props['MaxRuntimeInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_runtime_in_seconds
                ]
            else:
                props['MaxRuntimeInSeconds'] = self.max_runtime_in_seconds

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnets: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnets is not None:
            if hasattr(self.subnets, 'to_dict'):
                props['Subnets'] = self.subnets.to_dict()
            elif isinstance(self.subnets, list):
                props['Subnets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnets
                ]
            else:
                props['Subnets'] = self.subnets

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class ModelBiasJobDefinition(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::ModelBiasJobDefinition"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_bias_job_input: Optional[ModelBiasJobInput] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_bias_job_output_config: Optional[MonitoringOutputConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    endpoint_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    stopping_condition: Optional[StoppingCondition] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    job_definition_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    job_resources: Optional[MonitoringResources] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_config: Optional[NetworkConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_bias_baseline_config: Optional[ModelBiasBaselineConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_bias_app_specification: Optional[ModelBiasAppSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_bias_job_input is not None:
            # Serialize model_bias_job_input (handle intrinsic functions)
            if hasattr(self.model_bias_job_input, 'to_dict'):
                props["ModelBiasJobInput"] = self.model_bias_job_input.to_dict()
            elif isinstance(self.model_bias_job_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelBiasJobInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_bias_job_input
                ]
            else:
                props["ModelBiasJobInput"] = self.model_bias_job_input

        if self.model_bias_job_output_config is not None:
            # Serialize model_bias_job_output_config (handle intrinsic functions)
            if hasattr(self.model_bias_job_output_config, 'to_dict'):
                props["ModelBiasJobOutputConfig"] = self.model_bias_job_output_config.to_dict()
            elif isinstance(self.model_bias_job_output_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelBiasJobOutputConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_bias_job_output_config
                ]
            else:
                props["ModelBiasJobOutputConfig"] = self.model_bias_job_output_config

        if self.endpoint_name is not None:
            # Serialize endpoint_name (handle intrinsic functions)
            if hasattr(self.endpoint_name, 'to_dict'):
                props["EndpointName"] = self.endpoint_name.to_dict()
            elif isinstance(self.endpoint_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndpointName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_name
                ]
            else:
                props["EndpointName"] = self.endpoint_name

        if self.stopping_condition is not None:
            # Serialize stopping_condition (handle intrinsic functions)
            if hasattr(self.stopping_condition, 'to_dict'):
                props["StoppingCondition"] = self.stopping_condition.to_dict()
            elif isinstance(self.stopping_condition, list):
                # Serialize list items (may contain intrinsic functions)
                props['StoppingCondition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stopping_condition
                ]
            else:
                props["StoppingCondition"] = self.stopping_condition

        if self.job_definition_name is not None:
            # Serialize job_definition_name (handle intrinsic functions)
            if hasattr(self.job_definition_name, 'to_dict'):
                props["JobDefinitionName"] = self.job_definition_name.to_dict()
            elif isinstance(self.job_definition_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['JobDefinitionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.job_definition_name
                ]
            else:
                props["JobDefinitionName"] = self.job_definition_name

        if self.job_resources is not None:
            # Serialize job_resources (handle intrinsic functions)
            if hasattr(self.job_resources, 'to_dict'):
                props["JobResources"] = self.job_resources.to_dict()
            elif isinstance(self.job_resources, list):
                # Serialize list items (may contain intrinsic functions)
                props['JobResources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.job_resources
                ]
            else:
                props["JobResources"] = self.job_resources

        if self.network_config is not None:
            # Serialize network_config (handle intrinsic functions)
            if hasattr(self.network_config, 'to_dict'):
                props["NetworkConfig"] = self.network_config.to_dict()
            elif isinstance(self.network_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_config
                ]
            else:
                props["NetworkConfig"] = self.network_config

        if self.model_bias_baseline_config is not None:
            # Serialize model_bias_baseline_config (handle intrinsic functions)
            if hasattr(self.model_bias_baseline_config, 'to_dict'):
                props["ModelBiasBaselineConfig"] = self.model_bias_baseline_config.to_dict()
            elif isinstance(self.model_bias_baseline_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelBiasBaselineConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_bias_baseline_config
                ]
            else:
                props["ModelBiasBaselineConfig"] = self.model_bias_baseline_config

        if self.model_bias_app_specification is not None:
            # Serialize model_bias_app_specification (handle intrinsic functions)
            if hasattr(self.model_bias_app_specification, 'to_dict'):
                props["ModelBiasAppSpecification"] = self.model_bias_app_specification.to_dict()
            elif isinstance(self.model_bias_app_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelBiasAppSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_bias_app_specification
                ]
            else:
                props["ModelBiasAppSpecification"] = self.model_bias_app_specification

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_job_definition_arn(self) -> GetAtt:
        """Get the JobDefinitionArn attribute."""
        return self.get_att("JobDefinitionArn")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")




@dataclass
class AdditionalInformation:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ethical_considerations: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    caveats_and_recommendations: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_details: Optional[dict[str, str]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ethical_considerations is not None:
            if hasattr(self.ethical_considerations, 'to_dict'):
                props['EthicalConsiderations'] = self.ethical_considerations.to_dict()
            elif isinstance(self.ethical_considerations, list):
                props['EthicalConsiderations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ethical_considerations
                ]
            else:
                props['EthicalConsiderations'] = self.ethical_considerations

        if self.caveats_and_recommendations is not None:
            if hasattr(self.caveats_and_recommendations, 'to_dict'):
                props['CaveatsAndRecommendations'] = self.caveats_and_recommendations.to_dict()
            elif isinstance(self.caveats_and_recommendations, list):
                props['CaveatsAndRecommendations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.caveats_and_recommendations
                ]
            else:
                props['CaveatsAndRecommendations'] = self.caveats_and_recommendations

        if self.custom_details is not None:
            if hasattr(self.custom_details, 'to_dict'):
                props['CustomDetails'] = self.custom_details.to_dict()
            elif isinstance(self.custom_details, list):
                props['CustomDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_details
                ]
            else:
                props['CustomDetails'] = self.custom_details

        return props


@dataclass
class BusinessDetails:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    business_stakeholders: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    line_of_business: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    business_problem: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.business_stakeholders is not None:
            if hasattr(self.business_stakeholders, 'to_dict'):
                props['BusinessStakeholders'] = self.business_stakeholders.to_dict()
            elif isinstance(self.business_stakeholders, list):
                props['BusinessStakeholders'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.business_stakeholders
                ]
            else:
                props['BusinessStakeholders'] = self.business_stakeholders

        if self.line_of_business is not None:
            if hasattr(self.line_of_business, 'to_dict'):
                props['LineOfBusiness'] = self.line_of_business.to_dict()
            elif isinstance(self.line_of_business, list):
                props['LineOfBusiness'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.line_of_business
                ]
            else:
                props['LineOfBusiness'] = self.line_of_business

        if self.business_problem is not None:
            if hasattr(self.business_problem, 'to_dict'):
                props['BusinessProblem'] = self.business_problem.to_dict()
            elif isinstance(self.business_problem, list):
                props['BusinessProblem'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.business_problem
                ]
            else:
                props['BusinessProblem'] = self.business_problem

        return props


@dataclass
class Container:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    nearest_model_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_data_url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.nearest_model_name is not None:
            if hasattr(self.nearest_model_name, 'to_dict'):
                props['NearestModelName'] = self.nearest_model_name.to_dict()
            elif isinstance(self.nearest_model_name, list):
                props['NearestModelName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.nearest_model_name
                ]
            else:
                props['NearestModelName'] = self.nearest_model_name

        if self.model_data_url is not None:
            if hasattr(self.model_data_url, 'to_dict'):
                props['ModelDataUrl'] = self.model_data_url.to_dict()
            elif isinstance(self.model_data_url, list):
                props['ModelDataUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_data_url
                ]
            else:
                props['ModelDataUrl'] = self.model_data_url

        if self.image is not None:
            if hasattr(self.image, 'to_dict'):
                props['Image'] = self.image.to_dict()
            elif isinstance(self.image, list):
                props['Image'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image
                ]
            else:
                props['Image'] = self.image

        return props


@dataclass
class Content:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    intended_uses: Optional[IntendedUses] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    additional_information: Optional[AdditionalInformation] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_overview: Optional[ModelOverview] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    training_details: Optional[TrainingDetails] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    evaluation_details: Optional[list[EvaluationDetail]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_package_details: Optional[ModelPackageDetails] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    business_details: Optional[BusinessDetails] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.intended_uses is not None:
            if hasattr(self.intended_uses, 'to_dict'):
                props['IntendedUses'] = self.intended_uses.to_dict()
            elif isinstance(self.intended_uses, list):
                props['IntendedUses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.intended_uses
                ]
            else:
                props['IntendedUses'] = self.intended_uses

        if self.additional_information is not None:
            if hasattr(self.additional_information, 'to_dict'):
                props['AdditionalInformation'] = self.additional_information.to_dict()
            elif isinstance(self.additional_information, list):
                props['AdditionalInformation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_information
                ]
            else:
                props['AdditionalInformation'] = self.additional_information

        if self.model_overview is not None:
            if hasattr(self.model_overview, 'to_dict'):
                props['ModelOverview'] = self.model_overview.to_dict()
            elif isinstance(self.model_overview, list):
                props['ModelOverview'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_overview
                ]
            else:
                props['ModelOverview'] = self.model_overview

        if self.training_details is not None:
            if hasattr(self.training_details, 'to_dict'):
                props['TrainingDetails'] = self.training_details.to_dict()
            elif isinstance(self.training_details, list):
                props['TrainingDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.training_details
                ]
            else:
                props['TrainingDetails'] = self.training_details

        if self.evaluation_details is not None:
            if hasattr(self.evaluation_details, 'to_dict'):
                props['EvaluationDetails'] = self.evaluation_details.to_dict()
            elif isinstance(self.evaluation_details, list):
                props['EvaluationDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.evaluation_details
                ]
            else:
                props['EvaluationDetails'] = self.evaluation_details

        if self.model_package_details is not None:
            if hasattr(self.model_package_details, 'to_dict'):
                props['ModelPackageDetails'] = self.model_package_details.to_dict()
            elif isinstance(self.model_package_details, list):
                props['ModelPackageDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_package_details
                ]
            else:
                props['ModelPackageDetails'] = self.model_package_details

        if self.business_details is not None:
            if hasattr(self.business_details, 'to_dict'):
                props['BusinessDetails'] = self.business_details.to_dict()
            elif isinstance(self.business_details, list):
                props['BusinessDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.business_details
                ]
            else:
                props['BusinessDetails'] = self.business_details

        return props


@dataclass
class EvaluationDetail:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    datasets: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    evaluation_observation: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_groups: Optional[list[MetricGroup]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metadata: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    evaluation_job_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.datasets is not None:
            if hasattr(self.datasets, 'to_dict'):
                props['Datasets'] = self.datasets.to_dict()
            elif isinstance(self.datasets, list):
                props['Datasets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.datasets
                ]
            else:
                props['Datasets'] = self.datasets

        if self.evaluation_observation is not None:
            if hasattr(self.evaluation_observation, 'to_dict'):
                props['EvaluationObservation'] = self.evaluation_observation.to_dict()
            elif isinstance(self.evaluation_observation, list):
                props['EvaluationObservation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.evaluation_observation
                ]
            else:
                props['EvaluationObservation'] = self.evaluation_observation

        if self.metric_groups is not None:
            if hasattr(self.metric_groups, 'to_dict'):
                props['MetricGroups'] = self.metric_groups.to_dict()
            elif isinstance(self.metric_groups, list):
                props['MetricGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_groups
                ]
            else:
                props['MetricGroups'] = self.metric_groups

        if self.metadata is not None:
            if hasattr(self.metadata, 'to_dict'):
                props['Metadata'] = self.metadata.to_dict()
            elif isinstance(self.metadata, list):
                props['Metadata'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metadata
                ]
            else:
                props['Metadata'] = self.metadata

        if self.evaluation_job_arn is not None:
            if hasattr(self.evaluation_job_arn, 'to_dict'):
                props['EvaluationJobArn'] = self.evaluation_job_arn.to_dict()
            elif isinstance(self.evaluation_job_arn, list):
                props['EvaluationJobArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.evaluation_job_arn
                ]
            else:
                props['EvaluationJobArn'] = self.evaluation_job_arn

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class Function:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    condition: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    function: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    facet: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.condition is not None:
            if hasattr(self.condition, 'to_dict'):
                props['Condition'] = self.condition.to_dict()
            elif isinstance(self.condition, list):
                props['Condition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.condition
                ]
            else:
                props['Condition'] = self.condition

        if self.function is not None:
            if hasattr(self.function, 'to_dict'):
                props['Function'] = self.function.to_dict()
            elif isinstance(self.function, list):
                props['Function'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.function
                ]
            else:
                props['Function'] = self.function

        if self.facet is not None:
            if hasattr(self.facet, 'to_dict'):
                props['Facet'] = self.facet.to_dict()
            elif isinstance(self.facet, list):
                props['Facet'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.facet
                ]
            else:
                props['Facet'] = self.facet

        return props


@dataclass
class InferenceEnvironment:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_image: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.container_image is not None:
            if hasattr(self.container_image, 'to_dict'):
                props['ContainerImage'] = self.container_image.to_dict()
            elif isinstance(self.container_image, list):
                props['ContainerImage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_image
                ]
            else:
                props['ContainerImage'] = self.container_image

        return props


@dataclass
class InferenceSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    containers: Optional[list[Container]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.containers is not None:
            if hasattr(self.containers, 'to_dict'):
                props['Containers'] = self.containers.to_dict()
            elif isinstance(self.containers, list):
                props['Containers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.containers
                ]
            else:
                props['Containers'] = self.containers

        return props


@dataclass
class IntendedUses:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    intended_uses: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    factors_affecting_model_efficiency: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    purpose_of_model: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    risk_rating: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    explanations_for_risk_rating: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.intended_uses is not None:
            if hasattr(self.intended_uses, 'to_dict'):
                props['IntendedUses'] = self.intended_uses.to_dict()
            elif isinstance(self.intended_uses, list):
                props['IntendedUses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.intended_uses
                ]
            else:
                props['IntendedUses'] = self.intended_uses

        if self.factors_affecting_model_efficiency is not None:
            if hasattr(self.factors_affecting_model_efficiency, 'to_dict'):
                props['FactorsAffectingModelEfficiency'] = self.factors_affecting_model_efficiency.to_dict()
            elif isinstance(self.factors_affecting_model_efficiency, list):
                props['FactorsAffectingModelEfficiency'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.factors_affecting_model_efficiency
                ]
            else:
                props['FactorsAffectingModelEfficiency'] = self.factors_affecting_model_efficiency

        if self.purpose_of_model is not None:
            if hasattr(self.purpose_of_model, 'to_dict'):
                props['PurposeOfModel'] = self.purpose_of_model.to_dict()
            elif isinstance(self.purpose_of_model, list):
                props['PurposeOfModel'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.purpose_of_model
                ]
            else:
                props['PurposeOfModel'] = self.purpose_of_model

        if self.risk_rating is not None:
            if hasattr(self.risk_rating, 'to_dict'):
                props['RiskRating'] = self.risk_rating.to_dict()
            elif isinstance(self.risk_rating, list):
                props['RiskRating'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.risk_rating
                ]
            else:
                props['RiskRating'] = self.risk_rating

        if self.explanations_for_risk_rating is not None:
            if hasattr(self.explanations_for_risk_rating, 'to_dict'):
                props['ExplanationsForRiskRating'] = self.explanations_for_risk_rating.to_dict()
            elif isinstance(self.explanations_for_risk_rating, list):
                props['ExplanationsForRiskRating'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.explanations_for_risk_rating
                ]
            else:
                props['ExplanationsForRiskRating'] = self.explanations_for_risk_rating

        return props


@dataclass
class MetricDataItems:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    x_axis_name: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    y_axis_name: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notes: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.x_axis_name is not None:
            if hasattr(self.x_axis_name, 'to_dict'):
                props['XAxisName'] = self.x_axis_name.to_dict()
            elif isinstance(self.x_axis_name, list):
                props['XAxisName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.x_axis_name
                ]
            else:
                props['XAxisName'] = self.x_axis_name

        if self.type_ is not None:
            if hasattr(self.type_, 'to_dict'):
                props['Type'] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props['Type'] = self.type_

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.y_axis_name is not None:
            if hasattr(self.y_axis_name, 'to_dict'):
                props['YAxisName'] = self.y_axis_name.to_dict()
            elif isinstance(self.y_axis_name, list):
                props['YAxisName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.y_axis_name
                ]
            else:
                props['YAxisName'] = self.y_axis_name

        if self.notes is not None:
            if hasattr(self.notes, 'to_dict'):
                props['Notes'] = self.notes.to_dict()
            elif isinstance(self.notes, list):
                props['Notes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notes
                ]
            else:
                props['Notes'] = self.notes

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class MetricGroup:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    metric_data: Optional[list[MetricDataItems]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        if self.metric_data is not None:
            if hasattr(self.metric_data, 'to_dict'):
                props['MetricData'] = self.metric_data.to_dict()
            elif isinstance(self.metric_data, list):
                props['MetricData'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metric_data
                ]
            else:
                props['MetricData'] = self.metric_data

        return props


@dataclass
class ModelOverview:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_owner: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_artifact: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    algorithm_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inference_environment: Optional[InferenceEnvironment] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    problem_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_version: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_creator: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_owner is not None:
            if hasattr(self.model_owner, 'to_dict'):
                props['ModelOwner'] = self.model_owner.to_dict()
            elif isinstance(self.model_owner, list):
                props['ModelOwner'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_owner
                ]
            else:
                props['ModelOwner'] = self.model_owner

        if self.model_artifact is not None:
            if hasattr(self.model_artifact, 'to_dict'):
                props['ModelArtifact'] = self.model_artifact.to_dict()
            elif isinstance(self.model_artifact, list):
                props['ModelArtifact'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_artifact
                ]
            else:
                props['ModelArtifact'] = self.model_artifact

        if self.algorithm_type is not None:
            if hasattr(self.algorithm_type, 'to_dict'):
                props['AlgorithmType'] = self.algorithm_type.to_dict()
            elif isinstance(self.algorithm_type, list):
                props['AlgorithmType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.algorithm_type
                ]
            else:
                props['AlgorithmType'] = self.algorithm_type

        if self.model_name is not None:
            if hasattr(self.model_name, 'to_dict'):
                props['ModelName'] = self.model_name.to_dict()
            elif isinstance(self.model_name, list):
                props['ModelName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_name
                ]
            else:
                props['ModelName'] = self.model_name

        if self.inference_environment is not None:
            if hasattr(self.inference_environment, 'to_dict'):
                props['InferenceEnvironment'] = self.inference_environment.to_dict()
            elif isinstance(self.inference_environment, list):
                props['InferenceEnvironment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inference_environment
                ]
            else:
                props['InferenceEnvironment'] = self.inference_environment

        if self.problem_type is not None:
            if hasattr(self.problem_type, 'to_dict'):
                props['ProblemType'] = self.problem_type.to_dict()
            elif isinstance(self.problem_type, list):
                props['ProblemType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.problem_type
                ]
            else:
                props['ProblemType'] = self.problem_type

        if self.model_description is not None:
            if hasattr(self.model_description, 'to_dict'):
                props['ModelDescription'] = self.model_description.to_dict()
            elif isinstance(self.model_description, list):
                props['ModelDescription'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_description
                ]
            else:
                props['ModelDescription'] = self.model_description

        if self.model_version is not None:
            if hasattr(self.model_version, 'to_dict'):
                props['ModelVersion'] = self.model_version.to_dict()
            elif isinstance(self.model_version, list):
                props['ModelVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_version
                ]
            else:
                props['ModelVersion'] = self.model_version

        if self.model_creator is not None:
            if hasattr(self.model_creator, 'to_dict'):
                props['ModelCreator'] = self.model_creator.to_dict()
            elif isinstance(self.model_creator, list):
                props['ModelCreator'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_creator
                ]
            else:
                props['ModelCreator'] = self.model_creator

        if self.model_id is not None:
            if hasattr(self.model_id, 'to_dict'):
                props['ModelId'] = self.model_id.to_dict()
            elif isinstance(self.model_id, list):
                props['ModelId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_id
                ]
            else:
                props['ModelId'] = self.model_id

        return props


@dataclass
class ModelPackageCreator:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_profile_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.user_profile_name is not None:
            if hasattr(self.user_profile_name, 'to_dict'):
                props['UserProfileName'] = self.user_profile_name.to_dict()
            elif isinstance(self.user_profile_name, list):
                props['UserProfileName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_profile_name
                ]
            else:
                props['UserProfileName'] = self.user_profile_name

        return props


@dataclass
class ModelPackageDetails:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_package_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    task: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    created_by: Optional[ModelPackageCreator] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    approval_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_approval_status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_package_version: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_package_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_package_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_package_status: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_algorithms: Optional[list[SourceAlgorithm]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inference_specification: Optional[InferenceSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_package_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    domain: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_package_group_name is not None:
            if hasattr(self.model_package_group_name, 'to_dict'):
                props['ModelPackageGroupName'] = self.model_package_group_name.to_dict()
            elif isinstance(self.model_package_group_name, list):
                props['ModelPackageGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_package_group_name
                ]
            else:
                props['ModelPackageGroupName'] = self.model_package_group_name

        if self.task is not None:
            if hasattr(self.task, 'to_dict'):
                props['Task'] = self.task.to_dict()
            elif isinstance(self.task, list):
                props['Task'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.task
                ]
            else:
                props['Task'] = self.task

        if self.created_by is not None:
            if hasattr(self.created_by, 'to_dict'):
                props['CreatedBy'] = self.created_by.to_dict()
            elif isinstance(self.created_by, list):
                props['CreatedBy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.created_by
                ]
            else:
                props['CreatedBy'] = self.created_by

        if self.approval_description is not None:
            if hasattr(self.approval_description, 'to_dict'):
                props['ApprovalDescription'] = self.approval_description.to_dict()
            elif isinstance(self.approval_description, list):
                props['ApprovalDescription'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.approval_description
                ]
            else:
                props['ApprovalDescription'] = self.approval_description

        if self.model_approval_status is not None:
            if hasattr(self.model_approval_status, 'to_dict'):
                props['ModelApprovalStatus'] = self.model_approval_status.to_dict()
            elif isinstance(self.model_approval_status, list):
                props['ModelApprovalStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_approval_status
                ]
            else:
                props['ModelApprovalStatus'] = self.model_approval_status

        if self.model_package_version is not None:
            if hasattr(self.model_package_version, 'to_dict'):
                props['ModelPackageVersion'] = self.model_package_version.to_dict()
            elif isinstance(self.model_package_version, list):
                props['ModelPackageVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_package_version
                ]
            else:
                props['ModelPackageVersion'] = self.model_package_version

        if self.model_package_description is not None:
            if hasattr(self.model_package_description, 'to_dict'):
                props['ModelPackageDescription'] = self.model_package_description.to_dict()
            elif isinstance(self.model_package_description, list):
                props['ModelPackageDescription'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_package_description
                ]
            else:
                props['ModelPackageDescription'] = self.model_package_description

        if self.model_package_name is not None:
            if hasattr(self.model_package_name, 'to_dict'):
                props['ModelPackageName'] = self.model_package_name.to_dict()
            elif isinstance(self.model_package_name, list):
                props['ModelPackageName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_package_name
                ]
            else:
                props['ModelPackageName'] = self.model_package_name

        if self.model_package_status is not None:
            if hasattr(self.model_package_status, 'to_dict'):
                props['ModelPackageStatus'] = self.model_package_status.to_dict()
            elif isinstance(self.model_package_status, list):
                props['ModelPackageStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_package_status
                ]
            else:
                props['ModelPackageStatus'] = self.model_package_status

        if self.source_algorithms is not None:
            if hasattr(self.source_algorithms, 'to_dict'):
                props['SourceAlgorithms'] = self.source_algorithms.to_dict()
            elif isinstance(self.source_algorithms, list):
                props['SourceAlgorithms'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_algorithms
                ]
            else:
                props['SourceAlgorithms'] = self.source_algorithms

        if self.inference_specification is not None:
            if hasattr(self.inference_specification, 'to_dict'):
                props['InferenceSpecification'] = self.inference_specification.to_dict()
            elif isinstance(self.inference_specification, list):
                props['InferenceSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inference_specification
                ]
            else:
                props['InferenceSpecification'] = self.inference_specification

        if self.model_package_arn is not None:
            if hasattr(self.model_package_arn, 'to_dict'):
                props['ModelPackageArn'] = self.model_package_arn.to_dict()
            elif isinstance(self.model_package_arn, list):
                props['ModelPackageArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_package_arn
                ]
            else:
                props['ModelPackageArn'] = self.model_package_arn

        if self.domain is not None:
            if hasattr(self.domain, 'to_dict'):
                props['Domain'] = self.domain.to_dict()
            elif isinstance(self.domain, list):
                props['Domain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain
                ]
            else:
                props['Domain'] = self.domain

        return props


@dataclass
class ObjectiveFunction:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    function: Optional[Function] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notes: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.function is not None:
            if hasattr(self.function, 'to_dict'):
                props['Function'] = self.function.to_dict()
            elif isinstance(self.function, list):
                props['Function'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.function
                ]
            else:
                props['Function'] = self.function

        if self.notes is not None:
            if hasattr(self.notes, 'to_dict'):
                props['Notes'] = self.notes.to_dict()
            elif isinstance(self.notes, list):
                props['Notes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notes
                ]
            else:
                props['Notes'] = self.notes

        return props


@dataclass
class SecurityConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        return props


@dataclass
class SourceAlgorithm:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_data_url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    algorithm_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_data_url is not None:
            if hasattr(self.model_data_url, 'to_dict'):
                props['ModelDataUrl'] = self.model_data_url.to_dict()
            elif isinstance(self.model_data_url, list):
                props['ModelDataUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_data_url
                ]
            else:
                props['ModelDataUrl'] = self.model_data_url

        if self.algorithm_name is not None:
            if hasattr(self.algorithm_name, 'to_dict'):
                props['AlgorithmName'] = self.algorithm_name.to_dict()
            elif isinstance(self.algorithm_name, list):
                props['AlgorithmName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.algorithm_name
                ]
            else:
                props['AlgorithmName'] = self.algorithm_name

        return props


@dataclass
class TrainingDetails:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    objective_function: Optional[ObjectiveFunction] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    training_observations: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    training_job_details: Optional[TrainingJobDetails] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.objective_function is not None:
            if hasattr(self.objective_function, 'to_dict'):
                props['ObjectiveFunction'] = self.objective_function.to_dict()
            elif isinstance(self.objective_function, list):
                props['ObjectiveFunction'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.objective_function
                ]
            else:
                props['ObjectiveFunction'] = self.objective_function

        if self.training_observations is not None:
            if hasattr(self.training_observations, 'to_dict'):
                props['TrainingObservations'] = self.training_observations.to_dict()
            elif isinstance(self.training_observations, list):
                props['TrainingObservations'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.training_observations
                ]
            else:
                props['TrainingObservations'] = self.training_observations

        if self.training_job_details is not None:
            if hasattr(self.training_job_details, 'to_dict'):
                props['TrainingJobDetails'] = self.training_job_details.to_dict()
            elif isinstance(self.training_job_details, list):
                props['TrainingJobDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.training_job_details
                ]
            else:
                props['TrainingJobDetails'] = self.training_job_details

        return props


@dataclass
class TrainingEnvironment:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_image: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.container_image is not None:
            if hasattr(self.container_image, 'to_dict'):
                props['ContainerImage'] = self.container_image.to_dict()
            elif isinstance(self.container_image, list):
                props['ContainerImage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_image
                ]
            else:
                props['ContainerImage'] = self.container_image

        return props


@dataclass
class TrainingHyperParameter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class TrainingJobDetails:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    training_metrics: Optional[list[TrainingMetric]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hyper_parameters: Optional[list[TrainingHyperParameter]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    training_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_provided_training_metrics: Optional[list[TrainingMetric]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    training_environment: Optional[TrainingEnvironment] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    training_datasets: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_provided_hyper_parameters: Optional[list[TrainingHyperParameter]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.training_metrics is not None:
            if hasattr(self.training_metrics, 'to_dict'):
                props['TrainingMetrics'] = self.training_metrics.to_dict()
            elif isinstance(self.training_metrics, list):
                props['TrainingMetrics'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.training_metrics
                ]
            else:
                props['TrainingMetrics'] = self.training_metrics

        if self.hyper_parameters is not None:
            if hasattr(self.hyper_parameters, 'to_dict'):
                props['HyperParameters'] = self.hyper_parameters.to_dict()
            elif isinstance(self.hyper_parameters, list):
                props['HyperParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hyper_parameters
                ]
            else:
                props['HyperParameters'] = self.hyper_parameters

        if self.training_arn is not None:
            if hasattr(self.training_arn, 'to_dict'):
                props['TrainingArn'] = self.training_arn.to_dict()
            elif isinstance(self.training_arn, list):
                props['TrainingArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.training_arn
                ]
            else:
                props['TrainingArn'] = self.training_arn

        if self.user_provided_training_metrics is not None:
            if hasattr(self.user_provided_training_metrics, 'to_dict'):
                props['UserProvidedTrainingMetrics'] = self.user_provided_training_metrics.to_dict()
            elif isinstance(self.user_provided_training_metrics, list):
                props['UserProvidedTrainingMetrics'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_provided_training_metrics
                ]
            else:
                props['UserProvidedTrainingMetrics'] = self.user_provided_training_metrics

        if self.training_environment is not None:
            if hasattr(self.training_environment, 'to_dict'):
                props['TrainingEnvironment'] = self.training_environment.to_dict()
            elif isinstance(self.training_environment, list):
                props['TrainingEnvironment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.training_environment
                ]
            else:
                props['TrainingEnvironment'] = self.training_environment

        if self.training_datasets is not None:
            if hasattr(self.training_datasets, 'to_dict'):
                props['TrainingDatasets'] = self.training_datasets.to_dict()
            elif isinstance(self.training_datasets, list):
                props['TrainingDatasets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.training_datasets
                ]
            else:
                props['TrainingDatasets'] = self.training_datasets

        if self.user_provided_hyper_parameters is not None:
            if hasattr(self.user_provided_hyper_parameters, 'to_dict'):
                props['UserProvidedHyperParameters'] = self.user_provided_hyper_parameters.to_dict()
            elif isinstance(self.user_provided_hyper_parameters, list):
                props['UserProvidedHyperParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_provided_hyper_parameters
                ]
            else:
                props['UserProvidedHyperParameters'] = self.user_provided_hyper_parameters

        return props


@dataclass
class TrainingMetric:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notes: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.notes is not None:
            if hasattr(self.notes, 'to_dict'):
                props['Notes'] = self.notes.to_dict()
            elif isinstance(self.notes, list):
                props['Notes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notes
                ]
            else:
                props['Notes'] = self.notes

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class UserContext:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    domain_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_profile_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_profile_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.domain_id is not None:
            if hasattr(self.domain_id, 'to_dict'):
                props['DomainId'] = self.domain_id.to_dict()
            elif isinstance(self.domain_id, list):
                props['DomainId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_id
                ]
            else:
                props['DomainId'] = self.domain_id

        if self.user_profile_arn is not None:
            if hasattr(self.user_profile_arn, 'to_dict'):
                props['UserProfileArn'] = self.user_profile_arn.to_dict()
            elif isinstance(self.user_profile_arn, list):
                props['UserProfileArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_profile_arn
                ]
            else:
                props['UserProfileArn'] = self.user_profile_arn

        if self.user_profile_name is not None:
            if hasattr(self.user_profile_name, 'to_dict'):
                props['UserProfileName'] = self.user_profile_name.to_dict()
            elif isinstance(self.user_profile_name, list):
                props['UserProfileName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_profile_name
                ]
            else:
                props['UserProfileName'] = self.user_profile_name

        return props


@dataclass
class ModelCard(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::ModelCard"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    last_modified_by: Optional[UserContext] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_card_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_card_status: Optional[Union[str, ModelCardStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    created_by: Optional[UserContext] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_config: Optional[SecurityConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    content: Optional[Content] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.last_modified_by is not None:
            # Serialize last_modified_by (handle intrinsic functions)
            if hasattr(self.last_modified_by, 'to_dict'):
                props["LastModifiedBy"] = self.last_modified_by.to_dict()
            elif isinstance(self.last_modified_by, list):
                # Serialize list items (may contain intrinsic functions)
                props['LastModifiedBy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.last_modified_by
                ]
            else:
                props["LastModifiedBy"] = self.last_modified_by

        if self.model_card_name is not None:
            # Serialize model_card_name (handle intrinsic functions)
            if hasattr(self.model_card_name, 'to_dict'):
                props["ModelCardName"] = self.model_card_name.to_dict()
            elif isinstance(self.model_card_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelCardName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_card_name
                ]
            else:
                props["ModelCardName"] = self.model_card_name

        if self.model_card_status is not None:
            # Serialize model_card_status (handle intrinsic functions)
            if hasattr(self.model_card_status, 'to_dict'):
                props["ModelCardStatus"] = self.model_card_status.to_dict()
            elif isinstance(self.model_card_status, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelCardStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_card_status
                ]
            else:
                props["ModelCardStatus"] = self.model_card_status

        if self.created_by is not None:
            # Serialize created_by (handle intrinsic functions)
            if hasattr(self.created_by, 'to_dict'):
                props["CreatedBy"] = self.created_by.to_dict()
            elif isinstance(self.created_by, list):
                # Serialize list items (may contain intrinsic functions)
                props['CreatedBy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.created_by
                ]
            else:
                props["CreatedBy"] = self.created_by

        if self.security_config is not None:
            # Serialize security_config (handle intrinsic functions)
            if hasattr(self.security_config, 'to_dict'):
                props["SecurityConfig"] = self.security_config.to_dict()
            elif isinstance(self.security_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_config
                ]
            else:
                props["SecurityConfig"] = self.security_config

        if self.content is not None:
            # Serialize content (handle intrinsic functions)
            if hasattr(self.content, 'to_dict'):
                props["Content"] = self.content.to_dict()
            elif isinstance(self.content, list):
                # Serialize list items (may contain intrinsic functions)
                props['Content'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.content
                ]
            else:
                props["Content"] = self.content

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_last_modified_by__user_profile_arn(self) -> GetAtt:
        """Get the LastModifiedBy.UserProfileArn attribute."""
        return self.get_att("LastModifiedBy.UserProfileArn")

    @property
    def attr_created_by__domain_id(self) -> GetAtt:
        """Get the CreatedBy.DomainId attribute."""
        return self.get_att("CreatedBy.DomainId")

    @property
    def attr_model_card_arn(self) -> GetAtt:
        """Get the ModelCardArn attribute."""
        return self.get_att("ModelCardArn")

    @property
    def attr_created_by__user_profile_name(self) -> GetAtt:
        """Get the CreatedBy.UserProfileName attribute."""
        return self.get_att("CreatedBy.UserProfileName")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_last_modified_time(self) -> GetAtt:
        """Get the LastModifiedTime attribute."""
        return self.get_att("LastModifiedTime")

    @property
    def attr_last_modified_by__domain_id(self) -> GetAtt:
        """Get the LastModifiedBy.DomainId attribute."""
        return self.get_att("LastModifiedBy.DomainId")

    @property
    def attr_model_card_version(self) -> GetAtt:
        """Get the ModelCardVersion attribute."""
        return self.get_att("ModelCardVersion")

    @property
    def attr_model_card_processing_status(self) -> GetAtt:
        """Get the ModelCardProcessingStatus attribute."""
        return self.get_att("ModelCardProcessingStatus")

    @property
    def attr_last_modified_by__user_profile_name(self) -> GetAtt:
        """Get the LastModifiedBy.UserProfileName attribute."""
        return self.get_att("LastModifiedBy.UserProfileName")

    @property
    def attr_created_by__user_profile_arn(self) -> GetAtt:
        """Get the CreatedBy.UserProfileArn attribute."""
        return self.get_att("CreatedBy.UserProfileArn")




@dataclass
class BatchTransformInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dataset_format: Optional[DatasetFormat] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_distribution_type: Optional[Union[str, ProcessingS3DataDistributionType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inference_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_captured_destination_s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_input_mode: Optional[Union[str, ProcessingS3InputMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    probability_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    features_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.dataset_format is not None:
            if hasattr(self.dataset_format, 'to_dict'):
                props['DatasetFormat'] = self.dataset_format.to_dict()
            elif isinstance(self.dataset_format, list):
                props['DatasetFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dataset_format
                ]
            else:
                props['DatasetFormat'] = self.dataset_format

        if self.s3_data_distribution_type is not None:
            if hasattr(self.s3_data_distribution_type, 'to_dict'):
                props['S3DataDistributionType'] = self.s3_data_distribution_type.to_dict()
            elif isinstance(self.s3_data_distribution_type, list):
                props['S3DataDistributionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_distribution_type
                ]
            else:
                props['S3DataDistributionType'] = self.s3_data_distribution_type

        if self.inference_attribute is not None:
            if hasattr(self.inference_attribute, 'to_dict'):
                props['InferenceAttribute'] = self.inference_attribute.to_dict()
            elif isinstance(self.inference_attribute, list):
                props['InferenceAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inference_attribute
                ]
            else:
                props['InferenceAttribute'] = self.inference_attribute

        if self.data_captured_destination_s3_uri is not None:
            if hasattr(self.data_captured_destination_s3_uri, 'to_dict'):
                props['DataCapturedDestinationS3Uri'] = self.data_captured_destination_s3_uri.to_dict()
            elif isinstance(self.data_captured_destination_s3_uri, list):
                props['DataCapturedDestinationS3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_captured_destination_s3_uri
                ]
            else:
                props['DataCapturedDestinationS3Uri'] = self.data_captured_destination_s3_uri

        if self.s3_input_mode is not None:
            if hasattr(self.s3_input_mode, 'to_dict'):
                props['S3InputMode'] = self.s3_input_mode.to_dict()
            elif isinstance(self.s3_input_mode, list):
                props['S3InputMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_input_mode
                ]
            else:
                props['S3InputMode'] = self.s3_input_mode

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.probability_attribute is not None:
            if hasattr(self.probability_attribute, 'to_dict'):
                props['ProbabilityAttribute'] = self.probability_attribute.to_dict()
            elif isinstance(self.probability_attribute, list):
                props['ProbabilityAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.probability_attribute
                ]
            else:
                props['ProbabilityAttribute'] = self.probability_attribute

        if self.features_attribute is not None:
            if hasattr(self.features_attribute, 'to_dict'):
                props['FeaturesAttribute'] = self.features_attribute.to_dict()
            elif isinstance(self.features_attribute, list):
                props['FeaturesAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.features_attribute
                ]
            else:
                props['FeaturesAttribute'] = self.features_attribute

        return props


@dataclass
class ClusterConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size_in_gb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_count is not None:
            if hasattr(self.instance_count, 'to_dict'):
                props['InstanceCount'] = self.instance_count.to_dict()
            elif isinstance(self.instance_count, list):
                props['InstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_count
                ]
            else:
                props['InstanceCount'] = self.instance_count

        if self.volume_size_in_gb is not None:
            if hasattr(self.volume_size_in_gb, 'to_dict'):
                props['VolumeSizeInGB'] = self.volume_size_in_gb.to_dict()
            elif isinstance(self.volume_size_in_gb, list):
                props['VolumeSizeInGB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size_in_gb
                ]
            else:
                props['VolumeSizeInGB'] = self.volume_size_in_gb

        if self.volume_kms_key_id is not None:
            if hasattr(self.volume_kms_key_id, 'to_dict'):
                props['VolumeKmsKeyId'] = self.volume_kms_key_id.to_dict()
            elif isinstance(self.volume_kms_key_id, list):
                props['VolumeKmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_kms_key_id
                ]
            else:
                props['VolumeKmsKeyId'] = self.volume_kms_key_id

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        return props


@dataclass
class ConstraintsResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        return props


@dataclass
class Csv:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    header: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.header is not None:
            if hasattr(self.header, 'to_dict'):
                props['Header'] = self.header.to_dict()
            elif isinstance(self.header, list):
                props['Header'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.header
                ]
            else:
                props['Header'] = self.header

        return props


@dataclass
class DatasetFormat:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parquet: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    csv: Optional[Csv] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    json: Optional[Json] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.parquet is not None:
            if hasattr(self.parquet, 'to_dict'):
                props['Parquet'] = self.parquet.to_dict()
            elif isinstance(self.parquet, list):
                props['Parquet'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parquet
                ]
            else:
                props['Parquet'] = self.parquet

        if self.csv is not None:
            if hasattr(self.csv, 'to_dict'):
                props['Csv'] = self.csv.to_dict()
            elif isinstance(self.csv, list):
                props['Csv'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.csv
                ]
            else:
                props['Csv'] = self.csv

        if self.json is not None:
            if hasattr(self.json, 'to_dict'):
                props['Json'] = self.json.to_dict()
            elif isinstance(self.json, list):
                props['Json'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.json
                ]
            else:
                props['Json'] = self.json

        return props


@dataclass
class EndpointInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_distribution_type: Optional[Union[str, ProcessingS3DataDistributionType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inference_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_input_mode: Optional[Union[str, ProcessingS3InputMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    probability_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    features_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_data_distribution_type is not None:
            if hasattr(self.s3_data_distribution_type, 'to_dict'):
                props['S3DataDistributionType'] = self.s3_data_distribution_type.to_dict()
            elif isinstance(self.s3_data_distribution_type, list):
                props['S3DataDistributionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_distribution_type
                ]
            else:
                props['S3DataDistributionType'] = self.s3_data_distribution_type

        if self.endpoint_name is not None:
            if hasattr(self.endpoint_name, 'to_dict'):
                props['EndpointName'] = self.endpoint_name.to_dict()
            elif isinstance(self.endpoint_name, list):
                props['EndpointName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_name
                ]
            else:
                props['EndpointName'] = self.endpoint_name

        if self.inference_attribute is not None:
            if hasattr(self.inference_attribute, 'to_dict'):
                props['InferenceAttribute'] = self.inference_attribute.to_dict()
            elif isinstance(self.inference_attribute, list):
                props['InferenceAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inference_attribute
                ]
            else:
                props['InferenceAttribute'] = self.inference_attribute

        if self.s3_input_mode is not None:
            if hasattr(self.s3_input_mode, 'to_dict'):
                props['S3InputMode'] = self.s3_input_mode.to_dict()
            elif isinstance(self.s3_input_mode, list):
                props['S3InputMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_input_mode
                ]
            else:
                props['S3InputMode'] = self.s3_input_mode

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.probability_attribute is not None:
            if hasattr(self.probability_attribute, 'to_dict'):
                props['ProbabilityAttribute'] = self.probability_attribute.to_dict()
            elif isinstance(self.probability_attribute, list):
                props['ProbabilityAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.probability_attribute
                ]
            else:
                props['ProbabilityAttribute'] = self.probability_attribute

        if self.features_attribute is not None:
            if hasattr(self.features_attribute, 'to_dict'):
                props['FeaturesAttribute'] = self.features_attribute.to_dict()
            elif isinstance(self.features_attribute, list):
                props['FeaturesAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.features_attribute
                ]
            else:
                props['FeaturesAttribute'] = self.features_attribute

        return props


@dataclass
class Json:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    line: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.line is not None:
            if hasattr(self.line, 'to_dict'):
                props['Line'] = self.line.to_dict()
            elif isinstance(self.line, list):
                props['Line'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.line
                ]
            else:
                props['Line'] = self.line

        return props


@dataclass
class ModelExplainabilityAppSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    config_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    environment: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.config_uri is not None:
            if hasattr(self.config_uri, 'to_dict'):
                props['ConfigUri'] = self.config_uri.to_dict()
            elif isinstance(self.config_uri, list):
                props['ConfigUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.config_uri
                ]
            else:
                props['ConfigUri'] = self.config_uri

        if self.environment is not None:
            if hasattr(self.environment, 'to_dict'):
                props['Environment'] = self.environment.to_dict()
            elif isinstance(self.environment, list):
                props['Environment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment
                ]
            else:
                props['Environment'] = self.environment

        if self.image_uri is not None:
            if hasattr(self.image_uri, 'to_dict'):
                props['ImageUri'] = self.image_uri.to_dict()
            elif isinstance(self.image_uri, list):
                props['ImageUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_uri
                ]
            else:
                props['ImageUri'] = self.image_uri

        return props


@dataclass
class ModelExplainabilityBaselineConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    constraints_resource: Optional[ConstraintsResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baselining_job_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.constraints_resource is not None:
            if hasattr(self.constraints_resource, 'to_dict'):
                props['ConstraintsResource'] = self.constraints_resource.to_dict()
            elif isinstance(self.constraints_resource, list):
                props['ConstraintsResource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.constraints_resource
                ]
            else:
                props['ConstraintsResource'] = self.constraints_resource

        if self.baselining_job_name is not None:
            if hasattr(self.baselining_job_name, 'to_dict'):
                props['BaseliningJobName'] = self.baselining_job_name.to_dict()
            elif isinstance(self.baselining_job_name, list):
                props['BaseliningJobName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baselining_job_name
                ]
            else:
                props['BaseliningJobName'] = self.baselining_job_name

        return props


@dataclass
class ModelExplainabilityJobInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    batch_transform_input: Optional[BatchTransformInput] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_input: Optional[EndpointInput] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.batch_transform_input is not None:
            if hasattr(self.batch_transform_input, 'to_dict'):
                props['BatchTransformInput'] = self.batch_transform_input.to_dict()
            elif isinstance(self.batch_transform_input, list):
                props['BatchTransformInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.batch_transform_input
                ]
            else:
                props['BatchTransformInput'] = self.batch_transform_input

        if self.endpoint_input is not None:
            if hasattr(self.endpoint_input, 'to_dict'):
                props['EndpointInput'] = self.endpoint_input.to_dict()
            elif isinstance(self.endpoint_input, list):
                props['EndpointInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_input
                ]
            else:
                props['EndpointInput'] = self.endpoint_input

        return props


@dataclass
class MonitoringOutput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_output: Optional[S3Output] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_output is not None:
            if hasattr(self.s3_output, 'to_dict'):
                props['S3Output'] = self.s3_output.to_dict()
            elif isinstance(self.s3_output, list):
                props['S3Output'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_output
                ]
            else:
                props['S3Output'] = self.s3_output

        return props


@dataclass
class MonitoringOutputConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring_outputs: Optional[list[MonitoringOutput]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.monitoring_outputs is not None:
            if hasattr(self.monitoring_outputs, 'to_dict'):
                props['MonitoringOutputs'] = self.monitoring_outputs.to_dict()
            elif isinstance(self.monitoring_outputs, list):
                props['MonitoringOutputs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_outputs
                ]
            else:
                props['MonitoringOutputs'] = self.monitoring_outputs

        return props


@dataclass
class MonitoringResources:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cluster_config: Optional[ClusterConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cluster_config is not None:
            if hasattr(self.cluster_config, 'to_dict'):
                props['ClusterConfig'] = self.cluster_config.to_dict()
            elif isinstance(self.cluster_config, list):
                props['ClusterConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cluster_config
                ]
            else:
                props['ClusterConfig'] = self.cluster_config

        return props


@dataclass
class NetworkConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_network_isolation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_inter_container_traffic_encryption: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_config: Optional[VpcConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enable_network_isolation is not None:
            if hasattr(self.enable_network_isolation, 'to_dict'):
                props['EnableNetworkIsolation'] = self.enable_network_isolation.to_dict()
            elif isinstance(self.enable_network_isolation, list):
                props['EnableNetworkIsolation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_network_isolation
                ]
            else:
                props['EnableNetworkIsolation'] = self.enable_network_isolation

        if self.enable_inter_container_traffic_encryption is not None:
            if hasattr(self.enable_inter_container_traffic_encryption, 'to_dict'):
                props['EnableInterContainerTrafficEncryption'] = self.enable_inter_container_traffic_encryption.to_dict()
            elif isinstance(self.enable_inter_container_traffic_encryption, list):
                props['EnableInterContainerTrafficEncryption'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_inter_container_traffic_encryption
                ]
            else:
                props['EnableInterContainerTrafficEncryption'] = self.enable_inter_container_traffic_encryption

        if self.vpc_config is not None:
            if hasattr(self.vpc_config, 'to_dict'):
                props['VpcConfig'] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props['VpcConfig'] = self.vpc_config

        return props


@dataclass
class S3Output:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_upload_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.s3_upload_mode is not None:
            if hasattr(self.s3_upload_mode, 'to_dict'):
                props['S3UploadMode'] = self.s3_upload_mode.to_dict()
            elif isinstance(self.s3_upload_mode, list):
                props['S3UploadMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_upload_mode
                ]
            else:
                props['S3UploadMode'] = self.s3_upload_mode

        return props


@dataclass
class StoppingCondition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_runtime_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_runtime_in_seconds is not None:
            if hasattr(self.max_runtime_in_seconds, 'to_dict'):
                props['MaxRuntimeInSeconds'] = self.max_runtime_in_seconds.to_dict()
            elif isinstance(self.max_runtime_in_seconds, list):
                props['MaxRuntimeInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_runtime_in_seconds
                ]
            else:
                props['MaxRuntimeInSeconds'] = self.max_runtime_in_seconds

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnets: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnets is not None:
            if hasattr(self.subnets, 'to_dict'):
                props['Subnets'] = self.subnets.to_dict()
            elif isinstance(self.subnets, list):
                props['Subnets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnets
                ]
            else:
                props['Subnets'] = self.subnets

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class ModelExplainabilityJobDefinition(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::ModelExplainabilityJobDefinition"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_explainability_job_output_config: Optional[MonitoringOutputConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    endpoint_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    stopping_condition: Optional[StoppingCondition] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_explainability_baseline_config: Optional[ModelExplainabilityBaselineConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    job_definition_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    job_resources: Optional[MonitoringResources] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_config: Optional[NetworkConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_explainability_job_input: Optional[ModelExplainabilityJobInput] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_explainability_app_specification: Optional[ModelExplainabilityAppSpecification] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_explainability_job_output_config is not None:
            # Serialize model_explainability_job_output_config (handle intrinsic functions)
            if hasattr(self.model_explainability_job_output_config, 'to_dict'):
                props["ModelExplainabilityJobOutputConfig"] = self.model_explainability_job_output_config.to_dict()
            elif isinstance(self.model_explainability_job_output_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelExplainabilityJobOutputConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_explainability_job_output_config
                ]
            else:
                props["ModelExplainabilityJobOutputConfig"] = self.model_explainability_job_output_config

        if self.endpoint_name is not None:
            # Serialize endpoint_name (handle intrinsic functions)
            if hasattr(self.endpoint_name, 'to_dict'):
                props["EndpointName"] = self.endpoint_name.to_dict()
            elif isinstance(self.endpoint_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndpointName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_name
                ]
            else:
                props["EndpointName"] = self.endpoint_name

        if self.stopping_condition is not None:
            # Serialize stopping_condition (handle intrinsic functions)
            if hasattr(self.stopping_condition, 'to_dict'):
                props["StoppingCondition"] = self.stopping_condition.to_dict()
            elif isinstance(self.stopping_condition, list):
                # Serialize list items (may contain intrinsic functions)
                props['StoppingCondition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stopping_condition
                ]
            else:
                props["StoppingCondition"] = self.stopping_condition

        if self.model_explainability_baseline_config is not None:
            # Serialize model_explainability_baseline_config (handle intrinsic functions)
            if hasattr(self.model_explainability_baseline_config, 'to_dict'):
                props["ModelExplainabilityBaselineConfig"] = self.model_explainability_baseline_config.to_dict()
            elif isinstance(self.model_explainability_baseline_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelExplainabilityBaselineConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_explainability_baseline_config
                ]
            else:
                props["ModelExplainabilityBaselineConfig"] = self.model_explainability_baseline_config

        if self.job_definition_name is not None:
            # Serialize job_definition_name (handle intrinsic functions)
            if hasattr(self.job_definition_name, 'to_dict'):
                props["JobDefinitionName"] = self.job_definition_name.to_dict()
            elif isinstance(self.job_definition_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['JobDefinitionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.job_definition_name
                ]
            else:
                props["JobDefinitionName"] = self.job_definition_name

        if self.job_resources is not None:
            # Serialize job_resources (handle intrinsic functions)
            if hasattr(self.job_resources, 'to_dict'):
                props["JobResources"] = self.job_resources.to_dict()
            elif isinstance(self.job_resources, list):
                # Serialize list items (may contain intrinsic functions)
                props['JobResources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.job_resources
                ]
            else:
                props["JobResources"] = self.job_resources

        if self.network_config is not None:
            # Serialize network_config (handle intrinsic functions)
            if hasattr(self.network_config, 'to_dict'):
                props["NetworkConfig"] = self.network_config.to_dict()
            elif isinstance(self.network_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_config
                ]
            else:
                props["NetworkConfig"] = self.network_config

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        if self.model_explainability_job_input is not None:
            # Serialize model_explainability_job_input (handle intrinsic functions)
            if hasattr(self.model_explainability_job_input, 'to_dict'):
                props["ModelExplainabilityJobInput"] = self.model_explainability_job_input.to_dict()
            elif isinstance(self.model_explainability_job_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelExplainabilityJobInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_explainability_job_input
                ]
            else:
                props["ModelExplainabilityJobInput"] = self.model_explainability_job_input

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.model_explainability_app_specification is not None:
            # Serialize model_explainability_app_specification (handle intrinsic functions)
            if hasattr(self.model_explainability_app_specification, 'to_dict'):
                props["ModelExplainabilityAppSpecification"] = self.model_explainability_app_specification.to_dict()
            elif isinstance(self.model_explainability_app_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelExplainabilityAppSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_explainability_app_specification
                ]
            else:
                props["ModelExplainabilityAppSpecification"] = self.model_explainability_app_specification

        return props

    @property
    def attr_job_definition_arn(self) -> GetAtt:
        """Get the JobDefinitionArn attribute."""
        return self.get_att("JobDefinitionArn")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")




@dataclass
class AdditionalInferenceSpecificationDefinition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    supported_content_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    supported_realtime_inference_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    containers: Optional[list[ModelPackageContainerDefinition]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    supported_transform_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    supported_response_mime_types: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            if hasattr(self.description, 'to_dict'):
                props['Description'] = self.description.to_dict()
            elif isinstance(self.description, list):
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props['Description'] = self.description

        if self.supported_content_types is not None:
            if hasattr(self.supported_content_types, 'to_dict'):
                props['SupportedContentTypes'] = self.supported_content_types.to_dict()
            elif isinstance(self.supported_content_types, list):
                props['SupportedContentTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.supported_content_types
                ]
            else:
                props['SupportedContentTypes'] = self.supported_content_types

        if self.supported_realtime_inference_instance_types is not None:
            if hasattr(self.supported_realtime_inference_instance_types, 'to_dict'):
                props['SupportedRealtimeInferenceInstanceTypes'] = self.supported_realtime_inference_instance_types.to_dict()
            elif isinstance(self.supported_realtime_inference_instance_types, list):
                props['SupportedRealtimeInferenceInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.supported_realtime_inference_instance_types
                ]
            else:
                props['SupportedRealtimeInferenceInstanceTypes'] = self.supported_realtime_inference_instance_types

        if self.containers is not None:
            if hasattr(self.containers, 'to_dict'):
                props['Containers'] = self.containers.to_dict()
            elif isinstance(self.containers, list):
                props['Containers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.containers
                ]
            else:
                props['Containers'] = self.containers

        if self.supported_transform_instance_types is not None:
            if hasattr(self.supported_transform_instance_types, 'to_dict'):
                props['SupportedTransformInstanceTypes'] = self.supported_transform_instance_types.to_dict()
            elif isinstance(self.supported_transform_instance_types, list):
                props['SupportedTransformInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.supported_transform_instance_types
                ]
            else:
                props['SupportedTransformInstanceTypes'] = self.supported_transform_instance_types

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        if self.supported_response_mime_types is not None:
            if hasattr(self.supported_response_mime_types, 'to_dict'):
                props['SupportedResponseMIMETypes'] = self.supported_response_mime_types.to_dict()
            elif isinstance(self.supported_response_mime_types, list):
                props['SupportedResponseMIMETypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.supported_response_mime_types
                ]
            else:
                props['SupportedResponseMIMETypes'] = self.supported_response_mime_types

        return props


@dataclass
class Bias:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    report: Optional[MetricsSource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    pre_training_report: Optional[MetricsSource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    post_training_report: Optional[MetricsSource] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.report is not None:
            if hasattr(self.report, 'to_dict'):
                props['Report'] = self.report.to_dict()
            elif isinstance(self.report, list):
                props['Report'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.report
                ]
            else:
                props['Report'] = self.report

        if self.pre_training_report is not None:
            if hasattr(self.pre_training_report, 'to_dict'):
                props['PreTrainingReport'] = self.pre_training_report.to_dict()
            elif isinstance(self.pre_training_report, list):
                props['PreTrainingReport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pre_training_report
                ]
            else:
                props['PreTrainingReport'] = self.pre_training_report

        if self.post_training_report is not None:
            if hasattr(self.post_training_report, 'to_dict'):
                props['PostTrainingReport'] = self.post_training_report.to_dict()
            elif isinstance(self.post_training_report, list):
                props['PostTrainingReport'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.post_training_report
                ]
            else:
                props['PostTrainingReport'] = self.post_training_report

        return props


@dataclass
class DataSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_source: Optional[S3DataSource] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_data_source is not None:
            if hasattr(self.s3_data_source, 'to_dict'):
                props['S3DataSource'] = self.s3_data_source.to_dict()
            elif isinstance(self.s3_data_source, list):
                props['S3DataSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_source
                ]
            else:
                props['S3DataSource'] = self.s3_data_source

        return props


@dataclass
class DriftCheckBaselines:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_data_quality: Optional[DriftCheckModelDataQuality] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bias: Optional[DriftCheckBias] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_quality: Optional[DriftCheckModelQuality] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    explainability: Optional[DriftCheckExplainability] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_data_quality is not None:
            if hasattr(self.model_data_quality, 'to_dict'):
                props['ModelDataQuality'] = self.model_data_quality.to_dict()
            elif isinstance(self.model_data_quality, list):
                props['ModelDataQuality'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_data_quality
                ]
            else:
                props['ModelDataQuality'] = self.model_data_quality

        if self.bias is not None:
            if hasattr(self.bias, 'to_dict'):
                props['Bias'] = self.bias.to_dict()
            elif isinstance(self.bias, list):
                props['Bias'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bias
                ]
            else:
                props['Bias'] = self.bias

        if self.model_quality is not None:
            if hasattr(self.model_quality, 'to_dict'):
                props['ModelQuality'] = self.model_quality.to_dict()
            elif isinstance(self.model_quality, list):
                props['ModelQuality'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_quality
                ]
            else:
                props['ModelQuality'] = self.model_quality

        if self.explainability is not None:
            if hasattr(self.explainability, 'to_dict'):
                props['Explainability'] = self.explainability.to_dict()
            elif isinstance(self.explainability, list):
                props['Explainability'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.explainability
                ]
            else:
                props['Explainability'] = self.explainability

        return props


@dataclass
class DriftCheckBias:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    pre_training_constraints: Optional[MetricsSource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    config_file: Optional[FileSource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    post_training_constraints: Optional[MetricsSource] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.pre_training_constraints is not None:
            if hasattr(self.pre_training_constraints, 'to_dict'):
                props['PreTrainingConstraints'] = self.pre_training_constraints.to_dict()
            elif isinstance(self.pre_training_constraints, list):
                props['PreTrainingConstraints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pre_training_constraints
                ]
            else:
                props['PreTrainingConstraints'] = self.pre_training_constraints

        if self.config_file is not None:
            if hasattr(self.config_file, 'to_dict'):
                props['ConfigFile'] = self.config_file.to_dict()
            elif isinstance(self.config_file, list):
                props['ConfigFile'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.config_file
                ]
            else:
                props['ConfigFile'] = self.config_file

        if self.post_training_constraints is not None:
            if hasattr(self.post_training_constraints, 'to_dict'):
                props['PostTrainingConstraints'] = self.post_training_constraints.to_dict()
            elif isinstance(self.post_training_constraints, list):
                props['PostTrainingConstraints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.post_training_constraints
                ]
            else:
                props['PostTrainingConstraints'] = self.post_training_constraints

        return props


@dataclass
class DriftCheckExplainability:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    constraints: Optional[MetricsSource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    config_file: Optional[FileSource] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.constraints is not None:
            if hasattr(self.constraints, 'to_dict'):
                props['Constraints'] = self.constraints.to_dict()
            elif isinstance(self.constraints, list):
                props['Constraints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.constraints
                ]
            else:
                props['Constraints'] = self.constraints

        if self.config_file is not None:
            if hasattr(self.config_file, 'to_dict'):
                props['ConfigFile'] = self.config_file.to_dict()
            elif isinstance(self.config_file, list):
                props['ConfigFile'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.config_file
                ]
            else:
                props['ConfigFile'] = self.config_file

        return props


@dataclass
class DriftCheckModelDataQuality:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    constraints: Optional[MetricsSource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    statistics: Optional[MetricsSource] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.constraints is not None:
            if hasattr(self.constraints, 'to_dict'):
                props['Constraints'] = self.constraints.to_dict()
            elif isinstance(self.constraints, list):
                props['Constraints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.constraints
                ]
            else:
                props['Constraints'] = self.constraints

        if self.statistics is not None:
            if hasattr(self.statistics, 'to_dict'):
                props['Statistics'] = self.statistics.to_dict()
            elif isinstance(self.statistics, list):
                props['Statistics'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.statistics
                ]
            else:
                props['Statistics'] = self.statistics

        return props


@dataclass
class DriftCheckModelQuality:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    constraints: Optional[MetricsSource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    statistics: Optional[MetricsSource] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.constraints is not None:
            if hasattr(self.constraints, 'to_dict'):
                props['Constraints'] = self.constraints.to_dict()
            elif isinstance(self.constraints, list):
                props['Constraints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.constraints
                ]
            else:
                props['Constraints'] = self.constraints

        if self.statistics is not None:
            if hasattr(self.statistics, 'to_dict'):
                props['Statistics'] = self.statistics.to_dict()
            elif isinstance(self.statistics, list):
                props['Statistics'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.statistics
                ]
            else:
                props['Statistics'] = self.statistics

        return props


@dataclass
class Explainability:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    report: Optional[MetricsSource] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.report is not None:
            if hasattr(self.report, 'to_dict'):
                props['Report'] = self.report.to_dict()
            elif isinstance(self.report, list):
                props['Report'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.report
                ]
            else:
                props['Report'] = self.report

        return props


@dataclass
class FileSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    content_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    content_digest: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.content_type is not None:
            if hasattr(self.content_type, 'to_dict'):
                props['ContentType'] = self.content_type.to_dict()
            elif isinstance(self.content_type, list):
                props['ContentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.content_type
                ]
            else:
                props['ContentType'] = self.content_type

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        if self.content_digest is not None:
            if hasattr(self.content_digest, 'to_dict'):
                props['ContentDigest'] = self.content_digest.to_dict()
            elif isinstance(self.content_digest, list):
                props['ContentDigest'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.content_digest
                ]
            else:
                props['ContentDigest'] = self.content_digest

        return props


@dataclass
class InferenceSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    supported_content_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    supported_realtime_inference_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    containers: Optional[list[ModelPackageContainerDefinition]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    supported_transform_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    supported_response_mime_types: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.supported_content_types is not None:
            if hasattr(self.supported_content_types, 'to_dict'):
                props['SupportedContentTypes'] = self.supported_content_types.to_dict()
            elif isinstance(self.supported_content_types, list):
                props['SupportedContentTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.supported_content_types
                ]
            else:
                props['SupportedContentTypes'] = self.supported_content_types

        if self.supported_realtime_inference_instance_types is not None:
            if hasattr(self.supported_realtime_inference_instance_types, 'to_dict'):
                props['SupportedRealtimeInferenceInstanceTypes'] = self.supported_realtime_inference_instance_types.to_dict()
            elif isinstance(self.supported_realtime_inference_instance_types, list):
                props['SupportedRealtimeInferenceInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.supported_realtime_inference_instance_types
                ]
            else:
                props['SupportedRealtimeInferenceInstanceTypes'] = self.supported_realtime_inference_instance_types

        if self.containers is not None:
            if hasattr(self.containers, 'to_dict'):
                props['Containers'] = self.containers.to_dict()
            elif isinstance(self.containers, list):
                props['Containers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.containers
                ]
            else:
                props['Containers'] = self.containers

        if self.supported_transform_instance_types is not None:
            if hasattr(self.supported_transform_instance_types, 'to_dict'):
                props['SupportedTransformInstanceTypes'] = self.supported_transform_instance_types.to_dict()
            elif isinstance(self.supported_transform_instance_types, list):
                props['SupportedTransformInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.supported_transform_instance_types
                ]
            else:
                props['SupportedTransformInstanceTypes'] = self.supported_transform_instance_types

        if self.supported_response_mime_types is not None:
            if hasattr(self.supported_response_mime_types, 'to_dict'):
                props['SupportedResponseMIMETypes'] = self.supported_response_mime_types.to_dict()
            elif isinstance(self.supported_response_mime_types, list):
                props['SupportedResponseMIMETypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.supported_response_mime_types
                ]
            else:
                props['SupportedResponseMIMETypes'] = self.supported_response_mime_types

        return props


@dataclass
class MetadataProperties:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    generated_by: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    repository: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    commit_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    project_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.generated_by is not None:
            if hasattr(self.generated_by, 'to_dict'):
                props['GeneratedBy'] = self.generated_by.to_dict()
            elif isinstance(self.generated_by, list):
                props['GeneratedBy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.generated_by
                ]
            else:
                props['GeneratedBy'] = self.generated_by

        if self.repository is not None:
            if hasattr(self.repository, 'to_dict'):
                props['Repository'] = self.repository.to_dict()
            elif isinstance(self.repository, list):
                props['Repository'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.repository
                ]
            else:
                props['Repository'] = self.repository

        if self.commit_id is not None:
            if hasattr(self.commit_id, 'to_dict'):
                props['CommitId'] = self.commit_id.to_dict()
            elif isinstance(self.commit_id, list):
                props['CommitId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.commit_id
                ]
            else:
                props['CommitId'] = self.commit_id

        if self.project_id is not None:
            if hasattr(self.project_id, 'to_dict'):
                props['ProjectId'] = self.project_id.to_dict()
            elif isinstance(self.project_id, list):
                props['ProjectId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.project_id
                ]
            else:
                props['ProjectId'] = self.project_id

        return props


@dataclass
class MetricsSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    content_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    content_digest: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.content_type is not None:
            if hasattr(self.content_type, 'to_dict'):
                props['ContentType'] = self.content_type.to_dict()
            elif isinstance(self.content_type, list):
                props['ContentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.content_type
                ]
            else:
                props['ContentType'] = self.content_type

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        if self.content_digest is not None:
            if hasattr(self.content_digest, 'to_dict'):
                props['ContentDigest'] = self.content_digest.to_dict()
            elif isinstance(self.content_digest, list):
                props['ContentDigest'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.content_digest
                ]
            else:
                props['ContentDigest'] = self.content_digest

        return props


@dataclass
class ModelAccessConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accept_eula: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.accept_eula is not None:
            if hasattr(self.accept_eula, 'to_dict'):
                props['AcceptEula'] = self.accept_eula.to_dict()
            elif isinstance(self.accept_eula, list):
                props['AcceptEula'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accept_eula
                ]
            else:
                props['AcceptEula'] = self.accept_eula

        return props


@dataclass
class ModelCard:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_card_status: Optional[Union[str, ModelCardStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_card_content: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_card_status is not None:
            if hasattr(self.model_card_status, 'to_dict'):
                props['ModelCardStatus'] = self.model_card_status.to_dict()
            elif isinstance(self.model_card_status, list):
                props['ModelCardStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_card_status
                ]
            else:
                props['ModelCardStatus'] = self.model_card_status

        if self.model_card_content is not None:
            if hasattr(self.model_card_content, 'to_dict'):
                props['ModelCardContent'] = self.model_card_content.to_dict()
            elif isinstance(self.model_card_content, list):
                props['ModelCardContent'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_card_content
                ]
            else:
                props['ModelCardContent'] = self.model_card_content

        return props


@dataclass
class ModelDataQuality:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    constraints: Optional[MetricsSource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    statistics: Optional[MetricsSource] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.constraints is not None:
            if hasattr(self.constraints, 'to_dict'):
                props['Constraints'] = self.constraints.to_dict()
            elif isinstance(self.constraints, list):
                props['Constraints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.constraints
                ]
            else:
                props['Constraints'] = self.constraints

        if self.statistics is not None:
            if hasattr(self.statistics, 'to_dict'):
                props['Statistics'] = self.statistics.to_dict()
            elif isinstance(self.statistics, list):
                props['Statistics'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.statistics
                ]
            else:
                props['Statistics'] = self.statistics

        return props


@dataclass
class ModelDataSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_source: Optional[S3ModelDataSource] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_data_source is not None:
            if hasattr(self.s3_data_source, 'to_dict'):
                props['S3DataSource'] = self.s3_data_source.to_dict()
            elif isinstance(self.s3_data_source, list):
                props['S3DataSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_source
                ]
            else:
                props['S3DataSource'] = self.s3_data_source

        return props


@dataclass
class ModelInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_input_config: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.data_input_config is not None:
            if hasattr(self.data_input_config, 'to_dict'):
                props['DataInputConfig'] = self.data_input_config.to_dict()
            elif isinstance(self.data_input_config, list):
                props['DataInputConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_input_config
                ]
            else:
                props['DataInputConfig'] = self.data_input_config

        return props


@dataclass
class ModelMetrics:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_data_quality: Optional[ModelDataQuality] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bias: Optional[Bias] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_quality: Optional[ModelQuality] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    explainability: Optional[Explainability] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_data_quality is not None:
            if hasattr(self.model_data_quality, 'to_dict'):
                props['ModelDataQuality'] = self.model_data_quality.to_dict()
            elif isinstance(self.model_data_quality, list):
                props['ModelDataQuality'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_data_quality
                ]
            else:
                props['ModelDataQuality'] = self.model_data_quality

        if self.bias is not None:
            if hasattr(self.bias, 'to_dict'):
                props['Bias'] = self.bias.to_dict()
            elif isinstance(self.bias, list):
                props['Bias'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bias
                ]
            else:
                props['Bias'] = self.bias

        if self.model_quality is not None:
            if hasattr(self.model_quality, 'to_dict'):
                props['ModelQuality'] = self.model_quality.to_dict()
            elif isinstance(self.model_quality, list):
                props['ModelQuality'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_quality
                ]
            else:
                props['ModelQuality'] = self.model_quality

        if self.explainability is not None:
            if hasattr(self.explainability, 'to_dict'):
                props['Explainability'] = self.explainability.to_dict()
            elif isinstance(self.explainability, list):
                props['Explainability'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.explainability
                ]
            else:
                props['Explainability'] = self.explainability

        return props


@dataclass
class ModelPackageContainerDefinition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_input: Optional[ModelInput] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    nearest_model_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_hostname: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_digest: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    framework_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    environment: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_data_url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_data_source: Optional[ModelDataSource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    framework: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_input is not None:
            if hasattr(self.model_input, 'to_dict'):
                props['ModelInput'] = self.model_input.to_dict()
            elif isinstance(self.model_input, list):
                props['ModelInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_input
                ]
            else:
                props['ModelInput'] = self.model_input

        if self.nearest_model_name is not None:
            if hasattr(self.nearest_model_name, 'to_dict'):
                props['NearestModelName'] = self.nearest_model_name.to_dict()
            elif isinstance(self.nearest_model_name, list):
                props['NearestModelName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.nearest_model_name
                ]
            else:
                props['NearestModelName'] = self.nearest_model_name

        if self.container_hostname is not None:
            if hasattr(self.container_hostname, 'to_dict'):
                props['ContainerHostname'] = self.container_hostname.to_dict()
            elif isinstance(self.container_hostname, list):
                props['ContainerHostname'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_hostname
                ]
            else:
                props['ContainerHostname'] = self.container_hostname

        if self.image_digest is not None:
            if hasattr(self.image_digest, 'to_dict'):
                props['ImageDigest'] = self.image_digest.to_dict()
            elif isinstance(self.image_digest, list):
                props['ImageDigest'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_digest
                ]
            else:
                props['ImageDigest'] = self.image_digest

        if self.framework_version is not None:
            if hasattr(self.framework_version, 'to_dict'):
                props['FrameworkVersion'] = self.framework_version.to_dict()
            elif isinstance(self.framework_version, list):
                props['FrameworkVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.framework_version
                ]
            else:
                props['FrameworkVersion'] = self.framework_version

        if self.environment is not None:
            if hasattr(self.environment, 'to_dict'):
                props['Environment'] = self.environment.to_dict()
            elif isinstance(self.environment, list):
                props['Environment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment
                ]
            else:
                props['Environment'] = self.environment

        if self.model_data_url is not None:
            if hasattr(self.model_data_url, 'to_dict'):
                props['ModelDataUrl'] = self.model_data_url.to_dict()
            elif isinstance(self.model_data_url, list):
                props['ModelDataUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_data_url
                ]
            else:
                props['ModelDataUrl'] = self.model_data_url

        if self.image is not None:
            if hasattr(self.image, 'to_dict'):
                props['Image'] = self.image.to_dict()
            elif isinstance(self.image, list):
                props['Image'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image
                ]
            else:
                props['Image'] = self.image

        if self.model_data_source is not None:
            if hasattr(self.model_data_source, 'to_dict'):
                props['ModelDataSource'] = self.model_data_source.to_dict()
            elif isinstance(self.model_data_source, list):
                props['ModelDataSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_data_source
                ]
            else:
                props['ModelDataSource'] = self.model_data_source

        if self.framework is not None:
            if hasattr(self.framework, 'to_dict'):
                props['Framework'] = self.framework.to_dict()
            elif isinstance(self.framework, list):
                props['Framework'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.framework
                ]
            else:
                props['Framework'] = self.framework

        return props


@dataclass
class ModelPackageStatusDetails:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    validation_statuses: Optional[list[ModelPackageStatusItem]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.validation_statuses is not None:
            if hasattr(self.validation_statuses, 'to_dict'):
                props['ValidationStatuses'] = self.validation_statuses.to_dict()
            elif isinstance(self.validation_statuses, list):
                props['ValidationStatuses'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.validation_statuses
                ]
            else:
                props['ValidationStatuses'] = self.validation_statuses

        return props


@dataclass
class ModelPackageStatusItem:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    status: Optional[Union[str, DetailedModelPackageStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    failure_reason: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.status is not None:
            if hasattr(self.status, 'to_dict'):
                props['Status'] = self.status.to_dict()
            elif isinstance(self.status, list):
                props['Status'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.status
                ]
            else:
                props['Status'] = self.status

        if self.failure_reason is not None:
            if hasattr(self.failure_reason, 'to_dict'):
                props['FailureReason'] = self.failure_reason.to_dict()
            elif isinstance(self.failure_reason, list):
                props['FailureReason'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.failure_reason
                ]
            else:
                props['FailureReason'] = self.failure_reason

        if self.name is not None:
            if hasattr(self.name, 'to_dict'):
                props['Name'] = self.name.to_dict()
            elif isinstance(self.name, list):
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props['Name'] = self.name

        return props


@dataclass
class ModelQuality:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    constraints: Optional[MetricsSource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    statistics: Optional[MetricsSource] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.constraints is not None:
            if hasattr(self.constraints, 'to_dict'):
                props['Constraints'] = self.constraints.to_dict()
            elif isinstance(self.constraints, list):
                props['Constraints'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.constraints
                ]
            else:
                props['Constraints'] = self.constraints

        if self.statistics is not None:
            if hasattr(self.statistics, 'to_dict'):
                props['Statistics'] = self.statistics.to_dict()
            elif isinstance(self.statistics, list):
                props['Statistics'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.statistics
                ]
            else:
                props['Statistics'] = self.statistics

        return props


@dataclass
class S3DataSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_type: Optional[Union[str, S3DataType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        if self.s3_data_type is not None:
            if hasattr(self.s3_data_type, 'to_dict'):
                props['S3DataType'] = self.s3_data_type.to_dict()
            elif isinstance(self.s3_data_type, list):
                props['S3DataType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_type
                ]
            else:
                props['S3DataType'] = self.s3_data_type

        return props


@dataclass
class S3ModelDataSource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_access_config: Optional[ModelAccessConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_type: Optional[Union[str, S3ModelDataType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    compression_type: Optional[Union[str, ModelCompressionType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_access_config is not None:
            if hasattr(self.model_access_config, 'to_dict'):
                props['ModelAccessConfig'] = self.model_access_config.to_dict()
            elif isinstance(self.model_access_config, list):
                props['ModelAccessConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_access_config
                ]
            else:
                props['ModelAccessConfig'] = self.model_access_config

        if self.s3_data_type is not None:
            if hasattr(self.s3_data_type, 'to_dict'):
                props['S3DataType'] = self.s3_data_type.to_dict()
            elif isinstance(self.s3_data_type, list):
                props['S3DataType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_type
                ]
            else:
                props['S3DataType'] = self.s3_data_type

        if self.compression_type is not None:
            if hasattr(self.compression_type, 'to_dict'):
                props['CompressionType'] = self.compression_type.to_dict()
            elif isinstance(self.compression_type, list):
                props['CompressionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compression_type
                ]
            else:
                props['CompressionType'] = self.compression_type

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        return props


@dataclass
class SecurityConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        return props


@dataclass
class SourceAlgorithm:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    model_data_url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    algorithm_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_data_url is not None:
            if hasattr(self.model_data_url, 'to_dict'):
                props['ModelDataUrl'] = self.model_data_url.to_dict()
            elif isinstance(self.model_data_url, list):
                props['ModelDataUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_data_url
                ]
            else:
                props['ModelDataUrl'] = self.model_data_url

        if self.algorithm_name is not None:
            if hasattr(self.algorithm_name, 'to_dict'):
                props['AlgorithmName'] = self.algorithm_name.to_dict()
            elif isinstance(self.algorithm_name, list):
                props['AlgorithmName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.algorithm_name
                ]
            else:
                props['AlgorithmName'] = self.algorithm_name

        return props


@dataclass
class SourceAlgorithmSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    source_algorithms: Optional[list[SourceAlgorithm]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.source_algorithms is not None:
            if hasattr(self.source_algorithms, 'to_dict'):
                props['SourceAlgorithms'] = self.source_algorithms.to_dict()
            elif isinstance(self.source_algorithms, list):
                props['SourceAlgorithms'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_algorithms
                ]
            else:
                props['SourceAlgorithms'] = self.source_algorithms

        return props


@dataclass
class TransformInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    content_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    split_type: Optional[Union[str, SplitType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    compression_type: Optional[Union[str, CompressionType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_source: Optional[DataSource] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.content_type is not None:
            if hasattr(self.content_type, 'to_dict'):
                props['ContentType'] = self.content_type.to_dict()
            elif isinstance(self.content_type, list):
                props['ContentType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.content_type
                ]
            else:
                props['ContentType'] = self.content_type

        if self.split_type is not None:
            if hasattr(self.split_type, 'to_dict'):
                props['SplitType'] = self.split_type.to_dict()
            elif isinstance(self.split_type, list):
                props['SplitType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.split_type
                ]
            else:
                props['SplitType'] = self.split_type

        if self.compression_type is not None:
            if hasattr(self.compression_type, 'to_dict'):
                props['CompressionType'] = self.compression_type.to_dict()
            elif isinstance(self.compression_type, list):
                props['CompressionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.compression_type
                ]
            else:
                props['CompressionType'] = self.compression_type

        if self.data_source is not None:
            if hasattr(self.data_source, 'to_dict'):
                props['DataSource'] = self.data_source.to_dict()
            elif isinstance(self.data_source, list):
                props['DataSource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_source
                ]
            else:
                props['DataSource'] = self.data_source

        return props


@dataclass
class TransformJobDefinition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transform_resources: Optional[TransformResources] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_concurrent_transforms: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_payload_in_mb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transform_output: Optional[TransformOutput] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    environment: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transform_input: Optional[TransformInput] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    batch_strategy: Optional[Union[str, BatchStrategy, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.transform_resources is not None:
            if hasattr(self.transform_resources, 'to_dict'):
                props['TransformResources'] = self.transform_resources.to_dict()
            elif isinstance(self.transform_resources, list):
                props['TransformResources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transform_resources
                ]
            else:
                props['TransformResources'] = self.transform_resources

        if self.max_concurrent_transforms is not None:
            if hasattr(self.max_concurrent_transforms, 'to_dict'):
                props['MaxConcurrentTransforms'] = self.max_concurrent_transforms.to_dict()
            elif isinstance(self.max_concurrent_transforms, list):
                props['MaxConcurrentTransforms'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_concurrent_transforms
                ]
            else:
                props['MaxConcurrentTransforms'] = self.max_concurrent_transforms

        if self.max_payload_in_mb is not None:
            if hasattr(self.max_payload_in_mb, 'to_dict'):
                props['MaxPayloadInMB'] = self.max_payload_in_mb.to_dict()
            elif isinstance(self.max_payload_in_mb, list):
                props['MaxPayloadInMB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_payload_in_mb
                ]
            else:
                props['MaxPayloadInMB'] = self.max_payload_in_mb

        if self.transform_output is not None:
            if hasattr(self.transform_output, 'to_dict'):
                props['TransformOutput'] = self.transform_output.to_dict()
            elif isinstance(self.transform_output, list):
                props['TransformOutput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transform_output
                ]
            else:
                props['TransformOutput'] = self.transform_output

        if self.environment is not None:
            if hasattr(self.environment, 'to_dict'):
                props['Environment'] = self.environment.to_dict()
            elif isinstance(self.environment, list):
                props['Environment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment
                ]
            else:
                props['Environment'] = self.environment

        if self.transform_input is not None:
            if hasattr(self.transform_input, 'to_dict'):
                props['TransformInput'] = self.transform_input.to_dict()
            elif isinstance(self.transform_input, list):
                props['TransformInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transform_input
                ]
            else:
                props['TransformInput'] = self.transform_input

        if self.batch_strategy is not None:
            if hasattr(self.batch_strategy, 'to_dict'):
                props['BatchStrategy'] = self.batch_strategy.to_dict()
            elif isinstance(self.batch_strategy, list):
                props['BatchStrategy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.batch_strategy
                ]
            else:
                props['BatchStrategy'] = self.batch_strategy

        return props


@dataclass
class TransformOutput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    assemble_with: Optional[Union[str, AssemblyType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    accept: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_output_path: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.assemble_with is not None:
            if hasattr(self.assemble_with, 'to_dict'):
                props['AssembleWith'] = self.assemble_with.to_dict()
            elif isinstance(self.assemble_with, list):
                props['AssembleWith'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.assemble_with
                ]
            else:
                props['AssembleWith'] = self.assemble_with

        if self.accept is not None:
            if hasattr(self.accept, 'to_dict'):
                props['Accept'] = self.accept.to_dict()
            elif isinstance(self.accept, list):
                props['Accept'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accept
                ]
            else:
                props['Accept'] = self.accept

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.s3_output_path is not None:
            if hasattr(self.s3_output_path, 'to_dict'):
                props['S3OutputPath'] = self.s3_output_path.to_dict()
            elif isinstance(self.s3_output_path, list):
                props['S3OutputPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_output_path
                ]
            else:
                props['S3OutputPath'] = self.s3_output_path

        return props


@dataclass
class TransformResources:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, TransformInstanceType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_count is not None:
            if hasattr(self.instance_count, 'to_dict'):
                props['InstanceCount'] = self.instance_count.to_dict()
            elif isinstance(self.instance_count, list):
                props['InstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_count
                ]
            else:
                props['InstanceCount'] = self.instance_count

        if self.volume_kms_key_id is not None:
            if hasattr(self.volume_kms_key_id, 'to_dict'):
                props['VolumeKmsKeyId'] = self.volume_kms_key_id.to_dict()
            elif isinstance(self.volume_kms_key_id, list):
                props['VolumeKmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_kms_key_id
                ]
            else:
                props['VolumeKmsKeyId'] = self.volume_kms_key_id

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        return props


@dataclass
class ValidationProfile:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    profile_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    transform_job_definition: Optional[TransformJobDefinition] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.profile_name is not None:
            if hasattr(self.profile_name, 'to_dict'):
                props['ProfileName'] = self.profile_name.to_dict()
            elif isinstance(self.profile_name, list):
                props['ProfileName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.profile_name
                ]
            else:
                props['ProfileName'] = self.profile_name

        if self.transform_job_definition is not None:
            if hasattr(self.transform_job_definition, 'to_dict'):
                props['TransformJobDefinition'] = self.transform_job_definition.to_dict()
            elif isinstance(self.transform_job_definition, list):
                props['TransformJobDefinition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.transform_job_definition
                ]
            else:
                props['TransformJobDefinition'] = self.transform_job_definition

        return props


@dataclass
class ValidationSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    validation_role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    validation_profiles: Optional[list[ValidationProfile]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.validation_role is not None:
            if hasattr(self.validation_role, 'to_dict'):
                props['ValidationRole'] = self.validation_role.to_dict()
            elif isinstance(self.validation_role, list):
                props['ValidationRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.validation_role
                ]
            else:
                props['ValidationRole'] = self.validation_role

        if self.validation_profiles is not None:
            if hasattr(self.validation_profiles, 'to_dict'):
                props['ValidationProfiles'] = self.validation_profiles.to_dict()
            elif isinstance(self.validation_profiles, list):
                props['ValidationProfiles'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.validation_profiles
                ]
            else:
                props['ValidationProfiles'] = self.validation_profiles

        return props


@dataclass
class ModelPackage(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::ModelPackage"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    drift_check_baselines: Optional[DriftCheckBaselines] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_metrics: Optional[ModelMetrics] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    task: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    customer_metadata_properties: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_approval_status: Optional[Union[str, ModelApprovalStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_package_version: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    metadata_properties: Optional[MetadataProperties] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    source_algorithm_specification: Optional[SourceAlgorithmSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_package_status_details: Optional[ModelPackageStatusDetails] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_package_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    additional_inference_specifications_to_add: Optional[list[AdditionalInferenceSpecificationDefinition]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_config: Optional[SecurityConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    inference_specification: Optional[InferenceSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    sample_payload_url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    certify_for_marketplace: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_package_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    approval_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_card: Optional[ModelCard] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    validation_specification: Optional[ValidationSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    skip_model_validation: Optional[Union[str, SkipModelValidation, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_package_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    last_modified_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    client_token: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    additional_inference_specifications: Optional[list[AdditionalInferenceSpecificationDefinition]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.drift_check_baselines is not None:
            # Serialize drift_check_baselines (handle intrinsic functions)
            if hasattr(self.drift_check_baselines, 'to_dict'):
                props["DriftCheckBaselines"] = self.drift_check_baselines.to_dict()
            elif isinstance(self.drift_check_baselines, list):
                # Serialize list items (may contain intrinsic functions)
                props['DriftCheckBaselines'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.drift_check_baselines
                ]
            else:
                props["DriftCheckBaselines"] = self.drift_check_baselines

        if self.model_metrics is not None:
            # Serialize model_metrics (handle intrinsic functions)
            if hasattr(self.model_metrics, 'to_dict'):
                props["ModelMetrics"] = self.model_metrics.to_dict()
            elif isinstance(self.model_metrics, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelMetrics'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_metrics
                ]
            else:
                props["ModelMetrics"] = self.model_metrics

        if self.task is not None:
            # Serialize task (handle intrinsic functions)
            if hasattr(self.task, 'to_dict'):
                props["Task"] = self.task.to_dict()
            elif isinstance(self.task, list):
                # Serialize list items (may contain intrinsic functions)
                props['Task'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.task
                ]
            else:
                props["Task"] = self.task

        if self.customer_metadata_properties is not None:
            # Serialize customer_metadata_properties (handle intrinsic functions)
            if hasattr(self.customer_metadata_properties, 'to_dict'):
                props["CustomerMetadataProperties"] = self.customer_metadata_properties.to_dict()
            elif isinstance(self.customer_metadata_properties, list):
                # Serialize list items (may contain intrinsic functions)
                props['CustomerMetadataProperties'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.customer_metadata_properties
                ]
            else:
                props["CustomerMetadataProperties"] = self.customer_metadata_properties

        if self.source_uri is not None:
            # Serialize source_uri (handle intrinsic functions)
            if hasattr(self.source_uri, 'to_dict'):
                props["SourceUri"] = self.source_uri.to_dict()
            elif isinstance(self.source_uri, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_uri
                ]
            else:
                props["SourceUri"] = self.source_uri

        if self.model_approval_status is not None:
            # Serialize model_approval_status (handle intrinsic functions)
            if hasattr(self.model_approval_status, 'to_dict'):
                props["ModelApprovalStatus"] = self.model_approval_status.to_dict()
            elif isinstance(self.model_approval_status, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelApprovalStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_approval_status
                ]
            else:
                props["ModelApprovalStatus"] = self.model_approval_status

        if self.model_package_version is not None:
            # Serialize model_package_version (handle intrinsic functions)
            if hasattr(self.model_package_version, 'to_dict'):
                props["ModelPackageVersion"] = self.model_package_version.to_dict()
            elif isinstance(self.model_package_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelPackageVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_package_version
                ]
            else:
                props["ModelPackageVersion"] = self.model_package_version

        if self.metadata_properties is not None:
            # Serialize metadata_properties (handle intrinsic functions)
            if hasattr(self.metadata_properties, 'to_dict'):
                props["MetadataProperties"] = self.metadata_properties.to_dict()
            elif isinstance(self.metadata_properties, list):
                # Serialize list items (may contain intrinsic functions)
                props['MetadataProperties'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.metadata_properties
                ]
            else:
                props["MetadataProperties"] = self.metadata_properties

        if self.source_algorithm_specification is not None:
            # Serialize source_algorithm_specification (handle intrinsic functions)
            if hasattr(self.source_algorithm_specification, 'to_dict'):
                props["SourceAlgorithmSpecification"] = self.source_algorithm_specification.to_dict()
            elif isinstance(self.source_algorithm_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['SourceAlgorithmSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.source_algorithm_specification
                ]
            else:
                props["SourceAlgorithmSpecification"] = self.source_algorithm_specification

        if self.model_package_status_details is not None:
            # Serialize model_package_status_details (handle intrinsic functions)
            if hasattr(self.model_package_status_details, 'to_dict'):
                props["ModelPackageStatusDetails"] = self.model_package_status_details.to_dict()
            elif isinstance(self.model_package_status_details, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelPackageStatusDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_package_status_details
                ]
            else:
                props["ModelPackageStatusDetails"] = self.model_package_status_details

        if self.model_package_description is not None:
            # Serialize model_package_description (handle intrinsic functions)
            if hasattr(self.model_package_description, 'to_dict'):
                props["ModelPackageDescription"] = self.model_package_description.to_dict()
            elif isinstance(self.model_package_description, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelPackageDescription'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_package_description
                ]
            else:
                props["ModelPackageDescription"] = self.model_package_description

        if self.additional_inference_specifications_to_add is not None:
            # Serialize additional_inference_specifications_to_add (handle intrinsic functions)
            if hasattr(self.additional_inference_specifications_to_add, 'to_dict'):
                props["AdditionalInferenceSpecificationsToAdd"] = self.additional_inference_specifications_to_add.to_dict()
            elif isinstance(self.additional_inference_specifications_to_add, list):
                # Serialize list items (may contain intrinsic functions)
                props['AdditionalInferenceSpecificationsToAdd'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_inference_specifications_to_add
                ]
            else:
                props["AdditionalInferenceSpecificationsToAdd"] = self.additional_inference_specifications_to_add

        if self.security_config is not None:
            # Serialize security_config (handle intrinsic functions)
            if hasattr(self.security_config, 'to_dict'):
                props["SecurityConfig"] = self.security_config.to_dict()
            elif isinstance(self.security_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_config
                ]
            else:
                props["SecurityConfig"] = self.security_config

        if self.inference_specification is not None:
            # Serialize inference_specification (handle intrinsic functions)
            if hasattr(self.inference_specification, 'to_dict'):
                props["InferenceSpecification"] = self.inference_specification.to_dict()
            elif isinstance(self.inference_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['InferenceSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inference_specification
                ]
            else:
                props["InferenceSpecification"] = self.inference_specification

        if self.sample_payload_url is not None:
            # Serialize sample_payload_url (handle intrinsic functions)
            if hasattr(self.sample_payload_url, 'to_dict'):
                props["SamplePayloadUrl"] = self.sample_payload_url.to_dict()
            elif isinstance(self.sample_payload_url, list):
                # Serialize list items (may contain intrinsic functions)
                props['SamplePayloadUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sample_payload_url
                ]
            else:
                props["SamplePayloadUrl"] = self.sample_payload_url

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.certify_for_marketplace is not None:
            # Serialize certify_for_marketplace (handle intrinsic functions)
            if hasattr(self.certify_for_marketplace, 'to_dict'):
                props["CertifyForMarketplace"] = self.certify_for_marketplace.to_dict()
            elif isinstance(self.certify_for_marketplace, list):
                # Serialize list items (may contain intrinsic functions)
                props['CertifyForMarketplace'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.certify_for_marketplace
                ]
            else:
                props["CertifyForMarketplace"] = self.certify_for_marketplace

        if self.model_package_group_name is not None:
            # Serialize model_package_group_name (handle intrinsic functions)
            if hasattr(self.model_package_group_name, 'to_dict'):
                props["ModelPackageGroupName"] = self.model_package_group_name.to_dict()
            elif isinstance(self.model_package_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelPackageGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_package_group_name
                ]
            else:
                props["ModelPackageGroupName"] = self.model_package_group_name

        if self.approval_description is not None:
            # Serialize approval_description (handle intrinsic functions)
            if hasattr(self.approval_description, 'to_dict'):
                props["ApprovalDescription"] = self.approval_description.to_dict()
            elif isinstance(self.approval_description, list):
                # Serialize list items (may contain intrinsic functions)
                props['ApprovalDescription'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.approval_description
                ]
            else:
                props["ApprovalDescription"] = self.approval_description

        if self.model_card is not None:
            # Serialize model_card (handle intrinsic functions)
            if hasattr(self.model_card, 'to_dict'):
                props["ModelCard"] = self.model_card.to_dict()
            elif isinstance(self.model_card, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelCard'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_card
                ]
            else:
                props["ModelCard"] = self.model_card

        if self.validation_specification is not None:
            # Serialize validation_specification (handle intrinsic functions)
            if hasattr(self.validation_specification, 'to_dict'):
                props["ValidationSpecification"] = self.validation_specification.to_dict()
            elif isinstance(self.validation_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['ValidationSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.validation_specification
                ]
            else:
                props["ValidationSpecification"] = self.validation_specification

        if self.skip_model_validation is not None:
            # Serialize skip_model_validation (handle intrinsic functions)
            if hasattr(self.skip_model_validation, 'to_dict'):
                props["SkipModelValidation"] = self.skip_model_validation.to_dict()
            elif isinstance(self.skip_model_validation, list):
                # Serialize list items (may contain intrinsic functions)
                props['SkipModelValidation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.skip_model_validation
                ]
            else:
                props["SkipModelValidation"] = self.skip_model_validation

        if self.model_package_name is not None:
            # Serialize model_package_name (handle intrinsic functions)
            if hasattr(self.model_package_name, 'to_dict'):
                props["ModelPackageName"] = self.model_package_name.to_dict()
            elif isinstance(self.model_package_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelPackageName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_package_name
                ]
            else:
                props["ModelPackageName"] = self.model_package_name

        if self.last_modified_time is not None:
            # Serialize last_modified_time (handle intrinsic functions)
            if hasattr(self.last_modified_time, 'to_dict'):
                props["LastModifiedTime"] = self.last_modified_time.to_dict()
            elif isinstance(self.last_modified_time, list):
                # Serialize list items (may contain intrinsic functions)
                props['LastModifiedTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.last_modified_time
                ]
            else:
                props["LastModifiedTime"] = self.last_modified_time

        if self.client_token is not None:
            # Serialize client_token (handle intrinsic functions)
            if hasattr(self.client_token, 'to_dict'):
                props["ClientToken"] = self.client_token.to_dict()
            elif isinstance(self.client_token, list):
                # Serialize list items (may contain intrinsic functions)
                props['ClientToken'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.client_token
                ]
            else:
                props["ClientToken"] = self.client_token

        if self.domain is not None:
            # Serialize domain (handle intrinsic functions)
            if hasattr(self.domain, 'to_dict'):
                props["Domain"] = self.domain.to_dict()
            elif isinstance(self.domain, list):
                # Serialize list items (may contain intrinsic functions)
                props['Domain'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain
                ]
            else:
                props["Domain"] = self.domain

        if self.additional_inference_specifications is not None:
            # Serialize additional_inference_specifications (handle intrinsic functions)
            if hasattr(self.additional_inference_specifications, 'to_dict'):
                props["AdditionalInferenceSpecifications"] = self.additional_inference_specifications.to_dict()
            elif isinstance(self.additional_inference_specifications, list):
                # Serialize list items (may contain intrinsic functions)
                props['AdditionalInferenceSpecifications'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_inference_specifications
                ]
            else:
                props["AdditionalInferenceSpecifications"] = self.additional_inference_specifications

        return props

    @property
    def attr_model_package_status(self) -> GetAtt:
        """Get the ModelPackageStatus attribute."""
        return self.get_att("ModelPackageStatus")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_model_package_arn(self) -> GetAtt:
        """Get the ModelPackageArn attribute."""
        return self.get_att("ModelPackageArn")




@dataclass
class ModelPackageGroup(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::ModelPackageGroup"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_package_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_package_group_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_package_group_policy: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_package_group_name is not None:
            # Serialize model_package_group_name (handle intrinsic functions)
            if hasattr(self.model_package_group_name, 'to_dict'):
                props["ModelPackageGroupName"] = self.model_package_group_name.to_dict()
            elif isinstance(self.model_package_group_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelPackageGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_package_group_name
                ]
            else:
                props["ModelPackageGroupName"] = self.model_package_group_name

        if self.model_package_group_description is not None:
            # Serialize model_package_group_description (handle intrinsic functions)
            if hasattr(self.model_package_group_description, 'to_dict'):
                props["ModelPackageGroupDescription"] = self.model_package_group_description.to_dict()
            elif isinstance(self.model_package_group_description, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelPackageGroupDescription'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_package_group_description
                ]
            else:
                props["ModelPackageGroupDescription"] = self.model_package_group_description

        if self.model_package_group_policy is not None:
            # Serialize model_package_group_policy (handle intrinsic functions)
            if hasattr(self.model_package_group_policy, 'to_dict'):
                props["ModelPackageGroupPolicy"] = self.model_package_group_policy.to_dict()
            elif isinstance(self.model_package_group_policy, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelPackageGroupPolicy'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_package_group_policy
                ]
            else:
                props["ModelPackageGroupPolicy"] = self.model_package_group_policy

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_model_package_group_arn(self) -> GetAtt:
        """Get the ModelPackageGroupArn attribute."""
        return self.get_att("ModelPackageGroupArn")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_model_package_group_status(self) -> GetAtt:
        """Get the ModelPackageGroupStatus attribute."""
        return self.get_att("ModelPackageGroupStatus")




@dataclass
class BatchTransformInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dataset_format: Optional[DatasetFormat] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_distribution_type: Optional[Union[str, ProcessingS3DataDistributionType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    start_time_offset: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    end_time_offset: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    probability_threshold_attribute: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inference_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_captured_destination_s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_input_mode: Optional[Union[str, ProcessingS3InputMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    probability_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.dataset_format is not None:
            if hasattr(self.dataset_format, 'to_dict'):
                props['DatasetFormat'] = self.dataset_format.to_dict()
            elif isinstance(self.dataset_format, list):
                props['DatasetFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dataset_format
                ]
            else:
                props['DatasetFormat'] = self.dataset_format

        if self.s3_data_distribution_type is not None:
            if hasattr(self.s3_data_distribution_type, 'to_dict'):
                props['S3DataDistributionType'] = self.s3_data_distribution_type.to_dict()
            elif isinstance(self.s3_data_distribution_type, list):
                props['S3DataDistributionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_distribution_type
                ]
            else:
                props['S3DataDistributionType'] = self.s3_data_distribution_type

        if self.start_time_offset is not None:
            if hasattr(self.start_time_offset, 'to_dict'):
                props['StartTimeOffset'] = self.start_time_offset.to_dict()
            elif isinstance(self.start_time_offset, list):
                props['StartTimeOffset'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.start_time_offset
                ]
            else:
                props['StartTimeOffset'] = self.start_time_offset

        if self.end_time_offset is not None:
            if hasattr(self.end_time_offset, 'to_dict'):
                props['EndTimeOffset'] = self.end_time_offset.to_dict()
            elif isinstance(self.end_time_offset, list):
                props['EndTimeOffset'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.end_time_offset
                ]
            else:
                props['EndTimeOffset'] = self.end_time_offset

        if self.probability_threshold_attribute is not None:
            if hasattr(self.probability_threshold_attribute, 'to_dict'):
                props['ProbabilityThresholdAttribute'] = self.probability_threshold_attribute.to_dict()
            elif isinstance(self.probability_threshold_attribute, list):
                props['ProbabilityThresholdAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.probability_threshold_attribute
                ]
            else:
                props['ProbabilityThresholdAttribute'] = self.probability_threshold_attribute

        if self.inference_attribute is not None:
            if hasattr(self.inference_attribute, 'to_dict'):
                props['InferenceAttribute'] = self.inference_attribute.to_dict()
            elif isinstance(self.inference_attribute, list):
                props['InferenceAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inference_attribute
                ]
            else:
                props['InferenceAttribute'] = self.inference_attribute

        if self.data_captured_destination_s3_uri is not None:
            if hasattr(self.data_captured_destination_s3_uri, 'to_dict'):
                props['DataCapturedDestinationS3Uri'] = self.data_captured_destination_s3_uri.to_dict()
            elif isinstance(self.data_captured_destination_s3_uri, list):
                props['DataCapturedDestinationS3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_captured_destination_s3_uri
                ]
            else:
                props['DataCapturedDestinationS3Uri'] = self.data_captured_destination_s3_uri

        if self.s3_input_mode is not None:
            if hasattr(self.s3_input_mode, 'to_dict'):
                props['S3InputMode'] = self.s3_input_mode.to_dict()
            elif isinstance(self.s3_input_mode, list):
                props['S3InputMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_input_mode
                ]
            else:
                props['S3InputMode'] = self.s3_input_mode

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.probability_attribute is not None:
            if hasattr(self.probability_attribute, 'to_dict'):
                props['ProbabilityAttribute'] = self.probability_attribute.to_dict()
            elif isinstance(self.probability_attribute, list):
                props['ProbabilityAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.probability_attribute
                ]
            else:
                props['ProbabilityAttribute'] = self.probability_attribute

        return props


@dataclass
class ClusterConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size_in_gb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_count is not None:
            if hasattr(self.instance_count, 'to_dict'):
                props['InstanceCount'] = self.instance_count.to_dict()
            elif isinstance(self.instance_count, list):
                props['InstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_count
                ]
            else:
                props['InstanceCount'] = self.instance_count

        if self.volume_size_in_gb is not None:
            if hasattr(self.volume_size_in_gb, 'to_dict'):
                props['VolumeSizeInGB'] = self.volume_size_in_gb.to_dict()
            elif isinstance(self.volume_size_in_gb, list):
                props['VolumeSizeInGB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size_in_gb
                ]
            else:
                props['VolumeSizeInGB'] = self.volume_size_in_gb

        if self.volume_kms_key_id is not None:
            if hasattr(self.volume_kms_key_id, 'to_dict'):
                props['VolumeKmsKeyId'] = self.volume_kms_key_id.to_dict()
            elif isinstance(self.volume_kms_key_id, list):
                props['VolumeKmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_kms_key_id
                ]
            else:
                props['VolumeKmsKeyId'] = self.volume_kms_key_id

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        return props


@dataclass
class ConstraintsResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        return props


@dataclass
class Csv:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    header: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.header is not None:
            if hasattr(self.header, 'to_dict'):
                props['Header'] = self.header.to_dict()
            elif isinstance(self.header, list):
                props['Header'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.header
                ]
            else:
                props['Header'] = self.header

        return props


@dataclass
class DatasetFormat:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parquet: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    csv: Optional[Csv] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    json: Optional[Json] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.parquet is not None:
            if hasattr(self.parquet, 'to_dict'):
                props['Parquet'] = self.parquet.to_dict()
            elif isinstance(self.parquet, list):
                props['Parquet'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parquet
                ]
            else:
                props['Parquet'] = self.parquet

        if self.csv is not None:
            if hasattr(self.csv, 'to_dict'):
                props['Csv'] = self.csv.to_dict()
            elif isinstance(self.csv, list):
                props['Csv'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.csv
                ]
            else:
                props['Csv'] = self.csv

        if self.json is not None:
            if hasattr(self.json, 'to_dict'):
                props['Json'] = self.json.to_dict()
            elif isinstance(self.json, list):
                props['Json'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.json
                ]
            else:
                props['Json'] = self.json

        return props


@dataclass
class EndpointInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_distribution_type: Optional[Union[str, ProcessingS3DataDistributionType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    start_time_offset: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    end_time_offset: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    probability_threshold_attribute: Optional[Union[float, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inference_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_input_mode: Optional[Union[str, ProcessingS3InputMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    probability_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_data_distribution_type is not None:
            if hasattr(self.s3_data_distribution_type, 'to_dict'):
                props['S3DataDistributionType'] = self.s3_data_distribution_type.to_dict()
            elif isinstance(self.s3_data_distribution_type, list):
                props['S3DataDistributionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_distribution_type
                ]
            else:
                props['S3DataDistributionType'] = self.s3_data_distribution_type

        if self.start_time_offset is not None:
            if hasattr(self.start_time_offset, 'to_dict'):
                props['StartTimeOffset'] = self.start_time_offset.to_dict()
            elif isinstance(self.start_time_offset, list):
                props['StartTimeOffset'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.start_time_offset
                ]
            else:
                props['StartTimeOffset'] = self.start_time_offset

        if self.end_time_offset is not None:
            if hasattr(self.end_time_offset, 'to_dict'):
                props['EndTimeOffset'] = self.end_time_offset.to_dict()
            elif isinstance(self.end_time_offset, list):
                props['EndTimeOffset'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.end_time_offset
                ]
            else:
                props['EndTimeOffset'] = self.end_time_offset

        if self.probability_threshold_attribute is not None:
            if hasattr(self.probability_threshold_attribute, 'to_dict'):
                props['ProbabilityThresholdAttribute'] = self.probability_threshold_attribute.to_dict()
            elif isinstance(self.probability_threshold_attribute, list):
                props['ProbabilityThresholdAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.probability_threshold_attribute
                ]
            else:
                props['ProbabilityThresholdAttribute'] = self.probability_threshold_attribute

        if self.endpoint_name is not None:
            if hasattr(self.endpoint_name, 'to_dict'):
                props['EndpointName'] = self.endpoint_name.to_dict()
            elif isinstance(self.endpoint_name, list):
                props['EndpointName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_name
                ]
            else:
                props['EndpointName'] = self.endpoint_name

        if self.inference_attribute is not None:
            if hasattr(self.inference_attribute, 'to_dict'):
                props['InferenceAttribute'] = self.inference_attribute.to_dict()
            elif isinstance(self.inference_attribute, list):
                props['InferenceAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inference_attribute
                ]
            else:
                props['InferenceAttribute'] = self.inference_attribute

        if self.s3_input_mode is not None:
            if hasattr(self.s3_input_mode, 'to_dict'):
                props['S3InputMode'] = self.s3_input_mode.to_dict()
            elif isinstance(self.s3_input_mode, list):
                props['S3InputMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_input_mode
                ]
            else:
                props['S3InputMode'] = self.s3_input_mode

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.probability_attribute is not None:
            if hasattr(self.probability_attribute, 'to_dict'):
                props['ProbabilityAttribute'] = self.probability_attribute.to_dict()
            elif isinstance(self.probability_attribute, list):
                props['ProbabilityAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.probability_attribute
                ]
            else:
                props['ProbabilityAttribute'] = self.probability_attribute

        return props


@dataclass
class Json:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    line: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.line is not None:
            if hasattr(self.line, 'to_dict'):
                props['Line'] = self.line.to_dict()
            elif isinstance(self.line, list):
                props['Line'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.line
                ]
            else:
                props['Line'] = self.line

        return props


@dataclass
class ModelQualityAppSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_entrypoint: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    problem_type: Optional[Union[str, MonitoringProblemType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    post_analytics_processor_source_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    record_preprocessor_source_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    environment: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_arguments: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.container_entrypoint is not None:
            if hasattr(self.container_entrypoint, 'to_dict'):
                props['ContainerEntrypoint'] = self.container_entrypoint.to_dict()
            elif isinstance(self.container_entrypoint, list):
                props['ContainerEntrypoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_entrypoint
                ]
            else:
                props['ContainerEntrypoint'] = self.container_entrypoint

        if self.problem_type is not None:
            if hasattr(self.problem_type, 'to_dict'):
                props['ProblemType'] = self.problem_type.to_dict()
            elif isinstance(self.problem_type, list):
                props['ProblemType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.problem_type
                ]
            else:
                props['ProblemType'] = self.problem_type

        if self.post_analytics_processor_source_uri is not None:
            if hasattr(self.post_analytics_processor_source_uri, 'to_dict'):
                props['PostAnalyticsProcessorSourceUri'] = self.post_analytics_processor_source_uri.to_dict()
            elif isinstance(self.post_analytics_processor_source_uri, list):
                props['PostAnalyticsProcessorSourceUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.post_analytics_processor_source_uri
                ]
            else:
                props['PostAnalyticsProcessorSourceUri'] = self.post_analytics_processor_source_uri

        if self.record_preprocessor_source_uri is not None:
            if hasattr(self.record_preprocessor_source_uri, 'to_dict'):
                props['RecordPreprocessorSourceUri'] = self.record_preprocessor_source_uri.to_dict()
            elif isinstance(self.record_preprocessor_source_uri, list):
                props['RecordPreprocessorSourceUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.record_preprocessor_source_uri
                ]
            else:
                props['RecordPreprocessorSourceUri'] = self.record_preprocessor_source_uri

        if self.environment is not None:
            if hasattr(self.environment, 'to_dict'):
                props['Environment'] = self.environment.to_dict()
            elif isinstance(self.environment, list):
                props['Environment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment
                ]
            else:
                props['Environment'] = self.environment

        if self.image_uri is not None:
            if hasattr(self.image_uri, 'to_dict'):
                props['ImageUri'] = self.image_uri.to_dict()
            elif isinstance(self.image_uri, list):
                props['ImageUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_uri
                ]
            else:
                props['ImageUri'] = self.image_uri

        if self.container_arguments is not None:
            if hasattr(self.container_arguments, 'to_dict'):
                props['ContainerArguments'] = self.container_arguments.to_dict()
            elif isinstance(self.container_arguments, list):
                props['ContainerArguments'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_arguments
                ]
            else:
                props['ContainerArguments'] = self.container_arguments

        return props


@dataclass
class ModelQualityBaselineConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    constraints_resource: Optional[ConstraintsResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baselining_job_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.constraints_resource is not None:
            if hasattr(self.constraints_resource, 'to_dict'):
                props['ConstraintsResource'] = self.constraints_resource.to_dict()
            elif isinstance(self.constraints_resource, list):
                props['ConstraintsResource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.constraints_resource
                ]
            else:
                props['ConstraintsResource'] = self.constraints_resource

        if self.baselining_job_name is not None:
            if hasattr(self.baselining_job_name, 'to_dict'):
                props['BaseliningJobName'] = self.baselining_job_name.to_dict()
            elif isinstance(self.baselining_job_name, list):
                props['BaseliningJobName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baselining_job_name
                ]
            else:
                props['BaseliningJobName'] = self.baselining_job_name

        return props


@dataclass
class ModelQualityJobInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ground_truth_s3_input: Optional[MonitoringGroundTruthS3Input] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    batch_transform_input: Optional[BatchTransformInput] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_input: Optional[EndpointInput] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ground_truth_s3_input is not None:
            if hasattr(self.ground_truth_s3_input, 'to_dict'):
                props['GroundTruthS3Input'] = self.ground_truth_s3_input.to_dict()
            elif isinstance(self.ground_truth_s3_input, list):
                props['GroundTruthS3Input'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ground_truth_s3_input
                ]
            else:
                props['GroundTruthS3Input'] = self.ground_truth_s3_input

        if self.batch_transform_input is not None:
            if hasattr(self.batch_transform_input, 'to_dict'):
                props['BatchTransformInput'] = self.batch_transform_input.to_dict()
            elif isinstance(self.batch_transform_input, list):
                props['BatchTransformInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.batch_transform_input
                ]
            else:
                props['BatchTransformInput'] = self.batch_transform_input

        if self.endpoint_input is not None:
            if hasattr(self.endpoint_input, 'to_dict'):
                props['EndpointInput'] = self.endpoint_input.to_dict()
            elif isinstance(self.endpoint_input, list):
                props['EndpointInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_input
                ]
            else:
                props['EndpointInput'] = self.endpoint_input

        return props


@dataclass
class MonitoringGroundTruthS3Input:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        return props


@dataclass
class MonitoringOutput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_output: Optional[S3Output] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_output is not None:
            if hasattr(self.s3_output, 'to_dict'):
                props['S3Output'] = self.s3_output.to_dict()
            elif isinstance(self.s3_output, list):
                props['S3Output'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_output
                ]
            else:
                props['S3Output'] = self.s3_output

        return props


@dataclass
class MonitoringOutputConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring_outputs: Optional[list[MonitoringOutput]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.monitoring_outputs is not None:
            if hasattr(self.monitoring_outputs, 'to_dict'):
                props['MonitoringOutputs'] = self.monitoring_outputs.to_dict()
            elif isinstance(self.monitoring_outputs, list):
                props['MonitoringOutputs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_outputs
                ]
            else:
                props['MonitoringOutputs'] = self.monitoring_outputs

        return props


@dataclass
class MonitoringResources:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cluster_config: Optional[ClusterConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cluster_config is not None:
            if hasattr(self.cluster_config, 'to_dict'):
                props['ClusterConfig'] = self.cluster_config.to_dict()
            elif isinstance(self.cluster_config, list):
                props['ClusterConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cluster_config
                ]
            else:
                props['ClusterConfig'] = self.cluster_config

        return props


@dataclass
class NetworkConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_network_isolation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_inter_container_traffic_encryption: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_config: Optional[VpcConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enable_network_isolation is not None:
            if hasattr(self.enable_network_isolation, 'to_dict'):
                props['EnableNetworkIsolation'] = self.enable_network_isolation.to_dict()
            elif isinstance(self.enable_network_isolation, list):
                props['EnableNetworkIsolation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_network_isolation
                ]
            else:
                props['EnableNetworkIsolation'] = self.enable_network_isolation

        if self.enable_inter_container_traffic_encryption is not None:
            if hasattr(self.enable_inter_container_traffic_encryption, 'to_dict'):
                props['EnableInterContainerTrafficEncryption'] = self.enable_inter_container_traffic_encryption.to_dict()
            elif isinstance(self.enable_inter_container_traffic_encryption, list):
                props['EnableInterContainerTrafficEncryption'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_inter_container_traffic_encryption
                ]
            else:
                props['EnableInterContainerTrafficEncryption'] = self.enable_inter_container_traffic_encryption

        if self.vpc_config is not None:
            if hasattr(self.vpc_config, 'to_dict'):
                props['VpcConfig'] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props['VpcConfig'] = self.vpc_config

        return props


@dataclass
class S3Output:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_upload_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.s3_upload_mode is not None:
            if hasattr(self.s3_upload_mode, 'to_dict'):
                props['S3UploadMode'] = self.s3_upload_mode.to_dict()
            elif isinstance(self.s3_upload_mode, list):
                props['S3UploadMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_upload_mode
                ]
            else:
                props['S3UploadMode'] = self.s3_upload_mode

        return props


@dataclass
class StoppingCondition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_runtime_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_runtime_in_seconds is not None:
            if hasattr(self.max_runtime_in_seconds, 'to_dict'):
                props['MaxRuntimeInSeconds'] = self.max_runtime_in_seconds.to_dict()
            elif isinstance(self.max_runtime_in_seconds, list):
                props['MaxRuntimeInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_runtime_in_seconds
                ]
            else:
                props['MaxRuntimeInSeconds'] = self.max_runtime_in_seconds

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnets: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnets is not None:
            if hasattr(self.subnets, 'to_dict'):
                props['Subnets'] = self.subnets.to_dict()
            elif isinstance(self.subnets, list):
                props['Subnets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnets
                ]
            else:
                props['Subnets'] = self.subnets

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class ModelQualityJobDefinition(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::ModelQualityJobDefinition"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_quality_app_specification: Optional[ModelQualityAppSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    endpoint_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    stopping_condition: Optional[StoppingCondition] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_quality_baseline_config: Optional[ModelQualityBaselineConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    job_definition_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_quality_job_input: Optional[ModelQualityJobInput] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    job_resources: Optional[MonitoringResources] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_config: Optional[NetworkConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    model_quality_job_output_config: Optional[MonitoringOutputConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.model_quality_app_specification is not None:
            # Serialize model_quality_app_specification (handle intrinsic functions)
            if hasattr(self.model_quality_app_specification, 'to_dict'):
                props["ModelQualityAppSpecification"] = self.model_quality_app_specification.to_dict()
            elif isinstance(self.model_quality_app_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelQualityAppSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_quality_app_specification
                ]
            else:
                props["ModelQualityAppSpecification"] = self.model_quality_app_specification

        if self.endpoint_name is not None:
            # Serialize endpoint_name (handle intrinsic functions)
            if hasattr(self.endpoint_name, 'to_dict'):
                props["EndpointName"] = self.endpoint_name.to_dict()
            elif isinstance(self.endpoint_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndpointName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_name
                ]
            else:
                props["EndpointName"] = self.endpoint_name

        if self.stopping_condition is not None:
            # Serialize stopping_condition (handle intrinsic functions)
            if hasattr(self.stopping_condition, 'to_dict'):
                props["StoppingCondition"] = self.stopping_condition.to_dict()
            elif isinstance(self.stopping_condition, list):
                # Serialize list items (may contain intrinsic functions)
                props['StoppingCondition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stopping_condition
                ]
            else:
                props["StoppingCondition"] = self.stopping_condition

        if self.model_quality_baseline_config is not None:
            # Serialize model_quality_baseline_config (handle intrinsic functions)
            if hasattr(self.model_quality_baseline_config, 'to_dict'):
                props["ModelQualityBaselineConfig"] = self.model_quality_baseline_config.to_dict()
            elif isinstance(self.model_quality_baseline_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelQualityBaselineConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_quality_baseline_config
                ]
            else:
                props["ModelQualityBaselineConfig"] = self.model_quality_baseline_config

        if self.job_definition_name is not None:
            # Serialize job_definition_name (handle intrinsic functions)
            if hasattr(self.job_definition_name, 'to_dict'):
                props["JobDefinitionName"] = self.job_definition_name.to_dict()
            elif isinstance(self.job_definition_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['JobDefinitionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.job_definition_name
                ]
            else:
                props["JobDefinitionName"] = self.job_definition_name

        if self.model_quality_job_input is not None:
            # Serialize model_quality_job_input (handle intrinsic functions)
            if hasattr(self.model_quality_job_input, 'to_dict'):
                props["ModelQualityJobInput"] = self.model_quality_job_input.to_dict()
            elif isinstance(self.model_quality_job_input, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelQualityJobInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_quality_job_input
                ]
            else:
                props["ModelQualityJobInput"] = self.model_quality_job_input

        if self.job_resources is not None:
            # Serialize job_resources (handle intrinsic functions)
            if hasattr(self.job_resources, 'to_dict'):
                props["JobResources"] = self.job_resources.to_dict()
            elif isinstance(self.job_resources, list):
                # Serialize list items (may contain intrinsic functions)
                props['JobResources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.job_resources
                ]
            else:
                props["JobResources"] = self.job_resources

        if self.network_config is not None:
            # Serialize network_config (handle intrinsic functions)
            if hasattr(self.network_config, 'to_dict'):
                props["NetworkConfig"] = self.network_config.to_dict()
            elif isinstance(self.network_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_config
                ]
            else:
                props["NetworkConfig"] = self.network_config

        if self.model_quality_job_output_config is not None:
            # Serialize model_quality_job_output_config (handle intrinsic functions)
            if hasattr(self.model_quality_job_output_config, 'to_dict'):
                props["ModelQualityJobOutputConfig"] = self.model_quality_job_output_config.to_dict()
            elif isinstance(self.model_quality_job_output_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ModelQualityJobOutputConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.model_quality_job_output_config
                ]
            else:
                props["ModelQualityJobOutputConfig"] = self.model_quality_job_output_config

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_job_definition_arn(self) -> GetAtt:
        """Get the JobDefinitionArn attribute."""
        return self.get_att("JobDefinitionArn")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")




@dataclass
class BaselineConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    statistics_resource: Optional[StatisticsResource] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    constraints_resource: Optional[ConstraintsResource] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.statistics_resource is not None:
            if hasattr(self.statistics_resource, 'to_dict'):
                props['StatisticsResource'] = self.statistics_resource.to_dict()
            elif isinstance(self.statistics_resource, list):
                props['StatisticsResource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.statistics_resource
                ]
            else:
                props['StatisticsResource'] = self.statistics_resource

        if self.constraints_resource is not None:
            if hasattr(self.constraints_resource, 'to_dict'):
                props['ConstraintsResource'] = self.constraints_resource.to_dict()
            elif isinstance(self.constraints_resource, list):
                props['ConstraintsResource'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.constraints_resource
                ]
            else:
                props['ConstraintsResource'] = self.constraints_resource

        return props


@dataclass
class BatchTransformInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dataset_format: Optional[DatasetFormat] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_distribution_type: Optional[Union[str, ProcessingS3DataDistributionType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_captured_destination_s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_input_mode: Optional[Union[str, ProcessingS3InputMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    exclude_features_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.dataset_format is not None:
            if hasattr(self.dataset_format, 'to_dict'):
                props['DatasetFormat'] = self.dataset_format.to_dict()
            elif isinstance(self.dataset_format, list):
                props['DatasetFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dataset_format
                ]
            else:
                props['DatasetFormat'] = self.dataset_format

        if self.s3_data_distribution_type is not None:
            if hasattr(self.s3_data_distribution_type, 'to_dict'):
                props['S3DataDistributionType'] = self.s3_data_distribution_type.to_dict()
            elif isinstance(self.s3_data_distribution_type, list):
                props['S3DataDistributionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_distribution_type
                ]
            else:
                props['S3DataDistributionType'] = self.s3_data_distribution_type

        if self.data_captured_destination_s3_uri is not None:
            if hasattr(self.data_captured_destination_s3_uri, 'to_dict'):
                props['DataCapturedDestinationS3Uri'] = self.data_captured_destination_s3_uri.to_dict()
            elif isinstance(self.data_captured_destination_s3_uri, list):
                props['DataCapturedDestinationS3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_captured_destination_s3_uri
                ]
            else:
                props['DataCapturedDestinationS3Uri'] = self.data_captured_destination_s3_uri

        if self.s3_input_mode is not None:
            if hasattr(self.s3_input_mode, 'to_dict'):
                props['S3InputMode'] = self.s3_input_mode.to_dict()
            elif isinstance(self.s3_input_mode, list):
                props['S3InputMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_input_mode
                ]
            else:
                props['S3InputMode'] = self.s3_input_mode

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.exclude_features_attribute is not None:
            if hasattr(self.exclude_features_attribute, 'to_dict'):
                props['ExcludeFeaturesAttribute'] = self.exclude_features_attribute.to_dict()
            elif isinstance(self.exclude_features_attribute, list):
                props['ExcludeFeaturesAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.exclude_features_attribute
                ]
            else:
                props['ExcludeFeaturesAttribute'] = self.exclude_features_attribute

        return props


@dataclass
class ClusterConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size_in_gb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_count is not None:
            if hasattr(self.instance_count, 'to_dict'):
                props['InstanceCount'] = self.instance_count.to_dict()
            elif isinstance(self.instance_count, list):
                props['InstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_count
                ]
            else:
                props['InstanceCount'] = self.instance_count

        if self.volume_size_in_gb is not None:
            if hasattr(self.volume_size_in_gb, 'to_dict'):
                props['VolumeSizeInGB'] = self.volume_size_in_gb.to_dict()
            elif isinstance(self.volume_size_in_gb, list):
                props['VolumeSizeInGB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size_in_gb
                ]
            else:
                props['VolumeSizeInGB'] = self.volume_size_in_gb

        if self.volume_kms_key_id is not None:
            if hasattr(self.volume_kms_key_id, 'to_dict'):
                props['VolumeKmsKeyId'] = self.volume_kms_key_id.to_dict()
            elif isinstance(self.volume_kms_key_id, list):
                props['VolumeKmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_kms_key_id
                ]
            else:
                props['VolumeKmsKeyId'] = self.volume_kms_key_id

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        return props


@dataclass
class ConstraintsResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        return props


@dataclass
class Csv:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    header: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.header is not None:
            if hasattr(self.header, 'to_dict'):
                props['Header'] = self.header.to_dict()
            elif isinstance(self.header, list):
                props['Header'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.header
                ]
            else:
                props['Header'] = self.header

        return props


@dataclass
class DatasetFormat:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parquet: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    csv: Optional[Csv] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    json: Optional[Json] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.parquet is not None:
            if hasattr(self.parquet, 'to_dict'):
                props['Parquet'] = self.parquet.to_dict()
            elif isinstance(self.parquet, list):
                props['Parquet'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parquet
                ]
            else:
                props['Parquet'] = self.parquet

        if self.csv is not None:
            if hasattr(self.csv, 'to_dict'):
                props['Csv'] = self.csv.to_dict()
            elif isinstance(self.csv, list):
                props['Csv'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.csv
                ]
            else:
                props['Csv'] = self.csv

        if self.json is not None:
            if hasattr(self.json, 'to_dict'):
                props['Json'] = self.json.to_dict()
            elif isinstance(self.json, list):
                props['Json'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.json
                ]
            else:
                props['Json'] = self.json

        return props


@dataclass
class EndpointInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_distribution_type: Optional[Union[str, ProcessingS3DataDistributionType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_input_mode: Optional[Union[str, ProcessingS3InputMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    exclude_features_attribute: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_data_distribution_type is not None:
            if hasattr(self.s3_data_distribution_type, 'to_dict'):
                props['S3DataDistributionType'] = self.s3_data_distribution_type.to_dict()
            elif isinstance(self.s3_data_distribution_type, list):
                props['S3DataDistributionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_distribution_type
                ]
            else:
                props['S3DataDistributionType'] = self.s3_data_distribution_type

        if self.endpoint_name is not None:
            if hasattr(self.endpoint_name, 'to_dict'):
                props['EndpointName'] = self.endpoint_name.to_dict()
            elif isinstance(self.endpoint_name, list):
                props['EndpointName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_name
                ]
            else:
                props['EndpointName'] = self.endpoint_name

        if self.s3_input_mode is not None:
            if hasattr(self.s3_input_mode, 'to_dict'):
                props['S3InputMode'] = self.s3_input_mode.to_dict()
            elif isinstance(self.s3_input_mode, list):
                props['S3InputMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_input_mode
                ]
            else:
                props['S3InputMode'] = self.s3_input_mode

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.exclude_features_attribute is not None:
            if hasattr(self.exclude_features_attribute, 'to_dict'):
                props['ExcludeFeaturesAttribute'] = self.exclude_features_attribute.to_dict()
            elif isinstance(self.exclude_features_attribute, list):
                props['ExcludeFeaturesAttribute'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.exclude_features_attribute
                ]
            else:
                props['ExcludeFeaturesAttribute'] = self.exclude_features_attribute

        return props


@dataclass
class Json:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    line: Optional[Union[bool, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.line is not None:
            if hasattr(self.line, 'to_dict'):
                props['Line'] = self.line.to_dict()
            elif isinstance(self.line, list):
                props['Line'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.line
                ]
            else:
                props['Line'] = self.line

        return props


@dataclass
class MonitoringAppSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_entrypoint: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    post_analytics_processor_source_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    record_preprocessor_source_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_arguments: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.container_entrypoint is not None:
            if hasattr(self.container_entrypoint, 'to_dict'):
                props['ContainerEntrypoint'] = self.container_entrypoint.to_dict()
            elif isinstance(self.container_entrypoint, list):
                props['ContainerEntrypoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_entrypoint
                ]
            else:
                props['ContainerEntrypoint'] = self.container_entrypoint

        if self.post_analytics_processor_source_uri is not None:
            if hasattr(self.post_analytics_processor_source_uri, 'to_dict'):
                props['PostAnalyticsProcessorSourceUri'] = self.post_analytics_processor_source_uri.to_dict()
            elif isinstance(self.post_analytics_processor_source_uri, list):
                props['PostAnalyticsProcessorSourceUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.post_analytics_processor_source_uri
                ]
            else:
                props['PostAnalyticsProcessorSourceUri'] = self.post_analytics_processor_source_uri

        if self.record_preprocessor_source_uri is not None:
            if hasattr(self.record_preprocessor_source_uri, 'to_dict'):
                props['RecordPreprocessorSourceUri'] = self.record_preprocessor_source_uri.to_dict()
            elif isinstance(self.record_preprocessor_source_uri, list):
                props['RecordPreprocessorSourceUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.record_preprocessor_source_uri
                ]
            else:
                props['RecordPreprocessorSourceUri'] = self.record_preprocessor_source_uri

        if self.image_uri is not None:
            if hasattr(self.image_uri, 'to_dict'):
                props['ImageUri'] = self.image_uri.to_dict()
            elif isinstance(self.image_uri, list):
                props['ImageUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_uri
                ]
            else:
                props['ImageUri'] = self.image_uri

        if self.container_arguments is not None:
            if hasattr(self.container_arguments, 'to_dict'):
                props['ContainerArguments'] = self.container_arguments.to_dict()
            elif isinstance(self.container_arguments, list):
                props['ContainerArguments'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_arguments
                ]
            else:
                props['ContainerArguments'] = self.container_arguments

        return props


@dataclass
class MonitoringExecutionSummary:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    scheduled_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring_schedule_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    processing_job_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    failure_reason: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    creation_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    last_modified_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring_execution_status: Optional[Union[str, ExecutionStatus, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.scheduled_time is not None:
            if hasattr(self.scheduled_time, 'to_dict'):
                props['ScheduledTime'] = self.scheduled_time.to_dict()
            elif isinstance(self.scheduled_time, list):
                props['ScheduledTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.scheduled_time
                ]
            else:
                props['ScheduledTime'] = self.scheduled_time

        if self.endpoint_name is not None:
            if hasattr(self.endpoint_name, 'to_dict'):
                props['EndpointName'] = self.endpoint_name.to_dict()
            elif isinstance(self.endpoint_name, list):
                props['EndpointName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_name
                ]
            else:
                props['EndpointName'] = self.endpoint_name

        if self.monitoring_schedule_name is not None:
            if hasattr(self.monitoring_schedule_name, 'to_dict'):
                props['MonitoringScheduleName'] = self.monitoring_schedule_name.to_dict()
            elif isinstance(self.monitoring_schedule_name, list):
                props['MonitoringScheduleName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_schedule_name
                ]
            else:
                props['MonitoringScheduleName'] = self.monitoring_schedule_name

        if self.processing_job_arn is not None:
            if hasattr(self.processing_job_arn, 'to_dict'):
                props['ProcessingJobArn'] = self.processing_job_arn.to_dict()
            elif isinstance(self.processing_job_arn, list):
                props['ProcessingJobArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.processing_job_arn
                ]
            else:
                props['ProcessingJobArn'] = self.processing_job_arn

        if self.failure_reason is not None:
            if hasattr(self.failure_reason, 'to_dict'):
                props['FailureReason'] = self.failure_reason.to_dict()
            elif isinstance(self.failure_reason, list):
                props['FailureReason'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.failure_reason
                ]
            else:
                props['FailureReason'] = self.failure_reason

        if self.creation_time is not None:
            if hasattr(self.creation_time, 'to_dict'):
                props['CreationTime'] = self.creation_time.to_dict()
            elif isinstance(self.creation_time, list):
                props['CreationTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.creation_time
                ]
            else:
                props['CreationTime'] = self.creation_time

        if self.last_modified_time is not None:
            if hasattr(self.last_modified_time, 'to_dict'):
                props['LastModifiedTime'] = self.last_modified_time.to_dict()
            elif isinstance(self.last_modified_time, list):
                props['LastModifiedTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.last_modified_time
                ]
            else:
                props['LastModifiedTime'] = self.last_modified_time

        if self.monitoring_execution_status is not None:
            if hasattr(self.monitoring_execution_status, 'to_dict'):
                props['MonitoringExecutionStatus'] = self.monitoring_execution_status.to_dict()
            elif isinstance(self.monitoring_execution_status, list):
                props['MonitoringExecutionStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_execution_status
                ]
            else:
                props['MonitoringExecutionStatus'] = self.monitoring_execution_status

        return props


@dataclass
class MonitoringInput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    batch_transform_input: Optional[BatchTransformInput] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    endpoint_input: Optional[EndpointInput] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.batch_transform_input is not None:
            if hasattr(self.batch_transform_input, 'to_dict'):
                props['BatchTransformInput'] = self.batch_transform_input.to_dict()
            elif isinstance(self.batch_transform_input, list):
                props['BatchTransformInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.batch_transform_input
                ]
            else:
                props['BatchTransformInput'] = self.batch_transform_input

        if self.endpoint_input is not None:
            if hasattr(self.endpoint_input, 'to_dict'):
                props['EndpointInput'] = self.endpoint_input.to_dict()
            elif isinstance(self.endpoint_input, list):
                props['EndpointInput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_input
                ]
            else:
                props['EndpointInput'] = self.endpoint_input

        return props


@dataclass
class MonitoringJobDefinition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring_inputs: Optional[list[MonitoringInput]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring_resources: Optional[MonitoringResources] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    baseline_config: Optional[BaselineConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    stopping_condition: Optional[StoppingCondition] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring_app_specification: Optional[MonitoringAppSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    network_config: Optional[NetworkConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    environment: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring_output_config: Optional[MonitoringOutputConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.monitoring_inputs is not None:
            if hasattr(self.monitoring_inputs, 'to_dict'):
                props['MonitoringInputs'] = self.monitoring_inputs.to_dict()
            elif isinstance(self.monitoring_inputs, list):
                props['MonitoringInputs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_inputs
                ]
            else:
                props['MonitoringInputs'] = self.monitoring_inputs

        if self.monitoring_resources is not None:
            if hasattr(self.monitoring_resources, 'to_dict'):
                props['MonitoringResources'] = self.monitoring_resources.to_dict()
            elif isinstance(self.monitoring_resources, list):
                props['MonitoringResources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_resources
                ]
            else:
                props['MonitoringResources'] = self.monitoring_resources

        if self.baseline_config is not None:
            if hasattr(self.baseline_config, 'to_dict'):
                props['BaselineConfig'] = self.baseline_config.to_dict()
            elif isinstance(self.baseline_config, list):
                props['BaselineConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.baseline_config
                ]
            else:
                props['BaselineConfig'] = self.baseline_config

        if self.stopping_condition is not None:
            if hasattr(self.stopping_condition, 'to_dict'):
                props['StoppingCondition'] = self.stopping_condition.to_dict()
            elif isinstance(self.stopping_condition, list):
                props['StoppingCondition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stopping_condition
                ]
            else:
                props['StoppingCondition'] = self.stopping_condition

        if self.monitoring_app_specification is not None:
            if hasattr(self.monitoring_app_specification, 'to_dict'):
                props['MonitoringAppSpecification'] = self.monitoring_app_specification.to_dict()
            elif isinstance(self.monitoring_app_specification, list):
                props['MonitoringAppSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_app_specification
                ]
            else:
                props['MonitoringAppSpecification'] = self.monitoring_app_specification

        if self.network_config is not None:
            if hasattr(self.network_config, 'to_dict'):
                props['NetworkConfig'] = self.network_config.to_dict()
            elif isinstance(self.network_config, list):
                props['NetworkConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_config
                ]
            else:
                props['NetworkConfig'] = self.network_config

        if self.environment is not None:
            if hasattr(self.environment, 'to_dict'):
                props['Environment'] = self.environment.to_dict()
            elif isinstance(self.environment, list):
                props['Environment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment
                ]
            else:
                props['Environment'] = self.environment

        if self.monitoring_output_config is not None:
            if hasattr(self.monitoring_output_config, 'to_dict'):
                props['MonitoringOutputConfig'] = self.monitoring_output_config.to_dict()
            elif isinstance(self.monitoring_output_config, list):
                props['MonitoringOutputConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_output_config
                ]
            else:
                props['MonitoringOutputConfig'] = self.monitoring_output_config

        if self.role_arn is not None:
            if hasattr(self.role_arn, 'to_dict'):
                props['RoleArn'] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props['RoleArn'] = self.role_arn

        return props


@dataclass
class MonitoringOutput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_output: Optional[S3Output] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_output is not None:
            if hasattr(self.s3_output, 'to_dict'):
                props['S3Output'] = self.s3_output.to_dict()
            elif isinstance(self.s3_output, list):
                props['S3Output'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_output
                ]
            else:
                props['S3Output'] = self.s3_output

        return props


@dataclass
class MonitoringOutputConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring_outputs: Optional[list[MonitoringOutput]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.monitoring_outputs is not None:
            if hasattr(self.monitoring_outputs, 'to_dict'):
                props['MonitoringOutputs'] = self.monitoring_outputs.to_dict()
            elif isinstance(self.monitoring_outputs, list):
                props['MonitoringOutputs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_outputs
                ]
            else:
                props['MonitoringOutputs'] = self.monitoring_outputs

        return props


@dataclass
class MonitoringResources:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cluster_config: Optional[ClusterConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cluster_config is not None:
            if hasattr(self.cluster_config, 'to_dict'):
                props['ClusterConfig'] = self.cluster_config.to_dict()
            elif isinstance(self.cluster_config, list):
                props['ClusterConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cluster_config
                ]
            else:
                props['ClusterConfig'] = self.cluster_config

        return props


@dataclass
class MonitoringScheduleConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    schedule_config: Optional[ScheduleConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring_job_definition: Optional[MonitoringJobDefinition] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring_job_definition_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    monitoring_type: Optional[Union[str, MonitoringType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.schedule_config is not None:
            if hasattr(self.schedule_config, 'to_dict'):
                props['ScheduleConfig'] = self.schedule_config.to_dict()
            elif isinstance(self.schedule_config, list):
                props['ScheduleConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schedule_config
                ]
            else:
                props['ScheduleConfig'] = self.schedule_config

        if self.monitoring_job_definition is not None:
            if hasattr(self.monitoring_job_definition, 'to_dict'):
                props['MonitoringJobDefinition'] = self.monitoring_job_definition.to_dict()
            elif isinstance(self.monitoring_job_definition, list):
                props['MonitoringJobDefinition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_job_definition
                ]
            else:
                props['MonitoringJobDefinition'] = self.monitoring_job_definition

        if self.monitoring_job_definition_name is not None:
            if hasattr(self.monitoring_job_definition_name, 'to_dict'):
                props['MonitoringJobDefinitionName'] = self.monitoring_job_definition_name.to_dict()
            elif isinstance(self.monitoring_job_definition_name, list):
                props['MonitoringJobDefinitionName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_job_definition_name
                ]
            else:
                props['MonitoringJobDefinitionName'] = self.monitoring_job_definition_name

        if self.monitoring_type is not None:
            if hasattr(self.monitoring_type, 'to_dict'):
                props['MonitoringType'] = self.monitoring_type.to_dict()
            elif isinstance(self.monitoring_type, list):
                props['MonitoringType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_type
                ]
            else:
                props['MonitoringType'] = self.monitoring_type

        return props


@dataclass
class NetworkConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_network_isolation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_inter_container_traffic_encryption: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_config: Optional[VpcConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enable_network_isolation is not None:
            if hasattr(self.enable_network_isolation, 'to_dict'):
                props['EnableNetworkIsolation'] = self.enable_network_isolation.to_dict()
            elif isinstance(self.enable_network_isolation, list):
                props['EnableNetworkIsolation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_network_isolation
                ]
            else:
                props['EnableNetworkIsolation'] = self.enable_network_isolation

        if self.enable_inter_container_traffic_encryption is not None:
            if hasattr(self.enable_inter_container_traffic_encryption, 'to_dict'):
                props['EnableInterContainerTrafficEncryption'] = self.enable_inter_container_traffic_encryption.to_dict()
            elif isinstance(self.enable_inter_container_traffic_encryption, list):
                props['EnableInterContainerTrafficEncryption'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_inter_container_traffic_encryption
                ]
            else:
                props['EnableInterContainerTrafficEncryption'] = self.enable_inter_container_traffic_encryption

        if self.vpc_config is not None:
            if hasattr(self.vpc_config, 'to_dict'):
                props['VpcConfig'] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props['VpcConfig'] = self.vpc_config

        return props


@dataclass
class S3Output:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_upload_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.s3_upload_mode is not None:
            if hasattr(self.s3_upload_mode, 'to_dict'):
                props['S3UploadMode'] = self.s3_upload_mode.to_dict()
            elif isinstance(self.s3_upload_mode, list):
                props['S3UploadMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_upload_mode
                ]
            else:
                props['S3UploadMode'] = self.s3_upload_mode

        return props


@dataclass
class ScheduleConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    schedule_expression: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_analysis_start_time: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_analysis_end_time: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.schedule_expression is not None:
            if hasattr(self.schedule_expression, 'to_dict'):
                props['ScheduleExpression'] = self.schedule_expression.to_dict()
            elif isinstance(self.schedule_expression, list):
                props['ScheduleExpression'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.schedule_expression
                ]
            else:
                props['ScheduleExpression'] = self.schedule_expression

        if self.data_analysis_start_time is not None:
            if hasattr(self.data_analysis_start_time, 'to_dict'):
                props['DataAnalysisStartTime'] = self.data_analysis_start_time.to_dict()
            elif isinstance(self.data_analysis_start_time, list):
                props['DataAnalysisStartTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_analysis_start_time
                ]
            else:
                props['DataAnalysisStartTime'] = self.data_analysis_start_time

        if self.data_analysis_end_time is not None:
            if hasattr(self.data_analysis_end_time, 'to_dict'):
                props['DataAnalysisEndTime'] = self.data_analysis_end_time.to_dict()
            elif isinstance(self.data_analysis_end_time, list):
                props['DataAnalysisEndTime'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_analysis_end_time
                ]
            else:
                props['DataAnalysisEndTime'] = self.data_analysis_end_time

        return props


@dataclass
class StatisticsResource:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        return props


@dataclass
class StoppingCondition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_runtime_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_runtime_in_seconds is not None:
            if hasattr(self.max_runtime_in_seconds, 'to_dict'):
                props['MaxRuntimeInSeconds'] = self.max_runtime_in_seconds.to_dict()
            elif isinstance(self.max_runtime_in_seconds, list):
                props['MaxRuntimeInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_runtime_in_seconds
                ]
            else:
                props['MaxRuntimeInSeconds'] = self.max_runtime_in_seconds

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnets: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnets is not None:
            if hasattr(self.subnets, 'to_dict'):
                props['Subnets'] = self.subnets.to_dict()
            elif isinstance(self.subnets, list):
                props['Subnets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnets
                ]
            else:
                props['Subnets'] = self.subnets

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class MonitoringSchedule(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::MonitoringSchedule"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    monitoring_schedule_status: Optional[Union[str, ScheduleStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    monitoring_schedule_config: Optional[MonitoringScheduleConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    monitoring_schedule_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    endpoint_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    failure_reason: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    last_monitoring_execution_summary: Optional[MonitoringExecutionSummary] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.monitoring_schedule_status is not None:
            # Serialize monitoring_schedule_status (handle intrinsic functions)
            if hasattr(self.monitoring_schedule_status, 'to_dict'):
                props["MonitoringScheduleStatus"] = self.monitoring_schedule_status.to_dict()
            elif isinstance(self.monitoring_schedule_status, list):
                # Serialize list items (may contain intrinsic functions)
                props['MonitoringScheduleStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_schedule_status
                ]
            else:
                props["MonitoringScheduleStatus"] = self.monitoring_schedule_status

        if self.monitoring_schedule_config is not None:
            # Serialize monitoring_schedule_config (handle intrinsic functions)
            if hasattr(self.monitoring_schedule_config, 'to_dict'):
                props["MonitoringScheduleConfig"] = self.monitoring_schedule_config.to_dict()
            elif isinstance(self.monitoring_schedule_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['MonitoringScheduleConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_schedule_config
                ]
            else:
                props["MonitoringScheduleConfig"] = self.monitoring_schedule_config

        if self.monitoring_schedule_name is not None:
            # Serialize monitoring_schedule_name (handle intrinsic functions)
            if hasattr(self.monitoring_schedule_name, 'to_dict'):
                props["MonitoringScheduleName"] = self.monitoring_schedule_name.to_dict()
            elif isinstance(self.monitoring_schedule_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['MonitoringScheduleName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.monitoring_schedule_name
                ]
            else:
                props["MonitoringScheduleName"] = self.monitoring_schedule_name

        if self.endpoint_name is not None:
            # Serialize endpoint_name (handle intrinsic functions)
            if hasattr(self.endpoint_name, 'to_dict'):
                props["EndpointName"] = self.endpoint_name.to_dict()
            elif isinstance(self.endpoint_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['EndpointName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.endpoint_name
                ]
            else:
                props["EndpointName"] = self.endpoint_name

        if self.failure_reason is not None:
            # Serialize failure_reason (handle intrinsic functions)
            if hasattr(self.failure_reason, 'to_dict'):
                props["FailureReason"] = self.failure_reason.to_dict()
            elif isinstance(self.failure_reason, list):
                # Serialize list items (may contain intrinsic functions)
                props['FailureReason'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.failure_reason
                ]
            else:
                props["FailureReason"] = self.failure_reason

        if self.last_monitoring_execution_summary is not None:
            # Serialize last_monitoring_execution_summary (handle intrinsic functions)
            if hasattr(self.last_monitoring_execution_summary, 'to_dict'):
                props["LastMonitoringExecutionSummary"] = self.last_monitoring_execution_summary.to_dict()
            elif isinstance(self.last_monitoring_execution_summary, list):
                # Serialize list items (may contain intrinsic functions)
                props['LastMonitoringExecutionSummary'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.last_monitoring_execution_summary
                ]
            else:
                props["LastMonitoringExecutionSummary"] = self.last_monitoring_execution_summary

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_monitoring_schedule_arn(self) -> GetAtt:
        """Get the MonitoringScheduleArn attribute."""
        return self.get_att("MonitoringScheduleArn")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_last_modified_time(self) -> GetAtt:
        """Get the LastModifiedTime attribute."""
        return self.get_att("LastModifiedTime")




@dataclass
class InstanceMetadataServiceConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    minimum_instance_metadata_service_version: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.minimum_instance_metadata_service_version is not None:
            if hasattr(self.minimum_instance_metadata_service_version, 'to_dict'):
                props['MinimumInstanceMetadataServiceVersion'] = self.minimum_instance_metadata_service_version.to_dict()
            elif isinstance(self.minimum_instance_metadata_service_version, list):
                props['MinimumInstanceMetadataServiceVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.minimum_instance_metadata_service_version
                ]
            else:
                props['MinimumInstanceMetadataServiceVersion'] = self.minimum_instance_metadata_service_version

        return props


@dataclass
class NotebookInstance(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::NotebookInstance"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    volume_size_in_gb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    additional_code_repositories: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    default_code_repository: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    direct_internet_access: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    platform_identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    accelerator_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    subnet_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    security_group_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_metadata_service_configuration: Optional[InstanceMetadataServiceConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    root_access: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    notebook_instance_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    lifecycle_config_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_id is not None:
            # Serialize kms_key_id (handle intrinsic functions)
            if hasattr(self.kms_key_id, 'to_dict'):
                props["KmsKeyId"] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props["KmsKeyId"] = self.kms_key_id

        if self.volume_size_in_gb is not None:
            # Serialize volume_size_in_gb (handle intrinsic functions)
            if hasattr(self.volume_size_in_gb, 'to_dict'):
                props["VolumeSizeInGB"] = self.volume_size_in_gb.to_dict()
            elif isinstance(self.volume_size_in_gb, list):
                # Serialize list items (may contain intrinsic functions)
                props['VolumeSizeInGB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size_in_gb
                ]
            else:
                props["VolumeSizeInGB"] = self.volume_size_in_gb

        if self.additional_code_repositories is not None:
            # Serialize additional_code_repositories (handle intrinsic functions)
            if hasattr(self.additional_code_repositories, 'to_dict'):
                props["AdditionalCodeRepositories"] = self.additional_code_repositories.to_dict()
            elif isinstance(self.additional_code_repositories, list):
                # Serialize list items (may contain intrinsic functions)
                props['AdditionalCodeRepositories'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.additional_code_repositories
                ]
            else:
                props["AdditionalCodeRepositories"] = self.additional_code_repositories

        if self.default_code_repository is not None:
            # Serialize default_code_repository (handle intrinsic functions)
            if hasattr(self.default_code_repository, 'to_dict'):
                props["DefaultCodeRepository"] = self.default_code_repository.to_dict()
            elif isinstance(self.default_code_repository, list):
                # Serialize list items (may contain intrinsic functions)
                props['DefaultCodeRepository'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_code_repository
                ]
            else:
                props["DefaultCodeRepository"] = self.default_code_repository

        if self.direct_internet_access is not None:
            # Serialize direct_internet_access (handle intrinsic functions)
            if hasattr(self.direct_internet_access, 'to_dict'):
                props["DirectInternetAccess"] = self.direct_internet_access.to_dict()
            elif isinstance(self.direct_internet_access, list):
                # Serialize list items (may contain intrinsic functions)
                props['DirectInternetAccess'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.direct_internet_access
                ]
            else:
                props["DirectInternetAccess"] = self.direct_internet_access

        if self.platform_identifier is not None:
            # Serialize platform_identifier (handle intrinsic functions)
            if hasattr(self.platform_identifier, 'to_dict'):
                props["PlatformIdentifier"] = self.platform_identifier.to_dict()
            elif isinstance(self.platform_identifier, list):
                # Serialize list items (may contain intrinsic functions)
                props['PlatformIdentifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.platform_identifier
                ]
            else:
                props["PlatformIdentifier"] = self.platform_identifier

        if self.accelerator_types is not None:
            # Serialize accelerator_types (handle intrinsic functions)
            if hasattr(self.accelerator_types, 'to_dict'):
                props["AcceleratorTypes"] = self.accelerator_types.to_dict()
            elif isinstance(self.accelerator_types, list):
                # Serialize list items (may contain intrinsic functions)
                props['AcceleratorTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.accelerator_types
                ]
            else:
                props["AcceleratorTypes"] = self.accelerator_types

        if self.subnet_id is not None:
            # Serialize subnet_id (handle intrinsic functions)
            if hasattr(self.subnet_id, 'to_dict'):
                props["SubnetId"] = self.subnet_id.to_dict()
            elif isinstance(self.subnet_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['SubnetId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnet_id
                ]
            else:
                props["SubnetId"] = self.subnet_id

        if self.security_group_ids is not None:
            # Serialize security_group_ids (handle intrinsic functions)
            if hasattr(self.security_group_ids, 'to_dict'):
                props["SecurityGroupIds"] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                # Serialize list items (may contain intrinsic functions)
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props["SecurityGroupIds"] = self.security_group_ids

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        if self.instance_metadata_service_configuration is not None:
            # Serialize instance_metadata_service_configuration (handle intrinsic functions)
            if hasattr(self.instance_metadata_service_configuration, 'to_dict'):
                props["InstanceMetadataServiceConfiguration"] = self.instance_metadata_service_configuration.to_dict()
            elif isinstance(self.instance_metadata_service_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceMetadataServiceConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_metadata_service_configuration
                ]
            else:
                props["InstanceMetadataServiceConfiguration"] = self.instance_metadata_service_configuration

        if self.root_access is not None:
            # Serialize root_access (handle intrinsic functions)
            if hasattr(self.root_access, 'to_dict'):
                props["RootAccess"] = self.root_access.to_dict()
            elif isinstance(self.root_access, list):
                # Serialize list items (may contain intrinsic functions)
                props['RootAccess'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.root_access
                ]
            else:
                props["RootAccess"] = self.root_access

        if self.notebook_instance_name is not None:
            # Serialize notebook_instance_name (handle intrinsic functions)
            if hasattr(self.notebook_instance_name, 'to_dict'):
                props["NotebookInstanceName"] = self.notebook_instance_name.to_dict()
            elif isinstance(self.notebook_instance_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['NotebookInstanceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notebook_instance_name
                ]
            else:
                props["NotebookInstanceName"] = self.notebook_instance_name

        if self.instance_type is not None:
            # Serialize instance_type (handle intrinsic functions)
            if hasattr(self.instance_type, 'to_dict'):
                props["InstanceType"] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props["InstanceType"] = self.instance_type

        if self.lifecycle_config_name is not None:
            # Serialize lifecycle_config_name (handle intrinsic functions)
            if hasattr(self.lifecycle_config_name, 'to_dict'):
                props["LifecycleConfigName"] = self.lifecycle_config_name.to_dict()
            elif isinstance(self.lifecycle_config_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['LifecycleConfigName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_config_name
                ]
            else:
                props["LifecycleConfigName"] = self.lifecycle_config_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_notebook_instance_name(self) -> GetAtt:
        """Get the NotebookInstanceName attribute."""
        return self.get_att("NotebookInstanceName")




@dataclass
class NotebookInstanceLifecycleHook:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    content: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.content is not None:
            if hasattr(self.content, 'to_dict'):
                props['Content'] = self.content.to_dict()
            elif isinstance(self.content, list):
                props['Content'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.content
                ]
            else:
                props['Content'] = self.content

        return props


@dataclass
class NotebookInstanceLifecycleConfig(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::NotebookInstanceLifecycleConfig"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    on_start: Optional[list[NotebookInstanceLifecycleHook]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    notebook_instance_lifecycle_config_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    on_create: Optional[list[NotebookInstanceLifecycleHook]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.on_start is not None:
            # Serialize on_start (handle intrinsic functions)
            if hasattr(self.on_start, 'to_dict'):
                props["OnStart"] = self.on_start.to_dict()
            elif isinstance(self.on_start, list):
                # Serialize list items (may contain intrinsic functions)
                props['OnStart'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_start
                ]
            else:
                props["OnStart"] = self.on_start

        if self.notebook_instance_lifecycle_config_name is not None:
            # Serialize notebook_instance_lifecycle_config_name (handle intrinsic functions)
            if hasattr(self.notebook_instance_lifecycle_config_name, 'to_dict'):
                props["NotebookInstanceLifecycleConfigName"] = self.notebook_instance_lifecycle_config_name.to_dict()
            elif isinstance(self.notebook_instance_lifecycle_config_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['NotebookInstanceLifecycleConfigName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notebook_instance_lifecycle_config_name
                ]
            else:
                props["NotebookInstanceLifecycleConfigName"] = self.notebook_instance_lifecycle_config_name

        if self.on_create is not None:
            # Serialize on_create (handle intrinsic functions)
            if hasattr(self.on_create, 'to_dict'):
                props["OnCreate"] = self.on_create.to_dict()
            elif isinstance(self.on_create, list):
                # Serialize list items (may contain intrinsic functions)
                props['OnCreate'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.on_create
                ]
            else:
                props["OnCreate"] = self.on_create

        return props

    @property
    def attr_notebook_instance_lifecycle_config_name(self) -> GetAtt:
        """Get the NotebookInstanceLifecycleConfigName attribute."""
        return self.get_att("NotebookInstanceLifecycleConfigName")




@dataclass
class PartnerAppConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    admin_users: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    arguments: Optional[dict[str, str]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.admin_users is not None:
            if hasattr(self.admin_users, 'to_dict'):
                props['AdminUsers'] = self.admin_users.to_dict()
            elif isinstance(self.admin_users, list):
                props['AdminUsers'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.admin_users
                ]
            else:
                props['AdminUsers'] = self.admin_users

        if self.arguments is not None:
            if hasattr(self.arguments, 'to_dict'):
                props['Arguments'] = self.arguments.to_dict()
            elif isinstance(self.arguments, list):
                props['Arguments'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.arguments
                ]
            else:
                props['Arguments'] = self.arguments

        return props


@dataclass
class PartnerAppMaintenanceConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maintenance_window_start: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.maintenance_window_start is not None:
            if hasattr(self.maintenance_window_start, 'to_dict'):
                props['MaintenanceWindowStart'] = self.maintenance_window_start.to_dict()
            elif isinstance(self.maintenance_window_start, list):
                props['MaintenanceWindowStart'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maintenance_window_start
                ]
            else:
                props['MaintenanceWindowStart'] = self.maintenance_window_start

        return props


@dataclass
class PartnerApp(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::PartnerApp"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    app_version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    execution_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_iam_session_based_identity: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    enable_auto_minor_version_upgrade: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    application_config: Optional[PartnerAppConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    auth_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    maintenance_config: Optional[PartnerAppMaintenanceConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.app_version is not None:
            # Serialize app_version (handle intrinsic functions)
            if hasattr(self.app_version, 'to_dict'):
                props["AppVersion"] = self.app_version.to_dict()
            elif isinstance(self.app_version, list):
                # Serialize list items (may contain intrinsic functions)
                props['AppVersion'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_version
                ]
            else:
                props["AppVersion"] = self.app_version

        if self.execution_role_arn is not None:
            # Serialize execution_role_arn (handle intrinsic functions)
            if hasattr(self.execution_role_arn, 'to_dict'):
                props["ExecutionRoleArn"] = self.execution_role_arn.to_dict()
            elif isinstance(self.execution_role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExecutionRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role_arn
                ]
            else:
                props["ExecutionRoleArn"] = self.execution_role_arn

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.kms_key_id is not None:
            # Serialize kms_key_id (handle intrinsic functions)
            if hasattr(self.kms_key_id, 'to_dict'):
                props["KmsKeyId"] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props["KmsKeyId"] = self.kms_key_id

        if self.enable_iam_session_based_identity is not None:
            # Serialize enable_iam_session_based_identity (handle intrinsic functions)
            if hasattr(self.enable_iam_session_based_identity, 'to_dict'):
                props["EnableIamSessionBasedIdentity"] = self.enable_iam_session_based_identity.to_dict()
            elif isinstance(self.enable_iam_session_based_identity, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableIamSessionBasedIdentity'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_iam_session_based_identity
                ]
            else:
                props["EnableIamSessionBasedIdentity"] = self.enable_iam_session_based_identity

        if self.tier is not None:
            # Serialize tier (handle intrinsic functions)
            if hasattr(self.tier, 'to_dict'):
                props["Tier"] = self.tier.to_dict()
            elif isinstance(self.tier, list):
                # Serialize list items (may contain intrinsic functions)
                props['Tier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.tier
                ]
            else:
                props["Tier"] = self.tier

        if self.enable_auto_minor_version_upgrade is not None:
            # Serialize enable_auto_minor_version_upgrade (handle intrinsic functions)
            if hasattr(self.enable_auto_minor_version_upgrade, 'to_dict'):
                props["EnableAutoMinorVersionUpgrade"] = self.enable_auto_minor_version_upgrade.to_dict()
            elif isinstance(self.enable_auto_minor_version_upgrade, list):
                # Serialize list items (may contain intrinsic functions)
                props['EnableAutoMinorVersionUpgrade'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_auto_minor_version_upgrade
                ]
            else:
                props["EnableAutoMinorVersionUpgrade"] = self.enable_auto_minor_version_upgrade

        if self.application_config is not None:
            # Serialize application_config (handle intrinsic functions)
            if hasattr(self.application_config, 'to_dict'):
                props["ApplicationConfig"] = self.application_config.to_dict()
            elif isinstance(self.application_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ApplicationConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.application_config
                ]
            else:
                props["ApplicationConfig"] = self.application_config

        if self.auth_type is not None:
            # Serialize auth_type (handle intrinsic functions)
            if hasattr(self.auth_type, 'to_dict'):
                props["AuthType"] = self.auth_type.to_dict()
            elif isinstance(self.auth_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['AuthType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auth_type
                ]
            else:
                props["AuthType"] = self.auth_type

        if self.maintenance_config is not None:
            # Serialize maintenance_config (handle intrinsic functions)
            if hasattr(self.maintenance_config, 'to_dict'):
                props["MaintenanceConfig"] = self.maintenance_config.to_dict()
            elif isinstance(self.maintenance_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['MaintenanceConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maintenance_config
                ]
            else:
                props["MaintenanceConfig"] = self.maintenance_config

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.name is not None:
            # Serialize name (handle intrinsic functions)
            if hasattr(self.name, 'to_dict'):
                props["Name"] = self.name.to_dict()
            elif isinstance(self.name, list):
                # Serialize list items (may contain intrinsic functions)
                props['Name'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.name
                ]
            else:
                props["Name"] = self.name

        return props

    @property
    def attr_current_version_eol_date(self) -> GetAtt:
        """Get the CurrentVersionEolDate attribute."""
        return self.get_att("CurrentVersionEolDate")

    @property
    def attr_base_url(self) -> GetAtt:
        """Get the BaseUrl attribute."""
        return self.get_att("BaseUrl")

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")




@dataclass
class ParallelismConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_parallel_execution_steps: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_parallel_execution_steps is not None:
            if hasattr(self.max_parallel_execution_steps, 'to_dict'):
                props['MaxParallelExecutionSteps'] = self.max_parallel_execution_steps.to_dict()
            elif isinstance(self.max_parallel_execution_steps, list):
                props['MaxParallelExecutionSteps'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_parallel_execution_steps
                ]
            else:
                props['MaxParallelExecutionSteps'] = self.max_parallel_execution_steps

        return props


@dataclass
class PipelineDefinition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    pipeline_definition_body: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    pipeline_definition_s3_location: Optional[S3Location] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.pipeline_definition_body is not None:
            if hasattr(self.pipeline_definition_body, 'to_dict'):
                props['PipelineDefinitionBody'] = self.pipeline_definition_body.to_dict()
            elif isinstance(self.pipeline_definition_body, list):
                props['PipelineDefinitionBody'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pipeline_definition_body
                ]
            else:
                props['PipelineDefinitionBody'] = self.pipeline_definition_body

        if self.pipeline_definition_s3_location is not None:
            if hasattr(self.pipeline_definition_s3_location, 'to_dict'):
                props['PipelineDefinitionS3Location'] = self.pipeline_definition_s3_location.to_dict()
            elif isinstance(self.pipeline_definition_s3_location, list):
                props['PipelineDefinitionS3Location'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pipeline_definition_s3_location
                ]
            else:
                props['PipelineDefinitionS3Location'] = self.pipeline_definition_s3_location

        return props


@dataclass
class S3Location:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    bucket: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    e_tag: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.bucket is not None:
            if hasattr(self.bucket, 'to_dict'):
                props['Bucket'] = self.bucket.to_dict()
            elif isinstance(self.bucket, list):
                props['Bucket'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.bucket
                ]
            else:
                props['Bucket'] = self.bucket

        if self.version is not None:
            if hasattr(self.version, 'to_dict'):
                props['Version'] = self.version.to_dict()
            elif isinstance(self.version, list):
                props['Version'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version
                ]
            else:
                props['Version'] = self.version

        if self.e_tag is not None:
            if hasattr(self.e_tag, 'to_dict'):
                props['ETag'] = self.e_tag.to_dict()
            elif isinstance(self.e_tag, list):
                props['ETag'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.e_tag
                ]
            else:
                props['ETag'] = self.e_tag

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class Pipeline(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::Pipeline"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    pipeline_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    parallelism_configuration: Optional[ParallelismConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    pipeline_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    pipeline_display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    pipeline_definition: Optional[PipelineDefinition] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.pipeline_name is not None:
            # Serialize pipeline_name (handle intrinsic functions)
            if hasattr(self.pipeline_name, 'to_dict'):
                props["PipelineName"] = self.pipeline_name.to_dict()
            elif isinstance(self.pipeline_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['PipelineName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pipeline_name
                ]
            else:
                props["PipelineName"] = self.pipeline_name

        if self.parallelism_configuration is not None:
            # Serialize parallelism_configuration (handle intrinsic functions)
            if hasattr(self.parallelism_configuration, 'to_dict'):
                props["ParallelismConfiguration"] = self.parallelism_configuration.to_dict()
            elif isinstance(self.parallelism_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['ParallelismConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parallelism_configuration
                ]
            else:
                props["ParallelismConfiguration"] = self.parallelism_configuration

        if self.pipeline_description is not None:
            # Serialize pipeline_description (handle intrinsic functions)
            if hasattr(self.pipeline_description, 'to_dict'):
                props["PipelineDescription"] = self.pipeline_description.to_dict()
            elif isinstance(self.pipeline_description, list):
                # Serialize list items (may contain intrinsic functions)
                props['PipelineDescription'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pipeline_description
                ]
            else:
                props["PipelineDescription"] = self.pipeline_description

        if self.pipeline_display_name is not None:
            # Serialize pipeline_display_name (handle intrinsic functions)
            if hasattr(self.pipeline_display_name, 'to_dict'):
                props["PipelineDisplayName"] = self.pipeline_display_name.to_dict()
            elif isinstance(self.pipeline_display_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['PipelineDisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pipeline_display_name
                ]
            else:
                props["PipelineDisplayName"] = self.pipeline_display_name

        if self.pipeline_definition is not None:
            # Serialize pipeline_definition (handle intrinsic functions)
            if hasattr(self.pipeline_definition, 'to_dict'):
                props["PipelineDefinition"] = self.pipeline_definition.to_dict()
            elif isinstance(self.pipeline_definition, list):
                # Serialize list items (may contain intrinsic functions)
                props['PipelineDefinition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.pipeline_definition
                ]
            else:
                props["PipelineDefinition"] = self.pipeline_definition

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props



@dataclass
class AppSpecification:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_entrypoint: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    container_arguments: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.container_entrypoint is not None:
            if hasattr(self.container_entrypoint, 'to_dict'):
                props['ContainerEntrypoint'] = self.container_entrypoint.to_dict()
            elif isinstance(self.container_entrypoint, list):
                props['ContainerEntrypoint'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_entrypoint
                ]
            else:
                props['ContainerEntrypoint'] = self.container_entrypoint

        if self.image_uri is not None:
            if hasattr(self.image_uri, 'to_dict'):
                props['ImageUri'] = self.image_uri.to_dict()
            elif isinstance(self.image_uri, list):
                props['ImageUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_uri
                ]
            else:
                props['ImageUri'] = self.image_uri

        if self.container_arguments is not None:
            if hasattr(self.container_arguments, 'to_dict'):
                props['ContainerArguments'] = self.container_arguments.to_dict()
            elif isinstance(self.container_arguments, list):
                props['ContainerArguments'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.container_arguments
                ]
            else:
                props['ContainerArguments'] = self.container_arguments

        return props


@dataclass
class AthenaDatasetDefinition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    work_group: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    query_string: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_format: Optional[Union[str, AthenaResultFormat, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_compression: Optional[Union[str, AthenaResultCompressionType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    catalog: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.work_group is not None:
            if hasattr(self.work_group, 'to_dict'):
                props['WorkGroup'] = self.work_group.to_dict()
            elif isinstance(self.work_group, list):
                props['WorkGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.work_group
                ]
            else:
                props['WorkGroup'] = self.work_group

        if self.output_s3_uri is not None:
            if hasattr(self.output_s3_uri, 'to_dict'):
                props['OutputS3Uri'] = self.output_s3_uri.to_dict()
            elif isinstance(self.output_s3_uri, list):
                props['OutputS3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_s3_uri
                ]
            else:
                props['OutputS3Uri'] = self.output_s3_uri

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.query_string is not None:
            if hasattr(self.query_string, 'to_dict'):
                props['QueryString'] = self.query_string.to_dict()
            elif isinstance(self.query_string, list):
                props['QueryString'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.query_string
                ]
            else:
                props['QueryString'] = self.query_string

        if self.database is not None:
            if hasattr(self.database, 'to_dict'):
                props['Database'] = self.database.to_dict()
            elif isinstance(self.database, list):
                props['Database'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.database
                ]
            else:
                props['Database'] = self.database

        if self.output_format is not None:
            if hasattr(self.output_format, 'to_dict'):
                props['OutputFormat'] = self.output_format.to_dict()
            elif isinstance(self.output_format, list):
                props['OutputFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_format
                ]
            else:
                props['OutputFormat'] = self.output_format

        if self.output_compression is not None:
            if hasattr(self.output_compression, 'to_dict'):
                props['OutputCompression'] = self.output_compression.to_dict()
            elif isinstance(self.output_compression, list):
                props['OutputCompression'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_compression
                ]
            else:
                props['OutputCompression'] = self.output_compression

        if self.catalog is not None:
            if hasattr(self.catalog, 'to_dict'):
                props['Catalog'] = self.catalog.to_dict()
            elif isinstance(self.catalog, list):
                props['Catalog'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.catalog
                ]
            else:
                props['Catalog'] = self.catalog

        return props


@dataclass
class ClusterConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_count: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_size_in_gb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    volume_kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.instance_count is not None:
            if hasattr(self.instance_count, 'to_dict'):
                props['InstanceCount'] = self.instance_count.to_dict()
            elif isinstance(self.instance_count, list):
                props['InstanceCount'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_count
                ]
            else:
                props['InstanceCount'] = self.instance_count

        if self.volume_size_in_gb is not None:
            if hasattr(self.volume_size_in_gb, 'to_dict'):
                props['VolumeSizeInGB'] = self.volume_size_in_gb.to_dict()
            elif isinstance(self.volume_size_in_gb, list):
                props['VolumeSizeInGB'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_size_in_gb
                ]
            else:
                props['VolumeSizeInGB'] = self.volume_size_in_gb

        if self.volume_kms_key_id is not None:
            if hasattr(self.volume_kms_key_id, 'to_dict'):
                props['VolumeKmsKeyId'] = self.volume_kms_key_id.to_dict()
            elif isinstance(self.volume_kms_key_id, list):
                props['VolumeKmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.volume_kms_key_id
                ]
            else:
                props['VolumeKmsKeyId'] = self.volume_kms_key_id

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        return props


@dataclass
class DatasetDefinition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    input_mode: Optional[Union[str, InputMode, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    redshift_dataset_definition: Optional[RedshiftDatasetDefinition] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    athena_dataset_definition: Optional[AthenaDatasetDefinition] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    data_distribution_type: Optional[Union[str, DataDistributionType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.input_mode is not None:
            if hasattr(self.input_mode, 'to_dict'):
                props['InputMode'] = self.input_mode.to_dict()
            elif isinstance(self.input_mode, list):
                props['InputMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.input_mode
                ]
            else:
                props['InputMode'] = self.input_mode

        if self.redshift_dataset_definition is not None:
            if hasattr(self.redshift_dataset_definition, 'to_dict'):
                props['RedshiftDatasetDefinition'] = self.redshift_dataset_definition.to_dict()
            elif isinstance(self.redshift_dataset_definition, list):
                props['RedshiftDatasetDefinition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.redshift_dataset_definition
                ]
            else:
                props['RedshiftDatasetDefinition'] = self.redshift_dataset_definition

        if self.athena_dataset_definition is not None:
            if hasattr(self.athena_dataset_definition, 'to_dict'):
                props['AthenaDatasetDefinition'] = self.athena_dataset_definition.to_dict()
            elif isinstance(self.athena_dataset_definition, list):
                props['AthenaDatasetDefinition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.athena_dataset_definition
                ]
            else:
                props['AthenaDatasetDefinition'] = self.athena_dataset_definition

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.data_distribution_type is not None:
            if hasattr(self.data_distribution_type, 'to_dict'):
                props['DataDistributionType'] = self.data_distribution_type.to_dict()
            elif isinstance(self.data_distribution_type, list):
                props['DataDistributionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.data_distribution_type
                ]
            else:
                props['DataDistributionType'] = self.data_distribution_type

        return props


@dataclass
class ExperimentConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    trial_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    experiment_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    trial_component_display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    run_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.trial_name is not None:
            if hasattr(self.trial_name, 'to_dict'):
                props['TrialName'] = self.trial_name.to_dict()
            elif isinstance(self.trial_name, list):
                props['TrialName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.trial_name
                ]
            else:
                props['TrialName'] = self.trial_name

        if self.experiment_name is not None:
            if hasattr(self.experiment_name, 'to_dict'):
                props['ExperimentName'] = self.experiment_name.to_dict()
            elif isinstance(self.experiment_name, list):
                props['ExperimentName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.experiment_name
                ]
            else:
                props['ExperimentName'] = self.experiment_name

        if self.trial_component_display_name is not None:
            if hasattr(self.trial_component_display_name, 'to_dict'):
                props['TrialComponentDisplayName'] = self.trial_component_display_name.to_dict()
            elif isinstance(self.trial_component_display_name, list):
                props['TrialComponentDisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.trial_component_display_name
                ]
            else:
                props['TrialComponentDisplayName'] = self.trial_component_display_name

        if self.run_name is not None:
            if hasattr(self.run_name, 'to_dict'):
                props['RunName'] = self.run_name.to_dict()
            elif isinstance(self.run_name, list):
                props['RunName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.run_name
                ]
            else:
                props['RunName'] = self.run_name

        return props


@dataclass
class FeatureStoreOutput:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    feature_group_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.feature_group_name is not None:
            if hasattr(self.feature_group_name, 'to_dict'):
                props['FeatureGroupName'] = self.feature_group_name.to_dict()
            elif isinstance(self.feature_group_name, list):
                props['FeatureGroupName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.feature_group_name
                ]
            else:
                props['FeatureGroupName'] = self.feature_group_name

        return props


@dataclass
class NetworkConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_network_isolation: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    enable_inter_container_traffic_encryption: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    vpc_config: Optional[VpcConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.enable_network_isolation is not None:
            if hasattr(self.enable_network_isolation, 'to_dict'):
                props['EnableNetworkIsolation'] = self.enable_network_isolation.to_dict()
            elif isinstance(self.enable_network_isolation, list):
                props['EnableNetworkIsolation'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_network_isolation
                ]
            else:
                props['EnableNetworkIsolation'] = self.enable_network_isolation

        if self.enable_inter_container_traffic_encryption is not None:
            if hasattr(self.enable_inter_container_traffic_encryption, 'to_dict'):
                props['EnableInterContainerTrafficEncryption'] = self.enable_inter_container_traffic_encryption.to_dict()
            elif isinstance(self.enable_inter_container_traffic_encryption, list):
                props['EnableInterContainerTrafficEncryption'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.enable_inter_container_traffic_encryption
                ]
            else:
                props['EnableInterContainerTrafficEncryption'] = self.enable_inter_container_traffic_encryption

        if self.vpc_config is not None:
            if hasattr(self.vpc_config, 'to_dict'):
                props['VpcConfig'] = self.vpc_config.to_dict()
            elif isinstance(self.vpc_config, list):
                props['VpcConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.vpc_config
                ]
            else:
                props['VpcConfig'] = self.vpc_config

        return props


@dataclass
class ProcessingInputsObject:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    app_managed: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    input_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    dataset_definition: Optional[DatasetDefinition] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_input: Optional[S3Input] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.app_managed is not None:
            if hasattr(self.app_managed, 'to_dict'):
                props['AppManaged'] = self.app_managed.to_dict()
            elif isinstance(self.app_managed, list):
                props['AppManaged'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_managed
                ]
            else:
                props['AppManaged'] = self.app_managed

        if self.input_name is not None:
            if hasattr(self.input_name, 'to_dict'):
                props['InputName'] = self.input_name.to_dict()
            elif isinstance(self.input_name, list):
                props['InputName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.input_name
                ]
            else:
                props['InputName'] = self.input_name

        if self.dataset_definition is not None:
            if hasattr(self.dataset_definition, 'to_dict'):
                props['DatasetDefinition'] = self.dataset_definition.to_dict()
            elif isinstance(self.dataset_definition, list):
                props['DatasetDefinition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.dataset_definition
                ]
            else:
                props['DatasetDefinition'] = self.dataset_definition

        if self.s3_input is not None:
            if hasattr(self.s3_input, 'to_dict'):
                props['S3Input'] = self.s3_input.to_dict()
            elif isinstance(self.s3_input, list):
                props['S3Input'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_input
                ]
            else:
                props['S3Input'] = self.s3_input

        return props


@dataclass
class ProcessingOutputConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    outputs: Optional[list[ProcessingOutputsObject]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.outputs is not None:
            if hasattr(self.outputs, 'to_dict'):
                props['Outputs'] = self.outputs.to_dict()
            elif isinstance(self.outputs, list):
                props['Outputs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.outputs
                ]
            else:
                props['Outputs'] = self.outputs

        return props


@dataclass
class ProcessingOutputsObject:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_output: Optional[S3Output] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    app_managed: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    feature_store_output: Optional[FeatureStoreOutput] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_output is not None:
            if hasattr(self.s3_output, 'to_dict'):
                props['S3Output'] = self.s3_output.to_dict()
            elif isinstance(self.s3_output, list):
                props['S3Output'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_output
                ]
            else:
                props['S3Output'] = self.s3_output

        if self.app_managed is not None:
            if hasattr(self.app_managed, 'to_dict'):
                props['AppManaged'] = self.app_managed.to_dict()
            elif isinstance(self.app_managed, list):
                props['AppManaged'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_managed
                ]
            else:
                props['AppManaged'] = self.app_managed

        if self.feature_store_output is not None:
            if hasattr(self.feature_store_output, 'to_dict'):
                props['FeatureStoreOutput'] = self.feature_store_output.to_dict()
            elif isinstance(self.feature_store_output, list):
                props['FeatureStoreOutput'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.feature_store_output
                ]
            else:
                props['FeatureStoreOutput'] = self.feature_store_output

        if self.output_name is not None:
            if hasattr(self.output_name, 'to_dict'):
                props['OutputName'] = self.output_name.to_dict()
            elif isinstance(self.output_name, list):
                props['OutputName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_name
                ]
            else:
                props['OutputName'] = self.output_name

        return props


@dataclass
class ProcessingResources:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cluster_config: Optional[ClusterConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cluster_config is not None:
            if hasattr(self.cluster_config, 'to_dict'):
                props['ClusterConfig'] = self.cluster_config.to_dict()
            elif isinstance(self.cluster_config, list):
                props['ClusterConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cluster_config
                ]
            else:
                props['ClusterConfig'] = self.cluster_config

        return props


@dataclass
class RedshiftDatasetDefinition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cluster_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    query_string: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    database: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_format: Optional[Union[str, RedshiftResultFormat, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    output_compression: Optional[Union[str, RedshiftResultCompressionType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cluster_role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    db_user: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.output_s3_uri is not None:
            if hasattr(self.output_s3_uri, 'to_dict'):
                props['OutputS3Uri'] = self.output_s3_uri.to_dict()
            elif isinstance(self.output_s3_uri, list):
                props['OutputS3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_s3_uri
                ]
            else:
                props['OutputS3Uri'] = self.output_s3_uri

        if self.kms_key_id is not None:
            if hasattr(self.kms_key_id, 'to_dict'):
                props['KmsKeyId'] = self.kms_key_id.to_dict()
            elif isinstance(self.kms_key_id, list):
                props['KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kms_key_id
                ]
            else:
                props['KmsKeyId'] = self.kms_key_id

        if self.cluster_id is not None:
            if hasattr(self.cluster_id, 'to_dict'):
                props['ClusterId'] = self.cluster_id.to_dict()
            elif isinstance(self.cluster_id, list):
                props['ClusterId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cluster_id
                ]
            else:
                props['ClusterId'] = self.cluster_id

        if self.query_string is not None:
            if hasattr(self.query_string, 'to_dict'):
                props['QueryString'] = self.query_string.to_dict()
            elif isinstance(self.query_string, list):
                props['QueryString'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.query_string
                ]
            else:
                props['QueryString'] = self.query_string

        if self.database is not None:
            if hasattr(self.database, 'to_dict'):
                props['Database'] = self.database.to_dict()
            elif isinstance(self.database, list):
                props['Database'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.database
                ]
            else:
                props['Database'] = self.database

        if self.output_format is not None:
            if hasattr(self.output_format, 'to_dict'):
                props['OutputFormat'] = self.output_format.to_dict()
            elif isinstance(self.output_format, list):
                props['OutputFormat'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_format
                ]
            else:
                props['OutputFormat'] = self.output_format

        if self.output_compression is not None:
            if hasattr(self.output_compression, 'to_dict'):
                props['OutputCompression'] = self.output_compression.to_dict()
            elif isinstance(self.output_compression, list):
                props['OutputCompression'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.output_compression
                ]
            else:
                props['OutputCompression'] = self.output_compression

        if self.cluster_role_arn is not None:
            if hasattr(self.cluster_role_arn, 'to_dict'):
                props['ClusterRoleArn'] = self.cluster_role_arn.to_dict()
            elif isinstance(self.cluster_role_arn, list):
                props['ClusterRoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cluster_role_arn
                ]
            else:
                props['ClusterRoleArn'] = self.cluster_role_arn

        if self.db_user is not None:
            if hasattr(self.db_user, 'to_dict'):
                props['DbUser'] = self.db_user.to_dict()
            elif isinstance(self.db_user, list):
                props['DbUser'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.db_user
                ]
            else:
                props['DbUser'] = self.db_user

        return props


@dataclass
class S3Input:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_compression_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_distribution_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_input_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_data_type: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_compression_type is not None:
            if hasattr(self.s3_compression_type, 'to_dict'):
                props['S3CompressionType'] = self.s3_compression_type.to_dict()
            elif isinstance(self.s3_compression_type, list):
                props['S3CompressionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_compression_type
                ]
            else:
                props['S3CompressionType'] = self.s3_compression_type

        if self.s3_data_distribution_type is not None:
            if hasattr(self.s3_data_distribution_type, 'to_dict'):
                props['S3DataDistributionType'] = self.s3_data_distribution_type.to_dict()
            elif isinstance(self.s3_data_distribution_type, list):
                props['S3DataDistributionType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_distribution_type
                ]
            else:
                props['S3DataDistributionType'] = self.s3_data_distribution_type

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        if self.s3_input_mode is not None:
            if hasattr(self.s3_input_mode, 'to_dict'):
                props['S3InputMode'] = self.s3_input_mode.to_dict()
            elif isinstance(self.s3_input_mode, list):
                props['S3InputMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_input_mode
                ]
            else:
                props['S3InputMode'] = self.s3_input_mode

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.s3_data_type is not None:
            if hasattr(self.s3_data_type, 'to_dict'):
                props['S3DataType'] = self.s3_data_type.to_dict()
            elif isinstance(self.s3_data_type, list):
                props['S3DataType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_data_type
                ]
            else:
                props['S3DataType'] = self.s3_data_type

        return props


@dataclass
class S3Output:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    local_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_upload_mode: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        if self.local_path is not None:
            if hasattr(self.local_path, 'to_dict'):
                props['LocalPath'] = self.local_path.to_dict()
            elif isinstance(self.local_path, list):
                props['LocalPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.local_path
                ]
            else:
                props['LocalPath'] = self.local_path

        if self.s3_upload_mode is not None:
            if hasattr(self.s3_upload_mode, 'to_dict'):
                props['S3UploadMode'] = self.s3_upload_mode.to_dict()
            elif isinstance(self.s3_upload_mode, list):
                props['S3UploadMode'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_upload_mode
                ]
            else:
                props['S3UploadMode'] = self.s3_upload_mode

        return props


@dataclass
class StoppingCondition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_runtime_in_seconds: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_runtime_in_seconds is not None:
            if hasattr(self.max_runtime_in_seconds, 'to_dict'):
                props['MaxRuntimeInSeconds'] = self.max_runtime_in_seconds.to_dict()
            elif isinstance(self.max_runtime_in_seconds, list):
                props['MaxRuntimeInSeconds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_runtime_in_seconds
                ]
            else:
                props['MaxRuntimeInSeconds'] = self.max_runtime_in_seconds

        return props


@dataclass
class VpcConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    subnets: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_group_ids: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.subnets is not None:
            if hasattr(self.subnets, 'to_dict'):
                props['Subnets'] = self.subnets.to_dict()
            elif isinstance(self.subnets, list):
                props['Subnets'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.subnets
                ]
            else:
                props['Subnets'] = self.subnets

        if self.security_group_ids is not None:
            if hasattr(self.security_group_ids, 'to_dict'):
                props['SecurityGroupIds'] = self.security_group_ids.to_dict()
            elif isinstance(self.security_group_ids, list):
                props['SecurityGroupIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_group_ids
                ]
            else:
                props['SecurityGroupIds'] = self.security_group_ids

        return props


@dataclass
class ProcessingJob(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::ProcessingJob"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    processing_resources: Optional[ProcessingResources] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    stopping_condition: Optional[StoppingCondition] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    experiment_config: Optional[ExperimentConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    processing_inputs: Optional[list[ProcessingInputsObject]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    network_config: Optional[NetworkConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    processing_output_config: Optional[ProcessingOutputConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    environment: Optional[dict[str, str]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    app_specification: Optional[AppSpecification] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    processing_job_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.processing_resources is not None:
            # Serialize processing_resources (handle intrinsic functions)
            if hasattr(self.processing_resources, 'to_dict'):
                props["ProcessingResources"] = self.processing_resources.to_dict()
            elif isinstance(self.processing_resources, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProcessingResources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.processing_resources
                ]
            else:
                props["ProcessingResources"] = self.processing_resources

        if self.stopping_condition is not None:
            # Serialize stopping_condition (handle intrinsic functions)
            if hasattr(self.stopping_condition, 'to_dict'):
                props["StoppingCondition"] = self.stopping_condition.to_dict()
            elif isinstance(self.stopping_condition, list):
                # Serialize list items (may contain intrinsic functions)
                props['StoppingCondition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.stopping_condition
                ]
            else:
                props["StoppingCondition"] = self.stopping_condition

        if self.experiment_config is not None:
            # Serialize experiment_config (handle intrinsic functions)
            if hasattr(self.experiment_config, 'to_dict'):
                props["ExperimentConfig"] = self.experiment_config.to_dict()
            elif isinstance(self.experiment_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ExperimentConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.experiment_config
                ]
            else:
                props["ExperimentConfig"] = self.experiment_config

        if self.processing_inputs is not None:
            # Serialize processing_inputs (handle intrinsic functions)
            if hasattr(self.processing_inputs, 'to_dict'):
                props["ProcessingInputs"] = self.processing_inputs.to_dict()
            elif isinstance(self.processing_inputs, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProcessingInputs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.processing_inputs
                ]
            else:
                props["ProcessingInputs"] = self.processing_inputs

        if self.network_config is not None:
            # Serialize network_config (handle intrinsic functions)
            if hasattr(self.network_config, 'to_dict'):
                props["NetworkConfig"] = self.network_config.to_dict()
            elif isinstance(self.network_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['NetworkConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.network_config
                ]
            else:
                props["NetworkConfig"] = self.network_config

        if self.processing_output_config is not None:
            # Serialize processing_output_config (handle intrinsic functions)
            if hasattr(self.processing_output_config, 'to_dict'):
                props["ProcessingOutputConfig"] = self.processing_output_config.to_dict()
            elif isinstance(self.processing_output_config, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProcessingOutputConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.processing_output_config
                ]
            else:
                props["ProcessingOutputConfig"] = self.processing_output_config

        if self.environment is not None:
            # Serialize environment (handle intrinsic functions)
            if hasattr(self.environment, 'to_dict'):
                props["Environment"] = self.environment.to_dict()
            elif isinstance(self.environment, list):
                # Serialize list items (may contain intrinsic functions)
                props['Environment'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.environment
                ]
            else:
                props["Environment"] = self.environment

        if self.app_specification is not None:
            # Serialize app_specification (handle intrinsic functions)
            if hasattr(self.app_specification, 'to_dict'):
                props["AppSpecification"] = self.app_specification.to_dict()
            elif isinstance(self.app_specification, list):
                # Serialize list items (may contain intrinsic functions)
                props['AppSpecification'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_specification
                ]
            else:
                props["AppSpecification"] = self.app_specification

        if self.processing_job_name is not None:
            # Serialize processing_job_name (handle intrinsic functions)
            if hasattr(self.processing_job_name, 'to_dict'):
                props["ProcessingJobName"] = self.processing_job_name.to_dict()
            elif isinstance(self.processing_job_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProcessingJobName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.processing_job_name
                ]
            else:
                props["ProcessingJobName"] = self.processing_job_name

        if self.role_arn is not None:
            # Serialize role_arn (handle intrinsic functions)
            if hasattr(self.role_arn, 'to_dict'):
                props["RoleArn"] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                # Serialize list items (may contain intrinsic functions)
                props['RoleArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props["RoleArn"] = self.role_arn

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_monitoring_schedule_arn(self) -> GetAtt:
        """Get the MonitoringScheduleArn attribute."""
        return self.get_att("MonitoringScheduleArn")

    @property
    def attr_training_job_arn(self) -> GetAtt:
        """Get the TrainingJobArn attribute."""
        return self.get_att("TrainingJobArn")

    @property
    def attr_processing_start_time(self) -> GetAtt:
        """Get the ProcessingStartTime attribute."""
        return self.get_att("ProcessingStartTime")

    @property
    def attr_processing_job_arn(self) -> GetAtt:
        """Get the ProcessingJobArn attribute."""
        return self.get_att("ProcessingJobArn")

    @property
    def attr_auto_ml_job_arn(self) -> GetAtt:
        """Get the AutoMLJobArn attribute."""
        return self.get_att("AutoMLJobArn")

    @property
    def attr_exit_message(self) -> GetAtt:
        """Get the ExitMessage attribute."""
        return self.get_att("ExitMessage")

    @property
    def attr_failure_reason(self) -> GetAtt:
        """Get the FailureReason attribute."""
        return self.get_att("FailureReason")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")

    @property
    def attr_last_modified_time(self) -> GetAtt:
        """Get the LastModifiedTime attribute."""
        return self.get_att("LastModifiedTime")

    @property
    def attr_processing_end_time(self) -> GetAtt:
        """Get the ProcessingEndTime attribute."""
        return self.get_att("ProcessingEndTime")

    @property
    def attr_processing_job_status(self) -> GetAtt:
        """Get the ProcessingJobStatus attribute."""
        return self.get_att("ProcessingJobStatus")




@dataclass
class CfnStackParameter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class CfnTemplateProviderDetail:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    template_url: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    parameters: Optional[list[CfnStackParameter]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    template_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    role_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.template_url is not None:
            if hasattr(self.template_url, 'to_dict'):
                props['TemplateURL'] = self.template_url.to_dict()
            elif isinstance(self.template_url, list):
                props['TemplateURL'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.template_url
                ]
            else:
                props['TemplateURL'] = self.template_url

        if self.parameters is not None:
            if hasattr(self.parameters, 'to_dict'):
                props['Parameters'] = self.parameters.to_dict()
            elif isinstance(self.parameters, list):
                props['Parameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.parameters
                ]
            else:
                props['Parameters'] = self.parameters

        if self.template_name is not None:
            if hasattr(self.template_name, 'to_dict'):
                props['TemplateName'] = self.template_name.to_dict()
            elif isinstance(self.template_name, list):
                props['TemplateName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.template_name
                ]
            else:
                props['TemplateName'] = self.template_name

        if self.role_arn is not None:
            if hasattr(self.role_arn, 'to_dict'):
                props['RoleARN'] = self.role_arn.to_dict()
            elif isinstance(self.role_arn, list):
                props['RoleARN'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.role_arn
                ]
            else:
                props['RoleARN'] = self.role_arn

        return props


@dataclass
class ProvisioningParameter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    key: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.value is not None:
            if hasattr(self.value, 'to_dict'):
                props['Value'] = self.value.to_dict()
            elif isinstance(self.value, list):
                props['Value'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.value
                ]
            else:
                props['Value'] = self.value

        if self.key is not None:
            if hasattr(self.key, 'to_dict'):
                props['Key'] = self.key.to_dict()
            elif isinstance(self.key, list):
                props['Key'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.key
                ]
            else:
                props['Key'] = self.key

        return props


@dataclass
class ServiceCatalogProvisionedProductDetails:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provisioned_product_status_message: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provisioned_product_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.provisioned_product_status_message is not None:
            if hasattr(self.provisioned_product_status_message, 'to_dict'):
                props['ProvisionedProductStatusMessage'] = self.provisioned_product_status_message.to_dict()
            elif isinstance(self.provisioned_product_status_message, list):
                props['ProvisionedProductStatusMessage'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.provisioned_product_status_message
                ]
            else:
                props['ProvisionedProductStatusMessage'] = self.provisioned_product_status_message

        if self.provisioned_product_id is not None:
            if hasattr(self.provisioned_product_id, 'to_dict'):
                props['ProvisionedProductId'] = self.provisioned_product_id.to_dict()
            elif isinstance(self.provisioned_product_id, list):
                props['ProvisionedProductId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.provisioned_product_id
                ]
            else:
                props['ProvisionedProductId'] = self.provisioned_product_id

        return props


@dataclass
class ServiceCatalogProvisioningDetails:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    path_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provisioning_parameters: Optional[list[ProvisioningParameter]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    product_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    provisioning_artifact_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.path_id is not None:
            if hasattr(self.path_id, 'to_dict'):
                props['PathId'] = self.path_id.to_dict()
            elif isinstance(self.path_id, list):
                props['PathId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.path_id
                ]
            else:
                props['PathId'] = self.path_id

        if self.provisioning_parameters is not None:
            if hasattr(self.provisioning_parameters, 'to_dict'):
                props['ProvisioningParameters'] = self.provisioning_parameters.to_dict()
            elif isinstance(self.provisioning_parameters, list):
                props['ProvisioningParameters'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.provisioning_parameters
                ]
            else:
                props['ProvisioningParameters'] = self.provisioning_parameters

        if self.product_id is not None:
            if hasattr(self.product_id, 'to_dict'):
                props['ProductId'] = self.product_id.to_dict()
            elif isinstance(self.product_id, list):
                props['ProductId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.product_id
                ]
            else:
                props['ProductId'] = self.product_id

        if self.provisioning_artifact_id is not None:
            if hasattr(self.provisioning_artifact_id, 'to_dict'):
                props['ProvisioningArtifactId'] = self.provisioning_artifact_id.to_dict()
            elif isinstance(self.provisioning_artifact_id, list):
                props['ProvisioningArtifactId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.provisioning_artifact_id
                ]
            else:
                props['ProvisioningArtifactId'] = self.provisioning_artifact_id

        return props


@dataclass
class TemplateProviderDetail:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cfn_template_provider_detail: Optional[CfnTemplateProviderDetail] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cfn_template_provider_detail is not None:
            if hasattr(self.cfn_template_provider_detail, 'to_dict'):
                props['CfnTemplateProviderDetail'] = self.cfn_template_provider_detail.to_dict()
            elif isinstance(self.cfn_template_provider_detail, list):
                props['CfnTemplateProviderDetail'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cfn_template_provider_detail
                ]
            else:
                props['CfnTemplateProviderDetail'] = self.cfn_template_provider_detail

        return props


@dataclass
class Project(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::Project"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    project_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    template_provider_details: Optional[list[TemplateProviderDetail]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_catalog_provisioned_product_details: Optional[ServiceCatalogProvisionedProductDetails] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    service_catalog_provisioning_details: Optional[ServiceCatalogProvisioningDetails] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    project_description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.project_name is not None:
            # Serialize project_name (handle intrinsic functions)
            if hasattr(self.project_name, 'to_dict'):
                props["ProjectName"] = self.project_name.to_dict()
            elif isinstance(self.project_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProjectName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.project_name
                ]
            else:
                props["ProjectName"] = self.project_name

        if self.template_provider_details is not None:
            # Serialize template_provider_details (handle intrinsic functions)
            if hasattr(self.template_provider_details, 'to_dict'):
                props["TemplateProviderDetails"] = self.template_provider_details.to_dict()
            elif isinstance(self.template_provider_details, list):
                # Serialize list items (may contain intrinsic functions)
                props['TemplateProviderDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.template_provider_details
                ]
            else:
                props["TemplateProviderDetails"] = self.template_provider_details

        if self.service_catalog_provisioned_product_details is not None:
            # Serialize service_catalog_provisioned_product_details (handle intrinsic functions)
            if hasattr(self.service_catalog_provisioned_product_details, 'to_dict'):
                props["ServiceCatalogProvisionedProductDetails"] = self.service_catalog_provisioned_product_details.to_dict()
            elif isinstance(self.service_catalog_provisioned_product_details, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceCatalogProvisionedProductDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_catalog_provisioned_product_details
                ]
            else:
                props["ServiceCatalogProvisionedProductDetails"] = self.service_catalog_provisioned_product_details

        if self.service_catalog_provisioning_details is not None:
            # Serialize service_catalog_provisioning_details (handle intrinsic functions)
            if hasattr(self.service_catalog_provisioning_details, 'to_dict'):
                props["ServiceCatalogProvisioningDetails"] = self.service_catalog_provisioning_details.to_dict()
            elif isinstance(self.service_catalog_provisioning_details, list):
                # Serialize list items (may contain intrinsic functions)
                props['ServiceCatalogProvisioningDetails'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.service_catalog_provisioning_details
                ]
            else:
                props["ServiceCatalogProvisioningDetails"] = self.service_catalog_provisioning_details

        if self.project_description is not None:
            # Serialize project_description (handle intrinsic functions)
            if hasattr(self.project_description, 'to_dict'):
                props["ProjectDescription"] = self.project_description.to_dict()
            elif isinstance(self.project_description, list):
                # Serialize list items (may contain intrinsic functions)
                props['ProjectDescription'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.project_description
                ]
            else:
                props["ProjectDescription"] = self.project_description

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_project_arn(self) -> GetAtt:
        """Get the ProjectArn attribute."""
        return self.get_att("ProjectArn")

    @property
    def attr_project_status(self) -> GetAtt:
        """Get the ProjectStatus attribute."""
        return self.get_att("ProjectStatus")

    @property
    def attr_project_id(self) -> GetAtt:
        """Get the ProjectId attribute."""
        return self.get_att("ProjectId")

    @property
    def attr_creation_time(self) -> GetAtt:
        """Get the CreationTime attribute."""
        return self.get_att("CreationTime")




@dataclass
class CodeRepository:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    repository_url: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.repository_url is not None:
            if hasattr(self.repository_url, 'to_dict'):
                props['RepositoryUrl'] = self.repository_url.to_dict()
            elif isinstance(self.repository_url, list):
                props['RepositoryUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.repository_url
                ]
            else:
                props['RepositoryUrl'] = self.repository_url

        return props


@dataclass
class CustomFileSystem:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    f_sx_lustre_file_system: Optional[FSxLustreFileSystem] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    efs_file_system: Optional[EFSFileSystem] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_file_system: Optional[S3FileSystem] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.f_sx_lustre_file_system is not None:
            if hasattr(self.f_sx_lustre_file_system, 'to_dict'):
                props['FSxLustreFileSystem'] = self.f_sx_lustre_file_system.to_dict()
            elif isinstance(self.f_sx_lustre_file_system, list):
                props['FSxLustreFileSystem'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.f_sx_lustre_file_system
                ]
            else:
                props['FSxLustreFileSystem'] = self.f_sx_lustre_file_system

        if self.efs_file_system is not None:
            if hasattr(self.efs_file_system, 'to_dict'):
                props['EFSFileSystem'] = self.efs_file_system.to_dict()
            elif isinstance(self.efs_file_system, list):
                props['EFSFileSystem'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.efs_file_system
                ]
            else:
                props['EFSFileSystem'] = self.efs_file_system

        if self.s3_file_system is not None:
            if hasattr(self.s3_file_system, 'to_dict'):
                props['S3FileSystem'] = self.s3_file_system.to_dict()
            elif isinstance(self.s3_file_system, list):
                props['S3FileSystem'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_file_system
                ]
            else:
                props['S3FileSystem'] = self.s3_file_system

        return props


@dataclass
class CustomImage:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    app_image_config_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_version_number: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.image_name is not None:
            if hasattr(self.image_name, 'to_dict'):
                props['ImageName'] = self.image_name.to_dict()
            elif isinstance(self.image_name, list):
                props['ImageName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_name
                ]
            else:
                props['ImageName'] = self.image_name

        if self.app_image_config_name is not None:
            if hasattr(self.app_image_config_name, 'to_dict'):
                props['AppImageConfigName'] = self.app_image_config_name.to_dict()
            elif isinstance(self.app_image_config_name, list):
                props['AppImageConfigName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_image_config_name
                ]
            else:
                props['AppImageConfigName'] = self.app_image_config_name

        if self.image_version_number is not None:
            if hasattr(self.image_version_number, 'to_dict'):
                props['ImageVersionNumber'] = self.image_version_number.to_dict()
            elif isinstance(self.image_version_number, list):
                props['ImageVersionNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_version_number
                ]
            else:
                props['ImageVersionNumber'] = self.image_version_number

        return props


@dataclass
class EFSFileSystem:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_system_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.file_system_id is not None:
            if hasattr(self.file_system_id, 'to_dict'):
                props['FileSystemId'] = self.file_system_id.to_dict()
            elif isinstance(self.file_system_id, list):
                props['FileSystemId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_id
                ]
            else:
                props['FileSystemId'] = self.file_system_id

        return props


@dataclass
class EbsStorageSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs_volume_size_in_gb: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ebs_volume_size_in_gb is not None:
            if hasattr(self.ebs_volume_size_in_gb, 'to_dict'):
                props['EbsVolumeSizeInGb'] = self.ebs_volume_size_in_gb.to_dict()
            elif isinstance(self.ebs_volume_size_in_gb, list):
                props['EbsVolumeSizeInGb'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_volume_size_in_gb
                ]
            else:
                props['EbsVolumeSizeInGb'] = self.ebs_volume_size_in_gb

        return props


@dataclass
class FSxLustreFileSystem:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_system_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.file_system_id is not None:
            if hasattr(self.file_system_id, 'to_dict'):
                props['FileSystemId'] = self.file_system_id.to_dict()
            elif isinstance(self.file_system_id, list):
                props['FileSystemId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_id
                ]
            else:
                props['FileSystemId'] = self.file_system_id

        return props


@dataclass
class JupyterServerAppSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_resource_spec: Optional[ResourceSpec] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_config_arns: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_resource_spec is not None:
            if hasattr(self.default_resource_spec, 'to_dict'):
                props['DefaultResourceSpec'] = self.default_resource_spec.to_dict()
            elif isinstance(self.default_resource_spec, list):
                props['DefaultResourceSpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_resource_spec
                ]
            else:
                props['DefaultResourceSpec'] = self.default_resource_spec

        if self.lifecycle_config_arns is not None:
            if hasattr(self.lifecycle_config_arns, 'to_dict'):
                props['LifecycleConfigArns'] = self.lifecycle_config_arns.to_dict()
            elif isinstance(self.lifecycle_config_arns, list):
                props['LifecycleConfigArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_config_arns
                ]
            else:
                props['LifecycleConfigArns'] = self.lifecycle_config_arns

        return props


@dataclass
class KernelGatewayAppSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_images: Optional[list[CustomImage]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_resource_spec: Optional[ResourceSpec] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_config_arns: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.custom_images is not None:
            if hasattr(self.custom_images, 'to_dict'):
                props['CustomImages'] = self.custom_images.to_dict()
            elif isinstance(self.custom_images, list):
                props['CustomImages'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_images
                ]
            else:
                props['CustomImages'] = self.custom_images

        if self.default_resource_spec is not None:
            if hasattr(self.default_resource_spec, 'to_dict'):
                props['DefaultResourceSpec'] = self.default_resource_spec.to_dict()
            elif isinstance(self.default_resource_spec, list):
                props['DefaultResourceSpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_resource_spec
                ]
            else:
                props['DefaultResourceSpec'] = self.default_resource_spec

        if self.lifecycle_config_arns is not None:
            if hasattr(self.lifecycle_config_arns, 'to_dict'):
                props['LifecycleConfigArns'] = self.lifecycle_config_arns.to_dict()
            elif isinstance(self.lifecycle_config_arns, list):
                props['LifecycleConfigArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_config_arns
                ]
            else:
                props['LifecycleConfigArns'] = self.lifecycle_config_arns

        return props


@dataclass
class OwnershipSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    owner_user_profile_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.owner_user_profile_name is not None:
            if hasattr(self.owner_user_profile_name, 'to_dict'):
                props['OwnerUserProfileName'] = self.owner_user_profile_name.to_dict()
            elif isinstance(self.owner_user_profile_name, list):
                props['OwnerUserProfileName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.owner_user_profile_name
                ]
            else:
                props['OwnerUserProfileName'] = self.owner_user_profile_name

        return props


@dataclass
class ResourceSpec:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_config_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sage_maker_image_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, AppInstanceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sage_maker_image_version_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.lifecycle_config_arn is not None:
            if hasattr(self.lifecycle_config_arn, 'to_dict'):
                props['LifecycleConfigArn'] = self.lifecycle_config_arn.to_dict()
            elif isinstance(self.lifecycle_config_arn, list):
                props['LifecycleConfigArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_config_arn
                ]
            else:
                props['LifecycleConfigArn'] = self.lifecycle_config_arn

        if self.sage_maker_image_arn is not None:
            if hasattr(self.sage_maker_image_arn, 'to_dict'):
                props['SageMakerImageArn'] = self.sage_maker_image_arn.to_dict()
            elif isinstance(self.sage_maker_image_arn, list):
                props['SageMakerImageArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sage_maker_image_arn
                ]
            else:
                props['SageMakerImageArn'] = self.sage_maker_image_arn

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        if self.sage_maker_image_version_arn is not None:
            if hasattr(self.sage_maker_image_version_arn, 'to_dict'):
                props['SageMakerImageVersionArn'] = self.sage_maker_image_version_arn.to_dict()
            elif isinstance(self.sage_maker_image_version_arn, list):
                props['SageMakerImageVersionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sage_maker_image_version_arn
                ]
            else:
                props['SageMakerImageVersionArn'] = self.sage_maker_image_version_arn

        return props


@dataclass
class S3FileSystem:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        return props


@dataclass
class SpaceAppLifecycleManagement:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    idle_settings: Optional[SpaceIdleSettings] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.idle_settings is not None:
            if hasattr(self.idle_settings, 'to_dict'):
                props['IdleSettings'] = self.idle_settings.to_dict()
            elif isinstance(self.idle_settings, list):
                props['IdleSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.idle_settings
                ]
            else:
                props['IdleSettings'] = self.idle_settings

        return props


@dataclass
class SpaceCodeEditorAppSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_resource_spec: Optional[ResourceSpec] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    app_lifecycle_management: Optional[SpaceAppLifecycleManagement] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_resource_spec is not None:
            if hasattr(self.default_resource_spec, 'to_dict'):
                props['DefaultResourceSpec'] = self.default_resource_spec.to_dict()
            elif isinstance(self.default_resource_spec, list):
                props['DefaultResourceSpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_resource_spec
                ]
            else:
                props['DefaultResourceSpec'] = self.default_resource_spec

        if self.app_lifecycle_management is not None:
            if hasattr(self.app_lifecycle_management, 'to_dict'):
                props['AppLifecycleManagement'] = self.app_lifecycle_management.to_dict()
            elif isinstance(self.app_lifecycle_management, list):
                props['AppLifecycleManagement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_lifecycle_management
                ]
            else:
                props['AppLifecycleManagement'] = self.app_lifecycle_management

        return props


@dataclass
class SpaceIdleSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    idle_timeout_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.idle_timeout_in_minutes is not None:
            if hasattr(self.idle_timeout_in_minutes, 'to_dict'):
                props['IdleTimeoutInMinutes'] = self.idle_timeout_in_minutes.to_dict()
            elif isinstance(self.idle_timeout_in_minutes, list):
                props['IdleTimeoutInMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.idle_timeout_in_minutes
                ]
            else:
                props['IdleTimeoutInMinutes'] = self.idle_timeout_in_minutes

        return props


@dataclass
class SpaceJupyterLabAppSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_resource_spec: Optional[ResourceSpec] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    code_repositories: Optional[list[CodeRepository]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    app_lifecycle_management: Optional[SpaceAppLifecycleManagement] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_resource_spec is not None:
            if hasattr(self.default_resource_spec, 'to_dict'):
                props['DefaultResourceSpec'] = self.default_resource_spec.to_dict()
            elif isinstance(self.default_resource_spec, list):
                props['DefaultResourceSpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_resource_spec
                ]
            else:
                props['DefaultResourceSpec'] = self.default_resource_spec

        if self.code_repositories is not None:
            if hasattr(self.code_repositories, 'to_dict'):
                props['CodeRepositories'] = self.code_repositories.to_dict()
            elif isinstance(self.code_repositories, list):
                props['CodeRepositories'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code_repositories
                ]
            else:
                props['CodeRepositories'] = self.code_repositories

        if self.app_lifecycle_management is not None:
            if hasattr(self.app_lifecycle_management, 'to_dict'):
                props['AppLifecycleManagement'] = self.app_lifecycle_management.to_dict()
            elif isinstance(self.app_lifecycle_management, list):
                props['AppLifecycleManagement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_lifecycle_management
                ]
            else:
                props['AppLifecycleManagement'] = self.app_lifecycle_management

        return props


@dataclass
class SpaceSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    jupyter_lab_app_settings: Optional[SpaceJupyterLabAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kernel_gateway_app_settings: Optional[KernelGatewayAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    code_editor_app_settings: Optional[SpaceCodeEditorAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    space_managed_resources: Optional[Union[str, FeatureStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    remote_access: Optional[Union[str, FeatureStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    jupyter_server_app_settings: Optional[JupyterServerAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_file_systems: Optional[list[CustomFileSystem]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    app_type: Optional[Union[str, AppType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    space_storage_settings: Optional[SpaceStorageSettings] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.jupyter_lab_app_settings is not None:
            if hasattr(self.jupyter_lab_app_settings, 'to_dict'):
                props['JupyterLabAppSettings'] = self.jupyter_lab_app_settings.to_dict()
            elif isinstance(self.jupyter_lab_app_settings, list):
                props['JupyterLabAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.jupyter_lab_app_settings
                ]
            else:
                props['JupyterLabAppSettings'] = self.jupyter_lab_app_settings

        if self.kernel_gateway_app_settings is not None:
            if hasattr(self.kernel_gateway_app_settings, 'to_dict'):
                props['KernelGatewayAppSettings'] = self.kernel_gateway_app_settings.to_dict()
            elif isinstance(self.kernel_gateway_app_settings, list):
                props['KernelGatewayAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kernel_gateway_app_settings
                ]
            else:
                props['KernelGatewayAppSettings'] = self.kernel_gateway_app_settings

        if self.code_editor_app_settings is not None:
            if hasattr(self.code_editor_app_settings, 'to_dict'):
                props['CodeEditorAppSettings'] = self.code_editor_app_settings.to_dict()
            elif isinstance(self.code_editor_app_settings, list):
                props['CodeEditorAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code_editor_app_settings
                ]
            else:
                props['CodeEditorAppSettings'] = self.code_editor_app_settings

        if self.space_managed_resources is not None:
            if hasattr(self.space_managed_resources, 'to_dict'):
                props['SpaceManagedResources'] = self.space_managed_resources.to_dict()
            elif isinstance(self.space_managed_resources, list):
                props['SpaceManagedResources'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.space_managed_resources
                ]
            else:
                props['SpaceManagedResources'] = self.space_managed_resources

        if self.remote_access is not None:
            if hasattr(self.remote_access, 'to_dict'):
                props['RemoteAccess'] = self.remote_access.to_dict()
            elif isinstance(self.remote_access, list):
                props['RemoteAccess'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.remote_access
                ]
            else:
                props['RemoteAccess'] = self.remote_access

        if self.jupyter_server_app_settings is not None:
            if hasattr(self.jupyter_server_app_settings, 'to_dict'):
                props['JupyterServerAppSettings'] = self.jupyter_server_app_settings.to_dict()
            elif isinstance(self.jupyter_server_app_settings, list):
                props['JupyterServerAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.jupyter_server_app_settings
                ]
            else:
                props['JupyterServerAppSettings'] = self.jupyter_server_app_settings

        if self.custom_file_systems is not None:
            if hasattr(self.custom_file_systems, 'to_dict'):
                props['CustomFileSystems'] = self.custom_file_systems.to_dict()
            elif isinstance(self.custom_file_systems, list):
                props['CustomFileSystems'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_file_systems
                ]
            else:
                props['CustomFileSystems'] = self.custom_file_systems

        if self.app_type is not None:
            if hasattr(self.app_type, 'to_dict'):
                props['AppType'] = self.app_type.to_dict()
            elif isinstance(self.app_type, list):
                props['AppType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_type
                ]
            else:
                props['AppType'] = self.app_type

        if self.space_storage_settings is not None:
            if hasattr(self.space_storage_settings, 'to_dict'):
                props['SpaceStorageSettings'] = self.space_storage_settings.to_dict()
            elif isinstance(self.space_storage_settings, list):
                props['SpaceStorageSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.space_storage_settings
                ]
            else:
                props['SpaceStorageSettings'] = self.space_storage_settings

        return props


@dataclass
class SpaceSharingSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sharing_type: Optional[Union[str, SharingType, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.sharing_type is not None:
            if hasattr(self.sharing_type, 'to_dict'):
                props['SharingType'] = self.sharing_type.to_dict()
            elif isinstance(self.sharing_type, list):
                props['SharingType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sharing_type
                ]
            else:
                props['SharingType'] = self.sharing_type

        return props


@dataclass
class SpaceStorageSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    ebs_storage_settings: Optional[EbsStorageSettings] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.ebs_storage_settings is not None:
            if hasattr(self.ebs_storage_settings, 'to_dict'):
                props['EbsStorageSettings'] = self.ebs_storage_settings.to_dict()
            elif isinstance(self.ebs_storage_settings, list):
                props['EbsStorageSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ebs_storage_settings
                ]
            else:
                props['EbsStorageSettings'] = self.ebs_storage_settings

        return props


@dataclass
class Space(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::Space"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    space_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    space_settings: Optional[SpaceSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    space_display_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    space_sharing_settings: Optional[SpaceSharingSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    ownership_settings: Optional[OwnershipSettings] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.domain_id is not None:
            # Serialize domain_id (handle intrinsic functions)
            if hasattr(self.domain_id, 'to_dict'):
                props["DomainId"] = self.domain_id.to_dict()
            elif isinstance(self.domain_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_id
                ]
            else:
                props["DomainId"] = self.domain_id

        if self.space_name is not None:
            # Serialize space_name (handle intrinsic functions)
            if hasattr(self.space_name, 'to_dict'):
                props["SpaceName"] = self.space_name.to_dict()
            elif isinstance(self.space_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['SpaceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.space_name
                ]
            else:
                props["SpaceName"] = self.space_name

        if self.space_settings is not None:
            # Serialize space_settings (handle intrinsic functions)
            if hasattr(self.space_settings, 'to_dict'):
                props["SpaceSettings"] = self.space_settings.to_dict()
            elif isinstance(self.space_settings, list):
                # Serialize list items (may contain intrinsic functions)
                props['SpaceSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.space_settings
                ]
            else:
                props["SpaceSettings"] = self.space_settings

        if self.space_display_name is not None:
            # Serialize space_display_name (handle intrinsic functions)
            if hasattr(self.space_display_name, 'to_dict'):
                props["SpaceDisplayName"] = self.space_display_name.to_dict()
            elif isinstance(self.space_display_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['SpaceDisplayName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.space_display_name
                ]
            else:
                props["SpaceDisplayName"] = self.space_display_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.space_sharing_settings is not None:
            # Serialize space_sharing_settings (handle intrinsic functions)
            if hasattr(self.space_sharing_settings, 'to_dict'):
                props["SpaceSharingSettings"] = self.space_sharing_settings.to_dict()
            elif isinstance(self.space_sharing_settings, list):
                # Serialize list items (may contain intrinsic functions)
                props['SpaceSharingSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.space_sharing_settings
                ]
            else:
                props["SpaceSharingSettings"] = self.space_sharing_settings

        if self.ownership_settings is not None:
            # Serialize ownership_settings (handle intrinsic functions)
            if hasattr(self.ownership_settings, 'to_dict'):
                props["OwnershipSettings"] = self.ownership_settings.to_dict()
            elif isinstance(self.ownership_settings, list):
                # Serialize list items (may contain intrinsic functions)
                props['OwnershipSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.ownership_settings
                ]
            else:
                props["OwnershipSettings"] = self.ownership_settings

        return props

    @property
    def attr_space_arn(self) -> GetAtt:
        """Get the SpaceArn attribute."""
        return self.get_att("SpaceArn")

    @property
    def attr_url(self) -> GetAtt:
        """Get the Url attribute."""
        return self.get_att("Url")




@dataclass
class StudioLifecycleConfig(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::StudioLifecycleConfig"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    studio_lifecycle_config_app_type: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    studio_lifecycle_config_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    studio_lifecycle_config_content: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.studio_lifecycle_config_app_type is not None:
            # Serialize studio_lifecycle_config_app_type (handle intrinsic functions)
            if hasattr(self.studio_lifecycle_config_app_type, 'to_dict'):
                props["StudioLifecycleConfigAppType"] = self.studio_lifecycle_config_app_type.to_dict()
            elif isinstance(self.studio_lifecycle_config_app_type, list):
                # Serialize list items (may contain intrinsic functions)
                props['StudioLifecycleConfigAppType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.studio_lifecycle_config_app_type
                ]
            else:
                props["StudioLifecycleConfigAppType"] = self.studio_lifecycle_config_app_type

        if self.studio_lifecycle_config_name is not None:
            # Serialize studio_lifecycle_config_name (handle intrinsic functions)
            if hasattr(self.studio_lifecycle_config_name, 'to_dict'):
                props["StudioLifecycleConfigName"] = self.studio_lifecycle_config_name.to_dict()
            elif isinstance(self.studio_lifecycle_config_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['StudioLifecycleConfigName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.studio_lifecycle_config_name
                ]
            else:
                props["StudioLifecycleConfigName"] = self.studio_lifecycle_config_name

        if self.studio_lifecycle_config_content is not None:
            # Serialize studio_lifecycle_config_content (handle intrinsic functions)
            if hasattr(self.studio_lifecycle_config_content, 'to_dict'):
                props["StudioLifecycleConfigContent"] = self.studio_lifecycle_config_content.to_dict()
            elif isinstance(self.studio_lifecycle_config_content, list):
                # Serialize list items (may contain intrinsic functions)
                props['StudioLifecycleConfigContent'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.studio_lifecycle_config_content
                ]
            else:
                props["StudioLifecycleConfigContent"] = self.studio_lifecycle_config_content

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_studio_lifecycle_config_arn(self) -> GetAtt:
        """Get the StudioLifecycleConfigArn attribute."""
        return self.get_att("StudioLifecycleConfigArn")




@dataclass
class AppLifecycleManagement:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    idle_settings: Optional[IdleSettings] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.idle_settings is not None:
            if hasattr(self.idle_settings, 'to_dict'):
                props['IdleSettings'] = self.idle_settings.to_dict()
            elif isinstance(self.idle_settings, list):
                props['IdleSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.idle_settings
                ]
            else:
                props['IdleSettings'] = self.idle_settings

        return props


@dataclass
class CodeEditorAppSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_images: Optional[list[CustomImage]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_resource_spec: Optional[ResourceSpec] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_config_arns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    built_in_lifecycle_config_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    app_lifecycle_management: Optional[AppLifecycleManagement] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.custom_images is not None:
            if hasattr(self.custom_images, 'to_dict'):
                props['CustomImages'] = self.custom_images.to_dict()
            elif isinstance(self.custom_images, list):
                props['CustomImages'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_images
                ]
            else:
                props['CustomImages'] = self.custom_images

        if self.default_resource_spec is not None:
            if hasattr(self.default_resource_spec, 'to_dict'):
                props['DefaultResourceSpec'] = self.default_resource_spec.to_dict()
            elif isinstance(self.default_resource_spec, list):
                props['DefaultResourceSpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_resource_spec
                ]
            else:
                props['DefaultResourceSpec'] = self.default_resource_spec

        if self.lifecycle_config_arns is not None:
            if hasattr(self.lifecycle_config_arns, 'to_dict'):
                props['LifecycleConfigArns'] = self.lifecycle_config_arns.to_dict()
            elif isinstance(self.lifecycle_config_arns, list):
                props['LifecycleConfigArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_config_arns
                ]
            else:
                props['LifecycleConfigArns'] = self.lifecycle_config_arns

        if self.built_in_lifecycle_config_arn is not None:
            if hasattr(self.built_in_lifecycle_config_arn, 'to_dict'):
                props['BuiltInLifecycleConfigArn'] = self.built_in_lifecycle_config_arn.to_dict()
            elif isinstance(self.built_in_lifecycle_config_arn, list):
                props['BuiltInLifecycleConfigArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.built_in_lifecycle_config_arn
                ]
            else:
                props['BuiltInLifecycleConfigArn'] = self.built_in_lifecycle_config_arn

        if self.app_lifecycle_management is not None:
            if hasattr(self.app_lifecycle_management, 'to_dict'):
                props['AppLifecycleManagement'] = self.app_lifecycle_management.to_dict()
            elif isinstance(self.app_lifecycle_management, list):
                props['AppLifecycleManagement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_lifecycle_management
                ]
            else:
                props['AppLifecycleManagement'] = self.app_lifecycle_management

        return props


@dataclass
class CodeRepository:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    repository_url: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.repository_url is not None:
            if hasattr(self.repository_url, 'to_dict'):
                props['RepositoryUrl'] = self.repository_url.to_dict()
            elif isinstance(self.repository_url, list):
                props['RepositoryUrl'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.repository_url
                ]
            else:
                props['RepositoryUrl'] = self.repository_url

        return props


@dataclass
class CustomFileSystemConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    efs_file_system_config: Optional[EFSFileSystemConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_file_system_config: Optional[S3FileSystemConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    f_sx_lustre_file_system_config: Optional[FSxLustreFileSystemConfig] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.efs_file_system_config is not None:
            if hasattr(self.efs_file_system_config, 'to_dict'):
                props['EFSFileSystemConfig'] = self.efs_file_system_config.to_dict()
            elif isinstance(self.efs_file_system_config, list):
                props['EFSFileSystemConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.efs_file_system_config
                ]
            else:
                props['EFSFileSystemConfig'] = self.efs_file_system_config

        if self.s3_file_system_config is not None:
            if hasattr(self.s3_file_system_config, 'to_dict'):
                props['S3FileSystemConfig'] = self.s3_file_system_config.to_dict()
            elif isinstance(self.s3_file_system_config, list):
                props['S3FileSystemConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_file_system_config
                ]
            else:
                props['S3FileSystemConfig'] = self.s3_file_system_config

        if self.f_sx_lustre_file_system_config is not None:
            if hasattr(self.f_sx_lustre_file_system_config, 'to_dict'):
                props['FSxLustreFileSystemConfig'] = self.f_sx_lustre_file_system_config.to_dict()
            elif isinstance(self.f_sx_lustre_file_system_config, list):
                props['FSxLustreFileSystemConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.f_sx_lustre_file_system_config
                ]
            else:
                props['FSxLustreFileSystemConfig'] = self.f_sx_lustre_file_system_config

        return props


@dataclass
class CustomImage:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    app_image_config_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    image_version_number: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.image_name is not None:
            if hasattr(self.image_name, 'to_dict'):
                props['ImageName'] = self.image_name.to_dict()
            elif isinstance(self.image_name, list):
                props['ImageName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_name
                ]
            else:
                props['ImageName'] = self.image_name

        if self.app_image_config_name is not None:
            if hasattr(self.app_image_config_name, 'to_dict'):
                props['AppImageConfigName'] = self.app_image_config_name.to_dict()
            elif isinstance(self.app_image_config_name, list):
                props['AppImageConfigName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_image_config_name
                ]
            else:
                props['AppImageConfigName'] = self.app_image_config_name

        if self.image_version_number is not None:
            if hasattr(self.image_version_number, 'to_dict'):
                props['ImageVersionNumber'] = self.image_version_number.to_dict()
            elif isinstance(self.image_version_number, list):
                props['ImageVersionNumber'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.image_version_number
                ]
            else:
                props['ImageVersionNumber'] = self.image_version_number

        return props


@dataclass
class CustomPosixUserConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    uid: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    gid: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.uid is not None:
            if hasattr(self.uid, 'to_dict'):
                props['Uid'] = self.uid.to_dict()
            elif isinstance(self.uid, list):
                props['Uid'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.uid
                ]
            else:
                props['Uid'] = self.uid

        if self.gid is not None:
            if hasattr(self.gid, 'to_dict'):
                props['Gid'] = self.gid.to_dict()
            elif isinstance(self.gid, list):
                props['Gid'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.gid
                ]
            else:
                props['Gid'] = self.gid

        return props


@dataclass
class DefaultEbsStorageSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    maximum_ebs_volume_size_in_gb: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_ebs_volume_size_in_gb: Optional[Union[int, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.maximum_ebs_volume_size_in_gb is not None:
            if hasattr(self.maximum_ebs_volume_size_in_gb, 'to_dict'):
                props['MaximumEbsVolumeSizeInGb'] = self.maximum_ebs_volume_size_in_gb.to_dict()
            elif isinstance(self.maximum_ebs_volume_size_in_gb, list):
                props['MaximumEbsVolumeSizeInGb'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.maximum_ebs_volume_size_in_gb
                ]
            else:
                props['MaximumEbsVolumeSizeInGb'] = self.maximum_ebs_volume_size_in_gb

        if self.default_ebs_volume_size_in_gb is not None:
            if hasattr(self.default_ebs_volume_size_in_gb, 'to_dict'):
                props['DefaultEbsVolumeSizeInGb'] = self.default_ebs_volume_size_in_gb.to_dict()
            elif isinstance(self.default_ebs_volume_size_in_gb, list):
                props['DefaultEbsVolumeSizeInGb'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_ebs_volume_size_in_gb
                ]
            else:
                props['DefaultEbsVolumeSizeInGb'] = self.default_ebs_volume_size_in_gb

        return props


@dataclass
class DefaultSpaceStorageSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_ebs_storage_settings: Optional[DefaultEbsStorageSettings] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_ebs_storage_settings is not None:
            if hasattr(self.default_ebs_storage_settings, 'to_dict'):
                props['DefaultEbsStorageSettings'] = self.default_ebs_storage_settings.to_dict()
            elif isinstance(self.default_ebs_storage_settings, list):
                props['DefaultEbsStorageSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_ebs_storage_settings
                ]
            else:
                props['DefaultEbsStorageSettings'] = self.default_ebs_storage_settings

        return props


@dataclass
class EFSFileSystemConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_system_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_system_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.file_system_path is not None:
            if hasattr(self.file_system_path, 'to_dict'):
                props['FileSystemPath'] = self.file_system_path.to_dict()
            elif isinstance(self.file_system_path, list):
                props['FileSystemPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_path
                ]
            else:
                props['FileSystemPath'] = self.file_system_path

        if self.file_system_id is not None:
            if hasattr(self.file_system_id, 'to_dict'):
                props['FileSystemId'] = self.file_system_id.to_dict()
            elif isinstance(self.file_system_id, list):
                props['FileSystemId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_id
                ]
            else:
                props['FileSystemId'] = self.file_system_id

        return props


@dataclass
class FSxLustreFileSystemConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_system_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    file_system_id: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.file_system_path is not None:
            if hasattr(self.file_system_path, 'to_dict'):
                props['FileSystemPath'] = self.file_system_path.to_dict()
            elif isinstance(self.file_system_path, list):
                props['FileSystemPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_path
                ]
            else:
                props['FileSystemPath'] = self.file_system_path

        if self.file_system_id is not None:
            if hasattr(self.file_system_id, 'to_dict'):
                props['FileSystemId'] = self.file_system_id.to_dict()
            elif isinstance(self.file_system_id, list):
                props['FileSystemId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.file_system_id
                ]
            else:
                props['FileSystemId'] = self.file_system_id

        return props


@dataclass
class HiddenSageMakerImage:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sage_maker_image_name: Optional[Union[str, SageMakerImageName, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    version_aliases: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.sage_maker_image_name is not None:
            if hasattr(self.sage_maker_image_name, 'to_dict'):
                props['SageMakerImageName'] = self.sage_maker_image_name.to_dict()
            elif isinstance(self.sage_maker_image_name, list):
                props['SageMakerImageName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sage_maker_image_name
                ]
            else:
                props['SageMakerImageName'] = self.sage_maker_image_name

        if self.version_aliases is not None:
            if hasattr(self.version_aliases, 'to_dict'):
                props['VersionAliases'] = self.version_aliases.to_dict()
            elif isinstance(self.version_aliases, list):
                props['VersionAliases'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.version_aliases
                ]
            else:
                props['VersionAliases'] = self.version_aliases

        return props


@dataclass
class IdleSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    max_idle_timeout_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    idle_timeout_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    min_idle_timeout_in_minutes: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_management: Optional[Union[str, LifecycleManagement, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.max_idle_timeout_in_minutes is not None:
            if hasattr(self.max_idle_timeout_in_minutes, 'to_dict'):
                props['MaxIdleTimeoutInMinutes'] = self.max_idle_timeout_in_minutes.to_dict()
            elif isinstance(self.max_idle_timeout_in_minutes, list):
                props['MaxIdleTimeoutInMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.max_idle_timeout_in_minutes
                ]
            else:
                props['MaxIdleTimeoutInMinutes'] = self.max_idle_timeout_in_minutes

        if self.idle_timeout_in_minutes is not None:
            if hasattr(self.idle_timeout_in_minutes, 'to_dict'):
                props['IdleTimeoutInMinutes'] = self.idle_timeout_in_minutes.to_dict()
            elif isinstance(self.idle_timeout_in_minutes, list):
                props['IdleTimeoutInMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.idle_timeout_in_minutes
                ]
            else:
                props['IdleTimeoutInMinutes'] = self.idle_timeout_in_minutes

        if self.min_idle_timeout_in_minutes is not None:
            if hasattr(self.min_idle_timeout_in_minutes, 'to_dict'):
                props['MinIdleTimeoutInMinutes'] = self.min_idle_timeout_in_minutes.to_dict()
            elif isinstance(self.min_idle_timeout_in_minutes, list):
                props['MinIdleTimeoutInMinutes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.min_idle_timeout_in_minutes
                ]
            else:
                props['MinIdleTimeoutInMinutes'] = self.min_idle_timeout_in_minutes

        if self.lifecycle_management is not None:
            if hasattr(self.lifecycle_management, 'to_dict'):
                props['LifecycleManagement'] = self.lifecycle_management.to_dict()
            elif isinstance(self.lifecycle_management, list):
                props['LifecycleManagement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_management
                ]
            else:
                props['LifecycleManagement'] = self.lifecycle_management

        return props


@dataclass
class JupyterLabAppSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_images: Optional[list[CustomImage]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_resource_spec: Optional[ResourceSpec] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_config_arns: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    built_in_lifecycle_config_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    code_repositories: Optional[list[CodeRepository]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    app_lifecycle_management: Optional[AppLifecycleManagement] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.custom_images is not None:
            if hasattr(self.custom_images, 'to_dict'):
                props['CustomImages'] = self.custom_images.to_dict()
            elif isinstance(self.custom_images, list):
                props['CustomImages'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_images
                ]
            else:
                props['CustomImages'] = self.custom_images

        if self.default_resource_spec is not None:
            if hasattr(self.default_resource_spec, 'to_dict'):
                props['DefaultResourceSpec'] = self.default_resource_spec.to_dict()
            elif isinstance(self.default_resource_spec, list):
                props['DefaultResourceSpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_resource_spec
                ]
            else:
                props['DefaultResourceSpec'] = self.default_resource_spec

        if self.lifecycle_config_arns is not None:
            if hasattr(self.lifecycle_config_arns, 'to_dict'):
                props['LifecycleConfigArns'] = self.lifecycle_config_arns.to_dict()
            elif isinstance(self.lifecycle_config_arns, list):
                props['LifecycleConfigArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_config_arns
                ]
            else:
                props['LifecycleConfigArns'] = self.lifecycle_config_arns

        if self.built_in_lifecycle_config_arn is not None:
            if hasattr(self.built_in_lifecycle_config_arn, 'to_dict'):
                props['BuiltInLifecycleConfigArn'] = self.built_in_lifecycle_config_arn.to_dict()
            elif isinstance(self.built_in_lifecycle_config_arn, list):
                props['BuiltInLifecycleConfigArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.built_in_lifecycle_config_arn
                ]
            else:
                props['BuiltInLifecycleConfigArn'] = self.built_in_lifecycle_config_arn

        if self.code_repositories is not None:
            if hasattr(self.code_repositories, 'to_dict'):
                props['CodeRepositories'] = self.code_repositories.to_dict()
            elif isinstance(self.code_repositories, list):
                props['CodeRepositories'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code_repositories
                ]
            else:
                props['CodeRepositories'] = self.code_repositories

        if self.app_lifecycle_management is not None:
            if hasattr(self.app_lifecycle_management, 'to_dict'):
                props['AppLifecycleManagement'] = self.app_lifecycle_management.to_dict()
            elif isinstance(self.app_lifecycle_management, list):
                props['AppLifecycleManagement'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.app_lifecycle_management
                ]
            else:
                props['AppLifecycleManagement'] = self.app_lifecycle_management

        return props


@dataclass
class JupyterServerAppSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_resource_spec: Optional[ResourceSpec] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_config_arns: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.default_resource_spec is not None:
            if hasattr(self.default_resource_spec, 'to_dict'):
                props['DefaultResourceSpec'] = self.default_resource_spec.to_dict()
            elif isinstance(self.default_resource_spec, list):
                props['DefaultResourceSpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_resource_spec
                ]
            else:
                props['DefaultResourceSpec'] = self.default_resource_spec

        if self.lifecycle_config_arns is not None:
            if hasattr(self.lifecycle_config_arns, 'to_dict'):
                props['LifecycleConfigArns'] = self.lifecycle_config_arns.to_dict()
            elif isinstance(self.lifecycle_config_arns, list):
                props['LifecycleConfigArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_config_arns
                ]
            else:
                props['LifecycleConfigArns'] = self.lifecycle_config_arns

        return props


@dataclass
class KernelGatewayAppSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_images: Optional[list[CustomImage]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_resource_spec: Optional[ResourceSpec] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_config_arns: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.custom_images is not None:
            if hasattr(self.custom_images, 'to_dict'):
                props['CustomImages'] = self.custom_images.to_dict()
            elif isinstance(self.custom_images, list):
                props['CustomImages'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_images
                ]
            else:
                props['CustomImages'] = self.custom_images

        if self.default_resource_spec is not None:
            if hasattr(self.default_resource_spec, 'to_dict'):
                props['DefaultResourceSpec'] = self.default_resource_spec.to_dict()
            elif isinstance(self.default_resource_spec, list):
                props['DefaultResourceSpec'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_resource_spec
                ]
            else:
                props['DefaultResourceSpec'] = self.default_resource_spec

        if self.lifecycle_config_arns is not None:
            if hasattr(self.lifecycle_config_arns, 'to_dict'):
                props['LifecycleConfigArns'] = self.lifecycle_config_arns.to_dict()
            elif isinstance(self.lifecycle_config_arns, list):
                props['LifecycleConfigArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_config_arns
                ]
            else:
                props['LifecycleConfigArns'] = self.lifecycle_config_arns

        return props


@dataclass
class RStudioServerProAppSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    access_status: Optional[Union[str, RStudioServerProAccessStatus, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    user_group: Optional[Union[str, RStudioServerProUserGroup, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.access_status is not None:
            if hasattr(self.access_status, 'to_dict'):
                props['AccessStatus'] = self.access_status.to_dict()
            elif isinstance(self.access_status, list):
                props['AccessStatus'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.access_status
                ]
            else:
                props['AccessStatus'] = self.access_status

        if self.user_group is not None:
            if hasattr(self.user_group, 'to_dict'):
                props['UserGroup'] = self.user_group.to_dict()
            elif isinstance(self.user_group, list):
                props['UserGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_group
                ]
            else:
                props['UserGroup'] = self.user_group

        return props


@dataclass
class ResourceSpec:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    lifecycle_config_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sage_maker_image_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    instance_type: Optional[Union[str, AppInstanceType, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sage_maker_image_version_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.lifecycle_config_arn is not None:
            if hasattr(self.lifecycle_config_arn, 'to_dict'):
                props['LifecycleConfigArn'] = self.lifecycle_config_arn.to_dict()
            elif isinstance(self.lifecycle_config_arn, list):
                props['LifecycleConfigArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.lifecycle_config_arn
                ]
            else:
                props['LifecycleConfigArn'] = self.lifecycle_config_arn

        if self.sage_maker_image_arn is not None:
            if hasattr(self.sage_maker_image_arn, 'to_dict'):
                props['SageMakerImageArn'] = self.sage_maker_image_arn.to_dict()
            elif isinstance(self.sage_maker_image_arn, list):
                props['SageMakerImageArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sage_maker_image_arn
                ]
            else:
                props['SageMakerImageArn'] = self.sage_maker_image_arn

        if self.instance_type is not None:
            if hasattr(self.instance_type, 'to_dict'):
                props['InstanceType'] = self.instance_type.to_dict()
            elif isinstance(self.instance_type, list):
                props['InstanceType'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.instance_type
                ]
            else:
                props['InstanceType'] = self.instance_type

        if self.sage_maker_image_version_arn is not None:
            if hasattr(self.sage_maker_image_version_arn, 'to_dict'):
                props['SageMakerImageVersionArn'] = self.sage_maker_image_version_arn.to_dict()
            elif isinstance(self.sage_maker_image_version_arn, list):
                props['SageMakerImageVersionArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sage_maker_image_version_arn
                ]
            else:
                props['SageMakerImageVersionArn'] = self.sage_maker_image_version_arn

        return props


@dataclass
class S3FileSystemConfig:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    mount_path: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.mount_path is not None:
            if hasattr(self.mount_path, 'to_dict'):
                props['MountPath'] = self.mount_path.to_dict()
            elif isinstance(self.mount_path, list):
                props['MountPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.mount_path
                ]
            else:
                props['MountPath'] = self.mount_path

        if self.s3_uri is not None:
            if hasattr(self.s3_uri, 'to_dict'):
                props['S3Uri'] = self.s3_uri.to_dict()
            elif isinstance(self.s3_uri, list):
                props['S3Uri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_uri
                ]
            else:
                props['S3Uri'] = self.s3_uri

        return props


@dataclass
class SharingSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notebook_output_option: Optional[Union[str, NotebookOutputOption, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_kms_key_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    s3_output_path: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.notebook_output_option is not None:
            if hasattr(self.notebook_output_option, 'to_dict'):
                props['NotebookOutputOption'] = self.notebook_output_option.to_dict()
            elif isinstance(self.notebook_output_option, list):
                props['NotebookOutputOption'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notebook_output_option
                ]
            else:
                props['NotebookOutputOption'] = self.notebook_output_option

        if self.s3_kms_key_id is not None:
            if hasattr(self.s3_kms_key_id, 'to_dict'):
                props['S3KmsKeyId'] = self.s3_kms_key_id.to_dict()
            elif isinstance(self.s3_kms_key_id, list):
                props['S3KmsKeyId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_kms_key_id
                ]
            else:
                props['S3KmsKeyId'] = self.s3_kms_key_id

        if self.s3_output_path is not None:
            if hasattr(self.s3_output_path, 'to_dict'):
                props['S3OutputPath'] = self.s3_output_path.to_dict()
            elif isinstance(self.s3_output_path, list):
                props['S3OutputPath'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.s3_output_path
                ]
            else:
                props['S3OutputPath'] = self.s3_output_path

        return props


@dataclass
class StudioWebPortalSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hidden_sage_maker_image_version_aliases: Optional[list[HiddenSageMakerImage]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hidden_app_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hidden_instance_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    hidden_ml_tools: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.hidden_sage_maker_image_version_aliases is not None:
            if hasattr(self.hidden_sage_maker_image_version_aliases, 'to_dict'):
                props['HiddenSageMakerImageVersionAliases'] = self.hidden_sage_maker_image_version_aliases.to_dict()
            elif isinstance(self.hidden_sage_maker_image_version_aliases, list):
                props['HiddenSageMakerImageVersionAliases'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hidden_sage_maker_image_version_aliases
                ]
            else:
                props['HiddenSageMakerImageVersionAliases'] = self.hidden_sage_maker_image_version_aliases

        if self.hidden_app_types is not None:
            if hasattr(self.hidden_app_types, 'to_dict'):
                props['HiddenAppTypes'] = self.hidden_app_types.to_dict()
            elif isinstance(self.hidden_app_types, list):
                props['HiddenAppTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hidden_app_types
                ]
            else:
                props['HiddenAppTypes'] = self.hidden_app_types

        if self.hidden_instance_types is not None:
            if hasattr(self.hidden_instance_types, 'to_dict'):
                props['HiddenInstanceTypes'] = self.hidden_instance_types.to_dict()
            elif isinstance(self.hidden_instance_types, list):
                props['HiddenInstanceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hidden_instance_types
                ]
            else:
                props['HiddenInstanceTypes'] = self.hidden_instance_types

        if self.hidden_ml_tools is not None:
            if hasattr(self.hidden_ml_tools, 'to_dict'):
                props['HiddenMlTools'] = self.hidden_ml_tools.to_dict()
            elif isinstance(self.hidden_ml_tools, list):
                props['HiddenMlTools'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.hidden_ml_tools
                ]
            else:
                props['HiddenMlTools'] = self.hidden_ml_tools

        return props


@dataclass
class UserSettings:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    security_groups: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    jupyter_lab_app_settings: Optional[JupyterLabAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    kernel_gateway_app_settings: Optional[KernelGatewayAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    studio_web_portal_settings: Optional[StudioWebPortalSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_file_system_configs: Optional[list[CustomFileSystemConfig]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    custom_posix_user_config: Optional[CustomPosixUserConfig] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    code_editor_app_settings: Optional[CodeEditorAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    r_studio_server_pro_app_settings: Optional[RStudioServerProAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    studio_web_portal: Optional[Union[str, StudioWebPortal, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    jupyter_server_app_settings: Optional[JupyterServerAppSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    auto_mount_home_efs: Optional[Union[str, AutoMountHomeEFS, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    default_landing_uri: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    execution_role: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    space_storage_settings: Optional[DefaultSpaceStorageSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    sharing_settings: Optional[SharingSettings] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.security_groups is not None:
            if hasattr(self.security_groups, 'to_dict'):
                props['SecurityGroups'] = self.security_groups.to_dict()
            elif isinstance(self.security_groups, list):
                props['SecurityGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.security_groups
                ]
            else:
                props['SecurityGroups'] = self.security_groups

        if self.jupyter_lab_app_settings is not None:
            if hasattr(self.jupyter_lab_app_settings, 'to_dict'):
                props['JupyterLabAppSettings'] = self.jupyter_lab_app_settings.to_dict()
            elif isinstance(self.jupyter_lab_app_settings, list):
                props['JupyterLabAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.jupyter_lab_app_settings
                ]
            else:
                props['JupyterLabAppSettings'] = self.jupyter_lab_app_settings

        if self.kernel_gateway_app_settings is not None:
            if hasattr(self.kernel_gateway_app_settings, 'to_dict'):
                props['KernelGatewayAppSettings'] = self.kernel_gateway_app_settings.to_dict()
            elif isinstance(self.kernel_gateway_app_settings, list):
                props['KernelGatewayAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.kernel_gateway_app_settings
                ]
            else:
                props['KernelGatewayAppSettings'] = self.kernel_gateway_app_settings

        if self.studio_web_portal_settings is not None:
            if hasattr(self.studio_web_portal_settings, 'to_dict'):
                props['StudioWebPortalSettings'] = self.studio_web_portal_settings.to_dict()
            elif isinstance(self.studio_web_portal_settings, list):
                props['StudioWebPortalSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.studio_web_portal_settings
                ]
            else:
                props['StudioWebPortalSettings'] = self.studio_web_portal_settings

        if self.custom_file_system_configs is not None:
            if hasattr(self.custom_file_system_configs, 'to_dict'):
                props['CustomFileSystemConfigs'] = self.custom_file_system_configs.to_dict()
            elif isinstance(self.custom_file_system_configs, list):
                props['CustomFileSystemConfigs'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_file_system_configs
                ]
            else:
                props['CustomFileSystemConfigs'] = self.custom_file_system_configs

        if self.custom_posix_user_config is not None:
            if hasattr(self.custom_posix_user_config, 'to_dict'):
                props['CustomPosixUserConfig'] = self.custom_posix_user_config.to_dict()
            elif isinstance(self.custom_posix_user_config, list):
                props['CustomPosixUserConfig'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.custom_posix_user_config
                ]
            else:
                props['CustomPosixUserConfig'] = self.custom_posix_user_config

        if self.code_editor_app_settings is not None:
            if hasattr(self.code_editor_app_settings, 'to_dict'):
                props['CodeEditorAppSettings'] = self.code_editor_app_settings.to_dict()
            elif isinstance(self.code_editor_app_settings, list):
                props['CodeEditorAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.code_editor_app_settings
                ]
            else:
                props['CodeEditorAppSettings'] = self.code_editor_app_settings

        if self.r_studio_server_pro_app_settings is not None:
            if hasattr(self.r_studio_server_pro_app_settings, 'to_dict'):
                props['RStudioServerProAppSettings'] = self.r_studio_server_pro_app_settings.to_dict()
            elif isinstance(self.r_studio_server_pro_app_settings, list):
                props['RStudioServerProAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.r_studio_server_pro_app_settings
                ]
            else:
                props['RStudioServerProAppSettings'] = self.r_studio_server_pro_app_settings

        if self.studio_web_portal is not None:
            if hasattr(self.studio_web_portal, 'to_dict'):
                props['StudioWebPortal'] = self.studio_web_portal.to_dict()
            elif isinstance(self.studio_web_portal, list):
                props['StudioWebPortal'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.studio_web_portal
                ]
            else:
                props['StudioWebPortal'] = self.studio_web_portal

        if self.jupyter_server_app_settings is not None:
            if hasattr(self.jupyter_server_app_settings, 'to_dict'):
                props['JupyterServerAppSettings'] = self.jupyter_server_app_settings.to_dict()
            elif isinstance(self.jupyter_server_app_settings, list):
                props['JupyterServerAppSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.jupyter_server_app_settings
                ]
            else:
                props['JupyterServerAppSettings'] = self.jupyter_server_app_settings

        if self.auto_mount_home_efs is not None:
            if hasattr(self.auto_mount_home_efs, 'to_dict'):
                props['AutoMountHomeEFS'] = self.auto_mount_home_efs.to_dict()
            elif isinstance(self.auto_mount_home_efs, list):
                props['AutoMountHomeEFS'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.auto_mount_home_efs
                ]
            else:
                props['AutoMountHomeEFS'] = self.auto_mount_home_efs

        if self.default_landing_uri is not None:
            if hasattr(self.default_landing_uri, 'to_dict'):
                props['DefaultLandingUri'] = self.default_landing_uri.to_dict()
            elif isinstance(self.default_landing_uri, list):
                props['DefaultLandingUri'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.default_landing_uri
                ]
            else:
                props['DefaultLandingUri'] = self.default_landing_uri

        if self.execution_role is not None:
            if hasattr(self.execution_role, 'to_dict'):
                props['ExecutionRole'] = self.execution_role.to_dict()
            elif isinstance(self.execution_role, list):
                props['ExecutionRole'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.execution_role
                ]
            else:
                props['ExecutionRole'] = self.execution_role

        if self.space_storage_settings is not None:
            if hasattr(self.space_storage_settings, 'to_dict'):
                props['SpaceStorageSettings'] = self.space_storage_settings.to_dict()
            elif isinstance(self.space_storage_settings, list):
                props['SpaceStorageSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.space_storage_settings
                ]
            else:
                props['SpaceStorageSettings'] = self.space_storage_settings

        if self.sharing_settings is not None:
            if hasattr(self.sharing_settings, 'to_dict'):
                props['SharingSettings'] = self.sharing_settings.to_dict()
            elif isinstance(self.sharing_settings, list):
                props['SharingSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.sharing_settings
                ]
            else:
                props['SharingSettings'] = self.sharing_settings

        return props


@dataclass
class UserProfile(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::UserProfile"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    domain_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    single_sign_on_user_value: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    user_settings: Optional[UserSettings] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    single_sign_on_user_identifier: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    user_profile_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.domain_id is not None:
            # Serialize domain_id (handle intrinsic functions)
            if hasattr(self.domain_id, 'to_dict'):
                props["DomainId"] = self.domain_id.to_dict()
            elif isinstance(self.domain_id, list):
                # Serialize list items (may contain intrinsic functions)
                props['DomainId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.domain_id
                ]
            else:
                props["DomainId"] = self.domain_id

        if self.single_sign_on_user_value is not None:
            # Serialize single_sign_on_user_value (handle intrinsic functions)
            if hasattr(self.single_sign_on_user_value, 'to_dict'):
                props["SingleSignOnUserValue"] = self.single_sign_on_user_value.to_dict()
            elif isinstance(self.single_sign_on_user_value, list):
                # Serialize list items (may contain intrinsic functions)
                props['SingleSignOnUserValue'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.single_sign_on_user_value
                ]
            else:
                props["SingleSignOnUserValue"] = self.single_sign_on_user_value

        if self.user_settings is not None:
            # Serialize user_settings (handle intrinsic functions)
            if hasattr(self.user_settings, 'to_dict'):
                props["UserSettings"] = self.user_settings.to_dict()
            elif isinstance(self.user_settings, list):
                # Serialize list items (may contain intrinsic functions)
                props['UserSettings'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_settings
                ]
            else:
                props["UserSettings"] = self.user_settings

        if self.single_sign_on_user_identifier is not None:
            # Serialize single_sign_on_user_identifier (handle intrinsic functions)
            if hasattr(self.single_sign_on_user_identifier, 'to_dict'):
                props["SingleSignOnUserIdentifier"] = self.single_sign_on_user_identifier.to_dict()
            elif isinstance(self.single_sign_on_user_identifier, list):
                # Serialize list items (may contain intrinsic functions)
                props['SingleSignOnUserIdentifier'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.single_sign_on_user_identifier
                ]
            else:
                props["SingleSignOnUserIdentifier"] = self.single_sign_on_user_identifier

        if self.user_profile_name is not None:
            # Serialize user_profile_name (handle intrinsic functions)
            if hasattr(self.user_profile_name, 'to_dict'):
                props["UserProfileName"] = self.user_profile_name.to_dict()
            elif isinstance(self.user_profile_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['UserProfileName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.user_profile_name
                ]
            else:
                props["UserProfileName"] = self.user_profile_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_user_profile_arn(self) -> GetAtt:
        """Get the UserProfileArn attribute."""
        return self.get_att("UserProfileArn")




@dataclass
class CognitoMemberDefinition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cognito_user_pool: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cognito_client_id: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cognito_user_group: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.cognito_user_pool is not None:
            if hasattr(self.cognito_user_pool, 'to_dict'):
                props['CognitoUserPool'] = self.cognito_user_pool.to_dict()
            elif isinstance(self.cognito_user_pool, list):
                props['CognitoUserPool'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cognito_user_pool
                ]
            else:
                props['CognitoUserPool'] = self.cognito_user_pool

        if self.cognito_client_id is not None:
            if hasattr(self.cognito_client_id, 'to_dict'):
                props['CognitoClientId'] = self.cognito_client_id.to_dict()
            elif isinstance(self.cognito_client_id, list):
                props['CognitoClientId'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cognito_client_id
                ]
            else:
                props['CognitoClientId'] = self.cognito_client_id

        if self.cognito_user_group is not None:
            if hasattr(self.cognito_user_group, 'to_dict'):
                props['CognitoUserGroup'] = self.cognito_user_group.to_dict()
            elif isinstance(self.cognito_user_group, list):
                props['CognitoUserGroup'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cognito_user_group
                ]
            else:
                props['CognitoUserGroup'] = self.cognito_user_group

        return props


@dataclass
class MemberDefinition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    oidc_member_definition: Optional[OidcMemberDefinition] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    cognito_member_definition: Optional[CognitoMemberDefinition] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.oidc_member_definition is not None:
            if hasattr(self.oidc_member_definition, 'to_dict'):
                props['OidcMemberDefinition'] = self.oidc_member_definition.to_dict()
            elif isinstance(self.oidc_member_definition, list):
                props['OidcMemberDefinition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.oidc_member_definition
                ]
            else:
                props['OidcMemberDefinition'] = self.oidc_member_definition

        if self.cognito_member_definition is not None:
            if hasattr(self.cognito_member_definition, 'to_dict'):
                props['CognitoMemberDefinition'] = self.cognito_member_definition.to_dict()
            elif isinstance(self.cognito_member_definition, list):
                props['CognitoMemberDefinition'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.cognito_member_definition
                ]
            else:
                props['CognitoMemberDefinition'] = self.cognito_member_definition

        return props


@dataclass
class NotificationConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    notification_topic_arn: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.notification_topic_arn is not None:
            if hasattr(self.notification_topic_arn, 'to_dict'):
                props['NotificationTopicArn'] = self.notification_topic_arn.to_dict()
            elif isinstance(self.notification_topic_arn, list):
                props['NotificationTopicArn'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_topic_arn
                ]
            else:
                props['NotificationTopicArn'] = self.notification_topic_arn

        return props


@dataclass
class OidcMemberDefinition:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-sag"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    oidc_groups: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.oidc_groups is not None:
            if hasattr(self.oidc_groups, 'to_dict'):
                props['OidcGroups'] = self.oidc_groups.to_dict()
            elif isinstance(self.oidc_groups, list):
                props['OidcGroups'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.oidc_groups
                ]
            else:
                props['OidcGroups'] = self.oidc_groups

        return props


@dataclass
class Workteam(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-sagem"""

    resource_type: ClassVar[str] = "AWS::SageMaker::Workteam"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    description: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    notification_configuration: Optional[NotificationConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    workteam_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    member_definitions: Optional[list[MemberDefinition]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    workforce_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.description is not None:
            # Serialize description (handle intrinsic functions)
            if hasattr(self.description, 'to_dict'):
                props["Description"] = self.description.to_dict()
            elif isinstance(self.description, list):
                # Serialize list items (may contain intrinsic functions)
                props['Description'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.description
                ]
            else:
                props["Description"] = self.description

        if self.notification_configuration is not None:
            # Serialize notification_configuration (handle intrinsic functions)
            if hasattr(self.notification_configuration, 'to_dict'):
                props["NotificationConfiguration"] = self.notification_configuration.to_dict()
            elif isinstance(self.notification_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['NotificationConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.notification_configuration
                ]
            else:
                props["NotificationConfiguration"] = self.notification_configuration

        if self.workteam_name is not None:
            # Serialize workteam_name (handle intrinsic functions)
            if hasattr(self.workteam_name, 'to_dict'):
                props["WorkteamName"] = self.workteam_name.to_dict()
            elif isinstance(self.workteam_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['WorkteamName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.workteam_name
                ]
            else:
                props["WorkteamName"] = self.workteam_name

        if self.member_definitions is not None:
            # Serialize member_definitions (handle intrinsic functions)
            if hasattr(self.member_definitions, 'to_dict'):
                props["MemberDefinitions"] = self.member_definitions.to_dict()
            elif isinstance(self.member_definitions, list):
                # Serialize list items (may contain intrinsic functions)
                props['MemberDefinitions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.member_definitions
                ]
            else:
                props["MemberDefinitions"] = self.member_definitions

        if self.workforce_name is not None:
            # Serialize workforce_name (handle intrinsic functions)
            if hasattr(self.workforce_name, 'to_dict'):
                props["WorkforceName"] = self.workforce_name.to_dict()
            elif isinstance(self.workforce_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['WorkforceName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.workforce_name
                ]
            else:
                props["WorkforceName"] = self.workforce_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        return props

    @property
    def attr_workteam_name(self) -> GetAtt:
        """Get the WorkteamName attribute."""
        return self.get_att("WorkteamName")



