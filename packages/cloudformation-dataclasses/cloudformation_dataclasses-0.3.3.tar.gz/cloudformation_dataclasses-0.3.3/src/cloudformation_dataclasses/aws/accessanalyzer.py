"""
AWS CloudFormation AccessAnalyzer Resources

⚠️  AUTO-GENERATED FILE - DO NOT EDIT MANUALLY ⚠️

This file is automatically generated from the AWS CloudFormation Resource Specification.
Any manual changes will be overwritten when regenerated.

Version Information:
  CloudFormation Spec: 2025.12.11
  Generator Version: 1.0.0
  Combined: spec-2025.12.11_gen-1.0.0
  Generated: 2025-12-17 16:59:34

To regenerate this file:
    uv run python -m cloudformation_dataclasses.codegen.generator --service AccessAnalyzer
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, ClassVar, Optional, Union

from cloudformation_dataclasses.core.base import CloudFormationResource
from cloudformation_dataclasses.intrinsics.functions import GetAtt, Ref, Sub


# =============================================================================
# Service Constants (auto-generated from botocore)
# =============================================================================

class AccessCheckPolicyType:
    """AccessCheckPolicyType enum values."""

    IDENTITY_POLICY = "IDENTITY_POLICY"
    RESOURCE_POLICY = "RESOURCE_POLICY"


class AccessCheckResourceType:
    """AccessCheckResourceType enum values."""

    AWS_DYNAMODB_TABLE = "AWS::DynamoDB::Table"
    AWS_DYNAMODB_STREAM = "AWS::DynamoDB::Stream"
    AWS_EFS_FILESYSTEM = "AWS::EFS::FileSystem"
    AWS_OPENSEARCHSERVICE_DOMAIN = "AWS::OpenSearchService::Domain"
    AWS_KINESIS_STREAM = "AWS::Kinesis::Stream"
    AWS_KINESIS_STREAMCONSUMER = "AWS::Kinesis::StreamConsumer"
    AWS_KMS_KEY = "AWS::KMS::Key"
    AWS_LAMBDA_FUNCTION = "AWS::Lambda::Function"
    AWS_S3_BUCKET = "AWS::S3::Bucket"
    AWS_S3_ACCESSPOINT = "AWS::S3::AccessPoint"
    AWS_S3EXPRESS_DIRECTORYBUCKET = "AWS::S3Express::DirectoryBucket"
    AWS_S3_GLACIER = "AWS::S3::Glacier"
    AWS_S3OUTPOSTS_BUCKET = "AWS::S3Outposts::Bucket"
    AWS_S3OUTPOSTS_ACCESSPOINT = "AWS::S3Outposts::AccessPoint"
    AWS_SECRETSMANAGER_SECRET = "AWS::SecretsManager::Secret"
    AWS_SNS_TOPIC = "AWS::SNS::Topic"
    AWS_SQS_QUEUE = "AWS::SQS::Queue"
    AWS_IAM_ASSUMEROLEPOLICYDOCUMENT = "AWS::IAM::AssumeRolePolicyDocument"
    AWS_S3TABLES_TABLEBUCKET = "AWS::S3Tables::TableBucket"
    AWS_APIGATEWAY_RESTAPI = "AWS::ApiGateway::RestApi"
    AWS_CODEARTIFACT_DOMAIN = "AWS::CodeArtifact::Domain"
    AWS_BACKUP_BACKUPVAULT = "AWS::Backup::BackupVault"
    AWS_CLOUDTRAIL_DASHBOARD = "AWS::CloudTrail::Dashboard"
    AWS_CLOUDTRAIL_EVENTDATASTORE = "AWS::CloudTrail::EventDataStore"
    AWS_S3TABLES_TABLE = "AWS::S3Tables::Table"
    AWS_S3EXPRESS_ACCESSPOINT = "AWS::S3Express::AccessPoint"


class AccessPreviewStatus:
    """AccessPreviewStatus enum values."""

    COMPLETED = "COMPLETED"
    CREATING = "CREATING"
    FAILED = "FAILED"


class AccessPreviewStatusReasonCode:
    """AccessPreviewStatusReasonCode enum values."""

    INTERNAL_ERROR = "INTERNAL_ERROR"
    INVALID_CONFIGURATION = "INVALID_CONFIGURATION"


class AclPermission:
    """AclPermission enum values."""

    READ = "READ"
    WRITE = "WRITE"
    READ_ACP = "READ_ACP"
    WRITE_ACP = "WRITE_ACP"
    FULL_CONTROL = "FULL_CONTROL"


class AnalyzerStatus:
    """AnalyzerStatus enum values."""

    ACTIVE = "ACTIVE"
    CREATING = "CREATING"
    DISABLED = "DISABLED"
    FAILED = "FAILED"


class CheckAccessNotGrantedResult:
    """CheckAccessNotGrantedResult enum values."""

    PASS = "PASS"
    FAIL = "FAIL"


class CheckNoNewAccessResult:
    """CheckNoNewAccessResult enum values."""

    PASS = "PASS"
    FAIL = "FAIL"


class CheckNoPublicAccessResult:
    """CheckNoPublicAccessResult enum values."""

    PASS = "PASS"
    FAIL = "FAIL"


class FindingChangeType:
    """FindingChangeType enum values."""

    CHANGED = "CHANGED"
    NEW = "NEW"
    UNCHANGED = "UNCHANGED"


class FindingSourceType:
    """FindingSourceType enum values."""

    POLICY = "POLICY"
    BUCKET_ACL = "BUCKET_ACL"
    S3_ACCESS_POINT = "S3_ACCESS_POINT"
    S3_ACCESS_POINT_ACCOUNT = "S3_ACCESS_POINT_ACCOUNT"


class FindingStatus:
    """FindingStatus enum values."""

    ACTIVE = "ACTIVE"
    ARCHIVED = "ARCHIVED"
    RESOLVED = "RESOLVED"


class FindingStatusUpdate:
    """FindingStatusUpdate enum values."""

    ACTIVE = "ACTIVE"
    ARCHIVED = "ARCHIVED"


class FindingType:
    """FindingType enum values."""

    EXTERNALACCESS = "ExternalAccess"
    UNUSEDIAMROLE = "UnusedIAMRole"
    UNUSEDIAMUSERACCESSKEY = "UnusedIAMUserAccessKey"
    UNUSEDIAMUSERPASSWORD = "UnusedIAMUserPassword"
    UNUSEDPERMISSION = "UnusedPermission"
    INTERNALACCESS = "InternalAccess"


class InternalAccessType:
    """InternalAccessType enum values."""

    INTRA_ACCOUNT = "INTRA_ACCOUNT"
    INTRA_ORG = "INTRA_ORG"


class JobErrorCode:
    """JobErrorCode enum values."""

    AUTHORIZATION_ERROR = "AUTHORIZATION_ERROR"
    RESOURCE_NOT_FOUND_ERROR = "RESOURCE_NOT_FOUND_ERROR"
    SERVICE_QUOTA_EXCEEDED_ERROR = "SERVICE_QUOTA_EXCEEDED_ERROR"
    SERVICE_ERROR = "SERVICE_ERROR"


class JobStatus:
    """JobStatus enum values."""

    IN_PROGRESS = "IN_PROGRESS"
    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    CANCELED = "CANCELED"


class KmsGrantOperation:
    """KmsGrantOperation enum values."""

    CREATEGRANT = "CreateGrant"
    DECRYPT = "Decrypt"
    DESCRIBEKEY = "DescribeKey"
    ENCRYPT = "Encrypt"
    GENERATEDATAKEY = "GenerateDataKey"
    GENERATEDATAKEYPAIR = "GenerateDataKeyPair"
    GENERATEDATAKEYPAIRWITHOUTPLAINTEXT = "GenerateDataKeyPairWithoutPlaintext"
    GENERATEDATAKEYWITHOUTPLAINTEXT = "GenerateDataKeyWithoutPlaintext"
    GETPUBLICKEY = "GetPublicKey"
    REENCRYPTFROM = "ReEncryptFrom"
    REENCRYPTTO = "ReEncryptTo"
    RETIREGRANT = "RetireGrant"
    SIGN = "Sign"
    VERIFY = "Verify"


class Locale:
    """Locale enum values."""

    DE = "DE"
    EN = "EN"
    ES = "ES"
    FR = "FR"
    IT = "IT"
    JA = "JA"
    KO = "KO"
    PT_BR = "PT_BR"
    ZH_CN = "ZH_CN"
    ZH_TW = "ZH_TW"


class OrderBy:
    """OrderBy enum values."""

    ASC = "ASC"
    DESC = "DESC"


class PolicyType:
    """PolicyType enum values."""

    IDENTITY_POLICY = "IDENTITY_POLICY"
    RESOURCE_POLICY = "RESOURCE_POLICY"
    SERVICE_CONTROL_POLICY = "SERVICE_CONTROL_POLICY"
    RESOURCE_CONTROL_POLICY = "RESOURCE_CONTROL_POLICY"


class PrincipalType:
    """PrincipalType enum values."""

    IAM_ROLE = "IAM_ROLE"
    IAM_USER = "IAM_USER"


class ReasonCode:
    """ReasonCode enum values."""

    AWS_SERVICE_ACCESS_DISABLED = "AWS_SERVICE_ACCESS_DISABLED"
    DELEGATED_ADMINISTRATOR_DEREGISTERED = "DELEGATED_ADMINISTRATOR_DEREGISTERED"
    ORGANIZATION_DELETED = "ORGANIZATION_DELETED"
    SERVICE_LINKED_ROLE_CREATION_FAILED = "SERVICE_LINKED_ROLE_CREATION_FAILED"


class RecommendationType:
    """RecommendationType enum values."""

    UNUSEDPERMISSIONRECOMMENDATION = "UnusedPermissionRecommendation"


class RecommendedRemediationAction:
    """RecommendedRemediationAction enum values."""

    CREATE_POLICY = "CREATE_POLICY"
    DETACH_POLICY = "DETACH_POLICY"


class ResourceControlPolicyRestriction:
    """ResourceControlPolicyRestriction enum values."""

    APPLICABLE = "APPLICABLE"
    FAILED_TO_EVALUATE_RCP = "FAILED_TO_EVALUATE_RCP"
    NOT_APPLICABLE = "NOT_APPLICABLE"
    APPLIED = "APPLIED"


class ResourceType:
    """ResourceType enum values."""

    AWS_S3_BUCKET = "AWS::S3::Bucket"
    AWS_IAM_ROLE = "AWS::IAM::Role"
    AWS_SQS_QUEUE = "AWS::SQS::Queue"
    AWS_LAMBDA_FUNCTION = "AWS::Lambda::Function"
    AWS_LAMBDA_LAYERVERSION = "AWS::Lambda::LayerVersion"
    AWS_KMS_KEY = "AWS::KMS::Key"
    AWS_SECRETSMANAGER_SECRET = "AWS::SecretsManager::Secret"
    AWS_EFS_FILESYSTEM = "AWS::EFS::FileSystem"
    AWS_EC2_SNAPSHOT = "AWS::EC2::Snapshot"
    AWS_ECR_REPOSITORY = "AWS::ECR::Repository"
    AWS_RDS_DBSNAPSHOT = "AWS::RDS::DBSnapshot"
    AWS_RDS_DBCLUSTERSNAPSHOT = "AWS::RDS::DBClusterSnapshot"
    AWS_SNS_TOPIC = "AWS::SNS::Topic"
    AWS_S3EXPRESS_DIRECTORYBUCKET = "AWS::S3Express::DirectoryBucket"
    AWS_DYNAMODB_TABLE = "AWS::DynamoDB::Table"
    AWS_DYNAMODB_STREAM = "AWS::DynamoDB::Stream"
    AWS_IAM_USER = "AWS::IAM::User"


class ServiceControlPolicyRestriction:
    """ServiceControlPolicyRestriction enum values."""

    APPLICABLE = "APPLICABLE"
    FAILED_TO_EVALUATE_SCP = "FAILED_TO_EVALUATE_SCP"
    NOT_APPLICABLE = "NOT_APPLICABLE"
    APPLIED = "APPLIED"


class Status:
    """Status enum values."""

    SUCCEEDED = "SUCCEEDED"
    FAILED = "FAILED"
    IN_PROGRESS = "IN_PROGRESS"


class Type:
    """Type enum values."""

    ACCOUNT = "ACCOUNT"
    ORGANIZATION = "ORGANIZATION"
    ACCOUNT_UNUSED_ACCESS = "ACCOUNT_UNUSED_ACCESS"
    ORGANIZATION_UNUSED_ACCESS = "ORGANIZATION_UNUSED_ACCESS"
    ACCOUNT_INTERNAL_ACCESS = "ACCOUNT_INTERNAL_ACCESS"
    ORGANIZATION_INTERNAL_ACCESS = "ORGANIZATION_INTERNAL_ACCESS"


class ValidatePolicyFindingType:
    """ValidatePolicyFindingType enum values."""

    ERROR = "ERROR"
    SECURITY_WARNING = "SECURITY_WARNING"
    SUGGESTION = "SUGGESTION"
    WARNING = "WARNING"


class ValidatePolicyResourceType:
    """ValidatePolicyResourceType enum values."""

    AWS_S3_BUCKET = "AWS::S3::Bucket"
    AWS_S3_ACCESSPOINT = "AWS::S3::AccessPoint"
    AWS_S3_MULTIREGIONACCESSPOINT = "AWS::S3::MultiRegionAccessPoint"
    AWS_S3OBJECTLAMBDA_ACCESSPOINT = "AWS::S3ObjectLambda::AccessPoint"
    AWS_IAM_ASSUMEROLEPOLICYDOCUMENT = "AWS::IAM::AssumeRolePolicyDocument"
    AWS_DYNAMODB_TABLE = "AWS::DynamoDB::Table"


class ValidationExceptionReason:
    """ValidationExceptionReason enum values."""

    UNKNOWNOPERATION = "unknownOperation"
    CANNOTPARSE = "cannotParse"
    FIELDVALIDATIONFAILED = "fieldValidationFailed"
    OTHER = "other"
    NOTSUPPORTED = "notSupported"


# Convenient aliases for enum values
IDENTITY_POLICY = AccessCheckPolicyType.IDENTITY_POLICY
RESOURCE_POLICY = AccessCheckPolicyType.RESOURCE_POLICY
AWS_DYNAMODB_TABLE = AccessCheckResourceType.AWS_DYNAMODB_TABLE
AWS_DYNAMODB_STREAM = AccessCheckResourceType.AWS_DYNAMODB_STREAM
AWS_EFS_FILESYSTEM = AccessCheckResourceType.AWS_EFS_FILESYSTEM
AWS_OPENSEARCHSERVICE_DOMAIN = AccessCheckResourceType.AWS_OPENSEARCHSERVICE_DOMAIN
AWS_KINESIS_STREAM = AccessCheckResourceType.AWS_KINESIS_STREAM
AWS_KINESIS_STREAMCONSUMER = AccessCheckResourceType.AWS_KINESIS_STREAMCONSUMER
AWS_KMS_KEY = AccessCheckResourceType.AWS_KMS_KEY
AWS_LAMBDA_FUNCTION = AccessCheckResourceType.AWS_LAMBDA_FUNCTION
AWS_S3_BUCKET = AccessCheckResourceType.AWS_S3_BUCKET
AWS_S3_ACCESSPOINT = AccessCheckResourceType.AWS_S3_ACCESSPOINT
AWS_S3EXPRESS_DIRECTORYBUCKET = AccessCheckResourceType.AWS_S3EXPRESS_DIRECTORYBUCKET
AWS_S3_GLACIER = AccessCheckResourceType.AWS_S3_GLACIER
AWS_S3OUTPOSTS_BUCKET = AccessCheckResourceType.AWS_S3OUTPOSTS_BUCKET
AWS_S3OUTPOSTS_ACCESSPOINT = AccessCheckResourceType.AWS_S3OUTPOSTS_ACCESSPOINT
AWS_SECRETSMANAGER_SECRET = AccessCheckResourceType.AWS_SECRETSMANAGER_SECRET
AWS_SNS_TOPIC = AccessCheckResourceType.AWS_SNS_TOPIC
AWS_SQS_QUEUE = AccessCheckResourceType.AWS_SQS_QUEUE
AWS_IAM_ASSUMEROLEPOLICYDOCUMENT = AccessCheckResourceType.AWS_IAM_ASSUMEROLEPOLICYDOCUMENT
AWS_S3TABLES_TABLEBUCKET = AccessCheckResourceType.AWS_S3TABLES_TABLEBUCKET
AWS_APIGATEWAY_RESTAPI = AccessCheckResourceType.AWS_APIGATEWAY_RESTAPI
AWS_CODEARTIFACT_DOMAIN = AccessCheckResourceType.AWS_CODEARTIFACT_DOMAIN
AWS_BACKUP_BACKUPVAULT = AccessCheckResourceType.AWS_BACKUP_BACKUPVAULT
AWS_CLOUDTRAIL_DASHBOARD = AccessCheckResourceType.AWS_CLOUDTRAIL_DASHBOARD
AWS_CLOUDTRAIL_EVENTDATASTORE = AccessCheckResourceType.AWS_CLOUDTRAIL_EVENTDATASTORE
AWS_S3TABLES_TABLE = AccessCheckResourceType.AWS_S3TABLES_TABLE
AWS_S3EXPRESS_ACCESSPOINT = AccessCheckResourceType.AWS_S3EXPRESS_ACCESSPOINT
COMPLETED = AccessPreviewStatus.COMPLETED
CREATING = AccessPreviewStatus.CREATING
FAILED = AccessPreviewStatus.FAILED
INTERNAL_ERROR = AccessPreviewStatusReasonCode.INTERNAL_ERROR
INVALID_CONFIGURATION = AccessPreviewStatusReasonCode.INVALID_CONFIGURATION
READ = AclPermission.READ
WRITE = AclPermission.WRITE
READ_ACP = AclPermission.READ_ACP
WRITE_ACP = AclPermission.WRITE_ACP
FULL_CONTROL = AclPermission.FULL_CONTROL
ACTIVE = AnalyzerStatus.ACTIVE
CREATING = AnalyzerStatus.CREATING
DISABLED = AnalyzerStatus.DISABLED
FAILED = AnalyzerStatus.FAILED
PASS = CheckAccessNotGrantedResult.PASS
FAIL = CheckAccessNotGrantedResult.FAIL
PASS = CheckNoNewAccessResult.PASS
FAIL = CheckNoNewAccessResult.FAIL
PASS = CheckNoPublicAccessResult.PASS
FAIL = CheckNoPublicAccessResult.FAIL
CHANGED = FindingChangeType.CHANGED
NEW = FindingChangeType.NEW
UNCHANGED = FindingChangeType.UNCHANGED
POLICY = FindingSourceType.POLICY
BUCKET_ACL = FindingSourceType.BUCKET_ACL
S3_ACCESS_POINT = FindingSourceType.S3_ACCESS_POINT
S3_ACCESS_POINT_ACCOUNT = FindingSourceType.S3_ACCESS_POINT_ACCOUNT
ACTIVE = FindingStatus.ACTIVE
ARCHIVED = FindingStatus.ARCHIVED
RESOLVED = FindingStatus.RESOLVED
ACTIVE = FindingStatusUpdate.ACTIVE
ARCHIVED = FindingStatusUpdate.ARCHIVED
EXTERNALACCESS = FindingType.EXTERNALACCESS
UNUSEDIAMROLE = FindingType.UNUSEDIAMROLE
UNUSEDIAMUSERACCESSKEY = FindingType.UNUSEDIAMUSERACCESSKEY
UNUSEDIAMUSERPASSWORD = FindingType.UNUSEDIAMUSERPASSWORD
UNUSEDPERMISSION = FindingType.UNUSEDPERMISSION
INTERNALACCESS = FindingType.INTERNALACCESS
INTRA_ACCOUNT = InternalAccessType.INTRA_ACCOUNT
INTRA_ORG = InternalAccessType.INTRA_ORG
AUTHORIZATION_ERROR = JobErrorCode.AUTHORIZATION_ERROR
RESOURCE_NOT_FOUND_ERROR = JobErrorCode.RESOURCE_NOT_FOUND_ERROR
SERVICE_QUOTA_EXCEEDED_ERROR = JobErrorCode.SERVICE_QUOTA_EXCEEDED_ERROR
SERVICE_ERROR = JobErrorCode.SERVICE_ERROR
IN_PROGRESS = JobStatus.IN_PROGRESS
SUCCEEDED = JobStatus.SUCCEEDED
FAILED = JobStatus.FAILED
CANCELED = JobStatus.CANCELED
CREATEGRANT = KmsGrantOperation.CREATEGRANT
DECRYPT = KmsGrantOperation.DECRYPT
DESCRIBEKEY = KmsGrantOperation.DESCRIBEKEY
ENCRYPT = KmsGrantOperation.ENCRYPT
GENERATEDATAKEY = KmsGrantOperation.GENERATEDATAKEY
GENERATEDATAKEYPAIR = KmsGrantOperation.GENERATEDATAKEYPAIR
GENERATEDATAKEYPAIRWITHOUTPLAINTEXT = KmsGrantOperation.GENERATEDATAKEYPAIRWITHOUTPLAINTEXT
GENERATEDATAKEYWITHOUTPLAINTEXT = KmsGrantOperation.GENERATEDATAKEYWITHOUTPLAINTEXT
GETPUBLICKEY = KmsGrantOperation.GETPUBLICKEY
REENCRYPTFROM = KmsGrantOperation.REENCRYPTFROM
REENCRYPTTO = KmsGrantOperation.REENCRYPTTO
RETIREGRANT = KmsGrantOperation.RETIREGRANT
SIGN = KmsGrantOperation.SIGN
VERIFY = KmsGrantOperation.VERIFY
DE = Locale.DE
EN = Locale.EN
ES = Locale.ES
FR = Locale.FR
IT = Locale.IT
JA = Locale.JA
KO = Locale.KO
PT_BR = Locale.PT_BR
ZH_CN = Locale.ZH_CN
ZH_TW = Locale.ZH_TW
ASC = OrderBy.ASC
DESC = OrderBy.DESC
IDENTITY_POLICY = PolicyType.IDENTITY_POLICY
RESOURCE_POLICY = PolicyType.RESOURCE_POLICY
SERVICE_CONTROL_POLICY = PolicyType.SERVICE_CONTROL_POLICY
RESOURCE_CONTROL_POLICY = PolicyType.RESOURCE_CONTROL_POLICY
IAM_ROLE = PrincipalType.IAM_ROLE
IAM_USER = PrincipalType.IAM_USER
AWS_SERVICE_ACCESS_DISABLED = ReasonCode.AWS_SERVICE_ACCESS_DISABLED
DELEGATED_ADMINISTRATOR_DEREGISTERED = ReasonCode.DELEGATED_ADMINISTRATOR_DEREGISTERED
ORGANIZATION_DELETED = ReasonCode.ORGANIZATION_DELETED
SERVICE_LINKED_ROLE_CREATION_FAILED = ReasonCode.SERVICE_LINKED_ROLE_CREATION_FAILED
UNUSEDPERMISSIONRECOMMENDATION = RecommendationType.UNUSEDPERMISSIONRECOMMENDATION
CREATE_POLICY = RecommendedRemediationAction.CREATE_POLICY
DETACH_POLICY = RecommendedRemediationAction.DETACH_POLICY
APPLICABLE = ResourceControlPolicyRestriction.APPLICABLE
FAILED_TO_EVALUATE_RCP = ResourceControlPolicyRestriction.FAILED_TO_EVALUATE_RCP
NOT_APPLICABLE = ResourceControlPolicyRestriction.NOT_APPLICABLE
APPLIED = ResourceControlPolicyRestriction.APPLIED
AWS_S3_BUCKET = ResourceType.AWS_S3_BUCKET
AWS_IAM_ROLE = ResourceType.AWS_IAM_ROLE
AWS_SQS_QUEUE = ResourceType.AWS_SQS_QUEUE
AWS_LAMBDA_FUNCTION = ResourceType.AWS_LAMBDA_FUNCTION
AWS_LAMBDA_LAYERVERSION = ResourceType.AWS_LAMBDA_LAYERVERSION
AWS_KMS_KEY = ResourceType.AWS_KMS_KEY
AWS_SECRETSMANAGER_SECRET = ResourceType.AWS_SECRETSMANAGER_SECRET
AWS_EFS_FILESYSTEM = ResourceType.AWS_EFS_FILESYSTEM
AWS_EC2_SNAPSHOT = ResourceType.AWS_EC2_SNAPSHOT
AWS_ECR_REPOSITORY = ResourceType.AWS_ECR_REPOSITORY
AWS_RDS_DBSNAPSHOT = ResourceType.AWS_RDS_DBSNAPSHOT
AWS_RDS_DBCLUSTERSNAPSHOT = ResourceType.AWS_RDS_DBCLUSTERSNAPSHOT
AWS_SNS_TOPIC = ResourceType.AWS_SNS_TOPIC
AWS_S3EXPRESS_DIRECTORYBUCKET = ResourceType.AWS_S3EXPRESS_DIRECTORYBUCKET
AWS_DYNAMODB_TABLE = ResourceType.AWS_DYNAMODB_TABLE
AWS_DYNAMODB_STREAM = ResourceType.AWS_DYNAMODB_STREAM
AWS_IAM_USER = ResourceType.AWS_IAM_USER
APPLICABLE = ServiceControlPolicyRestriction.APPLICABLE
FAILED_TO_EVALUATE_SCP = ServiceControlPolicyRestriction.FAILED_TO_EVALUATE_SCP
NOT_APPLICABLE = ServiceControlPolicyRestriction.NOT_APPLICABLE
APPLIED = ServiceControlPolicyRestriction.APPLIED
SUCCEEDED = Status.SUCCEEDED
FAILED = Status.FAILED
IN_PROGRESS = Status.IN_PROGRESS
ACCOUNT = Type.ACCOUNT
ORGANIZATION = Type.ORGANIZATION
ACCOUNT_UNUSED_ACCESS = Type.ACCOUNT_UNUSED_ACCESS
ORGANIZATION_UNUSED_ACCESS = Type.ORGANIZATION_UNUSED_ACCESS
ACCOUNT_INTERNAL_ACCESS = Type.ACCOUNT_INTERNAL_ACCESS
ORGANIZATION_INTERNAL_ACCESS = Type.ORGANIZATION_INTERNAL_ACCESS
ERROR = ValidatePolicyFindingType.ERROR
SECURITY_WARNING = ValidatePolicyFindingType.SECURITY_WARNING
SUGGESTION = ValidatePolicyFindingType.SUGGESTION
WARNING = ValidatePolicyFindingType.WARNING
AWS_S3_BUCKET = ValidatePolicyResourceType.AWS_S3_BUCKET
AWS_S3_ACCESSPOINT = ValidatePolicyResourceType.AWS_S3_ACCESSPOINT
AWS_S3_MULTIREGIONACCESSPOINT = ValidatePolicyResourceType.AWS_S3_MULTIREGIONACCESSPOINT
AWS_S3OBJECTLAMBDA_ACCESSPOINT = ValidatePolicyResourceType.AWS_S3OBJECTLAMBDA_ACCESSPOINT
AWS_IAM_ASSUMEROLEPOLICYDOCUMENT = ValidatePolicyResourceType.AWS_IAM_ASSUMEROLEPOLICYDOCUMENT
AWS_DYNAMODB_TABLE = ValidatePolicyResourceType.AWS_DYNAMODB_TABLE
UNKNOWNOPERATION = ValidationExceptionReason.UNKNOWNOPERATION
CANNOTPARSE = ValidationExceptionReason.CANNOTPARSE
FIELDVALIDATIONFAILED = ValidationExceptionReason.FIELDVALIDATIONFAILED
OTHER = ValidationExceptionReason.OTHER
NOTSUPPORTED = ValidationExceptionReason.NOTSUPPORTED


@dataclass
class AnalysisRule:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-acc"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    exclusions: Optional[list[AnalysisRuleCriteria]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.exclusions is not None:
            if hasattr(self.exclusions, 'to_dict'):
                props['Exclusions'] = self.exclusions.to_dict()
            elif isinstance(self.exclusions, list):
                props['Exclusions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.exclusions
                ]
            else:
                props['Exclusions'] = self.exclusions

        return props


@dataclass
class AnalysisRuleCriteria:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-acc"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    account_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_tags: Optional[Union[dict[str, Any], Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.account_ids is not None:
            if hasattr(self.account_ids, 'to_dict'):
                props['AccountIds'] = self.account_ids.to_dict()
            elif isinstance(self.account_ids, list):
                props['AccountIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.account_ids
                ]
            else:
                props['AccountIds'] = self.account_ids

        if self.resource_tags is not None:
            if hasattr(self.resource_tags, 'to_dict'):
                props['ResourceTags'] = self.resource_tags.to_dict()
            elif isinstance(self.resource_tags, list):
                props['ResourceTags'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_tags
                ]
            else:
                props['ResourceTags'] = self.resource_tags

        return props


@dataclass
class AnalyzerConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-acc"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    internal_access_configuration: Optional[InternalAccessConfiguration] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unused_access_configuration: Optional[UnusedAccessConfiguration] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.internal_access_configuration is not None:
            if hasattr(self.internal_access_configuration, 'to_dict'):
                props['InternalAccessConfiguration'] = self.internal_access_configuration.to_dict()
            elif isinstance(self.internal_access_configuration, list):
                props['InternalAccessConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internal_access_configuration
                ]
            else:
                props['InternalAccessConfiguration'] = self.internal_access_configuration

        if self.unused_access_configuration is not None:
            if hasattr(self.unused_access_configuration, 'to_dict'):
                props['UnusedAccessConfiguration'] = self.unused_access_configuration.to_dict()
            elif isinstance(self.unused_access_configuration, list):
                props['UnusedAccessConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unused_access_configuration
                ]
            else:
                props['UnusedAccessConfiguration'] = self.unused_access_configuration

        return props


@dataclass
class ArchiveRule:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-acc"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    filter: Optional[list[Filter]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    rule_name: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.filter is not None:
            if hasattr(self.filter, 'to_dict'):
                props['Filter'] = self.filter.to_dict()
            elif isinstance(self.filter, list):
                props['Filter'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.filter
                ]
            else:
                props['Filter'] = self.filter

        if self.rule_name is not None:
            if hasattr(self.rule_name, 'to_dict'):
                props['RuleName'] = self.rule_name.to_dict()
            elif isinstance(self.rule_name, list):
                props['RuleName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.rule_name
                ]
            else:
                props['RuleName'] = self.rule_name

        return props


@dataclass
class Filter:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-acc"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    exists: Optional[Union[bool, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    contains: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    neq: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    eq: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    property: Optional[Union[str, Ref, GetAtt, Sub]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.exists is not None:
            if hasattr(self.exists, 'to_dict'):
                props['Exists'] = self.exists.to_dict()
            elif isinstance(self.exists, list):
                props['Exists'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.exists
                ]
            else:
                props['Exists'] = self.exists

        if self.contains is not None:
            if hasattr(self.contains, 'to_dict'):
                props['Contains'] = self.contains.to_dict()
            elif isinstance(self.contains, list):
                props['Contains'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.contains
                ]
            else:
                props['Contains'] = self.contains

        if self.neq is not None:
            if hasattr(self.neq, 'to_dict'):
                props['Neq'] = self.neq.to_dict()
            elif isinstance(self.neq, list):
                props['Neq'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.neq
                ]
            else:
                props['Neq'] = self.neq

        if self.eq is not None:
            if hasattr(self.eq, 'to_dict'):
                props['Eq'] = self.eq.to_dict()
            elif isinstance(self.eq, list):
                props['Eq'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.eq
                ]
            else:
                props['Eq'] = self.eq

        if self.property is not None:
            if hasattr(self.property, 'to_dict'):
                props['Property'] = self.property.to_dict()
            elif isinstance(self.property, list):
                props['Property'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.property
                ]
            else:
                props['Property'] = self.property

        return props


@dataclass
class InternalAccessAnalysisRule:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-acc"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    inclusions: Optional[list[InternalAccessAnalysisRuleCriteria]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.inclusions is not None:
            if hasattr(self.inclusions, 'to_dict'):
                props['Inclusions'] = self.inclusions.to_dict()
            elif isinstance(self.inclusions, list):
                props['Inclusions'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.inclusions
                ]
            else:
                props['Inclusions'] = self.inclusions

        return props


@dataclass
class InternalAccessAnalysisRuleCriteria:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-acc"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_types: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    account_ids: Optional[Union[list[str], Ref]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    resource_arns: Optional[Union[list[str], Ref]] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.resource_types is not None:
            if hasattr(self.resource_types, 'to_dict'):
                props['ResourceTypes'] = self.resource_types.to_dict()
            elif isinstance(self.resource_types, list):
                props['ResourceTypes'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_types
                ]
            else:
                props['ResourceTypes'] = self.resource_types

        if self.account_ids is not None:
            if hasattr(self.account_ids, 'to_dict'):
                props['AccountIds'] = self.account_ids.to_dict()
            elif isinstance(self.account_ids, list):
                props['AccountIds'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.account_ids
                ]
            else:
                props['AccountIds'] = self.account_ids

        if self.resource_arns is not None:
            if hasattr(self.resource_arns, 'to_dict'):
                props['ResourceArns'] = self.resource_arns.to_dict()
            elif isinstance(self.resource_arns, list):
                props['ResourceArns'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.resource_arns
                ]
            else:
                props['ResourceArns'] = self.resource_arns

        return props


@dataclass
class InternalAccessConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-acc"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    internal_access_analysis_rule: Optional[InternalAccessAnalysisRule] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.internal_access_analysis_rule is not None:
            if hasattr(self.internal_access_analysis_rule, 'to_dict'):
                props['InternalAccessAnalysisRule'] = self.internal_access_analysis_rule.to_dict()
            elif isinstance(self.internal_access_analysis_rule, list):
                props['InternalAccessAnalysisRule'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.internal_access_analysis_rule
                ]
            else:
                props['InternalAccessAnalysisRule'] = self.internal_access_analysis_rule

        return props


@dataclass
class UnusedAccessConfiguration:
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-acc"""

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    unused_access_age: Optional[Union[int, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuid
    analysis_rule: Optional[AnalysisRule] = None

    def to_dict(self) -> dict[str, Any]:
        """Serialize to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.unused_access_age is not None:
            if hasattr(self.unused_access_age, 'to_dict'):
                props['UnusedAccessAge'] = self.unused_access_age.to_dict()
            elif isinstance(self.unused_access_age, list):
                props['UnusedAccessAge'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.unused_access_age
                ]
            else:
                props['UnusedAccessAge'] = self.unused_access_age

        if self.analysis_rule is not None:
            if hasattr(self.analysis_rule, 'to_dict'):
                props['AnalysisRule'] = self.analysis_rule.to_dict()
            elif isinstance(self.analysis_rule, list):
                props['AnalysisRule'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.analysis_rule
                ]
            else:
                props['AnalysisRule'] = self.analysis_rule

        return props


@dataclass
class Analyzer(CloudFormationResource):
    """http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-acces"""

    resource_type: ClassVar[str] = "AWS::AccessAnalyzer::Analyzer"

    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    archive_rules: Optional[list[ArchiveRule]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    type_: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    analyzer_name: Optional[Union[str, Ref, GetAtt, Sub]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    tags: Optional[list[Tag]] = None
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-reso
    analyzer_configuration: Optional[AnalyzerConfiguration] = None

    def _get_properties(self) -> dict[str, Any]:
        """Serialize resource properties to CloudFormation format."""
        props: dict[str, Any] = {}

        if self.archive_rules is not None:
            # Serialize archive_rules (handle intrinsic functions)
            if hasattr(self.archive_rules, 'to_dict'):
                props["ArchiveRules"] = self.archive_rules.to_dict()
            elif isinstance(self.archive_rules, list):
                # Serialize list items (may contain intrinsic functions)
                props['ArchiveRules'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.archive_rules
                ]
            else:
                props["ArchiveRules"] = self.archive_rules

        if self.type_ is not None:
            # Serialize type_ (handle intrinsic functions)
            if hasattr(self.type_, 'to_dict'):
                props["Type"] = self.type_.to_dict()
            elif isinstance(self.type_, list):
                # Serialize list items (may contain intrinsic functions)
                props['Type'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.type_
                ]
            else:
                props["Type"] = self.type_

        if self.analyzer_name is not None:
            # Serialize analyzer_name (handle intrinsic functions)
            if hasattr(self.analyzer_name, 'to_dict'):
                props["AnalyzerName"] = self.analyzer_name.to_dict()
            elif isinstance(self.analyzer_name, list):
                # Serialize list items (may contain intrinsic functions)
                props['AnalyzerName'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.analyzer_name
                ]
            else:
                props["AnalyzerName"] = self.analyzer_name

        # Serialize tags - use all_tags to include context tags
        merged_tags = self.all_tags
        if merged_tags:
            props['Tags'] = [
                item.to_dict() if hasattr(item, 'to_dict') else item
                for item in merged_tags
            ]

        if self.analyzer_configuration is not None:
            # Serialize analyzer_configuration (handle intrinsic functions)
            if hasattr(self.analyzer_configuration, 'to_dict'):
                props["AnalyzerConfiguration"] = self.analyzer_configuration.to_dict()
            elif isinstance(self.analyzer_configuration, list):
                # Serialize list items (may contain intrinsic functions)
                props['AnalyzerConfiguration'] = [
                    item.to_dict() if hasattr(item, 'to_dict') else item
                    for item in self.analyzer_configuration
                ]
            else:
                props["AnalyzerConfiguration"] = self.analyzer_configuration

        return props

    @property
    def attr_arn(self) -> GetAtt:
        """Get the Arn attribute."""
        return self.get_att("Arn")



